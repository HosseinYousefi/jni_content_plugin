// Autogenerated by jni_gen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_element

import "dart:ffi" as ffi;

import "package:jni/jni.dart" as jni;

import "package:content_plugin/android/content.dart" as content;

import "package:content_plugin/android/os.dart" as os;

import "app/assist.dart" as assist;

import "package:content_plugin/android/content/res.dart" as res;

import "package:content_plugin/android/content/pm.dart" as pm;
import "../init.dart" show jlookup;

/// An activity is a single, focused thing that the user can do.  Almost all
/// activities interact with the user, so the Activity class takes care of
/// creating a window for you in which you can place your UI with
/// \#setContentView.  While activities are often presented to the user
/// as full-screen windows, they can also be used in other ways: as floating
/// windows (via a theme with android.R.attr\#windowIsFloating set)
/// or embedded inside of another activity (using ActivityGroup).
///
/// There are two methods almost all subclasses of Activity will implement:
///
/// <ul>
///     <li> \#onCreate is where you initialize your activity.  Most
///     importantly, here you will usually call \#setContentView(int)
///     with a layout resource defining your UI, and using \#findViewById
///     to retrieve the widgets in that UI that you need to interact with
///     programmatically.
///
///     <li> \#onPause is where you deal with the user leaving your
///     activity.  Most importantly, any changes made by the user should at this
///     point be committed (usually to the
///     android.content.ContentProvider holding the data).
/// </ul>
///
/// To be of use with android.content.Context\#startActivity Context.startActivity(), all
/// activity classes must have a corresponding
/// android.R.styleable\#AndroidManifestActivity &lt;activity&gt;
/// declaration in their package's <code>AndroidManifest.xml</code>.
///
///
/// Topics covered here:
/// <ol>
/// <li><a href="\#Fragments">Fragments</a>
/// <li><a href="\#ActivityLifecycle">Activity Lifecycle</a>
/// <li><a href="\#ConfigurationChanges">Configuration Changes</a>
/// <li><a href="\#StartingActivities">Starting Activities and Getting Results</a>
/// <li><a href="\#SavingPersistentState">Saving Persistent State</a>
/// <li><a href="\#Permissions">Permissions</a>
/// <li><a href="\#ProcessLifecycle">Process Lifecycle</a>
/// </ol>
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// The Activity class is an important part of an application's overall lifecycle,
/// and the way activities are launched and put together is a fundamental
/// part of the platform's application model. For a detailed perspective on the structure of an
/// Android application and how activities behave, please read the
/// <a href="{@docRoot}guide/topics/fundamentals.html">Application Fundamentals</a> and
/// <a href="{@docRoot}guide/components/tasks-and-back-stack.html">Tasks and Back Stack</a>
/// developer guides.
///
///
/// You can also find a detailed discussion about how to create activities in the
/// <a href="{@docRoot}guide/components/activities.html">Activities</a>
/// developer guide.
///
/// </div>
///
/// <a name="Fragments"></a>
/// <h3>Fragments</h3>
///
/// The android.support.v4.app.FragmentActivity subclass
/// can make use of the android.support.v4.app.Fragment class to better
/// modularize their code, build more sophisticated user interfaces for larger
/// screens, and help scale their application between small and large screens.
///
///
/// For more information about using fragments, read the
/// <a href="{@docRoot}guide/components/fragments.html">Fragments</a> developer guide.
///
///
/// <a name="ActivityLifecycle"></a>
/// <h3>Activity Lifecycle</h3>
///
/// Activities in the system are managed as an _activity stack_.
/// When a new activity is started, it is placed on the top of the stack
/// and becomes the running activity -- the previous activity always remains
/// below it in the stack, and will not come to the foreground again until
/// the new activity exits.
///
///
/// An activity has essentially four states:
///
/// <ul>
///     <li> If an activity is in the foreground of the screen (at the top of
///         the stack),
///         it is _active_ or  _running_. </li>
///     <li>If an activity has lost focus but is still visible (that is, a new non-full-sized
///         or transparent activity has focus on top of your activity), it
///         is _paused_. A paused activity is completely alive (it
///         maintains all state and member information and remains attached to
///         the window manager), but can be killed by the system in extreme
///         low memory situations.
///     <li>If an activity is completely obscured by another activity,
///         it is _stopped_. It still retains all state and member information,
///         however, it is no longer visible to the user so its window is hidden
///         and it will often be killed by the system when memory is needed
///         elsewhere.</li>
///     <li>If an activity is paused or stopped, the system can drop the activity
///         from memory by either asking it to finish, or simply killing its
///         process.  When it is displayed again to the user, it must be
///         completely restarted and restored to its previous state.</li>
/// </ul>
///
/// The following diagram shows the important state paths of an Activity.
/// The square rectangles represent callback methods you can implement to
/// perform operations when the Activity moves between states.  The colored
/// ovals are major states the Activity can be in.
///
///
/// <img src="../../../images/activity_lifecycle.png" alt="State diagram for an Android Activity Lifecycle." border="0"/>
///
///
/// There are three key loops you may be interested in monitoring within your
/// activity:
///
/// <ul>
/// <li>The __entire lifetime__ of an activity happens between the first call
/// to android.app.Activity\#onCreate through to a single final call
/// to android.app.Activity\#onDestroy.  An activity will do all setup
/// of "global" state in onCreate(), and release all remaining resources in
/// onDestroy().  For example, if it has a thread running in the background
/// to download data from the network, it may create that thread in onCreate()
/// and then stop the thread in onDestroy().
///
/// <li>The __visible lifetime__ of an activity happens between a call to
/// android.app.Activity\#onStart until a corresponding call to
/// android.app.Activity\#onStop.  During this time the user can see the
/// activity on-screen, though it may not be in the foreground and interacting
/// with the user.  Between these two methods you can maintain resources that
/// are needed to show the activity to the user.  For example, you can register
/// a android.content.BroadcastReceiver in onStart() to monitor for changes
/// that impact your UI, and unregister it in onStop() when the user no
/// longer sees what you are displaying.  The onStart() and onStop() methods
/// can be called multiple times, as the activity becomes visible and hidden
/// to the user.
///
/// <li>The __foreground lifetime__ of an activity happens between a call to
/// android.app.Activity\#onResume until a corresponding call to
/// android.app.Activity\#onPause.  During this time the activity is
/// in front of all other activities and interacting with the user.  An activity
/// can frequently go between the resumed and paused states -- for example when
/// the device goes to sleep, when an activity result is delivered, when a new
/// intent is delivered -- so the code in these methods should be fairly
/// lightweight.
/// </ul>
///
/// The entire lifecycle of an activity is defined by the following
/// Activity methods.  All of these are hooks that you can override
/// to do appropriate work when the activity changes state.  All
/// activities will implement android.app.Activity\#onCreate
/// to do their initial setup; many will also implement
/// android.app.Activity\#onPause to commit changes to data and
/// otherwise prepare to stop interacting with the user.  You should always
/// call up to your superclass when implementing these methods.
///
///
///
///
/// <pre class="prettyprint">
/// public class Activity extends ApplicationContext {
///     protected void onCreate(Bundle savedInstanceState);
///
///     protected void onStart();
///
///     protected void onRestart();
///
///     protected void onResume();
///
///     protected void onPause();
///
///     protected void onStop();
///
///     protected void onDestroy();
/// }
/// </pre>
///
/// In general the movement through an activity's lifecycle looks like
/// this:
///
///
/// <table border="2" width="85%" align="center" frame="hsides" rules="rows">
///     <colgroup align="left" span="3"/>
///     <colgroup align="left"/>
///     <colgroup align="center"/>
///     <colgroup align="center"/>
///
///     <thead>
///     <tr><th colspan="3">Method</th> <th>Description</th> <th>Killable?</th> <th>Next</th></tr>
///     </thead>
///
///     <tbody>
///     <tr><td colspan="3" align="left" border="0">android.app.Activity\#onCreate onCreate()</td>
///         <td>Called when the activity is first created.
///             This is where you should do all of your normal static set up:
///             create views, bind data to lists, etc.  This method also
///             provides you with a Bundle containing the activity's previously
///             frozen state, if there was one.
///             Always followed by <code>onStart()</code>.</td>
///         <td align="center">No</td>
///         <td align="center"><code>onStart()</code></td>
///     </tr>
///
///     <tr><td rowspan="5" style="border-left: none; border-right: none;">&nbsp;&nbsp;&nbsp;&nbsp;</td>
///         <td colspan="2" align="left" border="0">android.app.Activity\#onRestart onRestart()</td>
///         <td>Called after your activity has been stopped, prior to it being
///             started again.
///             Always followed by <code>onStart()</code></td>
///         <td align="center">No</td>
///         <td align="center"><code>onStart()</code></td>
///     </tr>
///
///     <tr><td colspan="2" align="left" border="0">android.app.Activity\#onStart onStart()</td>
///         <td>Called when the activity is becoming visible to the user.
///             Followed by <code>onResume()</code> if the activity comes
///             to the foreground, or <code>onStop()</code> if it becomes hidden.</td>
///         <td align="center">No</td>
///         <td align="center"><code>onResume()</code> or <code>onStop()</code></td>
///     </tr>
///
///     <tr><td rowspan="2" style="border-left: none;">&nbsp;&nbsp;&nbsp;&nbsp;</td>
///         <td align="left" border="0">android.app.Activity\#onResume onResume()</td>
///         <td>Called when the activity will start
///             interacting with the user.  At this point your activity is at
///             the top of the activity stack, with user input going to it.
///             Always followed by <code>onPause()</code>.</td>
///         <td align="center">No</td>
///         <td align="center"><code>onPause()</code></td>
///     </tr>
///
///     <tr><td align="left" border="0">android.app.Activity\#onPause onPause()</td>
///         <td>Called when the system is about to start resuming a previous
///             activity.  This is typically used to commit unsaved changes to
///             persistent data, stop animations and other things that may be consuming
///             CPU, etc.  Implementations of this method must be very quick because
///             the next activity will not be resumed until this method returns.
///             Followed by either <code>onResume()</code> if the activity
///             returns back to the front, or <code>onStop()</code> if it becomes
///             invisible to the user.</td>
///         <td align="center"><font color="\#800000"><strong>Pre-android.os.Build.VERSION_CODES\#HONEYCOMB</strong></font></td>
///         <td align="center"><code>onResume()</code> or<br>
///                 <code>onStop()</code></td>
///     </tr>
///
///     <tr><td colspan="2" align="left" border="0">android.app.Activity\#onStop onStop()</td>
///         <td>Called when the activity is no longer visible to the user, because
///             another activity has been resumed and is covering this one.  This
///             may happen either because a new activity is being started, an existing
///             one is being brought in front of this one, or this one is being
///             destroyed.
///             Followed by either <code>onRestart()</code> if
///             this activity is coming back to interact with the user, or
///             <code>onDestroy()</code> if this activity is going away.</td>
///         <td align="center"><font color="\#800000"><strong>Yes</strong></font></td>
///         <td align="center"><code>onRestart()</code> or<br>
///                 <code>onDestroy()</code></td>
///     </tr>
///
///     <tr><td colspan="3" align="left" border="0">android.app.Activity\#onDestroy onDestroy()</td>
///         <td>The final call you receive before your
///             activity is destroyed.  This can happen either because the
///             activity is finishing (someone called Activity\#finish on
///             it, or because the system is temporarily destroying this
///             instance of the activity to save space.  You can distinguish
///             between these two scenarios with the Activity\#isFinishing method.</td>
///         <td align="center"><font color="\#800000"><strong>Yes</strong></font></td>
///         <td align="center">_nothing_</td>
///     </tr>
///     </tbody>
/// </table>
///
/// Note the "Killable" column in the above table -- for those methods that
/// are marked as being killable, after that method returns the process hosting the
/// activity may be killed by the system _at any time_ without another line
/// of its code being executed.  Because of this, you should use the
/// \#onPause method to write any persistent data (such as user edits)
/// to storage.  In addition, the method
/// \#onSaveInstanceState(Bundle) is called before placing the activity
/// in such a background state, allowing you to save away any dynamic instance
/// state in your activity into the given Bundle, to be later received in
/// \#onCreate if the activity needs to be re-created.
/// See the <a href="\#ProcessLifecycle">Process Lifecycle</a>
/// section for more information on how the lifecycle of a process is tied
/// to the activities it is hosting.  Note that it is important to save
/// persistent data in \#onPause instead of \#onSaveInstanceState
/// because the latter is not part of the lifecycle callbacks, so will not
/// be called in every situation as described in its documentation.
///
///
/// <p class="note">Be aware that these semantics will change slightly between
/// applications targeting platforms starting with android.os.Build.VERSION_CODES\#HONEYCOMB
/// vs. those targeting prior platforms.  Starting with Honeycomb, an application
/// is not in the killable state until its \#onStop has returned.  This
/// impacts when \#onSaveInstanceState(Bundle) may be called (it may be
/// safely called after \#onPause()) and allows an application to safely
/// wait until \#onStop() to save persistent state.
///
///
/// <p class="note">For applications targeting platforms starting with
/// android.os.Build.VERSION_CODES\#P \#onSaveInstanceState(Bundle)
/// will always be called after \#onStop, so an application may safely
/// perform fragment transactions in \#onStop and will be able to save
/// persistent state later.
///
///
/// For those methods that are not marked as being killable, the activity's
/// process will not be killed by the system starting from the time the method
/// is called and continuing after it returns.  Thus an activity is in the killable
/// state, for example, between after <code>onPause()</code> to the start of
/// <code>onResume()</code>.
///
///
/// <a name="ConfigurationChanges"></a>
/// <h3>Configuration Changes</h3>
///
/// If the configuration of the device (as defined by the
/// Configuration Resources.Configuration class) changes,
/// then anything displaying a user interface will need to update to match that
/// configuration.  Because Activity is the primary mechanism for interacting
/// with the user, it includes special support for handling configuration
/// changes.
///
///
/// Unless you specify otherwise, a configuration change (such as a change
/// in screen orientation, language, input devices, etc) will cause your
/// current activity to be _destroyed_, going through the normal activity
/// lifecycle process of \#onPause,
/// \#onStop, and \#onDestroy as appropriate.  If the activity
/// had been in the foreground or visible to the user, once \#onDestroy is
/// called in that instance then a new instance of the activity will be
/// created, with whatever savedInstanceState the previous instance had generated
/// from \#onSaveInstanceState.
///
///
/// This is done because any application resource,
/// including layout files, can change based on any configuration value.  Thus
/// the only safe way to handle a configuration change is to re-retrieve all
/// resources, including layouts, drawables, and strings.  Because activities
/// must already know how to save their state and re-create themselves from
/// that state, this is a convenient way to have an activity restart itself
/// with a new configuration.
///
///
/// In some special cases, you may want to bypass restarting of your
/// activity based on one or more types of configuration changes.  This is
/// done with the android.R.attr\#configChanges android:configChanges
/// attribute in its manifest.  For any types of configuration changes you say
/// that you handle there, you will receive a call to your current activity's
/// \#onConfigurationChanged method instead of being restarted.  If
/// a configuration change involves any that you do not handle, however, the
/// activity will still be restarted and \#onConfigurationChanged
/// will not be called.
///
///
/// <a name="StartingActivities"></a>
/// <h3>Starting Activities and Getting Results</h3>
///
/// The android.app.Activity\#startActivity
/// method is used to start a
/// new activity, which will be placed at the top of the activity stack.  It
/// takes a single argument, an android.content.Intent Intent,
/// which describes the activity
/// to be executed.
///
///
/// Sometimes you want to get a result back from an activity when it
/// ends.  For example, you may start an activity that lets the user pick
/// a person in a list of contacts; when it ends, it returns the person
/// that was selected.  To do this, you call the
/// android.app.Activity\#startActivityForResult(Intent, int)
/// version with a second integer parameter identifying the call.  The result
/// will come back through your android.app.Activity\#onActivityResult
/// method.
///
///
/// When an activity exits, it can call
/// android.app.Activity\#setResult(int)
/// to return data back to its parent.  It must always supply a result code,
/// which can be the standard results RESULT_CANCELED, RESULT_OK, or any
/// custom values starting at RESULT_FIRST_USER.  In addition, it can optionally
/// return back an Intent containing any additional data it wants.  All of this
/// information appears back on the
/// parent's <code>Activity.onActivityResult()</code>, along with the integer
/// identifier it originally supplied.
///
///
/// If a child activity fails for any reason (such as crashing), the parent
/// activity will receive a result with the code RESULT_CANCELED.
///
///
/// <pre class="prettyprint">
/// public class MyActivity extends Activity {
///     ...
///
///     static final int PICK_CONTACT_REQUEST = 0;
///
///     public boolean onKeyDown(int keyCode, KeyEvent event) {
///         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
///             // When the user center presses, let them pick a contact.
///             startActivityForResult(
///                 new Intent(Intent.ACTION_PICK,
///                 new Uri("content://contacts")),
///                 PICK_CONTACT_REQUEST);
///            return true;
///         }
///         return false;
///     }
///
///     protected void onActivityResult(int requestCode, int resultCode,
///             Intent data) {
///         if (requestCode == PICK_CONTACT_REQUEST) {
///             if (resultCode == RESULT_OK) {
///                 // A contact was picked.  Here we will just display it
///                 // to the user.
///                 startActivity(new Intent(Intent.ACTION_VIEW, data));
///             }
///         }
///     }
/// }
/// </pre>
///
/// <a name="SavingPersistentState"></a>
/// <h3>Saving Persistent State</h3>
///
/// There are generally two kinds of persistent state than an activity
/// will deal with: shared document-like data (typically stored in a SQLite
/// database using a {@linkplain android.content.ContentProvider content provider})
/// and internal state such as user preferences.
///
///
/// For content provider data, we suggest that activities use a
/// "edit in place" user model.  That is, any edits a user makes are effectively
/// made immediately without requiring an additional confirmation step.
/// Supporting this model is generally a simple matter of following two rules:
///
///
/// <ul>
///     <li> When creating a new document, the backing database entry or file for
///             it is created immediately.  For example, if the user chooses to write
///             a new email, a new entry for that email is created as soon as they
///             start entering data, so that if they go to any other activity after
///             that point this email will now appear in the list of drafts.
///
///     <li> When an activity's <code>onPause()</code> method is called, it should
///             commit to the backing content provider or file any changes the user
///             has made.  This ensures that those changes will be seen by any other
///             activity that is about to run.  You will probably want to commit
///             your data even more aggressively at key times during your
///             activity's lifecycle: for example before starting a new
///             activity, before finishing your own activity, when the user
///             switches between input fields, etc.
///
/// </ul>
///
/// This model is designed to prevent data loss when a user is navigating
/// between activities, and allows the system to safely kill an activity (because
/// system resources are needed somewhere else) at any time after it has been
/// paused.  Note this implies
/// that the user pressing BACK from your activity does _not_
/// mean "cancel" -- it means to leave the activity with its current contents
/// saved away.  Canceling edits in an activity must be provided through
/// some other mechanism, such as an explicit "revert" or "undo" option.
///
///
/// See the {@linkplain android.content.ContentProvider content package} for
/// more information about content providers.  These are a key aspect of how
/// different activities invoke and propagate data between themselves.
///
///
/// The Activity class also provides an API for managing internal persistent state
/// associated with an activity.  This can be used, for example, to remember
/// the user's preferred initial display in a calendar (day view or week view)
/// or the user's default home page in a web browser.
///
///
/// Activity persistent state is managed
/// with the method \#getPreferences,
/// allowing you to retrieve and
/// modify a set of name/value pairs associated with the activity.  To use
/// preferences that are shared across multiple application components
/// (activities, receivers, services, providers), you can use the underlying
/// Context\#getSharedPreferences Context.getSharedPreferences() method
/// to retrieve a preferences
/// object stored under a specific name.
/// (Note that it is not possible to share settings data across application
/// packages -- for that you will need a content provider.)
///
///
/// Here is an excerpt from a calendar activity that stores the user's
/// preferred view mode in its persistent settings:
///
///
/// <pre class="prettyprint">
/// public class CalendarActivity extends Activity {
///     ...
///
///     static final int DAY_VIEW_MODE = 0;
///     static final int WEEK_VIEW_MODE = 1;
///
///     private SharedPreferences mPrefs;
///     private int mCurViewMode;
///
///     protected void onCreate(Bundle savedInstanceState) {
///         super.onCreate(savedInstanceState);
///
///         SharedPreferences mPrefs = getSharedPreferences();
///         mCurViewMode = mPrefs.getInt("view_mode", DAY_VIEW_MODE);
///     }
///
///     protected void onPause() {
///         super.onPause();
///
///         SharedPreferences.Editor ed = mPrefs.edit();
///         ed.putInt("view_mode", mCurViewMode);
///         ed.commit();
///     }
/// }
/// </pre>
///
/// <a name="Permissions"></a>
/// <h3>Permissions</h3>
///
/// The ability to start a particular Activity can be enforced when it is
/// declared in its
/// manifest's android.R.styleable\#AndroidManifestActivity &lt;activity&gt;
/// tag.  By doing so, other applications will need to declare a corresponding
/// android.R.styleable\#AndroidManifestUsesPermission &lt;uses-permission&gt;
/// element in their own manifest to be able to start that activity.
///
/// When starting an Activity you can set Intent\#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION and/or Intent\#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION on the Intent.  This will grant the
/// Activity access to the specific URIs in the Intent.  Access will remain
/// until the Activity has finished (it will remain across the hosting
/// process being killed and other temporary destruction).  As of
/// android.os.Build.VERSION_CODES\#GINGERBREAD, if the Activity
/// was already created and a new Intent is being delivered to
/// \#onNewIntent(Intent), any newly granted URI permissions will be added
/// to the existing ones it holds.
///
/// See the <a href="{@docRoot}guide/topics/security/security.html">Security and Permissions</a>
/// document for more information on permissions and security in general.
///
/// <a name="ProcessLifecycle"></a>
/// <h3>Process Lifecycle</h3>
///
/// The Android system attempts to keep an application process around for as
/// long as possible, but eventually will need to remove old processes when
/// memory runs low. As described in <a href="\#ActivityLifecycle">Activity
/// Lifecycle</a>, the decision about which process to remove is intimately
/// tied to the state of the user's interaction with it. In general, there
/// are four states a process can be in based on the activities running in it,
/// listed here in order of importance. The system will kill less important
/// processes (the last ones) before it resorts to killing more important
/// processes (the first ones).
///
/// <ol>
/// <li> The __foreground activity__ (the activity at the top of the screen
/// that the user is currently interacting with) is considered the most important.
/// Its process will only be killed as a last resort, if it uses more memory
/// than is available on the device.  Generally at this point the device has
/// reached a memory paging state, so this is required in order to keep the user
/// interface responsive.
/// <li> A __visible activity__ (an activity that is visible to the user
/// but not in the foreground, such as one sitting behind a foreground dialog)
/// is considered extremely important and will not be killed unless that is
/// required to keep the foreground activity running.
/// <li> A __background activity__ (an activity that is not visible to
/// the user and has been paused) is no longer critical, so the system may
/// safely kill its process to reclaim memory for other foreground or
/// visible processes.  If its process needs to be killed, when the user navigates
/// back to the activity (making it visible on the screen again), its
/// \#onCreate method will be called with the savedInstanceState it had previously
/// supplied in \#onSaveInstanceState so that it can restart itself in the same
/// state as the user last left it.
/// <li> An __empty process__ is one hosting no activities or other
/// application components (such as Service or
/// android.content.BroadcastReceiver classes).  These are killed very
/// quickly by the system as memory becomes low.  For this reason, any
/// background operation you do outside of an activity must be executed in the
/// context of an activity BroadcastReceiver or Service to ensure that the system
/// knows it needs to keep your process around.
/// </ol>
///
/// Sometimes an Activity may need to do a long-running operation that exists
/// independently of the activity lifecycle itself.  An example may be a camera
/// application that allows you to upload a picture to a web site.  The upload
/// may take a long time, and the application should allow the user to leave
/// the application while it is executing.  To accomplish this, your Activity
/// should start a Service in which the upload takes place.  This allows
/// the system to properly prioritize your process (considering it to be more
/// important than other non-visible applications) for the duration of the
/// upload, independent of whether the original activity is paused, stopped,
/// or finished.
class Activity extends jni.JlObject {
  Activity.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int DEFAULT_KEYS_DIALER
  /// Use with \#setDefaultKeyMode to launch the dialer during default
  /// key handling.
  ///@see \#setDefaultKeyMode
  static const DEFAULT_KEYS_DIALER = 1;

  /// from: static public final int DEFAULT_KEYS_DISABLE
  /// Use with \#setDefaultKeyMode to turn off default handling of
  /// keys.
  ///@see \#setDefaultKeyMode
  static const DEFAULT_KEYS_DISABLE = 0;

  /// from: static public final int DEFAULT_KEYS_SEARCH_GLOBAL
  /// Use with \#setDefaultKeyMode to specify that unhandled keystrokes
  /// will start a global search (typically web search, but some platforms may define alternate
  /// methods for global search)
  ///
  /// See android.app.SearchManager android.app.SearchManager for more details.
  ///@see \#setDefaultKeyMode
  static const DEFAULT_KEYS_SEARCH_GLOBAL = 4;

  /// from: static public final int DEFAULT_KEYS_SEARCH_LOCAL
  /// Use with \#setDefaultKeyMode to specify that unhandled keystrokes
  /// will start an application-defined search.  (If the application or activity does not
  /// actually define a search, the the keys will be ignored.)
  ///
  /// See android.app.SearchManager android.app.SearchManager for more details.
  ///@see \#setDefaultKeyMode
  static const DEFAULT_KEYS_SEARCH_LOCAL = 3;

  /// from: static public final int DEFAULT_KEYS_SHORTCUT
  /// Use with \#setDefaultKeyMode to execute a menu shortcut in
  /// default key handling.
  ///
  /// That is, the user does not need to hold down the menu key to execute menu shortcuts.
  ///@see \#setDefaultKeyMode
  static const DEFAULT_KEYS_SHORTCUT = 2;

  /// from: static protected final int[] FOCUSED_STATE_SET
  static final _getFOCUSED_STATE_SET =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_Activity_FOCUSED_STATE_SET")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlObject get FOCUSED_STATE_SET =>
      jni.JlObject.fromRef(_getFOCUSED_STATE_SET());

  /// from: static public final int RESULT_CANCELED
  /// Standard activity result: operation canceled.
  static const RESULT_CANCELED = 0;

  /// from: static public final int RESULT_FIRST_USER
  /// Start of user-defined activity results.
  static const RESULT_FIRST_USER = 1;

  /// from: static public final int RESULT_OK
  /// Standard activity result: operation succeeded.
  static const RESULT_OK = -1;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Activity_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Activity() : super.fromRef(_ctor());

  static final _getIntent = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_getIntent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent getIntent()
  /// Return the intent that started this activity.
  content.Intent getIntent() => content.Intent.fromRef(_getIntent(reference));

  static final _setIntent = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_setIntent")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setIntent(android.content.Intent newIntent)
  /// Change the intent returned by \#getIntent.  This holds a
  /// reference to the given intent; it does not copy it.  Often used in
  /// conjunction with \#onNewIntent.
  ///@param newIntent The new Intent object to return from getIntent
  ///@see \#getIntent
  ///@see \#onNewIntent
  void setIntent(content.Intent newIntent) =>
      _setIntent(reference, newIntent.reference);

  static final _getApplication = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getApplication")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Application getApplication()
  /// Return the application that owns this activity.
  Application getApplication() =>
      Application.fromRef(_getApplication(reference));

  static final _isChild =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_isChild")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isChild()
  /// Is this activity embedded inside of another activity?
  bool isChild() => _isChild(reference) != 0;

  static final _getParent = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_getParent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Activity getParent()
  /// Return the parent activity if this view is an embedded child.
  Activity getParent() => Activity.fromRef(_getParent(reference));

  static final _getWindowManager = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getWindowManager")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.WindowManager getWindowManager()
  /// Retrieve the window manager for showing custom windows.
  jni.JlObject getWindowManager() =>
      jni.JlObject.fromRef(_getWindowManager(reference));

  static final _getWindow = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_getWindow")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.Window getWindow()
  /// Retrieve the current android.view.Window for the activity.
  /// This can be used to directly access parts of the Window API that
  /// are not available through Activity/Screen.
  ///@return Window The current window, or null if the activity is not
  ///         visual.
  jni.JlObject getWindow() => jni.JlObject.fromRef(_getWindow(reference));

  static final _getLoaderManager = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getLoaderManager")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.LoaderManager getLoaderManager()
  /// Return the LoaderManager for this activity, creating it if needed.
  ///@deprecated Use android.support.v4.app.FragmentActivity\#getSupportLoaderManager()
  LoaderManager getLoaderManager() =>
      LoaderManager.fromRef(_getLoaderManager(reference));

  static final _getCurrentFocus = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getCurrentFocus")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View getCurrentFocus()
  /// Calls android.view.Window\#getCurrentFocus on the
  /// Window of this Activity to return the currently focused view.
  ///@return View The current View with focus or null.
  ///@see \#getWindow
  ///@see android.view.Window\#getCurrentFocus
  jni.JlObject getCurrentFocus() =>
      jni.JlObject.fromRef(_getCurrentFocus(reference));

  static final _attachBaseContext = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_attachBaseContext")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void attachBaseContext(android.content.Context newBase)
  void attachBaseContext(content.Context newBase) =>
      _attachBaseContext(reference, newBase.reference);

  static final _onCreate = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_onCreate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onCreate(android.os.Bundle savedInstanceState)
  /// Called when the activity is starting.  This is where most initialization
  /// should go: calling \#setContentView(int) to inflate the
  /// activity's UI, using \#findViewById to programmatically interact
  /// with widgets in the UI, calling
  /// \#managedQuery(android.net.Uri , String[], String, String[], String) to retrieve
  /// cursors for data being displayed, etc.
  ///
  /// You can call \#finish from within this function, in
  /// which case onDestroy() will be immediately called after \#onCreate without any of the
  /// rest of the activity lifecycle (\#onStart, \#onResume, \#onPause, etc)
  /// executing.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param savedInstanceState If the activity is being re-initialized after
  ///     previously being shut down then this Bundle contains the data it most
  ///     recently supplied in \#onSaveInstanceState.  __<i>Note: Otherwise it is null.</i>__
  ///
  /// This value may be {@code null}.
  ///@see \#onStart
  ///@see \#onSaveInstanceState
  ///@see \#onRestoreInstanceState
  ///@see \#onPostCreate
  void onCreate(os.Bundle savedInstanceState) =>
      _onCreate(reference, savedInstanceState.reference);

  static final _onCreate_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_onCreate_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreate(android.os.Bundle savedInstanceState, android.os.PersistableBundle persistentState)
  /// Same as \#onCreate(android.os.Bundle) but called for those activities created with
  /// the attribute android.R.attr\#persistableMode set to
  /// <code>persistAcrossReboots</code>.
  ///@param savedInstanceState if the activity is being re-initialized after
  ///     previously being shut down then this Bundle contains the data it most
  ///     recently supplied in \#onSaveInstanceState.
  ///     __<i>Note: Otherwise it is null.</i>__
  /// This value may be {@code null}.
  ///@param persistentState if the activity is being re-initialized after
  ///     previously being shut down or powered off then this Bundle contains the data it most
  ///     recently supplied to outPersistentState in \#onSaveInstanceState.
  ///     __<i>Note: Otherwise it is null.</i>__
  ///
  /// This value may be {@code null}.
  ///@see \#onCreate(android.os.Bundle)
  ///@see \#onStart
  ///@see \#onSaveInstanceState
  ///@see \#onRestoreInstanceState
  ///@see \#onPostCreate
  void onCreate_1(
          os.Bundle savedInstanceState, os.PersistableBundle persistentState) =>
      _onCreate_1(
          reference, savedInstanceState.reference, persistentState.reference);

  static final _onRestoreInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onRestoreInstanceState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onRestoreInstanceState(android.os.Bundle savedInstanceState)
  /// This method is called after \#onStart when the activity is
  /// being re-initialized from a previously saved state, given here in
  /// <var>savedInstanceState</var>.  Most implementations will simply use \#onCreate
  /// to restore their state, but it is sometimes convenient to do it here
  /// after all of the initialization has been done or to allow subclasses to
  /// decide whether to use your default implementation.  The default
  /// implementation of this method performs a restore of any view state that
  /// had previously been frozen by \#onSaveInstanceState.
  ///
  /// This method is called between \#onStart and
  /// \#onPostCreate.
  ///@param savedInstanceState the data most recently supplied in \#onSaveInstanceState.
  ///@see \#onCreate
  ///@see \#onPostCreate
  ///@see \#onResume
  ///@see \#onSaveInstanceState
  void onRestoreInstanceState(os.Bundle savedInstanceState) =>
      _onRestoreInstanceState(reference, savedInstanceState.reference);

  static final _onRestoreInstanceState_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onRestoreInstanceState_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onRestoreInstanceState(android.os.Bundle savedInstanceState, android.os.PersistableBundle persistentState)
  /// This is the same as \#onRestoreInstanceState(Bundle) but is called for activities
  /// created with the attribute android.R.attr\#persistableMode set to
  /// <code>persistAcrossReboots</code>. The android.os.PersistableBundle passed
  /// came from the restored PersistableBundle first
  /// saved in \#onSaveInstanceState(Bundle, PersistableBundle).
  ///
  /// This method is called between \#onStart and
  /// \#onPostCreate.
  ///
  /// If this method is called \#onRestoreInstanceState(Bundle) will not be called.
  ///@param savedInstanceState the data most recently supplied in \#onSaveInstanceState.
  ///@param persistentState the data most recently supplied in \#onSaveInstanceState.
  ///@see \#onRestoreInstanceState(Bundle)
  ///@see \#onCreate
  ///@see \#onPostCreate
  ///@see \#onResume
  ///@see \#onSaveInstanceState
  void onRestoreInstanceState_1(
          os.Bundle savedInstanceState, os.PersistableBundle persistentState) =>
      _onRestoreInstanceState_1(
          reference, savedInstanceState.reference, persistentState.reference);

  static final _onPostCreate = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_onPostCreate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPostCreate(android.os.Bundle savedInstanceState)
  /// Called when activity start-up is complete (after \#onStart
  /// and \#onRestoreInstanceState have been called).  Applications will
  /// generally not implement this method; it is intended for system
  /// classes to do final initialization after application code has run.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param savedInstanceState If the activity is being re-initialized after
  ///     previously being shut down then this Bundle contains the data it most
  ///     recently supplied in \#onSaveInstanceState.  __<i>Note: Otherwise it is null.</i>__
  /// This value may be {@code null}.
  ///@see \#onCreate
  void onPostCreate(os.Bundle savedInstanceState) =>
      _onPostCreate(reference, savedInstanceState.reference);

  static final _onPostCreate_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onPostCreate_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onPostCreate(android.os.Bundle savedInstanceState, android.os.PersistableBundle persistentState)
  /// This is the same as \#onPostCreate(Bundle) but is called for activities
  /// created with the attribute android.R.attr\#persistableMode set to
  /// <code>persistAcrossReboots</code>.
  ///@param savedInstanceState The data most recently supplied in \#onSaveInstanceState
  /// This value may be {@code null}.
  ///@param persistentState The data caming from the PersistableBundle first
  /// saved in \#onSaveInstanceState(Bundle, PersistableBundle).
  ///
  /// This value may be {@code null}.
  ///@see \#onCreate
  void onPostCreate_1(
          os.Bundle savedInstanceState, os.PersistableBundle persistentState) =>
      _onPostCreate_1(
          reference, savedInstanceState.reference, persistentState.reference);

  static final _onStart =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onStart")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStart()
  /// Called after \#onCreate &mdash; or after \#onRestart when
  /// the activity had been stopped, but is now again being displayed to the
  /// user.  It will be followed by \#onResume.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onCreate
  ///@see \#onStop
  ///@see \#onResume
  void onStart() => _onStart(reference);

  static final _onRestart =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onRestart")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onRestart()
  /// Called after \#onStop when the current activity is being
  /// re-displayed to the user (the user has navigated back to it).  It will
  /// be followed by \#onStart and then \#onResume.
  ///
  /// For activities that are using raw Cursor objects (instead of
  /// creating them through
  /// \#managedQuery(android.net.Uri , String[], String, String[], String),
  /// this is usually the place
  /// where the cursor should be requeried (because you had deactivated it in
  /// \#onStop.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onStop
  ///@see \#onStart
  ///@see \#onResume
  void onRestart() => _onRestart(reference);

  static final _onStateNotSaved =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onStateNotSaved")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onStateNotSaved()
  /// Called when an \#onResume is coming up, prior to other pre-resume callbacks
  /// such as \#onNewIntent and \#onActivityResult.  This is primarily intended
  /// to give the activity a hint that its state is no longer saved -- it will generally
  /// be called after \#onSaveInstanceState and prior to the activity being
  /// resumed/started again.
  void onStateNotSaved() => _onStateNotSaved(reference);

  static final _onResume =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onResume")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onResume()
  /// Called after \#onRestoreInstanceState, \#onRestart, or
  /// \#onPause, for your activity to start interacting with the user.
  /// This is a good place to begin animations, open exclusive-access devices
  /// (such as the camera), etc.
  ///
  /// Keep in mind that onResume is not the best indicator that your activity
  /// is visible to the user; a system window such as the keyguard may be in
  /// front.  Use \#onWindowFocusChanged to know for certain that your
  /// activity is visible to the user (for example, to resume a game).
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onRestoreInstanceState
  ///@see \#onRestart
  ///@see \#onPostResume
  ///@see \#onPause
  void onResume() => _onResume(reference);

  static final _onPostResume =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onPostResume")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPostResume()
  /// Called when activity resume is complete (after \#onResume has
  /// been called). Applications will generally not implement this method;
  /// it is intended for system classes to do final setup after application
  /// resume code has run.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onResume
  void onPostResume() => _onPostResume(reference);

  static final _isVoiceInteraction =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_isVoiceInteraction")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isVoiceInteraction()
  /// Check whether this activity is running as part of a voice interaction with the user.
  /// If true, it should perform its interaction with the user through the
  /// VoiceInteractor returned by \#getVoiceInteractor.
  bool isVoiceInteraction() => _isVoiceInteraction(reference) != 0;

  static final _isVoiceInteractionRoot =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_isVoiceInteractionRoot")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isVoiceInteractionRoot()
  /// Like \#isVoiceInteraction, but only returns true if this is also the root
  /// of a voice interaction.  That is, returns true if this activity was directly
  /// started by the voice interaction service as the initiation of a voice interaction.
  /// Otherwise, for example if it was started by another activity while under voice
  /// interaction, returns false.
  bool isVoiceInteractionRoot() => _isVoiceInteractionRoot(reference) != 0;

  static final _getVoiceInteractor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getVoiceInteractor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.VoiceInteractor getVoiceInteractor()
  /// Retrieve the active VoiceInteractor that the user is going through to
  /// interact with this activity.
  VoiceInteractor getVoiceInteractor() =>
      VoiceInteractor.fromRef(_getVoiceInteractor(reference));

  static final _isLocalVoiceInteractionSupported =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_isLocalVoiceInteractionSupported")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isLocalVoiceInteractionSupported()
  /// Queries whether the currently enabled voice interaction service supports returning
  /// a voice interactor for use by the activity. This is valid only for the duration of the
  /// activity.
  ///@return whether the current voice interaction service supports local voice interaction
  bool isLocalVoiceInteractionSupported() =>
      _isLocalVoiceInteractionSupported(reference) != 0;

  static final _startLocalVoiceInteraction = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_startLocalVoiceInteraction")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startLocalVoiceInteraction(android.os.Bundle privateOptions)
  /// Starts a local voice interaction session. When ready,
  /// \#onLocalVoiceInteractionStarted() is called. You can pass a bundle of private options
  /// to the registered voice interaction service.
  ///@param privateOptions a Bundle of private arguments to the current voice interaction service
  void startLocalVoiceInteraction(os.Bundle privateOptions) =>
      _startLocalVoiceInteraction(reference, privateOptions.reference);

  static final _onLocalVoiceInteractionStarted =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onLocalVoiceInteractionStarted")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onLocalVoiceInteractionStarted()
  /// Callback to indicate that \#startLocalVoiceInteraction(Bundle) has resulted in a
  /// voice interaction session being started. You can now retrieve a voice interactor using
  /// \#getVoiceInteractor().
  void onLocalVoiceInteractionStarted() =>
      _onLocalVoiceInteractionStarted(reference);

  static final _onLocalVoiceInteractionStopped =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onLocalVoiceInteractionStopped")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onLocalVoiceInteractionStopped()
  /// Callback to indicate that the local voice interaction has stopped either
  /// because it was requested through a call to \#stopLocalVoiceInteraction()
  /// or because it was canceled by the user. The previously acquired VoiceInteractor
  /// is no longer valid after this.
  void onLocalVoiceInteractionStopped() =>
      _onLocalVoiceInteractionStopped(reference);

  static final _stopLocalVoiceInteraction =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_stopLocalVoiceInteraction")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void stopLocalVoiceInteraction()
  /// Request to terminate the current voice interaction that was previously started
  /// using \#startLocalVoiceInteraction(Bundle). When the interaction is
  /// terminated, \#onLocalVoiceInteractionStopped() will be called.
  void stopLocalVoiceInteraction() => _stopLocalVoiceInteraction(reference);

  static final _onNewIntent = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_onNewIntent")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onNewIntent(android.content.Intent intent)
  /// This is called for activities that set launchMode to "singleTop" in
  /// their package, or if a client used the Intent\#FLAG_ACTIVITY_SINGLE_TOP
  /// flag when calling \#startActivity.  In either case, when the
  /// activity is re-launched while at the top of the activity stack instead
  /// of a new instance of the activity being started, onNewIntent() will be
  /// called on the existing instance with the Intent that was used to
  /// re-launch it.
  ///
  /// An activity will always be paused before receiving a new intent, so
  /// you can count on \#onResume being called after this method.
  ///
  /// Note that \#getIntent still returns the original Intent.  You
  /// can use \#setIntent to update it to this new Intent.
  ///@param intent The new intent that was started for the activity.
  ///@see \#getIntent
  ///@see \#setIntent
  ///@see \#onResume
  void onNewIntent(content.Intent intent) =>
      _onNewIntent(reference, intent.reference);

  static final _onSaveInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onSaveInstanceState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onSaveInstanceState(android.os.Bundle outState)
  /// Called to retrieve per-instance state from an activity before being killed
  /// so that the state can be restored in \#onCreate or
  /// \#onRestoreInstanceState (the Bundle populated by this method
  /// will be passed to both).
  ///
  /// This method is called before an activity may be killed so that when it
  /// comes back some time in the future it can restore its state.  For example,
  /// if activity B is launched in front of activity A, and at some point activity
  /// A is killed to reclaim resources, activity A will have a chance to save the
  /// current state of its user interface via this method so that when the user
  /// returns to activity A, the state of the user interface can be restored
  /// via \#onCreate or \#onRestoreInstanceState.
  ///
  /// Do not confuse this method with activity lifecycle callbacks such as
  /// \#onPause, which is always called when an activity is being placed
  /// in the background or on its way to destruction, or \#onStop which
  /// is called before destruction.  One example of when \#onPause and
  /// \#onStop is called and not this method is when a user navigates back
  /// from activity B to activity A: there is no need to call \#onSaveInstanceState
  /// on B because that particular instance will never be restored, so the
  /// system avoids calling it.  An example when \#onPause is called and
  /// not \#onSaveInstanceState is when activity B is launched in front of activity A:
  /// the system may avoid calling \#onSaveInstanceState on activity A if it isn't
  /// killed during the lifetime of B since the state of the user interface of
  /// A will stay intact.
  ///
  /// The default implementation takes care of most of the UI per-instance
  /// state for you by calling android.view.View\#onSaveInstanceState() on each
  /// view in the hierarchy that has an id, and by saving the id of the currently
  /// focused view (all of which is restored by the default implementation of
  /// \#onRestoreInstanceState).  If you override this method to save additional
  /// information not captured by each individual view, you will likely want to
  /// call through to the default implementation, otherwise be prepared to save
  /// all of the state of each view yourself.
  ///
  /// If called, this method will occur after \#onStop for applications
  /// targeting platforms starting with android.os.Build.VERSION_CODES\#P.
  /// For applications targeting earlier platform versions this method will occur
  /// before \#onStop and there are no guarantees about whether it will
  /// occur before or after \#onPause.
  ///@param outState Bundle in which to place your saved state.
  ///@see \#onCreate
  ///@see \#onRestoreInstanceState
  ///@see \#onPause
  void onSaveInstanceState(os.Bundle outState) =>
      _onSaveInstanceState(reference, outState.reference);

  static final _onSaveInstanceState_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onSaveInstanceState_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onSaveInstanceState(android.os.Bundle outState, android.os.PersistableBundle outPersistentState)
  /// This is the same as \#onSaveInstanceState but is called for activities
  /// created with the attribute android.R.attr\#persistableMode set to
  /// <code>persistAcrossReboots</code>. The android.os.PersistableBundle passed
  /// in will be saved and presented in \#onCreate(Bundle, PersistableBundle)
  /// the first time that this activity is restarted following the next device reboot.
  ///@param outState Bundle in which to place your saved state.
  ///@param outPersistentState State which will be saved across reboots.
  ///@see \#onSaveInstanceState(Bundle)
  ///@see \#onCreate
  ///@see \#onRestoreInstanceState(Bundle, PersistableBundle)
  ///@see \#onPause
  void onSaveInstanceState_1(
          os.Bundle outState, os.PersistableBundle outPersistentState) =>
      _onSaveInstanceState_1(
          reference, outState.reference, outPersistentState.reference);

  static final _onPause =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onPause")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPause()
  /// Called as part of the activity lifecycle when an activity is going into
  /// the background, but has not (yet) been killed.  The counterpart to
  /// \#onResume.
  ///
  /// When activity B is launched in front of activity A, this callback will
  /// be invoked on A.  B will not be created until A's \#onPause returns,
  /// so be sure to not do anything lengthy here.
  ///
  /// This callback is mostly used for saving any persistent state the
  /// activity is editing, to present a "edit in place" model to the user and
  /// making sure nothing is lost if there are not enough resources to start
  /// the new activity without first killing this one.  This is also a good
  /// place to do things like stop animations and other things that consume a
  /// noticeable amount of CPU in order to make the switch to the next activity
  /// as fast as possible, or to close resources that are exclusive access
  /// such as the camera.
  ///
  /// In situations where the system needs more memory it may kill paused
  /// processes to reclaim resources.  Because of this, you should be sure
  /// that all of your state is saved by the time you return from
  /// this function.  In general \#onSaveInstanceState is used to save
  /// per-instance state in the activity and this method is used to store
  /// global persistent data (in content providers, files, etc.)
  ///
  /// After receiving this call you will usually receive a following call
  /// to \#onStop (after the next activity has been resumed and
  /// displayed), however in some cases there will be a direct call back to
  /// \#onResume without going through the stopped state.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onResume
  ///@see \#onSaveInstanceState
  ///@see \#onStop
  void onPause() => _onPause(reference);

  static final _onUserLeaveHint =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onUserLeaveHint")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onUserLeaveHint()
  /// Called as part of the activity lifecycle when an activity is about to go
  /// into the background as the result of user choice.  For example, when the
  /// user presses the Home key, \#onUserLeaveHint will be called, but
  /// when an incoming phone call causes the in-call Activity to be automatically
  /// brought to the foreground, \#onUserLeaveHint will not be called on
  /// the activity being interrupted.  In cases when it is invoked, this method
  /// is called right before the activity's \#onPause callback.
  ///
  /// This callback and \#onUserInteraction are intended to help
  /// activities manage status bar notifications intelligently; specifically,
  /// for helping activities determine the proper time to cancel a notification.
  ///@see \#onUserInteraction()
  void onUserLeaveHint() => _onUserLeaveHint(reference);

  static final _onCreateThumbnail = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onCreateThumbnail")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onCreateThumbnail(android.graphics.Bitmap outBitmap, android.graphics.Canvas canvas)
  /// @deprecated Method doesn't do anything and will be removed in the future.
  bool onCreateThumbnail(jni.JlObject outBitmap, jni.JlObject canvas) =>
      _onCreateThumbnail(reference, outBitmap.reference, canvas.reference) != 0;

  static final _onCreateDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onCreateDescription")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence onCreateDescription()
  /// Generate a new description for this activity.  This method is called
  /// before stopping the activity and can, if desired, return some textual
  /// description of its current state to be displayed to the user.
  ///
  /// The default implementation returns null, which will cause you to
  /// inherit the description from the previous activity.  If all activities
  /// return null, generally the label of the top activity will be used as the
  /// description.
  ///@return A description of what the user is doing.  It should be short and
  ///         sweet (only a few words).
  ///@see \#onSaveInstanceState
  ///@see \#onStop
  jni.JlObject onCreateDescription() =>
      jni.JlObject.fromRef(_onCreateDescription(reference));

  static final _onProvideAssistData = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onProvideAssistData")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onProvideAssistData(android.os.Bundle data)
  /// This is called when the user is requesting an assist, to build a full
  /// Intent\#ACTION_ASSIST Intent with all of the context of the current
  /// application.  You can override this method to place into the bundle anything
  /// you would like to appear in the Intent\#EXTRA_ASSIST_CONTEXT part
  /// of the assist Intent.
  ///
  /// This function will be called after any global assist callbacks that had
  /// been registered with Application\#registerOnProvideAssistDataListener Application.registerOnProvideAssistDataListener.
  void onProvideAssistData(os.Bundle data) =>
      _onProvideAssistData(reference, data.reference);

  static final _onProvideAssistContent = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onProvideAssistContent")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onProvideAssistContent(android.app.assist.AssistContent outContent)
  /// This is called when the user is requesting an assist, to provide references
  /// to content related to the current activity.  Before being called, the
  /// {@code outContent} Intent is filled with the base Intent of the activity (the Intent
  /// returned by \#getIntent()).  The Intent's extras are stripped of any types
  /// that are not valid for PersistableBundle or non-framework Parcelables, and
  /// the flags Intent\#FLAG_GRANT_WRITE_URI_PERMISSION and
  /// Intent\#FLAG_GRANT_PERSISTABLE_URI_PERMISSION are cleared from the Intent.
  ///
  /// Custom implementation may adjust the content intent to better reflect the top-level
  /// context of the activity, and fill in its ClipData with additional content of
  /// interest that the user is currently viewing.  For example, an image gallery application
  /// that has launched in to an activity allowing the user to swipe through pictures should
  /// modify the intent to reference the current image they are looking it; such an
  /// application when showing a list of pictures should add a ClipData that has
  /// references to all of the pictures currently visible on screen.
  ///
  ///@param outContent The assist content to return.
  void onProvideAssistContent(assist.AssistContent outContent) =>
      _onProvideAssistContent(reference, outContent.reference);

  static final _requestShowKeyboardShortcuts =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_requestShowKeyboardShortcuts")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final void requestShowKeyboardShortcuts()
  /// Request the Keyboard Shortcuts screen to show up. This will trigger
  /// \#onProvideKeyboardShortcuts to retrieve the shortcuts for the foreground activity.
  void requestShowKeyboardShortcuts() =>
      _requestShowKeyboardShortcuts(reference);

  static final _dismissKeyboardShortcutsHelper =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_dismissKeyboardShortcutsHelper")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final void dismissKeyboardShortcutsHelper()
  /// Dismiss the Keyboard Shortcuts screen.
  void dismissKeyboardShortcutsHelper() =>
      _dismissKeyboardShortcutsHelper(reference);

  static final _onProvideKeyboardShortcuts = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32)>>(
          "android_app_Activity_onProvideKeyboardShortcuts")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onProvideKeyboardShortcuts(java.util.List<android.view.KeyboardShortcutGroup> data, android.view.Menu menu, int deviceId)
  void onProvideKeyboardShortcuts(
          jni.JlObject data, jni.JlObject menu, int deviceId) =>
      _onProvideKeyboardShortcuts(
          reference, data.reference, menu.reference, deviceId);

  static final _showAssist = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_showAssist")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean showAssist(android.os.Bundle args)
  /// Ask to have the current assistant shown to the user.  This only works if the calling
  /// activity is the current foreground activity.  It is the same as calling
  /// android.service.voice.VoiceInteractionService\#showSession VoiceInteractionService.showSession and requesting all of the possible context.
  /// The receiver will always see
  /// android.service.voice.VoiceInteractionSession\#SHOW_SOURCE_APPLICATION set.
  ///@return Returns true if the assistant was successfully invoked, else false.  For example
  /// false will be returned if the caller is not the current top activity.
  bool showAssist(os.Bundle args) =>
      _showAssist(reference, args.reference) != 0;

  static final _onStop =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onStop")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStop()
  /// Called when you are no longer visible to the user.  You will next
  /// receive either \#onRestart, \#onDestroy, or nothing,
  /// depending on later user activity.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onRestart
  ///@see \#onResume
  ///@see \#onSaveInstanceState
  ///@see \#onDestroy
  void onStop() => _onStop(reference);

  static final _onDestroy =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onDestroy")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onDestroy()
  /// Perform any final cleanup before an activity is destroyed.  This can
  /// happen either because the activity is finishing (someone called
  /// \#finish on it, or because the system is temporarily destroying
  /// this instance of the activity to save space.  You can distinguish
  /// between these two scenarios with the \#isFinishing method.
  ///
  /// _Note: do not count on this method being called as a place for
  /// saving data! For example, if an activity is editing data in a content
  /// provider, those edits should be committed in either \#onPause or
  /// \#onSaveInstanceState, not here._ This method is usually implemented to
  /// free resources like threads that are associated with an activity, so
  /// that a destroyed activity does not leave such things around while the
  /// rest of its application is still running.  There are situations where
  /// the system will simply kill the activity's hosting process without
  /// calling this method (or any others) in it, so it should not be used to
  /// do things that are intended to remain around after the process goes
  /// away.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onPause
  ///@see \#onStop
  ///@see \#finish
  ///@see \#isFinishing
  void onDestroy() => _onDestroy(reference);

  static final _reportFullyDrawn =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_reportFullyDrawn")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void reportFullyDrawn()
  /// Report to the system that your app is now fully drawn, purely for diagnostic
  /// purposes (calling it does not impact the visible behavior of the activity).
  /// This is only used to help instrument application launch times, so that the
  /// app can report when it is fully in a usable state; without this, the only thing
  /// the system itself can determine is the point at which the activity's window
  /// is _first_ drawn and displayed.  To participate in app launch time
  /// measurement, you should always call this method after first launch (when
  /// \#onCreate(android.os.Bundle) is called), at the point where you have
  /// entirely drawn your UI and populated with all of the significant data.  You
  /// can safely call this method any time after first launch as well, in which case
  /// it will simply be ignored.
  void reportFullyDrawn() => _reportFullyDrawn(reference);

  static final _onMultiWindowModeChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onMultiWindowModeChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onMultiWindowModeChanged(boolean isInMultiWindowMode, android.content.res.Configuration newConfig)
  /// Called by the system when the activity changes from fullscreen mode to multi-window mode and
  /// visa-versa. This method provides the same configuration that will be sent in the following
  /// \#onConfigurationChanged(Configuration) call after the activity enters this mode.
  ///@see android.R.attr\#resizeableActivity
  ///@param isInMultiWindowMode True if the activity is in multi-window mode.
  ///@param newConfig The new configuration of the activity with the state
  ///                  {@param isInMultiWindowMode}.
  void onMultiWindowModeChanged(
          bool isInMultiWindowMode, res.Configuration newConfig) =>
      _onMultiWindowModeChanged(
          reference, isInMultiWindowMode ? 1 : 0, newConfig.reference);

  static final _onMultiWindowModeChanged_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Activity_onMultiWindowModeChanged_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onMultiWindowModeChanged(boolean isInMultiWindowMode)
  /// Called by the system when the activity changes from fullscreen mode to multi-window mode and
  /// visa-versa.
  ///@see android.R.attr\#resizeableActivity
  ///@param isInMultiWindowMode True if the activity is in multi-window mode.
  ///@deprecated Use \#onMultiWindowModeChanged(boolean, Configuration) instead.
  void onMultiWindowModeChanged_1(bool isInMultiWindowMode) =>
      _onMultiWindowModeChanged_1(reference, isInMultiWindowMode ? 1 : 0);

  static final _isInMultiWindowMode =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_isInMultiWindowMode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isInMultiWindowMode()
  /// Returns true if the activity is currently in multi-window mode.
  ///@see android.R.attr\#resizeableActivity
  ///@return True if the activity is in multi-window mode.
  bool isInMultiWindowMode() => _isInMultiWindowMode(reference) != 0;

  static final _onPictureInPictureModeChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onPictureInPictureModeChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode, android.content.res.Configuration newConfig)
  /// Called by the system when the activity changes to and from picture-in-picture mode. This
  /// method provides the same configuration that will be sent in the following
  /// \#onConfigurationChanged(Configuration) call after the activity enters this mode.
  ///@see android.R.attr\#supportsPictureInPicture
  ///@param isInPictureInPictureMode True if the activity is in picture-in-picture mode.
  ///@param newConfig The new configuration of the activity with the state
  ///                  {@param isInPictureInPictureMode}.
  void onPictureInPictureModeChanged(
          bool isInPictureInPictureMode, res.Configuration newConfig) =>
      _onPictureInPictureModeChanged(
          reference, isInPictureInPictureMode ? 1 : 0, newConfig.reference);

  static final _onPictureInPictureModeChanged_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Activity_onPictureInPictureModeChanged_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode)
  /// Called by the system when the activity changes to and from picture-in-picture mode.
  ///@see android.R.attr\#supportsPictureInPicture
  ///@param isInPictureInPictureMode True if the activity is in picture-in-picture mode.
  ///@deprecated Use \#onPictureInPictureModeChanged(boolean, Configuration) instead.
  void onPictureInPictureModeChanged_1(bool isInPictureInPictureMode) =>
      _onPictureInPictureModeChanged_1(
          reference, isInPictureInPictureMode ? 1 : 0);

  static final _isInPictureInPictureMode =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_isInPictureInPictureMode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isInPictureInPictureMode()
  /// Returns true if the activity is currently in picture-in-picture mode.
  ///@see android.R.attr\#supportsPictureInPicture
  ///@return True if the activity is in picture-in-picture mode.
  bool isInPictureInPictureMode() => _isInPictureInPictureMode(reference) != 0;

  static final _enterPictureInPictureMode =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_enterPictureInPictureMode")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void enterPictureInPictureMode()
  /// Puts the activity in picture-in-picture mode if possible in the current system state. Any
  /// prior calls to \#setPictureInPictureParams(PictureInPictureParams) will still apply
  /// when entering picture-in-picture through this call.
  ///@see \#enterPictureInPictureMode(PictureInPictureParams)
  ///@see android.R.attr\#supportsPictureInPicture
  void enterPictureInPictureMode() => _enterPictureInPictureMode(reference);

  static final _enterPictureInPictureMode_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_enterPictureInPictureMode_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean enterPictureInPictureMode(android.app.PictureInPictureParams params)
  /// Puts the activity in picture-in-picture mode if possible in the current system state. The
  /// set parameters in {@param params} will be combined with the parameters from prior calls to
  /// \#setPictureInPictureParams(PictureInPictureParams).
  ///
  /// The system may disallow entering picture-in-picture in various cases, including when the
  /// activity is not visible, if the screen is locked or if the user has an activity pinned.
  ///@see android.R.attr\#supportsPictureInPicture
  ///@see PictureInPictureParams
  ///@param params non-null parameters to be combined with previously set parameters when entering
  /// picture-in-picture.
  ///
  /// This value must never be {@code null}.
  ///@return true if the system successfully put this activity into picture-in-picture mode or was
  /// already in picture-in-picture mode (@see {@link \#isInPictureInPictureMode()). If the device
  /// does not support picture-in-picture, return false.
  bool enterPictureInPictureMode_1(PictureInPictureParams params) =>
      _enterPictureInPictureMode_1(reference, params.reference) != 0;

  static final _setPictureInPictureParams = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_setPictureInPictureParams")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setPictureInPictureParams(android.app.PictureInPictureParams params)
  /// Updates the properties of the picture-in-picture activity, or sets it to be used later when
  /// \#enterPictureInPictureMode() is called.
  ///@param params the new parameters for the picture-in-picture.
  ///
  /// This value must never be {@code null}.
  void setPictureInPictureParams(PictureInPictureParams params) =>
      _setPictureInPictureParams(reference, params.reference);

  static final _getMaxNumPictureInPictureActions =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_getMaxNumPictureInPictureActions")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getMaxNumPictureInPictureActions()
  /// Return the number of actions that will be displayed in the picture-in-picture UI when the
  /// user interacts with the activity currently in picture-in-picture mode. This number may change
  /// if the global configuration changes (ie. if the device is plugged into an external display),
  /// but will always be larger than three.
  int getMaxNumPictureInPictureActions() =>
      _getMaxNumPictureInPictureActions(reference);

  static final _onConfigurationChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onConfigurationChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onConfigurationChanged(android.content.res.Configuration newConfig)
  /// Called by the system when the device configuration changes while your
  /// activity is running.  Note that this will _only_ be called if
  /// you have selected configurations you would like to handle with the
  /// android.R.attr\#configChanges attribute in your manifest.  If
  /// any configuration change occurs that is not selected to be reported
  /// by that attribute, then instead of reporting it the system will stop
  /// and restart the activity (to have it launched with the new
  /// configuration).
  ///
  /// At the time that this function has been called, your Resources
  /// object will have been updated to return resource values matching the
  /// new configuration.
  ///@param newConfig The new device configuration.
  void onConfigurationChanged(res.Configuration newConfig) =>
      _onConfigurationChanged(reference, newConfig.reference);

  static final _getChangingConfigurations =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_getChangingConfigurations")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getChangingConfigurations()
  /// If this activity is being destroyed because it can not handle a
  /// configuration parameter being changed (and thus its
  /// \#onConfigurationChanged(Configuration) method is
  /// _not_ being called), then you can use this method to discover
  /// the set of changes that have occurred while in the process of being
  /// destroyed.  Note that there is no guarantee that these will be
  /// accurate (other changes could have happened at any time), so you should
  /// only use this as an optimization hint.
  ///@return Returns a bit field of the configuration parameters that are
  /// changing, as defined by the android.content.res.Configuration
  /// class.
  int getChangingConfigurations() => _getChangingConfigurations(reference);

  static final _getLastNonConfigurationInstance = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getLastNonConfigurationInstance")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object getLastNonConfigurationInstance()
  /// Retrieve the non-configuration instance data that was previously
  /// returned by \#onRetainNonConfigurationInstance().  This will
  /// be available from the initial \#onCreate and
  /// \#onStart calls to the new instance, allowing you to extract
  /// any useful dynamic state from the previous instance.
  ///
  /// Note that the data you retrieve here should _only_ be used
  /// as an optimization for handling configuration changes.  You should always
  /// be able to handle getting a null pointer back, and an activity must
  /// still be able to restore itself to its previous state (through the
  /// normal \#onSaveInstanceState(Bundle) mechanism) even if this
  /// function returns null.
  ///
  /// <strong>Note:</strong> For most cases you should use the Fragment API
  /// Fragment\#setRetainInstance(boolean) instead; this is also
  /// available on older platforms through the Android support libraries.
  ///@return the object previously returned by \#onRetainNonConfigurationInstance()
  jni.JlObject getLastNonConfigurationInstance() =>
      jni.JlObject.fromRef(_getLastNonConfigurationInstance(reference));

  static final _onRetainNonConfigurationInstance = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onRetainNonConfigurationInstance")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object onRetainNonConfigurationInstance()
  /// Called by the system, as part of destroying an
  /// activity due to a configuration change, when it is known that a new
  /// instance will immediately be created for the new configuration.  You
  /// can return any object you like here, including the activity instance
  /// itself, which can later be retrieved by calling
  /// \#getLastNonConfigurationInstance() in the new activity
  /// instance.
  ///
  /// _If you are targeting android.os.Build.VERSION_CODES\#HONEYCOMB
  /// or later, consider instead using a Fragment with
  /// Fragment\#setRetainInstance(boolean) Fragment.setRetainInstance(boolean._
  ///
  /// This function is called purely as an optimization, and you must
  /// not rely on it being called.  When it is called, a number of guarantees
  /// will be made to help optimize configuration switching:
  /// <ul>
  /// <li> The function will be called between \#onStop and
  /// \#onDestroy.
  /// <li> A new instance of the activity will _always_ be immediately
  /// created after this one's \#onDestroy() is called.  In particular,
  /// _no_ messages will be dispatched during this time (when the returned
  /// object does not have an activity to be associated with).
  /// <li> The object you return here will _always_ be available from
  /// the \#getLastNonConfigurationInstance() method of the following
  /// activity instance as described there.
  /// </ul>
  ///
  /// These guarantees are designed so that an activity can use this API
  /// to propagate extensive state from the old to new activity instance, from
  /// loaded bitmaps, to network connections, to evenly actively running
  /// threads.  Note that you should _not_ propagate any data that
  /// may change based on the configuration, including any data loaded from
  /// resources such as strings, layouts, or drawables.
  ///
  /// The guarantee of no message handling during the switch to the next
  /// activity simplifies use with active objects.  For example if your retained
  /// state is an android.os.AsyncTask you are guaranteed that its
  /// call back functions (like android.os.AsyncTask\#onPostExecute) will
  /// not be called from the call here until you execute the next instance's
  /// \#onCreate(Bundle).  (Note however that there is of course no such
  /// guarantee for android.os.AsyncTask\#doInBackground since that is
  /// running in a separate thread.)
  ///
  /// <strong>Note:</strong> For most cases you should use the Fragment API
  /// Fragment\#setRetainInstance(boolean) instead; this is also
  /// available on older platforms through the Android support libraries.
  ///@return any Object holding the desired state to propagate to the
  ///         next activity instance
  jni.JlObject onRetainNonConfigurationInstance() =>
      jni.JlObject.fromRef(_onRetainNonConfigurationInstance(reference));

  static final _onLowMemory =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onLowMemory")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onLowMemory()
  void onLowMemory() => _onLowMemory(reference);

  static final _onTrimMemory = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_onTrimMemory")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onTrimMemory(int level)
  void onTrimMemory(int level) => _onTrimMemory(reference, level);

  static final _getFragmentManager = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getFragmentManager")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.FragmentManager getFragmentManager()
  /// Return the FragmentManager for interacting with fragments associated
  /// with this activity.
  ///@deprecated Use android.support.v4.app.FragmentActivity\#getSupportFragmentManager()
  FragmentManager getFragmentManager() =>
      FragmentManager.fromRef(_getFragmentManager(reference));

  static final _onAttachFragment = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onAttachFragment")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttachFragment(android.app.Fragment fragment)
  /// Called when a Fragment is being attached to this activity, immediately
  /// after the call to its Fragment\#onAttach Fragment.onAttach()
  /// method and before Fragment\#onCreate Fragment.onCreate().
  ///@deprecated Use android.support.v4.app.FragmentActivity\#onAttachFragment(android.support.v4.app.Fragment)
  void onAttachFragment(Fragment fragment) =>
      _onAttachFragment(reference, fragment.reference);

  static final _managedQuery = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_managedQuery")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.database.Cursor managedQuery(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder)
  /// Wrapper around
  /// ContentResolver\#query(android.net.Uri , String[], String, String[], String)
  /// that gives the resulting Cursor to call
  /// \#startManagingCursor so that the activity will manage its
  /// lifecycle for you.
  ///
  /// _If you are targeting android.os.Build.VERSION_CODES\#HONEYCOMB
  /// or later, consider instead using LoaderManager instead, available
  /// via \#getLoaderManager()._
  ///
  /// <strong>Warning:</strong> Do not call Cursor\#close() on a cursor obtained using
  /// this method, because the activity will do that for you at the appropriate time. However, if
  /// you call \#stopManagingCursor on a cursor from a managed query, the system _will
  /// not_ automatically close the cursor and, in that case, you must call
  /// Cursor\#close().
  ///
  ///@param uri The URI of the content provider to query.
  ///@param projection List of columns to return.
  ///@param selection SQL WHERE clause.
  ///@param selectionArgs The arguments to selection, if any ?s are pesent
  ///@param sortOrder SQL ORDER BY clause.
  ///@return The Cursor that was returned by query().
  ///@see ContentResolver\#query(android.net.Uri , String[], String, String[], String)
  ///@see \#startManagingCursor
  ///@deprecated Use CursorLoader instead.
  jni.JlObject managedQuery(
          jni.JlObject uri,
          jni.JlObject projection,
          jni.JlString selection,
          jni.JlObject selectionArgs,
          jni.JlString sortOrder) =>
      jni.JlObject.fromRef(_managedQuery(
          reference,
          uri.reference,
          projection.reference,
          selection.reference,
          selectionArgs.reference,
          sortOrder.reference));

  static final _startManagingCursor = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_startManagingCursor")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startManagingCursor(android.database.Cursor c)
  /// This method allows the activity to take care of managing the given
  /// Cursor's lifecycle for you based on the activity's lifecycle.
  /// That is, when the activity is stopped it will automatically call
  /// Cursor\#deactivate on the given Cursor, and when it is later restarted
  /// it will call Cursor\#requery for you.  When the activity is
  /// destroyed, all managed Cursors will be closed automatically.
  ///
  /// _If you are targeting android.os.Build.VERSION_CODES\#HONEYCOMB
  /// or later, consider instead using LoaderManager instead, available
  /// via \#getLoaderManager()._
  ///
  /// <strong>Warning:</strong> Do not call Cursor\#close() on cursor obtained from
  /// \#managedQuery, because the activity will do that for you at the appropriate time.
  /// However, if you call \#stopManagingCursor on a cursor from a managed query, the system
  /// _will not_ automatically close the cursor and, in that case, you must call
  /// Cursor\#close().
  ///
  ///@param c The Cursor to be managed.
  ///@see \#managedQuery(android.net.Uri , String[], String, String[], String)
  ///@see \#stopManagingCursor
  ///@deprecated Use the new android.content.CursorLoader class with
  /// LoaderManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  void startManagingCursor(jni.JlObject c) =>
      _startManagingCursor(reference, c.reference);

  static final _stopManagingCursor = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_stopManagingCursor")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void stopManagingCursor(android.database.Cursor c)
  /// Given a Cursor that was previously given to
  /// \#startManagingCursor, stop the activity's management of that
  /// cursor.
  ///
  /// <strong>Warning:</strong> After calling this method on a cursor from a managed query,
  /// the system _will not_ automatically close the cursor and you must call
  /// Cursor\#close().
  ///
  ///@param c The Cursor that was being managed.
  ///@see \#startManagingCursor
  ///@deprecated Use the new android.content.CursorLoader class with
  /// LoaderManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  void stopManagingCursor(jni.JlObject c) =>
      _stopManagingCursor(reference, c.reference);

  static final _getActionBar = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_getActionBar")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.ActionBar getActionBar()
  /// Retrieve a reference to this activity's ActionBar.
  ///@return The Activity's ActionBar, or null if it does not have one.
  ActionBar getActionBar() => ActionBar.fromRef(_getActionBar(reference));

  static final _setActionBar = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_setActionBar")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setActionBar(android.widget.Toolbar toolbar)
  /// Set a android.widget.Toolbar Toolbar to act as the ActionBar for this
  /// Activity window.
  ///
  /// When set to a non-null value the \#getActionBar() method will return
  /// an ActionBar object that can be used to control the given toolbar as if it were
  /// a traditional window decor action bar. The toolbar's menu will be populated with the
  /// Activity's options menu and the navigation button will be wired through the standard
  /// android.R.id\#home home menu select action.
  ///
  ///
  /// In order to use a Toolbar within the Activity's window content the application
  /// must not request the window feature Window\#FEATURE_ACTION_BAR FEATURE_ACTION_BAR.
  ///
  ///@param toolbar Toolbar to set as the Activity's action bar, or {@code null} to clear it
  ///
  /// This value may be {@code null}.
  void setActionBar(jni.JlObject toolbar) =>
      _setActionBar(reference, toolbar.reference);

  static final _setContentView = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_setContentView")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setContentView(int layoutResID)
  /// Set the activity content from a layout resource.  The resource will be
  /// inflated, adding all top-level views to the activity.
  ///@param layoutResID Resource ID to be inflated.
  ///@see \#setContentView(android.view.View)
  ///@see \#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
  void setContentView(int layoutResID) =>
      _setContentView(reference, layoutResID);

  static final _setContentView_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_setContentView_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setContentView(android.view.View view)
  /// Set the activity content to an explicit view.  This view is placed
  /// directly into the activity's view hierarchy.  It can itself be a complex
  /// view hierarchy.  When calling this method, the layout parameters of the
  /// specified view are ignored.  Both the width and the height of the view are
  /// set by default to ViewGroup.LayoutParams\#MATCH_PARENT. To use
  /// your own layout parameters, invoke
  /// \#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
  /// instead.
  ///@param view The desired content to display.
  ///@see \#setContentView(int)
  ///@see \#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
  void setContentView_1(jni.JlObject view) =>
      _setContentView_1(reference, view.reference);

  static final _setContentView_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_setContentView_2")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setContentView(android.view.View view, android.view.ViewGroup.LayoutParams params)
  /// Set the activity content to an explicit view.  This view is placed
  /// directly into the activity's view hierarchy.  It can itself be a complex
  /// view hierarchy.
  ///@param view The desired content to display.
  ///@param params Layout parameters for the view.
  ///@see \#setContentView(android.view.View)
  ///@see \#setContentView(int)
  void setContentView_2(jni.JlObject view, jni.JlObject params) =>
      _setContentView_2(reference, view.reference, params.reference);

  static final _addContentView = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_addContentView")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void addContentView(android.view.View view, android.view.ViewGroup.LayoutParams params)
  /// Add an additional content view to the activity.  Added after any existing
  /// ones in the activity -- existing views are NOT removed.
  ///@param view The desired content to display.
  ///@param params Layout parameters for the view.
  void addContentView(jni.JlObject view, jni.JlObject params) =>
      _addContentView(reference, view.reference, params.reference);

  static final _getContentTransitionManager = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getContentTransitionManager")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.transition.TransitionManager getContentTransitionManager()
  /// Retrieve the TransitionManager responsible for default transitions in this window.
  /// Requires Window\#FEATURE_CONTENT_TRANSITIONS.
  ///
  /// This method will return non-null after content has been initialized (e.g. by using
  /// \#setContentView) if Window\#FEATURE_CONTENT_TRANSITIONS has been granted.
  ///
  ///@return This window's content TransitionManager or null if none is set.
  jni.JlObject getContentTransitionManager() =>
      jni.JlObject.fromRef(_getContentTransitionManager(reference));

  static final _setContentTransitionManager = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_setContentTransitionManager")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setContentTransitionManager(android.transition.TransitionManager tm)
  /// Set the TransitionManager to use for default transitions in this window.
  /// Requires Window\#FEATURE_CONTENT_TRANSITIONS.
  ///@param tm The TransitionManager to use for scene changes.
  void setContentTransitionManager(jni.JlObject tm) =>
      _setContentTransitionManager(reference, tm.reference);

  static final _getContentScene = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getContentScene")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.transition.Scene getContentScene()
  /// Retrieve the Scene representing this window's current content.
  /// Requires Window\#FEATURE_CONTENT_TRANSITIONS.
  ///
  /// This method will return null if the current content is not represented by a Scene.
  ///
  ///@return Current Scene being shown or null
  jni.JlObject getContentScene() =>
      jni.JlObject.fromRef(_getContentScene(reference));

  static final _setFinishOnTouchOutside = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Activity_setFinishOnTouchOutside")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setFinishOnTouchOutside(boolean finish)
  /// Sets whether this activity is finished when touched outside its window's
  /// bounds.
  void setFinishOnTouchOutside(bool finish) =>
      _setFinishOnTouchOutside(reference, finish ? 1 : 0);

  static final _setDefaultKeyMode = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_setDefaultKeyMode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setDefaultKeyMode(int mode)
  /// Select the default key handling for this activity.  This controls what
  /// will happen to key events that are not otherwise handled.  The default
  /// mode (\#DEFAULT_KEYS_DISABLE) will simply drop them on the
  /// floor. Other modes allow you to launch the dialer
  /// (\#DEFAULT_KEYS_DIALER), execute a shortcut in your options
  /// menu without requiring the menu key be held down
  /// (\#DEFAULT_KEYS_SHORTCUT), or launch a search (\#DEFAULT_KEYS_SEARCH_LOCAL
  /// and \#DEFAULT_KEYS_SEARCH_GLOBAL).
  ///
  /// Note that the mode selected here does not impact the default
  /// handling of system keys, such as the "back" and "menu" keys, and your
  /// activity and its views always get a first chance to receive and handle
  /// all application keys.
  ///@param mode The desired default key mode constant.
  ///
  /// Value is android.app.Activity\#DEFAULT_KEYS_DISABLE, android.app.Activity\#DEFAULT_KEYS_DIALER, android.app.Activity\#DEFAULT_KEYS_SHORTCUT, android.app.Activity\#DEFAULT_KEYS_SEARCH_LOCAL, or android.app.Activity\#DEFAULT_KEYS_SEARCH_GLOBAL
  ///@see \#onKeyDown
  void setDefaultKeyMode(int mode) => _setDefaultKeyMode(reference, mode);

  static final _onKeyDown = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_onKeyDown")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyDown(int keyCode, android.view.KeyEvent event)
  /// Called when a key was pressed down and not handled by any of the views
  /// inside of the activity. So, for example, key presses while the cursor
  /// is inside a TextView will not trigger the event (unless it is a navigation
  /// to another object) because TextView handles its own key presses.
  ///
  /// If the focused view didn't want this event, this method is called.
  ///
  /// The default implementation takes care of KeyEvent\#KEYCODE_BACK
  /// by calling \#onBackPressed(), though the behavior varies based
  /// on the application compatibility mode: for
  /// android.os.Build.VERSION_CODES\#ECLAIR or later applications,
  /// it will set up the dispatch to call \#onKeyUp where the action
  /// will be performed; for earlier applications, it will perform the
  /// action immediately in on-down, as those versions of the platform
  /// behaved.
  ///
  /// Other additional default key handling may be performed
  /// if configured with \#setDefaultKeyMode.
  ///@return Return <code>true</code> to prevent this event from being propagated
  /// further, or <code>false</code> to indicate that you have not handled
  /// this event and it should continue to be propagated.
  ///@see \#onKeyUp
  ///@see android.view.KeyEvent
  bool onKeyDown(int keyCode, jni.JlObject event) =>
      _onKeyDown(reference, keyCode, event.reference) != 0;

  static final _onKeyLongPress = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onKeyLongPress")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyLongPress(int keyCode, android.view.KeyEvent event)
  /// Default implementation of KeyEvent.Callback\#onKeyLongPress(int, KeyEvent) KeyEvent.Callback.onKeyLongPress(): always returns false (doesn't handle
  /// the event).
  bool onKeyLongPress(int keyCode, jni.JlObject event) =>
      _onKeyLongPress(reference, keyCode, event.reference) != 0;

  static final _onKeyUp = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_onKeyUp")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyUp(int keyCode, android.view.KeyEvent event)
  /// Called when a key was released and not handled by any of the views
  /// inside of the activity. So, for example, key presses while the cursor
  /// is inside a TextView will not trigger the event (unless it is a navigation
  /// to another object) because TextView handles its own key presses.
  ///
  /// The default implementation handles KEYCODE_BACK to stop the activity
  /// and go back.
  ///@return Return <code>true</code> to prevent this event from being propagated
  /// further, or <code>false</code> to indicate that you have not handled
  /// this event and it should continue to be propagated.
  ///@see \#onKeyDown
  ///@see KeyEvent
  bool onKeyUp(int keyCode, jni.JlObject event) =>
      _onKeyUp(reference, keyCode, event.reference) != 0;

  static final _onKeyMultiple = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_onKeyMultiple")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyMultiple(int keyCode, int repeatCount, android.view.KeyEvent event)
  /// Default implementation of KeyEvent.Callback\#onKeyMultiple(int, int, KeyEvent) KeyEvent.Callback.onKeyMultiple(): always returns false (doesn't handle
  /// the event).
  bool onKeyMultiple(int keyCode, int repeatCount, jni.JlObject event) =>
      _onKeyMultiple(reference, keyCode, repeatCount, event.reference) != 0;

  static final _onBackPressed =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onBackPressed")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onBackPressed()
  /// Called when the activity has detected the user's press of the back
  /// key.  The default implementation simply finishes the current activity,
  /// but you can override this to do whatever you want.
  void onBackPressed() => _onBackPressed(reference);

  static final _onKeyShortcut = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_onKeyShortcut")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyShortcut(int keyCode, android.view.KeyEvent event)
  /// Called when a key shortcut event is not handled by any of the views in the Activity.
  /// Override this method to implement global key shortcuts for the Activity.
  /// Key shortcuts can also be implemented by setting the
  /// MenuItem\#setShortcut(char, char) shortcut property of menu items.
  ///@param keyCode The value in event.getKeyCode().
  ///@param event Description of the key event.
  ///@return True if the key shortcut was handled.
  bool onKeyShortcut(int keyCode, jni.JlObject event) =>
      _onKeyShortcut(reference, keyCode, event.reference) != 0;

  static final _onTouchEvent = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_onTouchEvent")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onTouchEvent(android.view.MotionEvent event)
  /// Called when a touch screen event was not handled by any of the views
  /// under it.  This is most useful to process touch events that happen
  /// outside of your window bounds, where there is no view to receive it.
  ///@param event The touch screen event being processed.
  ///@return Return true if you have consumed the event, false if you haven't.
  /// The default implementation always returns false.
  bool onTouchEvent(jni.JlObject event) =>
      _onTouchEvent(reference, event.reference) != 0;

  static final _onTrackballEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onTrackballEvent")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onTrackballEvent(android.view.MotionEvent event)
  /// Called when the trackball was moved and not handled by any of the
  /// views inside of the activity.  So, for example, if the trackball moves
  /// while focus is on a button, you will receive a call here because
  /// buttons do not normally do anything with trackball events.  The call
  /// here happens _before_ trackball movements are converted to
  /// DPAD key events, which then get sent back to the view hierarchy, and
  /// will be processed at the point for things like focus navigation.
  ///@param event The trackball event being processed.
  ///@return Return true if you have consumed the event, false if you haven't.
  /// The default implementation always returns false.
  bool onTrackballEvent(jni.JlObject event) =>
      _onTrackballEvent(reference, event.reference) != 0;

  static final _onGenericMotionEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onGenericMotionEvent")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onGenericMotionEvent(android.view.MotionEvent event)
  /// Called when a generic motion event was not handled by any of the
  /// views inside of the activity.
  ///
  /// Generic motion events describe joystick movements, mouse hovers, track pad
  /// touches, scroll wheel movements and other input events.  The
  /// MotionEvent\#getSource() source of the motion event specifies
  /// the class of input that was received.  Implementations of this method
  /// must examine the bits in the source before processing the event.
  /// The following code example shows how this is done.
  ///
  ///
  /// Generic motion events with source class
  /// android.view.InputDevice\#SOURCE_CLASS_POINTER
  /// are delivered to the view under the pointer.  All other generic motion events are
  /// delivered to the focused view.
  ///
  ///
  /// See View\#onGenericMotionEvent(MotionEvent) for an example of how to
  /// handle this event.
  ///
  ///
  ///@param event The generic motion event being processed.
  ///@return Return true if you have consumed the event, false if you haven't.
  /// The default implementation always returns false.
  bool onGenericMotionEvent(jni.JlObject event) =>
      _onGenericMotionEvent(reference, event.reference) != 0;

  static final _onUserInteraction =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onUserInteraction")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onUserInteraction()
  /// Called whenever a key, touch, or trackball event is dispatched to the
  /// activity.  Implement this method if you wish to know that the user has
  /// interacted with the device in some way while your activity is running.
  /// This callback and \#onUserLeaveHint are intended to help
  /// activities manage status bar notifications intelligently; specifically,
  /// for helping activities determine the proper time to cancel a notfication.
  ///
  /// All calls to your activity's \#onUserLeaveHint callback will
  /// be accompanied by calls to \#onUserInteraction.  This
  /// ensures that your activity will be told of relevant user activity such
  /// as pulling down the notification pane and touching an item there.
  ///
  /// Note that this callback will be invoked for the touch down action
  /// that begins a touch gesture, but may not be invoked for the touch-moved
  /// and touch-up actions that follow.
  ///@see \#onUserLeaveHint()
  void onUserInteraction() => _onUserInteraction(reference);

  static final _onWindowAttributesChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onWindowAttributesChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onWindowAttributesChanged(android.view.WindowManager.LayoutParams params)
  void onWindowAttributesChanged(jni.JlObject params) =>
      _onWindowAttributesChanged(reference, params.reference);

  static final _onContentChanged =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onContentChanged")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onContentChanged()
  void onContentChanged() => _onContentChanged(reference);

  static final _onWindowFocusChanged = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Activity_onWindowFocusChanged")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onWindowFocusChanged(boolean hasFocus)
  /// Called when the current Window of the activity gains or loses
  /// focus.  This is the best indicator of whether this activity is visible
  /// to the user.  The default implementation clears the key tracking
  /// state, so should always be called.
  ///
  /// Note that this provides information about global focus state, which
  /// is managed independently of activity lifecycles.  As such, while focus
  /// changes will generally have some relation to lifecycle changes (an
  /// activity that is stopped will not generally get window focus), you
  /// should not rely on any particular order between the callbacks here and
  /// those in the other lifecycle methods such as \#onResume.
  ///
  /// As a general rule, however, a resumed activity will have window
  /// focus...  unless it has displayed other dialogs or popups that take
  /// input focus, in which case the activity itself will not have focus
  /// when the other windows have it.  Likewise, the system may display
  /// system-level windows (such as the status bar notification panel or
  /// a system alert) which will temporarily take window input focus without
  /// pausing the foreground activity.
  ///@param hasFocus Whether the window of this activity has focus.
  ///@see \#hasWindowFocus()
  ///@see \#onResume
  ///@see View\#onWindowFocusChanged(boolean)
  void onWindowFocusChanged(bool hasFocus) =>
      _onWindowFocusChanged(reference, hasFocus ? 1 : 0);

  static final _onAttachedToWindow =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onAttachedToWindow")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttachedToWindow()
  /// Called when the main window associated with the activity has been
  /// attached to the window manager.
  /// See View\#onAttachedToWindow() View.onAttachedToWindow()
  /// for more information.
  ///@see View\#onAttachedToWindow
  void onAttachedToWindow() => _onAttachedToWindow(reference);

  static final _onDetachedFromWindow =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onDetachedFromWindow")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDetachedFromWindow()
  /// Called when the main window associated with the activity has been
  /// detached from the window manager.
  /// See View\#onDetachedFromWindow() View.onDetachedFromWindow()
  /// for more information.
  ///@see View\#onDetachedFromWindow
  void onDetachedFromWindow() => _onDetachedFromWindow(reference);

  static final _hasWindowFocus =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_hasWindowFocus")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasWindowFocus()
  /// Returns true if this activity's _main_ window currently has window focus.
  /// Note that this is not the same as the view itself having focus.
  ///@return True if this activity's main window currently has window focus.
  ///@see \#onWindowAttributesChanged(android.view.WindowManager.LayoutParams)
  bool hasWindowFocus() => _hasWindowFocus(reference) != 0;

  static final _dispatchKeyEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_dispatchKeyEvent")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchKeyEvent(android.view.KeyEvent event)
  /// Called to process key events.  You can override this to intercept all
  /// key events before they are dispatched to the window.  Be sure to call
  /// this implementation for key events that should be handled normally.
  ///@param event The key event.
  ///@return boolean Return true if this event was consumed.
  bool dispatchKeyEvent(jni.JlObject event) =>
      _dispatchKeyEvent(reference, event.reference) != 0;

  static final _dispatchKeyShortcutEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_dispatchKeyShortcutEvent")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchKeyShortcutEvent(android.view.KeyEvent event)
  /// Called to process a key shortcut event.
  /// You can override this to intercept all key shortcut events before they are
  /// dispatched to the window.  Be sure to call this implementation for key shortcut
  /// events that should be handled normally.
  ///@param event The key shortcut event.
  ///@return True if this event was consumed.
  bool dispatchKeyShortcutEvent(jni.JlObject event) =>
      _dispatchKeyShortcutEvent(reference, event.reference) != 0;

  static final _dispatchTouchEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_dispatchTouchEvent")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchTouchEvent(android.view.MotionEvent ev)
  /// Called to process touch screen events.  You can override this to
  /// intercept all touch screen events before they are dispatched to the
  /// window.  Be sure to call this implementation for touch screen events
  /// that should be handled normally.
  ///@param ev The touch screen event.
  ///@return boolean Return true if this event was consumed.
  bool dispatchTouchEvent(jni.JlObject ev) =>
      _dispatchTouchEvent(reference, ev.reference) != 0;

  static final _dispatchTrackballEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_dispatchTrackballEvent")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchTrackballEvent(android.view.MotionEvent ev)
  /// Called to process trackball events.  You can override this to
  /// intercept all trackball events before they are dispatched to the
  /// window.  Be sure to call this implementation for trackball events
  /// that should be handled normally.
  ///@param ev The trackball event.
  ///@return boolean Return true if this event was consumed.
  bool dispatchTrackballEvent(jni.JlObject ev) =>
      _dispatchTrackballEvent(reference, ev.reference) != 0;

  static final _dispatchGenericMotionEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_dispatchGenericMotionEvent")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchGenericMotionEvent(android.view.MotionEvent ev)
  /// Called to process generic motion events.  You can override this to
  /// intercept all generic motion events before they are dispatched to the
  /// window.  Be sure to call this implementation for generic motion events
  /// that should be handled normally.
  ///@param ev The generic motion event.
  ///@return boolean Return true if this event was consumed.
  bool dispatchGenericMotionEvent(jni.JlObject ev) =>
      _dispatchGenericMotionEvent(reference, ev.reference) != 0;

  static final _dispatchPopulateAccessibilityEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_dispatchPopulateAccessibilityEvent")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)
  bool dispatchPopulateAccessibilityEvent(jni.JlObject event) =>
      _dispatchPopulateAccessibilityEvent(reference, event.reference) != 0;

  static final _onCreatePanelView = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_onCreatePanelView")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.View onCreatePanelView(int featureId)
  /// Default implementation of
  /// android.view.Window.Callback\#onCreatePanelView
  /// for activities. This
  /// simply returns null so that all panel sub-windows will have the default
  /// menu behavior.
  jni.JlObject onCreatePanelView(int featureId) =>
      jni.JlObject.fromRef(_onCreatePanelView(reference, featureId));

  static final _onCreatePanelMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onCreatePanelMenu")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onCreatePanelMenu(int featureId, android.view.Menu menu)
  /// Default implementation of
  /// android.view.Window.Callback\#onCreatePanelMenu
  /// for activities.  This calls through to the new
  /// \#onCreateOptionsMenu method for the
  /// android.view.Window\#FEATURE_OPTIONS_PANEL panel,
  /// so that subclasses of Activity don't need to deal with feature codes.
  bool onCreatePanelMenu(int featureId, jni.JlObject menu) =>
      _onCreatePanelMenu(reference, featureId, menu.reference) != 0;

  static final _onPreparePanel = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onPreparePanel")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onPreparePanel(int featureId, android.view.View view, android.view.Menu menu)
  /// Default implementation of
  /// android.view.Window.Callback\#onPreparePanel
  /// for activities.  This
  /// calls through to the new \#onPrepareOptionsMenu method for the
  /// android.view.Window\#FEATURE_OPTIONS_PANEL
  /// panel, so that subclasses of
  /// Activity don't need to deal with feature codes.
  bool onPreparePanel(int featureId, jni.JlObject view, jni.JlObject menu) =>
      _onPreparePanel(reference, featureId, view.reference, menu.reference) !=
      0;

  static final _onMenuOpened = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_onMenuOpened")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onMenuOpened(int featureId, android.view.Menu menu)
  /// {@inheritDoc}
  ///@return The default implementation returns true.
  bool onMenuOpened(int featureId, jni.JlObject menu) =>
      _onMenuOpened(reference, featureId, menu.reference) != 0;

  static final _onMenuItemSelected = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onMenuItemSelected")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onMenuItemSelected(int featureId, android.view.MenuItem item)
  /// Default implementation of
  /// android.view.Window.Callback\#onMenuItemSelected
  /// for activities.  This calls through to the new
  /// \#onOptionsItemSelected method for the
  /// android.view.Window\#FEATURE_OPTIONS_PANEL
  /// panel, so that subclasses of
  /// Activity don't need to deal with feature codes.
  bool onMenuItemSelected(int featureId, jni.JlObject item) =>
      _onMenuItemSelected(reference, featureId, item.reference) != 0;

  static final _onPanelClosed = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_onPanelClosed")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPanelClosed(int featureId, android.view.Menu menu)
  /// Default implementation of
  /// android.view.Window.Callback\#onPanelClosed(int, Menu) for
  /// activities. This calls through to \#onOptionsMenuClosed(Menu)
  /// method for the android.view.Window\#FEATURE_OPTIONS_PANEL panel,
  /// so that subclasses of Activity don't need to deal with feature codes.
  /// For context menus (Window\#FEATURE_CONTEXT_MENU), the
  /// \#onContextMenuClosed(Menu) will be called.
  void onPanelClosed(int featureId, jni.JlObject menu) =>
      _onPanelClosed(reference, featureId, menu.reference);

  static final _invalidateOptionsMenu =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_invalidateOptionsMenu")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void invalidateOptionsMenu()
  /// Declare that the options menu has changed, so should be recreated.
  /// The \#onCreateOptionsMenu(Menu) method will be called the next
  /// time it needs to be displayed.
  void invalidateOptionsMenu() => _invalidateOptionsMenu(reference);

  static final _onCreateOptionsMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onCreateOptionsMenu")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onCreateOptionsMenu(android.view.Menu menu)
  /// Initialize the contents of the Activity's standard options menu.  You
  /// should place your menu items in to <var>menu</var>.
  ///
  /// This is only called once, the first time the options menu is
  /// displayed.  To update the menu every time it is displayed, see
  /// \#onPrepareOptionsMenu.
  ///
  /// The default implementation populates the menu with standard system
  /// menu items.  These are placed in the Menu\#CATEGORY_SYSTEM group so that
  /// they will be correctly ordered with application-defined menu items.
  /// Deriving classes should always call through to the base implementation.
  ///
  /// You can safely hold on to <var>menu</var> (and any items created
  /// from it), making modifications to it as desired, until the next
  /// time onCreateOptionsMenu() is called.
  ///
  /// When you add items to the menu, you can implement the Activity's
  /// \#onOptionsItemSelected method to handle them there.
  ///@param menu The options menu in which you place your items.
  ///@return You must return true for the menu to be displayed;
  ///         if you return false it will not be shown.
  ///@see \#onPrepareOptionsMenu
  ///@see \#onOptionsItemSelected
  bool onCreateOptionsMenu(jni.JlObject menu) =>
      _onCreateOptionsMenu(reference, menu.reference) != 0;

  static final _onPrepareOptionsMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onPrepareOptionsMenu")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onPrepareOptionsMenu(android.view.Menu menu)
  /// Prepare the Screen's standard options menu to be displayed.  This is
  /// called right before the menu is shown, every time it is shown.  You can
  /// use this method to efficiently enable/disable items or otherwise
  /// dynamically modify the contents.
  ///
  /// The default implementation updates the system menu items based on the
  /// activity's state.  Deriving classes should always call through to the
  /// base class implementation.
  ///@param menu The options menu as last shown or first initialized by
  ///             onCreateOptionsMenu().
  ///@return You must return true for the menu to be displayed;
  ///         if you return false it will not be shown.
  ///@see \#onCreateOptionsMenu
  bool onPrepareOptionsMenu(jni.JlObject menu) =>
      _onPrepareOptionsMenu(reference, menu.reference) != 0;

  static final _onOptionsItemSelected = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onOptionsItemSelected")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onOptionsItemSelected(android.view.MenuItem item)
  /// This hook is called whenever an item in your options menu is selected.
  /// The default implementation simply returns false to have the normal
  /// processing happen (calling the item's Runnable or sending a message to
  /// its Handler as appropriate).  You can use this method for any items
  /// for which you would like to do processing without those other
  /// facilities.
  ///
  /// Derived classes should call through to the base class for it to
  /// perform the default menu handling.
  ///
  ///@param item The menu item that was selected.
  ///@return boolean Return false to allow normal menu processing to
  ///         proceed, true to consume it here.
  ///@see \#onCreateOptionsMenu
  bool onOptionsItemSelected(jni.JlObject item) =>
      _onOptionsItemSelected(reference, item.reference) != 0;

  static final _onNavigateUp =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onNavigateUp")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onNavigateUp()
  /// This method is called whenever the user chooses to navigate Up within your application's
  /// activity hierarchy from the action bar.
  ///
  /// If the attribute android.R.attr\#parentActivityName parentActivityName
  /// was specified in the manifest for this activity or an activity-alias to it,
  /// default Up navigation will be handled automatically. If any activity
  /// along the parent chain requires extra Intent arguments, the Activity subclass
  /// should override the method \#onPrepareNavigateUpTaskStack(TaskStackBuilder)
  /// to supply those arguments.
  ///
  ///
  /// See <a href="{@docRoot}guide/components/tasks-and-back-stack.html">Tasks and Back Stack</a>
  /// from the developer guide and <a href="{@docRoot}design/patterns/navigation.html">Navigation</a>
  /// from the design guide for more information about navigating within your app.
  ///
  ///
  /// See the TaskStackBuilder class and the Activity methods
  /// \#getParentActivityIntent(), \#shouldUpRecreateTask(Intent), and
  /// \#navigateUpTo(Intent) for help implementing custom Up navigation.
  /// The AppNavigation sample application in the Android SDK is also available for reference.
  ///
  ///@return true if Up navigation completed successfully and this Activity was finished,
  ///         false otherwise.
  bool onNavigateUp() => _onNavigateUp(reference) != 0;

  static final _onNavigateUpFromChild = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onNavigateUpFromChild")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onNavigateUpFromChild(android.app.Activity child)
  /// This is called when a child activity of this one attempts to navigate up.
  /// The default implementation simply calls onNavigateUp() on this activity (the parent).
  ///@param child The activity making the call.
  bool onNavigateUpFromChild(Activity child) =>
      _onNavigateUpFromChild(reference, child.reference) != 0;

  static final _onCreateNavigateUpTaskStack = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onCreateNavigateUpTaskStack")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreateNavigateUpTaskStack(android.app.TaskStackBuilder builder)
  /// Define the synthetic task stack that will be generated during Up navigation from
  /// a different task.
  ///
  /// The default implementation of this method adds the parent chain of this activity
  /// as specified in the manifest to the supplied TaskStackBuilder. Applications
  /// may choose to override this method to construct the desired task stack in a different
  /// way.
  ///
  ///
  /// This method will be invoked by the default implementation of \#onNavigateUp()
  /// if \#shouldUpRecreateTask(Intent) returns true when supplied with the intent
  /// returned by \#getParentActivityIntent().
  ///
  ///
  /// Applications that wish to supply extra Intent parameters to the parent stack defined
  /// by the manifest should override \#onPrepareNavigateUpTaskStack(TaskStackBuilder).
  ///
  ///@param builder An empty TaskStackBuilder - the application should add intents representing
  ///                the desired task stack
  void onCreateNavigateUpTaskStack(TaskStackBuilder builder) =>
      _onCreateNavigateUpTaskStack(reference, builder.reference);

  static final _onPrepareNavigateUpTaskStack = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onPrepareNavigateUpTaskStack")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPrepareNavigateUpTaskStack(android.app.TaskStackBuilder builder)
  /// Prepare the synthetic task stack that will be generated during Up navigation
  /// from a different task.
  ///
  /// This method receives the TaskStackBuilder with the constructed series of
  /// Intents as generated by \#onCreateNavigateUpTaskStack(TaskStackBuilder).
  /// If any extra data should be added to these intents before launching the new task,
  /// the application should override this method and add that data here.
  ///
  ///@param builder A TaskStackBuilder that has been populated with Intents by
  ///                onCreateNavigateUpTaskStack.
  void onPrepareNavigateUpTaskStack(TaskStackBuilder builder) =>
      _onPrepareNavigateUpTaskStack(reference, builder.reference);

  static final _onOptionsMenuClosed = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onOptionsMenuClosed")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onOptionsMenuClosed(android.view.Menu menu)
  /// This hook is called whenever the options menu is being closed (either by the user canceling
  /// the menu with the back/menu button, or when an item is selected).
  ///@param menu The options menu as last shown or first initialized by
  ///             onCreateOptionsMenu().
  void onOptionsMenuClosed(jni.JlObject menu) =>
      _onOptionsMenuClosed(reference, menu.reference);

  static final _openOptionsMenu =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_openOptionsMenu")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void openOptionsMenu()
  /// Programmatically opens the options menu. If the options menu is already
  /// open, this method does nothing.
  void openOptionsMenu() => _openOptionsMenu(reference);

  static final _closeOptionsMenu =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_closeOptionsMenu")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void closeOptionsMenu()
  /// Progammatically closes the options menu. If the options menu is already
  /// closed, this method does nothing.
  void closeOptionsMenu() => _closeOptionsMenu(reference);

  static final _onCreateContextMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onCreateContextMenu")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreateContextMenu(android.view.ContextMenu menu, android.view.View v, android.view.ContextMenu.ContextMenuInfo menuInfo)
  /// Called when a context menu for the {@code view} is about to be shown.
  /// Unlike \#onCreateOptionsMenu(Menu), this will be called every
  /// time the context menu is about to be shown and should be populated for
  /// the view (or item inside the view for AdapterView subclasses,
  /// this can be found in the {@code menuInfo})).
  ///
  /// Use \#onContextItemSelected(android.view.MenuItem) to know when an
  /// item has been selected.
  ///
  /// It is not safe to hold onto the context menu after this method returns.
  void onCreateContextMenu(
          jni.JlObject menu, jni.JlObject v, jni.JlObject menuInfo) =>
      _onCreateContextMenu(
          reference, menu.reference, v.reference, menuInfo.reference);

  static final _registerForContextMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_registerForContextMenu")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerForContextMenu(android.view.View view)
  /// Registers a context menu to be shown for the given view (multiple views
  /// can show the context menu). This method will set the
  /// OnCreateContextMenuListener on the view to this activity, so
  /// \#onCreateContextMenu(ContextMenu, View, ContextMenuInfo) will be
  /// called when it is time to show the context menu.
  ///@see \#unregisterForContextMenu(View)
  ///@param view The view that should show a context menu.
  void registerForContextMenu(jni.JlObject view) =>
      _registerForContextMenu(reference, view.reference);

  static final _unregisterForContextMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_unregisterForContextMenu")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterForContextMenu(android.view.View view)
  /// Prevents a context menu to be shown for the given view. This method will remove the
  /// OnCreateContextMenuListener on the view.
  ///@see \#registerForContextMenu(View)
  ///@param view The view that should stop showing a context menu.
  void unregisterForContextMenu(jni.JlObject view) =>
      _unregisterForContextMenu(reference, view.reference);

  static final _openContextMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_openContextMenu")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void openContextMenu(android.view.View view)
  /// Programmatically opens the context menu for a particular {@code view}.
  /// The {@code view} should have been added via
  /// \#registerForContextMenu(View).
  ///@param view The view to show the context menu for.
  void openContextMenu(jni.JlObject view) =>
      _openContextMenu(reference, view.reference);

  static final _closeContextMenu =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_closeContextMenu")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void closeContextMenu()
  /// Programmatically closes the most recently opened context menu, if showing.
  void closeContextMenu() => _closeContextMenu(reference);

  static final _onContextItemSelected = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onContextItemSelected")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onContextItemSelected(android.view.MenuItem item)
  /// This hook is called whenever an item in a context menu is selected. The
  /// default implementation simply returns false to have the normal processing
  /// happen (calling the item's Runnable or sending a message to its Handler
  /// as appropriate). You can use this method for any items for which you
  /// would like to do processing without those other facilities.
  ///
  /// Use MenuItem\#getMenuInfo() to get extra information set by the
  /// View that added this menu item.
  ///
  /// Derived classes should call through to the base class for it to perform
  /// the default menu handling.
  ///@param item The context menu item that was selected.
  ///@return boolean Return false to allow normal context menu processing to
  ///         proceed, true to consume it here.
  bool onContextItemSelected(jni.JlObject item) =>
      _onContextItemSelected(reference, item.reference) != 0;

  static final _onContextMenuClosed = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onContextMenuClosed")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onContextMenuClosed(android.view.Menu menu)
  /// This hook is called whenever the context menu is being closed (either by
  /// the user canceling the menu with the back/menu button, or when an item is
  /// selected).
  ///@param menu The context menu that is being closed.
  void onContextMenuClosed(jni.JlObject menu) =>
      _onContextMenuClosed(reference, menu.reference);

  static final _onCreateDialog = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_onCreateDialog")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: protected android.app.Dialog onCreateDialog(int id)
  /// @deprecated Old no-arguments version of \#onCreateDialog(int, Bundle).
  Dialog onCreateDialog(int id) =>
      Dialog.fromRef(_onCreateDialog(reference, id));

  static final _onCreateDialog_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onCreateDialog_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: protected android.app.Dialog onCreateDialog(int id, android.os.Bundle args)
  /// Callback for creating dialogs that are managed (saved and restored) for you
  /// by the activity.  The default implementation calls through to
  /// \#onCreateDialog(int) for compatibility.
  ///
  /// _If you are targeting android.os.Build.VERSION_CODES\#HONEYCOMB
  /// or later, consider instead using a DialogFragment instead._
  ///
  /// If you use \#showDialog(int), the activity will call through to
  /// this method the first time, and hang onto it thereafter.  Any dialog
  /// that is created by this method will automatically be saved and restored
  /// for you, including whether it is showing.
  ///
  /// If you would like the activity to manage saving and restoring dialogs
  /// for you, you should override this method and handle any ids that are
  /// passed to \#showDialog.
  ///
  /// If you would like an opportunity to prepare your dialog before it is shown,
  /// override \#onPrepareDialog(int, Dialog, Bundle).
  ///@param id The id of the dialog.
  ///@param args The dialog arguments provided to \#showDialog(int, Bundle).
  ///@return The dialog.  If you return null, the dialog will not be created.
  ///@see \#onPrepareDialog(int, Dialog, Bundle)
  ///@see \#showDialog(int, Bundle)
  ///@see \#dismissDialog(int)
  ///@see \#removeDialog(int)
  ///@deprecated Use the new DialogFragment class with
  /// FragmentManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  Dialog onCreateDialog_1(int id, os.Bundle args) =>
      Dialog.fromRef(_onCreateDialog_1(reference, id, args.reference));

  static final _onPrepareDialog = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onPrepareDialog")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPrepareDialog(int id, android.app.Dialog dialog)
  /// @deprecated Old no-arguments version of
  /// \#onPrepareDialog(int, Dialog, Bundle).
  void onPrepareDialog(int id, Dialog dialog) =>
      _onPrepareDialog(reference, id, dialog.reference);

  static final _onPrepareDialog_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onPrepareDialog_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPrepareDialog(int id, android.app.Dialog dialog, android.os.Bundle args)
  /// Provides an opportunity to prepare a managed dialog before it is being
  /// shown.  The default implementation calls through to
  /// \#onPrepareDialog(int, Dialog) for compatibility.
  ///
  ///
  /// Override this if you need to update a managed dialog based on the state
  /// of the application each time it is shown. For example, a time picker
  /// dialog might want to be updated with the current time. You should call
  /// through to the superclass's implementation. The default implementation
  /// will set this Activity as the owner activity on the Dialog.
  ///@param id The id of the managed dialog.
  ///@param dialog The dialog.
  ///@param args The dialog arguments provided to \#showDialog(int, Bundle).
  ///@see \#onCreateDialog(int, Bundle)
  ///@see \#showDialog(int)
  ///@see \#dismissDialog(int)
  ///@see \#removeDialog(int)
  ///@deprecated Use the new DialogFragment class with
  /// FragmentManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  void onPrepareDialog_1(int id, Dialog dialog, os.Bundle args) =>
      _onPrepareDialog_1(reference, id, dialog.reference, args.reference);

  static final _showDialog = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_showDialog")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void showDialog(int id)
  /// Simple version of \#showDialog(int, Bundle) that does not
  /// take any arguments.  Simply calls \#showDialog(int, Bundle)
  /// with null arguments.
  ///@deprecated Use the new DialogFragment class with
  /// FragmentManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  void showDialog(int id) => _showDialog(reference, id);

  static final _showDialog_1 = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_showDialog_1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean showDialog(int id, android.os.Bundle args)
  /// Show a dialog managed by this activity.  A call to \#onCreateDialog(int, Bundle)
  /// will be made with the same id the first time this is called for a given
  /// id.  From thereafter, the dialog will be automatically saved and restored.
  ///
  /// _If you are targeting android.os.Build.VERSION_CODES\#HONEYCOMB
  /// or later, consider instead using a DialogFragment instead._
  ///
  /// Each time a dialog is shown, \#onPrepareDialog(int, Dialog, Bundle) will
  /// be made to provide an opportunity to do any timely preparation.
  ///@param id The id of the managed dialog.
  ///@param args Arguments to pass through to the dialog.  These will be saved
  /// and restored for you.  Note that if the dialog is already created,
  /// \#onCreateDialog(int, Bundle) will not be called with the new
  /// arguments but \#onPrepareDialog(int, Dialog, Bundle) will be.
  /// If you need to rebuild the dialog, call \#removeDialog(int) first.
  ///@return Returns true if the Dialog was created; false is returned if
  /// it is not created because \#onCreateDialog(int, Bundle) returns false.
  ///@see Dialog
  ///@see \#onCreateDialog(int, Bundle)
  ///@see \#onPrepareDialog(int, Dialog, Bundle)
  ///@see \#dismissDialog(int)
  ///@see \#removeDialog(int)
  ///@deprecated Use the new DialogFragment class with
  /// FragmentManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  bool showDialog_1(int id, os.Bundle args) =>
      _showDialog_1(reference, id, args.reference) != 0;

  static final _dismissDialog = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_dismissDialog")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void dismissDialog(int id)
  /// Dismiss a dialog that was previously shown via \#showDialog(int).
  ///@param id The id of the managed dialog.
  ///@throws IllegalArgumentException if the id was not previously shown via
  ///   \#showDialog(int).
  ///@see \#onCreateDialog(int, Bundle)
  ///@see \#onPrepareDialog(int, Dialog, Bundle)
  ///@see \#showDialog(int)
  ///@see \#removeDialog(int)
  ///@deprecated Use the new DialogFragment class with
  /// FragmentManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  void dismissDialog(int id) => _dismissDialog(reference, id);

  static final _removeDialog = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_removeDialog")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void removeDialog(int id)
  /// Removes any internal references to a dialog managed by this Activity.
  /// If the dialog is showing, it will dismiss it as part of the clean up.
  ///
  /// This can be useful if you know that you will never show a dialog again and
  /// want to avoid the overhead of saving and restoring it in the future.
  ///
  /// As of android.os.Build.VERSION_CODES\#GINGERBREAD, this function
  /// will not throw an exception if you try to remove an ID that does not
  /// currently have an associated dialog.
  ///
  ///@param id The id of the managed dialog.
  ///@see \#onCreateDialog(int, Bundle)
  ///@see \#onPrepareDialog(int, Dialog, Bundle)
  ///@see \#showDialog(int)
  ///@see \#dismissDialog(int)
  ///@deprecated Use the new DialogFragment class with
  /// FragmentManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  void removeDialog(int id) => _removeDialog(reference, id);

  static final _onSearchRequested = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onSearchRequested")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onSearchRequested(android.view.SearchEvent searchEvent)
  /// This hook is called when the user signals the desire to start a search.
  ///
  /// You can use this function as a simple way to launch the search UI, in response to a
  /// menu item, search button, or other widgets within your activity. Unless overidden,
  /// calling this function is the same as calling
  /// \#startSearch startSearch(null, false, null, false), which launches
  /// search for the current activity as specified in its manifest, see SearchManager.
  ///
  /// You can override this function to force global search, e.g. in response to a dedicated
  /// search key, or to block search entirely (by simply returning false).
  ///
  /// Note: when running in a Configuration\#UI_MODE_TYPE_TELEVISION or
  /// Configuration\#UI_MODE_TYPE_WATCH, the default implementation changes to simply
  /// return false and you must supply your own custom implementation if you want to support
  /// search.
  ///@param searchEvent The SearchEvent that signaled this search.
  /// This value may be {@code null}.
  ///@return Returns {@code true} if search launched, and {@code false} if the activity does
  /// not respond to search.  The default implementation always returns {@code true}, except
  /// when in Configuration\#UI_MODE_TYPE_TELEVISION mode where it returns false.
  ///@see android.app.SearchManager
  bool onSearchRequested(jni.JlObject searchEvent) =>
      _onSearchRequested(reference, searchEvent.reference) != 0;

  static final _onSearchRequested_1 =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onSearchRequested_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onSearchRequested()
  /// @see \#onSearchRequested(SearchEvent)
  bool onSearchRequested_1() => _onSearchRequested_1(reference) != 0;

  static final _getSearchEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getSearchEvent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.view.SearchEvent getSearchEvent()
  /// During the onSearchRequested() callbacks, this function will return the
  /// SearchEvent that triggered the callback, if it exists.
  ///@return SearchEvent The SearchEvent that triggered the \#onSearchRequested callback.
  jni.JlObject getSearchEvent() =>
      jni.JlObject.fromRef(_getSearchEvent(reference));

  static final _startSearch = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Activity_startSearch")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void startSearch(java.lang.String initialQuery, boolean selectInitialQuery, android.os.Bundle appSearchData, boolean globalSearch)
  /// This hook is called to launch the search UI.
  ///
  /// It is typically called from onSearchRequested(), either directly from
  /// Activity.onSearchRequested() or from an overridden version in any given
  /// Activity.  If your goal is simply to activate search, it is preferred to call
  /// onSearchRequested(), which may have been overridden elsewhere in your Activity.  If your goal
  /// is to inject specific data such as context data, it is preferred to <i>override</i>
  /// onSearchRequested(), so that any callers to it will benefit from the override.
  ///
  /// Note: when running in a Configuration\#UI_MODE_TYPE_WATCH, use of this API is
  /// not supported.
  ///@param initialQuery Any non-null non-empty string will be inserted as
  /// pre-entered text in the search query box.
  /// This value may be {@code null}.
  ///@param selectInitialQuery If true, the initial query will be preselected, which means that
  /// any further typing will replace it.  This is useful for cases where an entire pre-formed
  /// query is being inserted.  If false, the selection point will be placed at the end of the
  /// inserted query.  This is useful when the inserted query is text that the user entered,
  /// and the user would expect to be able to keep typing.  <i>This parameter is only meaningful
  /// if initialQuery is a non-empty string.</i>
  ///@param appSearchData An application can insert application-specific
  /// context here, in order to improve quality or specificity of its own
  /// searches.  This data will be returned with SEARCH intent(s).  Null if
  /// no extra data is required.
  /// This value may be {@code null}.
  ///@param globalSearch If false, this will only launch the search that has been specifically
  /// defined by the application (which is usually defined as a local search).  If no default
  /// search is defined in the current application or activity, global search will be launched.
  /// If true, this will always launch a platform-global (e.g. web-based) search instead.
  ///@see android.app.SearchManager
  ///@see \#onSearchRequested
  void startSearch(jni.JlString initialQuery, bool selectInitialQuery,
          os.Bundle appSearchData, bool globalSearch) =>
      _startSearch(
          reference,
          initialQuery.reference,
          selectInitialQuery ? 1 : 0,
          appSearchData.reference,
          globalSearch ? 1 : 0);

  static final _triggerSearch = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_triggerSearch")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void triggerSearch(java.lang.String query, android.os.Bundle appSearchData)
  /// Similar to \#startSearch, but actually fires off the search query after invoking
  /// the search dialog.  Made available for testing purposes.
  ///@param query The query to trigger.  If empty, the request will be ignored.
  ///@param appSearchData An application can insert application-specific
  /// context here, in order to improve quality or specificity of its own
  /// searches.  This data will be returned with SEARCH intent(s).  Null if
  /// no extra data is required.
  ///
  /// This value may be {@code null}.
  void triggerSearch(jni.JlString query, os.Bundle appSearchData) =>
      _triggerSearch(reference, query.reference, appSearchData.reference);

  static final _takeKeyEvents = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Activity_takeKeyEvents")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void takeKeyEvents(boolean get)
  /// Request that key events come to this activity. Use this if your
  /// activity has no views with focus, but the activity still wants
  /// a chance to process key events.
  ///@see android.view.Window\#takeKeyEvents
  void takeKeyEvents(bool get_) => _takeKeyEvents(reference, get_ ? 1 : 0);

  static final _requestWindowFeature = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_requestWindowFeature")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final boolean requestWindowFeature(int featureId)
  /// Enable extended window features.  This is a convenience for calling
  /// android.view.Window\#requestFeature getWindow().requestFeature().
  ///@param featureId The desired feature as defined in
  ///                  android.view.Window.
  ///@return Returns true if the requested feature is supported and now
  ///         enabled.
  ///@see android.view.Window\#requestFeature
  bool requestWindowFeature(int featureId) =>
      _requestWindowFeature(reference, featureId) != 0;

  static final _setFeatureDrawableResource = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_app_Activity_setFeatureDrawableResource")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final void setFeatureDrawableResource(int featureId, int resId)
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawableResource.
  void setFeatureDrawableResource(int featureId, int resId) =>
      _setFeatureDrawableResource(reference, featureId, resId);

  static final _setFeatureDrawableUri = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_setFeatureDrawableUri")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setFeatureDrawableUri(int featureId, android.net.Uri uri)
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawableUri.
  void setFeatureDrawableUri(int featureId, jni.JlObject uri) =>
      _setFeatureDrawableUri(reference, featureId, uri.reference);

  static final _setFeatureDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_setFeatureDrawable")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setFeatureDrawable(int featureId, android.graphics.drawable.Drawable drawable)
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawable(int, Drawable).
  void setFeatureDrawable(int featureId, jni.JlObject drawable) =>
      _setFeatureDrawable(reference, featureId, drawable.reference);

  static final _setFeatureDrawableAlpha = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_app_Activity_setFeatureDrawableAlpha")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final void setFeatureDrawableAlpha(int featureId, int alpha)
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawableAlpha.
  void setFeatureDrawableAlpha(int featureId, int alpha) =>
      _setFeatureDrawableAlpha(reference, featureId, alpha);

  static final _getLayoutInflater = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getLayoutInflater")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.LayoutInflater getLayoutInflater()
  /// Convenience for calling
  /// android.view.Window\#getLayoutInflater.
  ///@return This value will never be {@code null}.
  jni.JlObject getLayoutInflater() =>
      jni.JlObject.fromRef(_getLayoutInflater(reference));

  static final _getMenuInflater = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getMenuInflater")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.MenuInflater getMenuInflater()
  /// Returns a MenuInflater with this context.
  ///@return This value will never be {@code null}.
  jni.JlObject getMenuInflater() =>
      jni.JlObject.fromRef(_getMenuInflater(reference));

  static final _setTheme = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_setTheme")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setTheme(int resid)
  void setTheme(int resid) => _setTheme(reference, resid);

  static final _onApplyThemeResource = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Uint8)>>("android_app_Activity_onApplyThemeResource")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: protected void onApplyThemeResource(android.content.res.Resources.Theme theme, int resid, boolean first)
  void onApplyThemeResource(res.Resources_Theme theme, int resid, bool first) =>
      _onApplyThemeResource(reference, theme.reference, resid, first ? 1 : 0);

  static final _requestPermissions = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_requestPermissions")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void requestPermissions(java.lang.String[] permissions, int requestCode)
  /// Requests permissions to be granted to this application. These permissions
  /// must be requested in your manifest, they should not be granted to your app,
  /// and they should have protection level android.content.pm.PermissionInfo \#PROTECTION_DANGEROUS dangerous, regardless whether they are declared by
  /// the platform or a third-party app.
  ///
  /// Normal permissions android.content.pm.PermissionInfo\#PROTECTION_NORMAL
  /// are granted at install time if requested in the manifest. Signature permissions
  /// android.content.pm.PermissionInfo\#PROTECTION_SIGNATURE are granted at
  /// install time if requested in the manifest and the signature of your app matches
  /// the signature of the app declaring the permissions.
  ///
  ///
  ///
  /// If your app does not have the requested permissions the user will be presented
  /// with UI for accepting them. After the user has accepted or rejected the
  /// requested permissions you will receive a callback on \#onRequestPermissionsResult(int, String[], int[]) reporting whether the
  /// permissions were granted or not.
  ///
  ///
  ///
  /// Note that requesting a permission does not guarantee it will be granted and
  /// your app should be able to run without having this permission.
  ///
  ///
  ///
  /// This method may start an activity allowing the user to choose which permissions
  /// to grant and which to reject. Hence, you should be prepared that your activity
  /// may be paused and resumed. Further, granting some permissions may require
  /// a restart of you application. In such a case, the system will recreate the
  /// activity stack before delivering the result to \#onRequestPermissionsResult(int, String[], int[]).
  ///
  ///
  ///
  /// When checking whether you have a permission you should use \#checkSelfPermission(String).
  ///
  ///
  ///
  /// Calling this API for permissions already granted to your app would show UI
  /// to the user to decide whether the app can still hold these permissions. This
  /// can be useful if the way your app uses data guarded by the permissions
  /// changes significantly.
  ///
  ///
  ///
  /// You cannot request a permission if your activity sets android.R.styleable\#AndroidManifestActivity_noHistory noHistory to
  /// <code>true</code> because in this case the activity would not receive
  /// result callbacks including \#onRequestPermissionsResult(int, String[], int[]).
  ///
  ///
  ///
  /// The <a href="http://developer.android.com/samples/RuntimePermissions/index.html">
  /// RuntimePermissions</a> sample app demonstrates how to use this method to
  /// request permissions at run time.
  ///
  ///
  ///@param permissions The requested permissions. Must me non-null and not empty.
  /// This value must never be {@code null}.
  ///@param requestCode Application specific request code to match with a result
  ///    reported to \#onRequestPermissionsResult(int, String[], int[]).
  ///    Should be >= 0.
  ///@throws IllegalArgumentException if requestCode is negative.
  ///@see \#onRequestPermissionsResult(int, String[], int[])
  ///@see \#checkSelfPermission(String)
  ///@see \#shouldShowRequestPermissionRationale(String)
  void requestPermissions(jni.JlObject permissions, int requestCode) =>
      _requestPermissions(reference, permissions.reference, requestCode);

  static final _onRequestPermissionsResult = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onRequestPermissionsResult")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onRequestPermissionsResult(int requestCode, java.lang.String[] permissions, int[] grantResults)
  /// Callback for the result from requesting permissions. This method
  /// is invoked for every call on \#requestPermissions(String[], int).
  ///
  /// <strong>Note:</strong> It is possible that the permissions request interaction
  /// with the user is interrupted. In this case you will receive empty permissions
  /// and results arrays which should be treated as a cancellation.
  ///
  ///
  ///@param requestCode The request code passed in \#requestPermissions(String[], int).
  ///@param permissions The requested permissions. Never null.
  /// This value must never be {@code null}.
  ///@param grantResults The grant results for the corresponding permissions
  ///     which is either android.content.pm.PackageManager\#PERMISSION_GRANTED
  ///     or android.content.pm.PackageManager\#PERMISSION_DENIED. Never null.
  ///
  /// This value must never be {@code null}.
  ///@see \#requestPermissions(String[], int)
  void onRequestPermissionsResult(int requestCode, jni.JlObject permissions,
          jni.JlObject grantResults) =>
      _onRequestPermissionsResult(reference, requestCode, permissions.reference,
          grantResults.reference);

  static final _shouldShowRequestPermissionRationale = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_shouldShowRequestPermissionRationale")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldShowRequestPermissionRationale(java.lang.String permission)
  /// Gets whether you should show UI with rationale for requesting a permission.
  /// You should do this only if you do not have the permission and the context in
  /// which the permission is requested does not clearly communicate to the user
  /// what would be the benefit from granting this permission.
  ///
  /// For example, if you write a camera app, requesting the camera permission
  /// would be expected by the user and no rationale for why it is requested is
  /// needed. If however, the app needs location for tagging photos then a non-tech
  /// savvy user may wonder how location is related to taking photos. In this case
  /// you may choose to show UI with rationale of requesting this permission.
  ///
  ///
  ///@param permission A permission your app wants to request.
  /// This value must never be {@code null}.
  ///@return Whether you can show permission rationale UI.
  ///@see \#checkSelfPermission(String)
  ///@see \#requestPermissions(String[], int)
  ///@see \#onRequestPermissionsResult(int, String[], int[])
  bool shouldShowRequestPermissionRationale(jni.JlString permission) =>
      _shouldShowRequestPermissionRationale(reference, permission.reference) !=
      0;

  static final _startActivityForResult = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_startActivityForResult")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void startActivityForResult(android.content.Intent intent, int requestCode)
  /// Same as calling \#startActivityForResult(Intent, int, Bundle)
  /// with no options.
  ///@param intent The intent to start.
  ///@param requestCode If >= 0, this code will be returned in
  ///                    onActivityResult() when the activity exits.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivity
  void startActivityForResult(content.Intent intent, int requestCode) =>
      _startActivityForResult(reference, intent.reference, requestCode);

  static final _startActivityForResult_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_startActivityForResult_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivityForResult(android.content.Intent intent, int requestCode, android.os.Bundle options)
  /// Launch an activity for which you would like a result when it finished.
  /// When this activity exits, your
  /// onActivityResult() method will be called with the given requestCode.
  /// Using a negative requestCode is the same as calling
  /// \#startActivity (the activity is not launched as a sub-activity).
  ///
  /// Note that this method should only be used with Intent protocols
  /// that are defined to return a result.  In other protocols (such as
  /// Intent\#ACTION_MAIN or Intent\#ACTION_VIEW), you may
  /// not get the result when you expect.  For example, if the activity you
  /// are launching uses Intent\#FLAG_ACTIVITY_NEW_TASK, it will not
  /// run in your task and thus you will immediately receive a cancel result.
  ///
  /// As a special case, if you call startActivityForResult() with a requestCode
  /// >= 0 during the initial onCreate(Bundle savedInstanceState)/onResume() of your
  /// activity, then your window will not be displayed until a result is
  /// returned back from the started activity.  This is to avoid visible
  /// flickering when redirecting to another activity.
  ///
  /// This method throws android.content.ActivityNotFoundException
  /// if there was no Activity found to run the given Intent.
  ///@param intent The intent to start.
  ///@param requestCode If >= 0, this code will be returned in
  ///                    onActivityResult() when the activity exits.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivity
  void startActivityForResult_1(
          content.Intent intent, int requestCode, os.Bundle options) =>
      _startActivityForResult_1(
          reference, intent.reference, requestCode, options.reference);

  static final _isActivityTransitionRunning =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_isActivityTransitionRunning")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isActivityTransitionRunning()
  /// Returns whether there are any activity transitions currently running on this
  /// activity. A return value of {@code true} can mean that either an enter or
  /// exit transition is running, including whether the background of the activity
  /// is animating as a part of that transition.
  ///@return true if a transition is currently running on this activity, false otherwise.
  bool isActivityTransitionRunning() =>
      _isActivityTransitionRunning(reference) != 0;

  static final _startIntentSenderForResult = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32)>>(
          "android_app_Activity_startIntentSenderForResult")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void startIntentSenderForResult(android.content.IntentSender intent, int requestCode, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)
  /// Same as calling \#startIntentSenderForResult(IntentSender, int,
  /// Intent, int, int, int, Bundle) with no options.
  ///@param intent The IntentSender to launch.
  ///@param requestCode If >= 0, this code will be returned in
  ///                    onActivityResult() when the activity exits.
  ///@param fillInIntent If non-null, this will be provided as the
  /// intent parameter to IntentSender\#sendIntent.
  /// This value may be {@code null}.
  ///@param flagsMask Intent flags in the original IntentSender that you
  /// would like to change.
  ///@param flagsValues Desired values for any bits set in
  /// <var>flagsMask</var>
  ///@param extraFlags Always set to 0.
  void startIntentSenderForResult(
          content.IntentSender intent,
          int requestCode,
          content.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags) =>
      _startIntentSenderForResult(reference, intent.reference, requestCode,
          fillInIntent.reference, flagsMask, flagsValues, extraFlags);

  static final _startIntentSenderForResult_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_startIntentSenderForResult_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void startIntentSenderForResult(android.content.IntentSender intent, int requestCode, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, android.os.Bundle options)
  /// Like \#startActivityForResult(Intent, int), but allowing you
  /// to use a IntentSender to describe the activity to be started.  If
  /// the IntentSender is for an activity, that activity will be started
  /// as if you had called the regular \#startActivityForResult(Intent, int)
  /// here; otherwise, its associated action will be executed (such as
  /// sending a broadcast) as if you had called
  /// IntentSender\#sendIntent IntentSender.sendIntent on it.
  ///@param intent The IntentSender to launch.
  ///@param requestCode If >= 0, this code will be returned in
  ///                    onActivityResult() when the activity exits.
  ///@param fillInIntent If non-null, this will be provided as the
  /// intent parameter to IntentSender\#sendIntent.
  /// This value may be {@code null}.
  ///@param flagsMask Intent flags in the original IntentSender that you
  /// would like to change.
  ///@param flagsValues Desired values for any bits set in
  /// <var>flagsMask</var>
  ///@param extraFlags Always set to 0.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.  If options
  /// have also been supplied by the IntentSender, options given here will
  /// override any that conflict with those given by the IntentSender.
  void startIntentSenderForResult_1(
          content.IntentSender intent,
          int requestCode,
          content.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags,
          os.Bundle options) =>
      _startIntentSenderForResult_1(
          reference,
          intent.reference,
          requestCode,
          fillInIntent.reference,
          flagsMask,
          flagsValues,
          extraFlags,
          options.reference);

  static final _startActivity = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_startActivity")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivity(android.content.Intent intent)
  /// Same as \#startActivity(Intent, Bundle) with no options
  /// specified.
  ///@param intent The intent to start.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivity(Intent, Bundle)
  ///@see \#startActivityForResult
  void startActivity(content.Intent intent) =>
      _startActivity(reference, intent.reference);

  static final _startActivity_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_startActivity_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivity(android.content.Intent intent, android.os.Bundle options)
  /// Launch a new activity.  You will not receive any information about when
  /// the activity exits.  This implementation overrides the base version,
  /// providing information about
  /// the activity performing the launch.  Because of this additional
  /// information, the Intent\#FLAG_ACTIVITY_NEW_TASK launch flag is not
  /// required; if not specified, the new activity will be added to the
  /// task of the caller.
  ///
  /// This method throws android.content.ActivityNotFoundException
  /// if there was no Activity found to run the given Intent.
  ///@param intent The intent to start.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivity(Intent)
  ///@see \#startActivityForResult
  void startActivity_1(content.Intent intent, os.Bundle options) =>
      _startActivity_1(reference, intent.reference, options.reference);

  static final _startActivities = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_startActivities")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivities(android.content.Intent[] intents)
  /// Same as \#startActivities(Intent[], Bundle) with no options
  /// specified.
  ///@param intents The intents to start.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivities(Intent[], Bundle)
  ///@see \#startActivityForResult
  void startActivities(jni.JlObject intents) =>
      _startActivities(reference, intents.reference);

  static final _startActivities_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_startActivities_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivities(android.content.Intent[] intents, android.os.Bundle options)
  /// Launch a new activity.  You will not receive any information about when
  /// the activity exits.  This implementation overrides the base version,
  /// providing information about
  /// the activity performing the launch.  Because of this additional
  /// information, the Intent\#FLAG_ACTIVITY_NEW_TASK launch flag is not
  /// required; if not specified, the new activity will be added to the
  /// task of the caller.
  ///
  /// This method throws android.content.ActivityNotFoundException
  /// if there was no Activity found to run the given Intent.
  ///@param intents The intents to start.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivities(Intent[])
  ///@see \#startActivityForResult
  void startActivities_1(jni.JlObject intents, os.Bundle options) =>
      _startActivities_1(reference, intents.reference, options.reference);

  static final _startIntentSender = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("android_app_Activity_startIntentSender")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void startIntentSender(android.content.IntentSender intent, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)
  /// Same as calling \#startIntentSender(IntentSender, Intent, int, int, int, Bundle)
  /// with no options.
  ///@param intent The IntentSender to launch.
  ///@param fillInIntent If non-null, this will be provided as the
  /// intent parameter to IntentSender\#sendIntent.
  /// This value may be {@code null}.
  ///@param flagsMask Intent flags in the original IntentSender that you
  /// would like to change.
  ///@param flagsValues Desired values for any bits set in
  /// <var>flagsMask</var>
  ///@param extraFlags Always set to 0.
  void startIntentSender(
          content.IntentSender intent,
          content.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags) =>
      _startIntentSender(reference, intent.reference, fillInIntent.reference,
          flagsMask, flagsValues, extraFlags);

  static final _startIntentSender_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_startIntentSender_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void startIntentSender(android.content.IntentSender intent, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, android.os.Bundle options)
  /// Like \#startActivity(Intent, Bundle), but taking a IntentSender
  /// to start; see
  /// \#startIntentSenderForResult(IntentSender, int, Intent, int, int, int, Bundle)
  /// for more information.
  ///@param intent The IntentSender to launch.
  ///@param fillInIntent If non-null, this will be provided as the
  /// intent parameter to IntentSender\#sendIntent.
  /// This value may be {@code null}.
  ///@param flagsMask Intent flags in the original IntentSender that you
  /// would like to change.
  ///@param flagsValues Desired values for any bits set in
  /// <var>flagsMask</var>
  ///@param extraFlags Always set to 0.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.  If options
  /// have also been supplied by the IntentSender, options given here will
  /// override any that conflict with those given by the IntentSender.
  void startIntentSender_1(
          content.IntentSender intent,
          content.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags,
          os.Bundle options) =>
      _startIntentSender_1(reference, intent.reference, fillInIntent.reference,
          flagsMask, flagsValues, extraFlags, options.reference);

  static final _startActivityIfNeeded = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_startActivityIfNeeded")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean startActivityIfNeeded(android.content.Intent intent, int requestCode)
  /// Same as calling \#startActivityIfNeeded(Intent, int, Bundle)
  /// with no options.
  ///@param intent The intent to start.
  /// This value must never be {@code null}.
  ///@param requestCode If >= 0, this code will be returned in
  ///         onActivityResult() when the activity exits, as described in
  ///         \#startActivityForResult.
  ///@return If a new activity was launched then true is returned; otherwise
  ///         false is returned and you must handle the Intent yourself.
  ///@see \#startActivity
  ///@see \#startActivityForResult
  bool startActivityIfNeeded(content.Intent intent, int requestCode) =>
      _startActivityIfNeeded(reference, intent.reference, requestCode) != 0;

  static final _startActivityIfNeeded_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_startActivityIfNeeded_1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean startActivityIfNeeded(android.content.Intent intent, int requestCode, android.os.Bundle options)
  /// A special variation to launch an activity only if a new activity
  /// instance is needed to handle the given Intent.  In other words, this is
  /// just like \#startActivityForResult(Intent, int) except: if you are
  /// using the Intent\#FLAG_ACTIVITY_SINGLE_TOP flag, or
  /// singleTask or singleTop
  /// android.R.styleable\#AndroidManifestActivity_launchMode launchMode,
  /// and the activity
  /// that handles <var>intent</var> is the same as your currently running
  /// activity, then a new instance is not needed.  In this case, instead of
  /// the normal behavior of calling \#onNewIntent this function will
  /// return and you can handle the Intent yourself.
  ///
  /// This function can only be called from a top-level activity; if it is
  /// called from a child activity, a runtime exception will be thrown.
  ///@param intent The intent to start.
  /// This value must never be {@code null}.
  ///@param requestCode If >= 0, this code will be returned in
  ///         onActivityResult() when the activity exits, as described in
  ///         \#startActivityForResult.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@return If a new activity was launched then true is returned; otherwise
  ///         false is returned and you must handle the Intent yourself.
  ///@see \#startActivity
  ///@see \#startActivityForResult
  bool startActivityIfNeeded_1(
          content.Intent intent, int requestCode, os.Bundle options) =>
      _startActivityIfNeeded_1(
          reference, intent.reference, requestCode, options.reference) !=
      0;

  static final _startNextMatchingActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_startNextMatchingActivity")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean startNextMatchingActivity(android.content.Intent intent)
  /// Same as calling \#startNextMatchingActivity(Intent, Bundle) with
  /// no options.
  ///@param intent The intent to dispatch to the next activity.  For
  /// correct behavior, this must be the same as the Intent that started
  /// your own activity; the only changes you can make are to the extras
  /// inside of it.
  ///
  /// This value must never be {@code null}.
  ///@return Returns a boolean indicating whether there was another Activity
  /// to start: true if there was a next activity to start, false if there
  /// wasn't.  In general, if true is returned you will then want to call
  /// finish() on yourself.
  bool startNextMatchingActivity(content.Intent intent) =>
      _startNextMatchingActivity(reference, intent.reference) != 0;

  static final _startNextMatchingActivity_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_startNextMatchingActivity_1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean startNextMatchingActivity(android.content.Intent intent, android.os.Bundle options)
  /// Special version of starting an activity, for use when you are replacing
  /// other activity components.  You can use this to hand the Intent off
  /// to the next Activity that can handle it.  You typically call this in
  /// \#onCreate with the Intent returned by \#getIntent.
  ///@param intent The intent to dispatch to the next activity.  For
  /// correct behavior, this must be the same as the Intent that started
  /// your own activity; the only changes you can make are to the extras
  /// inside of it.
  /// This value must never be {@code null}.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@return Returns a boolean indicating whether there was another Activity
  /// to start: true if there was a next activity to start, false if there
  /// wasn't.  In general, if true is returned you will then want to call
  /// finish() on yourself.
  bool startNextMatchingActivity_1(content.Intent intent, os.Bundle options) =>
      _startNextMatchingActivity_1(
          reference, intent.reference, options.reference) !=
      0;

  static final _startActivityFromChild = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_startActivityFromChild")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void startActivityFromChild(android.app.Activity child, android.content.Intent intent, int requestCode)
  /// Same as calling \#startActivityFromChild(Activity, Intent, int, Bundle)
  /// with no options.
  ///@param child The activity making the call.
  /// This value must never be {@code null}.
  ///@param intent The intent to start.
  ///@param requestCode Reply request code.  < 0 if reply is not requested.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivity
  ///@see \#startActivityForResult
  void startActivityFromChild(
          Activity child, content.Intent intent, int requestCode) =>
      _startActivityFromChild(
          reference, child.reference, intent.reference, requestCode);

  static final _startActivityFromChild_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_startActivityFromChild_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivityFromChild(android.app.Activity child, android.content.Intent intent, int requestCode, android.os.Bundle options)
  /// This is called when a child activity of this one calls its
  /// \#startActivity or \#startActivityForResult method.
  ///
  /// This method throws android.content.ActivityNotFoundException
  /// if there was no Activity found to run the given Intent.
  ///@param child The activity making the call.
  /// This value must never be {@code null}.
  ///@param intent The intent to start.
  ///@param requestCode Reply request code.  < 0 if reply is not requested.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivity
  ///@see \#startActivityForResult
  void startActivityFromChild_1(Activity child, content.Intent intent,
          int requestCode, os.Bundle options) =>
      _startActivityFromChild_1(reference, child.reference, intent.reference,
          requestCode, options.reference);

  static final _startActivityFromFragment = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_startActivityFromFragment")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void startActivityFromFragment(android.app.Fragment fragment, android.content.Intent intent, int requestCode)
  /// Same as calling \#startActivityFromFragment(Fragment, Intent, int, Bundle)
  /// with no options.
  ///@param fragment The fragment making the call.
  /// This value must never be {@code null}.
  ///@param intent The intent to start.
  ///@param requestCode Reply request code.  < 0 if reply is not requested.
  ///@throws android.content.ActivityNotFoundException
  ///@see Fragment\#startActivity
  ///@see Fragment\#startActivityForResult
  ///@deprecated Use android.support.v4.app.FragmentActivity\#startActivityFromFragment(
  /// android.support.v4.app.Fragment,Intent,int)
  void startActivityFromFragment(
          Fragment fragment, content.Intent intent, int requestCode) =>
      _startActivityFromFragment(
          reference, fragment.reference, intent.reference, requestCode);

  static final _startActivityFromFragment_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_startActivityFromFragment_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivityFromFragment(android.app.Fragment fragment, android.content.Intent intent, int requestCode, android.os.Bundle options)
  /// This is called when a Fragment in this activity calls its
  /// Fragment\#startActivity or Fragment\#startActivityForResult
  /// method.
  ///
  /// This method throws android.content.ActivityNotFoundException
  /// if there was no Activity found to run the given Intent.
  ///@param fragment The fragment making the call.
  /// This value must never be {@code null}.
  ///@param intent The intent to start.
  ///@param requestCode Reply request code.  < 0 if reply is not requested.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@throws android.content.ActivityNotFoundException
  ///@see Fragment\#startActivity
  ///@see Fragment\#startActivityForResult
  ///@deprecated Use android.support.v4.app.FragmentActivity\#startActivityFromFragment(
  /// android.support.v4.app.Fragment,Intent,int,Bundle)
  void startActivityFromFragment_1(Fragment fragment, content.Intent intent,
          int requestCode, os.Bundle options) =>
      _startActivityFromFragment_1(reference, fragment.reference,
          intent.reference, requestCode, options.reference);

  static final _startIntentSenderFromChild = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32)>>(
          "android_app_Activity_startIntentSenderFromChild")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int)>();

  /// from: public void startIntentSenderFromChild(android.app.Activity child, android.content.IntentSender intent, int requestCode, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)
  /// Same as calling \#startIntentSenderFromChild(Activity, IntentSender,
  /// int, Intent, int, int, int, Bundle) with no options.
  void startIntentSenderFromChild(
          Activity child,
          content.IntentSender intent,
          int requestCode,
          content.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags) =>
      _startIntentSenderFromChild(
          reference,
          child.reference,
          intent.reference,
          requestCode,
          fillInIntent.reference,
          flagsMask,
          flagsValues,
          extraFlags);

  static final _startIntentSenderFromChild_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_startIntentSenderFromChild_1")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startIntentSenderFromChild(android.app.Activity child, android.content.IntentSender intent, int requestCode, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, android.os.Bundle options)
  /// Like \#startActivityFromChild(Activity, Intent, int), but
  /// taking a IntentSender; see
  /// \#startIntentSenderForResult(IntentSender, int, Intent, int, int, int)
  /// for more information.
  ///@param options This value may be {@code null}.
  void startIntentSenderFromChild_1(
          Activity child,
          content.IntentSender intent,
          int requestCode,
          content.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags,
          os.Bundle options) =>
      _startIntentSenderFromChild_1(
          reference,
          child.reference,
          intent.reference,
          requestCode,
          fillInIntent.reference,
          flagsMask,
          flagsValues,
          extraFlags,
          options.reference);

  static final _overridePendingTransition = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_app_Activity_overridePendingTransition")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void overridePendingTransition(int enterAnim, int exitAnim)
  /// Call immediately after one of the flavors of \#startActivity(Intent)
  /// or \#finish to specify an explicit transition animation to
  /// perform next.
  ///
  /// As of android.os.Build.VERSION_CODES\#JELLY_BEAN an alternative
  /// to using this with starting activities is to supply the desired animation
  /// information through a ActivityOptions bundle to
  /// \#startActivity(Intent, Bundle) or a related function.  This allows
  /// you to specify a custom animation even when starting an activity from
  /// outside the context of the current top activity.
  ///@param enterAnim A resource ID of the animation resource to use for
  /// the incoming activity.  Use 0 for no animation.
  ///@param exitAnim A resource ID of the animation resource to use for
  /// the outgoing activity.  Use 0 for no animation.
  void overridePendingTransition(int enterAnim, int exitAnim) =>
      _overridePendingTransition(reference, enterAnim, exitAnim);

  static final _setResult = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_setResult")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setResult(int resultCode)
  /// Call this to set the result that your activity will return to its
  /// caller.
  ///@param resultCode The result code to propagate back to the originating
  ///                   activity, often RESULT_CANCELED or RESULT_OK
  ///@see \#RESULT_CANCELED
  ///@see \#RESULT_OK
  ///@see \#RESULT_FIRST_USER
  ///@see \#setResult(int, Intent)
  void setResult(int resultCode) => _setResult(reference, resultCode);

  static final _setResult_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_setResult_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setResult(int resultCode, android.content.Intent data)
  /// Call this to set the result that your activity will return to its
  /// caller.
  ///
  /// As of android.os.Build.VERSION_CODES\#GINGERBREAD, the Intent
  /// you supply here can have Intent\#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION and/or Intent\#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION set.  This will grant the
  /// Activity receiving the result access to the specific URIs in the Intent.
  /// Access will remain until the Activity has finished (it will remain across the hosting
  /// process being killed and other temporary destruction) and will be added
  /// to any existing set of URI permissions it already holds.
  ///@param resultCode The result code to propagate back to the originating
  ///                   activity, often RESULT_CANCELED or RESULT_OK
  ///@param data The data to propagate back to the originating activity.
  ///@see \#RESULT_CANCELED
  ///@see \#RESULT_OK
  ///@see \#RESULT_FIRST_USER
  ///@see \#setResult(int)
  void setResult_1(int resultCode, content.Intent data) =>
      _setResult_1(reference, resultCode, data.reference);

  static final _getReferrer = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_getReferrer")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri getReferrer()
  /// Return information about who launched this activity.  If the launching Intent
  /// contains an android.content.Intent\#EXTRA_REFERRER Intent.EXTRA_REFERRER,
  /// that will be returned as-is; otherwise, if known, an
  /// Intent\#URI_ANDROID_APP_SCHEME android-app: referrer URI containing the
  /// package name that started the Intent will be returned.  This may return null if no
  /// referrer can be identified -- it is neither explicitly specified, nor is it known which
  /// application package was involved.
  ///
  /// If called while inside the handling of \#onNewIntent, this function will
  /// return the referrer that submitted that new intent to the activity.  Otherwise, it
  /// always returns the referrer of the original Intent.
  ///
  ///
  /// Note that this is _not_ a security feature -- you can not trust the
  /// referrer information, applications can spoof it.
  ///
  jni.JlObject getReferrer() => jni.JlObject.fromRef(_getReferrer(reference));

  static final _onProvideReferrer = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onProvideReferrer")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri onProvideReferrer()
  /// Override to generate the desired referrer for the content currently being shown
  /// by the app.  The default implementation returns null, meaning the referrer will simply
  /// be the android-app: of the package name of this activity.  Return a non-null Uri to
  /// have that supplied as the Intent\#EXTRA_REFERRER of any activities started from it.
  jni.JlObject onProvideReferrer() =>
      jni.JlObject.fromRef(_onProvideReferrer(reference));

  static final _getCallingPackage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getCallingPackage")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getCallingPackage()
  /// Return the name of the package that invoked this activity.  This is who
  /// the data in \#setResult setResult() will be sent to.  You can
  /// use this information to validate that the recipient is allowed to
  /// receive the data.
  ///
  /// <p class="note">Note: if the calling activity is not expecting a result (that is it
  /// did not use the \#startActivityForResult
  /// form that includes a request code), then the calling package will be
  /// null.
  ///
  ///
  /// <p class="note">Note: prior to android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2,
  /// the result from this method was unstable.  If the process hosting the calling
  /// package was no longer running, it would return null instead of the proper package
  /// name.  You can use \#getCallingActivity() and retrieve the package name
  /// from that instead.
  ///
  ///@return The package of the activity that will receive your
  ///         reply, or null if none.
  jni.JlString getCallingPackage() =>
      jni.JlString.fromRef(_getCallingPackage(reference));

  static final _getCallingActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getCallingActivity")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getCallingActivity()
  /// Return the name of the activity that invoked this activity.  This is
  /// who the data in \#setResult setResult() will be sent to.  You
  /// can use this information to validate that the recipient is allowed to
  /// receive the data.
  ///
  /// <p class="note">Note: if the calling activity is not expecting a result (that is it
  /// did not use the \#startActivityForResult
  /// form that includes a request code), then the calling package will be
  /// null.
  ///@return The ComponentName of the activity that will receive your
  ///         reply, or null if none.
  content.ComponentName getCallingActivity() =>
      content.ComponentName.fromRef(_getCallingActivity(reference));

  static final _setVisible = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Activity_setVisible")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setVisible(boolean visible)
  /// Control whether this activity's main window is visible.  This is intended
  /// only for the special case of an activity that is not going to show a
  /// UI itself, but can't just finish prior to onResume() because it needs
  /// to wait for a service binding or such.  Setting this to false allows
  /// you to prevent your UI from being shown during that time.
  ///
  /// The default value for this is taken from the
  /// android.R.attr\#windowNoDisplay attribute of the activity's theme.
  void setVisible(bool visible) => _setVisible(reference, visible ? 1 : 0);

  static final _isFinishing =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_isFinishing")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isFinishing()
  /// Check to see whether this activity is in the process of finishing,
  /// either because you called \#finish on it or someone else
  /// has requested that it finished.  This is often used in
  /// \#onPause to determine whether the activity is simply pausing or
  /// completely finishing.
  ///@return If the activity is finishing, returns true; else returns false.
  ///@see \#finish
  bool isFinishing() => _isFinishing(reference) != 0;

  static final _isDestroyed =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_isDestroyed")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isDestroyed()
  /// Returns true if the final \#onDestroy() call has been made
  /// on the Activity, so this instance is now dead.
  bool isDestroyed() => _isDestroyed(reference) != 0;

  static final _isChangingConfigurations =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_isChangingConfigurations")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isChangingConfigurations()
  /// Check to see whether this activity is in the process of being destroyed in order to be
  /// recreated with a new configuration. This is often used in
  /// \#onStop to determine whether the state needs to be cleaned up or will be passed
  /// on to the next instance of the activity via \#onRetainNonConfigurationInstance().
  ///@return If the activity is being torn down in order to be recreated with a new configuration,
  /// returns true; else returns false.
  bool isChangingConfigurations() => _isChangingConfigurations(reference) != 0;

  static final _recreate =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_recreate")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void recreate()
  /// Cause this Activity to be recreated with a new instance.  This results
  /// in essentially the same flow as when the Activity is created due to
  /// a configuration change -- the current instance will go through its
  /// lifecycle to \#onDestroy and a new instance then created after it.
  void recreate() => _recreate(reference);

  static final _finish =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_finish")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void finish()
  /// Call this when your activity is done and should be closed.  The
  /// ActivityResult is propagated back to whoever launched you via
  /// onActivityResult().
  void finish() => _finish(reference);

  static final _finishAffinity =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_finishAffinity")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void finishAffinity()
  /// Finish this activity as well as all activities immediately below it
  /// in the current task that have the same affinity.  This is typically
  /// used when an application can be launched on to another task (such as
  /// from an ACTION_VIEW of a content type it understands) and the user
  /// has used the up navigation to switch out of the current task and in
  /// to its own task.  In this case, if the user has navigated down into
  /// any other activities of the second application, all of those should
  /// be removed from the original task as part of the task switch.
  ///
  /// Note that this finish does _not_ allow you to deliver results
  /// to the previous activity, and an exception will be thrown if you are trying
  /// to do so.
  ///
  void finishAffinity() => _finishAffinity(reference);

  static final _finishFromChild = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_finishFromChild")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void finishFromChild(android.app.Activity child)
  /// This is called when a child activity of this one calls its
  /// \#finish method.  The default implementation simply calls
  /// finish() on this activity (the parent), finishing the entire group.
  ///@param child The activity making the call.
  ///@see \#finish
  void finishFromChild(Activity child) =>
      _finishFromChild(reference, child.reference);

  static final _finishAfterTransition =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_finishAfterTransition")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void finishAfterTransition()
  /// Reverses the Activity Scene entry Transition and triggers the calling Activity
  /// to reverse its exit Transition. When the exit Transition completes,
  /// \#finish() is called. If no entry Transition was used, finish() is called
  /// immediately and the Activity exit Transition is run.
  ///@see android.app.ActivityOptions\#makeSceneTransitionAnimation(Activity, android.util.Pair[])
  void finishAfterTransition() => _finishAfterTransition(reference);

  static final _finishActivity = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_finishActivity")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void finishActivity(int requestCode)
  /// Force finish another activity that you had previously started with
  /// \#startActivityForResult.
  ///@param requestCode The request code of the activity that you had
  ///                    given to startActivityForResult().  If there are multiple
  ///                    activities started with this request code, they
  ///                    will all be finished.
  void finishActivity(int requestCode) =>
      _finishActivity(reference, requestCode);

  static final _finishActivityFromChild = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_finishActivityFromChild")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void finishActivityFromChild(android.app.Activity child, int requestCode)
  /// This is called when a child activity of this one calls its
  /// finishActivity().
  ///@param child The activity making the call.
  /// This value must never be {@code null}.
  ///@param requestCode Request code that had been used to start the
  ///                    activity.
  void finishActivityFromChild(Activity child, int requestCode) =>
      _finishActivityFromChild(reference, child.reference, requestCode);

  static final _finishAndRemoveTask =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_finishAndRemoveTask")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void finishAndRemoveTask()
  /// Call this when your activity is done and should be closed and the task should be completely
  /// removed as a part of finishing the root activity of the task.
  void finishAndRemoveTask() => _finishAndRemoveTask(reference);

  static final _releaseInstance =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_releaseInstance")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean releaseInstance()
  /// Ask that the local app instance of this activity be released to free up its memory.
  /// This is asking for the activity to be destroyed, but does __not__ finish the activity --
  /// a new instance of the activity will later be re-created if needed due to the user
  /// navigating back to it.
  ///@return Returns true if the activity was in a state that it has started the process
  /// of destroying its current instance; returns false if for any reason this could not
  /// be done: it is currently visible to the user, it is already being destroyed, it is
  /// being finished, it hasn't yet saved its state, etc.
  bool releaseInstance() => _releaseInstance(reference) != 0;

  static final _onActivityResult = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onActivityResult")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onActivityResult(int requestCode, int resultCode, android.content.Intent data)
  /// Called when an activity you launched exits, giving you the requestCode
  /// you started it with, the resultCode it returned, and any additional
  /// data from it.  The <var>resultCode</var> will be
  /// \#RESULT_CANCELED if the activity explicitly returned that,
  /// didn't return any result, or crashed during its operation.
  ///
  /// You will receive this call immediately before onResume() when your
  /// activity is re-starting.
  ///
  /// This method is never invoked if your activity sets
  /// android.R.styleable\#AndroidManifestActivity_noHistory noHistory to
  /// <code>true</code>.
  ///@param requestCode The integer request code originally supplied to
  ///                    startActivityForResult(), allowing you to identify who this
  ///                    result came from.
  ///@param resultCode The integer result code returned by the child activity
  ///                   through its setResult().
  ///@param data An Intent, which can return result data to the caller
  ///               (various data can be attached to Intent "extras").
  ///@see \#startActivityForResult
  ///@see \#createPendingResult
  ///@see \#setResult(int)
  void onActivityResult(int requestCode, int resultCode, content.Intent data) =>
      _onActivityResult(reference, requestCode, resultCode, data.reference);

  static final _onActivityReenter = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onActivityReenter")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onActivityReenter(int resultCode, android.content.Intent data)
  /// Called when an activity you launched with an activity transition exposes this
  /// Activity through a returning activity transition, giving you the resultCode
  /// and any additional data from it. This method will only be called if the activity
  /// set a result code other than \#RESULT_CANCELED and it supports activity
  /// transitions with Window\#FEATURE_ACTIVITY_TRANSITIONS.
  ///
  /// The purpose of this function is to let the called Activity send a hint about
  /// its state so that this underlying Activity can prepare to be exposed. A call to
  /// this method does not guarantee that the called Activity has or will be exiting soon.
  /// It only indicates that it will expose this Activity's Window and it has
  /// some data to pass to prepare it.
  ///
  ///@param resultCode The integer result code returned by the child activity
  ///                   through its setResult().
  ///@param data An Intent, which can return result data to the caller
  ///               (various data can be attached to Intent "extras").
  void onActivityReenter(int resultCode, content.Intent data) =>
      _onActivityReenter(reference, resultCode, data.reference);

  static final _createPendingResult = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_createPendingResult")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.PendingIntent createPendingResult(int requestCode, android.content.Intent data, int flags)
  /// Create a new PendingIntent object which you can hand to others
  /// for them to use to send result data back to your
  /// \#onActivityResult callback.  The created object will be either
  /// one-shot (becoming invalid after a result is sent back) or multiple
  /// (allowing any number of results to be sent through it).
  ///@param requestCode Private request code for the sender that will be
  /// associated with the result data when it is returned.  The sender can not
  /// modify this value, allowing you to identify incoming results.
  ///@param data Default data to supply in the result, which may be modified
  /// by the sender.
  /// This value must never be {@code null}.
  ///@param flags May be PendingIntent\#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT,
  /// PendingIntent\#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE,
  /// PendingIntent\#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT,
  /// PendingIntent\#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT,
  /// or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if
  /// PendingIntent\#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE has been
  /// supplied.
  ///@see PendingIntent
  PendingIntent createPendingResult(
          int requestCode, content.Intent data, int flags) =>
      PendingIntent.fromRef(
          _createPendingResult(reference, requestCode, data.reference, flags));

  static final _setRequestedOrientation = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_setRequestedOrientation")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setRequestedOrientation(int requestedOrientation)
  /// Change the desired orientation of this activity.  If the activity
  /// is currently in the foreground or otherwise impacting the screen
  /// orientation, the screen will immediately be changed (possibly causing
  /// the activity to be restarted). Otherwise, this will be used the next
  /// time the activity is visible.
  ///@param requestedOrientation An orientation constant as used in
  /// ActivityInfo\#screenOrientation ActivityInfo.screenOrientation.
  ///
  /// Value is android.content.pm.ActivityInfo.SCREEN_ORIENTATION_UNSET, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_UNSPECIFIED, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_BEHIND, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_NOSENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_REVERSE_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_REVERSE_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_FULL_SENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_FULL_USER, or android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_LOCKED
  void setRequestedOrientation(int requestedOrientation) =>
      _setRequestedOrientation(reference, requestedOrientation);

  static final _getRequestedOrientation =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_getRequestedOrientation")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getRequestedOrientation()
  /// Return the current requested orientation of the activity.  This will
  /// either be the orientation requested in its component's manifest, or
  /// the last requested orientation given to
  /// \#setRequestedOrientation(int).
  ///@return Returns an orientation constant as used in
  /// ActivityInfo\#screenOrientation ActivityInfo.screenOrientation.
  ///
  /// Value is android.content.pm.ActivityInfo.SCREEN_ORIENTATION_UNSET, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_UNSPECIFIED, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_BEHIND, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_NOSENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_REVERSE_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_REVERSE_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_FULL_SENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_FULL_USER, or android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_LOCKED
  int getRequestedOrientation() => _getRequestedOrientation(reference);

  static final _getTaskId =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_getTaskId")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getTaskId()
  /// Return the identifier of the task this activity is in.  This identifier
  /// will remain the same for the lifetime of the activity.
  ///@return Task identifier, an opaque integer.
  int getTaskId() => _getTaskId(reference);

  static final _isTaskRoot =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_isTaskRoot")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isTaskRoot()
  /// Return whether this activity is the root of a task.  The root is the
  /// first activity in a task.
  ///@return True if this is the root activity, else false.
  bool isTaskRoot() => _isTaskRoot(reference) != 0;

  static final _moveTaskToBack = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Activity_moveTaskToBack")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean moveTaskToBack(boolean nonRoot)
  /// Move the task containing this activity to the back of the activity
  /// stack.  The activity's order within the task is unchanged.
  ///@param nonRoot If false then this only works if the activity is the root
  ///                of a task; if true it will work for any activity in
  ///                a task.
  ///@return If the task was moved (or it was already at the
  ///         back) true is returned, else false.
  bool moveTaskToBack(bool nonRoot) =>
      _moveTaskToBack(reference, nonRoot ? 1 : 0) != 0;

  static final _getLocalClassName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getLocalClassName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getLocalClassName()
  /// Returns class name for this activity with the package prefix removed.
  /// This is the default name used to read and write settings.
  ///@return The local class name.
  ///
  /// This value will never be {@code null}.
  jni.JlString getLocalClassName() =>
      jni.JlString.fromRef(_getLocalClassName(reference));

  static final _getComponentName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getComponentName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getComponentName()
  /// Returns the complete component name of this activity.
  ///@return Returns the complete component name for this activity
  content.ComponentName getComponentName() =>
      content.ComponentName.fromRef(_getComponentName(reference));

  static final _getPreferences = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_getPreferences")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.SharedPreferences getPreferences(int mode)
  /// Retrieve a SharedPreferences object for accessing preferences
  /// that are private to this activity.  This simply calls the underlying
  /// \#getSharedPreferences(String, int) method by passing in this activity's
  /// class name as the preferences name.
  ///@param mode Operating mode.  Use \#MODE_PRIVATE for the default
  ///             operation.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Context\#MODE_PRIVATE, android.content.Context\#MODE_WORLD_READABLE, android.content.Context\#MODE_WORLD_WRITEABLE, and android.content.Context\#MODE_MULTI_PROCESS
  ///@return Returns the single SharedPreferences instance that can be used
  ///         to retrieve and modify the preference values.
  content.SharedPreferences getPreferences(int mode) =>
      content.SharedPreferences.fromRef(_getPreferences(reference, mode));

  static final _getSystemService = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getSystemService")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object getSystemService(java.lang.String name)
  /// @param name Value is android.content.Context\#POWER_SERVICE, android.content.Context\#WINDOW_SERVICE, android.content.Context\#LAYOUT_INFLATER_SERVICE, android.content.Context\#ACCOUNT_SERVICE, android.content.Context\#ACTIVITY_SERVICE, android.content.Context\#ALARM_SERVICE, android.content.Context\#NOTIFICATION_SERVICE, android.content.Context\#ACCESSIBILITY_SERVICE, android.content.Context\#CAPTIONING_SERVICE, android.content.Context\#KEYGUARD_SERVICE, android.content.Context\#LOCATION_SERVICE, android.content.Context\#SEARCH_SERVICE, android.content.Context\#SENSOR_SERVICE, android.content.Context\#STORAGE_SERVICE, android.content.Context\#STORAGE_STATS_SERVICE, android.content.Context\#WALLPAPER_SERVICE, android.content.Context.TIME_ZONE_RULES_MANAGER_SERVICE, android.content.Context\#VIBRATOR_SERVICE, android.content.Context\#CONNECTIVITY_SERVICE, android.content.Context\#IPSEC_SERVICE, android.content.Context\#NETWORK_STATS_SERVICE, android.content.Context\#WIFI_SERVICE, android.content.Context\#WIFI_AWARE_SERVICE, android.content.Context\#WIFI_P2P_SERVICE, android.content.Context.WIFI_SCANNING_SERVICE, android.content.Context\#WIFI_RTT_RANGING_SERVICE, android.content.Context\#NSD_SERVICE, android.content.Context\#AUDIO_SERVICE, android.content.Context\#FINGERPRINT_SERVICE, android.content.Context\#MEDIA_ROUTER_SERVICE, android.content.Context\#TELEPHONY_SERVICE, android.content.Context\#TELEPHONY_SUBSCRIPTION_SERVICE, android.content.Context\#CARRIER_CONFIG_SERVICE, android.content.Context\#TELECOM_SERVICE, android.content.Context\#CLIPBOARD_SERVICE, android.content.Context\#INPUT_METHOD_SERVICE, android.content.Context\#TEXT_SERVICES_MANAGER_SERVICE, android.content.Context\#TEXT_CLASSIFICATION_SERVICE, android.content.Context\#APPWIDGET_SERVICE, android.content.Context\#DROPBOX_SERVICE, android.content.Context\#DEVICE_POLICY_SERVICE, android.content.Context\#UI_MODE_SERVICE, android.content.Context\#DOWNLOAD_SERVICE, android.content.Context\#NFC_SERVICE, android.content.Context\#BLUETOOTH_SERVICE, android.content.Context\#USB_SERVICE, android.content.Context\#LAUNCHER_APPS_SERVICE, android.content.Context\#INPUT_SERVICE, android.content.Context\#DISPLAY_SERVICE, android.content.Context\#USER_SERVICE, android.content.Context\#RESTRICTIONS_SERVICE, android.content.Context\#APP_OPS_SERVICE, android.content.Context\#CAMERA_SERVICE, android.content.Context\#PRINT_SERVICE, android.content.Context\#CONSUMER_IR_SERVICE, android.content.Context\#TV_INPUT_SERVICE, android.content.Context\#USAGE_STATS_SERVICE, android.content.Context\#MEDIA_SESSION_SERVICE, android.content.Context\#BATTERY_SERVICE, android.content.Context\#JOB_SCHEDULER_SERVICE, android.content.Context\#MEDIA_PROJECTION_SERVICE, android.content.Context\#MIDI_SERVICE, android.content.Context.RADIO_SERVICE, android.content.Context\#HARDWARE_PROPERTIES_SERVICE, android.content.Context\#SHORTCUT_SERVICE, android.content.Context\#SYSTEM_HEALTH_SERVICE, android.content.Context\#COMPANION_DEVICE_SERVICE, or android.content.Context\#CROSS_PROFILE_APPS_SERVICE
  ///
  /// This value must never be {@code null}.
  jni.JlObject getSystemService(jni.JlString name) =>
      jni.JlObject.fromRef(_getSystemService(reference, name.reference));

  static final _setTitle = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_setTitle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTitle(java.lang.CharSequence title)
  /// Change the title associated with this activity.  If this is a
  /// top-level activity, the title for its window will change.  If it
  /// is an embedded activity, the parent can do whatever it wants
  /// with it.
  void setTitle(jni.JlObject title) => _setTitle(reference, title.reference);

  static final _setTitle_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_setTitle_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setTitle(int titleId)
  /// Change the title associated with this activity.  If this is a
  /// top-level activity, the title for its window will change.  If it
  /// is an embedded activity, the parent can do whatever it wants
  /// with it.
  void setTitle_1(int titleId) => _setTitle_1(reference, titleId);

  static final _setTitleColor = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_setTitleColor")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setTitleColor(int textColor)
  /// Change the color of the title associated with this activity.
  ///
  /// This method is deprecated starting in API Level 11 and replaced by action
  /// bar styles. For information on styling the Action Bar, read the <a href="{@docRoot} guide/topics/ui/actionbar.html">Action Bar</a> developer
  /// guide.
  ///@deprecated Use action bar styles instead.
  void setTitleColor(int textColor) => _setTitleColor(reference, textColor);

  static final _getTitle = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_getTitle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.CharSequence getTitle()
  jni.JlObject getTitle() => jni.JlObject.fromRef(_getTitle(reference));

  static final _getTitleColor =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_getTitleColor")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getTitleColor()
  int getTitleColor() => _getTitleColor(reference);

  static final _onTitleChanged = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_onTitleChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: protected void onTitleChanged(java.lang.CharSequence title, int color)
  void onTitleChanged(jni.JlObject title, int color) =>
      _onTitleChanged(reference, title.reference, color);

  static final _onChildTitleChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onChildTitleChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void onChildTitleChanged(android.app.Activity childActivity, java.lang.CharSequence title)
  void onChildTitleChanged(Activity childActivity, jni.JlObject title) =>
      _onChildTitleChanged(reference, childActivity.reference, title.reference);

  static final _setTaskDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_setTaskDescription")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTaskDescription(android.app.ActivityManager.TaskDescription taskDescription)
  /// Sets information describing the task with this activity for presentation inside the Recents
  /// System UI. When ActivityManager\#getRecentTasks is called, the activities of each task
  /// are traversed in order from the topmost activity to the bottommost. The traversal continues
  /// for each property until a suitable value is found. For each task the taskDescription will be
  /// returned in android.app.ActivityManager.TaskDescription.
  ///@see ActivityManager\#getRecentTasks
  ///@see android.app.ActivityManager.TaskDescription
  ///@param taskDescription The TaskDescription properties that describe the task with this activity
  void setTaskDescription(ActivityManager_TaskDescription taskDescription) =>
      _setTaskDescription(reference, taskDescription.reference);

  static final _setProgressBarVisibility = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Activity_setProgressBarVisibility")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setProgressBarVisibility(boolean visible)
  /// Sets the visibility of the progress bar in the title.
  ///
  /// In order for the progress bar to be shown, the feature must be requested
  /// via \#requestWindowFeature(int).
  ///@param visible Whether to show the progress bars in the title.
  ///@deprecated No longer supported starting in API 21.
  void setProgressBarVisibility(bool visible) =>
      _setProgressBarVisibility(reference, visible ? 1 : 0);

  static final _setProgressBarIndeterminateVisibility = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Activity_setProgressBarIndeterminateVisibility")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setProgressBarIndeterminateVisibility(boolean visible)
  /// Sets the visibility of the indeterminate progress bar in the title.
  ///
  /// In order for the progress bar to be shown, the feature must be requested
  /// via \#requestWindowFeature(int).
  ///@param visible Whether to show the progress bars in the title.
  ///@deprecated No longer supported starting in API 21.
  void setProgressBarIndeterminateVisibility(bool visible) =>
      _setProgressBarIndeterminateVisibility(reference, visible ? 1 : 0);

  static final _setProgressBarIndeterminate = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Activity_setProgressBarIndeterminate")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setProgressBarIndeterminate(boolean indeterminate)
  /// Sets whether the horizontal progress bar in the title should be indeterminate (the circular
  /// is always indeterminate).
  ///
  /// In order for the progress bar to be shown, the feature must be requested
  /// via \#requestWindowFeature(int).
  ///@param indeterminate Whether the horizontal progress bar should be indeterminate.
  ///@deprecated No longer supported starting in API 21.
  void setProgressBarIndeterminate(bool indeterminate) =>
      _setProgressBarIndeterminate(reference, indeterminate ? 1 : 0);

  static final _setProgress = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_setProgress")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setProgress(int progress)
  /// Sets the progress for the progress bars in the title.
  ///
  /// In order for the progress bar to be shown, the feature must be requested
  /// via \#requestWindowFeature(int).
  ///@param progress The progress for the progress bar. Valid ranges are from
  ///            0 to 10000 (both inclusive). If 10000 is given, the progress
  ///            bar will be completely filled and will fade out.
  ///@deprecated No longer supported starting in API 21.
  void setProgress(int progress) => _setProgress(reference, progress);

  static final _setSecondaryProgress = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_setSecondaryProgress")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setSecondaryProgress(int secondaryProgress)
  /// Sets the secondary progress for the progress bar in the title. This
  /// progress is drawn between the primary progress (set via
  /// \#setProgress(int) and the background. It can be ideal for media
  /// scenarios such as showing the buffering progress while the default
  /// progress shows the play progress.
  ///
  /// In order for the progress bar to be shown, the feature must be requested
  /// via \#requestWindowFeature(int).
  ///@param secondaryProgress The secondary progress for the progress bar. Valid ranges are from
  ///            0 to 10000 (both inclusive).
  ///@deprecated No longer supported starting in API 21.
  void setSecondaryProgress(int secondaryProgress) =>
      _setSecondaryProgress(reference, secondaryProgress);

  static final _setVolumeControlStream = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_setVolumeControlStream")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setVolumeControlStream(int streamType)
  /// Suggests an audio stream whose volume should be changed by the hardware
  /// volume controls.
  ///
  /// The suggested audio stream will be tied to the window of this Activity.
  /// Volume requests which are received while the Activity is in the
  /// foreground will affect this stream.
  ///
  /// It is not guaranteed that the hardware volume controls will always change
  /// this stream's volume (for example, if a call is in progress, its stream's
  /// volume may be changed instead). To reset back to the default, use
  /// AudioManager\#USE_DEFAULT_STREAM_TYPE.
  ///@param streamType The type of the audio stream whose volume should be
  ///            changed by the hardware volume controls.
  void setVolumeControlStream(int streamType) =>
      _setVolumeControlStream(reference, streamType);

  static final _getVolumeControlStream =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_getVolumeControlStream")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getVolumeControlStream()
  /// Gets the suggested audio stream whose volume should be changed by the
  /// hardware volume controls.
  ///@return The suggested audio stream type whose volume should be changed by
  ///         the hardware volume controls.
  ///@see \#setVolumeControlStream(int)
  int getVolumeControlStream() => _getVolumeControlStream(reference);

  static final _setMediaController = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_setMediaController")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setMediaController(android.media.session.MediaController controller)
  /// Sets a MediaController to send media keys and volume changes to.
  ///
  /// The controller will be tied to the window of this Activity. Media key and
  /// volume events which are received while the Activity is in the foreground
  /// will be forwarded to the controller and used to invoke transport controls
  /// or adjust the volume. This may be used instead of or in addition to
  /// \#setVolumeControlStream to affect a specific session instead of a
  /// specific stream.
  ///
  /// It is not guaranteed that the hardware volume controls will always change
  /// this session's volume (for example, if a call is in progress, its
  /// stream's volume may be changed instead). To reset back to the default use
  /// null as the controller.
  ///@param controller The controller for the session which should receive
  ///            media keys and volume changes.
  void setMediaController(jni.JlObject controller) =>
      _setMediaController(reference, controller.reference);

  static final _getMediaController = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getMediaController")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.media.session.MediaController getMediaController()
  /// Gets the controller which should be receiving media key and volume events
  /// while this activity is in the foreground.
  ///@return The controller which should receive events.
  ///@see \#setMediaController(android.media.session.MediaController)
  jni.JlObject getMediaController() =>
      jni.JlObject.fromRef(_getMediaController(reference));

  static final _runOnUiThread = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_runOnUiThread")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void runOnUiThread(java.lang.Runnable action)
  /// Runs the specified action on the UI thread. If the current thread is the UI
  /// thread, then the action is executed immediately. If the current thread is
  /// not the UI thread, the action is posted to the event queue of the UI thread.
  ///@param action the action to run on the UI thread
  void runOnUiThread(jni.JlObject action) =>
      _runOnUiThread(reference, action.reference);

  static final _onCreateView = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_onCreateView")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View onCreateView(java.lang.String name, android.content.Context context, android.util.AttributeSet attrs)
  /// Standard implementation of
  /// android.view.LayoutInflater.Factory\#onCreateView used when
  /// inflating with the LayoutInflater returned by \#getSystemService.
  /// This implementation does nothing and is for
  /// pre-android.os.Build.VERSION_CODES\#HONEYCOMB apps.  Newer apps
  /// should use \#onCreateView(View, String, Context, AttributeSet).
  ///@see android.view.LayoutInflater\#createView
  ///@see android.view.Window\#getLayoutInflater
  ///@return This value may be {@code null}.
  jni.JlObject onCreateView(
          jni.JlString name, content.Context context, jni.JlObject attrs) =>
      jni.JlObject.fromRef(_onCreateView(
          reference, name.reference, context.reference, attrs.reference));

  static final _onCreateView_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onCreateView_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View onCreateView(android.view.View parent, java.lang.String name, android.content.Context context, android.util.AttributeSet attrs)
  /// Standard implementation of
  /// android.view.LayoutInflater.Factory2\#onCreateView(View, String, Context, AttributeSet)
  /// used when inflating with the LayoutInflater returned by \#getSystemService.
  /// This implementation handles <fragment> tags to embed fragments inside
  /// of the activity.
  ///@see android.view.LayoutInflater\#createView
  ///@see android.view.Window\#getLayoutInflater
  jni.JlObject onCreateView_1(jni.JlObject parent, jni.JlString name,
          content.Context context, jni.JlObject attrs) =>
      jni.JlObject.fromRef(_onCreateView_1(reference, parent.reference,
          name.reference, context.reference, attrs.reference));

  static final _dump = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_dump")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  /// Print the Activity's state into the given stream.  This gets invoked if
  /// you run "adb shell dumpsys activity &lt;activity_component_name&gt;".
  ///@param prefix Desired prefix to prepend at each line of output.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer The PrintWriter to which you should dump your state.  This will be
  /// closed for you after you return.
  ///@param args additional arguments to the dump request.
  void dump(jni.JlString prefix, jni.JlObject fd, jni.JlObject writer,
          jni.JlObject args) =>
      _dump(reference, prefix.reference, fd.reference, writer.reference,
          args.reference);

  static final _isImmersive =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_isImmersive")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isImmersive()
  /// Bit indicating that this activity is "immersive" and should not be
  /// interrupted by notifications if possible.
  ///
  /// This value is initially set by the manifest property
  /// <code>android:immersive</code> but may be changed at runtime by
  /// \#setImmersive.
  ///@see \#setImmersive(boolean)
  ///@see android.content.pm.ActivityInfo\#FLAG_IMMERSIVE
  bool isImmersive() => _isImmersive(reference) != 0;

  static final _requestVisibleBehind = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Activity_requestVisibleBehind")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean requestVisibleBehind(boolean visible)
  /// Activities that want to remain visible behind a translucent activity above them must call
  /// this method anytime between the start of \#onResume() and the return from
  /// \#onPause(). If this call is successful then the activity will remain visible after
  /// \#onPause() is called, and is allowed to continue playing media in the background.
  ///
  /// The actions of this call are reset each time that this activity is brought to the
  /// front. That is, every time \#onResume() is called the activity will be assumed
  /// to not have requested visible behind. Therefore, if you want this activity to continue to
  /// be visible in the background you must call this method again.
  ///
  /// Only fullscreen opaque activities may make this call. I.e. this call is a nop
  /// for dialog and translucent activities.
  ///
  /// Under all circumstances, the activity must stop playing and release resources prior to or
  /// within a call to \#onVisibleBehindCanceled() or if this call returns false.
  ///
  /// False will be returned any time this method is called between the return of onPause and
  ///      the next call to onResume.
  ///@deprecated This method's functionality is no longer supported as of
  ///             android.os.Build.VERSION_CODES\#O and will be removed in a future release.
  ///@param visible true to notify the system that the activity wishes to be visible behind other
  ///                translucent activities, false to indicate otherwise. Resources must be
  ///                released when passing false to this method.
  ///@return the resulting visibiity state. If true the activity will remain visible beyond
  ///      \#onPause() if the next activity is translucent or not fullscreen. If false
  ///      then the activity may not count on being visible behind other translucent activities,
  ///      and must stop any media playback and release resources.
  ///      Returning false may occur in lieu of a call to \#onVisibleBehindCanceled() so
  ///      the return value must be checked.
  ///@see \#onVisibleBehindCanceled()
  bool requestVisibleBehind(bool visible) =>
      _requestVisibleBehind(reference, visible ? 1 : 0) != 0;

  static final _onVisibleBehindCanceled =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onVisibleBehindCanceled")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onVisibleBehindCanceled()
  /// Called when a translucent activity over this activity is becoming opaque or another
  /// activity is being launched. Activities that override this method must call
  /// <code>super.onVisibleBehindCanceled()</code> or a SuperNotCalledException will be thrown.
  ///
  /// When this method is called the activity has 500 msec to release any resources it may be
  /// using while visible in the background.
  /// If the activity has not returned from this method in 500 msec the system will destroy
  /// the activity and kill the process in order to recover the resources for another
  /// process. Otherwise \#onStop() will be called following return.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#requestVisibleBehind(boolean)
  ///@deprecated This method's functionality is no longer supported as of
  /// android.os.Build.VERSION_CODES\#O and will be removed in a future release.
  void onVisibleBehindCanceled() => _onVisibleBehindCanceled(reference);

  static final _onEnterAnimationComplete =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_onEnterAnimationComplete")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onEnterAnimationComplete()
  /// Activities cannot draw during the period that their windows are animating in. In order
  /// to know when it is safe to begin drawing they can override this method which will be
  /// called when the entering animation has completed.
  void onEnterAnimationComplete() => _onEnterAnimationComplete(reference);

  static final _setImmersive = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Activity_setImmersive")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setImmersive(boolean i)
  /// Adjust the current immersive mode setting.
  ///
  /// Note that changing this value will have no effect on the activity's
  /// android.content.pm.ActivityInfo structure; that is, if
  /// <code>android:immersive</code> is set to <code>true</code>
  /// in the application's manifest entry for this activity, the android.content.pm.ActivityInfo\#flags ActivityInfo.flags member will
  /// always have its android.content.pm.ActivityInfo\#FLAG_IMMERSIVE FLAG_IMMERSIVE bit set.
  ///@see \#isImmersive()
  ///@see android.content.pm.ActivityInfo\#FLAG_IMMERSIVE
  void setImmersive(bool i) => _setImmersive(reference, i ? 1 : 0);

  static final _setVrModeEnabled = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_setVrModeEnabled")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void setVrModeEnabled(boolean enabled, android.content.ComponentName requestedComponent)
  /// Enable or disable virtual reality (VR) mode for this Activity.
  ///
  /// VR mode is a hint to Android system to switch to a mode optimized for VR applications
  /// while this Activity has user focus.
  ///
  ///
  /// It is recommended that applications additionally declare
  /// android.R.attr\#enableVrMode in their manifest to allow for smooth activity
  /// transitions when switching between VR activities.
  ///
  ///
  /// If the requested android.service.vr.VrListenerService component is not available,
  /// VR mode will not be started.  Developers can handle this case as follows:
  ///
  ///
  /// <pre>
  /// String servicePackage = "com.whatever.app";
  /// String serviceClass = "com.whatever.app.MyVrListenerService";
  ///
  /// // Name of the component of the VrListenerService to start.
  /// ComponentName serviceComponent = new ComponentName(servicePackage, serviceClass);
  ///
  /// try {
  ///    setVrModeEnabled(true, myComponentName);
  /// } catch (PackageManager.NameNotFoundException e) {
  ///        List&lt;ApplicationInfo> installed = getPackageManager().getInstalledApplications(0);
  ///        boolean isInstalled = false;
  ///        for (ApplicationInfo app : installed) {
  ///            if (app.packageName.equals(servicePackage)) {
  ///                isInstalled = true;
  ///                break;
  ///            }
  ///        }
  ///        if (isInstalled) {
  ///            // Package is installed, but not enabled in Settings.  Let user enable it.
  ///            startActivity(new Intent(Settings.ACTION_VR_LISTENER_SETTINGS));
  ///        } else {
  ///            // Package is not installed.  Send an intent to download this.
  ///            sentIntentToLaunchAppStore(servicePackage);
  ///        }
  /// }
  /// </pre>
  ///@param enabled {@code true} to enable this mode.
  ///@param requestedComponent the name of the component to use as a
  ///        android.service.vr.VrListenerService while VR mode is enabled.
  ///
  /// This value must never be {@code null}.
  ///@throws android.content.pm.PackageManager.NameNotFoundException if the given component
  ///    to run as a android.service.vr.VrListenerService is not installed, or has
  ///    not been enabled in user settings.
  ///@see android.content.pm.PackageManager\#FEATURE_VR_MODE_HIGH_PERFORMANCE
  ///@see android.service.vr.VrListenerService
  ///@see android.provider.Settings\#ACTION_VR_LISTENER_SETTINGS
  ///@see android.R.attr\#enableVrMode
  void setVrModeEnabled(
          bool enabled, content.ComponentName requestedComponent) =>
      _setVrModeEnabled(
          reference, enabled ? 1 : 0, requestedComponent.reference);

  static final _startActionMode = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_startActionMode")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.ActionMode startActionMode(android.view.ActionMode.Callback callback)
  /// Start an action mode of the default type ActionMode\#TYPE_PRIMARY.
  ///@param callback Callback that will manage lifecycle events for this action mode
  ///@return The ActionMode that was started, or null if it was canceled
  ///@see ActionMode
  jni.JlObject startActionMode(jni.JlObject callback) =>
      jni.JlObject.fromRef(_startActionMode(reference, callback.reference));

  static final _startActionMode_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Activity_startActionMode_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.ActionMode startActionMode(android.view.ActionMode.Callback callback, int type)
  /// Start an action mode of the given type.
  ///@param callback Callback that will manage lifecycle events for this action mode
  ///@param type One of ActionMode\#TYPE_PRIMARY or ActionMode\#TYPE_FLOATING.
  ///@return The ActionMode that was started, or null if it was canceled
  ///@see ActionMode
  jni.JlObject startActionMode_1(jni.JlObject callback, int type) =>
      jni.JlObject.fromRef(
          _startActionMode_1(reference, callback.reference, type));

  static final _onWindowStartingActionMode = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onWindowStartingActionMode")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback)
  /// Give the Activity a chance to control the UI for an action mode requested
  /// by the system.
  ///
  /// Note: If you are looking for a notification callback that an action mode
  /// has been started for this activity, see \#onActionModeStarted(ActionMode).
  ///
  ///@param callback The callback that should control the new action mode
  ///@return The new action mode, or <code>null</code> if the activity does not want to
  ///         provide special handling for this action mode. (It will be handled by the system.)
  jni.JlObject onWindowStartingActionMode(jni.JlObject callback) =>
      jni.JlObject.fromRef(
          _onWindowStartingActionMode(reference, callback.reference));

  static final _onWindowStartingActionMode_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_Activity_onWindowStartingActionMode_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback, int type)
  /// {@inheritDoc}
  ///@return This value may be {@code null}.
  jni.JlObject onWindowStartingActionMode_1(jni.JlObject callback, int type) =>
      jni.JlObject.fromRef(
          _onWindowStartingActionMode_1(reference, callback.reference, type));

  static final _onActionModeStarted = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onActionModeStarted")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onActionModeStarted(android.view.ActionMode mode)
  /// Notifies the Activity that an action mode has been started.
  /// Activity subclasses overriding this method should call the superclass implementation.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param mode The new action mode.
  void onActionModeStarted(jni.JlObject mode) =>
      _onActionModeStarted(reference, mode.reference);

  static final _onActionModeFinished = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_onActionModeFinished")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onActionModeFinished(android.view.ActionMode mode)
  /// Notifies the activity that an action mode has finished.
  /// Activity subclasses overriding this method should call the superclass implementation.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param mode The action mode that just finished.
  void onActionModeFinished(jni.JlObject mode) =>
      _onActionModeFinished(reference, mode.reference);

  static final _shouldUpRecreateTask = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_shouldUpRecreateTask")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldUpRecreateTask(android.content.Intent targetIntent)
  /// Returns true if the app should recreate the task when navigating 'up' from this activity
  /// by using targetIntent.
  ///
  /// If this method returns false the app can trivially call
  /// \#navigateUpTo(Intent) using the same parameters to correctly perform
  /// up navigation. If this method returns false, the app should synthesize a new task stack
  /// by using TaskStackBuilder or another similar mechanism to perform up navigation.
  ///
  ///@param targetIntent An intent representing the target destination for up navigation
  ///@return true if navigating up should recreate a new task stack, false if the same task
  ///         should be used for the destination
  bool shouldUpRecreateTask(content.Intent targetIntent) =>
      _shouldUpRecreateTask(reference, targetIntent.reference) != 0;

  static final _navigateUpTo = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Activity_navigateUpTo")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean navigateUpTo(android.content.Intent upIntent)
  /// Navigate from this activity to the activity specified by upIntent, finishing this activity
  /// in the process. If the activity indicated by upIntent already exists in the task's history,
  /// this activity and all others before the indicated activity in the history stack will be
  /// finished.
  ///
  /// If the indicated activity does not appear in the history stack, this will finish
  /// each activity in this task until the root activity of the task is reached, resulting in
  /// an "in-app home" behavior. This can be useful in apps with a complex navigation hierarchy
  /// when an activity may be reached by a path not passing through a canonical parent
  /// activity.
  ///
  ///
  /// This method should be used when performing up navigation from within the same task
  /// as the destination. If up navigation should cross tasks in some cases, see
  /// \#shouldUpRecreateTask(Intent).
  ///
  ///@param upIntent An intent representing the target destination for up navigation
  ///@return true if up navigation successfully reached the activity indicated by upIntent and
  ///         upIntent was delivered to it. false if an instance of the indicated activity could
  ///         not be found and this activity was simply finished normally.
  bool navigateUpTo(content.Intent upIntent) =>
      _navigateUpTo(reference, upIntent.reference) != 0;

  static final _navigateUpToFromChild = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_navigateUpToFromChild")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean navigateUpToFromChild(android.app.Activity child, android.content.Intent upIntent)
  /// This is called when a child activity of this one calls its
  /// \#navigateUpTo method.  The default implementation simply calls
  /// navigateUpTo(upIntent) on this activity (the parent).
  ///@param child The activity making the call.
  ///@param upIntent An intent representing the target destination for up navigation
  ///@return true if up navigation successfully reached the activity indicated by upIntent and
  ///         upIntent was delivered to it. false if an instance of the indicated activity could
  ///         not be found and this activity was simply finished normally.
  bool navigateUpToFromChild(Activity child, content.Intent upIntent) =>
      _navigateUpToFromChild(reference, child.reference, upIntent.reference) !=
      0;

  static final _getParentActivityIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_getParentActivityIntent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent getParentActivityIntent()
  /// Obtain an Intent that will launch an explicit target activity specified by
  /// this activity's logical parent. The logical parent is named in the application's manifest
  /// by the android.R.attr\#parentActivityName parentActivityName attribute.
  /// Activity subclasses may override this method to modify the Intent returned by
  /// super.getParentActivityIntent() or to implement a different mechanism of retrieving
  /// the parent intent entirely.
  ///@return a new Intent targeting the defined parent of this activity or null if
  ///         there is no valid parent.
  content.Intent getParentActivityIntent() =>
      content.Intent.fromRef(_getParentActivityIntent(reference));

  static final _setEnterSharedElementCallback = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_setEnterSharedElementCallback")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setEnterSharedElementCallback(android.app.SharedElementCallback callback)
  /// When android.app.ActivityOptions\#makeSceneTransitionAnimation(Activity,
  /// android.view.View, String) was used to start an Activity, <var>callback</var>
  /// will be called to handle shared elements on the <i>launched</i> Activity. This requires
  /// Window\#FEATURE_ACTIVITY_TRANSITIONS.
  ///@param callback Used to manipulate shared element transitions on the launched Activity.
  void setEnterSharedElementCallback(SharedElementCallback callback) =>
      _setEnterSharedElementCallback(reference, callback.reference);

  static final _setExitSharedElementCallback = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_setExitSharedElementCallback")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExitSharedElementCallback(android.app.SharedElementCallback callback)
  /// When android.app.ActivityOptions\#makeSceneTransitionAnimation(Activity,
  /// android.view.View, String) was used to start an Activity, <var>callback</var>
  /// will be called to handle shared elements on the <i>launching</i> Activity. Most
  /// calls will only come when returning from the started Activity.
  /// This requires Window\#FEATURE_ACTIVITY_TRANSITIONS.
  ///@param callback Used to manipulate shared element transitions on the launching Activity.
  void setExitSharedElementCallback(SharedElementCallback callback) =>
      _setExitSharedElementCallback(reference, callback.reference);

  static final _postponeEnterTransition =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_postponeEnterTransition")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void postponeEnterTransition()
  /// Postpone the entering activity transition when Activity was started with
  /// android.app.ActivityOptions\#makeSceneTransitionAnimation(Activity,
  /// android.util.Pair[]).
  /// This method gives the Activity the ability to delay starting the entering and
  /// shared element transitions until all data is loaded. Until then, the Activity won't
  /// draw into its window, leaving the window transparent. This may also cause the
  /// returning animation to be delayed until data is ready. This method should be
  /// called in \#onCreate(android.os.Bundle) or in
  /// \#onActivityReenter(int, android.content.Intent).
  /// \#startPostponedEnterTransition() must be called to allow the Activity to
  /// start the transitions. If the Activity did not use
  /// android.app.ActivityOptions\#makeSceneTransitionAnimation(Activity,
  /// android.util.Pair[]), then this method does nothing.
  ///
  void postponeEnterTransition() => _postponeEnterTransition(reference);

  static final _startPostponedEnterTransition =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_startPostponedEnterTransition")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void startPostponedEnterTransition()
  /// Begin postponed transitions after \#postponeEnterTransition() was called.
  /// If postponeEnterTransition() was called, you must call startPostponedEnterTransition()
  /// to have your Activity start drawing.
  void startPostponedEnterTransition() =>
      _startPostponedEnterTransition(reference);

  static final _requestDragAndDropPermissions = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Activity_requestDragAndDropPermissions")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.DragAndDropPermissions requestDragAndDropPermissions(android.view.DragEvent event)
  /// Create DragAndDropPermissions object bound to this activity and controlling the
  /// access permissions for content URIs associated with the DragEvent.
  ///@param event Drag event
  ///@return The DragAndDropPermissions object used to control access to the content URIs.
  /// Null if no content URIs are associated with the event or if permissions could not be granted.
  jni.JlObject requestDragAndDropPermissions(jni.JlObject event) =>
      jni.JlObject.fromRef(
          _requestDragAndDropPermissions(reference, event.reference));

  static final _startLockTask =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_startLockTask")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void startLockTask()
  /// Request to put this activity in a mode where the user is locked to a restricted set of
  /// applications.
  ///
  /// If DevicePolicyManager\#isLockTaskPermitted(String) returns {@code true}
  /// for this component, the current task will be launched directly into LockTask mode. Only apps
  /// whitelisted by DevicePolicyManager\#setLockTaskPackages(ComponentName, String[]) can
  /// be launched while LockTask mode is active. The user will not be able to leave this mode
  /// until this activity calls \#stopLockTask(). Calling this method while the device is
  /// already in LockTask mode has no effect.
  ///
  /// Otherwise, the current task will be launched into screen pinning mode. In this case, the
  /// system will prompt the user with a dialog requesting permission to use this mode.
  /// The user can exit at any time through instructions shown on the request dialog. Calling
  /// \#stopLockTask() will also terminate this mode.
  ///
  /// <strong>Note:</strong> this method can only be called when the activity is foreground.
  /// That is, between \#onResume() and \#onPause().
  ///@see \#stopLockTask()
  ///@see android.R.attr\#lockTaskMode
  void startLockTask() => _startLockTask(reference);

  static final _stopLockTask =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_stopLockTask")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void stopLockTask()
  /// Stop the current task from being locked.
  ///
  /// Called to end the LockTask or screen pinning mode started by \#startLockTask().
  /// This can only be called by activities that have called \#startLockTask() previously.
  ///
  /// <strong>Note:</strong> If the device is in LockTask mode that is not initially started
  /// by this activity, then calling this method will not terminate the LockTask mode, but only
  /// finish its own task. The device will remain in LockTask mode, until the activity which
  /// started the LockTask mode calls this method, or until its whitelist authorization is revoked
  /// by DevicePolicyManager\#setLockTaskPackages(ComponentName, String[]).
  ///@see \#startLockTask()
  ///@see android.R.attr\#lockTaskMode
  ///@see ActivityManager\#getLockTaskModeState()
  void stopLockTask() => _stopLockTask(reference);

  static final _showLockTaskEscapeMessage =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Activity_showLockTaskEscapeMessage")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void showLockTaskEscapeMessage()
  /// Shows the user the system defined message for telling the user how to exit
  /// lock task mode. The task containing this activity must be in lock task mode at the time
  /// of this call for the message to be displayed.
  void showLockTaskEscapeMessage() => _showLockTaskEscapeMessage(reference);

  static final _setShowWhenLocked = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Activity_setShowWhenLocked")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setShowWhenLocked(boolean showWhenLocked)
  /// Specifies whether an Activity should be shown on top of the the lock screen whenever
  /// the lockscreen is up and the activity is resumed. Normally an activity will be transitioned
  /// to the stopped state if it is started while the lockscreen is up, but with this flag set the
  /// activity will remain in the resumed state visible on-top of the lock screen. This value can
  /// be set as a manifest attribute using android.R.attr\#showWhenLocked.
  ///@param showWhenLocked {@code true} to show the Activity on top of the lock screen;
  ///                                   {@code false} otherwise.
  ///@see \#setTurnScreenOn(boolean)
  ///@see android.R.attr\#turnScreenOn
  ///@see android.R.attr\#showWhenLocked
  void setShowWhenLocked(bool showWhenLocked) =>
      _setShowWhenLocked(reference, showWhenLocked ? 1 : 0);

  static final _setTurnScreenOn = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Activity_setTurnScreenOn")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setTurnScreenOn(boolean turnScreenOn)
  /// Specifies whether the screen should be turned on when the Activity is resumed.
  /// Normally an activity will be transitioned to the stopped state if it is started while the
  /// screen if off, but with this flag set the activity will cause the screen to turn on if the
  /// activity will be visible and resumed due to the screen coming on. The screen will not be
  /// turned on if the activity won't be visible after the screen is turned on. This flag is
  /// normally used in conjunction with the android.R.attr\#showWhenLocked flag to make sure
  /// the activity is visible after the screen is turned on when the lockscreen is up. In addition,
  /// if this flag is set and the activity calls KeyguardManager\#requestDismissKeyguard(Activity, KeyguardManager.KeyguardDismissCallback)
  /// the screen will turn on.
  ///@param turnScreenOn {@code true} to turn on the screen; {@code false} otherwise.
  ///@see \#setShowWhenLocked(boolean)
  ///@see android.R.attr\#turnScreenOn
  ///@see android.R.attr\#showWhenLocked
  void setTurnScreenOn(bool turnScreenOn) =>
      _setTurnScreenOn(reference, turnScreenOn ? 1 : 0);
}

/// Displays a list of all activities which can be performed
/// for a given intent. Launches when clicked.
class LauncherActivity extends ListActivity {
  LauncherActivity.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_LauncherActivity_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  LauncherActivity() : super.fromRef(_ctor());

  static final _onCreate = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_LauncherActivity_onCreate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onCreate(android.os.Bundle icicle)
  void onCreate(os.Bundle icicle) => _onCreate(reference, icicle.reference);

  static final _setTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_LauncherActivity_setTitle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTitle(java.lang.CharSequence title)
  void setTitle(jni.JlObject title) => _setTitle(reference, title.reference);

  static final _setTitle_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_LauncherActivity_setTitle_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setTitle(int titleId)
  void setTitle_1(int titleId) => _setTitle_1(reference, titleId);

  static final _onSetContentView =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_LauncherActivity_onSetContentView")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onSetContentView()
  /// Override to call setContentView() with your own content view to
  /// customize the list layout.
  void onSetContentView() => _onSetContentView(reference);

  static final _onListItemClick = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int64)>>("android_app_LauncherActivity_onListItemClick")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: protected void onListItemClick(android.widget.ListView l, android.view.View v, int position, long id)
  void onListItemClick(jni.JlObject l, jni.JlObject v, int position, int id) =>
      _onListItemClick(reference, l.reference, v.reference, position, id);

  static final _intentForPosition = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_LauncherActivity_intentForPosition")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: protected android.content.Intent intentForPosition(int position)
  /// Return the actual Intent for a specific position in our
  /// android.widget.ListView.
  ///@param position The item whose Intent to return
  content.Intent intentForPosition(int position) =>
      content.Intent.fromRef(_intentForPosition(reference, position));

  static final _itemForPosition = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_LauncherActivity_itemForPosition")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: protected android.app.LauncherActivity.ListItem itemForPosition(int position)
  /// Return the ListItem for a specific position in our
  /// android.widget.ListView.
  ///@param position The item to return
  LauncherActivity_ListItem itemForPosition(int position) =>
      LauncherActivity_ListItem.fromRef(_itemForPosition(reference, position));

  static final _getTargetIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_LauncherActivity_getTargetIntent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected android.content.Intent getTargetIntent()
  /// Get the base intent to use when running
  /// PackageManager\#queryIntentActivities(Intent, int).
  content.Intent getTargetIntent() =>
      content.Intent.fromRef(_getTargetIntent(reference));

  static final _onQueryPackageManager = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_LauncherActivity_onQueryPackageManager")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected java.util.List<android.content.pm.ResolveInfo> onQueryPackageManager(android.content.Intent queryIntent)
  /// Perform query on package manager for list items.  The default
  /// implementation queries for activities.
  jni.JlObject onQueryPackageManager(content.Intent queryIntent) =>
      jni.JlObject.fromRef(
          _onQueryPackageManager(reference, queryIntent.reference));

  static final _makeListItems = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_LauncherActivity_makeListItems")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.LauncherActivity.ListItem> makeListItems()
  /// Perform the query to determine which results to show and return a list of them.
  jni.JlObject makeListItems() =>
      jni.JlObject.fromRef(_makeListItems(reference));
}

/// An item in the list
class LauncherActivity_ListItem extends jni.JlObject {
  LauncherActivity_ListItem.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: public java.lang.String className
  static final _getclassName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_LauncherActivity__ListItem_className")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get className => jni.JlString.fromRef(_getclassName(reference));
  static final _setclassName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_LauncherActivity__ListItem_className")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set className(jni.JlString value) =>
      _setclassName(reference, value.reference);

  /// from: public android.os.Bundle extras
  static final _getextras = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_LauncherActivity__ListItem_extras")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  os.Bundle get extras => os.Bundle.fromRef(_getextras(reference));
  static final _setextras = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_LauncherActivity__ListItem_extras")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set extras(os.Bundle value) => _setextras(reference, value.reference);

  /// from: public android.graphics.drawable.Drawable icon
  static final _geticon = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_LauncherActivity__ListItem_icon")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get icon => jni.JlObject.fromRef(_geticon(reference));
  static final _seticon = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_LauncherActivity__ListItem_icon")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set icon(jni.JlObject value) => _seticon(reference, value.reference);

  /// from: public java.lang.CharSequence label
  static final _getlabel = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_LauncherActivity__ListItem_label")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get label => jni.JlObject.fromRef(_getlabel(reference));
  static final _setlabel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_LauncherActivity__ListItem_label")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set label(jni.JlObject value) => _setlabel(reference, value.reference);

  /// from: public java.lang.String packageName
  static final _getpackageName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_LauncherActivity__ListItem_packageName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get packageName =>
      jni.JlString.fromRef(_getpackageName(reference));
  static final _setpackageName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_LauncherActivity__ListItem_packageName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set packageName(jni.JlString value) =>
      _setpackageName(reference, value.reference);

  /// from: public android.content.pm.ResolveInfo resolveInfo
  static final _getresolveInfo = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_LauncherActivity__ListItem_resolveInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  pm.ResolveInfo get resolveInfo =>
      pm.ResolveInfo.fromRef(_getresolveInfo(reference));
  static final _setresolveInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_LauncherActivity__ListItem_resolveInfo")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set resolveInfo(pm.ResolveInfo value) =>
      _setresolveInfo(reference, value.reference);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_LauncherActivity__ListItem_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  LauncherActivity_ListItem() : super.fromRef(_ctor());
}

/// Utility class to resize icons to match default icon size.
class LauncherActivity_IconResizer extends jni.JlObject {
  LauncherActivity_IconResizer.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_LauncherActivity__IconResizer_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  LauncherActivity_IconResizer() : super.fromRef(_ctor());

  static final _createIconThumbnail = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_LauncherActivity__IconResizer_createIconThumbnail")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable createIconThumbnail(android.graphics.drawable.Drawable icon)
  /// Returns a Drawable representing the thumbnail of the specified Drawable.
  /// The size of the thumbnail is defined by the dimension
  /// android.R.dimen.launcher_application_icon_size.
  ///
  /// This method is not thread-safe and should be invoked on the UI thread only.
  ///@param icon The icon to get a thumbnail of.
  ///@return A thumbnail for the specified icon or the icon itself if the
  ///         thumbnail could not be created.
  jni.JlObject createIconThumbnail(jni.JlObject icon) =>
      jni.JlObject.fromRef(_createIconThumbnail(reference, icon.reference));
}

/// A class that represents how a persistent notification is to be presented to
/// the user using the android.app.NotificationManager.
///
/// The Notification.Builder Notification.Builder has been added to make it
/// easier to construct Notifications.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For a guide to creating notifications, read the
/// <a href="{@docRoot}guide/topics/ui/notifiers/notifications.html">Status Bar Notifications</a>
/// developer guide.
///
/// </div>
class Notification extends jni.JlObject {
  Notification.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.media.AudioAttributes AUDIO_ATTRIBUTES_DEFAULT
  /// The default value of \#audioAttributes.
  static final _getAUDIO_ATTRIBUTES_DEFAULT =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_Notification_AUDIO_ATTRIBUTES_DEFAULT")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlObject get AUDIO_ATTRIBUTES_DEFAULT =>
      jni.JlObject.fromRef(_getAUDIO_ATTRIBUTES_DEFAULT());

  /// from: static public final int BADGE_ICON_LARGE
  /// If this notification is being shown as a badge, use the \#getLargeIcon() to
  /// represent this notification.
  static const BADGE_ICON_LARGE = 2;

  /// from: static public final int BADGE_ICON_NONE
  /// If this notification is being shown as a badge, always show as a number.
  static const BADGE_ICON_NONE = 0;

  /// from: static public final int BADGE_ICON_SMALL
  /// If this notification is being shown as a badge, use the \#getSmallIcon() to
  /// represent this notification.
  static const BADGE_ICON_SMALL = 1;

  /// from: static public final java.lang.String CATEGORY_ALARM
  /// Notification category: alarm or timer.
  static const CATEGORY_ALARM = "alarm";

  /// from: static public final java.lang.String CATEGORY_CALL
  /// Notification category: incoming call (voice or video) or similar synchronous communication request.
  static const CATEGORY_CALL = "call";

  /// from: static public final java.lang.String CATEGORY_EMAIL
  /// Notification category: asynchronous bulk message (email).
  static const CATEGORY_EMAIL = "email";

  /// from: static public final java.lang.String CATEGORY_ERROR
  /// Notification category: error in background operation or authentication status.
  static const CATEGORY_ERROR = "err";

  /// from: static public final java.lang.String CATEGORY_EVENT
  /// Notification category: calendar event.
  static const CATEGORY_EVENT = "event";

  /// from: static public final java.lang.String CATEGORY_MESSAGE
  /// Notification category: incoming direct message (SMS, instant message, etc.).
  static const CATEGORY_MESSAGE = "msg";

  /// from: static public final java.lang.String CATEGORY_NAVIGATION
  /// Notification category: map turn-by-turn navigation.
  static const CATEGORY_NAVIGATION = "navigation";

  /// from: static public final java.lang.String CATEGORY_PROGRESS
  /// Notification category: progress of a long-running background operation.
  static const CATEGORY_PROGRESS = "progress";

  /// from: static public final java.lang.String CATEGORY_PROMO
  /// Notification category: promotion or advertisement.
  static const CATEGORY_PROMO = "promo";

  /// from: static public final java.lang.String CATEGORY_RECOMMENDATION
  /// Notification category: a specific, timely recommendation for a single thing.
  /// For example, a news app might want to recommend a news story it believes the user will
  /// want to read next.
  static const CATEGORY_RECOMMENDATION = "recommendation";

  /// from: static public final java.lang.String CATEGORY_REMINDER
  /// Notification category: user-scheduled reminder.
  static const CATEGORY_REMINDER = "reminder";

  /// from: static public final java.lang.String CATEGORY_SERVICE
  /// Notification category: indication of running background service.
  static const CATEGORY_SERVICE = "service";

  /// from: static public final java.lang.String CATEGORY_SOCIAL
  /// Notification category: social network or sharing update.
  static const CATEGORY_SOCIAL = "social";

  /// from: static public final java.lang.String CATEGORY_STATUS
  /// Notification category: ongoing information about device or contextual status.
  static const CATEGORY_STATUS = "status";

  /// from: static public final java.lang.String CATEGORY_SYSTEM
  /// Notification category: system or device status update.  Reserved for system use.
  static const CATEGORY_SYSTEM = "sys";

  /// from: static public final java.lang.String CATEGORY_TRANSPORT
  /// Notification category: media transport control for playback.
  static const CATEGORY_TRANSPORT = "transport";

  /// from: static public final int COLOR_DEFAULT
  /// Special value of \#color telling the system not to decorate this notification with
  /// any special color but instead use default colors when presenting this notification.
  static const COLOR_DEFAULT = 0;

  /// from: static public final android.os.Parcelable.Creator<android.app.Notification> CREATOR
  /// Parcelable.Creator that instantiates Notification objects
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_Notification_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int DEFAULT_ALL
  /// Use all default values (where applicable).
  static const DEFAULT_ALL = -1;

  /// from: static public final int DEFAULT_LIGHTS
  /// Use the default notification lights. This will ignore the
  /// \#FLAG_SHOW_LIGHTS bit, and \#ledARGB, \#ledOffMS, or
  /// \#ledOnMS.
  ///@see \#defaults
  static const DEFAULT_LIGHTS = 4;

  /// from: static public final int DEFAULT_SOUND
  /// Use the default notification sound. This will ignore any given
  /// \#sound.
  ///
  ///
  /// A notification that is noisy is more likely to be presented as a heads-up notification.
  ///
  ///
  ///@see \#defaults
  static const DEFAULT_SOUND = 1;

  /// from: static public final int DEFAULT_VIBRATE
  /// Use the default notification vibrate. This will ignore any given
  /// \#vibrate. Using phone vibration requires the
  /// android.Manifest.permission\#VIBRATE VIBRATE permission.
  ///
  ///
  /// A notification that vibrates is more likely to be presented as a heads-up notification.
  ///
  ///
  ///@see \#defaults
  static const DEFAULT_VIBRATE = 2;

  /// from: static public final java.lang.String EXTRA_AUDIO_CONTENTS_URI
  /// \#extras key: the audio contents of this notification.
  ///
  /// This is for use when rendering the notification on an audio-focused interface;
  /// the audio contents are a complete sound sample that contains the contents/body of the
  /// notification. This may be used in substitute of a Text-to-Speech reading of the
  /// notification. For example if the notification represents a voice message this should point
  /// to the audio of that message.
  ///
  /// The data stored under this key should be a String representation of a Uri that contains the
  /// audio contents in one of the following formats: WAV, PCM 16-bit, AMR-WB.
  ///
  /// This extra is unnecessary if you are using {@code MessagingStyle} since each {@code Message}
  /// has a field for holding data URI. That field can be used for audio.
  /// See {@code Message\#setData}.
  ///
  /// Example usage:
  /// <pre>
  /// {@code
  /// Notification.Builder myBuilder = (build your Notification as normal);
  /// myBuilder.getExtras().putString(EXTRA_AUDIO_CONTENTS_URI, myAudioUri.toString());
  /// }
  /// </pre>
  static const EXTRA_AUDIO_CONTENTS_URI = "android.audioContents";

  /// from: static public final java.lang.String EXTRA_BACKGROUND_IMAGE_URI
  /// \#extras key: A
  /// android.content.ContentUris content URI pointing to an image that can be displayed
  /// in the background when the notification is selected. Used on television platforms.
  /// The URI must point to an image stream suitable for passing into
  /// android.graphics.BitmapFactory\#decodeStream(java.io.InputStream) BitmapFactory.decodeStream; all other content types will be ignored.
  static const EXTRA_BACKGROUND_IMAGE_URI = "android.backgroundImageUri";

  /// from: static public final java.lang.String EXTRA_BIG_TEXT
  /// \#extras key: this is the longer text shown in the big form of a
  /// BigTextStyle notification, as supplied to
  /// BigTextStyle\#bigText(CharSequence).
  static const EXTRA_BIG_TEXT = "android.bigText";

  /// from: static public final java.lang.String EXTRA_CHANNEL_GROUP_ID
  /// Optional extra for \#INTENT_CATEGORY_NOTIFICATION_PREFERENCES. If provided, will
  /// contain a NotificationChannelGroup\#getId() group id that can be used to narrow down
  /// what settings should be shown in the target app.
  static const EXTRA_CHANNEL_GROUP_ID = "android.intent.extra.CHANNEL_GROUP_ID";

  /// from: static public final java.lang.String EXTRA_CHANNEL_ID
  /// Optional extra for \#INTENT_CATEGORY_NOTIFICATION_PREFERENCES. If provided, will
  /// contain a NotificationChannel\#getId() channel id that can be used to narrow down
  /// what settings should be shown in the target app.
  static const EXTRA_CHANNEL_ID = "android.intent.extra.CHANNEL_ID";

  /// from: static public final java.lang.String EXTRA_CHRONOMETER_COUNT_DOWN
  /// \#extras key: whether the chronometer set on the notification should count down
  /// instead of counting up. Is only relevant if key \#EXTRA_SHOW_CHRONOMETER is present.
  /// This extra is a boolean. The default is false.
  static const EXTRA_CHRONOMETER_COUNT_DOWN = "android.chronometerCountDown";

  /// from: static public final java.lang.String EXTRA_COLORIZED
  /// \#extras key: whether the notification should be colorized as
  /// supplied to Builder\#setColorized(boolean)}.
  static const EXTRA_COLORIZED = "android.colorized";

  /// from: static public final java.lang.String EXTRA_COMPACT_ACTIONS
  /// \#extras key: the indices of actions to be shown in the compact view,
  /// as supplied to (e.g.) MediaStyle\#setShowActionsInCompactView(int...).
  static const EXTRA_COMPACT_ACTIONS = "android.compactActions";

  /// from: static public final java.lang.String EXTRA_CONVERSATION_TITLE
  /// \#extras key: a CharSequence to be displayed as the title to a conversation
  /// represented by a android.app.Notification.MessagingStyle
  static const EXTRA_CONVERSATION_TITLE = "android.conversationTitle";

  /// from: static public final java.lang.String EXTRA_HISTORIC_MESSAGES
  /// \#extras key: an array of
  /// android.app.Notification.MessagingStyle\#addHistoricMessage historic
  /// android.app.Notification.MessagingStyle.Message bundles provided by a
  /// android.app.Notification.MessagingStyle notification. This extra is a parcelable
  /// array of bundles.
  static const EXTRA_HISTORIC_MESSAGES = "android.messages.historic";

  /// from: static public final java.lang.String EXTRA_INFO_TEXT
  /// \#extras key: this is a small piece of additional text as supplied to
  /// Builder\#setContentInfo(CharSequence).
  static const EXTRA_INFO_TEXT = "android.infoText";

  /// from: static public final java.lang.String EXTRA_IS_GROUP_CONVERSATION
  /// \#extras key: whether the android.app.Notification.MessagingStyle notification
  /// represents a group conversation.
  static const EXTRA_IS_GROUP_CONVERSATION = "android.isGroupConversation";

  /// from: static public final java.lang.String EXTRA_LARGE_ICON
  /// \#extras key: this is a bitmap to be used instead of the small icon when showing the
  /// notification payload, as
  /// supplied to Builder\#setLargeIcon(android.graphics.Bitmap).
  ///@deprecated Use \#getLargeIcon(), which supports a wider variety of icon sources.
  static const EXTRA_LARGE_ICON = "android.largeIcon";

  /// from: static public final java.lang.String EXTRA_LARGE_ICON_BIG
  /// \#extras key: this is a bitmap to be used instead of the one from
  /// Builder\#setLargeIcon(android.graphics.Bitmap) when the notification is
  /// shown in its expanded form, as supplied to
  /// BigPictureStyle\#bigLargeIcon(android.graphics.Bitmap).
  static const EXTRA_LARGE_ICON_BIG = "android.largeIcon.big";

  /// from: static public final java.lang.String EXTRA_MEDIA_SESSION
  /// \#extras key: A
  /// android.media.session.MediaSession.Token associated with a
  /// android.app.Notification.MediaStyle notification.
  static const EXTRA_MEDIA_SESSION = "android.mediaSession";

  /// from: static public final java.lang.String EXTRA_MESSAGES
  /// \#extras key: an array of android.app.Notification.MessagingStyle.Message
  /// bundles provided by a
  /// android.app.Notification.MessagingStyle notification. This extra is a parcelable
  /// array of bundles.
  static const EXTRA_MESSAGES = "android.messages";

  /// from: static public final java.lang.String EXTRA_MESSAGING_PERSON
  /// \#extras key: the person to be displayed for all messages sent by the user including
  /// direct replies
  /// android.app.Notification.MessagingStyle notification. This extra is a
  /// Person
  static const EXTRA_MESSAGING_PERSON = "android.messagingUser";

  /// from: static public final java.lang.String EXTRA_NOTIFICATION_ID
  /// Optional extra for \#INTENT_CATEGORY_NOTIFICATION_PREFERENCES. If provided, will
  /// contain the id provided to NotificationManager\#notify(String, int, Notification)
  /// that can be used to narrow down what settings should be shown in the target app.
  static const EXTRA_NOTIFICATION_ID = "android.intent.extra.NOTIFICATION_ID";

  /// from: static public final java.lang.String EXTRA_NOTIFICATION_TAG
  /// Optional extra for \#INTENT_CATEGORY_NOTIFICATION_PREFERENCES. If provided, will
  /// contain the tag provided to NotificationManager\#notify(String, int, Notification)
  /// that can be used to narrow down what settings should be shown in the target app.
  static const EXTRA_NOTIFICATION_TAG = "android.intent.extra.NOTIFICATION_TAG";

  /// from: static public final java.lang.String EXTRA_PEOPLE
  /// \#extras key: A String array containing the people that this notification relates to,
  /// each of which was supplied to Builder\#addPerson(String).
  ///@deprecated the actual objects are now in \#EXTRA_PEOPLE_LIST
  static const EXTRA_PEOPLE = "android.people";

  /// from: static public final java.lang.String EXTRA_PEOPLE_LIST
  /// \#extras key: An arrayList of Person objects containing the people that
  /// this notification relates to.
  static const EXTRA_PEOPLE_LIST = "android.people.list";

  /// from: static public final java.lang.String EXTRA_PICTURE
  /// \#extras key: this is a bitmap to be shown in BigPictureStyle expanded
  /// notifications, supplied to BigPictureStyle\#bigPicture(android.graphics.Bitmap).
  static const EXTRA_PICTURE = "android.picture";

  /// from: static public final java.lang.String EXTRA_PROGRESS
  /// \#extras key: this is the progress value supplied to
  /// Builder\#setProgress(int, int, boolean).
  static const EXTRA_PROGRESS = "android.progress";

  /// from: static public final java.lang.String EXTRA_PROGRESS_INDETERMINATE
  /// \#extras key: whether the progress bar is indeterminate, supplied to
  /// Builder\#setProgress(int, int, boolean).
  static const EXTRA_PROGRESS_INDETERMINATE = "android.progressIndeterminate";

  /// from: static public final java.lang.String EXTRA_PROGRESS_MAX
  /// \#extras key: this is the maximum value supplied to
  /// Builder\#setProgress(int, int, boolean).
  static const EXTRA_PROGRESS_MAX = "android.progressMax";

  /// from: static public final java.lang.String EXTRA_REMOTE_INPUT_DRAFT
  /// If the notification contained an unsent draft for a RemoteInput when the user clicked on it,
  /// we're adding the draft as a String extra to the \#contentIntent using this key.
  ///
  /// Apps may use this extra to prepopulate text fields in the app, where the user usually
  /// sends messages.
  ///
  static const EXTRA_REMOTE_INPUT_DRAFT = "android.remoteInputDraft";

  /// from: static public final java.lang.String EXTRA_REMOTE_INPUT_HISTORY
  /// \#extras key: this is the remote input history, as supplied to
  /// Builder\#setRemoteInputHistory(CharSequence[]).
  ///
  /// Apps can fill this through Builder\#setRemoteInputHistory(CharSequence[])
  /// with the most recent inputs that have been sent through a RemoteInput of this
  /// Notification and are expected to clear it once the it is no longer relevant (e.g. for chat
  /// notifications once the other party has responded).
  ///
  /// The extra with this key is of type CharSequence[] and contains the most recent entry at
  /// the 0 index, the second most recent at the 1 index, etc.
  ///@see Builder\#setRemoteInputHistory(CharSequence[])
  static const EXTRA_REMOTE_INPUT_HISTORY = "android.remoteInputHistory";

  /// from: static public final java.lang.String EXTRA_SELF_DISPLAY_NAME
  /// \#extras key: the username to be displayed for all messages sent by the user including
  /// direct replies
  /// android.app.Notification.MessagingStyle notification. This extra is a
  /// CharSequence
  ///@deprecated use \#EXTRA_MESSAGING_PERSON
  static const EXTRA_SELF_DISPLAY_NAME = "android.selfDisplayName";

  /// from: static public final java.lang.String EXTRA_SHOW_CHRONOMETER
  /// \#extras key: whether \#when should be shown as a count-up timer (specifically
  /// a android.widget.Chronometer) instead of a timestamp, as supplied to
  /// Builder\#setUsesChronometer(boolean).
  static const EXTRA_SHOW_CHRONOMETER = "android.showChronometer";

  /// from: static public final java.lang.String EXTRA_SHOW_WHEN
  /// \#extras key: whether \#when should be shown,
  /// as supplied to Builder\#setShowWhen(boolean).
  static const EXTRA_SHOW_WHEN = "android.showWhen";

  /// from: static public final java.lang.String EXTRA_SMALL_ICON
  /// \#extras key: this is the resource ID of the notification's main small icon, as
  /// supplied to Builder\#setSmallIcon(int).
  ///@deprecated Use \#getSmallIcon(), which supports a wider variety of icon sources.
  static const EXTRA_SMALL_ICON = "android.icon";

  /// from: static public final java.lang.String EXTRA_SUB_TEXT
  /// \#extras key: this is a third line of text, as supplied to
  /// Builder\#setSubText(CharSequence).
  static const EXTRA_SUB_TEXT = "android.subText";

  /// from: static public final java.lang.String EXTRA_SUMMARY_TEXT
  /// \#extras key: this is a line of summary information intended to be shown
  /// alongside expanded notifications, as supplied to (e.g.)
  /// BigTextStyle\#setSummaryText(CharSequence).
  static const EXTRA_SUMMARY_TEXT = "android.summaryText";

  /// from: static public final java.lang.String EXTRA_TEMPLATE
  /// \#extras key: A string representing the name of the specific
  /// android.app.Notification.Style used to create this notification.
  static const EXTRA_TEMPLATE = "android.template";

  /// from: static public final java.lang.String EXTRA_TEXT
  /// \#extras key: this is the main text payload, as supplied to
  /// Builder\#setContentText(CharSequence).
  static const EXTRA_TEXT = "android.text";

  /// from: static public final java.lang.String EXTRA_TEXT_LINES
  /// \#extras key: An array of CharSequences to show in InboxStyle expanded
  /// notifications, each of which was supplied to InboxStyle\#addLine(CharSequence).
  static const EXTRA_TEXT_LINES = "android.textLines";

  /// from: static public final java.lang.String EXTRA_TITLE
  /// \#extras key: this is the title of the notification,
  /// as supplied to Builder\#setContentTitle(CharSequence).
  static const EXTRA_TITLE = "android.title";

  /// from: static public final java.lang.String EXTRA_TITLE_BIG
  /// \#extras key: this is the title of the notification when shown in expanded form,
  /// e.g.&nbsp;as supplied to BigTextStyle\#setBigContentTitle(CharSequence).
  static const EXTRA_TITLE_BIG = "android.title.big";

  /// from: static public final int FLAG_AUTO_CANCEL
  /// Bit to be bitwise-ored into the \#flags field that should be
  /// set if the notification should be canceled when it is clicked by the
  /// user.
  static const FLAG_AUTO_CANCEL = 16;

  /// from: static public final int FLAG_FOREGROUND_SERVICE
  /// Bit to be bitwise-ored into the \#flags field that should be
  /// set if this notification represents a currently running service.  This
  /// will normally be set for you by Service\#startForeground.
  static const FLAG_FOREGROUND_SERVICE = 64;

  /// from: static public final int FLAG_GROUP_SUMMARY
  /// Bit to be bitswise-ored into the \#flags field that should be
  /// set if this notification is the group summary for a group of notifications.
  /// Grouped notifications may display in a cluster or stack on devices which
  /// support such rendering. Requires a group key also be set using Builder\#setGroup.
  static const FLAG_GROUP_SUMMARY = 512;

  /// from: static public final int FLAG_HIGH_PRIORITY
  /// Obsolete flag indicating high-priority notifications; use the priority field instead.
  ///@deprecated Use \#priority with a positive value.
  static const FLAG_HIGH_PRIORITY = 128;

  /// from: static public final int FLAG_INSISTENT
  /// Bit to be bitwise-ored into the \#flags field that if set,
  /// the audio will be repeated until the notification is
  /// cancelled or the notification window is opened.
  static const FLAG_INSISTENT = 4;

  /// from: static public final int FLAG_LOCAL_ONLY
  /// Bit to be bitswise-ored into the \#flags field that should be
  /// set if this notification is relevant to the current device only
  /// and it is not recommended that it bridge to other devices.
  static const FLAG_LOCAL_ONLY = 256;

  /// from: static public final int FLAG_NO_CLEAR
  /// Bit to be bitwise-ored into the \#flags field that should be
  /// set if the notification should not be canceled when the user clicks
  /// the Clear all button.
  static const FLAG_NO_CLEAR = 32;

  /// from: static public final int FLAG_ONGOING_EVENT
  /// Bit to be bitwise-ored into the \#flags field that should be
  /// set if this notification is in reference to something that is ongoing,
  /// like a phone call.  It should not be set if this notification is in
  /// reference to something that happened at a particular point in time,
  /// like a missed phone call.
  static const FLAG_ONGOING_EVENT = 2;

  /// from: static public final int FLAG_ONLY_ALERT_ONCE
  /// Bit to be bitwise-ored into the \#flags field that should be
  /// set if you would only like the sound, vibrate and ticker to be played
  /// if the notification was not already showing.
  static const FLAG_ONLY_ALERT_ONCE = 8;

  /// from: static public final int FLAG_SHOW_LIGHTS
  /// Bit to be bitwise-ored into the \#flags field that should be
  /// set if you want the LED on for this notification.
  /// <ul>
  /// <li>To turn the LED off, pass 0 in the alpha channel for colorARGB
  ///      or 0 for both ledOnMS and ledOffMS.</li>
  /// <li>To turn the LED on, pass 1 for ledOnMS and 0 for ledOffMS.</li>
  /// <li>To flash the LED, pass the number of milliseconds that it should
  ///      be on and off to ledOnMS and ledOffMS.</li>
  /// </ul>
  ///
  /// Since hardware varies, you are not guaranteed that any of the values
  /// you pass are honored exactly.  Use the system defaults if possible
  /// because they will be set to values that work on any given hardware.
  ///
  /// The alpha channel must be set for forward compatibility.
  ///@deprecated use NotificationChannel\#shouldShowLights().
  static const FLAG_SHOW_LIGHTS = 1;

  /// from: static public final int GROUP_ALERT_ALL
  /// Constant for Builder\#setGroupAlertBehavior(int), meaning that all notifications in a
  /// group with sound or vibration ought to make sound or vibrate (respectively), so this
  /// notification will not be muted when it is in a group.
  static const GROUP_ALERT_ALL = 0;

  /// from: static public final int GROUP_ALERT_CHILDREN
  /// Constant for Builder\#setGroupAlertBehavior(int), meaning that the summary
  /// notification in a group should be silenced (no sound or vibration) even if they are
  /// posted to a NotificationChannel that has sound and/or vibration. Use this constant
  /// to mute this notification if this notification is a group summary.
  ///
  /// For example, you might want to use this constant if only the children notifications
  /// in your group have content and the summary is only used to visually group notifications
  /// rather than to alert the user that new information is available.
  static const GROUP_ALERT_CHILDREN = 2;

  /// from: static public final int GROUP_ALERT_SUMMARY
  /// Constant for Builder\#setGroupAlertBehavior(int), meaning that all children
  /// notification in a group should be silenced (no sound or vibration) even if they are posted
  /// to a NotificationChannel that has sound and/or vibration. Use this constant to
  /// mute this notification if this notification is a group child. This must be applied to all
  /// children notifications you want to mute.
  ///
  ///  For example, you might want to use this constant if you post a number of children
  /// notifications at once (say, after a periodic sync), and only need to notify the user
  /// audibly once.
  static const GROUP_ALERT_SUMMARY = 1;

  /// from: static public final java.lang.String INTENT_CATEGORY_NOTIFICATION_PREFERENCES
  /// An activity that provides a user interface for adjusting notification preferences for its
  /// containing application.
  static const INTENT_CATEGORY_NOTIFICATION_PREFERENCES =
      "android.intent.category.NOTIFICATION_PREFERENCES";

  /// from: static public final int PRIORITY_DEFAULT
  /// Default notification \#priority. If your application does not prioritize its own
  /// notifications, use this value for all notifications.
  ///@deprecated use NotificationManager\#IMPORTANCE_DEFAULT instead.
  static const PRIORITY_DEFAULT = 0;

  /// from: static public final int PRIORITY_HIGH
  /// Higher \#priority, for more important notifications or alerts. The UI may choose to
  /// show these items larger, or at a different position in notification lists, compared with
  /// your app's \#PRIORITY_DEFAULT items.
  ///@deprecated use NotificationManager\#IMPORTANCE_HIGH instead.
  static const PRIORITY_HIGH = 1;

  /// from: static public final int PRIORITY_LOW
  /// Lower \#priority, for items that are less important. The UI may choose to show these
  /// items smaller, or at a different position in the list, compared with your app's
  /// \#PRIORITY_DEFAULT items.
  ///@deprecated use NotificationManager\#IMPORTANCE_LOW instead.
  static const PRIORITY_LOW = -1;

  /// from: static public final int PRIORITY_MAX
  /// Highest \#priority, for your application's most important items that require the
  /// user's prompt attention or input.
  ///@deprecated use NotificationManager\#IMPORTANCE_HIGH instead.
  static const PRIORITY_MAX = 2;

  /// from: static public final int PRIORITY_MIN
  /// Lowest \#priority; these items might not be shown to the user except under special
  /// circumstances, such as detailed notification logs.
  ///@deprecated use NotificationManager\#IMPORTANCE_MIN instead.
  static const PRIORITY_MIN = -2;

  /// from: static public final int STREAM_DEFAULT
  /// Use this constant as the value for audioStreamType to request that
  /// the default stream type for notifications be used.  Currently the
  /// default stream type is AudioManager\#STREAM_NOTIFICATION.
  ///@deprecated Use NotificationChannel\#getAudioAttributes() instead.
  static const STREAM_DEFAULT = -1;

  /// from: static public final int VISIBILITY_PRIVATE
  /// Notification visibility: Show this notification on all lockscreens, but conceal sensitive or
  /// private information on secure lockscreens.
  ///
  /// {@see \#visibility}
  static const VISIBILITY_PRIVATE = 0;

  /// from: static public final int VISIBILITY_PUBLIC
  /// Notification visibility: Show this notification in its entirety on all lockscreens.
  ///
  /// {@see \#visibility}
  static const VISIBILITY_PUBLIC = 1;

  /// from: static public final int VISIBILITY_SECRET
  /// Notification visibility: Do not reveal any part of this notification on a secure lockscreen.
  ///
  /// {@see \#visibility}
  static const VISIBILITY_SECRET = -1;

  /// from: public android.app.Notification.Action[] actions
  /// Array of all Action structures attached to this notification by
  /// Builder\#addAction(int, CharSequence, PendingIntent). Mostly useful for instances of
  /// android.service.notification.NotificationListenerService that provide an alternative
  /// interface for invoking actions.
  static final _getactions = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_actions")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get actions => jni.JlObject.fromRef(_getactions(reference));
  static final _setactions = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_Notification_actions")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set actions(jni.JlObject value) => _setactions(reference, value.reference);

  /// from: public android.media.AudioAttributes audioAttributes
  /// The AudioAttributes audio attributes to use when playing the sound.
  ///@deprecated use NotificationChannel\#getAudioAttributes() instead.
  static final _getaudioAttributes = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_audioAttributes")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get audioAttributes =>
      jni.JlObject.fromRef(_getaudioAttributes(reference));
  static final _setaudioAttributes = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_Notification_audioAttributes")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set audioAttributes(jni.JlObject value) =>
      _setaudioAttributes(reference, value.reference);

  /// from: public int audioStreamType
  /// The audio stream type to use when playing the sound.
  /// Should be one of the STREAM_ constants from
  /// android.media.AudioManager.
  ///@deprecated Use \#audioAttributes instead.
  static final _getaudioStreamType = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_audioStreamType")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get audioStreamType => _getaudioStreamType(reference);
  static final _setaudioStreamType = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_app_Notification_audioStreamType")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set audioStreamType(int value) => _setaudioStreamType(reference, value);

  /// from: public android.widget.RemoteViews bigContentView
  /// A large-format version of \#contentView, giving the Notification an
  /// opportunity to show more detail. The system UI may choose to show this
  /// instead of the normal content view at its discretion.
  ///
  /// As of N, this field may be null. The expanded notification view is determined by the
  /// inputs to Notification.Builder; a custom RemoteViews can optionally be
  /// supplied with Notification.Builder\#setCustomBigContentView(RemoteViews).
  static final _getbigContentView = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_bigContentView")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get bigContentView =>
      jni.JlObject.fromRef(_getbigContentView(reference));
  static final _setbigContentView = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_Notification_bigContentView")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set bigContentView(jni.JlObject value) =>
      _setbigContentView(reference, value.reference);

  /// from: public java.lang.String category
  /// One of the predefined notification categories (see the <code>CATEGORY_*</code> constants)
  /// that best describes this Notification.  May be used by the system for ranking and filtering.
  static final _getcategory = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_category")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get category => jni.JlString.fromRef(_getcategory(reference));
  static final _setcategory = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_Notification_category")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set category(jni.JlString value) => _setcategory(reference, value.reference);

  /// from: public int color
  /// Accent color (an ARGB integer like the constants in android.graphics.Color)
  /// to be applied by the standard Style templates when presenting this notification.
  ///
  /// The current template design constructs a colorful header image by overlaying the
  /// \#icon image (stenciled in white) atop a field of this color. Alpha components are
  /// ignored.
  static final _getcolor = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_color")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get color => _getcolor(reference);
  static final _setcolor = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_app_Notification_color")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set color(int value) => _setcolor(reference, value);

  /// from: public android.app.PendingIntent contentIntent
  /// The intent to execute when the expanded status entry is clicked.  If
  /// this is an activity, it must include the
  /// android.content.Intent\#FLAG_ACTIVITY_NEW_TASK flag, which requires
  /// that you take care of task management as described in the
  /// <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
  /// Stack</a> document.  In particular, make sure to read the notification section
  /// <a href="{@docRoot}guide/topics/ui/notifiers/notifications.html\#HandlingNotifications">Handling
  /// Notifications</a> for the correct ways to launch an application from a
  /// notification.
  static final _getcontentIntent = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_contentIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  PendingIntent get contentIntent =>
      PendingIntent.fromRef(_getcontentIntent(reference));
  static final _setcontentIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_Notification_contentIntent")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set contentIntent(PendingIntent value) =>
      _setcontentIntent(reference, value.reference);

  /// from: public android.widget.RemoteViews contentView
  /// The view that will represent this notification in the notification list (which is pulled
  /// down from the status bar).
  ///
  /// As of N, this field may be null. The notification view is determined by the inputs
  /// to Notification.Builder; a custom RemoteViews can optionally be
  /// supplied with Notification.Builder\#setCustomContentView(RemoteViews).
  static final _getcontentView = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_contentView")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get contentView =>
      jni.JlObject.fromRef(_getcontentView(reference));
  static final _setcontentView = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_Notification_contentView")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set contentView(jni.JlObject value) =>
      _setcontentView(reference, value.reference);

  /// from: public int defaults
  /// Specifies which values should be taken from the defaults.
  ///
  /// To set, OR the desired from \#DEFAULT_SOUND,
  /// \#DEFAULT_VIBRATE, \#DEFAULT_LIGHTS. For all default
  /// values, use \#DEFAULT_ALL.
  ///
  ///
  ///@deprecated use NotificationChannel\#getSound() and
  /// NotificationChannel\#shouldShowLights() and
  /// NotificationChannel\#shouldVibrate().
  static final _getdefaults = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_defaults")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get defaults => _getdefaults(reference);
  static final _setdefaults = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_app_Notification_defaults")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set defaults(int value) => _setdefaults(reference, value);

  /// from: public android.app.PendingIntent deleteIntent
  /// The intent to execute when the notification is explicitly dismissed by the user, either with
  /// the "Clear All" button or by swiping it away individually.
  ///
  /// This probably shouldn't be launching an activity since several of those will be sent
  /// at the same time.
  static final _getdeleteIntent = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_deleteIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  PendingIntent get deleteIntent =>
      PendingIntent.fromRef(_getdeleteIntent(reference));
  static final _setdeleteIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_Notification_deleteIntent")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set deleteIntent(PendingIntent value) =>
      _setdeleteIntent(reference, value.reference);

  /// from: public android.os.Bundle extras
  /// Additional semantic data to be carried around with this Notification.
  ///
  /// The extras keys defined here are intended to capture the original inputs to Builder
  /// APIs, and are intended to be used by
  /// android.service.notification.NotificationListenerService implementations to extract
  /// detailed information from notification objects.
  static final _getextras = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_extras")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  os.Bundle get extras => os.Bundle.fromRef(_getextras(reference));
  static final _setextras = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_Notification_extras")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set extras(os.Bundle value) => _setextras(reference, value.reference);

  /// from: public int flags
  static final _getflags = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_flags")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get flags => _getflags(reference);
  static final _setflags = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_app_Notification_flags")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set flags(int value) => _setflags(reference, value);

  /// from: public android.app.PendingIntent fullScreenIntent
  /// An intent to launch instead of posting the notification to the status bar.
  ///
  ///
  /// The system UI may choose to display a heads-up notification, instead of
  /// launching this intent, while the user is using the device.
  ///
  ///
  ///@see Notification.Builder\#setFullScreenIntent
  static final _getfullScreenIntent = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_fullScreenIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  PendingIntent get fullScreenIntent =>
      PendingIntent.fromRef(_getfullScreenIntent(reference));
  static final _setfullScreenIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_Notification_fullScreenIntent")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set fullScreenIntent(PendingIntent value) =>
      _setfullScreenIntent(reference, value.reference);

  /// from: public android.widget.RemoteViews headsUpContentView
  /// A medium-format version of \#contentView, providing the Notification an
  /// opportunity to add action buttons to contentView. At its discretion, the system UI may
  /// choose to show this as a heads-up notification, which will pop up so the user can see
  /// it without leaving their current activity.
  ///
  /// As of N, this field may be null. The heads-up notification view is determined by the
  /// inputs to Notification.Builder; a custom RemoteViews can optionally be
  /// supplied with Notification.Builder\#setCustomHeadsUpContentView(RemoteViews).
  static final _getheadsUpContentView = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_headsUpContentView")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get headsUpContentView =>
      jni.JlObject.fromRef(_getheadsUpContentView(reference));
  static final _setheadsUpContentView = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_Notification_headsUpContentView")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set headsUpContentView(jni.JlObject value) =>
      _setheadsUpContentView(reference, value.reference);

  /// from: public int icon
  /// The resource id of a drawable to use as the icon in the status bar.
  ///@deprecated Use Builder\#setSmallIcon(Icon) instead.
  static final _geticon = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_icon")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get icon => _geticon(reference);
  static final _seticon = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_app_Notification_icon")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set icon(int value) => _seticon(reference, value);

  /// from: public int iconLevel
  /// If the icon in the status bar is to have more than one level, you can set this.  Otherwise,
  /// leave it at its default value of 0.
  ///@see android.widget.ImageView\#setImageLevel
  ///@see android.graphics.drawable.Drawable\#setLevel
  static final _geticonLevel = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_iconLevel")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get iconLevel => _geticonLevel(reference);
  static final _seticonLevel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_app_Notification_iconLevel")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set iconLevel(int value) => _seticonLevel(reference, value);

  /// from: public android.graphics.Bitmap largeIcon
  /// A large bitmap to be shown in the notification content area.
  ///@deprecated Use Builder\#setLargeIcon(Icon) instead.
  static final _getlargeIcon = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_largeIcon")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get largeIcon => jni.JlObject.fromRef(_getlargeIcon(reference));
  static final _setlargeIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_Notification_largeIcon")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set largeIcon(jni.JlObject value) =>
      _setlargeIcon(reference, value.reference);

  /// from: public int ledARGB
  /// The color of the led.  The hardware will do its best approximation.
  ///@see \#FLAG_SHOW_LIGHTS
  ///@see \#flags
  ///@deprecated use NotificationChannel\#shouldShowLights().
  static final _getledARGB = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_ledARGB")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get ledARGB => _getledARGB(reference);
  static final _setledARGB = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_app_Notification_ledARGB")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set ledARGB(int value) => _setledARGB(reference, value);

  /// from: public int ledOffMS
  /// The number of milliseconds for the LED to be off while it's flashing.
  /// The hardware will do its best approximation.
  ///@see \#FLAG_SHOW_LIGHTS
  ///@see \#flags
  ///@deprecated use NotificationChannel\#shouldShowLights().
  static final _getledOffMS = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_ledOffMS")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get ledOffMS => _getledOffMS(reference);
  static final _setledOffMS = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_app_Notification_ledOffMS")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set ledOffMS(int value) => _setledOffMS(reference, value);

  /// from: public int ledOnMS
  /// The number of milliseconds for the LED to be on while it's flashing.
  /// The hardware will do its best approximation.
  ///@see \#FLAG_SHOW_LIGHTS
  ///@see \#flags
  ///@deprecated use NotificationChannel\#shouldShowLights().
  static final _getledOnMS = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_ledOnMS")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get ledOnMS => _getledOnMS(reference);
  static final _setledOnMS = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_app_Notification_ledOnMS")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set ledOnMS(int value) => _setledOnMS(reference, value);

  /// from: public int number
  /// The number of events that this notification represents. For example, in a new mail
  /// notification, this could be the number of unread messages.
  ///
  /// The system may or may not use this field to modify the appearance of the notification.
  /// Starting with android.os.Build.VERSION_CODES\#O, the number may be displayed as a
  /// badge icon in Launchers that support badging.
  static final _getnumber = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_number")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get number => _getnumber(reference);
  static final _setnumber = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_app_Notification_number")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set number(int value) => _setnumber(reference, value);

  /// from: public int priority
  /// Relative priority for this notification.
  ///
  /// Priority is an indication of how much of the user's valuable attention should be consumed by
  /// this notification. Low-priority notifications may be hidden from the user in certain
  /// situations, while the user might be interrupted for a higher-priority notification. The
  /// system will make a determination about how to interpret this priority when presenting
  /// the notification.
  ///
  ///
  /// A notification that is at least \#PRIORITY_HIGH is more likely to be presented
  /// as a heads-up notification.
  ///
  ///
  ///
  /// Value is android.app.Notification\#PRIORITY_DEFAULT, android.app.Notification\#PRIORITY_LOW, android.app.Notification\#PRIORITY_MIN, android.app.Notification\#PRIORITY_HIGH, or android.app.Notification\#PRIORITY_MAX
  ///@deprecated use NotificationChannel\#getImportance() instead.
  static final _getpriority = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_priority")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get priority => _getpriority(reference);
  static final _setpriority = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_app_Notification_priority")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set priority(int value) => _setpriority(reference, value);

  /// from: public android.app.Notification publicVersion
  /// Replacement version of this notification whose content will be shown
  /// in an insecure context such as atop a secure keyguard. See \#visibility
  /// and \#VISIBILITY_PUBLIC.
  static final _getpublicVersion = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_publicVersion")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  Notification get publicVersion =>
      Notification.fromRef(_getpublicVersion(reference));
  static final _setpublicVersion = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_Notification_publicVersion")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set publicVersion(Notification value) =>
      _setpublicVersion(reference, value.reference);

  /// from: public android.net.Uri sound
  /// The sound to play.
  ///
  ///
  /// A notification that is noisy is more likely to be presented as a heads-up notification.
  ///
  ///
  ///
  ///
  /// To play the default notification sound, see \#defaults.
  ///
  ///
  ///@deprecated use NotificationChannel\#getSound().
  static final _getsound = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_sound")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get sound => jni.JlObject.fromRef(_getsound(reference));
  static final _setsound = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("set_android_app_Notification_sound")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set sound(jni.JlObject value) => _setsound(reference, value.reference);

  /// from: public java.lang.CharSequence tickerText
  /// Text that summarizes this notification for accessibility services.
  ///
  /// As of the L release, this text is no longer shown on screen, but it is still useful to
  /// accessibility services (where it serves as an audible announcement of the notification's
  /// appearance).
  ///@see \#tickerView
  static final _gettickerText = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_tickerText")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get tickerText =>
      jni.JlObject.fromRef(_gettickerText(reference));
  static final _settickerText = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_Notification_tickerText")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set tickerText(jni.JlObject value) =>
      _settickerText(reference, value.reference);

  /// from: public android.widget.RemoteViews tickerView
  /// Formerly, a view showing the \#tickerText.
  ///
  /// No longer displayed in the status bar as of API 21.
  static final _gettickerView = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_tickerView")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get tickerView =>
      jni.JlObject.fromRef(_gettickerView(reference));
  static final _settickerView = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_Notification_tickerView")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set tickerView(jni.JlObject value) =>
      _settickerView(reference, value.reference);

  /// from: public long[] vibrate
  /// The pattern with which to vibrate.
  ///
  ///
  /// To vibrate the default pattern, see \#defaults.
  ///
  ///
  ///@see android.os.Vibrator\#vibrate(long[],int)
  ///@deprecated use NotificationChannel\#getVibrationPattern().
  static final _getvibrate = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_vibrate")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get vibrate => jni.JlObject.fromRef(_getvibrate(reference));
  static final _setvibrate = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_Notification_vibrate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set vibrate(jni.JlObject value) => _setvibrate(reference, value.reference);

  /// from: public int visibility
  /// Sphere of visibility of this notification, which affects how and when the SystemUI reveals
  /// the notification's presence and contents in untrusted situations (namely, on the secure
  /// lockscreen).
  ///
  /// The default level, \#VISIBILITY_PRIVATE, behaves exactly as notifications have always
  /// done on Android: The notification's \#icon and \#tickerText (if available) are
  /// shown in all situations, but the contents are only available if the device is unlocked for
  /// the appropriate user.
  ///
  /// A more permissive policy can be expressed by \#VISIBILITY_PUBLIC; such a notification
  /// can be read even in an "insecure" context (that is, above a secure lockscreen).
  /// To modify the public version of this notification\u2014for example, to redact some portions\u2014see
  /// Builder\#setPublicVersion(Notification).
  ///
  /// Finally, a notification can be made \#VISIBILITY_SECRET, which will suppress its icon
  /// and ticker until the user has bypassed the lockscreen.
  ///
  /// Value is android.app.Notification\#VISIBILITY_PUBLIC, android.app.Notification\#VISIBILITY_PRIVATE, or android.app.Notification\#VISIBILITY_SECRET
  static final _getvisibility = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_visibility")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get visibility => _getvisibility(reference);
  static final _setvisibility = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_app_Notification_visibility")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set visibility(int value) => _setvisibility(reference, value);

  /// from: public long when
  /// A timestamp related to this notification, in milliseconds since the epoch.
  ///
  /// Default value: System\#currentTimeMillis() Now.
  ///
  /// Choose a timestamp that will be most relevant to the user. For most finite events, this
  /// corresponds to the time the event happened (or will happen, in the case of events that have
  /// yet to occur but about which the user is being informed). Indefinite events should be
  /// timestamped according to when the activity began.
  ///
  /// Some examples:
  ///
  /// <ul>
  ///   <li>Notification of a new chat message should be stamped when the message was received.</li>
  ///   <li>Notification of an ongoing file download (with a progress bar, for example) should be stamped when the download started.</li>
  ///   <li>Notification of a completed file download should be stamped when the download finished.</li>
  ///   <li>Notification of an upcoming meeting should be stamped with the time the meeting will begin (that is, in the future).</li>
  ///   <li>Notification of an ongoing stopwatch (increasing timer) should be stamped with the watch's start time.
  ///   <li>Notification of an ongoing countdown timer should be stamped with the timer's end time.
  /// </ul>
  ///
  /// For apps targeting android.os.Build.VERSION_CODES\#N and above, this time is not shown
  /// anymore by default and must be opted into by using
  /// android.app.Notification.Builder\#setShowWhen(boolean)
  static final _getwhen = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification_when")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get when => _getwhen(reference);
  static final _setwhen = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("set_android_app_Notification_when")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set when(int value) => _setwhen(reference, value);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Notification_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Constructs a Notification object with default values.
  /// You might want to consider using Builder instead.
  Notification() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Int32, ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_app_Notification_new_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(int icon, java.lang.CharSequence tickerText, long when)
  /// Constructs a Notification object with the information needed to
  /// have a status bar icon without the standard expanded view.
  ///@param icon The resource id of the icon to put in the status bar.
  ///@param tickerText The text that flows by in the status bar when the notification first
  ///                      activates.
  ///@param when The time to show in the time field.  In the System.currentTimeMillis
  ///                      timebase.
  ///@deprecated Use Builder instead.
  Notification.ctor_1(int icon, jni.JlObject tickerText, int when)
      : super.fromRef(_ctor_1(icon, tickerText.reference, when));

  static final _ctor_2 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Notification_new_2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel parcel)
  /// Unflatten the notification from a parcel.
  Notification.ctor_2(os.Parcel parcel)
      : super.fromRef(_ctor_2(parcel.reference));

  static final _getGroup = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Notification_getGroup")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getGroup()
  /// Get the key used to group this notification into a cluster or stack
  /// with other notifications on devices which support such rendering.
  jni.JlString getGroup() => jni.JlString.fromRef(_getGroup(reference));

  static final _getSortKey = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification_getSortKey")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSortKey()
  /// Get a sort key that orders this notification among other notifications from the
  /// same package. This can be useful if an external sort was already applied and an app
  /// would like to preserve this. Notifications will be sorted lexicographically using this
  /// value, although providing different priorities in addition to providing sort key may
  /// cause this value to be ignored.
  ///
  /// This sort key can also be used to order members of a notification group. See
  /// Builder\#setGroup.
  ///@see String\#compareTo(String)
  jni.JlString getSortKey() => jni.JlString.fromRef(_getSortKey(reference));

  static final _clone = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Notification_clone")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification clone()
  Notification clone() => Notification.fromRef(_clone(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Notification_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Notification_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  /// Flatten this notification into a parcel.
  void writeToParcel(os.Parcel parcel, int flags) =>
      _writeToParcel(reference, parcel.reference, flags);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _getChannelId = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification_getChannelId")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getChannelId()
  /// Returns the id of the channel this notification posts to.
  jni.JlString getChannelId() => jni.JlString.fromRef(_getChannelId(reference));

  static final _getTimeoutAfter =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Notification_getTimeoutAfter")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTimeoutAfter()
  /// Returns the duration from posting after which this notification should be canceled by the
  /// system, if it's not canceled already.
  int getTimeoutAfter() => _getTimeoutAfter(reference);

  static final _getBadgeIconType =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Notification_getBadgeIconType")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getBadgeIconType()
  /// Returns what icon should be shown for this notification if it is being displayed in a
  /// Launcher that supports badging. Will be one of \#BADGE_ICON_NONE,
  /// \#BADGE_ICON_SMALL, or \#BADGE_ICON_LARGE.
  int getBadgeIconType() => _getBadgeIconType(reference);

  static final _getShortcutId = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification_getShortcutId")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getShortcutId()
  /// Returns the ShortcutInfo\#getId() id that this notification supersedes, if any.
  ///
  /// Used by some Launchers that display notification content to hide shortcuts that duplicate
  /// notifications.
  jni.JlString getShortcutId() =>
      jni.JlString.fromRef(_getShortcutId(reference));

  static final _getSettingsText = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification_getSettingsText")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getSettingsText()
  /// Returns the settings text provided to Builder\#setSettingsText(CharSequence).
  jni.JlObject getSettingsText() =>
      jni.JlObject.fromRef(_getSettingsText(reference));

  static final _getGroupAlertBehavior =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Notification_getGroupAlertBehavior")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getGroupAlertBehavior()
  /// Returns which type of notifications in a group are responsible for audibly alerting the
  /// user. See \#GROUP_ALERT_ALL, \#GROUP_ALERT_CHILDREN,
  /// \#GROUP_ALERT_SUMMARY.
  ///@return Value is android.app.Notification\#GROUP_ALERT_ALL, android.app.Notification\#GROUP_ALERT_CHILDREN, or android.app.Notification\#GROUP_ALERT_SUMMARY
  int getGroupAlertBehavior() => _getGroupAlertBehavior(reference);

  static final _getSmallIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification_getSmallIcon")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Icon getSmallIcon()
  /// The small icon representing this notification in the status bar and content view.
  ///@return the small icon representing this notification.
  ///@see Builder\#getSmallIcon()
  ///@see Builder\#setSmallIcon(Icon)
  jni.JlObject getSmallIcon() => jni.JlObject.fromRef(_getSmallIcon(reference));

  static final _getLargeIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification_getLargeIcon")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Icon getLargeIcon()
  /// The large icon shown in this notification's content view.
  ///@see Builder\#getLargeIcon()
  ///@see Builder\#setLargeIcon(Icon)
  jni.JlObject getLargeIcon() => jni.JlObject.fromRef(_getLargeIcon(reference));
}

/// Helper class to add wearable extensions to notifications.
/// <p class="note"> See
/// <a href="{@docRoot}wear/notifications/creating.html">Creating Notifications
/// for Android Wear</a> for more information on how to use this class.
///
/// To create a notification with wearable extensions:
/// <ol>
///   <li>Create a android.app.Notification.Builder, setting any desired
///   properties.
///   <li>Create a android.app.Notification.WearableExtender.
///   <li>Set wearable-specific properties using the
///   {@code add} and {@code set} methods of android.app.Notification.WearableExtender.
///   <li>Call android.app.Notification.Builder\#extend to apply the extensions to a
///   notification.
///   <li>Post the notification to the notification system with the
///   {@code NotificationManager.notify(...)} methods.
/// </ol>
///
/// <pre class="prettyprint">
/// Notification notif = new Notification.Builder(mContext)
///         .setContentTitle(&quot;New mail from &quot; + sender.toString())
///         .setContentText(subject)
///         .setSmallIcon(R.drawable.new_mail)
///         .extend(new Notification.WearableExtender()
///                 .setContentIcon(R.drawable.new_mail))
///         .build();
/// NotificationManager notificationManger =
///         (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
/// notificationManger.notify(0, notif);</pre>
///
/// Wearable extensions can be accessed on an existing notification by using the
/// {@code WearableExtender(Notification)} constructor,
/// and then using the {@code get} methods to access values.
///
/// <pre class="prettyprint">
/// Notification.WearableExtender wearableExtender = new Notification.WearableExtender(
///         notification);
/// List&lt;Notification&gt; pages = wearableExtender.getPages();</pre>
class Notification_WearableExtender extends jni.JlObject {
  Notification_WearableExtender.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final int SCREEN_TIMEOUT_LONG
  /// Sentinel value for use with \#setHintScreenTimeout to keep the screen on
  /// for a longer amount of time when this notification is displayed on the screen.
  static const SCREEN_TIMEOUT_LONG = -1;

  /// from: static public final int SCREEN_TIMEOUT_SHORT
  /// Sentinel value for use with \#setHintScreenTimeout to keep the screen on for a
  /// short amount of time when this notification is displayed on the screen. This
  /// is the default value.
  static const SCREEN_TIMEOUT_SHORT = 0;

  /// from: static public final int SIZE_DEFAULT
  /// Size value for use with \#setCustomSizePreset to show this notification with
  /// default sizing.
  /// For custom display notifications created using \#setDisplayIntent,
  /// the default is \#SIZE_MEDIUM. All other notifications size automatically based
  /// on their content.
  static const SIZE_DEFAULT = 0;

  /// from: static public final int SIZE_FULL_SCREEN
  /// Size value for use with \#setCustomSizePreset to show this notification
  /// full screen.
  /// This value is only applicable for custom display notifications created using
  /// \#setDisplayIntent.
  static const SIZE_FULL_SCREEN = 5;

  /// from: static public final int SIZE_LARGE
  /// Size value for use with \#setCustomSizePreset to show this notification
  /// with a large size.
  /// This value is only applicable for custom display notifications created using
  /// \#setDisplayIntent.
  static const SIZE_LARGE = 4;

  /// from: static public final int SIZE_MEDIUM
  /// Size value for use with \#setCustomSizePreset to show this notification
  /// with a medium size.
  /// This value is only applicable for custom display notifications created using
  /// \#setDisplayIntent.
  static const SIZE_MEDIUM = 3;

  /// from: static public final int SIZE_SMALL
  /// Size value for use with \#setCustomSizePreset to show this notification
  /// with a small size.
  /// This value is only applicable for custom display notifications created using
  /// \#setDisplayIntent.
  static const SIZE_SMALL = 2;

  /// from: static public final int SIZE_XSMALL
  /// Size value for use with \#setCustomSizePreset to show this notification
  /// with an extra small size.
  /// This value is only applicable for custom display notifications created using
  /// \#setDisplayIntent.
  static const SIZE_XSMALL = 1;

  /// from: static public final int UNSET_ACTION_INDEX
  /// Sentinel value for an action index that is unset.
  static const UNSET_ACTION_INDEX = -1;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Notification__WearableExtender_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Create a android.app.Notification.WearableExtender with default
  /// options.
  Notification_WearableExtender() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Notification notif)
  Notification_WearableExtender.ctor_1(Notification notif)
      : super.fromRef(_ctor_1(notif.reference));

  static final _extend = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_extend")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder extend(android.app.Notification.Builder builder)
  /// Apply wearable extensions to a notification that is being built. This is typically
  /// called by the android.app.Notification.Builder\#extend method of
  /// android.app.Notification.Builder.
  Notification_Builder extend(Notification_Builder builder) =>
      Notification_Builder.fromRef(_extend(reference, builder.reference));

  static final _clone = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_clone")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender clone()
  Notification_WearableExtender clone() =>
      Notification_WearableExtender.fromRef(_clone(reference));

  static final _addAction = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_addAction")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender addAction(android.app.Notification.Action action)
  /// Add a wearable action to this notification.
  ///
  /// When wearable actions are added using this method, the set of actions that
  /// show on a wearable device splits from devices that only show actions added
  /// using android.app.Notification.Builder\#addAction. This allows for customization
  /// of which actions display on different devices.
  ///@param action the action to add to this notification
  ///@return this object for method chaining
  ///@see android.app.Notification.Action
  Notification_WearableExtender addAction(Notification_Action action) =>
      Notification_WearableExtender.fromRef(
          _addAction(reference, action.reference));

  static final _addActions = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_addActions")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender addActions(java.util.List<android.app.Notification.Action> actions)
  /// Adds wearable actions to this notification.
  ///
  /// When wearable actions are added using this method, the set of actions that
  /// show on a wearable device splits from devices that only show actions added
  /// using android.app.Notification.Builder\#addAction. This allows for customization
  /// of which actions display on different devices.
  ///@param actions the actions to add to this notification
  ///@return this object for method chaining
  ///@see android.app.Notification.Action
  Notification_WearableExtender addActions(jni.JlObject actions) =>
      Notification_WearableExtender.fromRef(
          _addActions(reference, actions.reference));

  static final _clearActions = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_clearActions")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender clearActions()
  /// Clear all wearable actions present on this builder.
  ///@return this object for method chaining.
  ///@see \#addAction
  Notification_WearableExtender clearActions() =>
      Notification_WearableExtender.fromRef(_clearActions(reference));

  static final _getActions = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_getActions")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.Notification.Action> getActions()
  /// Get the wearable actions present on this notification.
  jni.JlObject getActions() => jni.JlObject.fromRef(_getActions(reference));

  static final _setDisplayIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_setDisplayIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender setDisplayIntent(android.app.PendingIntent intent)
  /// Set an intent to launch inside of an activity view when displaying
  /// this notification. The PendingIntent provided should be for an activity.
  ///
  /// <pre class="prettyprint">
  /// Intent displayIntent = new Intent(context, MyDisplayActivity.class);
  /// PendingIntent displayPendingIntent = PendingIntent.getActivity(context,
  ///         0, displayIntent, PendingIntent.FLAG_UPDATE_CURRENT);
  /// Notification notif = new Notification.Builder(context)
  ///         .extend(new Notification.WearableExtender()
  ///                 .setDisplayIntent(displayPendingIntent)
  ///                 .setCustomSizePreset(Notification.WearableExtender.SIZE_MEDIUM))
  ///         .build();</pre>
  ///
  /// The activity to launch needs to allow embedding, must be exported, and
  /// should have an empty task affinity. It is also recommended to use the device
  /// default light theme.
  ///
  /// Example AndroidManifest.xml entry:
  /// <pre class="prettyprint">
  /// &lt;activity android:name=&quot;com.example.MyDisplayActivity&quot;
  ///     android:exported=&quot;true&quot;
  ///     android:allowEmbedded=&quot;true&quot;
  ///     android:taskAffinity=&quot;&quot;
  ///     android:theme=&quot;@android:style/Theme.DeviceDefault.Light&quot; /&gt;</pre>
  ///@param intent the PendingIntent for an activity
  ///@return this object for method chaining
  ///@see android.app.Notification.WearableExtender\#getDisplayIntent
  Notification_WearableExtender setDisplayIntent(PendingIntent intent) =>
      Notification_WearableExtender.fromRef(
          _setDisplayIntent(reference, intent.reference));

  static final _getDisplayIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_getDisplayIntent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent getDisplayIntent()
  /// Get the intent to launch inside of an activity view when displaying this
  /// notification. This {@code PendingIntent} should be for an activity.
  PendingIntent getDisplayIntent() =>
      PendingIntent.fromRef(_getDisplayIntent(reference));

  static final _addPage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_addPage")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender addPage(android.app.Notification page)
  /// Add an additional page of content to display with this notification. The current
  /// notification forms the first page, and pages added using this function form
  /// subsequent pages. This field can be used to separate a notification into multiple
  /// sections.
  ///@param page the notification to add as another page
  ///@return this object for method chaining
  ///@see android.app.Notification.WearableExtender\#getPages
  Notification_WearableExtender addPage(Notification page) =>
      Notification_WearableExtender.fromRef(
          _addPage(reference, page.reference));

  static final _addPages = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_addPages")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender addPages(java.util.List<android.app.Notification> pages)
  /// Add additional pages of content to display with this notification. The current
  /// notification forms the first page, and pages added using this function form
  /// subsequent pages. This field can be used to separate a notification into multiple
  /// sections.
  ///@param pages a list of notifications
  ///@return this object for method chaining
  ///@see android.app.Notification.WearableExtender\#getPages
  Notification_WearableExtender addPages(jni.JlObject pages) =>
      Notification_WearableExtender.fromRef(
          _addPages(reference, pages.reference));

  static final _clearPages = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_clearPages")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender clearPages()
  /// Clear all additional pages present on this builder.
  ///@return this object for method chaining.
  ///@see \#addPage
  Notification_WearableExtender clearPages() =>
      Notification_WearableExtender.fromRef(_clearPages(reference));

  static final _getPages = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_getPages")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.Notification> getPages()
  /// Get the array of additional pages of content for displaying this notification. The
  /// current notification forms the first page, and elements within this array form
  /// subsequent pages. This field can be used to separate a notification into multiple
  /// sections.
  ///@return the pages for this notification
  jni.JlObject getPages() => jni.JlObject.fromRef(_getPages(reference));

  static final _setBackground = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_setBackground")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender setBackground(android.graphics.Bitmap background)
  /// Set a background image to be displayed behind the notification content.
  /// Contrary to the android.app.Notification.BigPictureStyle, this background
  /// will work with any notification style.
  ///@param background the background bitmap
  ///@return this object for method chaining
  ///@see android.app.Notification.WearableExtender\#getBackground
  Notification_WearableExtender setBackground(jni.JlObject background) =>
      Notification_WearableExtender.fromRef(
          _setBackground(reference, background.reference));

  static final _getBackground = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_getBackground")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap getBackground()
  /// Get a background image to be displayed behind the notification content.
  /// Contrary to the android.app.Notification.BigPictureStyle, this background
  /// will work with any notification style.
  ///@return the background image
  ///@see android.app.Notification.WearableExtender\#setBackground
  jni.JlObject getBackground() =>
      jni.JlObject.fromRef(_getBackground(reference));

  static final _setContentIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_Notification__WearableExtender_setContentIcon")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setContentIcon(int icon)
  /// Set an icon that goes with the content of this notification.
  Notification_WearableExtender setContentIcon(int icon) =>
      Notification_WearableExtender.fromRef(_setContentIcon(reference, icon));

  static final _getContentIcon =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Notification__WearableExtender_getContentIcon")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getContentIcon()
  /// Get an icon that goes with the content of this notification.
  int getContentIcon() => _getContentIcon(reference);

  static final _setContentIconGravity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_Notification__WearableExtender_setContentIconGravity")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setContentIconGravity(int contentIconGravity)
  /// Set the gravity that the content icon should have within the notification display.
  /// Supported values include android.view.Gravity\#START and
  /// android.view.Gravity\#END. The default value is android.view.Gravity\#END.
  ///@see \#setContentIcon
  Notification_WearableExtender setContentIconGravity(int contentIconGravity) =>
      Notification_WearableExtender.fromRef(
          _setContentIconGravity(reference, contentIconGravity));

  static final _getContentIconGravity = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_getContentIconGravity")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getContentIconGravity()
  /// Get the gravity that the content icon should have within the notification display.
  /// Supported values include android.view.Gravity\#START and
  /// android.view.Gravity\#END. The default value is android.view.Gravity\#END.
  ///@see \#getContentIcon
  int getContentIconGravity() => _getContentIconGravity(reference);

  static final _setContentAction = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_Notification__WearableExtender_setContentAction")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setContentAction(int actionIndex)
  /// Set an action from this notification's actions to be clickable with the content of
  /// this notification. This action will no longer display separately from the
  /// notification's content.
  ///
  /// For notifications with multiple pages, child pages can also have content actions
  /// set, although the list of available actions comes from the main notification and not
  /// from the child page's notification.
  ///@param actionIndex The index of the action to hoist onto the current notification page.
  ///                    If wearable actions were added to the main notification, this index
  ///                    will apply to that list, otherwise it will apply to the regular
  ///                    actions list.
  Notification_WearableExtender setContentAction(int actionIndex) =>
      Notification_WearableExtender.fromRef(
          _setContentAction(reference, actionIndex));

  static final _getContentAction =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Notification__WearableExtender_getContentAction")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getContentAction()
  /// Get the index of the notification action, if any, that was specified as being clickable
  /// with the content of this notification. This action will no longer display separately
  /// from the notification's content.
  ///
  /// For notifications with multiple pages, child pages can also have content actions
  /// set, although the list of available actions comes from the main notification and not
  /// from the child page's notification.
  ///
  /// If wearable specific actions were added to the main notification, this index will
  /// apply to that list, otherwise it will apply to the regular actions list.
  ///@return the action index or \#UNSET_ACTION_INDEX if no action was selected.
  int getContentAction() => _getContentAction(reference);

  static final _setGravity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_Notification__WearableExtender_setGravity")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setGravity(int gravity)
  /// Set the gravity that this notification should have within the available viewport space.
  /// Supported values include android.view.Gravity\#TOP,
  /// android.view.Gravity\#CENTER_VERTICAL and android.view.Gravity\#BOTTOM.
  /// The default value is android.view.Gravity\#BOTTOM.
  Notification_WearableExtender setGravity(int gravity) =>
      Notification_WearableExtender.fromRef(_setGravity(reference, gravity));

  static final _getGravity =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Notification__WearableExtender_getGravity")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getGravity()
  /// Get the gravity that this notification should have within the available viewport space.
  /// Supported values include android.view.Gravity\#TOP,
  /// android.view.Gravity\#CENTER_VERTICAL and android.view.Gravity\#BOTTOM.
  /// The default value is android.view.Gravity\#BOTTOM.
  int getGravity() => _getGravity(reference);

  static final _setCustomSizePreset = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_Notification__WearableExtender_setCustomSizePreset")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setCustomSizePreset(int sizePreset)
  /// Set the custom size preset for the display of this notification out of the available
  /// presets found in android.app.Notification.WearableExtender, e.g.
  /// \#SIZE_LARGE.
  /// Some custom size presets are only applicable for custom display notifications created
  /// using android.app.Notification.WearableExtender\#setDisplayIntent. Check the
  /// documentation for the preset in question. See also
  /// \#setCustomContentHeight and \#getCustomSizePreset.
  Notification_WearableExtender setCustomSizePreset(int sizePreset) =>
      Notification_WearableExtender.fromRef(
          _setCustomSizePreset(reference, sizePreset));

  static final _getCustomSizePreset =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Notification__WearableExtender_getCustomSizePreset")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getCustomSizePreset()
  /// Get the custom size preset for the display of this notification out of the available
  /// presets found in android.app.Notification.WearableExtender, e.g.
  /// \#SIZE_LARGE.
  /// Some custom size presets are only applicable for custom display notifications created
  /// using \#setDisplayIntent. Check the documentation for the preset in question.
  /// See also \#setCustomContentHeight and \#setCustomSizePreset.
  int getCustomSizePreset() => _getCustomSizePreset(reference);

  static final _setCustomContentHeight = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_Notification__WearableExtender_setCustomContentHeight")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setCustomContentHeight(int height)
  /// Set the custom height in pixels for the display of this notification's content.
  /// This option is only available for custom display notifications created
  /// using android.app.Notification.WearableExtender\#setDisplayIntent. See also
  /// android.app.Notification.WearableExtender\#setCustomSizePreset and
  /// \#getCustomContentHeight.
  Notification_WearableExtender setCustomContentHeight(int height) =>
      Notification_WearableExtender.fromRef(
          _setCustomContentHeight(reference, height));

  static final _getCustomContentHeight = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_getCustomContentHeight")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getCustomContentHeight()
  /// Get the custom height in pixels for the display of this notification's content.
  /// This option is only available for custom display notifications created
  /// using \#setDisplayIntent. See also \#setCustomSizePreset and
  /// \#setCustomContentHeight.
  int getCustomContentHeight() => _getCustomContentHeight(reference);

  static final _setStartScrollBottom = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Notification__WearableExtender_setStartScrollBottom")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setStartScrollBottom(boolean startScrollBottom)
  /// Set whether the scrolling position for the contents of this notification should start
  /// at the bottom of the contents instead of the top when the contents are too long to
  /// display within the screen.  Default is false (start scroll at the top).
  Notification_WearableExtender setStartScrollBottom(bool startScrollBottom) =>
      Notification_WearableExtender.fromRef(
          _setStartScrollBottom(reference, startScrollBottom ? 1 : 0));

  static final _getStartScrollBottom =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Notification__WearableExtender_getStartScrollBottom")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getStartScrollBottom()
  /// Get whether the scrolling position for the contents of this notification should start
  /// at the bottom of the contents instead of the top when the contents are too long to
  /// display within the screen. Default is false (start scroll at the top).
  bool getStartScrollBottom() => _getStartScrollBottom(reference) != 0;

  static final _setContentIntentAvailableOffline = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Notification__WearableExtender_setContentIntentAvailableOffline")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setContentIntentAvailableOffline(boolean contentIntentAvailableOffline)
  /// Set whether the content intent is available when the wearable device is not connected
  /// to a companion device.  The user can still trigger this intent when the wearable device
  /// is offline, but a visual hint will indicate that the content intent may not be available.
  /// Defaults to true.
  Notification_WearableExtender setContentIntentAvailableOffline(
          bool contentIntentAvailableOffline) =>
      Notification_WearableExtender.fromRef(_setContentIntentAvailableOffline(
          reference, contentIntentAvailableOffline ? 1 : 0));

  static final _getContentIntentAvailableOffline = jlookup<
              ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_getContentIntentAvailableOffline")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getContentIntentAvailableOffline()
  /// Get whether the content intent is available when the wearable device is not connected
  /// to a companion device.  The user can still trigger this intent when the wearable device
  /// is offline, but a visual hint will indicate that the content intent may not be available.
  /// Defaults to true.
  bool getContentIntentAvailableOffline() =>
      _getContentIntentAvailableOffline(reference) != 0;

  static final _setHintHideIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Notification__WearableExtender_setHintHideIcon")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setHintHideIcon(boolean hintHideIcon)
  /// Set a hint that this notification's icon should not be displayed.
  ///@param hintHideIcon {@code true} to hide the icon, {@code false} otherwise.
  ///@return this object for method chaining
  Notification_WearableExtender setHintHideIcon(bool hintHideIcon) =>
      Notification_WearableExtender.fromRef(
          _setHintHideIcon(reference, hintHideIcon ? 1 : 0));

  static final _getHintHideIcon =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Notification__WearableExtender_getHintHideIcon")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getHintHideIcon()
  /// Get a hint that this notification's icon should not be displayed.
  ///@return {@code true} if this icon should not be displayed, false otherwise.
  /// The default value is {@code false} if this was never set.
  bool getHintHideIcon() => _getHintHideIcon(reference) != 0;

  static final _setHintShowBackgroundOnly = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Notification__WearableExtender_setHintShowBackgroundOnly")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setHintShowBackgroundOnly(boolean hintShowBackgroundOnly)
  /// Set a visual hint that only the background image of this notification should be
  /// displayed, and other semantic content should be hidden. This hint is only applicable
  /// to sub-pages added using \#addPage.
  Notification_WearableExtender setHintShowBackgroundOnly(
          bool hintShowBackgroundOnly) =>
      Notification_WearableExtender.fromRef(_setHintShowBackgroundOnly(
          reference, hintShowBackgroundOnly ? 1 : 0));

  static final _getHintShowBackgroundOnly = jlookup<
              ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_getHintShowBackgroundOnly")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getHintShowBackgroundOnly()
  /// Get a visual hint that only the background image of this notification should be
  /// displayed, and other semantic content should be hidden. This hint is only applicable
  /// to sub-pages added using android.app.Notification.WearableExtender\#addPage.
  bool getHintShowBackgroundOnly() =>
      _getHintShowBackgroundOnly(reference) != 0;

  static final _setHintAvoidBackgroundClipping = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Notification__WearableExtender_setHintAvoidBackgroundClipping")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setHintAvoidBackgroundClipping(boolean hintAvoidBackgroundClipping)
  /// Set a hint that this notification's background should not be clipped if possible,
  /// and should instead be resized to fully display on the screen, retaining the aspect
  /// ratio of the image. This can be useful for images like barcodes or qr codes.
  ///@param hintAvoidBackgroundClipping {@code true} to avoid clipping if possible.
  ///@return this object for method chaining
  Notification_WearableExtender setHintAvoidBackgroundClipping(
          bool hintAvoidBackgroundClipping) =>
      Notification_WearableExtender.fromRef(_setHintAvoidBackgroundClipping(
          reference, hintAvoidBackgroundClipping ? 1 : 0));

  static final _getHintAvoidBackgroundClipping = jlookup<
              ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_getHintAvoidBackgroundClipping")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getHintAvoidBackgroundClipping()
  /// Get a hint that this notification's background should not be clipped if possible,
  /// and should instead be resized to fully display on the screen, retaining the aspect
  /// ratio of the image. This can be useful for images like barcodes or qr codes.
  ///@return {@code true} if it's ok if the background is clipped on the screen, false
  /// otherwise. The default value is {@code false} if this was never set.
  bool getHintAvoidBackgroundClipping() =>
      _getHintAvoidBackgroundClipping(reference) != 0;

  static final _setHintScreenTimeout = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_Notification__WearableExtender_setHintScreenTimeout")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setHintScreenTimeout(int timeout)
  /// Set a hint that the screen should remain on for at least this duration when
  /// this notification is displayed on the screen.
  ///@param timeout The requested screen timeout in milliseconds. Can also be either
  ///     \#SCREEN_TIMEOUT_SHORT or \#SCREEN_TIMEOUT_LONG.
  ///@return this object for method chaining
  Notification_WearableExtender setHintScreenTimeout(int timeout) =>
      Notification_WearableExtender.fromRef(
          _setHintScreenTimeout(reference, timeout));

  static final _getHintScreenTimeout =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Notification__WearableExtender_getHintScreenTimeout")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getHintScreenTimeout()
  /// Get the duration, in milliseconds, that the screen should remain on for
  /// when this notification is displayed.
  ///@return the duration in milliseconds if > 0, or either one of the sentinel values
  ///     \#SCREEN_TIMEOUT_SHORT or \#SCREEN_TIMEOUT_LONG.
  int getHintScreenTimeout() => _getHintScreenTimeout(reference);

  static final _setHintAmbientBigPicture = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Notification__WearableExtender_setHintAmbientBigPicture")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setHintAmbientBigPicture(boolean hintAmbientBigPicture)
  /// Set a hint that this notification's BigPictureStyle (if present) should be
  /// converted to low-bit and displayed in ambient mode, especially useful for barcodes and
  /// qr codes, as well as other simple black-and-white tickets.
  ///@param hintAmbientBigPicture {@code true} to enable converstion and ambient.
  ///@return this object for method chaining
  Notification_WearableExtender setHintAmbientBigPicture(
          bool hintAmbientBigPicture) =>
      Notification_WearableExtender.fromRef(
          _setHintAmbientBigPicture(reference, hintAmbientBigPicture ? 1 : 0));

  static final _getHintAmbientBigPicture = jlookup<
              ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_getHintAmbientBigPicture")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getHintAmbientBigPicture()
  /// Get a hint that this notification's BigPictureStyle (if present) should be
  /// converted to low-bit and displayed in ambient mode, especially useful for barcodes and
  /// qr codes, as well as other simple black-and-white tickets.
  ///@return {@code true} if it should be displayed in ambient, false otherwise
  /// otherwise. The default value is {@code false} if this was never set.
  bool getHintAmbientBigPicture() => _getHintAmbientBigPicture(reference) != 0;

  static final _setHintContentIntentLaunchesActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Notification__WearableExtender_setHintContentIntentLaunchesActivity")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setHintContentIntentLaunchesActivity(boolean hintContentIntentLaunchesActivity)
  /// Set a hint that this notification's content intent will launch an Activity
  /// directly, telling the platform that it can generate the appropriate transitions.
  ///@param hintContentIntentLaunchesActivity {@code true} if the content intent will launch
  /// an activity and transitions should be generated, false otherwise.
  ///@return this object for method chaining
  Notification_WearableExtender setHintContentIntentLaunchesActivity(
          bool hintContentIntentLaunchesActivity) =>
      Notification_WearableExtender.fromRef(
          _setHintContentIntentLaunchesActivity(
              reference, hintContentIntentLaunchesActivity ? 1 : 0));

  static final _getHintContentIntentLaunchesActivity = jlookup<
              ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_getHintContentIntentLaunchesActivity")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getHintContentIntentLaunchesActivity()
  /// Get a hint that this notification's content intent will launch an Activity
  /// directly, telling the platform that it can generate the appropriate transitions
  ///@return {@code true} if the content intent will launch an activity and transitions should
  /// be generated, false otherwise. The default value is {@code false} if this was never set.
  bool getHintContentIntentLaunchesActivity() =>
      _getHintContentIntentLaunchesActivity(reference) != 0;

  static final _setDismissalId = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_setDismissalId")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender setDismissalId(java.lang.String dismissalId)
  /// Sets the dismissal id for this notification. If a notification is posted with a
  /// dismissal id, then when that notification is canceled, notifications on other wearables
  /// and the paired Android phone having that same dismissal id will also be canceled. See
  /// <a href="{@docRoot}wear/notifications/index.html">Adding Wearable Features to
  /// Notifications</a> for more information.
  ///@param dismissalId the dismissal id of the notification.
  ///@return this object for method chaining
  Notification_WearableExtender setDismissalId(jni.JlString dismissalId) =>
      Notification_WearableExtender.fromRef(
          _setDismissalId(reference, dismissalId.reference));

  static final _getDismissalId = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_getDismissalId")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getDismissalId()
  /// Returns the dismissal id of the notification.
  ///@return the dismissal id of the notification or null if it has not been set.
  jni.JlString getDismissalId() =>
      jni.JlString.fromRef(_getDismissalId(reference));

  static final _setBridgeTag = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_setBridgeTag")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender setBridgeTag(java.lang.String bridgeTag)
  /// Sets a bridge tag for this notification. A bridge tag can be set for notifications
  /// posted from a phone to provide finer-grained control on what notifications are bridged
  /// to wearables. See <a href="{@docRoot}wear/notifications/index.html">Adding Wearable
  /// Features to Notifications</a> for more information.
  ///@param bridgeTag the bridge tag of the notification.
  ///@return this object for method chaining
  Notification_WearableExtender setBridgeTag(jni.JlString bridgeTag) =>
      Notification_WearableExtender.fromRef(
          _setBridgeTag(reference, bridgeTag.reference));

  static final _getBridgeTag = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__WearableExtender_getBridgeTag")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getBridgeTag()
  /// Returns the bridge tag of the notification.
  ///@return the bridge tag or null if not present.
  jni.JlString getBridgeTag() => jni.JlString.fromRef(_getBridgeTag(reference));
}

/// An object that can apply a rich notification style to a Notification.Builder
/// object.
class Notification_Style extends jni.JlObject {
  Notification_Style.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: protected android.app.Notification.Builder mBuilder
  static final _getmBuilder = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification__Style_mBuilder")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  Notification_Builder get mBuilder =>
      Notification_Builder.fromRef(_getmBuilder(reference));
  static final _setmBuilder = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_Notification__Style_mBuilder")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set mBuilder(Notification_Builder value) =>
      _setmBuilder(reference, value.reference);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Notification__Style_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Notification_Style() : super.fromRef(_ctor());

  static final _internalSetBigContentTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Style_internalSetBigContentTitle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void internalSetBigContentTitle(java.lang.CharSequence title)
  /// Overrides ContentTitle in the big form of the template.
  /// This defaults to the value passed to setContentTitle().
  void internalSetBigContentTitle(jni.JlObject title) =>
      _internalSetBigContentTitle(reference, title.reference);

  static final _internalSetSummaryText = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Style_internalSetSummaryText")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void internalSetSummaryText(java.lang.CharSequence cs)
  /// Set the first line of text after the detail section in the big form of the template.
  void internalSetSummaryText(jni.JlObject cs) =>
      _internalSetSummaryText(reference, cs.reference);

  static final _setBuilder = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Style_setBuilder")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setBuilder(android.app.Notification.Builder builder)
  void setBuilder(Notification_Builder builder) =>
      _setBuilder(reference, builder.reference);

  static final _checkBuilder =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Notification__Style_checkBuilder")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void checkBuilder()
  void checkBuilder() => _checkBuilder(reference);

  static final _getStandardView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_Notification__Style_getStandardView")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: protected android.widget.RemoteViews getStandardView(int layoutId)
  jni.JlObject getStandardView(int layoutId) =>
      jni.JlObject.fromRef(_getStandardView(reference, layoutId));

  static final _build = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Style_build")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification build()
  /// Calls android.app.Notification.Builder\#build() on the Builder this Style is
  /// attached to.
  ///@return the fully constructed Notification.
  Notification build() => Notification.fromRef(_build(reference));
}

/// Helper class for generating large-format notifications that include multiple back-and-forth
/// messages of varying types between any number of people.
///
///
/// If the platform does not provide large-format notifications, this method has no effect. The
/// user will always see the normal notification view.
///
///
/// If the app is targeting Android P and above, it is required to use the Person
/// class in order to get an optimal rendering of the notification and its avatars. For
/// conversations involving multiple people, the app should also make sure that it marks the
/// conversation as a group with \#setGroupConversation(boolean).
///
///
/// This class is a "rebuilder": It attaches to a Builder object and modifies its behavior.
/// Here's an example of how this may be used:
/// <pre class="prettyprint">
///
/// Person user = new Person.Builder().setIcon(userIcon).setName(userName).build();
/// MessagingStyle style = new MessagingStyle(user)
///      .addMessage(messages[1].getText(), messages[1].getTime(), messages[1].getPerson())
///      .addMessage(messages[2].getText(), messages[2].getTime(), messages[2].getPerson())
///      .setGroupConversation(hasMultiplePeople());
///
/// Notification noti = new Notification.Builder()
///     .setContentTitle(&quot;2 new messages with &quot; + sender.toString())
///     .setContentText(subject)
///     .setSmallIcon(R.drawable.new_message)
///     .setLargeIcon(aBitmap)
///     .setStyle(style)
///     .build();
/// </pre>
class Notification_MessagingStyle extends Notification_Style {
  Notification_MessagingStyle.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final int MAXIMUM_RETAINED_MESSAGES
  /// The maximum number of messages that will be retained in the Notification itself (the
  /// number displayed is up to the platform).
  static const MAXIMUM_RETAINED_MESSAGES = 25;

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.CharSequence userDisplayName)
  /// @param userDisplayName Required - the name to be displayed for any replies sent by the
  /// user before the posting app reposts the notification with those messages after they've
  /// been actually sent and in previous messages sent by the user added in
  /// \#addMessage(Notification.MessagingStyle.Message)
  ///
  /// This value must never be {@code null}.
  ///@deprecated use {@code MessagingStyle(Person)}
  Notification_MessagingStyle(jni.JlObject userDisplayName)
      : super.fromRef(_ctor(userDisplayName.reference));

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Person user)
  /// @param user Required - The person displayed for any messages that are sent by the
  /// user. Any messages added with \#addMessage(Notification.MessagingStyle.Message)
  /// who don't have a Person associated with it will be displayed as if they were sent
  /// by this user. The user also needs to have a valid name associated with it, which will
  /// be enforced starting in Android P.
  ///
  /// This value must never be {@code null}.
  Notification_MessagingStyle.ctor_1(Person user)
      : super.fromRef(_ctor_1(user.reference));

  static final _getUser = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle_getUser")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Person getUser()
  /// @return the user to be displayed for any replies sent by the user
  ///
  /// This value will never be {@code null}.
  Person getUser() => Person.fromRef(_getUser(reference));

  static final _getUserDisplayName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle_getUserDisplayName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getUserDisplayName()
  /// Returns the name to be displayed for any replies sent by the user
  ///@deprecated use \#getUser() instead
  jni.JlObject getUserDisplayName() =>
      jni.JlObject.fromRef(_getUserDisplayName(reference));

  static final _setConversationTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle_setConversationTitle")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.MessagingStyle setConversationTitle(java.lang.CharSequence conversationTitle)
  /// Sets the title to be displayed on this conversation. May be set to {@code null}.
  ///
  /// This API's behavior was changed in SDK version Build.VERSION_CODES\#P. If your
  /// application's target version is less than Build.VERSION_CODES\#P, setting a
  /// conversation title to a non-null value will make \#isGroupConversation() return
  /// {@code true} and passing {@code null} will make it return {@code false}. In
  /// Build.VERSION_CODES\#P and beyond, use \#setGroupConversation(boolean)
  /// to set group conversation status.
  ///@param conversationTitle Title displayed for this conversation
  /// This value may be {@code null}.
  ///@return this object for method chaining
  Notification_MessagingStyle setConversationTitle(
          jni.JlObject conversationTitle) =>
      Notification_MessagingStyle.fromRef(
          _setConversationTitle(reference, conversationTitle.reference));

  static final _getConversationTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle_getConversationTitle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getConversationTitle()
  /// Return the title to be displayed on this conversation. May return {@code null}.
  jni.JlObject getConversationTitle() =>
      jni.JlObject.fromRef(_getConversationTitle(reference));

  static final _addMessage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int64,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle_addMessage")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.MessagingStyle addMessage(java.lang.CharSequence text, long timestamp, java.lang.CharSequence sender)
  /// Adds a message for display by this notification. Convenience call for a simple
  /// Message in \#addMessage(Notification.MessagingStyle.Message).
  ///@param text A CharSequence to be displayed as the message content
  ///@param timestamp Time at which the message arrived
  ///@param sender A CharSequence to be used for displaying the name of the
  /// sender. Should be <code>null</code> for messages by the current user, in which case
  /// the platform will insert \#getUserDisplayName().
  /// Should be unique amongst all individuals in the conversation, and should be
  /// consistent during re-posts of the notification.
  ///@see Message\#Message(CharSequence, long, CharSequence)
  ///@return this object for method chaining
  ///@deprecated use \#addMessage(CharSequence, long, Person)
  Notification_MessagingStyle addMessage(
          jni.JlObject text, int timestamp, jni.JlObject sender) =>
      Notification_MessagingStyle.fromRef(
          _addMessage(reference, text.reference, timestamp, sender.reference));

  static final _addMessage_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int64,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle_addMessage_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.MessagingStyle addMessage(java.lang.CharSequence text, long timestamp, android.app.Person sender)
  /// Adds a message for display by this notification. Convenience call for a simple
  /// Message in \#addMessage(Notification.MessagingStyle.Message).
  ///@param text A CharSequence to be displayed as the message content
  /// This value must never be {@code null}.
  ///@param timestamp Time at which the message arrived
  ///@param sender The Person who sent the message.
  /// Should be <code>null</code> for messages by the current user, in which case
  /// the platform will insert the user set in {@code MessagingStyle(Person)}.
  ///
  /// This value may be {@code null}.
  ///@see Message\#Message(CharSequence, long, CharSequence)
  ///@return this object for method chaining
  Notification_MessagingStyle addMessage_1(
          jni.JlObject text, int timestamp, Person sender) =>
      Notification_MessagingStyle.fromRef(_addMessage_1(
          reference, text.reference, timestamp, sender.reference));

  static final _addMessage_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle_addMessage_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.MessagingStyle addMessage(android.app.Notification.MessagingStyle.Message message)
  /// Adds a Message for display in this notification.
  ///
  /// The messages should be added in chronologic order, i.e. the oldest first,
  /// the newest last.
  ///@param message The Message to be displayed
  ///@return this object for method chaining
  Notification_MessagingStyle addMessage_2(
          Notification_MessagingStyle_Message message) =>
      Notification_MessagingStyle.fromRef(
          _addMessage_2(reference, message.reference));

  static final _addHistoricMessage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle_addHistoricMessage")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.MessagingStyle addHistoricMessage(android.app.Notification.MessagingStyle.Message message)
  /// Adds a Message for historic context in this notification.
  ///
  /// Messages should be added as historic if they are not the main subject of the
  /// notification but may give context to a conversation. The system may choose to present
  /// them only when relevant, e.g. when replying to a message through a RemoteInput.
  ///
  /// The messages should be added in chronologic order, i.e. the oldest first,
  /// the newest last.
  ///@param message The historic Message to be added
  ///@return this object for method chaining
  Notification_MessagingStyle addHistoricMessage(
          Notification_MessagingStyle_Message message) =>
      Notification_MessagingStyle.fromRef(
          _addHistoricMessage(reference, message.reference));

  static final _getMessages = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle_getMessages")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.Notification.MessagingStyle.Message> getMessages()
  /// Gets the list of {@code Message} objects that represent the notification
  jni.JlObject getMessages() => jni.JlObject.fromRef(_getMessages(reference));

  static final _getHistoricMessages = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle_getHistoricMessages")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.Notification.MessagingStyle.Message> getHistoricMessages()
  /// Gets the list of historic {@code Message}s in the notification.
  jni.JlObject getHistoricMessages() =>
      jni.JlObject.fromRef(_getHistoricMessages(reference));

  static final _setGroupConversation = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Notification__MessagingStyle_setGroupConversation")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.MessagingStyle setGroupConversation(boolean isGroupConversation)
  /// Sets whether this conversation notification represents a group. If the app is targeting
  /// Android P, this is required if the app wants to display the largeIcon set with
  /// Notification.Builder\#setLargeIcon(Bitmap), otherwise it will be hidden.
  ///@param isGroupConversation {@code true} if the conversation represents a group,
  /// {@code false} otherwise.
  ///@return this object for method chaining
  Notification_MessagingStyle setGroupConversation(bool isGroupConversation) =>
      Notification_MessagingStyle.fromRef(
          _setGroupConversation(reference, isGroupConversation ? 1 : 0));

  static final _isGroupConversation =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Notification__MessagingStyle_isGroupConversation")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isGroupConversation()
  /// Returns {@code true} if this notification represents a group conversation, otherwise
  /// {@code false}.
  ///
  ///  If the application that generated this MessagingStyle targets an SDK version
  /// less than Build.VERSION_CODES\#P, this method becomes dependent on whether or
  /// not the conversation title is set; returning {@code true} if the conversation title is
  /// a non-null value, or {@code false} otherwise. From Build.VERSION_CODES\#P forward,
  /// this method returns what's set by \#setGroupConversation(boolean) allowing for
  /// named, non-group conversations.
  ///@see \#setConversationTitle(CharSequence)
  bool isGroupConversation() => _isGroupConversation(reference) != 0;
}

class Notification_MessagingStyle_Message extends jni.JlObject {
  Notification_MessagingStyle_Message.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int64, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle__Message_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.CharSequence text, long timestamp, java.lang.CharSequence sender)
  /// Constructor
  ///@param text A CharSequence to be displayed as the message content
  ///@param timestamp Time at which the message arrived
  ///@param sender A CharSequence to be used for displaying the name of the
  /// sender. Should be <code>null</code> for messages by the current user, in which case
  /// the platform will insert MessagingStyle\#getUserDisplayName().
  /// Should be unique amongst all individuals in the conversation, and should be
  /// consistent during re-posts of the notification.
  ///@deprecated use {@code Message(CharSequence, long, Person)}
  Notification_MessagingStyle_Message(
      jni.JlObject text, int timestamp, jni.JlObject sender)
      : super.fromRef(_ctor(text.reference, timestamp, sender.reference));

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int64, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle__Message_new_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.CharSequence text, long timestamp, android.app.Person sender)
  /// Constructor
  ///@param text A CharSequence to be displayed as the message content
  /// This value must never be {@code null}.
  ///@param timestamp Time at which the message arrived
  ///@param sender The Person who sent the message.
  /// Should be <code>null</code> for messages by the current user, in which case
  /// the platform will insert the user set in {@code MessagingStyle(Person)}.
  ///
  /// The person provided should contain an Icon, set with
  /// Person.Builder\#setIcon(Icon) and also have a name provided
  /// with Person.Builder\#setName(CharSequence). If multiple users have the same
  /// name, consider providing a key with Person.Builder\#setKey(String) in order
  /// to differentiate between the different users.
  ///
  ///
  ///
  /// This value may be {@code null}.
  Notification_MessagingStyle_Message.ctor_1(
      jni.JlObject text, int timestamp, Person sender)
      : super.fromRef(_ctor_1(text.reference, timestamp, sender.reference));

  static final _setData = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle__Message_setData")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.MessagingStyle.Message setData(java.lang.String dataMimeType, android.net.Uri dataUri)
  /// Sets a binary blob of data and an associated MIME type for a message. In the case
  /// where the platform doesn't support the MIME type, the original text provided in the
  /// constructor will be used.
  ///@param dataMimeType The MIME type of the content. See
  /// <a href="{@docRoot}notifications/messaging.html"> for the list of supported MIME
  /// types on Android and Android Wear.
  ///@param dataUri The uri containing the content whose type is given by the MIME type.
  /// <p class="note">
  /// <ol>
  ///   <li>Notification Listeners including the System UI need permission to access the
  ///       data the Uri points to. The recommended ways to do this are:</li>
  ///   <li>Store the data in your own ContentProvider, making sure that other apps have
  ///       the correct permission to access your provider. The preferred mechanism for
  ///       providing access is to use per-URI permissions which are temporary and only
  ///       grant access to the receiving application. An easy way to create a
  ///       ContentProvider like this is to use the FileProvider helper class.</li>
  ///   <li>Use the system MediaStore. The MediaStore is primarily aimed at video, audio
  ///       and image MIME types, however beginning with Android 3.0 (API level 11) it can
  ///       also store non-media types (see MediaStore.Files for more info). Files can be
  ///       inserted into the MediaStore using scanFile() after which a content:// style
  ///       Uri suitable for sharing is passed to the provided onScanCompleted() callback.
  ///       Note that once added to the system MediaStore the content is accessible to any
  ///       app on the device.</li>
  /// </ol>
  ///@return this object for method chaining
  Notification_MessagingStyle_Message setData(
          jni.JlString dataMimeType, jni.JlObject dataUri) =>
      Notification_MessagingStyle_Message.fromRef(
          _setData(reference, dataMimeType.reference, dataUri.reference));

  static final _getText = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle__Message_getText")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getText()
  /// Get the text to be used for this message, or the fallback text if a type and content
  /// Uri have been set
  jni.JlObject getText() => jni.JlObject.fromRef(_getText(reference));

  static final _getTimestamp =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Notification__MessagingStyle__Message_getTimestamp")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTimestamp()
  /// Get the time at which this message arrived
  int getTimestamp() => _getTimestamp(reference);

  static final _getExtras = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle__Message_getExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getExtras()
  /// Get the extras Bundle for this message.
  os.Bundle getExtras() => os.Bundle.fromRef(_getExtras(reference));

  static final _getSender = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle__Message_getSender")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getSender()
  /// Get the text used to display the contact's name in the messaging experience
  ///@deprecated use \#getSenderPerson()
  jni.JlObject getSender() => jni.JlObject.fromRef(_getSender(reference));

  static final _getSenderPerson = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle__Message_getSenderPerson")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Person getSenderPerson()
  /// Get the sender associated with this message.
  ///@return This value may be {@code null}.
  Person getSenderPerson() => Person.fromRef(_getSenderPerson(reference));

  static final _getDataMimeType = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle__Message_getDataMimeType")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getDataMimeType()
  /// Get the MIME type of the data pointed to by the Uri
  jni.JlString getDataMimeType() =>
      jni.JlString.fromRef(_getDataMimeType(reference));

  static final _getDataUri = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MessagingStyle__Message_getDataUri")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri getDataUri()
  /// Get the the Uri pointing to the content of the message. Can be null, in which case
  /// {@see \#getText()} is used.
  jni.JlObject getDataUri() => jni.JlObject.fromRef(_getDataUri(reference));
}

/// Notification style for media playback notifications.
///
/// In the expanded form, Notification\#bigContentView, up to 5
/// Notification.Actions specified with
/// Notification.Builder\#addAction(Action) addAction will be
/// shown as icon-only pushbuttons, suitable for transport controls. The Bitmap given to
/// Notification.Builder\#setLargeIcon(android.graphics.Bitmap) setLargeIcon() will be
/// treated as album artwork.
///
/// Unlike the other styles provided here, MediaStyle can also modify the standard-size
/// Notification\#contentView; by providing action indices to
/// \#setShowActionsInCompactView(int...) you can promote up to 3 actions to be displayed
/// in the standard view alongside the usual content.
///
/// Notifications created with MediaStyle will have their category set to
/// Notification\#CATEGORY_TRANSPORT CATEGORY_TRANSPORT unless you set a different
/// category using Notification.Builder\#setCategory(String) setCategory().
///
/// Finally, if you attach a android.media.session.MediaSession.Token using
/// android.app.Notification.MediaStyle\#setMediaSession(MediaSession.Token),
/// the System UI can identify this as a notification representing an active media session
/// and respond accordingly (by showing album artwork in the lockscreen, for example).
///
///
/// Starting at android.os.Build.VERSION_CODES\#O Android O any notification that has a
/// media session attached with \#setMediaSession(MediaSession.Token) will be colorized.
/// You can opt-out of this behavior by using Notification.Builder\#setColorized(boolean).
///
///
/// To use this style with your Notification, feed it to
/// Notification.Builder\#setStyle(android.app.Notification.Style) like so:
/// <pre class="prettyprint">
/// Notification noti = new Notification.Builder()
///     .setSmallIcon(R.drawable.ic_stat_player)
///     .setContentTitle(&quot;Track title&quot;)
///     .setContentText(&quot;Artist - Album&quot;)
///     .setLargeIcon(albumArtBitmap))
///     .setStyle(__new Notification.MediaStyle()__
///         .setMediaSession(mySession))
///     .build();
/// </pre>
///@see Notification\#bigContentView
///@see Notification.Builder\#setColorized(boolean)
class Notification_MediaStyle extends Notification_Style {
  Notification_MediaStyle.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Notification__MediaStyle_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Notification_MediaStyle() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MediaStyle_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Notification.Builder builder)
  /// @deprecated use {@code MediaStyle()}.
  Notification_MediaStyle.ctor_1(Notification_Builder builder)
      : super.fromRef(_ctor_1(builder.reference));

  static final _setShowActionsInCompactView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MediaStyle_setShowActionsInCompactView")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.MediaStyle setShowActionsInCompactView(int[] actions)
  /// Request up to 3 actions (by index in the order of addition) to be shown in the compact
  /// notification view.
  ///@param actions the indices of the actions to show in the compact notification view
  Notification_MediaStyle setShowActionsInCompactView(jni.JlObject actions) =>
      Notification_MediaStyle.fromRef(
          _setShowActionsInCompactView(reference, actions.reference));

  static final _setMediaSession = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__MediaStyle_setMediaSession")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.MediaStyle setMediaSession(android.media.session.MediaSession.Token token)
  /// Attach a android.media.session.MediaSession.Token to this Notification
  /// to provide additional playback information and control to the SystemUI.
  Notification_MediaStyle setMediaSession(jni.JlObject token) =>
      Notification_MediaStyle.fromRef(
          _setMediaSession(reference, token.reference));
}

/// Helper class for generating large-format notifications that include a list of (up to 5) strings.
///
/// Here's how you'd set the <code>InboxStyle</code> on a notification:
/// <pre class="prettyprint">
/// Notification notif = new Notification.Builder(mContext)
///     .setContentTitle(&quot;5 New mails from &quot; + sender.toString())
///     .setContentText(subject)
///     .setSmallIcon(R.drawable.new_mail)
///     .setLargeIcon(aBitmap)
///     .setStyle(new Notification.InboxStyle()
///         .addLine(str1)
///         .addLine(str2)
///         .setContentTitle(&quot;&quot;)
///         .setSummaryText(&quot;+3 more&quot;))
///     .build();
/// </pre>
///@see Notification\#bigContentView
class Notification_InboxStyle extends Notification_Style {
  Notification_InboxStyle.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Notification__InboxStyle_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Notification_InboxStyle() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__InboxStyle_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Notification.Builder builder)
  /// @deprecated use {@code InboxStyle()}.
  Notification_InboxStyle.ctor_1(Notification_Builder builder)
      : super.fromRef(_ctor_1(builder.reference));

  static final _setBigContentTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__InboxStyle_setBigContentTitle")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.InboxStyle setBigContentTitle(java.lang.CharSequence title)
  /// Overrides ContentTitle in the big form of the template.
  /// This defaults to the value passed to setContentTitle().
  Notification_InboxStyle setBigContentTitle(jni.JlObject title) =>
      Notification_InboxStyle.fromRef(
          _setBigContentTitle(reference, title.reference));

  static final _setSummaryText = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__InboxStyle_setSummaryText")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.InboxStyle setSummaryText(java.lang.CharSequence cs)
  /// Set the first line of text after the detail section in the big form of the template.
  Notification_InboxStyle setSummaryText(jni.JlObject cs) =>
      Notification_InboxStyle.fromRef(_setSummaryText(reference, cs.reference));

  static final _addLine = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__InboxStyle_addLine")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.InboxStyle addLine(java.lang.CharSequence cs)
  /// Append a line to the digest section of the Inbox notification.
  Notification_InboxStyle addLine(jni.JlObject cs) =>
      Notification_InboxStyle.fromRef(_addLine(reference, cs.reference));
}

/// Extender interface for use with Builder\#extend. Extenders may be used to add
/// metadata or change options on a notification builder.
class Notification_Extender extends jni.JlObject {
  Notification_Extender.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _extend = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Extender_extend")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.Notification.Builder extend(android.app.Notification.Builder builder)
  /// Apply this extender to a notification builder.
  ///@param builder the builder to be modified.
  ///@return the build object for chaining.
  Notification_Builder extend(Notification_Builder builder) =>
      Notification_Builder.fromRef(_extend(reference, builder.reference));
}

/// Notification style for media custom views that are decorated by the system
///
/// Instead of providing a media notification that is completely custom, a developer can set
/// this style and still obtain system decorations like the notification header with the expand
/// affordance and actions.
///
/// Use android.app.Notification.Builder\#setCustomContentView(RemoteViews),
/// android.app.Notification.Builder\#setCustomBigContentView(RemoteViews) and
/// android.app.Notification.Builder\#setCustomHeadsUpContentView(RemoteViews) to set the
/// corresponding custom views to display.
///
/// Contrary to MediaStyle a developer has to opt-in to the colorizing of the
/// notification by using Notification.Builder\#setColorized(boolean).
///
/// To use this style with your Notification, feed it to
/// Notification.Builder\#setStyle(android.app.Notification.Style) like so:
/// <pre class="prettyprint">
/// Notification noti = new Notification.Builder()
///     .setSmallIcon(R.drawable.ic_stat_player)
///     .setLargeIcon(albumArtBitmap))
///     .setCustomContentView(contentView);
///     .setStyle(__new Notification.DecoratedMediaCustomViewStyle()__
///          .setMediaSession(mySession))
///     .build();
/// </pre>
///@see android.app.Notification.DecoratedCustomViewStyle
///@see android.app.Notification.MediaStyle
class Notification_DecoratedMediaCustomViewStyle
    extends Notification_MediaStyle {
  Notification_DecoratedMediaCustomViewStyle.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Notification__DecoratedMediaCustomViewStyle_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Notification_DecoratedMediaCustomViewStyle() : super.fromRef(_ctor());
}

/// Notification style for custom views that are decorated by the system
///
/// Instead of providing a notification that is completely custom, a developer can set this
/// style and still obtain system decorations like the notification header with the expand
/// affordance and actions.
///
/// Use android.app.Notification.Builder\#setCustomContentView(RemoteViews),
/// android.app.Notification.Builder\#setCustomBigContentView(RemoteViews) and
/// android.app.Notification.Builder\#setCustomHeadsUpContentView(RemoteViews) to set the
/// corresponding custom views to display.
///
/// To use this style with your Notification, feed it to
/// Notification.Builder\#setStyle(android.app.Notification.Style) like so:
/// <pre class="prettyprint">
/// Notification noti = new Notification.Builder()
///     .setSmallIcon(R.drawable.ic_stat_player)
///     .setLargeIcon(albumArtBitmap))
///     .setCustomContentView(contentView);
///     .setStyle(__new Notification.DecoratedCustomViewStyle()__)
///     .build();
/// </pre>
class Notification_DecoratedCustomViewStyle extends Notification_Style {
  Notification_DecoratedCustomViewStyle.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Notification__DecoratedCustomViewStyle_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Notification_DecoratedCustomViewStyle() : super.fromRef(_ctor());
}

/// Helper class to add Android Auto extensions to notifications. To create a notification
/// with car extensions:
///
/// <ol>
///  <li>Create an Notification.Builder, setting any desired
///  properties.
///  <li>Create a CarExtender.
///  <li>Set car-specific properties using the {@code add} and {@code set} methods of
///  CarExtender.
///  <li>Call Notification.Builder\#extend(Notification.Extender)
///  to apply the extensions to a notification.
/// </ol>
///
/// <pre class="prettyprint">
/// Notification notification = new Notification.Builder(context)
///         ...
///         .extend(new CarExtender()
///                 .set*(...))
///         .build();
/// </pre>
///
/// Car extensions can be accessed on an existing notification by using the
/// {@code CarExtender(Notification)} constructor, and then using the {@code get} methods
/// to access values.
class Notification_CarExtender extends jni.JlObject {
  Notification_CarExtender.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Notification__CarExtender_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Create a CarExtender with default options.
  Notification_CarExtender() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__CarExtender_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Notification notif)
  /// Create a CarExtender from the CarExtender options of an existing Notification.
  ///@param notif The notification from which to copy options.
  Notification_CarExtender.ctor_1(Notification notif)
      : super.fromRef(_ctor_1(notif.reference));

  static final _extend = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__CarExtender_extend")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder extend(android.app.Notification.Builder builder)
  /// Apply car extensions to a notification that is being built. This is typically called by
  /// the Notification.Builder\#extend(Notification.Extender)
  /// method of Notification.Builder.
  Notification_Builder extend(Notification_Builder builder) =>
      Notification_Builder.fromRef(_extend(reference, builder.reference));

  static final _setColor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Notification__CarExtender_setColor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.CarExtender setColor(int color)
  /// Sets the accent color to use when Android Auto presents the notification.
  ///
  /// Android Auto uses the color set with Notification.Builder\#setColor(int)
  /// to accent the displayed notification. However, not all colors are acceptable in an
  /// automotive setting. This method can be used to override the color provided in the
  /// notification in such a situation.
  Notification_CarExtender setColor(int color) =>
      Notification_CarExtender.fromRef(_setColor(reference, color));

  static final _getColor =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Notification__CarExtender_getColor")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getColor()
  /// Gets the accent color.
  ///@see \#setColor
  int getColor() => _getColor(reference);

  static final _setLargeIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__CarExtender_setLargeIcon")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.CarExtender setLargeIcon(android.graphics.Bitmap largeIcon)
  /// Sets the large icon of the car notification.
  ///
  /// If no large icon is set in the extender, Android Auto will display the icon
  /// specified by Notification.Builder\#setLargeIcon(android.graphics.Bitmap)
  ///@param largeIcon The large icon to use in the car notification.
  ///@return This object for method chaining.
  Notification_CarExtender setLargeIcon(jni.JlObject largeIcon) =>
      Notification_CarExtender.fromRef(
          _setLargeIcon(reference, largeIcon.reference));

  static final _getLargeIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__CarExtender_getLargeIcon")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap getLargeIcon()
  /// Gets the large icon used in this car notification, or null if no icon has been set.
  ///@return The large icon for the car notification.
  ///@see CarExtender\#setLargeIcon
  jni.JlObject getLargeIcon() => jni.JlObject.fromRef(_getLargeIcon(reference));

  static final _setUnreadConversation = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__CarExtender_setUnreadConversation")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.CarExtender setUnreadConversation(android.app.Notification.CarExtender.UnreadConversation unreadConversation)
  /// Sets the unread conversation in a message notification.
  ///@param unreadConversation The unread part of the conversation this notification conveys.
  ///@return This object for method chaining.
  Notification_CarExtender setUnreadConversation(
          Notification_CarExtender_UnreadConversation unreadConversation) =>
      Notification_CarExtender.fromRef(
          _setUnreadConversation(reference, unreadConversation.reference));

  static final _getUnreadConversation = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__CarExtender_getUnreadConversation")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.CarExtender.UnreadConversation getUnreadConversation()
  /// Returns the unread conversation conveyed by this notification.
  ///@see \#setUnreadConversation(UnreadConversation)
  Notification_CarExtender_UnreadConversation getUnreadConversation() =>
      Notification_CarExtender_UnreadConversation.fromRef(
          _getUnreadConversation(reference));
}

/// A class which holds the unread messages from a conversation.
class Notification_CarExtender_UnreadConversation extends jni.JlObject {
  Notification_CarExtender_UnreadConversation.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int64)>>(
          "android_app_Notification__CarExtender__UnreadConversation_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int)>();

  /// from: void <init>(java.lang.String[] messages, android.app.RemoteInput remoteInput, android.app.PendingIntent replyPendingIntent, android.app.PendingIntent readPendingIntent, java.lang.String[] participants, long latestTimestamp)
  Notification_CarExtender_UnreadConversation(
      jni.JlObject messages,
      RemoteInput remoteInput,
      PendingIntent replyPendingIntent,
      PendingIntent readPendingIntent,
      jni.JlObject participants,
      int latestTimestamp)
      : super.fromRef(_ctor(
            messages.reference,
            remoteInput.reference,
            replyPendingIntent.reference,
            readPendingIntent.reference,
            participants.reference,
            latestTimestamp));

  static final _getMessages = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__CarExtender__UnreadConversation_getMessages")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getMessages()
  /// Gets the list of messages conveyed by this notification.
  jni.JlObject getMessages() => jni.JlObject.fromRef(_getMessages(reference));

  static final _getRemoteInput = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__CarExtender__UnreadConversation_getRemoteInput")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.RemoteInput getRemoteInput()
  /// Gets the remote input that will be used to convey the response to a message list, or
  /// null if no such remote input exists.
  RemoteInput getRemoteInput() =>
      RemoteInput.fromRef(_getRemoteInput(reference));

  static final _getReplyPendingIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__CarExtender__UnreadConversation_getReplyPendingIntent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent getReplyPendingIntent()
  /// Gets the pending intent that will be triggered when the user replies to this
  /// notification.
  PendingIntent getReplyPendingIntent() =>
      PendingIntent.fromRef(_getReplyPendingIntent(reference));

  static final _getReadPendingIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__CarExtender__UnreadConversation_getReadPendingIntent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent getReadPendingIntent()
  /// Gets the pending intent that Android Auto will send after it reads aloud all messages
  /// in this object's message list.
  PendingIntent getReadPendingIntent() =>
      PendingIntent.fromRef(_getReadPendingIntent(reference));

  static final _getParticipants = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__CarExtender__UnreadConversation_getParticipants")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getParticipants()
  /// Gets the participants in the conversation.
  jni.JlObject getParticipants() =>
      jni.JlObject.fromRef(_getParticipants(reference));

  static final _getParticipant = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__CarExtender__UnreadConversation_getParticipant")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getParticipant()
  /// Gets the firs participant in the conversation.
  jni.JlString getParticipant() =>
      jni.JlString.fromRef(_getParticipant(reference));

  static final _getLatestTimestamp = jlookup<
              ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__CarExtender__UnreadConversation_getLatestTimestamp")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getLatestTimestamp()
  /// Gets the timestamp of the conversation.
  int getLatestTimestamp() => _getLatestTimestamp(reference);
}

/// Builder class for CarExtender.UnreadConversation objects.
class Notification_CarExtender_Builder extends jni.JlObject {
  Notification_CarExtender_Builder.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__CarExtender__Builder_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String name)
  /// Constructs a new builder for CarExtender.UnreadConversation.
  ///@param name The name of the other participant in the conversation.
  Notification_CarExtender_Builder(jni.JlString name)
      : super.fromRef(_ctor(name.reference));

  static final _addMessage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__CarExtender__Builder_addMessage")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.CarExtender.Builder addMessage(java.lang.String message)
  /// Appends a new unread message to the list of messages for this conversation.
  ///
  /// The messages should be added from oldest to newest.
  ///@param message The text of the new unread message.
  ///@return This object for method chaining.
  Notification_CarExtender_Builder addMessage(jni.JlString message) =>
      Notification_CarExtender_Builder.fromRef(
          _addMessage(reference, message.reference));

  static final _setReplyAction = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__CarExtender__Builder_setReplyAction")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.CarExtender.Builder setReplyAction(android.app.PendingIntent pendingIntent, android.app.RemoteInput remoteInput)
  /// Sets the pending intent and remote input which will convey the reply to this
  /// notification.
  ///@param pendingIntent The pending intent which will be triggered on a reply.
  ///@param remoteInput The remote input parcelable which will carry the reply.
  ///@return This object for method chaining.
  ///@see CarExtender.UnreadConversation\#getRemoteInput
  ///@see CarExtender.UnreadConversation\#getReplyPendingIntent
  Notification_CarExtender_Builder setReplyAction(
          PendingIntent pendingIntent, RemoteInput remoteInput) =>
      Notification_CarExtender_Builder.fromRef(_setReplyAction(
          reference, pendingIntent.reference, remoteInput.reference));

  static final _setReadPendingIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__CarExtender__Builder_setReadPendingIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.CarExtender.Builder setReadPendingIntent(android.app.PendingIntent pendingIntent)
  /// Sets the pending intent that will be sent once the messages in this notification
  /// are read.
  ///@param pendingIntent The pending intent to use.
  ///@return This object for method chaining.
  Notification_CarExtender_Builder setReadPendingIntent(
          PendingIntent pendingIntent) =>
      Notification_CarExtender_Builder.fromRef(
          _setReadPendingIntent(reference, pendingIntent.reference));

  static final _setLatestTimestamp = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "android_app_Notification__CarExtender__Builder_setLatestTimestamp")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.CarExtender.Builder setLatestTimestamp(long timestamp)
  /// Sets the timestamp of the most recent message in an unread conversation.
  ///
  /// If a messaging notification has been posted by your application and has not
  /// yet been cancelled, posting a later notification with the same id and tag
  /// but without a newer timestamp may result in Android Auto not displaying a
  /// heads up notification for the later notification.
  ///@param timestamp The timestamp of the most recent message in the conversation.
  ///@return This object for method chaining.
  Notification_CarExtender_Builder setLatestTimestamp(int timestamp) =>
      Notification_CarExtender_Builder.fromRef(
          _setLatestTimestamp(reference, timestamp));

  static final _build = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__CarExtender__Builder_build")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.CarExtender.UnreadConversation build()
  /// Builds a new unread conversation object.
  ///@return The new unread conversation object.
  Notification_CarExtender_UnreadConversation build() =>
      Notification_CarExtender_UnreadConversation.fromRef(_build(reference));
}

/// Builder class for Notification objects.
///
/// Provides a convenient way to set the various fields of a Notification and generate
/// content views using the platform's notification layout template. If your app supports
/// versions of Android as old as API level 4, you can instead use
/// android.support.v4.app.NotificationCompat.Builder NotificationCompat.Builder,
/// available in the <a href="{@docRoot}tools/extras/support-library.html">Android Support
/// library</a>.
///
/// Example:
///
/// <pre class="prettyprint">
/// Notification noti = new Notification.Builder(mContext)
///         .setContentTitle(&quot;New mail from &quot; + sender.toString())
///         .setContentText(subject)
///         .setSmallIcon(R.drawable.new_mail)
///         .setLargeIcon(aBitmap)
///         .build();
/// </pre>
class Notification_Builder extends jni.JlObject {
  Notification_Builder.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context, java.lang.String channelId)
  /// Constructs a new Builder with the defaults:
  ///@param context A Context that will be used by the Builder to construct the
  ///            RemoteViews. The Context will not be held past the lifetime of this Builder
  ///            object.
  ///@param channelId The constructed Notification will be posted on this
  ///            NotificationChannel. To use a NotificationChannel, it must first be
  ///            created using NotificationManager\#createNotificationChannel.
  Notification_Builder(content.Context context, jni.JlString channelId)
      : super.fromRef(_ctor(context.reference, channelId.reference));

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  /// @deprecated use Notification.Builder\#Notification.Builder(Context, String)
  /// instead. All posted Notifications must specify a NotificationChannel Id.
  Notification_Builder.ctor_1(content.Context context)
      : super.fromRef(_ctor_1(context.reference));

  static final _setShortcutId = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setShortcutId")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setShortcutId(java.lang.String shortcutId)
  /// If this notification is duplicative of a Launcher shortcut, sets the
  /// ShortcutInfo\#getId() id of the shortcut, in case the Launcher wants to hide
  /// the shortcut.
  ///
  /// This field will be ignored by Launchers that don't support badging, don't show
  /// notification content, or don't show android.content.pm.ShortcutManager shortcuts.
  ///@param shortcutId the ShortcutInfo\#getId() id of the shortcut this notification
  ///                   supersedes
  Notification_Builder setShortcutId(jni.JlString shortcutId) =>
      Notification_Builder.fromRef(
          _setShortcutId(reference, shortcutId.reference));

  static final _setBadgeIconType = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_Notification__Builder_setBadgeIconType")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setBadgeIconType(int icon)
  /// Sets which icon to display as a badge for this notification.
  ///
  /// Must be one of \#BADGE_ICON_NONE, \#BADGE_ICON_SMALL,
  /// \#BADGE_ICON_LARGE.
  ///
  /// Note: This value might be ignored, for launchers that don't support badge icons.
  Notification_Builder setBadgeIconType(int icon) =>
      Notification_Builder.fromRef(_setBadgeIconType(reference, icon));

  static final _setGroupAlertBehavior = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_Notification__Builder_setGroupAlertBehavior")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setGroupAlertBehavior(int groupAlertBehavior)
  /// Sets the group alert behavior for this notification. Use this method to mute this
  /// notification if alerts for this notification's group should be handled by a different
  /// notification. This is only applicable for notifications that belong to a
  /// \#setGroup(String) group. This must be called on all notifications you want to
  /// mute. For example, if you want only the summary of your group to make noise, all
  /// children in the group should have the group alert behavior \#GROUP_ALERT_SUMMARY.
  ///
  ///  The default value is \#GROUP_ALERT_ALL.
  ///
  ///@param groupAlertBehavior Value is android.app.Notification\#GROUP_ALERT_ALL, android.app.Notification\#GROUP_ALERT_CHILDREN, or android.app.Notification\#GROUP_ALERT_SUMMARY
  Notification_Builder setGroupAlertBehavior(int groupAlertBehavior) =>
      Notification_Builder.fromRef(
          _setGroupAlertBehavior(reference, groupAlertBehavior));

  static final _setChannelId = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setChannelId")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setChannelId(java.lang.String channelId)
  /// Specifies the channel the notification should be delivered on.
  Notification_Builder setChannelId(jni.JlString channelId) =>
      Notification_Builder.fromRef(
          _setChannelId(reference, channelId.reference));

  static final _setTimeoutAfter = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "android_app_Notification__Builder_setTimeoutAfter")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setTimeoutAfter(long durationMs)
  /// Specifies a duration in milliseconds after which this notification should be canceled,
  /// if it is not already canceled.
  Notification_Builder setTimeoutAfter(int durationMs) =>
      Notification_Builder.fromRef(_setTimeoutAfter(reference, durationMs));

  static final _setWhen = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_app_Notification__Builder_setWhen")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setWhen(long when)
  /// Add a timestamp pertaining to the notification (usually the time the event occurred).
  ///
  /// For apps targeting android.os.Build.VERSION_CODES\#N and above, this time is not
  /// shown anymore by default and must be opted into by using
  /// android.app.Notification.Builder\#setShowWhen(boolean)
  ///@see Notification\#when
  Notification_Builder setWhen(int when) =>
      Notification_Builder.fromRef(_setWhen(reference, when));

  static final _setShowWhen = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Notification__Builder_setShowWhen")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setShowWhen(boolean show)
  /// Control whether the timestamp set with \#setWhen(long) setWhen is shown
  /// in the content view.
  /// For apps targeting android.os.Build.VERSION_CODES\#N and above, this defaults to
  /// {@code false}. For earlier apps, the default is {@code true}.
  Notification_Builder setShowWhen(bool show_) =>
      Notification_Builder.fromRef(_setShowWhen(reference, show_ ? 1 : 0));

  static final _setUsesChronometer = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Notification__Builder_setUsesChronometer")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setUsesChronometer(boolean b)
  /// Show the Notification\#when field as a stopwatch.
  ///
  /// Instead of presenting <code>when</code> as a timestamp, the notification will show an
  /// automatically updating display of the minutes and seconds since <code>when</code>.
  ///
  /// Useful when showing an elapsed time (like an ongoing phone call).
  ///
  /// The counter can also be set to count down to <code>when</code> when using
  /// \#setChronometerCountDown(boolean).
  ///@see android.widget.Chronometer
  ///@see Notification\#when
  ///@see \#setChronometerCountDown(boolean)
  Notification_Builder setUsesChronometer(bool b) =>
      Notification_Builder.fromRef(_setUsesChronometer(reference, b ? 1 : 0));

  static final _setChronometerCountDown = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Notification__Builder_setChronometerCountDown")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setChronometerCountDown(boolean countDown)
  /// Sets the Chronometer to count down instead of counting up.
  ///
  /// This is only relevant if \#setUsesChronometer(boolean) has been set to true.
  /// If it isn't set the chronometer will count up.
  ///@see \#setUsesChronometer(boolean)
  Notification_Builder setChronometerCountDown(bool countDown) =>
      Notification_Builder.fromRef(
          _setChronometerCountDown(reference, countDown ? 1 : 0));

  static final _setSmallIcon = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Notification__Builder_setSmallIcon")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setSmallIcon(int icon)
  /// Set the small icon resource, which will be used to represent the notification in the
  /// status bar.
  ///
  ///
  /// The platform template for the expanded view will draw this icon in the left, unless a
  /// \#setLargeIcon(Bitmap) large icon has also been specified, in which case the small
  /// icon will be moved to the right-hand side.
  ///@param icon A resource ID in the application's package of the drawable to use.
  ///@see Notification\#icon
  Notification_Builder setSmallIcon(int icon) =>
      Notification_Builder.fromRef(_setSmallIcon(reference, icon));

  static final _setSmallIcon_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_app_Notification__Builder_setSmallIcon_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.app.Notification.Builder setSmallIcon(int icon, int level)
  /// A variant of \#setSmallIcon(int) setSmallIcon(int) that takes an additional
  /// level parameter for when the icon is a android.graphics.drawable.LevelListDrawable LevelListDrawable.
  ///@param icon A resource ID in the application's package of the drawable to use.
  ///@param level The level to use for the icon.
  ///@see Notification\#icon
  ///@see Notification\#iconLevel
  Notification_Builder setSmallIcon_1(int icon, int level) =>
      Notification_Builder.fromRef(_setSmallIcon_1(reference, icon, level));

  static final _setSmallIcon_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setSmallIcon_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setSmallIcon(android.graphics.drawable.Icon icon)
  /// Set the small icon, which will be used to represent the notification in the
  /// status bar and content view (unless overriden there by a
  /// \#setLargeIcon(Bitmap) large icon).
  ///@param icon An Icon object to use.
  ///@see Notification\#icon
  Notification_Builder setSmallIcon_2(jni.JlObject icon) =>
      Notification_Builder.fromRef(_setSmallIcon_2(reference, icon.reference));

  static final _setContentTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setContentTitle")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setContentTitle(java.lang.CharSequence title)
  /// Set the first line of text in the platform notification template.
  Notification_Builder setContentTitle(jni.JlObject title) =>
      Notification_Builder.fromRef(
          _setContentTitle(reference, title.reference));

  static final _setContentText = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setContentText")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setContentText(java.lang.CharSequence text)
  /// Set the second line of text in the platform notification template.
  Notification_Builder setContentText(jni.JlObject text) =>
      Notification_Builder.fromRef(_setContentText(reference, text.reference));

  static final _setSubText = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setSubText")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setSubText(java.lang.CharSequence text)
  /// This provides some additional information that is displayed in the notification. No
  /// guarantees are given where exactly it is displayed.
  ///
  /// This information should only be provided if it provides an essential
  /// benefit to the understanding of the notification. The more text you provide the
  /// less readable it becomes. For example, an email client should only provide the account
  /// name here if more than one email account has been added.
  ///
  ///
  /// As of android.os.Build.VERSION_CODES\#N this information is displayed in the
  /// notification header area.
  ///
  /// On Android versions before android.os.Build.VERSION_CODES\#N
  /// this will be shown in the third line of text in the platform notification template.
  /// You should not be using \#setProgress(int, int, boolean) at the
  /// same time on those versions; they occupy the same place.
  ///
  ///
  Notification_Builder setSubText(jni.JlObject text) =>
      Notification_Builder.fromRef(_setSubText(reference, text.reference));

  static final _setSettingsText = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setSettingsText")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setSettingsText(java.lang.CharSequence text)
  /// Provides text that will appear as a link to your application's settings.
  ///
  /// This text does not appear within notification Style templates but may
  /// appear when the user uses an affordance to learn more about the notification.
  /// Additionally, this text will not appear unless you provide a valid link target by
  /// handling \#INTENT_CATEGORY_NOTIFICATION_PREFERENCES.
  ///
  /// This text is meant to be concise description about what the user can customize
  /// when they click on this link. The recommended maximum length is 40 characters.
  ///@param text
  ///@return
  Notification_Builder setSettingsText(jni.JlObject text) =>
      Notification_Builder.fromRef(_setSettingsText(reference, text.reference));

  static final _setRemoteInputHistory = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setRemoteInputHistory")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setRemoteInputHistory(java.lang.CharSequence[] text)
  /// Set the remote input history.
  ///
  /// This should be set to the most recent inputs that have been sent
  /// through a RemoteInput of this Notification and cleared once the it is no
  /// longer relevant (e.g. for chat notifications once the other party has responded).
  ///
  /// The most recent input must be stored at the 0 index, the second most recent at the
  /// 1 index, etc. Note that the system will limit both how far back the inputs will be shown
  /// and how much of each individual input is shown.
  ///
  /// Note: The reply text will only be shown on notifications that have least one action
  /// with a {@code RemoteInput}.
  ///
  Notification_Builder setRemoteInputHistory(jni.JlObject text) =>
      Notification_Builder.fromRef(
          _setRemoteInputHistory(reference, text.reference));

  static final _setNumber = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Notification__Builder_setNumber")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setNumber(int number)
  /// Sets the number of items this notification represents. May be displayed as a badge count
  /// for Launchers that support badging.
  Notification_Builder setNumber(int number) =>
      Notification_Builder.fromRef(_setNumber(reference, number));

  static final _setContentInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setContentInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setContentInfo(java.lang.CharSequence info)
  /// A small piece of additional information pertaining to this notification.
  ///
  /// The platform template will draw this on the last line of the notification, at the far
  /// right (to the right of a smallIcon if it has been placed there).
  ///@deprecated use \#setSubText(CharSequence) instead to set a text in the header.
  /// For legacy apps targeting a version below android.os.Build.VERSION_CODES\#N this
  /// field will still show up, but the subtext will take precedence.
  Notification_Builder setContentInfo(jni.JlObject info) =>
      Notification_Builder.fromRef(_setContentInfo(reference, info.reference));

  static final _setProgress = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Uint8)>>("android_app_Notification__Builder_setProgress")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public android.app.Notification.Builder setProgress(int max, int progress, boolean indeterminate)
  /// Set the progress this notification represents.
  ///
  /// The platform template will represent this using a ProgressBar.
  Notification_Builder setProgress(int max, int progress, bool indeterminate) =>
      Notification_Builder.fromRef(
          _setProgress(reference, max, progress, indeterminate ? 1 : 0));

  static final _setContent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setContent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setContent(android.widget.RemoteViews views)
  /// Supply a custom RemoteViews to use instead of the platform template.
  ///
  /// Use \#setCustomContentView(RemoteViews) instead.
  Notification_Builder setContent(jni.JlObject views) =>
      Notification_Builder.fromRef(_setContent(reference, views.reference));

  static final _setCustomContentView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setCustomContentView")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setCustomContentView(android.widget.RemoteViews contentView)
  /// Supply custom RemoteViews to use instead of the platform template.
  ///
  /// This will override the layout that would otherwise be constructed by this Builder
  /// object.
  Notification_Builder setCustomContentView(jni.JlObject contentView) =>
      Notification_Builder.fromRef(
          _setCustomContentView(reference, contentView.reference));

  static final _setCustomBigContentView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setCustomBigContentView")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setCustomBigContentView(android.widget.RemoteViews contentView)
  /// Supply custom RemoteViews to use instead of the platform template in the expanded form.
  ///
  /// This will override the expanded layout that would otherwise be constructed by this
  /// Builder object.
  Notification_Builder setCustomBigContentView(jni.JlObject contentView) =>
      Notification_Builder.fromRef(
          _setCustomBigContentView(reference, contentView.reference));

  static final _setCustomHeadsUpContentView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setCustomHeadsUpContentView")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setCustomHeadsUpContentView(android.widget.RemoteViews contentView)
  /// Supply custom RemoteViews to use instead of the platform template in the heads up dialog.
  ///
  /// This will override the heads-up layout that would otherwise be constructed by this
  /// Builder object.
  Notification_Builder setCustomHeadsUpContentView(jni.JlObject contentView) =>
      Notification_Builder.fromRef(
          _setCustomHeadsUpContentView(reference, contentView.reference));

  static final _setContentIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setContentIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setContentIntent(android.app.PendingIntent intent)
  /// Supply a PendingIntent to be sent when the notification is clicked.
  ///
  /// As of android.os.Build.VERSION_CODES\#HONEYCOMB, if this field is unset and you
  /// have specified a custom RemoteViews with \#setContent(RemoteViews), you can use
  /// RemoteViews\#setOnClickPendingIntent RemoteViews.setOnClickPendingIntent(int,PendingIntent)
  /// to assign PendingIntents to individual views in that custom layout (i.e., to create
  /// clickable buttons inside the notification view).
  ///@see Notification\#contentIntent Notification.contentIntent
  Notification_Builder setContentIntent(PendingIntent intent) =>
      Notification_Builder.fromRef(
          _setContentIntent(reference, intent.reference));

  static final _setDeleteIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setDeleteIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setDeleteIntent(android.app.PendingIntent intent)
  /// Supply a PendingIntent to send when the notification is cleared explicitly by the user.
  ///@see Notification\#deleteIntent
  Notification_Builder setDeleteIntent(PendingIntent intent) =>
      Notification_Builder.fromRef(
          _setDeleteIntent(reference, intent.reference));

  static final _setFullScreenIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Notification__Builder_setFullScreenIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setFullScreenIntent(android.app.PendingIntent intent, boolean highPriority)
  /// An intent to launch instead of posting the notification to the status bar.
  /// Only for use with extremely high-priority notifications demanding the user's
  /// <strong>immediate</strong> attention, such as an incoming phone call or
  /// alarm clock that the user has explicitly set to a particular time.
  /// If this facility is used for something else, please give the user an option
  /// to turn it off and use a normal notification, as this can be extremely
  /// disruptive.
  ///
  ///
  /// The system UI may choose to display a heads-up notification, instead of
  /// launching this intent, while the user is using the device.
  ///
  ///
  ///@param intent The pending intent to launch.
  ///@param highPriority Passing true will cause this notification to be sent
  ///          even if other notifications are suppressed.
  ///@see Notification\#fullScreenIntent
  Notification_Builder setFullScreenIntent(
          PendingIntent intent, bool highPriority) =>
      Notification_Builder.fromRef(_setFullScreenIntent(
          reference, intent.reference, highPriority ? 1 : 0));

  static final _setTicker = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setTicker")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setTicker(java.lang.CharSequence tickerText)
  /// Set the "ticker" text which is sent to accessibility services.
  ///@see Notification\#tickerText
  Notification_Builder setTicker(jni.JlObject tickerText) =>
      Notification_Builder.fromRef(_setTicker(reference, tickerText.reference));

  static final _setTicker_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setTicker_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setTicker(java.lang.CharSequence tickerText, android.widget.RemoteViews views)
  /// Obsolete version of \#setTicker(CharSequence).
  Notification_Builder setTicker_1(
          jni.JlObject tickerText, jni.JlObject views) =>
      Notification_Builder.fromRef(
          _setTicker_1(reference, tickerText.reference, views.reference));

  static final _setLargeIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setLargeIcon")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setLargeIcon(android.graphics.Bitmap b)
  /// Add a large icon to the notification content view.
  ///
  /// In the platform template, this image will be shown on the left of the notification view
  /// in place of the \#setSmallIcon(Icon) small icon (which will be placed in a small
  /// badge atop the large icon).
  Notification_Builder setLargeIcon(jni.JlObject b) =>
      Notification_Builder.fromRef(_setLargeIcon(reference, b.reference));

  static final _setLargeIcon_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setLargeIcon_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setLargeIcon(android.graphics.drawable.Icon icon)
  /// Add a large icon to the notification content view.
  ///
  /// In the platform template, this image will be shown on the left of the notification view
  /// in place of the \#setSmallIcon(Icon) small icon (which will be placed in a small
  /// badge atop the large icon).
  Notification_Builder setLargeIcon_1(jni.JlObject icon) =>
      Notification_Builder.fromRef(_setLargeIcon_1(reference, icon.reference));

  static final _setSound = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setSound")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setSound(android.net.Uri sound)
  /// Set the sound to play.
  ///
  /// It will be played using the \#AUDIO_ATTRIBUTES_DEFAULT default audio attributes
  /// for notifications.
  ///@deprecated use NotificationChannel\#setSound(Uri, AudioAttributes) instead.
  Notification_Builder setSound(jni.JlObject sound) =>
      Notification_Builder.fromRef(_setSound(reference, sound.reference));

  static final _setSound_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Notification__Builder_setSound_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setSound(android.net.Uri sound, int streamType)
  /// Set the sound to play, along with a specific stream on which to play it.
  ///
  /// See android.media.AudioManager for the <code>STREAM_</code> constants.
  ///@deprecated use NotificationChannel\#setSound(Uri, AudioAttributes).
  Notification_Builder setSound_1(jni.JlObject sound, int streamType) =>
      Notification_Builder.fromRef(
          _setSound_1(reference, sound.reference, streamType));

  static final _setSound_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setSound_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setSound(android.net.Uri sound, android.media.AudioAttributes audioAttributes)
  /// Set the sound to play, along with specific AudioAttributes audio attributes to
  /// use during playback.
  ///@deprecated use NotificationChannel\#setSound(Uri, AudioAttributes) instead.
  ///@see Notification\#sound
  Notification_Builder setSound_2(
          jni.JlObject sound, jni.JlObject audioAttributes) =>
      Notification_Builder.fromRef(
          _setSound_2(reference, sound.reference, audioAttributes.reference));

  static final _setVibrate = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setVibrate")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setVibrate(long[] pattern)
  /// Set the vibration pattern to use.
  ///
  /// See android.os.Vibrator\#vibrate(long[], int) for a discussion of the
  /// <code>pattern</code> parameter.
  ///
  ///
  /// A notification that vibrates is more likely to be presented as a heads-up notification.
  ///
  ///
  ///@deprecated use NotificationChannel\#setVibrationPattern(long[]) instead.
  ///@see Notification\#vibrate
  Notification_Builder setVibrate(jni.JlObject pattern) =>
      Notification_Builder.fromRef(_setVibrate(reference, pattern.reference));

  static final _setLights = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("android_app_Notification__Builder_setLights")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public android.app.Notification.Builder setLights(int argb, int onMs, int offMs)
  /// Set the desired color for the indicator LED on the device, as well as the
  /// blink duty cycle (specified in milliseconds).
  ///
  ///
  /// Not all devices will honor all (or even any) of these values.
  ///@deprecated use NotificationChannel\#enableLights(boolean) instead.
  ///@see Notification\#ledARGB
  ///@see Notification\#ledOnMS
  ///@see Notification\#ledOffMS
  Notification_Builder setLights(int argb, int onMs, int offMs) =>
      Notification_Builder.fromRef(_setLights(reference, argb, onMs, offMs));

  static final _setOngoing = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Notification__Builder_setOngoing")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setOngoing(boolean ongoing)
  /// Set whether this is an "ongoing" notification.
  ///
  ///
  /// Ongoing notifications cannot be dismissed by the user, so your application or service
  /// must take care of canceling them.
  ///
  ///
  /// They are typically used to indicate a background task that the user is actively engaged
  /// with (e.g., playing music) or is pending in some way and therefore occupying the device
  /// (e.g., a file download, sync operation, active network connection).
  ///@see Notification\#FLAG_ONGOING_EVENT
  ///@see Service\#setForeground(boolean)
  Notification_Builder setOngoing(bool ongoing) =>
      Notification_Builder.fromRef(_setOngoing(reference, ongoing ? 1 : 0));

  static final _setColorized = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Notification__Builder_setColorized")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setColorized(boolean colorize)
  /// Set whether this notification should be colorized. When set, the color set with
  /// \#setColor(int) will be used as the background color of this notification.
  ///
  /// This should only be used for high priority ongoing tasks like navigation, an ongoing
  /// call, or other similarly high-priority events for the user.
  ///
  /// For most styles, the coloring will only be applied if the notification is for a
  /// foreground service notification.
  /// However, for MediaStyle and DecoratedMediaCustomViewStyle notifications
  /// that have a media session attached there is no such requirement.
  ///@see Builder\#setColor(int)
  ///@see MediaStyle\#setMediaSession(MediaSession.Token)
  Notification_Builder setColorized(bool colorize) =>
      Notification_Builder.fromRef(_setColorized(reference, colorize ? 1 : 0));

  static final _setOnlyAlertOnce = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Notification__Builder_setOnlyAlertOnce")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setOnlyAlertOnce(boolean onlyAlertOnce)
  /// Set this flag if you would only like the sound, vibrate
  /// and ticker to be played if the notification is not already showing.
  ///@see Notification\#FLAG_ONLY_ALERT_ONCE
  Notification_Builder setOnlyAlertOnce(bool onlyAlertOnce) =>
      Notification_Builder.fromRef(
          _setOnlyAlertOnce(reference, onlyAlertOnce ? 1 : 0));

  static final _setAutoCancel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Notification__Builder_setAutoCancel")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setAutoCancel(boolean autoCancel)
  /// Make this notification automatically dismissed when the user touches it.
  ///@see Notification\#FLAG_AUTO_CANCEL
  Notification_Builder setAutoCancel(bool autoCancel) =>
      Notification_Builder.fromRef(
          _setAutoCancel(reference, autoCancel ? 1 : 0));

  static final _setLocalOnly = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Notification__Builder_setLocalOnly")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setLocalOnly(boolean localOnly)
  /// Set whether or not this notification should not bridge to other devices.
  ///
  /// Some notifications can be bridged to other devices for remote display.
  /// This hint can be set to recommend this notification not be bridged.
  Notification_Builder setLocalOnly(bool localOnly) =>
      Notification_Builder.fromRef(_setLocalOnly(reference, localOnly ? 1 : 0));

  static final _setDefaults = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Notification__Builder_setDefaults")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setDefaults(int defaults)
  /// Set which notification properties will be inherited from system defaults.
  ///
  /// The value should be one or more of the following fields combined with
  /// bitwise-or:
  /// \#DEFAULT_SOUND, \#DEFAULT_VIBRATE, \#DEFAULT_LIGHTS.
  ///
  /// For all default values, use \#DEFAULT_ALL.
  ///@deprecated use NotificationChannel\#enableVibration(boolean) and
  /// NotificationChannel\#enableLights(boolean) and
  /// NotificationChannel\#setSound(Uri, AudioAttributes) instead.
  Notification_Builder setDefaults(int defaults) =>
      Notification_Builder.fromRef(_setDefaults(reference, defaults));

  static final _setPriority = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Notification__Builder_setPriority")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setPriority(int pri)
  /// Set the priority of this notification.
  ///@see Notification\#priority
  ///@deprecated use NotificationChannel\#setImportance(int) instead.
  ///@param pri Value is android.app.Notification\#PRIORITY_DEFAULT, android.app.Notification\#PRIORITY_LOW, android.app.Notification\#PRIORITY_MIN, android.app.Notification\#PRIORITY_HIGH, or android.app.Notification\#PRIORITY_MAX
  Notification_Builder setPriority(int pri) =>
      Notification_Builder.fromRef(_setPriority(reference, pri));

  static final _setCategory = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setCategory")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setCategory(java.lang.String category)
  /// Set the notification category.
  ///@see Notification\#category
  Notification_Builder setCategory(jni.JlString category) =>
      Notification_Builder.fromRef(_setCategory(reference, category.reference));

  static final _addPerson = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_addPerson")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder addPerson(java.lang.String uri)
  /// Add a person that is relevant to this notification.
  ///
  /// <P>
  /// Depending on user preferences, this annotation may allow the notification to pass
  /// through interruption filters, if this notification is of category \#CATEGORY_CALL
  /// or \#CATEGORY_MESSAGE. The addition of people may also cause this notification to
  /// appear more prominently in the user interface.
  /// </P>
  ///
  /// <P>
  /// The person should be specified by the {@code String} representation of a
  /// android.provider.ContactsContract.Contacts\#CONTENT_LOOKUP_URI.
  /// </P>
  ///
  /// <P>The system will also attempt to resolve {@code mailto:} and {@code tel:} schema
  /// URIs.  The path part of these URIs must exist in the contacts database, in the
  /// appropriate column, or the reference will be discarded as invalid. Telephone schema
  /// URIs will be resolved by android.provider.ContactsContract.PhoneLookup.
  /// It is also possible to provide a URI with the schema {@code name:} in order to uniquely
  /// identify a person without an entry in the contacts database.
  /// </P>
  ///@param uri A URI for the person.
  ///@see Notification\#EXTRA_PEOPLE
  ///@deprecated use \#addPerson(Person)
  Notification_Builder addPerson(jni.JlString uri) =>
      Notification_Builder.fromRef(_addPerson(reference, uri.reference));

  static final _addPerson_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_addPerson_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder addPerson(android.app.Person person)
  /// Add a person that is relevant to this notification.
  ///
  /// <P>
  /// Depending on user preferences, this annotation may allow the notification to pass
  /// through interruption filters, if this notification is of category \#CATEGORY_CALL
  /// or \#CATEGORY_MESSAGE. The addition of people may also cause this notification to
  /// appear more prominently in the user interface.
  /// </P>
  ///
  /// <P>
  /// A person should usually contain a uri in order to benefit from the ranking boost.
  /// However, even if no uri is provided, it's beneficial to provide other people in the
  /// notification, such that listeners and voice only devices can announce and handle them
  /// properly.
  /// </P>
  ///@param person the person to add.
  ///@see Notification\#EXTRA_PEOPLE_LIST
  Notification_Builder addPerson_1(Person person) =>
      Notification_Builder.fromRef(_addPerson_1(reference, person.reference));

  static final _setGroup = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setGroup")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setGroup(java.lang.String groupKey)
  /// Set this notification to be part of a group of notifications sharing the same key.
  /// Grouped notifications may display in a cluster or stack on devices which
  /// support such rendering.
  ///
  /// To make this notification the summary for its group, also call
  /// \#setGroupSummary. A sort order can be specified for group members by using
  /// \#setSortKey.
  ///@param groupKey The group key of the group.
  ///@return this object for method chaining
  Notification_Builder setGroup(jni.JlString groupKey) =>
      Notification_Builder.fromRef(_setGroup(reference, groupKey.reference));

  static final _setGroupSummary = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Notification__Builder_setGroupSummary")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setGroupSummary(boolean isGroupSummary)
  /// Set this notification to be the group summary for a group of notifications.
  /// Grouped notifications may display in a cluster or stack on devices which
  /// support such rendering. If thereRequires a group key also be set using \#setGroup.
  /// The group summary may be suppressed if too few notifications are included in the group.
  ///@param isGroupSummary Whether this notification should be a group summary.
  ///@return this object for method chaining
  Notification_Builder setGroupSummary(bool isGroupSummary) =>
      Notification_Builder.fromRef(
          _setGroupSummary(reference, isGroupSummary ? 1 : 0));

  static final _setSortKey = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setSortKey")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setSortKey(java.lang.String sortKey)
  /// Set a sort key that orders this notification among other notifications from the
  /// same package. This can be useful if an external sort was already applied and an app
  /// would like to preserve this. Notifications will be sorted lexicographically using this
  /// value, although providing different priorities in addition to providing sort key may
  /// cause this value to be ignored.
  ///
  /// This sort key can also be used to order members of a notification group. See
  /// \#setGroup.
  ///@see String\#compareTo(String)
  Notification_Builder setSortKey(jni.JlString sortKey) =>
      Notification_Builder.fromRef(_setSortKey(reference, sortKey.reference));

  static final _addExtras = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_addExtras")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder addExtras(android.os.Bundle extras)
  /// Merge additional metadata into this notification.
  ///
  /// Values within the Bundle will replace existing extras values in this Builder.
  ///@see Notification\#extras
  Notification_Builder addExtras(os.Bundle extras) =>
      Notification_Builder.fromRef(_addExtras(reference, extras.reference));

  static final _setExtras = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setExtras")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setExtras(android.os.Bundle extras)
  /// Set metadata for this notification.
  ///
  /// A reference to the Bundle is held for the lifetime of this Builder, and the Bundle's
  /// current contents are copied into the Notification each time \#build() is
  /// called.
  ///
  /// Replaces any existing extras values with those from the provided Bundle.
  /// Use \#addExtras to merge in metadata instead.
  ///@see Notification\#extras
  Notification_Builder setExtras(os.Bundle extras) =>
      Notification_Builder.fromRef(_setExtras(reference, extras.reference));

  static final _getExtras = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_getExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getExtras()
  /// Get the current metadata Bundle used by this notification Builder.
  ///
  /// The returned Bundle is shared with this Builder.
  ///
  /// The current contents of this Bundle are copied into the Notification each time
  /// \#build() is called.
  ///@see Notification\#extras
  os.Bundle getExtras() => os.Bundle.fromRef(_getExtras(reference));

  static final _addAction = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_addAction")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder addAction(int icon, java.lang.CharSequence title, android.app.PendingIntent intent)
  /// Add an action to this notification. Actions are typically displayed by
  /// the system as a button adjacent to the notification content.
  ///
  /// Every action must have an icon (32dp square and matching the
  /// <a href="{@docRoot}design/style/iconography.html\#action-bar">Holo
  /// Dark action bar</a> visual style), a textual label, and a PendingIntent.
  ///
  /// A notification in its expanded form can display up to 3 actions, from left to right in
  /// the order they were added. Actions will not be displayed when the notification is
  /// collapsed, however, so be sure that any essential functions may be accessed by the user
  /// in some other way (for example, in the Activity pointed to by \#contentIntent).
  ///@param icon Resource ID of a drawable that represents the action.
  ///@param title Text describing the action.
  ///@param intent PendingIntent to be fired when the action is invoked.
  ///@deprecated Use \#addAction(Action) instead.
  Notification_Builder addAction(
          int icon, jni.JlObject title, PendingIntent intent) =>
      Notification_Builder.fromRef(
          _addAction(reference, icon, title.reference, intent.reference));

  static final _addAction_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_addAction_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder addAction(android.app.Notification.Action action)
  /// Add an action to this notification. Actions are typically displayed by
  /// the system as a button adjacent to the notification content.
  ///
  /// Every action must have an icon (32dp square and matching the
  /// <a href="{@docRoot}design/style/iconography.html\#action-bar">Holo
  /// Dark action bar</a> visual style), a textual label, and a PendingIntent.
  ///
  /// A notification in its expanded form can display up to 3 actions, from left to right in
  /// the order they were added. Actions will not be displayed when the notification is
  /// collapsed, however, so be sure that any essential functions may be accessed by the user
  /// in some other way (for example, in the Activity pointed to by \#contentIntent).
  ///@param action The action to add.
  Notification_Builder addAction_1(Notification_Action action) =>
      Notification_Builder.fromRef(_addAction_1(reference, action.reference));

  static final _setActions = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setActions")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setActions(android.app.Notification.Action[] actions)
  /// Alter the complete list of actions attached to this notification.
  ///@see \#addAction(Action).
  ///@param actions
  ///@return
  Notification_Builder setActions(jni.JlObject actions) =>
      Notification_Builder.fromRef(_setActions(reference, actions.reference));

  static final _setStyle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setStyle")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setStyle(android.app.Notification.Style style)
  /// Add a rich notification style to be applied at build time.
  ///@param style Object responsible for modifying the notification style.
  Notification_Builder setStyle(Notification_Style style) =>
      Notification_Builder.fromRef(_setStyle(reference, style.reference));

  static final _getStyle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_getStyle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Style getStyle()
  /// Returns the style set by \#setStyle(Style).
  Notification_Style getStyle() =>
      Notification_Style.fromRef(_getStyle(reference));

  static final _setVisibility = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_Notification__Builder_setVisibility")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setVisibility(int visibility)
  /// Specify the value of \#visibility.
  ///@param visibility Value is android.app.Notification\#VISIBILITY_PUBLIC, android.app.Notification\#VISIBILITY_PRIVATE, or android.app.Notification\#VISIBILITY_SECRET
  ///@return The same Builder.
  Notification_Builder setVisibility(int visibility) =>
      Notification_Builder.fromRef(_setVisibility(reference, visibility));

  static final _setPublicVersion = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_setPublicVersion")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setPublicVersion(android.app.Notification n)
  /// Supply a replacement Notification whose contents should be shown in insecure contexts
  /// (i.e. atop the secure lockscreen). See \#visibility and \#VISIBILITY_PUBLIC.
  ///@param n A replacement notification, presumably with some or all info redacted.
  ///@return The same Builder.
  Notification_Builder setPublicVersion(Notification n) =>
      Notification_Builder.fromRef(_setPublicVersion(reference, n.reference));

  static final _extend = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_extend")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder extend(android.app.Notification.Extender extender)
  /// Apply an extender to this notification builder. Extenders may be used to add
  /// metadata or change options on this builder.
  Notification_Builder extend(Notification_Extender extender) =>
      Notification_Builder.fromRef(_extend(reference, extender.reference));

  static final _setColor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Notification__Builder_setColor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setColor(int argb)
  /// Sets Notification\#color.
  ///@param argb The accent color to use
  ///@return The same Builder.
  Notification_Builder setColor(int argb) =>
      Notification_Builder.fromRef(_setColor(reference, argb));

  static final _createContentView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_createContentView")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.RemoteViews createContentView()
  /// Construct a RemoteViews for the final 1U notification layout. In order:
  ///   1. Custom contentView from the caller
  ///   2. Style's proposed content view
  ///   3. Standard template view
  jni.JlObject createContentView() =>
      jni.JlObject.fromRef(_createContentView(reference));

  static final _createBigContentView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_createBigContentView")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.RemoteViews createBigContentView()
  /// Construct a RemoteViews for the final big notification layout.
  jni.JlObject createBigContentView() =>
      jni.JlObject.fromRef(_createBigContentView(reference));

  static final _createHeadsUpContentView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_createHeadsUpContentView")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.RemoteViews createHeadsUpContentView()
  /// Construct a RemoteViews for the final heads-up notification layout.
  jni.JlObject createHeadsUpContentView() =>
      jni.JlObject.fromRef(_createHeadsUpContentView(reference));

  static final _recoverBuilder = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_recoverBuilder")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.Notification.Builder recoverBuilder(android.content.Context context, android.app.Notification n)
  /// Creates a Builder from an existing notification so further changes can be made.
  ///@param context The context for your application / activity.
  ///@param n The notification to create a Builder from.
  static Notification_Builder recoverBuilder(
          content.Context context, Notification n) =>
      Notification_Builder.fromRef(
          _recoverBuilder(context.reference, n.reference));

  static final _getNotification = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_getNotification")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification getNotification()
  /// @deprecated Use \#build() instead.
  Notification getNotification() =>
      Notification.fromRef(_getNotification(reference));

  static final _build = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Builder_build")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification build()
  /// Combine all of the options that have been set and return a new Notification
  /// object.
  Notification build() => Notification.fromRef(_build(reference));
}

/// Helper class for generating large-format notifications that include a lot of text.
///
/// Here's how you'd set the <code>BigTextStyle</code> on a notification:
/// <pre class="prettyprint">
/// Notification notif = new Notification.Builder(mContext)
///     .setContentTitle(&quot;New mail from &quot; + sender.toString())
///     .setContentText(subject)
///     .setSmallIcon(R.drawable.new_mail)
///     .setLargeIcon(aBitmap)
///     .setStyle(new Notification.BigTextStyle()
///         .bigText(aVeryLongString))
///     .build();
/// </pre>
///@see Notification\#bigContentView
class Notification_BigTextStyle extends Notification_Style {
  Notification_BigTextStyle.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Notification__BigTextStyle_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Notification_BigTextStyle() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__BigTextStyle_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Notification.Builder builder)
  /// @deprecated use {@code BigTextStyle()}.
  Notification_BigTextStyle.ctor_1(Notification_Builder builder)
      : super.fromRef(_ctor_1(builder.reference));

  static final _setBigContentTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__BigTextStyle_setBigContentTitle")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.BigTextStyle setBigContentTitle(java.lang.CharSequence title)
  /// Overrides ContentTitle in the big form of the template.
  /// This defaults to the value passed to setContentTitle().
  Notification_BigTextStyle setBigContentTitle(jni.JlObject title) =>
      Notification_BigTextStyle.fromRef(
          _setBigContentTitle(reference, title.reference));

  static final _setSummaryText = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__BigTextStyle_setSummaryText")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.BigTextStyle setSummaryText(java.lang.CharSequence cs)
  /// Set the first line of text after the detail section in the big form of the template.
  Notification_BigTextStyle setSummaryText(jni.JlObject cs) =>
      Notification_BigTextStyle.fromRef(
          _setSummaryText(reference, cs.reference));

  static final _bigText = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__BigTextStyle_bigText")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.BigTextStyle bigText(java.lang.CharSequence cs)
  /// Provide the longer text to be displayed in the big form of the
  /// template in place of the content text.
  Notification_BigTextStyle bigText(jni.JlObject cs) =>
      Notification_BigTextStyle.fromRef(_bigText(reference, cs.reference));
}

/// Helper class for generating large-format notifications that include a large image attachment.
///
/// Here's how you'd set the <code>BigPictureStyle</code> on a notification:
/// <pre class="prettyprint">
/// Notification notif = new Notification.Builder(mContext)
///     .setContentTitle(&quot;New photo from &quot; + sender.toString())
///     .setContentText(subject)
///     .setSmallIcon(R.drawable.new_post)
///     .setLargeIcon(aBitmap)
///     .setStyle(new Notification.BigPictureStyle()
///         .bigPicture(aBigBitmap))
///     .build();
/// </pre>
///@see Notification\#bigContentView
class Notification_BigPictureStyle extends Notification_Style {
  Notification_BigPictureStyle.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Notification__BigPictureStyle_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Notification_BigPictureStyle() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__BigPictureStyle_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Notification.Builder builder)
  /// @deprecated use {@code BigPictureStyle()}.
  Notification_BigPictureStyle.ctor_1(Notification_Builder builder)
      : super.fromRef(_ctor_1(builder.reference));

  static final _setBigContentTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__BigPictureStyle_setBigContentTitle")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.BigPictureStyle setBigContentTitle(java.lang.CharSequence title)
  /// Overrides ContentTitle in the big form of the template.
  /// This defaults to the value passed to setContentTitle().
  Notification_BigPictureStyle setBigContentTitle(jni.JlObject title) =>
      Notification_BigPictureStyle.fromRef(
          _setBigContentTitle(reference, title.reference));

  static final _setSummaryText = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__BigPictureStyle_setSummaryText")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.BigPictureStyle setSummaryText(java.lang.CharSequence cs)
  /// Set the first line of text after the detail section in the big form of the template.
  Notification_BigPictureStyle setSummaryText(jni.JlObject cs) =>
      Notification_BigPictureStyle.fromRef(
          _setSummaryText(reference, cs.reference));

  static final _bigPicture = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__BigPictureStyle_bigPicture")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.BigPictureStyle bigPicture(android.graphics.Bitmap b)
  /// Provide the bitmap to be used as the payload for the BigPicture notification.
  Notification_BigPictureStyle bigPicture(jni.JlObject b) =>
      Notification_BigPictureStyle.fromRef(_bigPicture(reference, b.reference));

  static final _bigLargeIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__BigPictureStyle_bigLargeIcon")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.BigPictureStyle bigLargeIcon(android.graphics.Bitmap b)
  /// Override the large icon when the big notification is shown.
  Notification_BigPictureStyle bigLargeIcon(jni.JlObject b) =>
      Notification_BigPictureStyle.fromRef(
          _bigLargeIcon(reference, b.reference));

  static final _bigLargeIcon_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__BigPictureStyle_bigLargeIcon_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.BigPictureStyle bigLargeIcon(android.graphics.drawable.Icon icon)
  /// Override the large icon when the big notification is shown.
  Notification_BigPictureStyle bigLargeIcon_1(jni.JlObject icon) =>
      Notification_BigPictureStyle.fromRef(
          _bigLargeIcon_1(reference, icon.reference));
}

/// Structure to encapsulate a named action that can be shown as part of this notification.
/// It must include an icon, a label, and a PendingIntent to be fired when the action is
/// selected by the user.
///
/// Apps should use Notification.Builder\#addAction(int, CharSequence, PendingIntent)
/// or Notification.Builder\#addAction(Notification.Action)
/// to attach actions.
class Notification_Action extends jni.JlObject {
  Notification_Action.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.Notification.Action> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_Notification__Action_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int SEMANTIC_ACTION_ARCHIVE
  /// {@code SemanticAction}: Archive the content associated with the notification. This
  /// could mean archiving an email, message, etc.
  static const SEMANTIC_ACTION_ARCHIVE = 5;

  /// from: static public final int SEMANTIC_ACTION_CALL
  /// {@code SemanticAction}: Call a contact, group, etc.
  static const SEMANTIC_ACTION_CALL = 10;

  /// from: static public final int SEMANTIC_ACTION_DELETE
  /// {@code SemanticAction}: Delete the content associated with the notification. This
  /// could mean deleting an email, message, etc.
  static const SEMANTIC_ACTION_DELETE = 4;

  /// from: static public final int SEMANTIC_ACTION_MARK_AS_READ
  /// {@code SemanticAction}: Mark content as read.
  static const SEMANTIC_ACTION_MARK_AS_READ = 2;

  /// from: static public final int SEMANTIC_ACTION_MARK_AS_UNREAD
  /// {@code SemanticAction}: Mark content as unread.
  static const SEMANTIC_ACTION_MARK_AS_UNREAD = 3;

  /// from: static public final int SEMANTIC_ACTION_MUTE
  /// {@code SemanticAction}: Mute the content associated with the notification. This could
  /// mean silencing a conversation or currently playing media.
  static const SEMANTIC_ACTION_MUTE = 6;

  /// from: static public final int SEMANTIC_ACTION_NONE
  /// /*missing*/: No semantic action defined.
  static const SEMANTIC_ACTION_NONE = 0;

  /// from: static public final int SEMANTIC_ACTION_REPLY
  /// {@code SemanticAction}: Reply to a conversation, chat, group, or wherever replies
  /// may be appropriate.
  static const SEMANTIC_ACTION_REPLY = 1;

  /// from: static public final int SEMANTIC_ACTION_THUMBS_DOWN
  /// {@code SemanticAction}: Mark content with a thumbs down.
  static const SEMANTIC_ACTION_THUMBS_DOWN = 9;

  /// from: static public final int SEMANTIC_ACTION_THUMBS_UP
  /// {@code SemanticAction}: Mark content with a thumbs up.
  static const SEMANTIC_ACTION_THUMBS_UP = 8;

  /// from: static public final int SEMANTIC_ACTION_UNMUTE
  /// {@code SemanticAction}: Unmute the content associated with the notification. This could
  /// mean un-silencing a conversation or currently playing media.
  static const SEMANTIC_ACTION_UNMUTE = 7;

  /// from: public android.app.PendingIntent actionIntent
  /// Intent to send when the user invokes this action. May be null, in which case the action
  /// may be rendered in a disabled presentation by the system UI.
  static final _getactionIntent = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification__Action_actionIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  PendingIntent get actionIntent =>
      PendingIntent.fromRef(_getactionIntent(reference));
  static final _setactionIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_Notification__Action_actionIntent")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set actionIntent(PendingIntent value) =>
      _setactionIntent(reference, value.reference);

  /// from: public int icon
  /// Small icon representing the action.
  ///@deprecated Use Action\#getIcon() instead.
  static final _geticon = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification__Action_icon")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get icon => _geticon(reference);
  static final _seticon = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_app_Notification__Action_icon")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set icon(int value) => _seticon(reference, value);

  /// from: public java.lang.CharSequence title
  /// Title of the action.
  static final _gettitle = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_Notification__Action_title")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get title => jni.JlObject.fromRef(_gettitle(reference));
  static final _settitle = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_Notification__Action_title")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set title(jni.JlObject value) => _settitle(reference, value.reference);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int icon, java.lang.CharSequence title, android.app.PendingIntent intent)
  /// @deprecated Use android.app.Notification.Action.Builder.
  Notification_Action(int icon, jni.JlObject title, PendingIntent intent)
      : super.fromRef(_ctor(icon, title.reference, intent.reference));

  static final _getIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action_getIcon")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Icon getIcon()
  /// Return an icon representing the action.
  jni.JlObject getIcon() => jni.JlObject.fromRef(_getIcon(reference));

  static final _getExtras = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action_getExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getExtras()
  /// Get additional metadata carried around with this Action.
  os.Bundle getExtras() => os.Bundle.fromRef(_getExtras(reference));

  static final _getAllowGeneratedReplies =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Notification__Action_getAllowGeneratedReplies")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getAllowGeneratedReplies()
  /// Return whether the platform should automatically generate possible replies for this
  /// Action
  bool getAllowGeneratedReplies() => _getAllowGeneratedReplies(reference) != 0;

  static final _getRemoteInputs = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action_getRemoteInputs")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.RemoteInput[] getRemoteInputs()
  /// Get the list of inputs to be collected from the user when this action is sent.
  /// May return null if no remote inputs were added. Only returns inputs which accept
  /// a text input. For inputs which only accept data use \#getDataOnlyRemoteInputs.
  jni.JlObject getRemoteInputs() =>
      jni.JlObject.fromRef(_getRemoteInputs(reference));

  static final _getSemanticAction =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Notification__Action_getSemanticAction")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getSemanticAction()
  /// Returns the {@code SemanticAction} associated with this Action. A
  /// {@code SemanticAction} denotes what an Action's PendingIntent will do
  /// (eg. reply, mark as read, delete, etc).
  ///@return Value is android.app.Notification.Action\#SEMANTIC_ACTION_NONE, android.app.Notification.Action\#SEMANTIC_ACTION_REPLY, android.app.Notification.Action\#SEMANTIC_ACTION_MARK_AS_READ, android.app.Notification.Action\#SEMANTIC_ACTION_MARK_AS_UNREAD, android.app.Notification.Action\#SEMANTIC_ACTION_DELETE, android.app.Notification.Action\#SEMANTIC_ACTION_ARCHIVE, android.app.Notification.Action\#SEMANTIC_ACTION_MUTE, android.app.Notification.Action\#SEMANTIC_ACTION_UNMUTE, android.app.Notification.Action\#SEMANTIC_ACTION_THUMBS_UP, android.app.Notification.Action\#SEMANTIC_ACTION_THUMBS_DOWN, or android.app.Notification.Action\#SEMANTIC_ACTION_CALL
  int getSemanticAction() => _getSemanticAction(reference);

  static final _getDataOnlyRemoteInputs = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action_getDataOnlyRemoteInputs")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.RemoteInput[] getDataOnlyRemoteInputs()
  /// Get the list of inputs to be collected from the user that ONLY accept data when this
  /// action is sent. These remote inputs are guaranteed to return true on a call to
  /// RemoteInput\#isDataOnly.
  ///
  /// Returns null if there are no data-only remote inputs.
  ///
  /// This method exists so that legacy RemoteInput collectors that pre-date the addition
  /// of non-textual RemoteInputs do not access these remote inputs.
  jni.JlObject getDataOnlyRemoteInputs() =>
      jni.JlObject.fromRef(_getDataOnlyRemoteInputs(reference));

  static final _clone = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action_clone")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action clone()
  Notification_Action clone() => Notification_Action.fromRef(_clone(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Notification__Action_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Notification__Action_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os.Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags);
}

/// Wearable extender for notification actions. To add extensions to an action,
/// create a new android.app.Notification.Action.WearableExtender object using
/// the {@code WearableExtender()} constructor and apply it to a
/// android.app.Notification.Action.Builder using
/// android.app.Notification.Action.Builder\#extend.
///
/// <pre class="prettyprint">
/// Notification.Action action = new Notification.Action.Builder(
///         R.drawable.archive_all, "Archive all", actionIntent)
///         .extend(new Notification.Action.WearableExtender()
///                 .setAvailableOffline(false))
///         .build();</pre>
class Notification_Action_WearableExtender extends jni.JlObject {
  Notification_Action_WearableExtender.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Notification__Action__WearableExtender_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Create a android.app.Notification.Action.WearableExtender with default
  /// options.
  Notification_Action_WearableExtender() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__WearableExtender_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Notification.Action action)
  /// Create a android.app.Notification.Action.WearableExtender by reading
  /// wearable options present in an existing notification action.
  ///@param action the notification action to inspect.
  Notification_Action_WearableExtender.ctor_1(Notification_Action action)
      : super.fromRef(_ctor_1(action.reference));

  static final _extend = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__WearableExtender_extend")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action.Builder extend(android.app.Notification.Action.Builder builder)
  /// Apply wearable extensions to a notification action that is being built. This is
  /// typically called by the android.app.Notification.Action.Builder\#extend
  /// method of android.app.Notification.Action.Builder.
  Notification_Action_Builder extend(Notification_Action_Builder builder) =>
      Notification_Action_Builder.fromRef(
          _extend(reference, builder.reference));

  static final _clone = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__WearableExtender_clone")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action.WearableExtender clone()
  Notification_Action_WearableExtender clone() =>
      Notification_Action_WearableExtender.fromRef(_clone(reference));

  static final _setAvailableOffline = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Notification__Action__WearableExtender_setAvailableOffline")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Action.WearableExtender setAvailableOffline(boolean availableOffline)
  /// Set whether this action is available when the wearable device is not connected to
  /// a companion device. The user can still trigger this action when the wearable device is
  /// offline, but a visual hint will indicate that the action may not be available.
  /// Defaults to true.
  Notification_Action_WearableExtender setAvailableOffline(
          bool availableOffline) =>
      Notification_Action_WearableExtender.fromRef(
          _setAvailableOffline(reference, availableOffline ? 1 : 0));

  static final _isAvailableOffline = jlookup<
              ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__WearableExtender_isAvailableOffline")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isAvailableOffline()
  /// Get whether this action is available when the wearable device is not connected to
  /// a companion device. The user can still trigger this action when the wearable device is
  /// offline, but a visual hint will indicate that the action may not be available.
  /// Defaults to true.
  bool isAvailableOffline() => _isAvailableOffline(reference) != 0;

  static final _setInProgressLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__WearableExtender_setInProgressLabel")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action.WearableExtender setInProgressLabel(java.lang.CharSequence label)
  /// Set a label to display while the wearable is preparing to automatically execute the
  /// action. This is usually a 'ing' verb ending in ellipsis like "Sending..."
  ///@param label the label to display while the action is being prepared to execute
  ///@return this object for method chaining
  Notification_Action_WearableExtender setInProgressLabel(jni.JlObject label) =>
      Notification_Action_WearableExtender.fromRef(
          _setInProgressLabel(reference, label.reference));

  static final _getInProgressLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__WearableExtender_getInProgressLabel")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getInProgressLabel()
  /// Get the label to display while the wearable is preparing to automatically execute
  /// the action. This is usually a 'ing' verb ending in ellipsis like "Sending..."
  ///@return the label to display while the action is being prepared to execute
  jni.JlObject getInProgressLabel() =>
      jni.JlObject.fromRef(_getInProgressLabel(reference));

  static final _setConfirmLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__WearableExtender_setConfirmLabel")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action.WearableExtender setConfirmLabel(java.lang.CharSequence label)
  /// Set a label to display to confirm that the action should be executed.
  /// This is usually an imperative verb like "Send".
  ///@param label the label to confirm the action should be executed
  ///@return this object for method chaining
  Notification_Action_WearableExtender setConfirmLabel(jni.JlObject label) =>
      Notification_Action_WearableExtender.fromRef(
          _setConfirmLabel(reference, label.reference));

  static final _getConfirmLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__WearableExtender_getConfirmLabel")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getConfirmLabel()
  /// Get the label to display to confirm that the action should be executed.
  /// This is usually an imperative verb like "Send".
  ///@return the label to confirm the action should be executed
  jni.JlObject getConfirmLabel() =>
      jni.JlObject.fromRef(_getConfirmLabel(reference));

  static final _setCancelLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__WearableExtender_setCancelLabel")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action.WearableExtender setCancelLabel(java.lang.CharSequence label)
  /// Set a label to display to cancel the action.
  /// This is usually an imperative verb, like "Cancel".
  ///@param label the label to display to cancel the action
  ///@return this object for method chaining
  Notification_Action_WearableExtender setCancelLabel(jni.JlObject label) =>
      Notification_Action_WearableExtender.fromRef(
          _setCancelLabel(reference, label.reference));

  static final _getCancelLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__WearableExtender_getCancelLabel")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getCancelLabel()
  /// Get the label to display to cancel the action.
  /// This is usually an imperative verb like "Cancel".
  ///@return the label to display to cancel the action
  jni.JlObject getCancelLabel() =>
      jni.JlObject.fromRef(_getCancelLabel(reference));

  static final _setHintLaunchesActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Notification__Action__WearableExtender_setHintLaunchesActivity")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Action.WearableExtender setHintLaunchesActivity(boolean hintLaunchesActivity)
  /// Set a hint that this Action will launch an Activity directly, telling the
  /// platform that it can generate the appropriate transitions.
  ///@param hintLaunchesActivity {@code true} if the content intent will launch
  /// an activity and transitions should be generated, false otherwise.
  ///@return this object for method chaining
  Notification_Action_WearableExtender setHintLaunchesActivity(
          bool hintLaunchesActivity) =>
      Notification_Action_WearableExtender.fromRef(
          _setHintLaunchesActivity(reference, hintLaunchesActivity ? 1 : 0));

  static final _getHintLaunchesActivity = jlookup<
              ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__WearableExtender_getHintLaunchesActivity")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getHintLaunchesActivity()
  /// Get a hint that this Action will launch an Activity directly, telling the
  /// platform that it can generate the appropriate transitions
  ///@return {@code true} if the content intent will launch an activity and transitions
  /// should be generated, false otherwise. The default value is {@code false} if this was
  /// never set.
  bool getHintLaunchesActivity() => _getHintLaunchesActivity(reference) != 0;

  static final _setHintDisplayActionInline = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Notification__Action__WearableExtender_setHintDisplayActionInline")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Action.WearableExtender setHintDisplayActionInline(boolean hintDisplayInline)
  /// Set a hint that this Action should be displayed inline.
  ///@param hintDisplayInline {@code true} if action should be displayed inline, false
  ///        otherwise
  ///@return this object for method chaining
  Notification_Action_WearableExtender setHintDisplayActionInline(
          bool hintDisplayInline) =>
      Notification_Action_WearableExtender.fromRef(
          _setHintDisplayActionInline(reference, hintDisplayInline ? 1 : 0));

  static final _getHintDisplayActionInline = jlookup<
              ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__WearableExtender_getHintDisplayActionInline")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getHintDisplayActionInline()
  /// Get a hint that this Action should be displayed inline.
  ///@return {@code true} if the Action should be displayed inline, {@code false}
  ///         otherwise. The default value is {@code false} if this was never set.
  bool getHintDisplayActionInline() =>
      _getHintDisplayActionInline(reference) != 0;
}

/// Extender interface for use with Builder\#extend. Extenders may be used to add
/// metadata or change options on an action builder.
class Notification_Action_Extender extends jni.JlObject {
  Notification_Action_Extender.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _extend = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__Extender_extend")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.Notification.Action.Builder extend(android.app.Notification.Action.Builder builder)
  /// Apply this extender to a notification action builder.
  ///@param builder the builder to be modified.
  ///@return the build object for chaining.
  Notification_Action_Builder extend(Notification_Action_Builder builder) =>
      Notification_Action_Builder.fromRef(
          _extend(reference, builder.reference));
}

/// Builder class for Action objects.
class Notification_Action_Builder extends jni.JlObject {
  Notification_Action_Builder.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__Builder_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int icon, java.lang.CharSequence title, android.app.PendingIntent intent)
  /// Construct a new builder for Action object.
  ///@param icon icon to show for this action
  ///@param title the title of the action
  ///@param intent the PendingIntent to fire when users trigger this action
  Notification_Action_Builder(
      int icon, jni.JlObject title, PendingIntent intent)
      : super.fromRef(_ctor(icon, title.reference, intent.reference));

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__Builder_new_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.graphics.drawable.Icon icon, java.lang.CharSequence title, android.app.PendingIntent intent)
  /// Construct a new builder for Action object.
  ///@param icon icon to show for this action
  ///@param title the title of the action
  ///@param intent the PendingIntent to fire when users trigger this action
  Notification_Action_Builder.ctor_1(
      jni.JlObject icon, jni.JlObject title, PendingIntent intent)
      : super.fromRef(
            _ctor_1(icon.reference, title.reference, intent.reference));

  static final _ctor_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__Builder_new_2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Notification.Action action)
  /// Construct a new builder for Action object using the fields from an
  /// Action.
  ///@param action the action to read fields from.
  Notification_Action_Builder.ctor_2(Notification_Action action)
      : super.fromRef(_ctor_2(action.reference));

  static final _addExtras = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__Builder_addExtras")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action.Builder addExtras(android.os.Bundle extras)
  /// Merge additional metadata into this builder.
  ///
  /// Values within the Bundle will replace existing extras values in this Builder.
  ///@see Notification.Action\#extras
  Notification_Action_Builder addExtras(os.Bundle extras) =>
      Notification_Action_Builder.fromRef(
          _addExtras(reference, extras.reference));

  static final _getExtras = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__Builder_getExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getExtras()
  /// Get the metadata Bundle used by this Builder.
  ///
  /// The returned Bundle is shared with this Builder.
  os.Bundle getExtras() => os.Bundle.fromRef(_getExtras(reference));

  static final _addRemoteInput = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__Builder_addRemoteInput")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action.Builder addRemoteInput(android.app.RemoteInput remoteInput)
  /// Add an input to be collected from the user when this action is sent.
  /// Response values can be retrieved from the fired intent by using the
  /// RemoteInput\#getResultsFromIntent function.
  ///@param remoteInput a RemoteInput to add to the action
  ///@return this object for method chaining
  Notification_Action_Builder addRemoteInput(RemoteInput remoteInput) =>
      Notification_Action_Builder.fromRef(
          _addRemoteInput(reference, remoteInput.reference));

  static final _setAllowGeneratedReplies = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Notification__Action__Builder_setAllowGeneratedReplies")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Action.Builder setAllowGeneratedReplies(boolean allowGeneratedReplies)
  /// Set whether the platform should automatically generate possible replies to add to
  /// RemoteInput\#getChoices(). If the Action doesn't have a
  /// RemoteInput, this has no effect.
  ///@param allowGeneratedReplies {@code true} to allow generated replies, {@code false}
  /// otherwise
  ///@return this object for method chaining
  /// The default value is {@code true}
  Notification_Action_Builder setAllowGeneratedReplies(
          bool allowGeneratedReplies) =>
      Notification_Action_Builder.fromRef(
          _setAllowGeneratedReplies(reference, allowGeneratedReplies ? 1 : 0));

  static final _setSemanticAction = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_Notification__Action__Builder_setSemanticAction")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Action.Builder setSemanticAction(int semanticAction)
  /// Sets the {@code SemanticAction} for this Action. A
  /// {@code SemanticAction} denotes what an Action's
  /// PendingIntent will do (eg. reply, mark as read, delete, etc).
  ///@param semanticAction a SemanticAction defined within Action with
  /// {@code SEMANTIC_ACTION_} prefixes
  /// Value is android.app.Notification.Action\#SEMANTIC_ACTION_NONE, android.app.Notification.Action\#SEMANTIC_ACTION_REPLY, android.app.Notification.Action\#SEMANTIC_ACTION_MARK_AS_READ, android.app.Notification.Action\#SEMANTIC_ACTION_MARK_AS_UNREAD, android.app.Notification.Action\#SEMANTIC_ACTION_DELETE, android.app.Notification.Action\#SEMANTIC_ACTION_ARCHIVE, android.app.Notification.Action\#SEMANTIC_ACTION_MUTE, android.app.Notification.Action\#SEMANTIC_ACTION_UNMUTE, android.app.Notification.Action\#SEMANTIC_ACTION_THUMBS_UP, android.app.Notification.Action\#SEMANTIC_ACTION_THUMBS_DOWN, or android.app.Notification.Action\#SEMANTIC_ACTION_CALL
  ///@return this object for method chaining
  Notification_Action_Builder setSemanticAction(int semanticAction) =>
      Notification_Action_Builder.fromRef(
          _setSemanticAction(reference, semanticAction));

  static final _extend = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__Builder_extend")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action.Builder extend(android.app.Notification.Action.Extender extender)
  /// Apply an extender to this action builder. Extenders may be used to add
  /// metadata or change options on this builder.
  Notification_Action_Builder extend(Notification_Action_Extender extender) =>
      Notification_Action_Builder.fromRef(
          _extend(reference, extender.reference));

  static final _build = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Notification__Action__Builder_build")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action build()
  /// Combine all of the options that have been set and return a new Action
  /// object.
  ///@return the built action
  Notification_Action build() => Notification_Action.fromRef(_build(reference));
}

/// Represents a set of parameters used to initialize and update an Activity in picture-in-picture
/// mode.
class PictureInPictureParams extends jni.JlObject {
  PictureInPictureParams.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.PictureInPictureParams> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_PictureInPictureParams_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_PictureInPictureParams_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  /// {@hide }
  PictureInPictureParams() : super.fromRef(_ctor());

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_PictureInPictureParams_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_PictureInPictureParams_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os.Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags);
}

/// Builder class for PictureInPictureParams objects.
class PictureInPictureParams_Builder extends jni.JlObject {
  PictureInPictureParams_Builder.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_PictureInPictureParams__Builder_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  PictureInPictureParams_Builder() : super.fromRef(_ctor());

  static final _setAspectRatio = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_PictureInPictureParams__Builder_setAspectRatio")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PictureInPictureParams.Builder setAspectRatio(android.util.Rational aspectRatio)
  /// Sets the aspect ratio.  This aspect ratio is defined as the desired width / height, and
  /// does not change upon device rotation.
  ///@param aspectRatio the new aspect ratio for the activity in picture-in-picture, must be
  /// between 2.39:1 and 1:2.39 (inclusive).
  ///@return this builder instance.
  PictureInPictureParams_Builder setAspectRatio(jni.JlObject aspectRatio) =>
      PictureInPictureParams_Builder.fromRef(
          _setAspectRatio(reference, aspectRatio.reference));

  static final _setActions = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_PictureInPictureParams__Builder_setActions")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PictureInPictureParams.Builder setActions(java.util.List<android.app.RemoteAction> actions)
  /// Sets the user actions.  If there are more than
  /// Activity\#getMaxNumPictureInPictureActions() actions, then the input list
  /// will be truncated to that number.
  ///@param actions the new actions to show in the picture-in-picture menu.
  ///@return this builder instance.
  ///@see RemoteAction
  PictureInPictureParams_Builder setActions(jni.JlObject actions) =>
      PictureInPictureParams_Builder.fromRef(
          _setActions(reference, actions.reference));

  static final _setSourceRectHint = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_PictureInPictureParams__Builder_setSourceRectHint")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PictureInPictureParams.Builder setSourceRectHint(android.graphics.Rect launchBounds)
  /// Sets the source bounds hint. These bounds are only used when an activity first enters
  /// picture-in-picture, and describe the bounds in window coordinates of activity entering
  /// picture-in-picture that will be visible following the transition. For the best effect,
  /// these bounds should also match the aspect ratio in the arguments.
  ///@param launchBounds window-coordinate bounds indicating the area of the activity that
  /// will still be visible following the transition into picture-in-picture (eg. the video
  /// view bounds in a video player)
  ///@return this builder instance.
  PictureInPictureParams_Builder setSourceRectHint(jni.JlObject launchBounds) =>
      PictureInPictureParams_Builder.fromRef(
          _setSourceRectHint(reference, launchBounds.reference));

  static final _build = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_PictureInPictureParams__Builder_build")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PictureInPictureParams build()
  /// @return an immutable PictureInPictureParams to be used when entering or updating
  /// the activity in picture-in-picture.
  ///@see Activity\#enterPictureInPictureMode(PictureInPictureParams)
  ///@see Activity\#setPictureInPictureParams(PictureInPictureParams)
  PictureInPictureParams build() =>
      PictureInPictureParams.fromRef(_build(reference));
}

/// A Fragment is a piece of an application's user interface or behavior
/// that can be placed in an Activity.  Interaction with fragments
/// is done through FragmentManager, which can be obtained via
/// Activity\#getFragmentManager() Activity.getFragmentManager() and
/// Fragment\#getFragmentManager() Fragment.getFragmentManager().
///
/// The Fragment class can be used many ways to achieve a wide variety of
/// results. In its core, it represents a particular operation or interface
/// that is running within a larger Activity.  A Fragment is closely
/// tied to the Activity it is in, and can not be used apart from one.  Though
/// Fragment defines its own lifecycle, that lifecycle is dependent on its
/// activity: if the activity is stopped, no fragments inside of it can be
/// started; when the activity is destroyed, all fragments will be destroyed.
///
/// All subclasses of Fragment must include a public no-argument constructor.
/// The framework will often re-instantiate a fragment class when needed,
/// in particular during state restore, and needs to be able to find this
/// constructor to instantiate it.  If the no-argument constructor is not
/// available, a runtime exception will occur in some cases during state
/// restore.
///
/// Topics covered here:
/// <ol>
/// <li><a href="\#OlderPlatforms">Older Platforms</a>
/// <li><a href="\#Lifecycle">Lifecycle</a>
/// <li><a href="\#Layout">Layout</a>
/// <li><a href="\#BackStack">Back Stack</a>
/// </ol>
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using fragments, read the
/// <a href="{@docRoot}guide/components/fragments.html">Fragments</a> developer guide.
///
/// </div>
///
/// <a name="OlderPlatforms"></a>
/// <h3>Older Platforms</h3>
///
/// While the Fragment API was introduced in
/// android.os.Build.VERSION_CODES\#HONEYCOMB, a version of the API
/// at is also available for use on older platforms through
/// android.support.v4.app.FragmentActivity.  See the blog post
/// <a href="http://android-developers.blogspot.com/2011/03/fragments-for-all.html">
/// Fragments For All</a> for more details.
///
/// <a name="Lifecycle"></a>
/// <h3>Lifecycle</h3>
///
/// Though a Fragment's lifecycle is tied to its owning activity, it has
/// its own wrinkle on the standard activity lifecycle.  It includes basic
/// activity lifecycle methods such as \#onResume, but also important
/// are methods related to interactions with the activity and UI generation.
///
/// The core series of lifecycle methods that are called to bring a fragment
/// up to resumed state (interacting with the user) are:
///
/// <ol>
/// <li> \#onAttach called once the fragment is associated with its activity.
/// <li> \#onCreate called to do initial creation of the fragment.
/// <li> \#onCreateView creates and returns the view hierarchy associated
/// with the fragment.
/// <li> \#onActivityCreated tells the fragment that its activity has
/// completed its own Activity\#onCreate Activity.onCreate().
/// <li> \#onViewStateRestored tells the fragment that all of the saved
/// state of its view hierarchy has been restored.
/// <li> \#onStart makes the fragment visible to the user (based on its
/// containing activity being started).
/// <li> \#onResume makes the fragment begin interacting with the user
/// (based on its containing activity being resumed).
/// </ol>
///
/// As a fragment is no longer being used, it goes through a reverse
/// series of callbacks:
///
/// <ol>
/// <li> \#onPause fragment is no longer interacting with the user either
/// because its activity is being paused or a fragment operation is modifying it
/// in the activity.
/// <li> \#onStop fragment is no longer visible to the user either
/// because its activity is being stopped or a fragment operation is modifying it
/// in the activity.
/// <li> \#onDestroyView allows the fragment to clean up resources
/// associated with its View.
/// <li> \#onDestroy called to do final cleanup of the fragment's state.
/// <li> \#onDetach called immediately prior to the fragment no longer
/// being associated with its activity.
/// </ol>
///
/// <a name="Layout"></a>
/// <h3>Layout</h3>
///
/// Fragments can be used as part of your application's layout, allowing
/// you to better modularize your code and more easily adjust your user
/// interface to the screen it is running on.  As an example, we can look
/// at a simple program consisting of a list of items, and display of the
/// details of each item.
///
///
/// An activity's layout XML can include <code>&lt;fragment&gt;</code> tags
/// to embed fragment instances inside of the layout.  For example, here is
/// a simple layout that embeds one fragment:
///
///
/// {@sample development/samples/ApiDemos/res/layout/fragment_layout.xml layout}
///
/// The layout is installed in the activity in the normal way:
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentLayout.java
///      main}
///
/// The titles fragment, showing a list of titles, is fairly simple, relying
/// on ListFragment for most of its work.  Note the implementation of
/// clicking an item: depending on the current activity's layout, it can either
/// create and display a new fragment to show the details in-place (more about
/// this later), or start a new activity to show the details.
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentLayout.java
///      titles}
///
/// The details fragment showing the contents of a selected item just
/// displays a string of text based on an index of a string array built in to
/// the app:
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentLayout.java
///      details}
///
/// In this case when the user clicks on a title, there is no details
/// container in the current activity, so the titles fragment's click code will
/// launch a new activity to display the details fragment:
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentLayout.java
///      details_activity}
///
/// However the screen may be large enough to show both the list of titles
/// and details about the currently selected title.  To use such a layout on
/// a landscape screen, this alternative layout can be placed under layout-land:
///
///
/// {@sample development/samples/ApiDemos/res/layout-land/fragment_layout.xml layout}
///
/// Note how the prior code will adjust to this alternative UI flow: the titles
/// fragment will now embed the details fragment inside of this activity, and the
/// details activity will finish itself if it is running in a configuration
/// where the details can be shown in-place.
///
/// When a configuration change causes the activity hosting these fragments
/// to restart, its new instance may use a different layout that doesn't
/// include the same fragments as the previous layout.  In this case all of
/// the previous fragments will still be instantiated and running in the new
/// instance.  However, any that are no longer associated with a &lt;fragment&gt;
/// tag in the view hierarchy will not have their content view created
/// and will return false from \#isInLayout.  (The code here also shows
/// how you can determine if a fragment placed in a container is no longer
/// running in a layout with that container and avoid creating its view hierarchy
/// in that case.)
///
/// The attributes of the &lt;fragment&gt; tag are used to control the
/// LayoutParams provided when attaching the fragment's view to the parent
/// container.  They can also be parsed by the fragment in \#onInflate
/// as parameters.
///
/// The fragment being instantiated must have some kind of unique identifier
/// so that it can be re-associated with a previous instance if the parent
/// activity needs to be destroyed and recreated.  This can be provided these
/// ways:
///
/// <ul>
/// <li>If nothing is explicitly supplied, the view ID of the container will
/// be used.
/// <li><code>android:tag</code> can be used in &lt;fragment&gt; to provide
/// a specific tag name for the fragment.
/// <li><code>android:id</code> can be used in &lt;fragment&gt; to provide
/// a specific identifier for the fragment.
/// </ul>
///
/// <a name="BackStack"></a>
/// <h3>Back Stack</h3>
///
/// The transaction in which fragments are modified can be placed on an
/// internal back-stack of the owning activity.  When the user presses back
/// in the activity, any transactions on the back stack are popped off before
/// the activity itself is finished.
///
/// For example, consider this simple fragment that is instantiated with
/// an integer argument and displays that in a TextView in its UI:
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentStack.java
///      fragment}
///
/// A function that creates a new instance of the fragment, replacing
/// whatever current fragment instance is being shown and pushing that change
/// on to the back stack could be written as:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentStack.java
///      add_stack}
///
/// After each call to this function, a new entry is on the stack, and
/// pressing back will pop it to return the user to whatever previous state
/// the activity UI was in.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.Fragment for consistent behavior across all devices
///      and access to <a href="{@docRoot}topic/libraries/architecture/lifecycle.html">Lifecycle</a>.
class Fragment extends jni.JlObject {
  Fragment.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Fragment_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Default constructor.  <strong>Every</strong> fragment must have an
  /// empty constructor, so it can be instantiated when restoring its
  /// activity's state.  It is strongly recommended that subclasses do not
  /// have other constructors with parameters, since these constructors
  /// will not be called when the fragment is re-instantiated; instead,
  /// arguments can be supplied by the caller with \#setArguments
  /// and later retrieved by the Fragment with \#getArguments.
  ///
  /// Applications should generally not implement a constructor. Prefer
  /// \#onAttach(Context) instead. It is the first place application code can run where
  /// the fragment is ready to be used - the point where the fragment is actually associated with
  /// its context. Some applications may also want to implement \#onInflate to retrieve
  /// attributes from a layout resource, although note this happens when the fragment is attached.
  Fragment() : super.fromRef(_ctor());

  static final _instantiate = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_instantiate")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.Fragment instantiate(android.content.Context context, java.lang.String fname)
  /// Like \#instantiate(Context, String, Bundle) but with a null
  /// argument Bundle.
  static Fragment instantiate(content.Context context, jni.JlString fname) =>
      Fragment.fromRef(_instantiate(context.reference, fname.reference));

  static final _instantiate_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_instantiate_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.Fragment instantiate(android.content.Context context, java.lang.String fname, android.os.Bundle args)
  /// Create a new instance of a Fragment with the given class name.  This is
  /// the same as calling its empty constructor.
  ///@param context The calling context being used to instantiate the fragment.
  /// This is currently just used to get its ClassLoader.
  ///@param fname The class name of the fragment to instantiate.
  ///@param args Bundle of arguments to supply to the fragment, which it
  /// can retrieve with \#getArguments().  May be null.
  /// This value may be {@code null}.
  ///@return Returns a new fragment instance.
  ///@throws InstantiationException If there is a failure in instantiating
  /// the given fragment class.  This is a runtime exception; it is not
  /// normally expected to happen.
  static Fragment instantiate_1(
          content.Context context, jni.JlString fname, os.Bundle args) =>
      Fragment.fromRef(
          _instantiate_1(context.reference, fname.reference, args.reference));

  static final _equals_1 = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_equals_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean equals(java.lang.Object o)
  /// Subclasses can not override equals().
  bool equals_1(jni.JlObject o) => _equals_1(reference, o.reference) != 0;

  static final _hashCode_1 =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_hashCode_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int hashCode()
  /// Subclasses can not override hashCode().
  int hashCode_1() => _hashCode_1(reference);

  static final _toString_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _getId =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_getId")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getId()
  /// Return the identifier this fragment is known by.  This is either
  /// the android:id value supplied in a layout or the container view ID
  /// supplied when adding the fragment.
  int getId() => _getId(reference);

  static final _getTag = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_getTag")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String getTag()
  /// Get the tag name of the fragment, if specified.
  jni.JlString getTag() => jni.JlString.fromRef(_getTag(reference));

  static final _setArguments = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_setArguments")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setArguments(android.os.Bundle args)
  /// Supply the construction arguments for this fragment.
  /// The arguments supplied here will be retained across fragment destroy and
  /// creation.
  ///
  /// This method cannot be called if the fragment is added to a FragmentManager and
  /// if \#isStateSaved() would return true. Prior to Build.VERSION_CODES\#O,
  /// this method may only be called if the fragment has not yet been added to a FragmentManager.
  ///
  ///
  void setArguments(os.Bundle args) => _setArguments(reference, args.reference);

  static final _getArguments = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_getArguments")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.Bundle getArguments()
  /// Return the arguments supplied to \#setArguments, if any.
  os.Bundle getArguments() => os.Bundle.fromRef(_getArguments(reference));

  static final _isStateSaved =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_isStateSaved")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isStateSaved()
  /// Returns true if this fragment is added and its state has already been saved
  /// by its host. Any operations that would change saved state should not be performed
  /// if this method returns true, and some operations such as \#setArguments(Bundle)
  /// will fail.
  ///@return true if this fragment's state has already been saved by its host
  bool isStateSaved() => _isStateSaved(reference) != 0;

  static final _setInitialSavedState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_setInitialSavedState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setInitialSavedState(android.app.Fragment.SavedState state)
  /// Set the initial saved state that this Fragment should restore itself
  /// from when first being constructed, as returned by
  /// FragmentManager\#saveFragmentInstanceState(Fragment) FragmentManager.saveFragmentInstanceState.
  ///@param state The state the fragment should be restored from.
  void setInitialSavedState(Fragment_SavedState state) =>
      _setInitialSavedState(reference, state.reference);

  static final _setTargetFragment = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Fragment_setTargetFragment")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setTargetFragment(android.app.Fragment fragment, int requestCode)
  /// Optional target for this fragment.  This may be used, for example,
  /// if this fragment is being started by another, and when done wants to
  /// give a result back to the first.  The target set here is retained
  /// across instances via FragmentManager\#putFragment FragmentManager.putFragment().
  ///@param fragment The fragment that is the target of this one.
  ///@param requestCode Optional request code, for convenience if you
  /// are going to call back with \#onActivityResult(int, int, Intent).
  void setTargetFragment(Fragment fragment, int requestCode) =>
      _setTargetFragment(reference, fragment.reference, requestCode);

  static final _getTargetFragment = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_getTargetFragment")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Fragment getTargetFragment()
  /// Return the target fragment set by \#setTargetFragment.
  Fragment getTargetFragment() =>
      Fragment.fromRef(_getTargetFragment(reference));

  static final _getTargetRequestCode =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_getTargetRequestCode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getTargetRequestCode()
  /// Return the target request code set by \#setTargetFragment.
  int getTargetRequestCode() => _getTargetRequestCode(reference);

  static final _getContext = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_getContext")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context getContext()
  /// Return the Context this fragment is currently associated with.
  content.Context getContext() =>
      content.Context.fromRef(_getContext(reference));

  static final _getActivity = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_getActivity")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Activity getActivity()
  /// Return the Activity this fragment is currently associated with.
  Activity getActivity() => Activity.fromRef(_getActivity(reference));

  static final _getHost = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_getHost")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.Object getHost()
  /// Return the host object of this fragment. May return {@code null} if the fragment
  /// isn't currently being hosted.
  jni.JlObject getHost() => jni.JlObject.fromRef(_getHost(reference));

  static final _getResources = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_getResources")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.Resources getResources()
  /// Return <code>getActivity().getResources()</code>.
  res.Resources getResources() =>
      res.Resources.fromRef(_getResources(reference));

  static final _getText = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Fragment_getText")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final java.lang.CharSequence getText(int resId)
  /// Return a localized, styled CharSequence from the application's package's
  /// default string table.
  ///@param resId Resource id for the CharSequence text
  jni.JlObject getText(int resId) =>
      jni.JlObject.fromRef(_getText(reference, resId));

  static final _getString = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Fragment_getString")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final java.lang.String getString(int resId)
  /// Return a localized string from the application's package's
  /// default string table.
  ///@param resId Resource id for the string
  jni.JlString getString(int resId) =>
      jni.JlString.fromRef(_getString(reference, resId));

  static final _getString_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_getString_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String getString(int resId, java.lang.Object[] formatArgs)
  /// Return a localized formatted string from the application's package's
  /// default string table, substituting the format arguments as defined in
  /// java.util.Formatter and java.lang.String\#format.
  ///@param resId Resource id for the format string
  ///@param formatArgs The format arguments that will be used for substitution.
  jni.JlString getString_1(int resId, jni.JlObject formatArgs) =>
      jni.JlString.fromRef(
          _getString_1(reference, resId, formatArgs.reference));

  static final _getFragmentManager = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_getFragmentManager")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.FragmentManager getFragmentManager()
  /// Return the FragmentManager for interacting with fragments associated
  /// with this fragment's activity.  Note that this will be non-null slightly
  /// before \#getActivity(), during the time from when the fragment is
  /// placed in a FragmentTransaction until it is committed and
  /// attached to its activity.
  ///
  /// If this Fragment is a child of another Fragment, the FragmentManager
  /// returned here will be the parent's \#getChildFragmentManager().
  FragmentManager getFragmentManager() =>
      FragmentManager.fromRef(_getFragmentManager(reference));

  static final _getChildFragmentManager = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_getChildFragmentManager")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.FragmentManager getChildFragmentManager()
  /// Return a private FragmentManager for placing and managing Fragments
  /// inside of this Fragment.
  FragmentManager getChildFragmentManager() =>
      FragmentManager.fromRef(_getChildFragmentManager(reference));

  static final _getParentFragment = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_getParentFragment")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Fragment getParentFragment()
  /// Returns the parent Fragment containing this Fragment.  If this Fragment
  /// is attached directly to an Activity, returns null.
  Fragment getParentFragment() =>
      Fragment.fromRef(_getParentFragment(reference));

  static final _isAdded =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_isAdded")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isAdded()
  /// Return true if the fragment is currently added to its activity.
  bool isAdded() => _isAdded(reference) != 0;

  static final _isDetached =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_isDetached")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isDetached()
  /// Return true if the fragment has been explicitly detached from the UI.
  /// That is, FragmentTransaction\#detach(Fragment) FragmentTransaction.detach(Fragment) has been used on it.
  bool isDetached() => _isDetached(reference) != 0;

  static final _isRemoving =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_isRemoving")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isRemoving()
  /// Return true if this fragment is currently being removed from its
  /// activity.  This is  _not_ whether its activity is finishing, but
  /// rather whether it is in the process of being removed from its activity.
  bool isRemoving() => _isRemoving(reference) != 0;

  static final _isInLayout =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_isInLayout")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isInLayout()
  /// Return true if the layout is included as part of an activity view
  /// hierarchy via the &lt;fragment&gt; tag.  This will always be true when
  /// fragments are created through the &lt;fragment&gt; tag, _except_
  /// in the case where an old fragment is restored from a previous state and
  /// it does not appear in the layout of the current state.
  bool isInLayout() => _isInLayout(reference) != 0;

  static final _isResumed =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_isResumed")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isResumed()
  /// Return true if the fragment is in the resumed state.  This is true
  /// for the duration of \#onResume() and \#onPause() as well.
  bool isResumed() => _isResumed(reference) != 0;

  static final _isVisible =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_isVisible")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isVisible()
  /// Return true if the fragment is currently visible to the user.  This means
  /// it: (1) has been added, (2) has its view attached to the window, and
  /// (3) is not hidden.
  bool isVisible() => _isVisible(reference) != 0;

  static final _isHidden =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_isHidden")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isHidden()
  /// Return true if the fragment has been hidden.  By default fragments
  /// are shown.  You can find out about changes to this state with
  /// \#onHiddenChanged.  Note that the hidden state is orthogonal
  /// to other states -- that is, to be visible to the user, a fragment
  /// must be both started and not hidden.
  bool isHidden() => _isHidden(reference) != 0;

  static final _onHiddenChanged = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Fragment_onHiddenChanged")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onHiddenChanged(boolean hidden)
  /// Called when the hidden state (as returned by \#isHidden() of
  /// the fragment has changed.  Fragments start out not hidden; this will
  /// be called whenever the fragment changes state from that.
  ///@param hidden True if the fragment is now hidden, false otherwise.
  void onHiddenChanged(bool hidden) =>
      _onHiddenChanged(reference, hidden ? 1 : 0);

  static final _setRetainInstance = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Fragment_setRetainInstance")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setRetainInstance(boolean retain)
  /// Control whether a fragment instance is retained across Activity
  /// re-creation (such as from a configuration change).  This can only
  /// be used with fragments not in the back stack.  If set, the fragment
  /// lifecycle will be slightly different when an activity is recreated:
  /// <ul>
  /// <li> \#onDestroy() will not be called (but \#onDetach() still
  /// will be, because the fragment is being detached from its current activity).
  /// <li> \#onCreate(Bundle) will not be called since the fragment
  /// is not being re-created.
  /// <li> \#onAttach(Activity) and \#onActivityCreated(Bundle) __will__
  /// still be called.
  /// </ul>
  void setRetainInstance(bool retain) =>
      _setRetainInstance(reference, retain ? 1 : 0);

  static final _getRetainInstance =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_getRetainInstance")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean getRetainInstance()
  bool getRetainInstance() => _getRetainInstance(reference) != 0;

  static final _setHasOptionsMenu = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Fragment_setHasOptionsMenu")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setHasOptionsMenu(boolean hasMenu)
  /// Report that this fragment would like to participate in populating
  /// the options menu by receiving a call to \#onCreateOptionsMenu
  /// and related methods.
  ///@param hasMenu If true, the fragment has menu items to contribute.
  void setHasOptionsMenu(bool hasMenu) =>
      _setHasOptionsMenu(reference, hasMenu ? 1 : 0);

  static final _setMenuVisibility = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Fragment_setMenuVisibility")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setMenuVisibility(boolean menuVisible)
  /// Set a hint for whether this fragment's menu should be visible.  This
  /// is useful if you know that a fragment has been placed in your view
  /// hierarchy so that the user can not currently seen it, so any menu items
  /// it has should also not be shown.
  ///@param menuVisible The default is true, meaning the fragment's menu will
  /// be shown as usual.  If false, the user will not see the menu.
  void setMenuVisibility(bool menuVisible) =>
      _setMenuVisibility(reference, menuVisible ? 1 : 0);

  static final _setUserVisibleHint = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Fragment_setUserVisibleHint")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setUserVisibleHint(boolean isVisibleToUser)
  /// Set a hint to the system about whether this fragment's UI is currently visible
  /// to the user. This hint defaults to true and is persistent across fragment instance
  /// state save and restore.
  ///
  /// An app may set this to false to indicate that the fragment's UI is
  /// scrolled out of visibility or is otherwise not directly visible to the user.
  /// This may be used by the system to prioritize operations such as fragment lifecycle updates
  /// or loader ordering behavior.
  ///
  ///
  /// <strong>Note:</strong> This method may be called outside of the fragment lifecycle
  /// and thus has no ordering guarantees with regard to fragment lifecycle method calls.
  ///
  ///
  /// <strong>Note:</strong> Prior to Android N there was a platform bug that could cause
  /// <code>setUserVisibleHint</code> to bring a fragment up to the started state before its
  /// <code>FragmentTransaction</code> had been committed. As some apps relied on this behavior,
  /// it is preserved for apps that declare a <code>targetSdkVersion</code> of 23 or lower.
  ///
  ///@param isVisibleToUser true if this fragment's UI is currently visible to the user (default),
  ///                        false if it is not.
  void setUserVisibleHint(bool isVisibleToUser) =>
      _setUserVisibleHint(reference, isVisibleToUser ? 1 : 0);

  static final _getUserVisibleHint =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_getUserVisibleHint")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getUserVisibleHint()
  /// @return The current value of the user-visible hint on this fragment.
  ///@see \#setUserVisibleHint(boolean)
  bool getUserVisibleHint() => _getUserVisibleHint(reference) != 0;

  static final _getLoaderManager = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_getLoaderManager")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.LoaderManager getLoaderManager()
  /// Return the LoaderManager for this fragment, creating it if needed.
  ///@deprecated Use android.support.v4.app.Fragment\#getLoaderManager()
  LoaderManager getLoaderManager() =>
      LoaderManager.fromRef(_getLoaderManager(reference));

  static final _startActivity = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_startActivity")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivity(android.content.Intent intent)
  /// Call Activity\#startActivity(Intent) from the fragment's
  /// containing Activity.
  ///@param intent The intent to start.
  void startActivity(content.Intent intent) =>
      _startActivity(reference, intent.reference);

  static final _startActivity_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_startActivity_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivity(android.content.Intent intent, android.os.Bundle options)
  /// Call Activity\#startActivity(Intent, Bundle) from the fragment's
  /// containing Activity.
  ///@param intent The intent to start.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  void startActivity_1(content.Intent intent, os.Bundle options) =>
      _startActivity_1(reference, intent.reference, options.reference);

  static final _startActivityForResult = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Fragment_startActivityForResult")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void startActivityForResult(android.content.Intent intent, int requestCode)
  /// Call Activity\#startActivityForResult(Intent, int) from the fragment's
  /// containing Activity.
  void startActivityForResult(content.Intent intent, int requestCode) =>
      _startActivityForResult(reference, intent.reference, requestCode);

  static final _startActivityForResult_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_startActivityForResult_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivityForResult(android.content.Intent intent, int requestCode, android.os.Bundle options)
  /// Call Activity\#startActivityForResult(Intent, int, Bundle) from the fragment's
  /// containing Activity.
  void startActivityForResult_1(
          content.Intent intent, int requestCode, os.Bundle options) =>
      _startActivityForResult_1(
          reference, intent.reference, requestCode, options.reference);

  static final _startIntentSenderForResult = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_startIntentSenderForResult")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void startIntentSenderForResult(android.content.IntentSender intent, int requestCode, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, android.os.Bundle options)
  /// Call Activity\#startIntentSenderForResult(IntentSender, int, Intent, int, int, int,
  /// Bundle) from the fragment's containing Activity.
  ///@param fillInIntent This value may be {@code null}.
  void startIntentSenderForResult(
          content.IntentSender intent,
          int requestCode,
          content.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags,
          os.Bundle options) =>
      _startIntentSenderForResult(
          reference,
          intent.reference,
          requestCode,
          fillInIntent.reference,
          flagsMask,
          flagsValues,
          extraFlags,
          options.reference);

  static final _onActivityResult = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_onActivityResult")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onActivityResult(int requestCode, int resultCode, android.content.Intent data)
  /// Receive the result from a previous call to
  /// \#startActivityForResult(Intent, int).  This follows the
  /// related Activity API as described there in
  /// Activity\#onActivityResult(int, int, Intent).
  ///@param requestCode The integer request code originally supplied to
  ///                    startActivityForResult(), allowing you to identify who this
  ///                    result came from.
  ///@param resultCode The integer result code returned by the child activity
  ///                   through its setResult().
  ///@param data An Intent, which can return result data to the caller
  ///               (various data can be attached to Intent "extras").
  void onActivityResult(int requestCode, int resultCode, content.Intent data) =>
      _onActivityResult(reference, requestCode, resultCode, data.reference);

  static final _requestPermissions = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Fragment_requestPermissions")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void requestPermissions(java.lang.String[] permissions, int requestCode)
  /// Requests permissions to be granted to this application. These permissions
  /// must be requested in your manifest, they should not be granted to your app,
  /// and they should have protection level android.content.pm.PermissionInfo \#PROTECTION_DANGEROUS dangerous, regardless whether they are declared by
  /// the platform or a third-party app.
  ///
  /// Normal permissions android.content.pm.PermissionInfo\#PROTECTION_NORMAL
  /// are granted at install time if requested in the manifest. Signature permissions
  /// android.content.pm.PermissionInfo\#PROTECTION_SIGNATURE are granted at
  /// install time if requested in the manifest and the signature of your app matches
  /// the signature of the app declaring the permissions.
  ///
  ///
  ///
  /// If your app does not have the requested permissions the user will be presented
  /// with UI for accepting them. After the user has accepted or rejected the
  /// requested permissions you will receive a callback on \#onRequestPermissionsResult(int, String[], int[]) reporting whether the
  /// permissions were granted or not.
  ///
  ///
  ///
  /// Note that requesting a permission does not guarantee it will be granted and
  /// your app should be able to run without having this permission.
  ///
  ///
  ///
  /// This method may start an activity allowing the user to choose which permissions
  /// to grant and which to reject. Hence, you should be prepared that your activity
  /// may be paused and resumed. Further, granting some permissions may require
  /// a restart of you application. In such a case, the system will recreate the
  /// activity stack before delivering the result to \#onRequestPermissionsResult(int, String[], int[]).
  ///
  ///
  ///
  /// When checking whether you have a permission you should use android.content.Context\#checkSelfPermission(String).
  ///
  ///
  ///
  /// Calling this API for permissions already granted to your app would show UI
  /// to the user to decide whether the app can still hold these permissions. This
  /// can be useful if the way your app uses data guarded by the permissions
  /// changes significantly.
  ///
  ///
  ///
  /// You cannot request a permission if your activity sets android.R.styleable\#AndroidManifestActivity_noHistory noHistory to
  /// <code>true</code> because in this case the activity would not receive
  /// result callbacks including \#onRequestPermissionsResult(int, String[], int[]).
  ///
  ///
  ///
  /// A sample permissions request looks like this:
  ///
  ///
  /// <code><pre>
  /// private void showContacts() {
  ///     if (getActivity().checkSelfPermission(Manifest.permission.READ_CONTACTS)
  ///             != PackageManager.PERMISSION_GRANTED) {
  ///         requestPermissions(new String[]{Manifest.permission.READ_CONTACTS},
  ///                 PERMISSIONS_REQUEST_READ_CONTACTS);
  ///     } else {
  ///         doShowContacts();
  ///     }
  /// }
  ///
  /// {@literal @}Override
  /// public void onRequestPermissionsResult(int requestCode, String[] permissions,
  ///         int[] grantResults) {
  ///     if (requestCode == PERMISSIONS_REQUEST_READ_CONTACTS
  ///             && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
  ///         doShowContacts();
  ///     }
  /// }
  /// </code></pre>
  ///
  ///@param permissions The requested permissions. Must me non-null and not empty.
  /// This value must never be {@code null}.
  ///@param requestCode Application specific request code to match with a result
  ///    reported to \#onRequestPermissionsResult(int, String[], int[]).
  ///    Should be >= 0.
  ///@see \#onRequestPermissionsResult(int, String[], int[])
  ///@see android.content.Context\#checkSelfPermission(String)
  void requestPermissions(jni.JlObject permissions, int requestCode) =>
      _requestPermissions(reference, permissions.reference, requestCode);

  static final _onRequestPermissionsResult = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_onRequestPermissionsResult")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onRequestPermissionsResult(int requestCode, java.lang.String[] permissions, int[] grantResults)
  /// Callback for the result from requesting permissions. This method
  /// is invoked for every call on \#requestPermissions(String[], int).
  ///
  /// <strong>Note:</strong> It is possible that the permissions request interaction
  /// with the user is interrupted. In this case you will receive empty permissions
  /// and results arrays which should be treated as a cancellation.
  ///
  ///
  ///@param requestCode The request code passed in \#requestPermissions(String[], int).
  ///@param permissions The requested permissions. Never null.
  /// This value must never be {@code null}.
  ///@param grantResults The grant results for the corresponding permissions
  ///     which is either android.content.pm.PackageManager\#PERMISSION_GRANTED
  ///     or android.content.pm.PackageManager\#PERMISSION_DENIED. Never null.
  ///
  /// This value must never be {@code null}.
  ///@see \#requestPermissions(String[], int)
  void onRequestPermissionsResult(int requestCode, jni.JlObject permissions,
          jni.JlObject grantResults) =>
      _onRequestPermissionsResult(reference, requestCode, permissions.reference,
          grantResults.reference);

  static final _shouldShowRequestPermissionRationale = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_shouldShowRequestPermissionRationale")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldShowRequestPermissionRationale(java.lang.String permission)
  /// Gets whether you should show UI with rationale for requesting a permission.
  /// You should do this only if you do not have the permission and the context in
  /// which the permission is requested does not clearly communicate to the user
  /// what would be the benefit from granting this permission.
  ///
  /// For example, if you write a camera app, requesting the camera permission
  /// would be expected by the user and no rationale for why it is requested is
  /// needed. If however, the app needs location for tagging photos then a non-tech
  /// savvy user may wonder how location is related to taking photos. In this case
  /// you may choose to show UI with rationale of requesting this permission.
  ///
  ///
  ///@param permission A permission your app wants to request.
  /// This value must never be {@code null}.
  ///@return Whether you can show permission rationale UI.
  ///@see Context\#checkSelfPermission(String)
  ///@see \#requestPermissions(String[], int)
  ///@see \#onRequestPermissionsResult(int, String[], int[])
  bool shouldShowRequestPermissionRationale(jni.JlString permission) =>
      _shouldShowRequestPermissionRationale(reference, permission.reference) !=
      0;

  static final _onGetLayoutInflater = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_onGetLayoutInflater")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.LayoutInflater onGetLayoutInflater(android.os.Bundle savedInstanceState)
  /// Returns the LayoutInflater used to inflate Views of this Fragment. The default
  /// implementation will throw an exception if the Fragment is not attached.
  ///@return The LayoutInflater used to inflate Views of this Fragment.
  jni.JlObject onGetLayoutInflater(os.Bundle savedInstanceState) =>
      jni.JlObject.fromRef(
          _onGetLayoutInflater(reference, savedInstanceState.reference));

  static final _getLayoutInflater = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_getLayoutInflater")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.view.LayoutInflater getLayoutInflater()
  /// Returns the cached LayoutInflater used to inflate Views of this Fragment. If
  /// \#onGetLayoutInflater(Bundle) has not been called \#onGetLayoutInflater(Bundle)
  /// will be called with a {@code null} argument and that value will be cached.
  ///
  /// The cached LayoutInflater will be replaced immediately prior to
  /// \#onCreateView(LayoutInflater, ViewGroup, Bundle) and cleared immediately after
  /// \#onDetach().
  ///@return The LayoutInflater used to inflate Views of this Fragment.
  jni.JlObject getLayoutInflater() =>
      jni.JlObject.fromRef(_getLayoutInflater(reference));

  static final _onInflate = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_onInflate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onInflate(android.util.AttributeSet attrs, android.os.Bundle savedInstanceState)
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@deprecated Use \#onInflate(Context, AttributeSet, Bundle) instead.
  void onInflate(jni.JlObject attrs, os.Bundle savedInstanceState) =>
      _onInflate(reference, attrs.reference, savedInstanceState.reference);

  static final _onInflate_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_onInflate_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onInflate(android.content.Context context, android.util.AttributeSet attrs, android.os.Bundle savedInstanceState)
  /// Called when a fragment is being created as part of a view layout
  /// inflation, typically from setting the content view of an activity.  This
  /// may be called immediately after the fragment is created from a <fragment>
  /// tag in a layout file.  Note this is _before_ the fragment's
  /// \#onAttach(Activity) has been called; all you should do here is
  /// parse the attributes and save them away.
  ///
  /// This is called every time the fragment is inflated, even if it is
  /// being inflated into a new instance with saved state.  It typically makes
  /// sense to re-parse the parameters each time, to allow them to change with
  /// different configurations.
  ///
  ///
  /// Here is a typical implementation of a fragment that can take parameters
  /// both through attributes supplied here as well from \#getArguments():
  ///
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentArguments.java
  ///      fragment}
  ///
  /// Note that parsing the XML attributes uses a "styleable" resource.  The
  /// declaration for the styleable used here is:
  ///
  ///
  /// {@sample development/samples/ApiDemos/res/values/attrs.xml fragment_arguments}
  ///
  /// The fragment can then be declared within its activity's content layout
  /// through a tag like this:
  ///
  ///
  /// {@sample development/samples/ApiDemos/res/layout/fragment_arguments.xml from_attributes}
  ///
  /// This fragment can also be created dynamically from arguments given
  /// at runtime in the arguments Bundle; here is an example of doing so at
  /// creation of the containing activity:
  ///
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentArguments.java
  ///      create}
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param context The Context that is inflating this fragment.
  ///@param attrs The attributes at the tag where the fragment is
  /// being created.
  ///@param savedInstanceState If the fragment is being re-created from
  /// a previous saved state, this is the state.
  void onInflate_1(content.Context context, jni.JlObject attrs,
          os.Bundle savedInstanceState) =>
      _onInflate_1(reference, context.reference, attrs.reference,
          savedInstanceState.reference);

  static final _onInflate_2 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_onInflate_2")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onInflate(android.app.Activity activity, android.util.AttributeSet attrs, android.os.Bundle savedInstanceState)
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@deprecated Use \#onInflate(Context, AttributeSet, Bundle) instead.
  void onInflate_2(Activity activity, jni.JlObject attrs,
          os.Bundle savedInstanceState) =>
      _onInflate_2(reference, activity.reference, attrs.reference,
          savedInstanceState.reference);

  static final _onAttachFragment = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_onAttachFragment")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttachFragment(android.app.Fragment childFragment)
  /// Called when a fragment is attached as a child of this fragment.
  ///
  /// This is called after the attached fragment's <code>onAttach</code> and before
  /// the attached fragment's <code>onCreate</code> if the fragment has not yet had a previous
  /// call to <code>onCreate</code>.
  ///
  ///@param childFragment child fragment being attached
  void onAttachFragment(Fragment childFragment) =>
      _onAttachFragment(reference, childFragment.reference);

  static final _onAttach = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_onAttach")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttach(android.content.Context context)
  /// Called when a fragment is first attached to its context.
  /// \#onCreate(Bundle) will be called after this.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onAttach(content.Context context) =>
      _onAttach(reference, context.reference);

  static final _onAttach_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_onAttach_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttach(android.app.Activity activity)
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@deprecated Use \#onAttach(Context) instead.
  void onAttach_1(Activity activity) =>
      _onAttach_1(reference, activity.reference);

  static final _onCreateAnimator = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Uint8,
                  ffi.Int32)>>("android_app_Fragment_onCreateAnimator")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public android.animation.Animator onCreateAnimator(int transit, boolean enter, int nextAnim)
  /// Called when a fragment loads an animation.
  jni.JlObject onCreateAnimator(int transit, bool enter, int nextAnim) =>
      jni.JlObject.fromRef(
          _onCreateAnimator(reference, transit, enter ? 1 : 0, nextAnim));

  static final _onCreate = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_onCreate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreate(android.os.Bundle savedInstanceState)
  /// Called to do initial creation of a fragment.  This is called after
  /// \#onAttach(Activity) and before
  /// \#onCreateView(LayoutInflater, ViewGroup, Bundle), but is not called if the fragment
  /// instance is retained across Activity re-creation (see \#setRetainInstance(boolean)).
  ///
  /// Note that this can be called while the fragment's activity is
  /// still in the process of being created.  As such, you can not rely
  /// on things like the activity's content view hierarchy being initialized
  /// at this point.  If you want to do work once the activity itself is
  /// created, see \#onActivityCreated(Bundle).
  ///
  /// If your app's <code>targetSdkVersion</code> is android.os.Build.VERSION_CODES\#M
  /// or lower, child fragments being restored from the savedInstanceState are restored after
  /// <code>onCreate</code> returns. When targeting android.os.Build.VERSION_CODES\#N or
  /// above and running on an N or newer platform version
  /// they are restored by <code>Fragment.onCreate</code>.
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param savedInstanceState If the fragment is being re-created from
  /// a previous saved state, this is the state.
  ///
  /// This value may be {@code null}.
  void onCreate(os.Bundle savedInstanceState) =>
      _onCreate(reference, savedInstanceState.reference);

  static final _onCreateView = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_onCreateView")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View onCreateView(android.view.LayoutInflater inflater, android.view.ViewGroup container, android.os.Bundle savedInstanceState)
  /// Called to have the fragment instantiate its user interface view.
  /// This is optional, and non-graphical fragments can return null (which
  /// is the default implementation).  This will be called between
  /// \#onCreate(Bundle) and \#onActivityCreated(Bundle).
  ///
  /// If you return a View from here, you will later be called in
  /// \#onDestroyView when the view is being released.
  ///@param inflater The LayoutInflater object that can be used to inflate
  /// any views in the fragment,
  ///@param container If non-null, this is the parent view that the fragment's
  /// UI should be attached to.  The fragment should not add the view itself,
  /// but this can be used to generate the LayoutParams of the view.
  /// This value may be {@code null}.
  ///@param savedInstanceState If non-null, this fragment is being re-constructed
  /// from a previous saved state as given here.
  ///@return Return the View for the fragment's UI, or null.
  jni.JlObject onCreateView(jni.JlObject inflater, jni.JlObject container,
          os.Bundle savedInstanceState) =>
      jni.JlObject.fromRef(_onCreateView(reference, inflater.reference,
          container.reference, savedInstanceState.reference));

  static final _onViewCreated = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_onViewCreated")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onViewCreated(android.view.View view, android.os.Bundle savedInstanceState)
  /// Called immediately after \#onCreateView(LayoutInflater, ViewGroup, Bundle)
  /// has returned, but before any saved state has been restored in to the view.
  /// This gives subclasses a chance to initialize themselves once
  /// they know their view hierarchy has been completely created.  The fragment's
  /// view hierarchy is not however attached to its parent at this point.
  ///@param view The View returned by \#onCreateView(LayoutInflater, ViewGroup, Bundle).
  ///@param savedInstanceState If non-null, this fragment is being re-constructed
  /// from a previous saved state as given here.
  ///
  /// This value may be {@code null}.
  void onViewCreated(jni.JlObject view, os.Bundle savedInstanceState) =>
      _onViewCreated(reference, view.reference, savedInstanceState.reference);

  static final _getView = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_getView")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View getView()
  /// Get the root view for the fragment's layout (the one returned by \#onCreateView),
  /// if provided.
  ///@return The fragment's root view, or null if it has no layout.
  jni.JlObject getView() => jni.JlObject.fromRef(_getView(reference));

  static final _onActivityCreated = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_onActivityCreated")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onActivityCreated(android.os.Bundle savedInstanceState)
  /// Called when the fragment's activity has been created and this
  /// fragment's view hierarchy instantiated.  It can be used to do final
  /// initialization once these pieces are in place, such as retrieving
  /// views or restoring state.  It is also useful for fragments that use
  /// \#setRetainInstance(boolean) to retain their instance,
  /// as this callback tells the fragment when it is fully associated with
  /// the new activity instance.  This is called after \#onCreateView
  /// and before \#onViewStateRestored(Bundle).
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param savedInstanceState If the fragment is being re-created from
  /// a previous saved state, this is the state.
  ///
  /// This value may be {@code null}.
  void onActivityCreated(os.Bundle savedInstanceState) =>
      _onActivityCreated(reference, savedInstanceState.reference);

  static final _onViewStateRestored = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_onViewStateRestored")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onViewStateRestored(android.os.Bundle savedInstanceState)
  /// Called when all saved state has been restored into the view hierarchy
  /// of the fragment.  This can be used to do initialization based on saved
  /// state that you are letting the view hierarchy track itself, such as
  /// whether check box widgets are currently checked.  This is called
  /// after \#onActivityCreated(Bundle) and before
  /// \#onStart().
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param savedInstanceState If the fragment is being re-created from
  /// a previous saved state, this is the state.
  void onViewStateRestored(os.Bundle savedInstanceState) =>
      _onViewStateRestored(reference, savedInstanceState.reference);

  static final _onStart =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_onStart")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onStart()
  /// Called when the Fragment is visible to the user.  This is generally
  /// tied to Activity\#onStart() Activity.onStart of the containing
  /// Activity's lifecycle.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onStart() => _onStart(reference);

  static final _onResume =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_onResume")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onResume()
  /// Called when the fragment is visible to the user and actively running.
  /// This is generally
  /// tied to Activity\#onResume() Activity.onResume of the containing
  /// Activity's lifecycle.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onResume() => _onResume(reference);

  static final _onSaveInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_onSaveInstanceState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onSaveInstanceState(android.os.Bundle outState)
  /// Called to ask the fragment to save its current dynamic state, so it
  /// can later be reconstructed in a new instance of its process is
  /// restarted.  If a new instance of the fragment later needs to be
  /// created, the data you place in the Bundle here will be available
  /// in the Bundle given to \#onCreate(Bundle),
  /// \#onCreateView(LayoutInflater, ViewGroup, Bundle), and
  /// \#onActivityCreated(Bundle).
  ///
  /// This corresponds to Activity\#onSaveInstanceState(Bundle) Activity.onSaveInstanceState(Bundle) and most of the discussion there
  /// applies here as well.  Note however: _this method may be called
  /// at any time before \#onDestroy()_.  There are many situations
  /// where a fragment may be mostly torn down (such as when placed on the
  /// back stack with no UI showing), but its state will not be saved until
  /// its owning activity actually needs to save its state.
  ///@param outState Bundle in which to place your saved state.
  void onSaveInstanceState(os.Bundle outState) =>
      _onSaveInstanceState(reference, outState.reference);

  static final _onMultiWindowModeChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_onMultiWindowModeChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onMultiWindowModeChanged(boolean isInMultiWindowMode, android.content.res.Configuration newConfig)
  /// Called when the Fragment's activity changes from fullscreen mode to multi-window mode and
  /// visa-versa. This is generally tied to Activity\#onMultiWindowModeChanged of the
  /// containing Activity. This method provides the same configuration that will be sent in the
  /// following \#onConfigurationChanged(Configuration) call after the activity enters this
  /// mode.
  ///@param isInMultiWindowMode True if the activity is in multi-window mode.
  ///@param newConfig The new configuration of the activity with the state
  ///                  {@param isInMultiWindowMode}.
  void onMultiWindowModeChanged(
          bool isInMultiWindowMode, res.Configuration newConfig) =>
      _onMultiWindowModeChanged(
          reference, isInMultiWindowMode ? 1 : 0, newConfig.reference);

  static final _onMultiWindowModeChanged_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Fragment_onMultiWindowModeChanged_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onMultiWindowModeChanged(boolean isInMultiWindowMode)
  /// Called when the Fragment's activity changes from fullscreen mode to multi-window mode and
  /// visa-versa. This is generally tied to Activity\#onMultiWindowModeChanged of the
  /// containing Activity.
  ///@param isInMultiWindowMode True if the activity is in multi-window mode.
  ///@deprecated Use \#onMultiWindowModeChanged(boolean, Configuration) instead.
  void onMultiWindowModeChanged_1(bool isInMultiWindowMode) =>
      _onMultiWindowModeChanged_1(reference, isInMultiWindowMode ? 1 : 0);

  static final _onPictureInPictureModeChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_onPictureInPictureModeChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode, android.content.res.Configuration newConfig)
  /// Called by the system when the activity changes to and from picture-in-picture mode. This is
  /// generally tied to Activity\#onPictureInPictureModeChanged of the containing Activity.
  /// This method provides the same configuration that will be sent in the following
  /// \#onConfigurationChanged(Configuration) call after the activity enters this mode.
  ///@param isInPictureInPictureMode True if the activity is in picture-in-picture mode.
  ///@param newConfig The new configuration of the activity with the state
  ///                  {@param isInPictureInPictureMode}.
  void onPictureInPictureModeChanged(
          bool isInPictureInPictureMode, res.Configuration newConfig) =>
      _onPictureInPictureModeChanged(
          reference, isInPictureInPictureMode ? 1 : 0, newConfig.reference);

  static final _onPictureInPictureModeChanged_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Fragment_onPictureInPictureModeChanged_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode)
  /// Called by the system when the activity changes to and from picture-in-picture mode. This is
  /// generally tied to Activity\#onPictureInPictureModeChanged of the containing Activity.
  ///@param isInPictureInPictureMode True if the activity is in picture-in-picture mode.
  ///@deprecated Use \#onPictureInPictureModeChanged(boolean, Configuration) instead.
  void onPictureInPictureModeChanged_1(bool isInPictureInPictureMode) =>
      _onPictureInPictureModeChanged_1(
          reference, isInPictureInPictureMode ? 1 : 0);

  static final _onConfigurationChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_onConfigurationChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onConfigurationChanged(android.content.res.Configuration newConfig)
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  void onConfigurationChanged(res.Configuration newConfig) =>
      _onConfigurationChanged(reference, newConfig.reference);

  static final _onPause =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_onPause")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onPause()
  /// Called when the Fragment is no longer resumed.  This is generally
  /// tied to Activity\#onPause() Activity.onPause of the containing
  /// Activity's lifecycle.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onPause() => _onPause(reference);

  static final _onStop =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_onStop")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onStop()
  /// Called when the Fragment is no longer started.  This is generally
  /// tied to Activity\#onStop() Activity.onStop of the containing
  /// Activity's lifecycle.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onStop() => _onStop(reference);

  static final _onLowMemory =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_onLowMemory")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onLowMemory()
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  void onLowMemory() => _onLowMemory(reference);

  static final _onTrimMemory = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Fragment_onTrimMemory")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onTrimMemory(int level)
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  void onTrimMemory(int level) => _onTrimMemory(reference, level);

  static final _onDestroyView =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_onDestroyView")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDestroyView()
  /// Called when the view previously created by \#onCreateView has
  /// been detached from the fragment.  The next time the fragment needs
  /// to be displayed, a new view will be created.  This is called
  /// after \#onStop() and before \#onDestroy().  It is called
  /// _regardless_ of whether \#onCreateView returned a
  /// non-null view.  Internally it is called after the view's state has
  /// been saved but before it has been removed from its parent.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onDestroyView() => _onDestroyView(reference);

  static final _onDestroy =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_onDestroy")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDestroy()
  /// Called when the fragment is no longer in use.  This is called
  /// after \#onStop() and before \#onDetach().
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onDestroy() => _onDestroy(reference);

  static final _onDetach =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_onDetach")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDetach()
  /// Called when the fragment is no longer attached to its activity.  This is called after
  /// \#onDestroy(), except in the cases where the fragment instance is retained across
  /// Activity re-creation (see \#setRetainInstance(boolean)), in which case it is called
  /// after \#onStop().
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onDetach() => _onDetach(reference);

  static final _onCreateOptionsMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_onCreateOptionsMenu")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreateOptionsMenu(android.view.Menu menu, android.view.MenuInflater inflater)
  /// Initialize the contents of the Activity's standard options menu.  You
  /// should place your menu items in to <var>menu</var>.  For this method
  /// to be called, you must have first called \#setHasOptionsMenu.  See
  /// Activity\#onCreateOptionsMenu(Menu) Activity.onCreateOptionsMenu
  /// for more information.
  ///@param menu The options menu in which you place your items.
  ///@see \#setHasOptionsMenu
  ///@see \#onPrepareOptionsMenu
  ///@see \#onOptionsItemSelected
  void onCreateOptionsMenu(jni.JlObject menu, jni.JlObject inflater) =>
      _onCreateOptionsMenu(reference, menu.reference, inflater.reference);

  static final _onPrepareOptionsMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_onPrepareOptionsMenu")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPrepareOptionsMenu(android.view.Menu menu)
  /// Prepare the Screen's standard options menu to be displayed.  This is
  /// called right before the menu is shown, every time it is shown.  You can
  /// use this method to efficiently enable/disable items or otherwise
  /// dynamically modify the contents.  See
  /// Activity\#onPrepareOptionsMenu(Menu) Activity.onPrepareOptionsMenu
  /// for more information.
  ///@param menu The options menu as last shown or first initialized by
  ///             onCreateOptionsMenu().
  ///@see \#setHasOptionsMenu
  ///@see \#onCreateOptionsMenu
  void onPrepareOptionsMenu(jni.JlObject menu) =>
      _onPrepareOptionsMenu(reference, menu.reference);

  static final _onDestroyOptionsMenu =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_onDestroyOptionsMenu")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDestroyOptionsMenu()
  /// Called when this fragment's option menu items are no longer being
  /// included in the overall options menu.  Receiving this call means that
  /// the menu needed to be rebuilt, but this fragment's items were not
  /// included in the newly built menu (its \#onCreateOptionsMenu(Menu, MenuInflater)
  /// was not called).
  void onDestroyOptionsMenu() => _onDestroyOptionsMenu(reference);

  static final _onOptionsItemSelected = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_onOptionsItemSelected")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onOptionsItemSelected(android.view.MenuItem item)
  /// This hook is called whenever an item in your options menu is selected.
  /// The default implementation simply returns false to have the normal
  /// processing happen (calling the item's Runnable or sending a message to
  /// its Handler as appropriate).  You can use this method for any items
  /// for which you would like to do processing without those other
  /// facilities.
  ///
  /// Derived classes should call through to the base class for it to
  /// perform the default menu handling.
  ///@param item The menu item that was selected.
  ///@return boolean Return false to allow normal menu processing to
  ///         proceed, true to consume it here.
  ///@see \#onCreateOptionsMenu
  bool onOptionsItemSelected(jni.JlObject item) =>
      _onOptionsItemSelected(reference, item.reference) != 0;

  static final _onOptionsMenuClosed = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_onOptionsMenuClosed")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onOptionsMenuClosed(android.view.Menu menu)
  /// This hook is called whenever the options menu is being closed (either by the user canceling
  /// the menu with the back/menu button, or when an item is selected).
  ///@param menu The options menu as last shown or first initialized by
  ///             onCreateOptionsMenu().
  void onOptionsMenuClosed(jni.JlObject menu) =>
      _onOptionsMenuClosed(reference, menu.reference);

  static final _onCreateContextMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_onCreateContextMenu")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreateContextMenu(android.view.ContextMenu menu, android.view.View v, android.view.ContextMenu.ContextMenuInfo menuInfo)
  /// Called when a context menu for the {@code view} is about to be shown.
  /// Unlike \#onCreateOptionsMenu, this will be called every
  /// time the context menu is about to be shown and should be populated for
  /// the view (or item inside the view for AdapterView subclasses,
  /// this can be found in the {@code menuInfo})).
  ///
  /// Use \#onContextItemSelected(android.view.MenuItem) to know when an
  /// item has been selected.
  ///
  /// The default implementation calls up to
  /// Activity\#onCreateContextMenu Activity.onCreateContextMenu, though
  /// you can not call this implementation if you don't want that behavior.
  ///
  /// It is not safe to hold onto the context menu after this method returns.
  /// {@inheritDoc}
  void onCreateContextMenu(
          jni.JlObject menu, jni.JlObject v, jni.JlObject menuInfo) =>
      _onCreateContextMenu(
          reference, menu.reference, v.reference, menuInfo.reference);

  static final _registerForContextMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_registerForContextMenu")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerForContextMenu(android.view.View view)
  /// Registers a context menu to be shown for the given view (multiple views
  /// can show the context menu). This method will set the
  /// OnCreateContextMenuListener on the view to this fragment, so
  /// \#onCreateContextMenu(ContextMenu, View, ContextMenuInfo) will be
  /// called when it is time to show the context menu.
  ///@see \#unregisterForContextMenu(View)
  ///@param view The view that should show a context menu.
  void registerForContextMenu(jni.JlObject view) =>
      _registerForContextMenu(reference, view.reference);

  static final _unregisterForContextMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_unregisterForContextMenu")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterForContextMenu(android.view.View view)
  /// Prevents a context menu to be shown for the given view. This method will
  /// remove the OnCreateContextMenuListener on the view.
  ///@see \#registerForContextMenu(View)
  ///@param view The view that should stop showing a context menu.
  void unregisterForContextMenu(jni.JlObject view) =>
      _unregisterForContextMenu(reference, view.reference);

  static final _onContextItemSelected = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_onContextItemSelected")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onContextItemSelected(android.view.MenuItem item)
  /// This hook is called whenever an item in a context menu is selected. The
  /// default implementation simply returns false to have the normal processing
  /// happen (calling the item's Runnable or sending a message to its Handler
  /// as appropriate). You can use this method for any items for which you
  /// would like to do processing without those other facilities.
  ///
  /// Use MenuItem\#getMenuInfo() to get extra information set by the
  /// View that added this menu item.
  ///
  /// Derived classes should call through to the base class for it to perform
  /// the default menu handling.
  ///@param item The context menu item that was selected.
  ///@return boolean Return false to allow normal context menu processing to
  ///         proceed, true to consume it here.
  bool onContextItemSelected(jni.JlObject item) =>
      _onContextItemSelected(reference, item.reference) != 0;

  static final _setEnterSharedElementCallback = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_setEnterSharedElementCallback")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setEnterSharedElementCallback(android.app.SharedElementCallback callback)
  /// When custom transitions are used with Fragments, the enter transition callback
  /// is called when this Fragment is attached or detached when not popping the back stack.
  ///@param callback Used to manipulate the shared element transitions on this Fragment
  ///                 when added not as a pop from the back stack.
  void setEnterSharedElementCallback(SharedElementCallback callback) =>
      _setEnterSharedElementCallback(reference, callback.reference);

  static final _setExitSharedElementCallback = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_setExitSharedElementCallback")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExitSharedElementCallback(android.app.SharedElementCallback callback)
  /// When custom transitions are used with Fragments, the exit transition callback
  /// is called when this Fragment is attached or detached when popping the back stack.
  ///@param callback Used to manipulate the shared element transitions on this Fragment
  ///                 when added as a pop from the back stack.
  void setExitSharedElementCallback(SharedElementCallback callback) =>
      _setExitSharedElementCallback(reference, callback.reference);

  static final _setEnterTransition = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_setEnterTransition")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setEnterTransition(android.transition.Transition transition)
  /// Sets the Transition that will be used to move Views into the initial scene. The entering
  /// Views will be those that are regular Views or ViewGroups that have
  /// ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as entering is governed by changing visibility from
  /// View\#INVISIBLE to View\#VISIBLE. If <code>transition</code> is null,
  /// entering Views will remain unaffected.
  ///@param transition The Transition to use to move Views into the initial Scene.
  ///@attr ref android.R.styleable\#Fragment_fragmentEnterTransition
  void setEnterTransition(jni.JlObject transition) =>
      _setEnterTransition(reference, transition.reference);

  static final _getEnterTransition = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_getEnterTransition")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.transition.Transition getEnterTransition()
  /// Returns the Transition that will be used to move Views into the initial scene. The entering
  /// Views will be those that are regular Views or ViewGroups that have
  /// ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as entering is governed by changing visibility from
  /// View\#INVISIBLE to View\#VISIBLE.
  ///@return the Transition to use to move Views into the initial Scene.
  ///@attr ref android.R.styleable\#Fragment_fragmentEnterTransition
  jni.JlObject getEnterTransition() =>
      jni.JlObject.fromRef(_getEnterTransition(reference));

  static final _setReturnTransition = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_setReturnTransition")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setReturnTransition(android.transition.Transition transition)
  /// Sets the Transition that will be used to move Views out of the scene when the Fragment is
  /// preparing to be removed, hidden, or detached because of popping the back stack. The exiting
  /// Views will be those that are regular Views or ViewGroups that have
  /// ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as entering is governed by changing visibility from
  /// View\#VISIBLE to View\#INVISIBLE. If <code>transition</code> is null,
  /// entering Views will remain unaffected. If nothing is set, the default will be to
  /// use the same value as set in \#setEnterTransition(android.transition.Transition).
  ///@param transition The Transition to use to move Views out of the Scene when the Fragment
  ///                   is preparing to close.
  ///@attr ref android.R.styleable\#Fragment_fragmentExitTransition
  void setReturnTransition(jni.JlObject transition) =>
      _setReturnTransition(reference, transition.reference);

  static final _getReturnTransition = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_getReturnTransition")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.transition.Transition getReturnTransition()
  /// Returns the Transition that will be used to move Views out of the scene when the Fragment is
  /// preparing to be removed, hidden, or detached because of popping the back stack. The exiting
  /// Views will be those that are regular Views or ViewGroups that have
  /// ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as entering is governed by changing visibility from
  /// View\#VISIBLE to View\#INVISIBLE. If <code>transition</code> is null,
  /// entering Views will remain unaffected.
  ///@return the Transition to use to move Views out of the Scene when the Fragment
  ///         is preparing to close.
  ///@attr ref android.R.styleable\#Fragment_fragmentExitTransition
  jni.JlObject getReturnTransition() =>
      jni.JlObject.fromRef(_getReturnTransition(reference));

  static final _setExitTransition = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_setExitTransition")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExitTransition(android.transition.Transition transition)
  /// Sets the Transition that will be used to move Views out of the scene when the
  /// fragment is removed, hidden, or detached when not popping the back stack.
  /// The exiting Views will be those that are regular Views or ViewGroups that
  /// have ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as exiting is governed by changing visibility
  /// from View\#VISIBLE to View\#INVISIBLE. If transition is null, the views will
  /// remain unaffected.
  ///@param transition The Transition to use to move Views out of the Scene when the Fragment
  ///                   is being closed not due to popping the back stack.
  ///@attr ref android.R.styleable\#Fragment_fragmentExitTransition
  void setExitTransition(jni.JlObject transition) =>
      _setExitTransition(reference, transition.reference);

  static final _getExitTransition = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_getExitTransition")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.transition.Transition getExitTransition()
  /// Returns the Transition that will be used to move Views out of the scene when the
  /// fragment is removed, hidden, or detached when not popping the back stack.
  /// The exiting Views will be those that are regular Views or ViewGroups that
  /// have ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as exiting is governed by changing visibility
  /// from View\#VISIBLE to View\#INVISIBLE. If transition is null, the views will
  /// remain unaffected.
  ///@return the Transition to use to move Views out of the Scene when the Fragment
  ///         is being closed not due to popping the back stack.
  ///@attr ref android.R.styleable\#Fragment_fragmentExitTransition
  jni.JlObject getExitTransition() =>
      jni.JlObject.fromRef(_getExitTransition(reference));

  static final _setReenterTransition = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_setReenterTransition")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setReenterTransition(android.transition.Transition transition)
  /// Sets the Transition that will be used to move Views in to the scene when returning due
  /// to popping a back stack. The entering Views will be those that are regular Views
  /// or ViewGroups that have ViewGroup\#isTransitionGroup return true. Typical Transitions
  /// will extend android.transition.Visibility as exiting is governed by changing
  /// visibility from View\#VISIBLE to View\#INVISIBLE. If transition is null,
  /// the views will remain unaffected. If nothing is set, the default will be to use the same
  /// transition as \#setExitTransition(android.transition.Transition).
  ///@param transition The Transition to use to move Views into the scene when reentering from a
  ///                   previously-started Activity.
  ///@attr ref android.R.styleable\#Fragment_fragmentReenterTransition
  void setReenterTransition(jni.JlObject transition) =>
      _setReenterTransition(reference, transition.reference);

  static final _getReenterTransition = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_getReenterTransition")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.transition.Transition getReenterTransition()
  /// Returns the Transition that will be used to move Views in to the scene when returning due
  /// to popping a back stack. The entering Views will be those that are regular Views
  /// or ViewGroups that have ViewGroup\#isTransitionGroup return true. Typical Transitions
  /// will extend android.transition.Visibility as exiting is governed by changing
  /// visibility from View\#VISIBLE to View\#INVISIBLE. If transition is null,
  /// the views will remain unaffected. If nothing is set, the default will be to use the same
  /// transition as \#setExitTransition(android.transition.Transition).
  ///@return the Transition to use to move Views into the scene when reentering from a
  ///                   previously-started Activity.
  ///@attr ref android.R.styleable\#Fragment_fragmentReenterTransition
  jni.JlObject getReenterTransition() =>
      jni.JlObject.fromRef(_getReenterTransition(reference));

  static final _setSharedElementEnterTransition = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_setSharedElementEnterTransition")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setSharedElementEnterTransition(android.transition.Transition transition)
  /// Sets the Transition that will be used for shared elements transferred into the content
  /// Scene. Typical Transitions will affect size and location, such as
  /// android.transition.ChangeBounds. A null
  /// value will cause transferred shared elements to blink to the final position.
  ///@param transition The Transition to use for shared elements transferred into the content
  ///                   Scene.
  ///@attr ref android.R.styleable\#Fragment_fragmentSharedElementEnterTransition
  void setSharedElementEnterTransition(jni.JlObject transition) =>
      _setSharedElementEnterTransition(reference, transition.reference);

  static final _getSharedElementEnterTransition = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_getSharedElementEnterTransition")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.transition.Transition getSharedElementEnterTransition()
  /// Returns the Transition that will be used for shared elements transferred into the content
  /// Scene. Typical Transitions will affect size and location, such as
  /// android.transition.ChangeBounds. A null
  /// value will cause transferred shared elements to blink to the final position.
  ///@return The Transition to use for shared elements transferred into the content
  ///                   Scene.
  ///@attr ref android.R.styleable\#Fragment_fragmentSharedElementEnterTransition
  jni.JlObject getSharedElementEnterTransition() =>
      jni.JlObject.fromRef(_getSharedElementEnterTransition(reference));

  static final _setSharedElementReturnTransition = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_setSharedElementReturnTransition")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setSharedElementReturnTransition(android.transition.Transition transition)
  /// Sets the Transition that will be used for shared elements transferred back during a
  /// pop of the back stack. This Transition acts in the leaving Fragment.
  /// Typical Transitions will affect size and location, such as
  /// android.transition.ChangeBounds. A null
  /// value will cause transferred shared elements to blink to the final position.
  /// If no value is set, the default will be to use the same value as
  /// \#setSharedElementEnterTransition(android.transition.Transition).
  ///@param transition The Transition to use for shared elements transferred out of the content
  ///                   Scene.
  ///@attr ref android.R.styleable\#Fragment_fragmentSharedElementReturnTransition
  void setSharedElementReturnTransition(jni.JlObject transition) =>
      _setSharedElementReturnTransition(reference, transition.reference);

  static final _getSharedElementReturnTransition = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment_getSharedElementReturnTransition")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.transition.Transition getSharedElementReturnTransition()
  /// Return the Transition that will be used for shared elements transferred back during a
  /// pop of the back stack. This Transition acts in the leaving Fragment.
  /// Typical Transitions will affect size and location, such as
  /// android.transition.ChangeBounds. A null
  /// value will cause transferred shared elements to blink to the final position.
  /// If no value is set, the default will be to use the same value as
  /// \#setSharedElementEnterTransition(android.transition.Transition).
  ///@return The Transition to use for shared elements transferred out of the content
  ///                   Scene.
  ///@attr ref android.R.styleable\#Fragment_fragmentSharedElementReturnTransition
  jni.JlObject getSharedElementReturnTransition() =>
      jni.JlObject.fromRef(_getSharedElementReturnTransition(reference));

  static final _setAllowEnterTransitionOverlap = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Fragment_setAllowEnterTransitionOverlap")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setAllowEnterTransitionOverlap(boolean allow)
  /// Sets whether the the exit transition and enter transition overlap or not.
  /// When true, the enter transition will start as soon as possible. When false, the
  /// enter transition will wait until the exit transition completes before starting.
  ///@param allow true to start the enter transition when possible or false to
  ///              wait until the exiting transition completes.
  ///@attr ref android.R.styleable\#Fragment_fragmentAllowEnterTransitionOverlap
  void setAllowEnterTransitionOverlap(bool allow) =>
      _setAllowEnterTransitionOverlap(reference, allow ? 1 : 0);

  static final _getAllowEnterTransitionOverlap =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_getAllowEnterTransitionOverlap")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getAllowEnterTransitionOverlap()
  /// Returns whether the the exit transition and enter transition overlap or not.
  /// When true, the enter transition will start as soon as possible. When false, the
  /// enter transition will wait until the exit transition completes before starting.
  ///@return true when the enter transition should start as soon as possible or false to
  /// when it should wait until the exiting transition completes.
  ///@attr ref android.R.styleable\#Fragment_fragmentAllowEnterTransitionOverlap
  bool getAllowEnterTransitionOverlap() =>
      _getAllowEnterTransitionOverlap(reference) != 0;

  static final _setAllowReturnTransitionOverlap = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Fragment_setAllowReturnTransitionOverlap")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setAllowReturnTransitionOverlap(boolean allow)
  /// Sets whether the the return transition and reenter transition overlap or not.
  /// When true, the reenter transition will start as soon as possible. When false, the
  /// reenter transition will wait until the return transition completes before starting.
  ///@param allow true to start the reenter transition when possible or false to wait until the
  ///              return transition completes.
  ///@attr ref android.R.styleable\#Fragment_fragmentAllowReturnTransitionOverlap
  void setAllowReturnTransitionOverlap(bool allow) =>
      _setAllowReturnTransitionOverlap(reference, allow ? 1 : 0);

  static final _getAllowReturnTransitionOverlap =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_getAllowReturnTransitionOverlap")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getAllowReturnTransitionOverlap()
  /// Returns whether the the return transition and reenter transition overlap or not.
  /// When true, the reenter transition will start as soon as possible. When false, the
  /// reenter transition will wait until the return transition completes before starting.
  ///@return true to start the reenter transition when possible or false to wait until the
  ///         return transition completes.
  ///@attr ref android.R.styleable\#Fragment_fragmentAllowReturnTransitionOverlap
  bool getAllowReturnTransitionOverlap() =>
      _getAllowReturnTransitionOverlap(reference) != 0;

  static final _postponeEnterTransition =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_postponeEnterTransition")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void postponeEnterTransition()
  /// Postpone the entering Fragment transition until \#startPostponedEnterTransition()
  /// or FragmentManager\#executePendingTransactions() has been called.
  ///
  /// This method gives the Fragment the ability to delay Fragment animations
  /// until all data is loaded. Until then, the added, shown, and
  /// attached Fragments will be INVISIBLE and removed, hidden, and detached Fragments won't
  /// be have their Views removed. The transaction runs when all postponed added Fragments in the
  /// transaction have called \#startPostponedEnterTransition().
  ///
  /// This method should be called before being added to the FragmentTransaction or
  /// in \#onCreate(Bundle), \#onAttach(Context), or
  /// \#onCreateView(LayoutInflater, ViewGroup, Bundle)}.
  /// \#startPostponedEnterTransition() must be called to allow the Fragment to
  /// start the transitions.
  ///
  /// When a FragmentTransaction is started that may affect a postponed FragmentTransaction,
  /// based on which containers are in their operations, the postponed FragmentTransaction
  /// will have its start triggered. The early triggering may result in faulty or nonexistent
  /// animations in the postponed transaction. FragmentTransactions that operate only on
  /// independent containers will not interfere with each other's postponement.
  ///
  /// Calling postponeEnterTransition on Fragments with a null View will not postpone the
  /// transition. Likewise, postponement only works if FragmentTransaction optimizations are
  /// enabled.
  ///@see Activity\#postponeEnterTransition()
  ///@see FragmentTransaction\#setReorderingAllowed(boolean)
  void postponeEnterTransition() => _postponeEnterTransition(reference);

  static final _startPostponedEnterTransition =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment_startPostponedEnterTransition")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void startPostponedEnterTransition()
  /// Begin postponed transitions after \#postponeEnterTransition() was called.
  /// If postponeEnterTransition() was called, you must call startPostponedEnterTransition()
  /// or FragmentManager\#executePendingTransactions() to complete the FragmentTransaction.
  /// If postponement was interrupted with FragmentManager\#executePendingTransactions(),
  /// before {@code startPostponedEnterTransition()}, animations may not run or may execute
  /// improperly.
  ///@see Activity\#startPostponedEnterTransition()
  void startPostponedEnterTransition() =>
      _startPostponedEnterTransition(reference);

  static final _dump = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Fragment_dump")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  /// Print the Fragments's state into the given stream.
  ///@param prefix Text to print at the front of each line.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer The PrintWriter to which you should dump your state.  This will be
  /// closed for you after you return.
  ///@param args additional arguments to the dump request.
  void dump(jni.JlString prefix, jni.JlObject fd, jni.JlObject writer,
          jni.JlObject args) =>
      _dump(reference, prefix.reference, fd.reference, writer.reference,
          args.reference);
}

/// State information that has been retrieved from a fragment instance
/// through FragmentManager\#saveFragmentInstanceState(Fragment) FragmentManager.saveFragmentInstanceState.
///@deprecated Use android.support.v4.app.Fragment.SavedState
class Fragment_SavedState extends jni.JlObject {
  Fragment_SavedState.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.ClassLoaderCreator<android.app.Fragment.SavedState> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_Fragment__SavedState_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_ClassLoaderCreator get CREATOR =>
      os.Parcelable_ClassLoaderCreator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment__SavedState_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Bundle state)
  Fragment_SavedState(os.Bundle state) : super.fromRef(_ctor(state.reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Fragment__SavedState_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Fragment__SavedState_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);
}

/// Thrown by Fragment\#instantiate(Context, String, Bundle) when
/// there is an instantiation failure.
///@deprecated Use android.support.v4.app.Fragment.InstantiationException
class Fragment_InstantiationException extends jni.JlObject {
  Fragment_InstantiationException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Fragment__InstantiationException_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String msg, java.lang.Exception cause)
  Fragment_InstantiationException(jni.JlString msg, jni.JlObject cause)
      : super.fromRef(_ctor(msg.reference, cause.reference));
}

/// A subclass of Dialog that can display one, two or three buttons. If you only want to
/// display a String in this dialog box, use the setMessage() method.  If you
/// want to display a more complex view, look up the FrameLayout called "custom"
/// and add your view to it:
///
/// <pre>
/// FrameLayout fl = findViewById(android.R.id.custom);
/// fl.addView(myView, new LayoutParams(MATCH_PARENT, WRAP_CONTENT));
/// </pre>
///
/// The AlertDialog class takes care of automatically setting
/// android.view.WindowManager.LayoutParams\#FLAG_ALT_FOCUSABLE_IM WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM for you based on whether
/// any views in the dialog return true from View\#onCheckIsTextEditor() View.onCheckIsTextEditor().  Generally you want this set for a Dialog
/// without text editors, so that it will be placed on top of the current
/// input method UI.  You can modify this behavior by forcing the flag to your
/// desired mode after calling \#onCreate.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about creating dialogs, read the
/// <a href="{@docRoot}guide/topics/ui/dialogs.html">Dialogs</a> developer guide.
///
/// </div>
class AlertDialog extends Dialog {
  AlertDialog.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int THEME_DEVICE_DEFAULT_DARK
  /// Special theme constant for \#AlertDialog(Context, int): use
  /// the device's default alert theme with a dark background.
  ///@deprecated Use android.R.style\#Theme_DeviceDefault_Dialog_Alert.
  static const THEME_DEVICE_DEFAULT_DARK = 4;

  /// from: static public final int THEME_DEVICE_DEFAULT_LIGHT
  /// Special theme constant for \#AlertDialog(Context, int): use
  /// the device's default alert theme with a light background.
  ///@deprecated Use android.R.style\#Theme_DeviceDefault_Light_Dialog_Alert.
  static const THEME_DEVICE_DEFAULT_LIGHT = 5;

  /// from: static public final int THEME_HOLO_DARK
  /// Special theme constant for \#AlertDialog(Context, int): use
  /// the holographic alert theme with a dark background.
  ///@deprecated Use android.R.style\#Theme_Material_Dialog_Alert.
  static const THEME_HOLO_DARK = 2;

  /// from: static public final int THEME_HOLO_LIGHT
  /// Special theme constant for \#AlertDialog(Context, int): use
  /// the holographic alert theme with a light background.
  ///@deprecated Use android.R.style\#Theme_Material_Light_Dialog_Alert.
  static const THEME_HOLO_LIGHT = 3;

  /// from: static public final int THEME_TRADITIONAL
  /// Special theme constant for \#AlertDialog(Context, int): use
  /// the traditional (pre-Holo) alert dialog theme.
  ///@deprecated Use android.R.style\#Theme_Material_Dialog_Alert.
  static const THEME_TRADITIONAL = 1;

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_AlertDialog_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void <init>(android.content.Context context)
  /// Creates an alert dialog that uses the default alert dialog theme.
  ///
  /// The default alert dialog theme is defined by
  /// android.R.attr\#alertDialogTheme within the parent
  /// {@code context}'s theme.
  ///@param context the parent context
  ///@see android.R.styleable\#Theme_alertDialogTheme
  AlertDialog(content.Context context)
      : super.fromRef(_ctor(context.reference));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                  ffi.Pointer<ffi.Void>)>>("android_app_AlertDialog_new_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: protected void <init>(android.content.Context context, boolean cancelable, android.content.DialogInterface.OnCancelListener cancelListener)
  /// Creates an alert dialog that uses the default alert dialog theme and a
  /// custom cancel listener.
  ///
  /// This is functionally identical to:
  /// <pre>
  ///     AlertDialog dialog = new AlertDialog(context);
  ///     alertDialog.setCancelable(cancelable);
  ///     alertDialog.setOnCancelListener(cancelListener);
  /// </pre>
  ///
  /// The default alert dialog theme is defined by
  /// android.R.attr\#alertDialogTheme within the parent
  /// {@code context}'s theme.
  ///@param context the parent context
  ///@see android.R.styleable\#Theme_alertDialogTheme
  AlertDialog.ctor_1(content.Context context, bool cancelable,
      content.DialogInterface_OnCancelListener cancelListener)
      : super.fromRef(_ctor_1(
            context.reference, cancelable ? 1 : 0, cancelListener.reference));

  static final _ctor_2 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_AlertDialog_new_2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: protected void <init>(android.content.Context context, int themeResId)
  /// Creates an alert dialog that uses an explicit theme resource.
  ///
  /// The specified theme resource ({@code themeResId}) is applied on top of
  /// the parent {@code context}'s theme. It may be specified as a style
  /// resource containing a fully-populated theme, such as
  /// android.R.style\#Theme_Material_Dialog, to replace all attributes
  /// in the parent {@code context}'s theme including primary and accent
  /// colors.
  ///
  /// To preserve attributes such as primary and accent colors, the
  /// {@code themeResId} may instead be specified as an overlay theme such as
  /// android.R.style\#ThemeOverlay_Material_Dialog. This will override
  /// only the window attributes necessary to style the alert window as a
  /// dialog.
  ///
  /// Alternatively, the {@code themeResId} may be specified as {@code 0} to
  /// use the parent {@code context}'s resolved value for
  /// android.R.attr\#alertDialogTheme.
  ///@param context the parent context
  ///@param themeResId the resource ID of the theme against which to inflate
  ///                   this dialog, or {@code 0} to use the parent
  ///                   {@code context}'s default alert dialog theme
  ///@see android.R.styleable\#Theme_alertDialogTheme
  AlertDialog.ctor_2(content.Context context, int themeResId)
      : super.fromRef(_ctor_2(context.reference, themeResId));

  static final _getButton = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_AlertDialog_getButton")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.widget.Button getButton(int whichButton)
  /// Gets one of the buttons used in the dialog. Returns null if the specified
  /// button does not exist or the dialog has not yet been fully created (for
  /// example, via \#show() or \#create()).
  ///@param whichButton The identifier of the button that should be returned.
  ///            For example, this can be
  ///            DialogInterface\#BUTTON_POSITIVE.
  ///@return The button from the dialog, or null if a button does not exist.
  jni.JlObject getButton(int whichButton) =>
      jni.JlObject.fromRef(_getButton(reference, whichButton));

  static final _getListView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog_getListView")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.ListView getListView()
  /// Gets the list view used in the dialog.
  ///@return The ListView from the dialog.
  jni.JlObject getListView() => jni.JlObject.fromRef(_getListView(reference));

  static final _setTitle = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_AlertDialog_setTitle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTitle(java.lang.CharSequence title)
  void setTitle(jni.JlObject title) => _setTitle(reference, title.reference);

  static final _setCustomTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog_setCustomTitle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setCustomTitle(android.view.View customTitleView)
  /// @see Builder\#setCustomTitle(View)
  void setCustomTitle(jni.JlObject customTitleView) =>
      _setCustomTitle(reference, customTitleView.reference);

  static final _setMessage = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_AlertDialog_setMessage")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setMessage(java.lang.CharSequence message)
  void setMessage(jni.JlObject message) =>
      _setMessage(reference, message.reference);

  static final _setView = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_AlertDialog_setView")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setView(android.view.View view)
  /// Set the view to display in that dialog.
  void setView(jni.JlObject view) => _setView(reference, view.reference);

  static final _setView_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("android_app_AlertDialog_setView_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int,
              int, int)>();

  /// from: public void setView(android.view.View view, int viewSpacingLeft, int viewSpacingTop, int viewSpacingRight, int viewSpacingBottom)
  /// Set the view to display in that dialog, specifying the spacing to appear around that
  /// view.
  ///@param view The view to show in the content area of the dialog
  ///@param viewSpacingLeft Extra space to appear to the left of {@code view}
  ///@param viewSpacingTop Extra space to appear above {@code view}
  ///@param viewSpacingRight Extra space to appear to the right of {@code view}
  ///@param viewSpacingBottom Extra space to appear below {@code view}
  void setView_1(jni.JlObject view, int viewSpacingLeft, int viewSpacingTop,
          int viewSpacingRight, int viewSpacingBottom) =>
      _setView_1(reference, view.reference, viewSpacingLeft, viewSpacingTop,
          viewSpacingRight, viewSpacingBottom);

  static final _setButton = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_AlertDialog_setButton")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setButton(int whichButton, java.lang.CharSequence text, android.os.Message msg)
  /// Set a message to be sent when a button is pressed.
  ///@param whichButton Which button to set the message for, can be one of
  ///            DialogInterface\#BUTTON_POSITIVE,
  ///            DialogInterface\#BUTTON_NEGATIVE, or
  ///            DialogInterface\#BUTTON_NEUTRAL
  ///@param text The text to display in positive button.
  ///@param msg The Message to be sent when clicked.
  void setButton(int whichButton, jni.JlObject text, os.Message msg) =>
      _setButton(reference, whichButton, text.reference, msg.reference);

  static final _setButton_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog_setButton_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setButton(int whichButton, java.lang.CharSequence text, android.content.DialogInterface.OnClickListener listener)
  /// Set a listener to be invoked when the positive button of the dialog is pressed.
  ///@param whichButton Which button to set the listener on, can be one of
  ///            DialogInterface\#BUTTON_POSITIVE,
  ///            DialogInterface\#BUTTON_NEGATIVE, or
  ///            DialogInterface\#BUTTON_NEUTRAL
  ///@param text The text to display in positive button.
  ///@param listener The DialogInterface.OnClickListener to use.
  void setButton_1(int whichButton, jni.JlObject text,
          content.DialogInterface_OnClickListener listener) =>
      _setButton_1(reference, whichButton, text.reference, listener.reference);

  static final _setButton_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog_setButton_2")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setButton(java.lang.CharSequence text, android.os.Message msg)
  /// @deprecated Use \#setButton(int, CharSequence, Message) with
  ///             DialogInterface\#BUTTON_POSITIVE.
  void setButton_2(jni.JlObject text, os.Message msg) =>
      _setButton_2(reference, text.reference, msg.reference);

  static final _setButton2 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_AlertDialog_setButton2")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setButton2(java.lang.CharSequence text, android.os.Message msg)
  /// @deprecated Use \#setButton(int, CharSequence, Message) with
  ///             DialogInterface\#BUTTON_NEGATIVE.
  void setButton2(jni.JlObject text, os.Message msg) =>
      _setButton2(reference, text.reference, msg.reference);

  static final _setButton3 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_AlertDialog_setButton3")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setButton3(java.lang.CharSequence text, android.os.Message msg)
  /// @deprecated Use \#setButton(int, CharSequence, Message) with
  ///             DialogInterface\#BUTTON_NEUTRAL.
  void setButton3(jni.JlObject text, os.Message msg) =>
      _setButton3(reference, text.reference, msg.reference);

  static final _setButton_3 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog_setButton_3")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setButton(java.lang.CharSequence text, android.content.DialogInterface.OnClickListener listener)
  /// Set a listener to be invoked when button 1 of the dialog is pressed.
  ///@param text The text to display in button 1.
  ///@param listener The DialogInterface.OnClickListener to use.
  ///@deprecated Use
  ///             \#setButton(int, CharSequence, android.content.DialogInterface.OnClickListener)
  ///             with DialogInterface\#BUTTON_POSITIVE
  void setButton_3(jni.JlObject text,
          content.DialogInterface_OnClickListener listener) =>
      _setButton_3(reference, text.reference, listener.reference);

  static final _setButton2_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog_setButton2_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setButton2(java.lang.CharSequence text, android.content.DialogInterface.OnClickListener listener)
  /// Set a listener to be invoked when button 2 of the dialog is pressed.
  ///@param text The text to display in button 2.
  ///@param listener The DialogInterface.OnClickListener to use.
  ///@deprecated Use
  ///             \#setButton(int, CharSequence, android.content.DialogInterface.OnClickListener)
  ///             with DialogInterface\#BUTTON_NEGATIVE
  void setButton2_1(jni.JlObject text,
          content.DialogInterface_OnClickListener listener) =>
      _setButton2_1(reference, text.reference, listener.reference);

  static final _setButton3_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog_setButton3_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setButton3(java.lang.CharSequence text, android.content.DialogInterface.OnClickListener listener)
  /// Set a listener to be invoked when button 3 of the dialog is pressed.
  ///@param text The text to display in button 3.
  ///@param listener The DialogInterface.OnClickListener to use.
  ///@deprecated Use
  ///             \#setButton(int, CharSequence, android.content.DialogInterface.OnClickListener)
  ///             with DialogInterface\#BUTTON_POSITIVE
  void setButton3_1(jni.JlObject text,
          content.DialogInterface_OnClickListener listener) =>
      _setButton3_1(reference, text.reference, listener.reference);

  static final _setIcon = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_AlertDialog_setIcon")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setIcon(int resId)
  /// Set resId to 0 if you don't want an icon.
  ///@param resId the resourceId of the drawable to use as the icon or 0
  /// if you don't want an icon.
  void setIcon(int resId) => _setIcon(reference, resId);

  static final _setIcon_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_AlertDialog_setIcon_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setIcon(android.graphics.drawable.Drawable icon)
  void setIcon_1(jni.JlObject icon) => _setIcon_1(reference, icon.reference);

  static final _setIconAttribute = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_AlertDialog_setIconAttribute")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setIconAttribute(int attrId)
  /// Set an icon as supplied by a theme attribute. e.g. android.R.attr.alertDialogIcon
  ///@param attrId ID of a theme attribute that points to a drawable resource.
  void setIconAttribute(int attrId) => _setIconAttribute(reference, attrId);

  static final _setInverseBackgroundForced = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_AlertDialog_setInverseBackgroundForced")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setInverseBackgroundForced(boolean forceInverseBackground)
  void setInverseBackgroundForced(bool forceInverseBackground) =>
      _setInverseBackgroundForced(reference, forceInverseBackground ? 1 : 0);

  static final _onCreate = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_AlertDialog_onCreate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onCreate(android.os.Bundle savedInstanceState)
  void onCreate(os.Bundle savedInstanceState) =>
      _onCreate(reference, savedInstanceState.reference);

  static final _onKeyDown = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_AlertDialog_onKeyDown")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyDown(int keyCode, android.view.KeyEvent event)
  bool onKeyDown(int keyCode, jni.JlObject event) =>
      _onKeyDown(reference, keyCode, event.reference) != 0;

  static final _onKeyUp = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_AlertDialog_onKeyUp")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyUp(int keyCode, android.view.KeyEvent event)
  bool onKeyUp(int keyCode, jni.JlObject event) =>
      _onKeyUp(reference, keyCode, event.reference) != 0;
}

class AlertDialog_Builder extends jni.JlObject {
  AlertDialog_Builder.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  /// Creates a builder for an alert dialog that uses the default alert
  /// dialog theme.
  ///
  /// The default alert dialog theme is defined by
  /// android.R.attr\#alertDialogTheme within the parent
  /// {@code context}'s theme.
  ///@param context the parent context
  AlertDialog_Builder(content.Context context)
      : super.fromRef(_ctor(context.reference));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_AlertDialog__Builder_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Context context, int themeResId)
  /// Creates a builder for an alert dialog that uses an explicit theme
  /// resource.
  ///
  /// The specified theme resource ({@code themeResId}) is applied on top
  /// of the parent {@code context}'s theme. It may be specified as a
  /// style resource containing a fully-populated theme, such as
  /// android.R.style\#Theme_Material_Dialog, to replace all
  /// attributes in the parent {@code context}'s theme including primary
  /// and accent colors.
  ///
  /// To preserve attributes such as primary and accent colors, the
  /// {@code themeResId} may instead be specified as an overlay theme such
  /// as android.R.style\#ThemeOverlay_Material_Dialog. This will
  /// override only the window attributes necessary to style the alert
  /// window as a dialog.
  ///
  /// Alternatively, the {@code themeResId} may be specified as {@code 0}
  /// to use the parent {@code context}'s resolved value for
  /// android.R.attr\#alertDialogTheme.
  ///@param context the parent context
  ///@param themeResId the resource ID of the theme against which to inflate
  ///                   this dialog, or {@code 0} to use the parent
  ///                   {@code context}'s default alert dialog theme
  AlertDialog_Builder.ctor_1(content.Context context, int themeResId)
      : super.fromRef(_ctor_1(context.reference, themeResId));

  static final _getContext = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_getContext")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context getContext()
  /// Returns a Context with the appropriate theme for dialogs created by this Builder.
  /// Applications should use this Context for obtaining LayoutInflaters for inflating views
  /// that will be used in the resulting dialogs, as it will cause views to be inflated with
  /// the correct theme.
  ///@return A Context for built Dialogs.
  content.Context getContext() =>
      content.Context.fromRef(_getContext(reference));

  static final _setTitle = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_AlertDialog__Builder_setTitle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.AlertDialog.Builder setTitle(int titleId)
  /// Set the title using the given resource id.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setTitle(int titleId) =>
      AlertDialog_Builder.fromRef(_setTitle(reference, titleId));

  static final _setTitle_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setTitle_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setTitle(java.lang.CharSequence title)
  /// Set the title displayed in the Dialog.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setTitle_1(jni.JlObject title) =>
      AlertDialog_Builder.fromRef(_setTitle_1(reference, title.reference));

  static final _setCustomTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setCustomTitle")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setCustomTitle(android.view.View customTitleView)
  /// Set the title using the custom view {@code customTitleView}.
  ///
  /// The methods \#setTitle(int) and \#setIcon(int) should
  /// be sufficient for most titles, but this is provided if the title
  /// needs more customization. Using this will replace the title and icon
  /// set via the other methods.
  ///
  /// <strong>Note:</strong> To ensure consistent styling, the custom view
  /// should be inflated or constructed using the alert dialog's themed
  /// context obtained via \#getContext().
  ///@param customTitleView the custom view to use as the title
  ///@return this Builder object to allow for chaining of calls to set
  ///         methods
  AlertDialog_Builder setCustomTitle(jni.JlObject customTitleView) =>
      AlertDialog_Builder.fromRef(
          _setCustomTitle(reference, customTitleView.reference));

  static final _setMessage = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_AlertDialog__Builder_setMessage")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.AlertDialog.Builder setMessage(int messageId)
  /// Set the message to display using the given resource id.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setMessage(int messageId) =>
      AlertDialog_Builder.fromRef(_setMessage(reference, messageId));

  static final _setMessage_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setMessage_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setMessage(java.lang.CharSequence message)
  /// Set the message to display.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setMessage_1(jni.JlObject message) =>
      AlertDialog_Builder.fromRef(_setMessage_1(reference, message.reference));

  static final _setIcon = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_AlertDialog__Builder_setIcon")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.AlertDialog.Builder setIcon(int iconId)
  /// Set the resource id of the Drawable to be used in the title.
  ///
  /// Takes precedence over values set using \#setIcon(Drawable).
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setIcon(int iconId) =>
      AlertDialog_Builder.fromRef(_setIcon(reference, iconId));

  static final _setIcon_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setIcon_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setIcon(android.graphics.drawable.Drawable icon)
  /// Set the Drawable to be used in the title.
  ///
  /// <strong>Note:</strong> To ensure consistent styling, the drawable
  /// should be inflated or constructed using the alert dialog's themed
  /// context obtained via \#getContext().
  ///@return this Builder object to allow for chaining of calls to set
  ///         methods
  AlertDialog_Builder setIcon_1(jni.JlObject icon) =>
      AlertDialog_Builder.fromRef(_setIcon_1(reference, icon.reference));

  static final _setIconAttribute = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_AlertDialog__Builder_setIconAttribute")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.AlertDialog.Builder setIconAttribute(int attrId)
  /// Set an icon as supplied by a theme attribute. e.g.
  /// android.R.attr\#alertDialogIcon.
  ///
  /// Takes precedence over values set using \#setIcon(int) or
  /// \#setIcon(Drawable).
  ///@param attrId ID of a theme attribute that points to a drawable resource.
  AlertDialog_Builder setIconAttribute(int attrId) =>
      AlertDialog_Builder.fromRef(_setIconAttribute(reference, attrId));

  static final _setPositiveButton = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setPositiveButton")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setPositiveButton(int textId, android.content.DialogInterface.OnClickListener listener)
  /// Set a listener to be invoked when the positive button of the dialog is pressed.
  ///@param textId The resource id of the text to display in the positive button
  ///@param listener The DialogInterface.OnClickListener to use.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setPositiveButton(
          int textId, content.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(
          _setPositiveButton(reference, textId, listener.reference));

  static final _setPositiveButton_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setPositiveButton_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setPositiveButton(java.lang.CharSequence text, android.content.DialogInterface.OnClickListener listener)
  /// Set a listener to be invoked when the positive button of the dialog is pressed.
  ///@param text The text to display in the positive button
  ///@param listener The DialogInterface.OnClickListener to use.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setPositiveButton_1(jni.JlObject text,
          content.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(
          _setPositiveButton_1(reference, text.reference, listener.reference));

  static final _setNegativeButton = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setNegativeButton")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setNegativeButton(int textId, android.content.DialogInterface.OnClickListener listener)
  /// Set a listener to be invoked when the negative button of the dialog is pressed.
  ///@param textId The resource id of the text to display in the negative button
  ///@param listener The DialogInterface.OnClickListener to use.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setNegativeButton(
          int textId, content.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(
          _setNegativeButton(reference, textId, listener.reference));

  static final _setNegativeButton_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setNegativeButton_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setNegativeButton(java.lang.CharSequence text, android.content.DialogInterface.OnClickListener listener)
  /// Set a listener to be invoked when the negative button of the dialog is pressed.
  ///@param text The text to display in the negative button
  ///@param listener The DialogInterface.OnClickListener to use.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setNegativeButton_1(jni.JlObject text,
          content.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(
          _setNegativeButton_1(reference, text.reference, listener.reference));

  static final _setNeutralButton = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setNeutralButton")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setNeutralButton(int textId, android.content.DialogInterface.OnClickListener listener)
  /// Set a listener to be invoked when the neutral button of the dialog is pressed.
  ///@param textId The resource id of the text to display in the neutral button
  ///@param listener The DialogInterface.OnClickListener to use.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setNeutralButton(
          int textId, content.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(
          _setNeutralButton(reference, textId, listener.reference));

  static final _setNeutralButton_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setNeutralButton_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setNeutralButton(java.lang.CharSequence text, android.content.DialogInterface.OnClickListener listener)
  /// Set a listener to be invoked when the neutral button of the dialog is pressed.
  ///@param text The text to display in the neutral button
  ///@param listener The DialogInterface.OnClickListener to use.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setNeutralButton_1(jni.JlObject text,
          content.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(
          _setNeutralButton_1(reference, text.reference, listener.reference));

  static final _setCancelable = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_AlertDialog__Builder_setCancelable")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.AlertDialog.Builder setCancelable(boolean cancelable)
  /// Sets whether the dialog is cancelable or not.  Default is true.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setCancelable(bool cancelable) =>
      AlertDialog_Builder.fromRef(
          _setCancelable(reference, cancelable ? 1 : 0));

  static final _setOnCancelListener = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setOnCancelListener")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setOnCancelListener(android.content.DialogInterface.OnCancelListener onCancelListener)
  /// Sets the callback that will be called if the dialog is canceled.
  ///
  /// Even in a cancelable dialog, the dialog may be dismissed for reasons other than
  /// being canceled or one of the supplied choices being selected.
  /// If you are interested in listening for all cases where the dialog is dismissed
  /// and not just when it is canceled, see
  /// \#setOnDismissListener(android.content.DialogInterface.OnDismissListener) setOnDismissListener.
  ///
  ///@see \#setCancelable(boolean)
  ///@see \#setOnDismissListener(android.content.DialogInterface.OnDismissListener)
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setOnCancelListener(
          content.DialogInterface_OnCancelListener onCancelListener) =>
      AlertDialog_Builder.fromRef(
          _setOnCancelListener(reference, onCancelListener.reference));

  static final _setOnDismissListener = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setOnDismissListener")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setOnDismissListener(android.content.DialogInterface.OnDismissListener onDismissListener)
  /// Sets the callback that will be called when the dialog is dismissed for any reason.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setOnDismissListener(
          content.DialogInterface_OnDismissListener onDismissListener) =>
      AlertDialog_Builder.fromRef(
          _setOnDismissListener(reference, onDismissListener.reference));

  static final _setOnKeyListener = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setOnKeyListener")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setOnKeyListener(android.content.DialogInterface.OnKeyListener onKeyListener)
  /// Sets the callback that will be called if a key is dispatched to the dialog.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setOnKeyListener(
          content.DialogInterface_OnKeyListener onKeyListener) =>
      AlertDialog_Builder.fromRef(
          _setOnKeyListener(reference, onKeyListener.reference));

  static final _setItems = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setItems")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setItems(int itemsId, android.content.DialogInterface.OnClickListener listener)
  /// Set a list of items to be displayed in the dialog as the content, you will be notified of the
  /// selected item via the supplied listener. This should be an array type i.e. R.array.foo
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setItems(
          int itemsId, content.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(
          _setItems(reference, itemsId, listener.reference));

  static final _setItems_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setItems_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setItems(java.lang.CharSequence[] items, android.content.DialogInterface.OnClickListener listener)
  /// Set a list of items to be displayed in the dialog as the content, you will be notified of the
  /// selected item via the supplied listener.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setItems_1(jni.JlObject items,
          content.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(
          _setItems_1(reference, items.reference, listener.reference));

  static final _setAdapter = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setAdapter")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setAdapter(android.widget.ListAdapter adapter, android.content.DialogInterface.OnClickListener listener)
  /// Set a list of items, which are supplied by the given ListAdapter, to be
  /// displayed in the dialog as the content, you will be notified of the
  /// selected item via the supplied listener.
  ///@param adapter The ListAdapter to supply the list of items
  ///@param listener The listener that will be called when an item is clicked.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setAdapter(jni.JlObject adapter,
          content.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(
          _setAdapter(reference, adapter.reference, listener.reference));

  static final _setCursor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setCursor")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setCursor(android.database.Cursor cursor, android.content.DialogInterface.OnClickListener listener, java.lang.String labelColumn)
  /// Set a list of items, which are supplied by the given Cursor, to be
  /// displayed in the dialog as the content, you will be notified of the
  /// selected item via the supplied listener.
  ///@param cursor The Cursor to supply the list of items
  ///@param listener The listener that will be called when an item is clicked.
  ///@param labelColumn The column name on the cursor containing the string to display
  ///          in the label.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setCursor(
          jni.JlObject cursor,
          content.DialogInterface_OnClickListener listener,
          jni.JlString labelColumn) =>
      AlertDialog_Builder.fromRef(_setCursor(reference, cursor.reference,
          listener.reference, labelColumn.reference));

  static final _setMultiChoiceItems = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setMultiChoiceItems")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setMultiChoiceItems(int itemsId, boolean[] checkedItems, android.content.DialogInterface.OnMultiChoiceClickListener listener)
  /// Set a list of items to be displayed in the dialog as the content,
  /// you will be notified of the selected item via the supplied listener.
  /// This should be an array type, e.g. R.array.foo. The list will have
  /// a check mark displayed to the right of the text for each checked
  /// item. Clicking on an item in the list will not dismiss the dialog.
  /// Clicking on a button will dismiss the dialog.
  ///@param itemsId the resource id of an array i.e. R.array.foo
  ///@param checkedItems specifies which items are checked. It should be null in which case no
  ///        items are checked. If non null it must be exactly the same length as the array of
  ///        items.
  ///@param listener notified when an item on the list is clicked. The dialog will not be
  ///        dismissed when an item is clicked. It will only be dismissed if clicked on a
  ///        button, if no buttons are supplied it's up to the user to dismiss the dialog.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setMultiChoiceItems(
          int itemsId,
          jni.JlObject checkedItems,
          content.DialogInterface_OnMultiChoiceClickListener listener) =>
      AlertDialog_Builder.fromRef(_setMultiChoiceItems(
          reference, itemsId, checkedItems.reference, listener.reference));

  static final _setMultiChoiceItems_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setMultiChoiceItems_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setMultiChoiceItems(java.lang.CharSequence[] items, boolean[] checkedItems, android.content.DialogInterface.OnMultiChoiceClickListener listener)
  /// Set a list of items to be displayed in the dialog as the content,
  /// you will be notified of the selected item via the supplied listener.
  /// The list will have a check mark displayed to the right of the text
  /// for each checked item. Clicking on an item in the list will not
  /// dismiss the dialog. Clicking on a button will dismiss the dialog.
  ///@param items the text of the items to be displayed in the list.
  ///@param checkedItems specifies which items are checked. It should be null in which case no
  ///        items are checked. If non null it must be exactly the same length as the array of
  ///        items.
  ///@param listener notified when an item on the list is clicked. The dialog will not be
  ///        dismissed when an item is clicked. It will only be dismissed if clicked on a
  ///        button, if no buttons are supplied it's up to the user to dismiss the dialog.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setMultiChoiceItems_1(
          jni.JlObject items,
          jni.JlObject checkedItems,
          content.DialogInterface_OnMultiChoiceClickListener listener) =>
      AlertDialog_Builder.fromRef(_setMultiChoiceItems_1(reference,
          items.reference, checkedItems.reference, listener.reference));

  static final _setMultiChoiceItems_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setMultiChoiceItems_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setMultiChoiceItems(android.database.Cursor cursor, java.lang.String isCheckedColumn, java.lang.String labelColumn, android.content.DialogInterface.OnMultiChoiceClickListener listener)
  /// Set a list of items to be displayed in the dialog as the content,
  /// you will be notified of the selected item via the supplied listener.
  /// The list will have a check mark displayed to the right of the text
  /// for each checked item. Clicking on an item in the list will not
  /// dismiss the dialog. Clicking on a button will dismiss the dialog.
  ///@param cursor the cursor used to provide the items.
  ///@param isCheckedColumn specifies the column name on the cursor to use to determine
  ///        whether a checkbox is checked or not. It must return an integer value where 1
  ///        means checked and 0 means unchecked.
  ///@param labelColumn The column name on the cursor containing the string to display in the
  ///        label.
  ///@param listener notified when an item on the list is clicked. The dialog will not be
  ///        dismissed when an item is clicked. It will only be dismissed if clicked on a
  ///        button, if no buttons are supplied it's up to the user to dismiss the dialog.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setMultiChoiceItems_2(
          jni.JlObject cursor,
          jni.JlString isCheckedColumn,
          jni.JlString labelColumn,
          content.DialogInterface_OnMultiChoiceClickListener listener) =>
      AlertDialog_Builder.fromRef(_setMultiChoiceItems_2(
          reference,
          cursor.reference,
          isCheckedColumn.reference,
          labelColumn.reference,
          listener.reference));

  static final _setSingleChoiceItems = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setSingleChoiceItems")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setSingleChoiceItems(int itemsId, int checkedItem, android.content.DialogInterface.OnClickListener listener)
  /// Set a list of items to be displayed in the dialog as the content, you will be notified of
  /// the selected item via the supplied listener. This should be an array type i.e.
  /// R.array.foo The list will have a check mark displayed to the right of the text for the
  /// checked item. Clicking on an item in the list will not dismiss the dialog. Clicking on a
  /// button will dismiss the dialog.
  ///@param itemsId the resource id of an array i.e. R.array.foo
  ///@param checkedItem specifies which item is checked. If -1 no items are checked.
  ///@param listener notified when an item on the list is clicked. The dialog will not be
  ///        dismissed when an item is clicked. It will only be dismissed if clicked on a
  ///        button, if no buttons are supplied it's up to the user to dismiss the dialog.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setSingleChoiceItems(int itemsId, int checkedItem,
          content.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(_setSingleChoiceItems(
          reference, itemsId, checkedItem, listener.reference));

  static final _setSingleChoiceItems_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setSingleChoiceItems_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setSingleChoiceItems(android.database.Cursor cursor, int checkedItem, java.lang.String labelColumn, android.content.DialogInterface.OnClickListener listener)
  /// Set a list of items to be displayed in the dialog as the content, you will be notified of
  /// the selected item via the supplied listener. The list will have a check mark displayed to
  /// the right of the text for the checked item. Clicking on an item in the list will not
  /// dismiss the dialog. Clicking on a button will dismiss the dialog.
  ///@param cursor the cursor to retrieve the items from.
  ///@param checkedItem specifies which item is checked. If -1 no items are checked.
  ///@param labelColumn The column name on the cursor containing the string to display in the
  ///        label.
  ///@param listener notified when an item on the list is clicked. The dialog will not be
  ///        dismissed when an item is clicked. It will only be dismissed if clicked on a
  ///        button, if no buttons are supplied it's up to the user to dismiss the dialog.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setSingleChoiceItems_1(
          jni.JlObject cursor,
          int checkedItem,
          jni.JlString labelColumn,
          content.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(_setSingleChoiceItems_1(
          reference,
          cursor.reference,
          checkedItem,
          labelColumn.reference,
          listener.reference));

  static final _setSingleChoiceItems_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setSingleChoiceItems_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setSingleChoiceItems(java.lang.CharSequence[] items, int checkedItem, android.content.DialogInterface.OnClickListener listener)
  /// Set a list of items to be displayed in the dialog as the content, you will be notified of
  /// the selected item via the supplied listener. The list will have a check mark displayed to
  /// the right of the text for the checked item. Clicking on an item in the list will not
  /// dismiss the dialog. Clicking on a button will dismiss the dialog.
  ///@param items the items to be displayed.
  ///@param checkedItem specifies which item is checked. If -1 no items are checked.
  ///@param listener notified when an item on the list is clicked. The dialog will not be
  ///        dismissed when an item is clicked. It will only be dismissed if clicked on a
  ///        button, if no buttons are supplied it's up to the user to dismiss the dialog.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setSingleChoiceItems_2(jni.JlObject items,
          int checkedItem, content.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(_setSingleChoiceItems_2(
          reference, items.reference, checkedItem, listener.reference));

  static final _setSingleChoiceItems_3 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setSingleChoiceItems_3")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setSingleChoiceItems(android.widget.ListAdapter adapter, int checkedItem, android.content.DialogInterface.OnClickListener listener)
  /// Set a list of items to be displayed in the dialog as the content, you will be notified of
  /// the selected item via the supplied listener. The list will have a check mark displayed to
  /// the right of the text for the checked item. Clicking on an item in the list will not
  /// dismiss the dialog. Clicking on a button will dismiss the dialog.
  ///@param adapter The ListAdapter to supply the list of items
  ///@param checkedItem specifies which item is checked. If -1 no items are checked.
  ///@param listener notified when an item on the list is clicked. The dialog will not be
  ///        dismissed when an item is clicked. It will only be dismissed if clicked on a
  ///        button, if no buttons are supplied it's up to the user to dismiss the dialog.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setSingleChoiceItems_3(jni.JlObject adapter,
          int checkedItem, content.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(_setSingleChoiceItems_3(
          reference, adapter.reference, checkedItem, listener.reference));

  static final _setOnItemSelectedListener = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setOnItemSelectedListener")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setOnItemSelectedListener(android.widget.AdapterView.OnItemSelectedListener listener)
  /// Sets a listener to be invoked when an item in the list is selected.
  ///@param listener the listener to be invoked
  ///@return this Builder object to allow for chaining of calls to set methods
  ///@see AdapterView\#setOnItemSelectedListener(android.widget.AdapterView.OnItemSelectedListener)
  AlertDialog_Builder setOnItemSelectedListener(jni.JlObject listener) =>
      AlertDialog_Builder.fromRef(
          _setOnItemSelectedListener(reference, listener.reference));

  static final _setView = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_AlertDialog__Builder_setView")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.AlertDialog.Builder setView(int layoutResId)
  /// Set a custom view resource to be the contents of the Dialog. The
  /// resource will be inflated, adding all top-level views to the screen.
  ///@param layoutResId Resource ID to be inflated.
  ///@return this Builder object to allow for chaining of calls to set
  ///         methods
  AlertDialog_Builder setView(int layoutResId) =>
      AlertDialog_Builder.fromRef(_setView(reference, layoutResId));

  static final _setView_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_setView_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setView(android.view.View view)
  /// Sets a custom view to be the contents of the alert dialog.
  ///
  /// When using a pre-Holo theme, if the supplied view is an instance of
  /// a ListView then the light background will be used.
  ///
  /// <strong>Note:</strong> To ensure consistent styling, the custom view
  /// should be inflated or constructed using the alert dialog's themed
  /// context obtained via \#getContext().
  ///@param view the view to use as the contents of the alert dialog
  ///@return this Builder object to allow for chaining of calls to set
  ///         methods
  AlertDialog_Builder setView_1(jni.JlObject view) =>
      AlertDialog_Builder.fromRef(_setView_1(reference, view.reference));

  static final _setInverseBackgroundForced = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_AlertDialog__Builder_setInverseBackgroundForced")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.AlertDialog.Builder setInverseBackgroundForced(boolean useInverseBackground)
  /// Sets the alert dialog to use the inverse background, regardless of
  /// what the contents is.
  ///@param useInverseBackground whether to use the inverse background
  ///@return this Builder object to allow for chaining of calls to set methods
  ///@deprecated This flag is only used for pre-Material themes. Instead,
  ///             specify the window background using on the alert dialog
  ///             theme.
  AlertDialog_Builder setInverseBackgroundForced(bool useInverseBackground) =>
      AlertDialog_Builder.fromRef(
          _setInverseBackgroundForced(reference, useInverseBackground ? 1 : 0));

  static final _create = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_create")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog create()
  /// Creates an AlertDialog with the arguments supplied to this
  /// builder.
  ///
  /// Calling this method does not display the dialog. If no additional
  /// processing is needed, \#show() may be called instead to both
  /// create and display the dialog.
  AlertDialog create() => AlertDialog.fromRef(_create(reference));

  static final _show_ = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_AlertDialog__Builder_show_")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog show()
  /// Creates an AlertDialog with the arguments supplied to this
  /// builder and immediately displays the dialog.
  ///
  /// Calling this method is functionally identical to:
  /// <pre>
  ///     AlertDialog dialog = builder.create();
  ///     dialog.show();
  /// </pre>
  AlertDialog show_() => AlertDialog.fromRef(_show_(reference));
}

/// For apps developing against android.os.Build.VERSION_CODES\#HONEYCOMB
/// or later, tabs are typically presented in the UI using the new
/// ActionBar\#newTab() ActionBar.newTab() and
/// related APIs for placing tabs within their action bar area.
///
///@deprecated New applications should use Fragments instead of this class;
/// to continue to run on older devices, you can use the v4 support library
/// which provides a version of the Fragment API that is compatible down to
/// android.os.Build.VERSION_CODES\#DONUT.
class TabActivity extends ActivityGroup {
  TabActivity.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_TabActivity_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  TabActivity() : super.fromRef(_ctor());

  static final _setDefaultTab = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_TabActivity_setDefaultTab")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setDefaultTab(java.lang.String tag)
  /// Sets the default tab that is the first tab highlighted.
  ///@param tag the name of the default tab
  void setDefaultTab(jni.JlString tag) =>
      _setDefaultTab(reference, tag.reference);

  static final _setDefaultTab_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_TabActivity_setDefaultTab_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setDefaultTab(int index)
  /// Sets the default tab that is the first tab highlighted.
  ///@param index the index of the default tab
  void setDefaultTab_1(int index) => _setDefaultTab_1(reference, index);

  static final _onRestoreInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_TabActivity_onRestoreInstanceState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onRestoreInstanceState(android.os.Bundle state)
  void onRestoreInstanceState(os.Bundle state) =>
      _onRestoreInstanceState(reference, state.reference);

  static final _onPostCreate = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_TabActivity_onPostCreate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPostCreate(android.os.Bundle icicle)
  void onPostCreate(os.Bundle icicle) =>
      _onPostCreate(reference, icicle.reference);

  static final _onSaveInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_TabActivity_onSaveInstanceState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onSaveInstanceState(android.os.Bundle outState)
  void onSaveInstanceState(os.Bundle outState) =>
      _onSaveInstanceState(reference, outState.reference);

  static final _onContentChanged =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_TabActivity_onContentChanged")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onContentChanged()
  /// Updates the screen state (current list and other views) when the
  /// content changes.
  ///@see Activity\#onContentChanged()
  void onContentChanged() => _onContentChanged(reference);

  static final _onChildTitleChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_TabActivity_onChildTitleChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void onChildTitleChanged(android.app.Activity childActivity, java.lang.CharSequence title)
  void onChildTitleChanged(Activity childActivity, jni.JlObject title) =>
      _onChildTitleChanged(reference, childActivity.reference, title.reference);

  static final _getTabHost = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_TabActivity_getTabHost")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.TabHost getTabHost()
  /// Returns the TabHost the activity is using to host its tabs.
  ///@return the TabHost the activity is using to host its tabs.
  jni.JlObject getTabHost() => jni.JlObject.fromRef(_getTabHost(reference));

  static final _getTabWidget = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_TabActivity_getTabWidget")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.TabWidget getTabWidget()
  /// Returns the TabWidget the activity is using to draw the actual tabs.
  ///@return the TabWidget the activity is using to draw the actual tabs.
  jni.JlObject getTabWidget() => jni.JlObject.fromRef(_getTabWidget(reference));
}

/// A {@code RemoteInput} object specifies input to be collected from a user to be passed along with
/// an intent inside a android.app.PendingIntent that is sent.
/// Always use RemoteInput.Builder to create instances of this class.
/// <p class="note"> See
/// <a href="{@docRoot}guide/topics/ui/notifiers/notifications.html\#direct">Replying
/// to notifications</a> for more information on how to use this class.
///
/// The following example adds a {@code RemoteInput} to a Notification.Action,
/// sets the result key as {@code quick_reply}, and sets the label as {@code Quick reply}.
/// Users are prompted to input a response when they trigger the action. The results are sent along
/// with the intent and can be retrieved with the result key (provided to the Builder
/// constructor) from the Bundle returned by \#getResultsFromIntent.
///
/// <pre class="prettyprint">
/// public static final String KEY_QUICK_REPLY_TEXT = "quick_reply";
/// Notification.Action action = new Notification.Action.Builder(
///         R.drawable.reply, &quot;Reply&quot;, actionIntent)
///         __.addRemoteInput(new RemoteInput.Builder(KEY_QUICK_REPLY_TEXT)
///                 .setLabel("Quick reply").build()__)
///         .build();</pre>
///
/// When the android.app.PendingIntent is fired, the intent inside will contain the
/// input results if collected. To access these results, use the \#getResultsFromIntent
/// function. The result values will present under the result key passed to the Builder
/// constructor.
///
/// <pre class="prettyprint">
/// public static final String KEY_QUICK_REPLY_TEXT = "quick_reply";
/// Bundle results = RemoteInput.getResultsFromIntent(intent);
/// if (results != null) {
///     CharSequence quickReplyResult = results.getCharSequence(KEY_QUICK_REPLY_TEXT);
/// }</pre>
class RemoteInput extends jni.JlObject {
  RemoteInput.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.RemoteInput> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_RemoteInput_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final java.lang.String EXTRA_RESULTS_DATA
  /// Extra added to a clip data intent object to hold the text results bundle.
  static const EXTRA_RESULTS_DATA = "android.remoteinput.resultsData";

  /// from: static public final java.lang.String RESULTS_CLIP_LABEL
  /// Label used to denote the clip data type used for remote input transport
  static const RESULTS_CLIP_LABEL = "android.remoteinput.results";

  /// from: static public final int SOURCE_CHOICE
  /// The user selected one of the choices from \#getChoices.
  static const SOURCE_CHOICE = 1;

  /// from: static public final int SOURCE_FREE_FORM_INPUT
  /// The user manually entered the data.
  static const SOURCE_FREE_FORM_INPUT = 0;

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_RemoteInput_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Parcel in)
  RemoteInput(os.Parcel in_) : super.fromRef(_ctor(in_.reference));

  static final _getResultKey = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_RemoteInput_getResultKey")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getResultKey()
  /// Get the key that the result of this input will be set in from the Bundle returned by
  /// \#getResultsFromIntent when the android.app.PendingIntent is sent.
  jni.JlString getResultKey() => jni.JlString.fromRef(_getResultKey(reference));

  static final _getLabel = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_RemoteInput_getLabel")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getLabel()
  /// Get the label to display to users when collecting this input.
  jni.JlObject getLabel() => jni.JlObject.fromRef(_getLabel(reference));

  static final _getChoices = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_RemoteInput_getChoices")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence[] getChoices()
  /// Get possible input choices. This can be {@code null} if there are no choices to present.
  jni.JlObject getChoices() => jni.JlObject.fromRef(_getChoices(reference));

  static final _getAllowedDataTypes = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_RemoteInput_getAllowedDataTypes")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Set<java.lang.String> getAllowedDataTypes()
  /// Get possible non-textual inputs that are accepted.
  /// This can be {@code null} if the input does not accept non-textual values.
  /// See Builder\#setAllowDataType.
  jni.JlObject getAllowedDataTypes() =>
      jni.JlObject.fromRef(_getAllowedDataTypes(reference));

  static final _isDataOnly =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_RemoteInput_isDataOnly")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isDataOnly()
  /// Returns true if the input only accepts data, meaning \#getAllowFreeFormInput
  /// is false, \#getChoices is null or empty, and \#getAllowedDataTypes is
  /// non-null and not empty.
  bool isDataOnly() => _isDataOnly(reference) != 0;

  static final _getAllowFreeFormInput =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_RemoteInput_getAllowFreeFormInput")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getAllowFreeFormInput()
  /// Get whether or not users can provide an arbitrary value for
  /// input. If you set this to {@code false}, users must select one of the
  /// choices in \#getChoices. An IllegalArgumentException is thrown
  /// if you set this to false and \#getChoices returns {@code null} or empty.
  bool getAllowFreeFormInput() => _getAllowFreeFormInput(reference) != 0;

  static final _getExtras = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_RemoteInput_getExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getExtras()
  /// Get additional metadata carried around with this remote input.
  os.Bundle getExtras() => os.Bundle.fromRef(_getExtras(reference));

  static final _getDataResultsFromIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_RemoteInput_getDataResultsFromIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.Map<java.lang.String,android.net.Uri> getDataResultsFromIntent(android.content.Intent intent, java.lang.String remoteInputResultKey)
  /// Similar as \#getResultsFromIntent but retrieves data results for a
  /// specific RemoteInput result. To retrieve a value use:
  /// <pre>
  /// {@code
  /// Map<String, Uri> results =
  ///     RemoteInput.getDataResultsFromIntent(intent, REMOTE_INPUT_KEY);
  /// if (results != null) {
  ///   Uri data = results.get(MIME_TYPE_OF_INTEREST);
  /// }
  /// }
  /// </pre>
  ///@param intent The intent object that fired in response to an action or content intent
  ///               which also had one or more remote input requested.
  ///@param remoteInputResultKey The result key for the RemoteInput you want results for.
  static jni.JlObject getDataResultsFromIntent(
          content.Intent intent, jni.JlString remoteInputResultKey) =>
      jni.JlObject.fromRef(_getDataResultsFromIntent(
          intent.reference, remoteInputResultKey.reference));

  static final _getResultsFromIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_RemoteInput_getResultsFromIntent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.Bundle getResultsFromIntent(android.content.Intent intent)
  /// Get the remote input text results bundle from an intent. The returned Bundle will
  /// contain a key/value for every result key populated with text by remote input collector.
  /// Use the Bundle\#getCharSequence(String) method to retrieve a value. For non-text
  /// results use \#getDataResultsFromIntent.
  ///@param intent The intent object that fired in response to an action or content intent
  ///               which also had one or more remote input requested.
  static os.Bundle getResultsFromIntent(content.Intent intent) =>
      os.Bundle.fromRef(_getResultsFromIntent(intent.reference));

  static final _addResultsToIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_RemoteInput_addResultsToIntent")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void addResultsToIntent(android.app.RemoteInput[] remoteInputs, android.content.Intent intent, android.os.Bundle results)
  /// Populate an intent object with the text results gathered from remote input. This method
  /// should only be called by remote input collection services when sending results to a
  /// pending intent.
  ///@param remoteInputs The remote inputs for which results are being provided
  ///@param intent The intent to add remote inputs to. The ClipData
  ///               field of the intent will be modified to contain the results.
  ///@param results A bundle holding the remote input results. This bundle should
  ///                be populated with keys matching the result keys specified in
  ///                {@code remoteInputs} with values being the CharSequence results per key.
  static void addResultsToIntent(jni.JlObject remoteInputs,
          content.Intent intent, os.Bundle results) =>
      _addResultsToIntent(
          remoteInputs.reference, intent.reference, results.reference);

  static final _addDataResultToIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_RemoteInput_addDataResultToIntent")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void addDataResultToIntent(android.app.RemoteInput remoteInput, android.content.Intent intent, java.util.Map<java.lang.String,android.net.Uri> results)
  /// Same as \#addResultsToIntent but for setting data results. This is used
  /// for inputs that accept non-textual results (see Builder\#setAllowDataType).
  /// Only one result can be provided for every mime type accepted by the RemoteInput.
  /// If multiple inputs of the same mime type are expected then multiple RemoteInputs
  /// should be used.
  ///@param remoteInput The remote input for which results are being provided
  ///@param intent The intent to add remote input results to. The ClipData
  ///               field of the intent will be modified to contain the results.
  ///@param results A map of mime type to the Uri result for that mime type.
  static void addDataResultToIntent(RemoteInput remoteInput,
          content.Intent intent, jni.JlObject results) =>
      _addDataResultToIntent(
          remoteInput.reference, intent.reference, results.reference);

  static final _setResultsSource = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_RemoteInput_setResultsSource")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: static public void setResultsSource(android.content.Intent intent, int source)
  /// Set the source of the RemoteInput results. This method should only be called by remote
  /// input collection services (e.g.
  /// android.service.notification.NotificationListenerService)
  /// when sending results to a pending intent.
  ///@see \#SOURCE_FREE_FORM_INPUT
  ///@see \#SOURCE_CHOICE
  ///@param intent The intent to add remote input source to. The ClipData
  ///               field of the intent will be modified to contain the source.
  ///@param source The source of the results.
  ///
  /// Value is android.app.RemoteInput\#SOURCE_FREE_FORM_INPUT, or android.app.RemoteInput\#SOURCE_CHOICE
  static void setResultsSource(content.Intent intent, int source) =>
      _setResultsSource(intent.reference, source);

  static final _getResultsSource =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_RemoteInput_getResultsSource")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public int getResultsSource(android.content.Intent intent)
  /// Get the source of the RemoteInput results.
  ///@see \#SOURCE_FREE_FORM_INPUT
  ///@see \#SOURCE_CHOICE
  ///@param intent The intent object that fired in response to an action or content intent
  ///               which also had one or more remote input requested.
  ///@return The source of the results. If no source was set, \#SOURCE_FREE_FORM_INPUT will
  /// be returned.
  ///
  /// Value is android.app.RemoteInput\#SOURCE_FREE_FORM_INPUT, or android.app.RemoteInput\#SOURCE_CHOICE
  static int getResultsSource(content.Intent intent) =>
      _getResultsSource(intent.reference);

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_RemoteInput_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_RemoteInput_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os.Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags);
}

/// Builder class for RemoteInput objects.
class RemoteInput_Builder extends jni.JlObject {
  RemoteInput_Builder.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_RemoteInput__Builder_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String resultKey)
  /// Create a builder object for RemoteInput objects.
  ///@param resultKey the Bundle key that refers to this input when collected from the user
  ///
  /// This value must never be {@code null}.
  RemoteInput_Builder(jni.JlString resultKey)
      : super.fromRef(_ctor(resultKey.reference));

  static final _setLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_RemoteInput__Builder_setLabel")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.RemoteInput.Builder setLabel(java.lang.CharSequence label)
  /// Set a label to be displayed to the user when collecting this input.
  ///@param label The label to show to users when they input a response
  /// This value may be {@code null}.
  ///@return this object for method chaining
  ///
  /// This value will never be {@code null}.
  RemoteInput_Builder setLabel(jni.JlObject label) =>
      RemoteInput_Builder.fromRef(_setLabel(reference, label.reference));

  static final _setChoices = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_RemoteInput__Builder_setChoices")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.RemoteInput.Builder setChoices(java.lang.CharSequence[] choices)
  /// Specifies choices available to the user to satisfy this input.
  ///
  /// Note: Starting in Android P, these choices will always be shown on phones if the app's
  /// target SDK is >= P. However, these choices may also be rendered on other types of devices
  /// regardless of target SDK.
  ///@param choices an array of pre-defined choices for users input.
  ///        You must provide a non-null and non-empty array if
  ///        you disabled free form input using \#setAllowFreeFormInput
  /// This value may be {@code null}.
  ///@return this object for method chaining
  RemoteInput_Builder setChoices(jni.JlObject choices) =>
      RemoteInput_Builder.fromRef(_setChoices(reference, choices.reference));

  static final _setAllowDataType = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_RemoteInput__Builder_setAllowDataType")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.RemoteInput.Builder setAllowDataType(java.lang.String mimeType, boolean doAllow)
  /// Specifies whether the user can provide arbitrary values. This allows an input
  /// to accept non-textual values. Examples of usage are an input that wants audio
  /// or an image.
  ///@param mimeType A mime type that results are allowed to come in.
  ///         Be aware that text results (see \#setAllowFreeFormInput
  ///         are allowed by default. If you do not want text results you will have to
  ///         pass false to {@code setAllowFreeFormInput}
  /// This value must never be {@code null}.
  ///@param doAllow Whether the mime type should be allowed or not
  ///@return this object for method chaining
  ///
  /// This value will never be {@code null}.
  RemoteInput_Builder setAllowDataType(jni.JlString mimeType, bool doAllow) =>
      RemoteInput_Builder.fromRef(
          _setAllowDataType(reference, mimeType.reference, doAllow ? 1 : 0));

  static final _setAllowFreeFormInput = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_RemoteInput__Builder_setAllowFreeFormInput")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.RemoteInput.Builder setAllowFreeFormInput(boolean allowFreeFormTextInput)
  /// Specifies whether the user can provide arbitrary text values.
  ///@param allowFreeFormTextInput The default is {@code true}.
  ///         If you specify {@code false}, you must either provide a non-null
  ///         and non-empty array to \#setChoices, or enable a data result
  ///         in {@code setAllowDataType}. Otherwise an
  ///         IllegalArgumentException is thrown
  ///@return this object for method chaining
  RemoteInput_Builder setAllowFreeFormInput(bool allowFreeFormTextInput) =>
      RemoteInput_Builder.fromRef(
          _setAllowFreeFormInput(reference, allowFreeFormTextInput ? 1 : 0));

  static final _addExtras = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_RemoteInput__Builder_addExtras")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.RemoteInput.Builder addExtras(android.os.Bundle extras)
  /// Merge additional metadata into this builder.
  ///
  /// Values within the Bundle will replace existing extras values in this Builder.
  ///@see RemoteInput\#getExtras
  ///@param extras This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  RemoteInput_Builder addExtras(os.Bundle extras) =>
      RemoteInput_Builder.fromRef(_addExtras(reference, extras.reference));

  static final _getExtras = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_RemoteInput__Builder_getExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getExtras()
  /// Get the metadata Bundle used by this Builder.
  ///
  /// The returned Bundle is shared with this Builder.
  ///@return This value will never be {@code null}.
  os.Bundle getExtras() => os.Bundle.fromRef(_getExtras(reference));

  static final _build = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_RemoteInput__Builder_build")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.RemoteInput build()
  /// Combine all of the options that have been set and return a new RemoteInput
  /// object.
  ///@return This value will never be {@code null}.
  RemoteInput build() => RemoteInput.fromRef(_build(reference));
}

/// A primary toolbar within the activity that may display the activity title, application-level
/// navigation affordances, and other interactive items.
///
/// Beginning with Android 3.0 (API level 11), the action bar appears at the top of an
/// activity's window when the activity uses the system's android.R.style\#Theme_Holo Holo theme (or one of its descendant themes), which is the default.
/// You may otherwise add the action bar by calling android.view.Window\#requestFeature requestFeature(FEATURE_ACTION_BAR) or by declaring it in a
/// custom theme with the android.R.styleable\#Theme_windowActionBar windowActionBar property.
///
///
///
/// Beginning with Android L (API level 21), the action bar may be represented by any
/// Toolbar widget within the application layout. The application may signal to the Activity
/// which Toolbar should be treated as the Activity's action bar. Activities that use this
/// feature should use one of the supplied <code>.NoActionBar</code> themes, set the
/// android.R.styleable\#Theme_windowActionBar windowActionBar attribute to <code>false</code>
/// or otherwise not request the window feature.
///
///
/// By adjusting the window features requested by the theme and the layouts used for
/// an Activity's content view, an app can use the standard system action bar on older platform
/// releases and the newer inline toolbars on newer platform releases. The <code>ActionBar</code>
/// object obtained from the Activity can be used to control either configuration transparently.
///
///
/// When using the Holo themes the action bar shows the application icon on
/// the left, followed by the activity title. If your activity has an options menu, you can make
/// select items accessible directly from the action bar as "action items". You can also
/// modify various characteristics of the action bar or remove it completely.
///
///
/// When using the Material themes (default in API 21 or newer) the navigation button
/// (formerly "Home") takes over the space previously occupied by the application icon.
/// Apps wishing to express a stronger branding should use their brand colors heavily
/// in the action bar and other application chrome or use a \#setLogo(int) logo
/// in place of their standard title text.
///
///
/// From your activity, you can retrieve an instance of ActionBar by calling android.app.Activity\#getActionBar getActionBar().
///
///
/// In some cases, the action bar may be overlayed by another bar that enables contextual actions,
/// using an android.view.ActionMode. For example, when the user selects one or more items in
/// your activity, you can enable an action mode that offers actions specific to the selected
/// items, with a UI that temporarily replaces the action bar. Although the UI may occupy the
/// same space, the android.view.ActionMode APIs are distinct and independent from those for
/// ActionBar.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For information about how to use the action bar, including how to add action items, navigation
/// modes and more, read the <a href="{@docRoot}guide/topics/ui/actionbar.html">Action
/// Bar</a> developer guide.
///
/// </div>
class ActionBar extends jni.JlObject {
  ActionBar.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int DISPLAY_HOME_AS_UP
  /// Display the 'home' element such that it appears as an 'up' affordance.
  /// e.g. show an arrow to the left indicating the action that will be taken.
  ///
  /// Set this flag if selecting the 'home' button in the action bar to return
  /// up by a single level in your UI rather than back to the top level or front page.
  ///
  /// Setting this option will implicitly enable interaction with the home/up
  /// button. See \#setHomeButtonEnabled(boolean).
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  static const DISPLAY_HOME_AS_UP = 4;

  /// from: static public final int DISPLAY_SHOW_CUSTOM
  /// Show the custom view if one has been set.
  ///@see \#setCustomView(View)
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  static const DISPLAY_SHOW_CUSTOM = 16;

  /// from: static public final int DISPLAY_SHOW_HOME
  /// Show 'home' elements in this action bar, leaving more space for other
  /// navigation elements. This includes logo and icon.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  static const DISPLAY_SHOW_HOME = 2;

  /// from: static public final int DISPLAY_SHOW_TITLE
  /// Show the activity title and subtitle, if present.
  ///@see \#setTitle(CharSequence)
  ///@see \#setTitle(int)
  ///@see \#setSubtitle(CharSequence)
  ///@see \#setSubtitle(int)
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  static const DISPLAY_SHOW_TITLE = 8;

  /// from: static public final int DISPLAY_USE_LOGO
  /// Use logo instead of icon if available. This flag will cause appropriate
  /// navigation modes to use a wider logo in place of the standard icon.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  static const DISPLAY_USE_LOGO = 1;

  /// from: static public final int NAVIGATION_MODE_LIST
  /// List navigation mode. Instead of static title text this mode
  /// presents a list menu for navigation within the activity.
  /// e.g. this might be presented to the user as a dropdown list.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  static const NAVIGATION_MODE_LIST = 1;

  /// from: static public final int NAVIGATION_MODE_STANDARD
  /// Standard navigation mode. Consists of either a logo or icon
  /// and title text with an optional subtitle. Clicking any of these elements
  /// will dispatch onOptionsItemSelected to the host Activity with
  /// a MenuItem with item ID android.R.id.home.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  static const NAVIGATION_MODE_STANDARD = 0;

  /// from: static public final int NAVIGATION_MODE_TABS
  /// Tab navigation mode. Instead of static title text this mode
  /// presents a series of tabs for navigation within the activity.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  static const NAVIGATION_MODE_TABS = 2;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ActionBar_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ActionBar() : super.fromRef(_ctor());

  static final _setCustomView = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar_setCustomView")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setCustomView(android.view.View view)
  /// Set the action bar into custom navigation mode, supplying a view
  /// for custom navigation.
  ///
  /// Custom navigation views appear between the application icon and
  /// any action buttons and may use any space available there. Common
  /// use cases for custom navigation views might include an auto-suggesting
  /// address bar for a browser or other navigation mechanisms that do not
  /// translate well to provided navigation modes.
  ///@param view Custom navigation view to place in the ActionBar.
  void setCustomView(jni.JlObject view) =>
      _setCustomView(reference, view.reference);

  static final _setCustomView_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar_setCustomView_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setCustomView(android.view.View view, android.app.ActionBar.LayoutParams layoutParams)
  /// Set the action bar into custom navigation mode, supplying a view
  /// for custom navigation.
  ///
  /// Custom navigation views appear between the application icon and
  /// any action buttons and may use any space available there. Common
  /// use cases for custom navigation views might include an auto-suggesting
  /// address bar for a browser or other navigation mechanisms that do not
  /// translate well to provided navigation modes.
  ///
  ///
  /// The display option \#DISPLAY_SHOW_CUSTOM must be set for
  /// the custom view to be displayed.
  ///
  ///@param view Custom navigation view to place in the ActionBar.
  ///@param layoutParams How this custom view should layout in the bar.
  ///@see \#setDisplayOptions(int, int)
  void setCustomView_1(
          jni.JlObject view, ActionBar_LayoutParams layoutParams) =>
      _setCustomView_1(reference, view.reference, layoutParams.reference);

  static final _setCustomView_2 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ActionBar_setCustomView_2")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setCustomView(int resId)
  /// Set the action bar into custom navigation mode, supplying a view
  /// for custom navigation.
  ///
  /// Custom navigation views appear between the application icon and
  /// any action buttons and may use any space available there. Common
  /// use cases for custom navigation views might include an auto-suggesting
  /// address bar for a browser or other navigation mechanisms that do not
  /// translate well to provided navigation modes.
  ///
  ///
  /// The display option \#DISPLAY_SHOW_CUSTOM must be set for
  /// the custom view to be displayed.
  ///
  ///@param resId Resource ID of a layout to inflate into the ActionBar.
  ///@see \#setDisplayOptions(int, int)
  void setCustomView_2(int resId) => _setCustomView_2(reference, resId);

  static final _setIcon = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ActionBar_setIcon")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setIcon(int resId)
  /// Set the icon to display in the 'home' section of the action bar.
  /// The action bar will use an icon specified by its style or the
  /// activity icon by default.
  ///
  /// Whether the home section shows an icon or logo is controlled
  /// by the display option \#DISPLAY_USE_LOGO.
  ///@param resId Resource ID of a drawable to show as an icon.
  ///@see \#setDisplayUseLogoEnabled(boolean)
  ///@see \#setDisplayShowHomeEnabled(boolean)
  void setIcon(int resId) => _setIcon(reference, resId);

  static final _setIcon_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_ActionBar_setIcon_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setIcon(android.graphics.drawable.Drawable icon)
  /// Set the icon to display in the 'home' section of the action bar.
  /// The action bar will use an icon specified by its style or the
  /// activity icon by default.
  ///
  /// Whether the home section shows an icon or logo is controlled
  /// by the display option \#DISPLAY_USE_LOGO.
  ///@param icon Drawable to show as an icon.
  ///@see \#setDisplayUseLogoEnabled(boolean)
  ///@see \#setDisplayShowHomeEnabled(boolean)
  void setIcon_1(jni.JlObject icon) => _setIcon_1(reference, icon.reference);

  static final _setLogo = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ActionBar_setLogo")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setLogo(int resId)
  /// Set the logo to display in the 'home' section of the action bar.
  /// The action bar will use a logo specified by its style or the
  /// activity logo by default.
  ///
  /// Whether the home section shows an icon or logo is controlled
  /// by the display option \#DISPLAY_USE_LOGO.
  ///@param resId Resource ID of a drawable to show as a logo.
  ///@see \#setDisplayUseLogoEnabled(boolean)
  ///@see \#setDisplayShowHomeEnabled(boolean)
  void setLogo(int resId) => _setLogo(reference, resId);

  static final _setLogo_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_ActionBar_setLogo_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setLogo(android.graphics.drawable.Drawable logo)
  /// Set the logo to display in the 'home' section of the action bar.
  /// The action bar will use a logo specified by its style or the
  /// activity logo by default.
  ///
  /// Whether the home section shows an icon or logo is controlled
  /// by the display option \#DISPLAY_USE_LOGO.
  ///@param logo Drawable to show as a logo.
  ///@see \#setDisplayUseLogoEnabled(boolean)
  ///@see \#setDisplayShowHomeEnabled(boolean)
  void setLogo_1(jni.JlObject logo) => _setLogo_1(reference, logo.reference);

  static final _setListNavigationCallbacks = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar_setListNavigationCallbacks")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setListNavigationCallbacks(android.widget.SpinnerAdapter adapter, android.app.ActionBar.OnNavigationListener callback)
  /// Set the adapter and navigation callback for list navigation mode.
  ///
  /// The supplied adapter will provide views for the expanded list as well as
  /// the currently selected item. (These may be displayed differently.)
  ///
  /// The supplied OnNavigationListener will alert the application when the user
  /// changes the current list selection.
  ///@param adapter An adapter that will provide views both to display
  ///                the current navigation selection and populate views
  ///                within the dropdown navigation menu.
  ///@param callback An OnNavigationListener that will receive events when the user
  ///                 selects a navigation item.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void setListNavigationCallbacks(
          jni.JlObject adapter, ActionBar_OnNavigationListener callback) =>
      _setListNavigationCallbacks(
          reference, adapter.reference, callback.reference);

  static final _setSelectedNavigationItem = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ActionBar_setSelectedNavigationItem")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setSelectedNavigationItem(int position)
  /// Set the selected navigation item in list or tabbed navigation modes.
  ///@param position Position of the item to select.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void setSelectedNavigationItem(int position) =>
      _setSelectedNavigationItem(reference, position);

  static final _getSelectedNavigationIndex =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActionBar_getSelectedNavigationIndex")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getSelectedNavigationIndex()
  /// Get the position of the selected navigation item in list or tabbed navigation modes.
  ///@return Position of the selected item.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  int getSelectedNavigationIndex() => _getSelectedNavigationIndex(reference);

  static final _getNavigationItemCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActionBar_getNavigationItemCount")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getNavigationItemCount()
  /// Get the number of navigation items present in the current navigation mode.
  ///@return Number of navigation items.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  int getNavigationItemCount() => _getNavigationItemCount(reference);

  static final _setTitle = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_ActionBar_setTitle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setTitle(java.lang.CharSequence title)
  /// Set the action bar's title. This will only be displayed if
  /// \#DISPLAY_SHOW_TITLE is set.
  ///@param title Title to set
  ///@see \#setTitle(int)
  ///@see \#setDisplayOptions(int, int)
  void setTitle(jni.JlObject title) => _setTitle(reference, title.reference);

  static final _setTitle_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ActionBar_setTitle_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setTitle(int resId)
  /// Set the action bar's title. This will only be displayed if
  /// \#DISPLAY_SHOW_TITLE is set.
  ///@param resId Resource ID of title string to set
  ///@see \#setTitle(CharSequence)
  ///@see \#setDisplayOptions(int, int)
  void setTitle_1(int resId) => _setTitle_1(reference, resId);

  static final _setSubtitle = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_ActionBar_setSubtitle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setSubtitle(java.lang.CharSequence subtitle)
  /// Set the action bar's subtitle. This will only be displayed if
  /// \#DISPLAY_SHOW_TITLE is set. Set to null to disable the
  /// subtitle entirely.
  ///@param subtitle Subtitle to set
  ///@see \#setSubtitle(int)
  ///@see \#setDisplayOptions(int, int)
  void setSubtitle(jni.JlObject subtitle) =>
      _setSubtitle(reference, subtitle.reference);

  static final _setSubtitle_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ActionBar_setSubtitle_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setSubtitle(int resId)
  /// Set the action bar's subtitle. This will only be displayed if
  /// \#DISPLAY_SHOW_TITLE is set.
  ///@param resId Resource ID of subtitle string to set
  ///@see \#setSubtitle(CharSequence)
  ///@see \#setDisplayOptions(int, int)
  void setSubtitle_1(int resId) => _setSubtitle_1(reference, resId);

  static final _setDisplayOptions = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ActionBar_setDisplayOptions")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setDisplayOptions(int options)
  /// Set display options. This changes all display option bits at once. To change
  /// a limited subset of display options, see \#setDisplayOptions(int, int).
  ///@param options A combination of the bits defined by the DISPLAY_ constants
  ///                defined in ActionBar.
  ///
  /// Value is either <code>0</code> or a combination of android.app.ActionBar\#DISPLAY_USE_LOGO, android.app.ActionBar\#DISPLAY_SHOW_HOME, android.app.ActionBar\#DISPLAY_HOME_AS_UP, android.app.ActionBar\#DISPLAY_SHOW_TITLE, android.app.ActionBar\#DISPLAY_SHOW_CUSTOM, and android.app.ActionBar.DISPLAY_TITLE_MULTIPLE_LINES
  void setDisplayOptions(int options) => _setDisplayOptions(reference, options);

  static final _setDisplayOptions_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_app_ActionBar_setDisplayOptions_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void setDisplayOptions(int options, int mask)
  /// Set selected display options. Only the options specified by mask will be changed.
  /// To change all display option bits at once, see \#setDisplayOptions(int).
  ///
  /// Example: setDisplayOptions(0, DISPLAY_SHOW_HOME) will disable the
  /// \#DISPLAY_SHOW_HOME option.
  /// setDisplayOptions(DISPLAY_SHOW_HOME, DISPLAY_SHOW_HOME | DISPLAY_USE_LOGO)
  /// will enable \#DISPLAY_SHOW_HOME and disable \#DISPLAY_USE_LOGO.
  ///@param options A combination of the bits defined by the DISPLAY_ constants
  ///                defined in ActionBar.
  /// Value is either <code>0</code> or a combination of android.app.ActionBar\#DISPLAY_USE_LOGO, android.app.ActionBar\#DISPLAY_SHOW_HOME, android.app.ActionBar\#DISPLAY_HOME_AS_UP, android.app.ActionBar\#DISPLAY_SHOW_TITLE, android.app.ActionBar\#DISPLAY_SHOW_CUSTOM, and android.app.ActionBar.DISPLAY_TITLE_MULTIPLE_LINES
  ///@param mask A bit mask declaring which display options should be changed.
  ///
  /// Value is either <code>0</code> or a combination of android.app.ActionBar\#DISPLAY_USE_LOGO, android.app.ActionBar\#DISPLAY_SHOW_HOME, android.app.ActionBar\#DISPLAY_HOME_AS_UP, android.app.ActionBar\#DISPLAY_SHOW_TITLE, android.app.ActionBar\#DISPLAY_SHOW_CUSTOM, and android.app.ActionBar.DISPLAY_TITLE_MULTIPLE_LINES
  void setDisplayOptions_1(int options, int mask) =>
      _setDisplayOptions_1(reference, options, mask);

  static final _setDisplayUseLogoEnabled = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_ActionBar_setDisplayUseLogoEnabled")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setDisplayUseLogoEnabled(boolean useLogo)
  /// Set whether to display the activity logo rather than the activity icon.
  /// A logo is often a wider, more detailed image.
  ///
  /// To set several display options at once, see the setDisplayOptions methods.
  ///@param useLogo true to use the activity logo, false to use the activity icon.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  void setDisplayUseLogoEnabled(bool useLogo) =>
      _setDisplayUseLogoEnabled(reference, useLogo ? 1 : 0);

  static final _setDisplayShowHomeEnabled = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_ActionBar_setDisplayShowHomeEnabled")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setDisplayShowHomeEnabled(boolean showHome)
  /// Set whether to include the application home affordance in the action bar.
  /// Home is presented as either an activity icon or logo.
  ///
  /// To set several display options at once, see the setDisplayOptions methods.
  ///@param showHome true to show home, false otherwise.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  void setDisplayShowHomeEnabled(bool showHome) =>
      _setDisplayShowHomeEnabled(reference, showHome ? 1 : 0);

  static final _setDisplayHomeAsUpEnabled = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_ActionBar_setDisplayHomeAsUpEnabled")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setDisplayHomeAsUpEnabled(boolean showHomeAsUp)
  /// Set whether home should be displayed as an "up" affordance.
  /// Set this to true if selecting "home" returns up by a single level in your UI
  /// rather than back to the top level or front page.
  ///
  /// To set several display options at once, see the setDisplayOptions methods.
  ///@param showHomeAsUp true to show the user that selecting home will return one
  ///                     level up rather than to the top level of the app.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  void setDisplayHomeAsUpEnabled(bool showHomeAsUp) =>
      _setDisplayHomeAsUpEnabled(reference, showHomeAsUp ? 1 : 0);

  static final _setDisplayShowTitleEnabled = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_ActionBar_setDisplayShowTitleEnabled")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setDisplayShowTitleEnabled(boolean showTitle)
  /// Set whether an activity title/subtitle should be displayed.
  ///
  /// To set several display options at once, see the setDisplayOptions methods.
  ///@param showTitle true to display a title/subtitle if present.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  void setDisplayShowTitleEnabled(bool showTitle) =>
      _setDisplayShowTitleEnabled(reference, showTitle ? 1 : 0);

  static final _setDisplayShowCustomEnabled = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_ActionBar_setDisplayShowCustomEnabled")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setDisplayShowCustomEnabled(boolean showCustom)
  /// Set whether a custom view should be displayed, if set.
  ///
  /// To set several display options at once, see the setDisplayOptions methods.
  ///@param showCustom true if the currently set custom view should be displayed, false otherwise.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  void setDisplayShowCustomEnabled(bool showCustom) =>
      _setDisplayShowCustomEnabled(reference, showCustom ? 1 : 0);

  static final _setBackgroundDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar_setBackgroundDrawable")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setBackgroundDrawable(android.graphics.drawable.Drawable d)
  /// Set the ActionBar's background. This will be used for the primary
  /// action bar.
  ///@param d Background drawable
  /// This value may be {@code null}.
  ///@see \#setStackedBackgroundDrawable(Drawable)
  ///@see \#setSplitBackgroundDrawable(Drawable)
  void setBackgroundDrawable(jni.JlObject d) =>
      _setBackgroundDrawable(reference, d.reference);

  static final _setStackedBackgroundDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar_setStackedBackgroundDrawable")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setStackedBackgroundDrawable(android.graphics.drawable.Drawable d)
  /// Set the ActionBar's stacked background. This will appear
  /// in the second row/stacked bar on some devices and configurations.
  ///@param d Background drawable for the stacked row
  void setStackedBackgroundDrawable(jni.JlObject d) =>
      _setStackedBackgroundDrawable(reference, d.reference);

  static final _setSplitBackgroundDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar_setSplitBackgroundDrawable")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setSplitBackgroundDrawable(android.graphics.drawable.Drawable d)
  /// Set the ActionBar's split background. This will appear in
  /// the split action bar containing menu-provided action buttons
  /// on some devices and configurations.
  /// You can enable split action bar with android.R.attr\#uiOptions
  ///@param d Background drawable for the split bar
  void setSplitBackgroundDrawable(jni.JlObject d) =>
      _setSplitBackgroundDrawable(reference, d.reference);

  static final _getCustomView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar_getCustomView")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.view.View getCustomView()
  /// @return The current custom view.
  jni.JlObject getCustomView() =>
      jni.JlObject.fromRef(_getCustomView(reference));

  static final _getTitle = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_ActionBar_getTitle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.CharSequence getTitle()
  /// Returns the current ActionBar title in standard mode.
  /// Returns null if \#getNavigationMode() would not return
  /// \#NAVIGATION_MODE_STANDARD.
  ///@return The current ActionBar title or null.
  jni.JlObject getTitle() => jni.JlObject.fromRef(_getTitle(reference));

  static final _getSubtitle = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_ActionBar_getSubtitle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.CharSequence getSubtitle()
  /// Returns the current ActionBar subtitle in standard mode.
  /// Returns null if \#getNavigationMode() would not return
  /// \#NAVIGATION_MODE_STANDARD.
  ///@return The current ActionBar subtitle or null.
  jni.JlObject getSubtitle() => jni.JlObject.fromRef(_getSubtitle(reference));

  static final _getNavigationMode =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActionBar_getNavigationMode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getNavigationMode()
  /// Returns the current navigation mode. The result will be one of:
  /// <ul>
  /// <li>\#NAVIGATION_MODE_STANDARD</li>
  /// <li>\#NAVIGATION_MODE_LIST</li>
  /// <li>\#NAVIGATION_MODE_TABS</li>
  /// </ul>
  ///@return The current navigation mode.
  ///
  /// Value is android.app.ActionBar\#NAVIGATION_MODE_STANDARD, android.app.ActionBar\#NAVIGATION_MODE_LIST, or android.app.ActionBar\#NAVIGATION_MODE_TABS
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  int getNavigationMode() => _getNavigationMode(reference);

  static final _setNavigationMode = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ActionBar_setNavigationMode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setNavigationMode(int mode)
  /// Set the current navigation mode.
  ///@param mode The new mode to set.
  /// Value is android.app.ActionBar\#NAVIGATION_MODE_STANDARD, android.app.ActionBar\#NAVIGATION_MODE_LIST, or android.app.ActionBar\#NAVIGATION_MODE_TABS
  ///@see \#NAVIGATION_MODE_STANDARD
  ///@see \#NAVIGATION_MODE_LIST
  ///@see \#NAVIGATION_MODE_TABS
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void setNavigationMode(int mode) => _setNavigationMode(reference, mode);

  static final _getDisplayOptions =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActionBar_getDisplayOptions")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getDisplayOptions()
  /// @return The current set of display options.
  int getDisplayOptions() => _getDisplayOptions(reference);

  static final _newTab = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_ActionBar_newTab")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.ActionBar.Tab newTab()
  /// Create and return a new Tab.
  /// This tab will not be included in the action bar until it is added.
  ///
  /// Very often tabs will be used to switch between Fragment
  /// objects.  Here is a typical implementation of such tabs:
  ///
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentTabs.java
  ///      complete}
  ///@return A new Tab
  ///@see \#addTab(Tab)
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  ActionBar_Tab newTab() => ActionBar_Tab.fromRef(_newTab(reference));

  static final _addTab = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_ActionBar_addTab")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void addTab(android.app.ActionBar.Tab tab)
  /// Add a tab for use in tabbed navigation mode. The tab will be added at the end of the list.
  /// If this is the first tab to be added it will become the selected tab.
  ///@param tab Tab to add
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void addTab(ActionBar_Tab tab) => _addTab(reference, tab.reference);

  static final _addTab_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_ActionBar_addTab_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void addTab(android.app.ActionBar.Tab tab, boolean setSelected)
  /// Add a tab for use in tabbed navigation mode. The tab will be added at the end of the list.
  ///@param tab Tab to add
  ///@param setSelected True if the added tab should become the selected tab.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void addTab_1(ActionBar_Tab tab, bool setSelected) =>
      _addTab_1(reference, tab.reference, setSelected ? 1 : 0);

  static final _addTab_2 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ActionBar_addTab_2")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void addTab(android.app.ActionBar.Tab tab, int position)
  /// Add a tab for use in tabbed navigation mode. The tab will be inserted at
  /// <code>position</code>. If this is the first tab to be added it will become
  /// the selected tab.
  ///@param tab The tab to add
  ///@param position The new position of the tab
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void addTab_2(ActionBar_Tab tab, int position) =>
      _addTab_2(reference, tab.reference, position);

  static final _addTab_3 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32, ffi.Uint8)>>("android_app_ActionBar_addTab_3")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void addTab(android.app.ActionBar.Tab tab, int position, boolean setSelected)
  /// Add a tab for use in tabbed navigation mode. The tab will be insterted at
  /// <code>position</code>.
  ///@param tab The tab to add
  ///@param position The new position of the tab
  ///@param setSelected True if the added tab should become the selected tab.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void addTab_3(ActionBar_Tab tab, int position, bool setSelected) =>
      _addTab_3(reference, tab.reference, position, setSelected ? 1 : 0);

  static final _removeTab = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_ActionBar_removeTab")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void removeTab(android.app.ActionBar.Tab tab)
  /// Remove a tab from the action bar. If the removed tab was selected it will be deselected
  /// and another tab will be selected if present.
  ///@param tab The tab to remove
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void removeTab(ActionBar_Tab tab) => _removeTab(reference, tab.reference);

  static final _removeTabAt = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ActionBar_removeTabAt")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void removeTabAt(int position)
  /// Remove a tab from the action bar. If the removed tab was selected it will be deselected
  /// and another tab will be selected if present.
  ///@param position Position of the tab to remove
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void removeTabAt(int position) => _removeTabAt(reference, position);

  static final _removeAllTabs =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActionBar_removeAllTabs")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void removeAllTabs()
  /// Remove all tabs from the action bar and deselect the current tab.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void removeAllTabs() => _removeAllTabs(reference);

  static final _selectTab = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_ActionBar_selectTab")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void selectTab(android.app.ActionBar.Tab tab)
  /// Select the specified tab. If it is not a child of this action bar it will be added.
  ///
  /// Note: If you want to select by index, use \#setSelectedNavigationItem(int).
  ///
  ///@param tab Tab to select
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void selectTab(ActionBar_Tab tab) => _selectTab(reference, tab.reference);

  static final _getSelectedTab = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar_getSelectedTab")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.ActionBar.Tab getSelectedTab()
  /// Returns the currently selected tab if in tabbed navigation mode and there is at least
  /// one tab present.
  ///@return The currently selected tab or null
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  ActionBar_Tab getSelectedTab() =>
      ActionBar_Tab.fromRef(_getSelectedTab(reference));

  static final _getTabAt = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ActionBar_getTabAt")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.ActionBar.Tab getTabAt(int index)
  /// Returns the tab at the specified index.
  ///@param index Index value in the range 0-get
  ///@return
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  ActionBar_Tab getTabAt(int index) =>
      ActionBar_Tab.fromRef(_getTabAt(reference, index));

  static final _getTabCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActionBar_getTabCount")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getTabCount()
  /// Returns the number of tabs currently registered with the action bar.
  ///@return Tab count
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  int getTabCount() => _getTabCount(reference);

  static final _getHeight =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActionBar_getHeight")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getHeight()
  /// Retrieve the current height of the ActionBar.
  ///@return The ActionBar's height
  int getHeight() => _getHeight(reference);

  static final _show_ =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActionBar_show_")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void show()
  /// Show the ActionBar if it is not currently showing.
  /// If the window hosting the ActionBar does not have the feature
  /// Window\#FEATURE_ACTION_BAR_OVERLAY it will resize application
  /// content to fit the new space available.
  ///
  /// If you are hiding the ActionBar through
  /// View\#SYSTEM_UI_FLAG_FULLSCREEN View.SYSTEM_UI_FLAG_FULLSCREEN,
  /// you should not call this function directly.
  void show_() => _show_(reference);

  static final _hide_ =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActionBar_hide_")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void hide()
  /// Hide the ActionBar if it is currently showing.
  /// If the window hosting the ActionBar does not have the feature
  /// Window\#FEATURE_ACTION_BAR_OVERLAY it will resize application
  /// content to fit the new space available.
  ///
  /// Instead of calling this function directly, you can also cause an
  /// ActionBar using the overlay feature to hide through
  /// View\#SYSTEM_UI_FLAG_FULLSCREEN View.SYSTEM_UI_FLAG_FULLSCREEN.
  /// Hiding the ActionBar through this system UI flag allows you to more
  /// seamlessly hide it in conjunction with other screen decorations.
  void hide_() => _hide_(reference);

  static final _isShowing =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActionBar_isShowing")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isShowing()
  /// @return <code>true</code> if the ActionBar is showing, <code>false</code> otherwise.
  bool isShowing() => _isShowing(reference) != 0;

  static final _addOnMenuVisibilityListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar_addOnMenuVisibilityListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void addOnMenuVisibilityListener(android.app.ActionBar.OnMenuVisibilityListener listener)
  /// Add a listener that will respond to menu visibility change events.
  ///@param listener The new listener to add
  void addOnMenuVisibilityListener(
          ActionBar_OnMenuVisibilityListener listener) =>
      _addOnMenuVisibilityListener(reference, listener.reference);

  static final _removeOnMenuVisibilityListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar_removeOnMenuVisibilityListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void removeOnMenuVisibilityListener(android.app.ActionBar.OnMenuVisibilityListener listener)
  /// Remove a menu visibility listener. This listener will no longer receive menu
  /// visibility change events.
  ///@param listener A listener to remove that was previously added
  void removeOnMenuVisibilityListener(
          ActionBar_OnMenuVisibilityListener listener) =>
      _removeOnMenuVisibilityListener(reference, listener.reference);

  static final _setHomeButtonEnabled = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_ActionBar_setHomeButtonEnabled")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setHomeButtonEnabled(boolean enabled)
  /// Enable or disable the "home" button in the corner of the action bar. (Note that this
  /// is the application home/up affordance on the action bar, not the systemwide home
  /// button.)
  ///
  /// This defaults to true for packages targeting &lt; API 14. For packages targeting
  /// API 14 or greater, the application should call this method to enable interaction
  /// with the home/up affordance.
  ///
  /// Setting the \#DISPLAY_HOME_AS_UP display option will automatically enable
  /// the home button.
  ///@param enabled true to enable the home button, false to disable the home button.
  void setHomeButtonEnabled(bool enabled) =>
      _setHomeButtonEnabled(reference, enabled ? 1 : 0);

  static final _getThemedContext = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar_getThemedContext")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context getThemedContext()
  /// Returns a Context with an appropriate theme for creating views that
  /// will appear in the action bar. If you are inflating or instantiating custom views
  /// that will appear in an action bar, you should use the Context returned by this method.
  /// (This includes adapters used for list navigation mode.)
  /// This will ensure that views contrast properly against the action bar.
  ///@return A themed Context for creating views
  content.Context getThemedContext() =>
      content.Context.fromRef(_getThemedContext(reference));

  static final _setHomeAsUpIndicator = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar_setHomeAsUpIndicator")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setHomeAsUpIndicator(android.graphics.drawable.Drawable indicator)
  /// Set an alternate drawable to display next to the icon/logo/title
  /// when \#DISPLAY_HOME_AS_UP is enabled. This can be useful if you are using
  /// this mode to display an alternate selection for up navigation, such as a sliding drawer.
  ///
  /// If you pass <code>null</code> to this method, the default drawable from the theme
  /// will be used.
  ///
  ///
  /// If you implement alternate or intermediate behavior around Up, you should also
  /// call \#setHomeActionContentDescription(int) setHomeActionContentDescription()
  /// to provide a correct description of the action for accessibility support.
  ///
  ///@param indicator A drawable to use for the up indicator, or null to use the theme's default
  ///@see \#setDisplayOptions(int, int)
  ///@see \#setDisplayHomeAsUpEnabled(boolean)
  ///@see \#setHomeActionContentDescription(int)
  void setHomeAsUpIndicator(jni.JlObject indicator) =>
      _setHomeAsUpIndicator(reference, indicator.reference);

  static final _setHomeAsUpIndicator_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ActionBar_setHomeAsUpIndicator_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setHomeAsUpIndicator(int resId)
  /// Set an alternate drawable to display next to the icon/logo/title
  /// when \#DISPLAY_HOME_AS_UP is enabled. This can be useful if you are using
  /// this mode to display an alternate selection for up navigation, such as a sliding drawer.
  ///
  /// If you pass <code>0</code> to this method, the default drawable from the theme
  /// will be used.
  ///
  ///
  /// If you implement alternate or intermediate behavior around Up, you should also
  /// call \#setHomeActionContentDescription(int) setHomeActionContentDescription()
  /// to provide a correct description of the action for accessibility support.
  ///
  ///@param resId Resource ID of a drawable to use for the up indicator, or null
  ///              to use the theme's default
  ///@see \#setDisplayOptions(int, int)
  ///@see \#setDisplayHomeAsUpEnabled(boolean)
  ///@see \#setHomeActionContentDescription(int)
  void setHomeAsUpIndicator_1(int resId) =>
      _setHomeAsUpIndicator_1(reference, resId);

  static final _setHomeActionContentDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar_setHomeActionContentDescription")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setHomeActionContentDescription(java.lang.CharSequence description)
  /// Set an alternate description for the Home/Up action, when enabled.
  ///
  /// This description is commonly used for accessibility/screen readers when
  /// the Home action is enabled. (See \#setDisplayHomeAsUpEnabled(boolean).)
  /// Examples of this are, "Navigate Home" or "Navigate Up" depending on the
  /// \#DISPLAY_HOME_AS_UP display option. If you have changed the home-as-up
  /// indicator using \#setHomeAsUpIndicator(int) to indicate more specific
  /// functionality such as a sliding drawer, you should also set this to accurately
  /// describe the action.
  ///
  ///
  /// Setting this to <code>null</code> will use the system default description.
  ///
  ///@param description New description for the Home action when enabled
  ///@see \#setHomeAsUpIndicator(int)
  ///@see \#setHomeAsUpIndicator(android.graphics.drawable.Drawable)
  void setHomeActionContentDescription(jni.JlObject description) =>
      _setHomeActionContentDescription(reference, description.reference);

  static final _setHomeActionContentDescription_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ActionBar_setHomeActionContentDescription_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setHomeActionContentDescription(int resId)
  /// Set an alternate description for the Home/Up action, when enabled.
  ///
  /// This description is commonly used for accessibility/screen readers when
  /// the Home action is enabled. (See \#setDisplayHomeAsUpEnabled(boolean).)
  /// Examples of this are, "Navigate Home" or "Navigate Up" depending on the
  /// \#DISPLAY_HOME_AS_UP display option. If you have changed the home-as-up
  /// indicator using \#setHomeAsUpIndicator(int) to indicate more specific
  /// functionality such as a sliding drawer, you should also set this to accurately
  /// describe the action.
  ///
  ///
  /// Setting this to <code>0</code> will use the system default description.
  ///
  ///@param resId Resource ID of a string to use as the new description
  ///              for the Home action when enabled
  ///@see \#setHomeAsUpIndicator(int)
  ///@see \#setHomeAsUpIndicator(android.graphics.drawable.Drawable)
  void setHomeActionContentDescription_1(int resId) =>
      _setHomeActionContentDescription_1(reference, resId);

  static final _setHideOnContentScrollEnabled = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_ActionBar_setHideOnContentScrollEnabled")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setHideOnContentScrollEnabled(boolean hideOnContentScroll)
  /// Enable hiding the action bar on content scroll.
  ///
  /// If enabled, the action bar will scroll out of sight along with a
  /// View\#setNestedScrollingEnabled(boolean) nested scrolling child view's content.
  /// The action bar must be in Window\#FEATURE_ACTION_BAR_OVERLAY overlay mode
  /// to enable hiding on content scroll.
  ///
  ///
  /// When partially scrolled off screen the action bar is considered
  /// \#hide() hidden. A call to \#show() show will cause it to return to full view.
  ///
  ///
  ///@param hideOnContentScroll true to enable hiding on content scroll.
  void setHideOnContentScrollEnabled(bool hideOnContentScroll) =>
      _setHideOnContentScrollEnabled(reference, hideOnContentScroll ? 1 : 0);

  static final _isHideOnContentScrollEnabled =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActionBar_isHideOnContentScrollEnabled")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isHideOnContentScrollEnabled()
  /// Return whether the action bar is configured to scroll out of sight along with
  /// a View\#setNestedScrollingEnabled(boolean) nested scrolling child.
  ///@return true if hide-on-content-scroll is enabled
  ///@see \#setHideOnContentScrollEnabled(boolean)
  bool isHideOnContentScrollEnabled() =>
      _isHideOnContentScrollEnabled(reference) != 0;

  static final _getHideOffset =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActionBar_getHideOffset")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getHideOffset()
  /// Return the current vertical offset of the action bar.
  ///
  /// The action bar's current hide offset is the distance that the action bar is currently
  /// scrolled offscreen in pixels. The valid range is 0 (fully visible) to the action bar's
  /// current measured \#getHeight() height (fully invisible).
  ///
  ///@return The action bar's offset toward its fully hidden state in pixels
  int getHideOffset() => _getHideOffset(reference);

  static final _setHideOffset = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ActionBar_setHideOffset")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setHideOffset(int offset)
  /// Set the current hide offset of the action bar.
  ///
  /// The action bar's current hide offset is the distance that the action bar is currently
  /// scrolled offscreen in pixels. The valid range is 0 (fully visible) to the action bar's
  /// current measured \#getHeight() height (fully invisible).
  ///
  ///@param offset The action bar's offset toward its fully hidden state in pixels.
  void setHideOffset(int offset) => _setHideOffset(reference, offset);

  static final _setElevation = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("android_app_ActionBar_setElevation")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setElevation(float elevation)
  /// Set the Z-axis elevation of the action bar in pixels.
  ///
  /// The action bar's elevation is the distance it is placed from its parent surface. Higher
  /// values are closer to the user.
  ///
  ///@param elevation Elevation value in pixels
  void setElevation(double elevation) => _setElevation(reference, elevation);

  static final _getElevation =
      jlookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActionBar_getElevation")
          .asFunction<double Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getElevation()
  /// Get the Z-axis elevation of the action bar in pixels.
  ///
  /// The action bar's elevation is the distance it is placed from its parent surface. Higher
  /// values are closer to the user.
  ///
  ///@return Elevation value in pixels
  double getElevation() => _getElevation(reference);
}

/// Callback interface invoked when a tab is focused, unfocused, added, or removed.
///@deprecated Action bar navigation modes are deprecated and not supported by inline
/// toolbar action bars. Consider using other
/// <a href="http://developer.android.com/design/patterns/navigation.html">common
/// navigation patterns</a> instead.
class ActionBar_TabListener extends jni.JlObject {
  ActionBar_TabListener.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _onTabSelected = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar__TabListener_onTabSelected")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onTabSelected(android.app.ActionBar.Tab tab, android.app.FragmentTransaction ft)
  /// Called when a tab enters the selected state.
  ///@param tab The tab that was selected
  ///@param ft A FragmentTransaction for queuing fragment operations to execute
  ///        during a tab switch. The previous tab's unselect and this tab's select will be
  ///        executed in a single transaction. This FragmentTransaction does not support
  ///        being added to the back stack.
  void onTabSelected(ActionBar_Tab tab, FragmentTransaction ft) =>
      _onTabSelected(reference, tab.reference, ft.reference);

  static final _onTabUnselected = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar__TabListener_onTabUnselected")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onTabUnselected(android.app.ActionBar.Tab tab, android.app.FragmentTransaction ft)
  /// Called when a tab exits the selected state.
  ///@param tab The tab that was unselected
  ///@param ft A FragmentTransaction for queuing fragment operations to execute
  ///        during a tab switch. This tab's unselect and the newly selected tab's select
  ///        will be executed in a single transaction. This FragmentTransaction does not
  ///        support being added to the back stack.
  void onTabUnselected(ActionBar_Tab tab, FragmentTransaction ft) =>
      _onTabUnselected(reference, tab.reference, ft.reference);

  static final _onTabReselected = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar__TabListener_onTabReselected")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onTabReselected(android.app.ActionBar.Tab tab, android.app.FragmentTransaction ft)
  /// Called when a tab that is already selected is chosen again by the user.
  /// Some applications may use this action to return to the top level of a category.
  ///@param tab The tab that was reselected.
  ///@param ft A FragmentTransaction for queuing fragment operations to execute
  ///        once this method returns. This FragmentTransaction does not support
  ///        being added to the back stack.
  void onTabReselected(ActionBar_Tab tab, FragmentTransaction ft) =>
      _onTabReselected(reference, tab.reference, ft.reference);
}

/// A tab in the action bar.
///
/// Tabs manage the hiding and showing of Fragments.
///@deprecated Action bar navigation modes are deprecated and not supported by inline
/// toolbar action bars. Consider using other
/// <a href="http://developer.android.com/design/patterns/navigation.html">common
/// navigation patterns</a> instead.
class ActionBar_Tab extends jni.JlObject {
  ActionBar_Tab.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int INVALID_POSITION
  /// An invalid position for a tab.
  ///@see \#getPosition()
  static const INVALID_POSITION = -1;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ActionBar__Tab_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ActionBar_Tab() : super.fromRef(_ctor());

  static final _getPosition =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActionBar__Tab_getPosition")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getPosition()
  /// Return the current position of this tab in the action bar.
  ///@return Current position, or \#INVALID_POSITION if this tab is not currently in
  ///         the action bar.
  int getPosition() => _getPosition(reference);

  static final _getIcon = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_ActionBar__Tab_getIcon")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable getIcon()
  /// Return the icon associated with this tab.
  ///@return The tab's icon
  jni.JlObject getIcon() => jni.JlObject.fromRef(_getIcon(reference));

  static final _getText = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_ActionBar__Tab_getText")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.CharSequence getText()
  /// Return the text of this tab.
  ///@return The tab's text
  jni.JlObject getText() => jni.JlObject.fromRef(_getText(reference));

  static final _setIcon = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_ActionBar__Tab_setIcon")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.ActionBar.Tab setIcon(android.graphics.drawable.Drawable icon)
  /// Set the icon displayed on this tab.
  ///@param icon The drawable to use as an icon
  ///@return The current instance for call chaining
  ActionBar_Tab setIcon(jni.JlObject icon) =>
      ActionBar_Tab.fromRef(_setIcon(reference, icon.reference));

  static final _setIcon_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ActionBar__Tab_setIcon_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.ActionBar.Tab setIcon(int resId)
  /// Set the icon displayed on this tab.
  ///@param resId Resource ID referring to the drawable to use as an icon
  ///@return The current instance for call chaining
  ActionBar_Tab setIcon_1(int resId) =>
      ActionBar_Tab.fromRef(_setIcon_1(reference, resId));

  static final _setText = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_ActionBar__Tab_setText")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.ActionBar.Tab setText(java.lang.CharSequence text)
  /// Set the text displayed on this tab. Text may be truncated if there is not
  /// room to display the entire string.
  ///@param text The text to display
  ///@return The current instance for call chaining
  ActionBar_Tab setText(jni.JlObject text) =>
      ActionBar_Tab.fromRef(_setText(reference, text.reference));

  static final _setText_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ActionBar__Tab_setText_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.ActionBar.Tab setText(int resId)
  /// Set the text displayed on this tab. Text may be truncated if there is not
  /// room to display the entire string.
  ///@param resId A resource ID referring to the text that should be displayed
  ///@return The current instance for call chaining
  ActionBar_Tab setText_1(int resId) =>
      ActionBar_Tab.fromRef(_setText_1(reference, resId));

  static final _setCustomView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar__Tab_setCustomView")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.ActionBar.Tab setCustomView(android.view.View view)
  /// Set a custom view to be used for this tab. This overrides values set by
  /// \#setText(CharSequence) and \#setIcon(Drawable).
  ///@param view Custom view to be used as a tab.
  ///@return The current instance for call chaining
  ActionBar_Tab setCustomView(jni.JlObject view) =>
      ActionBar_Tab.fromRef(_setCustomView(reference, view.reference));

  static final _setCustomView_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ActionBar__Tab_setCustomView_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.ActionBar.Tab setCustomView(int layoutResId)
  /// Set a custom view to be used for this tab. This overrides values set by
  /// \#setText(CharSequence) and \#setIcon(Drawable).
  ///@param layoutResId A layout resource to inflate and use as a custom tab view
  ///@return The current instance for call chaining
  ActionBar_Tab setCustomView_1(int layoutResId) =>
      ActionBar_Tab.fromRef(_setCustomView_1(reference, layoutResId));

  static final _getCustomView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar__Tab_getCustomView")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.view.View getCustomView()
  /// Retrieve a previously set custom view for this tab.
  ///@return The custom view set by \#setCustomView(View).
  jni.JlObject getCustomView() =>
      jni.JlObject.fromRef(_getCustomView(reference));

  static final _setTag = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_ActionBar__Tab_setTag")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.ActionBar.Tab setTag(java.lang.Object obj)
  /// Give this Tab an arbitrary object to hold for later use.
  ///@param obj Object to store
  ///@return The current instance for call chaining
  ActionBar_Tab setTag(jni.JlObject obj) =>
      ActionBar_Tab.fromRef(_setTag(reference, obj.reference));

  static final _getTag = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_ActionBar__Tab_getTag")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.Object getTag()
  /// @return This Tab's tag object.
  jni.JlObject getTag() => jni.JlObject.fromRef(_getTag(reference));

  static final _setTabListener = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar__Tab_setTabListener")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.ActionBar.Tab setTabListener(android.app.ActionBar.TabListener listener)
  /// Set the TabListener that will handle switching to and from this tab.
  /// All tabs must have a TabListener set before being added to the ActionBar.
  ///@param listener Listener to handle tab selection events
  ///@return The current instance for call chaining
  ActionBar_Tab setTabListener(ActionBar_TabListener listener) =>
      ActionBar_Tab.fromRef(_setTabListener(reference, listener.reference));

  static final _select =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActionBar__Tab_select")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void select()
  /// Select this tab. Only valid if the tab has been added to the action bar.
  void select() => _select(reference);

  static final _setContentDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ActionBar__Tab_setContentDescription")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.ActionBar.Tab setContentDescription(int resId)
  /// Set a description of this tab's content for use in accessibility support.
  /// If no content description is provided the title will be used.
  ///@param resId A resource ID referring to the description text
  ///@return The current instance for call chaining
  ///@see \#setContentDescription(CharSequence)
  ///@see \#getContentDescription()
  ActionBar_Tab setContentDescription(int resId) =>
      ActionBar_Tab.fromRef(_setContentDescription(reference, resId));

  static final _setContentDescription_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar__Tab_setContentDescription_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.ActionBar.Tab setContentDescription(java.lang.CharSequence contentDesc)
  /// Set a description of this tab's content for use in accessibility support.
  /// If no content description is provided the title will be used.
  ///@param contentDesc Description of this tab's content
  ///@return The current instance for call chaining
  ///@see \#setContentDescription(int)
  ///@see \#getContentDescription()
  ActionBar_Tab setContentDescription_1(jni.JlObject contentDesc) =>
      ActionBar_Tab.fromRef(
          _setContentDescription_1(reference, contentDesc.reference));

  static final _getContentDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar__Tab_getContentDescription")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.CharSequence getContentDescription()
  /// Gets a brief description of this tab's content for use in accessibility support.
  ///@return Description of this tab's content
  ///@see \#setContentDescription(CharSequence)
  ///@see \#setContentDescription(int)
  jni.JlObject getContentDescription() =>
      jni.JlObject.fromRef(_getContentDescription(reference));
}

/// Listener interface for ActionBar navigation events.
///@deprecated Action bar navigation modes are deprecated and not supported by inline
/// toolbar action bars. Consider using other
/// <a href="http://developer.android.com/design/patterns/navigation.html">common
/// navigation patterns</a> instead.
class ActionBar_OnNavigationListener extends jni.JlObject {
  ActionBar_OnNavigationListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onNavigationItemSelected = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int64)>>(
          "android_app_ActionBar__OnNavigationListener_onNavigationItemSelected")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract boolean onNavigationItemSelected(int itemPosition, long itemId)
  /// This method is called whenever a navigation item in your action bar
  /// is selected.
  ///@param itemPosition Position of the item clicked.
  ///@param itemId ID of the item clicked.
  ///@return True if the event was handled, false otherwise.
  bool onNavigationItemSelected(int itemPosition, int itemId) =>
      _onNavigationItemSelected(reference, itemPosition, itemId) != 0;
}

/// Listener for receiving events when action bar menus are shown or hidden.
class ActionBar_OnMenuVisibilityListener extends jni.JlObject {
  ActionBar_OnMenuVisibilityListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onMenuVisibilityChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_ActionBar__OnMenuVisibilityListener_onMenuVisibilityChanged")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void onMenuVisibilityChanged(boolean isVisible)
  /// Called when an action bar menu is shown or hidden. Applications may want to use
  /// this to tune auto-hiding behavior for the action bar or pause/resume video playback,
  /// gameplay, or other activity within the main content area.
  ///@param isVisible True if an action bar menu is now visible, false if no action bar
  ///                  menus are visible.
  void onMenuVisibilityChanged(bool isVisible) =>
      _onMenuVisibilityChanged(reference, isVisible ? 1 : 0);
}

/// Per-child layout information associated with action bar custom views.
///@attr ref android.R.styleable\#ActionBar_LayoutParams_layout_gravity
class ActionBar_LayoutParams extends jni.JlObject {
  ActionBar_LayoutParams.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: public int gravity
  /// Gravity for the view associated with these LayoutParams.
  ///@see android.view.Gravity
  static final _getgravity = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActionBar__LayoutParams_gravity")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get gravity => _getgravity(reference);
  static final _setgravity = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActionBar__LayoutParams_gravity")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set gravity(int value) => _setgravity(reference, value);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar__LayoutParams_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context c, android.util.AttributeSet attrs)
  /// @param c This value must never be {@code null}.
  ActionBar_LayoutParams(content.Context c, jni.JlObject attrs)
      : super.fromRef(_ctor(c.reference, attrs.reference));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Int32,
                  ffi.Int32)>>("android_app_ActionBar__LayoutParams_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  /// from: public void <init>(int width, int height)
  ActionBar_LayoutParams.ctor_1(int width, int height)
      : super.fromRef(_ctor_1(width, height));

  static final _ctor_2 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Int32, ffi.Int32,
                  ffi.Int32)>>("android_app_ActionBar__LayoutParams_new_2")
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int)>();

  /// from: public void <init>(int width, int height, int gravity)
  ActionBar_LayoutParams.ctor_2(int width, int height, int gravity)
      : super.fromRef(_ctor_2(width, height, gravity));

  static final _ctor_3 =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int32)>>(
              "android_app_ActionBar__LayoutParams_new_3")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: public void <init>(int gravity)
  ActionBar_LayoutParams.ctor_3(int gravity) : super.fromRef(_ctor_3(gravity));

  static final _ctor_4 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar__LayoutParams_new_4")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.ActionBar.LayoutParams source)
  ActionBar_LayoutParams.ctor_4(ActionBar_LayoutParams source)
      : super.fromRef(_ctor_4(source.reference));

  static final _ctor_5 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActionBar__LayoutParams_new_5")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.view.ViewGroup.LayoutParams source)
  ActionBar_LayoutParams.ctor_5(jni.JlObject source)
      : super.fromRef(_ctor_5(source.reference));
}

/// A dialog showing a progress indicator and an optional text message or view.
/// Only a text message or a view can be used at the same time.
///
/// The dialog can be made cancelable on back key press.
///
///
/// The progress range is 0 to \#getMax() max.
///
///@deprecated <code>ProgressDialog</code> is a modal dialog, which prevents the
/// user from interacting with the app. Instead of using this class, you should
/// use a progress indicator like android.widget.ProgressBar, which can
/// be embedded in your app's UI. Alternatively, you can use a
/// <a href="/guide/topics/ui/notifiers/notifications.html">notification</a>
/// to inform the user of the task's progress.
class ProgressDialog extends AlertDialog {
  ProgressDialog.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int STYLE_HORIZONTAL
  /// Creates a ProgressDialog with a horizontal progress bar.
  static const STYLE_HORIZONTAL = 1;

  /// from: static public final int STYLE_SPINNER
  /// Creates a ProgressDialog with a circular, spinning progress
  /// bar. This is the default.
  static const STYLE_SPINNER = 0;

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_ProgressDialog_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  /// Creates a Progress dialog.
  ///@param context the parent context
  ProgressDialog(content.Context context)
      : super.fromRef(_ctor(context.reference));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ProgressDialog_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Context context, int theme)
  /// Creates a Progress dialog.
  ///@param context the parent context
  ///@param theme the resource ID of the theme against which to inflate
  ///              this dialog, or {@code 0} to use the parent
  ///              {@code context}'s default alert dialog theme
  ProgressDialog.ctor_1(content.Context context, int theme)
      : super.fromRef(_ctor_1(context.reference, theme));

  static final _onCreate = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ProgressDialog_onCreate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onCreate(android.os.Bundle savedInstanceState)
  void onCreate(os.Bundle savedInstanceState) =>
      _onCreate(reference, savedInstanceState.reference);

  static final _onStart =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ProgressDialog_onStart")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onStart()
  void onStart() => _onStart(reference);

  static final _onStop =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ProgressDialog_onStop")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStop()
  void onStop() => _onStop(reference);

  static final _setProgress = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ProgressDialog_setProgress")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setProgress(int value)
  /// Sets the current progress.
  ///@param value the current progress, a value between 0 and \#getMax()
  ///@see ProgressBar\#setProgress(int)
  void setProgress(int value) => _setProgress(reference, value);

  static final _setSecondaryProgress = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ProgressDialog_setSecondaryProgress")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setSecondaryProgress(int secondaryProgress)
  /// Sets the secondary progress.
  ///@param secondaryProgress the current secondary progress, a value between 0 and
  /// \#getMax()
  ///@see ProgressBar\#setSecondaryProgress(int)
  void setSecondaryProgress(int secondaryProgress) =>
      _setSecondaryProgress(reference, secondaryProgress);

  static final _getProgress =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ProgressDialog_getProgress")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getProgress()
  /// Gets the current progress.
  ///@return the current progress, a value between 0 and \#getMax()
  int getProgress() => _getProgress(reference);

  static final _getSecondaryProgress =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ProgressDialog_getSecondaryProgress")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getSecondaryProgress()
  /// Gets the current secondary progress.
  ///@return the current secondary progress, a value between 0 and \#getMax()
  int getSecondaryProgress() => _getSecondaryProgress(reference);

  static final _getMax =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ProgressDialog_getMax")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getMax()
  /// Gets the maximum allowed progress value. The default value is 100.
  ///@return the maximum value
  int getMax() => _getMax(reference);

  static final _setMax = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ProgressDialog_setMax")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setMax(int max)
  /// Sets the maximum allowed progress value.
  void setMax(int max) => _setMax(reference, max);

  static final _incrementProgressBy = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ProgressDialog_incrementProgressBy")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void incrementProgressBy(int diff)
  /// Increments the current progress value.
  ///@param diff the amount by which the current progress will be incremented,
  /// up to \#getMax()
  void incrementProgressBy(int diff) => _incrementProgressBy(reference, diff);

  static final _incrementSecondaryProgressBy = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ProgressDialog_incrementSecondaryProgressBy")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void incrementSecondaryProgressBy(int diff)
  /// Increments the current secondary progress value.
  ///@param diff the amount by which the current secondary progress will be incremented,
  /// up to \#getMax()
  void incrementSecondaryProgressBy(int diff) =>
      _incrementSecondaryProgressBy(reference, diff);

  static final _setProgressDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ProgressDialog_setProgressDrawable")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setProgressDrawable(android.graphics.drawable.Drawable d)
  /// Sets the drawable to be used to display the progress value.
  ///@param d the drawable to be used
  ///@see ProgressBar\#setProgressDrawable(Drawable)
  void setProgressDrawable(jni.JlObject d) =>
      _setProgressDrawable(reference, d.reference);

  static final _setIndeterminateDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ProgressDialog_setIndeterminateDrawable")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setIndeterminateDrawable(android.graphics.drawable.Drawable d)
  /// Sets the drawable to be used to display the indeterminate progress value.
  ///@param d the drawable to be used
  ///@see ProgressBar\#setProgressDrawable(Drawable)
  ///@see \#setIndeterminate(boolean)
  void setIndeterminateDrawable(jni.JlObject d) =>
      _setIndeterminateDrawable(reference, d.reference);

  static final _setIndeterminate = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_ProgressDialog_setIndeterminate")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setIndeterminate(boolean indeterminate)
  /// Change the indeterminate mode for this ProgressDialog. In indeterminate
  /// mode, the progress is ignored and the dialog shows an infinite
  /// animation instead.
  ///
  /// <strong>Note:</strong> A ProgressDialog with style \#STYLE_SPINNER
  /// is always indeterminate and will ignore this setting.
  ///
  ///@param indeterminate true to enable indeterminate mode, false otherwise
  ///@see \#setProgressStyle(int)
  void setIndeterminate(bool indeterminate) =>
      _setIndeterminate(reference, indeterminate ? 1 : 0);

  static final _isIndeterminate =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ProgressDialog_isIndeterminate")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isIndeterminate()
  /// Whether this ProgressDialog is in indeterminate mode.
  ///@return true if the dialog is in indeterminate mode, false otherwise
  bool isIndeterminate() => _isIndeterminate(reference) != 0;

  static final _setMessage = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ProgressDialog_setMessage")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setMessage(java.lang.CharSequence message)
  void setMessage(jni.JlObject message) =>
      _setMessage(reference, message.reference);

  static final _setProgressStyle = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ProgressDialog_setProgressStyle")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setProgressStyle(int style)
  /// Sets the style of this ProgressDialog, either \#STYLE_SPINNER or
  /// \#STYLE_HORIZONTAL. The default is \#STYLE_SPINNER.
  ///
  /// <strong>Note:</strong> A ProgressDialog with style \#STYLE_SPINNER
  /// is always indeterminate and will ignore the \#setIndeterminate(boolean) indeterminate setting.
  ///
  ///@param style the style of this ProgressDialog, either \#STYLE_SPINNER or
  /// \#STYLE_HORIZONTAL
  void setProgressStyle(int style) => _setProgressStyle(reference, style);

  static final _setProgressNumberFormat = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ProgressDialog_setProgressNumberFormat")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setProgressNumberFormat(java.lang.String format)
  /// Change the format of the small text showing current and maximum units
  /// of progress.  The default is "%1d/%2d".
  /// Should not be called during the number is progressing.
  ///@param format A string passed to String\#format String.format();
  /// use "%1d" for the current number and "%2d" for the maximum.  If null,
  /// nothing will be shown.
  void setProgressNumberFormat(jni.JlString format) =>
      _setProgressNumberFormat(reference, format.reference);

  static final _setProgressPercentFormat = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ProgressDialog_setProgressPercentFormat")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setProgressPercentFormat(java.text.NumberFormat format)
  /// Change the format of the small text showing the percentage of progress.
  /// The default is
  /// NumberFormat\#getPercentInstance() NumberFormat.getPercentageInstnace().
  /// Should not be called during the number is progressing.
  ///@param format An instance of a NumberFormat to generate the
  /// percentage text.  If null, nothing will be shown.
  void setProgressPercentFormat(jni.JlObject format) =>
      _setProgressPercentFormat(reference, format.reference);
}

/// A screen that contains and runs multiple embedded activities.
///@deprecated Use the new Fragment and FragmentManager APIs
/// instead; these are also
/// available on older platforms through the Android compatibility package.
class ActivityGroup extends Activity {
  ActivityGroup.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ActivityGroup_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ActivityGroup() : super.fromRef(_ctor());

  static final _ctor_1 =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Uint8)>>(
              "android_app_ActivityGroup_new_1")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: public void <init>(boolean singleActivityMode)
  ActivityGroup.ctor_1(bool singleActivityMode)
      : super.fromRef(_ctor_1(singleActivityMode ? 1 : 0));

  static final _onCreate = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_ActivityGroup_onCreate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onCreate(android.os.Bundle savedInstanceState)
  void onCreate(os.Bundle savedInstanceState) =>
      _onCreate(reference, savedInstanceState.reference);

  static final _onResume =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityGroup_onResume")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onResume()
  void onResume() => _onResume(reference);

  static final _onSaveInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityGroup_onSaveInstanceState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onSaveInstanceState(android.os.Bundle outState)
  void onSaveInstanceState(os.Bundle outState) =>
      _onSaveInstanceState(reference, outState.reference);

  static final _onPause =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityGroup_onPause")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPause()
  void onPause() => _onPause(reference);

  static final _onStop =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityGroup_onStop")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStop()
  void onStop() => _onStop(reference);

  static final _onDestroy =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityGroup_onDestroy")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onDestroy()
  void onDestroy() => _onDestroy(reference);

  static final _getCurrentActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityGroup_getCurrentActivity")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity getCurrentActivity()
  Activity getCurrentActivity() =>
      Activity.fromRef(_getCurrentActivity(reference));

  static final _getLocalActivityManager = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityGroup_getLocalActivityManager")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.LocalActivityManager getLocalActivityManager()
  LocalActivityManager getLocalActivityManager() =>
      LocalActivityManager.fromRef(_getLocalActivityManager(reference));
}

/// Listener provided in
/// Activity\#setEnterSharedElementCallback(SharedElementCallback) and
/// Activity\#setExitSharedElementCallback(SharedElementCallback) as well as
/// Fragment\#setEnterSharedElementCallback(SharedElementCallback) and
/// Fragment\#setExitSharedElementCallback(SharedElementCallback)
/// to monitor the Shared element transitions. The events can be used to customize Activity
/// and Fragment Transition behavior.
class SharedElementCallback extends jni.JlObject {
  SharedElementCallback.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_SharedElementCallback_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  SharedElementCallback() : super.fromRef(_ctor());

  static final _onSharedElementStart = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_SharedElementCallback_onSharedElementStart")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onSharedElementStart(java.util.List<java.lang.String> sharedElementNames, java.util.List<android.view.View> sharedElements, java.util.List<android.view.View> sharedElementSnapshots)
  /// In Activity Transitions, onSharedElementStart is called immediately before
  /// capturing the start of the shared element state on enter and reenter transitions and
  /// immediately before capturing the end of the shared element state for exit and return
  /// transitions.
  ///
  /// In Fragment Transitions, onSharedElementStart is called immediately before capturing the
  /// start state of all shared element transitions.
  ///
  /// This call can be used to adjust the transition start state by modifying the shared
  /// element Views. Note that no layout step will be executed between onSharedElementStart
  /// and the transition state capture.
  ///
  /// For Activity Transitions, any changes made in \#onSharedElementEnd(List, List, List)
  /// that are not updated during by layout should be corrected in onSharedElementStart for exit and
  /// return transitions. For example, rotation or scale will not be affected by layout and
  /// if changed in \#onSharedElementEnd(List, List, List), it will also have to be reset
  /// in onSharedElementStart again to correct the end state.
  ///@param sharedElementNames The names of the shared elements that were accepted into
  ///                           the View hierarchy.
  ///@param sharedElements The shared elements that are part of the View hierarchy.
  ///@param sharedElementSnapshots The Views containing snap shots of the shared element
  ///                               from the launching Window. These elements will not
  ///                               be part of the scene, but will be positioned relative
  ///                               to the Window decor View. This list is null for Fragment
  ///                               Transitions.
  void onSharedElementStart(jni.JlObject sharedElementNames,
          jni.JlObject sharedElements, jni.JlObject sharedElementSnapshots) =>
      _onSharedElementStart(reference, sharedElementNames.reference,
          sharedElements.reference, sharedElementSnapshots.reference);

  static final _onSharedElementEnd = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_SharedElementCallback_onSharedElementEnd")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onSharedElementEnd(java.util.List<java.lang.String> sharedElementNames, java.util.List<android.view.View> sharedElements, java.util.List<android.view.View> sharedElementSnapshots)
  /// In Activity Transitions, onSharedElementEnd is called immediately before
  /// capturing the end of the shared element state on enter and reenter transitions and
  /// immediately before capturing the start of the shared element state for exit and return
  /// transitions.
  ///
  /// In Fragment Transitions, onSharedElementEnd is called immediately before capturing the
  /// end state of all shared element transitions.
  ///
  /// This call can be used to adjust the transition end state by modifying the shared
  /// element Views. Note that no layout step will be executed between onSharedElementEnd
  /// and the transition state capture.
  ///
  /// Any changes made in \#onSharedElementStart(List, List, List) that are not updated
  /// during layout should be corrected in onSharedElementEnd. For example, rotation or scale
  /// will not be affected by layout and if changed in
  /// \#onSharedElementStart(List, List, List), it will also have to be reset in
  /// onSharedElementEnd again to correct the end state.
  ///@param sharedElementNames The names of the shared elements that were accepted into
  ///                           the View hierarchy.
  ///@param sharedElements The shared elements that are part of the View hierarchy.
  ///@param sharedElementSnapshots The Views containing snap shots of the shared element
  ///                               from the launching Window. These elements will not
  ///                               be part of the scene, but will be positioned relative
  ///                               to the Window decor View. This list will be null for
  ///                               Fragment Transitions.
  void onSharedElementEnd(jni.JlObject sharedElementNames,
          jni.JlObject sharedElements, jni.JlObject sharedElementSnapshots) =>
      _onSharedElementEnd(reference, sharedElementNames.reference,
          sharedElements.reference, sharedElementSnapshots.reference);

  static final _onRejectSharedElements = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_SharedElementCallback_onRejectSharedElements")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onRejectSharedElements(java.util.List<android.view.View> rejectedSharedElements)
  /// Called after \#onMapSharedElements(java.util.List, java.util.Map) when
  /// transferring shared elements in. Any shared elements that have no mapping will be in
  /// <var>rejectedSharedElements</var>. The elements remaining in
  /// <var>rejectedSharedElements</var> will be transitioned out of the Scene. If a
  /// View is removed from <var>rejectedSharedElements</var>, it must be handled by the
  /// <code>SharedElementCallback</code>.
  ///
  /// Views in rejectedSharedElements will have their position and size set to the
  /// position of the calling shared element, relative to the Window decor View and contain
  /// snapshots of the View from the calling Activity or Fragment. This
  /// view may be safely added to the decor View's overlay to remain in position.
  ///
  ///
  /// This method is not called for Fragment Transitions. All rejected shared elements
  /// will be handled by the exit transition.
  ///
  ///@param rejectedSharedElements Views containing visual information of shared elements
  ///                               that are not part of the entering scene. These Views
  ///                               are positioned relative to the Window decor View. A
  ///                               View removed from this list will not be transitioned
  ///                               automatically.
  void onRejectSharedElements(jni.JlObject rejectedSharedElements) =>
      _onRejectSharedElements(reference, rejectedSharedElements.reference);

  static final _onMapSharedElements = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_SharedElementCallback_onMapSharedElements")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onMapSharedElements(java.util.List<java.lang.String> names, java.util.Map<java.lang.String,android.view.View> sharedElements)
  /// Lets the SharedElementCallback adjust the mapping of shared element names to
  /// Views.
  ///@param names The names of all shared elements transferred from the calling Activity
  ///              or Fragment in the order they were provided.
  ///@param sharedElements The mapping of shared element names to Views. The best guess
  ///                       will be filled into sharedElements based on the transitionNames.
  void onMapSharedElements(jni.JlObject names, jni.JlObject sharedElements) =>
      _onMapSharedElements(
          reference, names.reference, sharedElements.reference);

  static final _onCaptureSharedElementSnapshot = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_SharedElementCallback_onCaptureSharedElementSnapshot")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Parcelable onCaptureSharedElementSnapshot(android.view.View sharedElement, android.graphics.Matrix viewToGlobalMatrix, android.graphics.RectF screenBounds)
  /// Creates a snapshot of a shared element to be used by the remote Activity and reconstituted
  /// with \#onCreateSnapshotView(android.content.Context, android.os.Parcelable). A
  /// null return value will mean that the remote Activity will have a null snapshot View in
  /// \#onSharedElementStart(java.util.List, java.util.List, java.util.List) and
  /// \#onSharedElementEnd(java.util.List, java.util.List, java.util.List).
  ///
  /// This is not called for Fragment Transitions.
  ///
  ///@param sharedElement The shared element View to create a snapshot for.
  ///@param viewToGlobalMatrix A matrix containing a transform from the view to the screen
  ///                           coordinates.
  ///@param screenBounds The bounds of shared element in screen coordinate space. This is
  ///                     the bounds of the view with the viewToGlobalMatrix applied.
  ///@return A snapshot to send to the remote Activity to be reconstituted with
  /// \#onCreateSnapshotView(android.content.Context, android.os.Parcelable) and passed
  /// into \#onSharedElementStart(java.util.List, java.util.List, java.util.List) and
  /// \#onSharedElementEnd(java.util.List, java.util.List, java.util.List).
  os.Parcelable onCaptureSharedElementSnapshot(jni.JlObject sharedElement,
          jni.JlObject viewToGlobalMatrix, jni.JlObject screenBounds) =>
      os.Parcelable.fromRef(_onCaptureSharedElementSnapshot(
          reference,
          sharedElement.reference,
          viewToGlobalMatrix.reference,
          screenBounds.reference));

  static final _onCreateSnapshotView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_SharedElementCallback_onCreateSnapshotView")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View onCreateSnapshotView(android.content.Context context, android.os.Parcelable snapshot)
  /// Reconstitutes a snapshot View from a Parcelable returned in
  /// \#onCaptureSharedElementSnapshot(android.view.View, android.graphics.Matrix,
  /// android.graphics.RectF) to be used in \#onSharedElementStart(java.util.List,
  /// java.util.List, java.util.List) and \#onSharedElementEnd(java.util.List,
  /// java.util.List, java.util.List). The returned View will be sized and positioned after
  /// this call so that it is ready to be added to the decor View's overlay.
  ///
  /// This is not called for Fragment Transitions.
  ///
  ///@param context The Context used to create the snapshot View.
  ///@param snapshot The Parcelable returned by \#onCaptureSharedElementSnapshot(
  /// android.view.View, android.graphics.Matrix, android.graphics.RectF).
  ///@return A View to be sent in \#onSharedElementStart(java.util.List, java.util.List,
  /// java.util.List) and \#onSharedElementEnd(java.util.List, java.util.List,
  /// java.util.List). A null value will produce a null snapshot value for those two methods.
  jni.JlObject onCreateSnapshotView(
          content.Context context, os.Parcelable snapshot) =>
      jni.JlObject.fromRef(_onCreateSnapshotView(
          reference, context.reference, snapshot.reference));

  static final _onSharedElementsArrived = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_SharedElementCallback_onSharedElementsArrived")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onSharedElementsArrived(java.util.List<java.lang.String> sharedElementNames, java.util.List<android.view.View> sharedElements, android.app.SharedElementCallback.OnSharedElementsReadyListener listener)
  /// Called during an Activity Transition when the shared elements have arrived at the
  /// final location and are ready to be transferred. This method is called for both the
  /// source and destination Activities.
  ///
  /// When the shared elements are ready to be transferred,
  /// OnSharedElementsReadyListener\#onSharedElementsReady()
  /// must be called to trigger the transfer.
  ///
  /// The default behavior is to trigger the transfer immediately.
  ///@param sharedElementNames The names of the shared elements that are being transferred..
  ///@param sharedElements The shared elements that are part of the View hierarchy.
  ///@param listener The listener to call when the shared elements are ready to be hidden
  ///                 in the source Activity or shown in the destination Activity.
  void onSharedElementsArrived(
          jni.JlObject sharedElementNames,
          jni.JlObject sharedElements,
          SharedElementCallback_OnSharedElementsReadyListener listener) =>
      _onSharedElementsArrived(reference, sharedElementNames.reference,
          sharedElements.reference, listener.reference);
}

/// Listener to be called after SharedElementCallback\#onSharedElementsArrived(List, List, OnSharedElementsReadyListener)
/// when the shared elements are ready to be hidden in the source Activity and shown in the
/// destination Activity.
class SharedElementCallback_OnSharedElementsReadyListener extends jni.JlObject {
  SharedElementCallback_OnSharedElementsReadyListener.fromRef(
      ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onSharedElementsReady = jlookup<
              ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_SharedElementCallback__OnSharedElementsReadyListener_onSharedElementsReady")
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onSharedElementsReady()
  /// Call this method during or after the OnSharedElementsReadyListener has been received
  /// in SharedElementCallback\#onSharedElementsArrived(List, List,
  /// OnSharedElementsReadyListener) to indicate that the shared elements are ready to be
  /// hidden in the source and shown in the destination Activity.
  void onSharedElementsReady() => _onSharedElementsReady(reference);
}

/// Provides access to the system wallpaper. With WallpaperManager, you can
/// get the current wallpaper, get the desired dimensions for the wallpaper, set
/// the wallpaper, and more.
///
///  An app can check whether wallpapers are supported for the current user, by calling
/// \#isWallpaperSupported(), and whether setting of wallpapers is allowed, by calling
/// \#isSetWallpaperAllowed().
class WallpaperManager extends jni.JlObject {
  WallpaperManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_CHANGE_LIVE_WALLPAPER
  /// Directly launch live wallpaper preview, allowing the user to immediately
  /// confirm to switch to a specific live wallpaper.  You must specify
  /// \#EXTRA_LIVE_WALLPAPER_COMPONENT with the ComponentName of
  /// a live wallpaper component that is to be shown.
  static const ACTION_CHANGE_LIVE_WALLPAPER =
      "android.service.wallpaper.CHANGE_LIVE_WALLPAPER";

  /// from: static public final java.lang.String ACTION_CROP_AND_SET_WALLPAPER
  /// Activity Action: Show settings for choosing wallpaper. Do not use directly to construct
  /// an intent; instead, use \#getCropAndSetWallpaperIntent.
  /// Input:  Intent\#getData is the URI of the image to crop and set as wallpaper.
  /// Output: RESULT_OK if user decided to crop/set the wallpaper, RESULT_CANCEL otherwise
  /// Activities that support this intent should specify a MIME filter of "image/*"
  static const ACTION_CROP_AND_SET_WALLPAPER =
      "android.service.wallpaper.CROP_AND_SET_WALLPAPER";

  /// from: static public final java.lang.String ACTION_LIVE_WALLPAPER_CHOOSER
  /// Launch an activity for the user to pick the current global live
  /// wallpaper.
  static const ACTION_LIVE_WALLPAPER_CHOOSER =
      "android.service.wallpaper.LIVE_WALLPAPER_CHOOSER";

  /// from: static public final java.lang.String COMMAND_DROP
  /// Command for \#sendWallpaperCommand: reported by the wallpaper
  /// host when the user drops an object into an area of the host.  The x
  /// and y arguments are the location of the drop.
  static const COMMAND_DROP = "android.home.drop";

  /// from: static public final java.lang.String COMMAND_SECONDARY_TAP
  /// Command for \#sendWallpaperCommand: reported by the wallpaper
  /// host when the user releases a secondary pointer on an empty area
  /// (not performing an action in the host).  The x and y arguments are
  /// the location of the secondary tap in screen coordinates.
  static const COMMAND_SECONDARY_TAP = "android.wallpaper.secondaryTap";

  /// from: static public final java.lang.String COMMAND_TAP
  /// Command for \#sendWallpaperCommand: reported by the wallpaper
  /// host when the user taps on an empty area (not performing an action
  /// in the host).  The x and y arguments are the location of the tap in
  /// screen coordinates.
  static const COMMAND_TAP = "android.wallpaper.tap";

  /// from: static public final java.lang.String EXTRA_LIVE_WALLPAPER_COMPONENT
  /// Extra in \#ACTION_CHANGE_LIVE_WALLPAPER that specifies the
  /// ComponentName of a live wallpaper that should be shown as a preview,
  /// for the user to confirm.
  static const EXTRA_LIVE_WALLPAPER_COMPONENT =
      "android.service.wallpaper.extra.LIVE_WALLPAPER_COMPONENT";

  /// from: static public final int FLAG_LOCK
  /// Flag: set or retrieve the lock-screen-specific wallpaper.
  static const FLAG_LOCK = 2;

  /// from: static public final int FLAG_SYSTEM
  /// Flag: set or retrieve the general system wallpaper.
  static const FLAG_SYSTEM = 1;

  /// from: static public final java.lang.String WALLPAPER_PREVIEW_META_DATA
  /// Manifest entry for activities that respond to Intent\#ACTION_SET_WALLPAPER
  /// which allows them to provide a custom large icon associated with this action.
  static const WALLPAPER_PREVIEW_META_DATA = "android.wallpaper.preview";

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_WallpaperManager_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  WallpaperManager() : super.fromRef(_ctor());

  static final _getInstance = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperManager_getInstance")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.WallpaperManager getInstance(android.content.Context context)
  /// Retrieve a WallpaperManager associated with the given Context.
  static WallpaperManager getInstance(content.Context context) =>
      WallpaperManager.fromRef(_getInstance(context.reference));

  static final _getDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperManager_getDrawable")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable getDrawable()
  /// Retrieve the current system wallpaper; if
  /// no wallpaper is set, the system built-in static wallpaper is returned.
  /// This is returned as an
  /// abstract Drawable that you can install in a View to display whatever
  /// wallpaper the user has currently set.
  ///
  /// This method can return null if there is no system wallpaper available, if
  /// wallpapers are not supported in the current user, or if the calling app is not
  /// permitted to access the system wallpaper.
  ///@return Returns a Drawable object that will draw the system wallpaper,
  ///     or {@code null} if no system wallpaper exists or if the calling application
  ///     is not able to access the wallpaper.
  jni.JlObject getDrawable() => jni.JlObject.fromRef(_getDrawable(reference));

  static final _getBuiltInDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperManager_getBuiltInDrawable")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable getBuiltInDrawable()
  /// Obtain a drawable for the built-in static system wallpaper.
  jni.JlObject getBuiltInDrawable() =>
      jni.JlObject.fromRef(_getBuiltInDrawable(reference));

  static final _getBuiltInDrawable_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_WallpaperManager_getBuiltInDrawable_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.drawable.Drawable getBuiltInDrawable(int which)
  /// Obtain a drawable for the specified built-in static system wallpaper.
  ///@param which The {@code FLAG_*} identifier of a valid wallpaper type.  Throws
  ///     IllegalArgumentException if an invalid wallpaper is requested.
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@return A Drawable presenting the specified wallpaper image, or {@code null}
  ///     if no built-in default image for that wallpaper type exists.
  jni.JlObject getBuiltInDrawable_1(int which) =>
      jni.JlObject.fromRef(_getBuiltInDrawable_1(reference, which));

  static final _getBuiltInDrawable_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Int32, ffi.Uint8, ffi.Float, ffi.Float)>>(
          "android_app_WallpaperManager_getBuiltInDrawable_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, int, int, double, double)>();

  /// from: public android.graphics.drawable.Drawable getBuiltInDrawable(int outWidth, int outHeight, boolean scaleToFit, float horizontalAlignment, float verticalAlignment)
  /// Returns a drawable for the system built-in static wallpaper. Based on the parameters, the
  /// drawable can be cropped and scaled
  ///@param outWidth The width of the returned drawable
  ///@param outWidth The height of the returned drawable
  ///@param scaleToFit If true, scale the wallpaper down rather than just cropping it
  ///@param horizontalAlignment A float value between 0 and 1 specifying where to crop the image;
  ///        0 for left-aligned, 0.5 for horizontal center-aligned, and 1 for right-aligned
  ///@param verticalAlignment A float value between 0 and 1 specifying where to crop the image;
  ///        0 for top-aligned, 0.5 for vertical center-aligned, and 1 for bottom-aligned
  ///@return A Drawable presenting the built-in default system wallpaper image,
  ///        or {@code null} if no such default image is defined on this device.
  jni.JlObject getBuiltInDrawable_2(
          int outWidth,
          int outHeight,
          bool scaleToFit,
          double horizontalAlignment,
          double verticalAlignment) =>
      jni.JlObject.fromRef(_getBuiltInDrawable_2(reference, outWidth, outHeight,
          scaleToFit ? 1 : 0, horizontalAlignment, verticalAlignment));

  static final _getBuiltInDrawable_3 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Uint8,
                      ffi.Float,
                      ffi.Float,
                      ffi.Int32)>>(
          "android_app_WallpaperManager_getBuiltInDrawable_3")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, int, int, double, double, int)>();

  /// from: public android.graphics.drawable.Drawable getBuiltInDrawable(int outWidth, int outHeight, boolean scaleToFit, float horizontalAlignment, float verticalAlignment, int which)
  /// Returns a drawable for the built-in static wallpaper of the specified type.  Based on the
  /// parameters, the drawable can be cropped and scaled.
  ///@param outWidth The width of the returned drawable
  ///@param outWidth The height of the returned drawable
  ///@param scaleToFit If true, scale the wallpaper down rather than just cropping it
  ///@param horizontalAlignment A float value between 0 and 1 specifying where to crop the image;
  ///        0 for left-aligned, 0.5 for horizontal center-aligned, and 1 for right-aligned
  ///@param verticalAlignment A float value between 0 and 1 specifying where to crop the image;
  ///        0 for top-aligned, 0.5 for vertical center-aligned, and 1 for bottom-aligned
  ///@param which The {@code FLAG_*} identifier of a valid wallpaper type.  Throws
  ///     IllegalArgumentException if an invalid wallpaper is requested.
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@return A Drawable presenting the built-in default wallpaper image of the given type,
  ///        or {@code null} if no default image of that type is defined on this device.
  jni.JlObject getBuiltInDrawable_3(
          int outWidth,
          int outHeight,
          bool scaleToFit,
          double horizontalAlignment,
          double verticalAlignment,
          int which) =>
      jni.JlObject.fromRef(_getBuiltInDrawable_3(reference, outWidth, outHeight,
          scaleToFit ? 1 : 0, horizontalAlignment, verticalAlignment, which));

  static final _peekDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperManager_peekDrawable")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable peekDrawable()
  /// Retrieve the current system wallpaper; if there is no wallpaper set,
  /// a null pointer is returned. This is returned as an
  /// abstract Drawable that you can install in a View to display whatever
  /// wallpaper the user has currently set.
  ///@return Returns a Drawable object that will draw the wallpaper or a
  /// null pointer if these is none.
  jni.JlObject peekDrawable() => jni.JlObject.fromRef(_peekDrawable(reference));

  static final _getFastDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperManager_getFastDrawable")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable getFastDrawable()
  /// Like \#getDrawable(), but the returned Drawable has a number
  /// of limitations to reduce its overhead as much as possible. It will
  /// never scale the wallpaper (only centering it if the requested bounds
  /// do match the bitmap bounds, which should not be typical), doesn't
  /// allow setting an alpha, color filter, or other attributes, etc.  The
  /// bounds of the returned drawable will be initialized to the same bounds
  /// as the wallpaper, so normally you will not need to touch it.  The
  /// drawable also assumes that it will be used in a context running in
  /// the same density as the screen (not in density compatibility mode).
  ///
  /// Requires android.Manifest.permission\#READ_EXTERNAL_STORAGE
  ///@return Returns a Drawable object that will draw the wallpaper.
  jni.JlObject getFastDrawable() =>
      jni.JlObject.fromRef(_getFastDrawable(reference));

  static final _peekFastDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperManager_peekFastDrawable")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable peekFastDrawable()
  /// Like \#getFastDrawable(), but if there is no wallpaper set,
  /// a null pointer is returned.
  ///
  /// Requires android.Manifest.permission\#READ_EXTERNAL_STORAGE
  ///@return Returns an optimized Drawable object that will draw the
  /// wallpaper or a null pointer if these is none.
  jni.JlObject peekFastDrawable() =>
      jni.JlObject.fromRef(_peekFastDrawable(reference));

  static final _getWallpaperFile = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_WallpaperManager_getWallpaperFile")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.os.ParcelFileDescriptor getWallpaperFile(int which)
  /// Get an open, readable file descriptor to the given wallpaper image file.
  /// The caller is responsible for closing the file descriptor when done ingesting the file.
  ///
  /// If no lock-specific wallpaper has been configured for the given user, then
  /// this method will return {@code null} when requesting \#FLAG_LOCK rather than
  /// returning the system wallpaper's image file.
  ///
  /// Requires android.Manifest.permission\#READ_EXTERNAL_STORAGE
  ///@param which The wallpaper whose image file is to be retrieved.  Must be a single
  ///     defined kind of wallpaper, either \#FLAG_SYSTEM or
  ///     \#FLAG_LOCK.
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@return An open, readable file desriptor to the requested wallpaper image file;
  ///     or {@code null} if no such wallpaper is configured or if the calling app does
  ///     not have permission to read the current wallpaper.
  ///@see \#FLAG_LOCK
  ///@see \#FLAG_SYSTEM
  os.ParcelFileDescriptor getWallpaperFile(int which) =>
      os.ParcelFileDescriptor.fromRef(_getWallpaperFile(reference, which));

  static final _addOnColorsChangedListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperManager_addOnColorsChangedListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void addOnColorsChangedListener(android.app.WallpaperManager.OnColorsChangedListener listener, android.os.Handler handler)
  /// Registers a listener to get notified when the wallpaper colors change.
  ///@param listener A listener to register
  /// This value must never be {@code null}.
  ///@param handler Where to call it from. Will be called from the main thread
  ///                if null.
  ///
  /// This value must never be {@code null}.
  void addOnColorsChangedListener(
          WallpaperManager_OnColorsChangedListener listener,
          os.Handler handler) =>
      _addOnColorsChangedListener(
          reference, listener.reference, handler.reference);

  static final _removeOnColorsChangedListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperManager_removeOnColorsChangedListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void removeOnColorsChangedListener(android.app.WallpaperManager.OnColorsChangedListener callback)
  /// Stop listening to color updates.
  ///@param callback A callback to unsubscribe.
  ///
  /// This value must never be {@code null}.
  void removeOnColorsChangedListener(
          WallpaperManager_OnColorsChangedListener callback) =>
      _removeOnColorsChangedListener(reference, callback.reference);

  static final _getWallpaperColors = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_WallpaperManager_getWallpaperColors")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.WallpaperColors getWallpaperColors(int which)
  /// Get the primary colors of a wallpaper.
  ///
  /// This method can return {@code null} when:
  /// <ul>
  /// <li>Colors are still being processed by the system.</li>
  /// <li>The user has chosen to use a live wallpaper:  live wallpapers might not
  /// implement
  /// android.service.wallpaper.WallpaperService.Engine\#onComputeColors() WallpaperService.Engine\#onComputeColors().</li>
  /// </ul>
  ///@param which Wallpaper type. Must be either \#FLAG_SYSTEM or
  ///     \#FLAG_LOCK.
  ///@return Current WallpaperColors or null if colors are unknown.
  ///@see \#addOnColorsChangedListener(OnColorsChangedListener, Handler)
  WallpaperColors getWallpaperColors(int which) =>
      WallpaperColors.fromRef(_getWallpaperColors(reference, which));

  static final _forgetLoadedWallpaper =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_WallpaperManager_forgetLoadedWallpaper")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void forgetLoadedWallpaper()
  /// Remove all internal references to the last loaded wallpaper.  Useful
  /// for apps that want to reduce memory usage when they only temporarily
  /// need to have the wallpaper.  After calling, the next request for the
  /// wallpaper will require reloading it again from disk.
  void forgetLoadedWallpaper() => _forgetLoadedWallpaper(reference);

  static final _getWallpaperInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperManager_getWallpaperInfo")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.WallpaperInfo getWallpaperInfo()
  /// If the current wallpaper is a live wallpaper component, return the
  /// information about that wallpaper.  Otherwise, if it is a static image,
  /// simply return null.
  WallpaperInfo getWallpaperInfo() =>
      WallpaperInfo.fromRef(_getWallpaperInfo(reference));

  static final _getWallpaperId = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_WallpaperManager_getWallpaperId")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getWallpaperId(int which)
  /// Get the ID of the current wallpaper of the given kind.  If there is no
  /// such wallpaper configured, returns a negative number.
  ///
  /// Every time the wallpaper image is set, a new ID is assigned to it.
  /// This method allows the caller to determine whether the wallpaper imagery
  /// has changed, regardless of how that change happened.
  ///@param which The wallpaper whose ID is to be returned.  Must be a single
  ///     defined kind of wallpaper, either \#FLAG_SYSTEM or
  ///     \#FLAG_LOCK.
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@return The positive numeric ID of the current wallpaper of the given kind,
  ///     or a negative value if no such wallpaper is configured.
  int getWallpaperId(int which) => _getWallpaperId(reference, which);

  static final _getCropAndSetWallpaperIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperManager_getCropAndSetWallpaperIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent getCropAndSetWallpaperIntent(android.net.Uri imageUri)
  /// Gets an Intent that will launch an activity that crops the given
  /// image and sets the device's wallpaper. If there is a default HOME activity
  /// that supports cropping wallpapers, it will be preferred as the default.
  /// Use this method instead of directly creating a \#ACTION_CROP_AND_SET_WALLPAPER
  /// intent.
  ///@param imageUri The image URI that will be set in the intent. The must be a content
  ///                 URI and its provider must resolve its type to "image/*"
  ///@throws IllegalArgumentException if the URI is not a content URI or its MIME type is
  ///         not "image/*"
  content.Intent getCropAndSetWallpaperIntent(jni.JlObject imageUri) =>
      content.Intent.fromRef(
          _getCropAndSetWallpaperIntent(reference, imageUri.reference));

  static final _setResource = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_WallpaperManager_setResource")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setResource(int resid)
  /// Change the current system wallpaper to the bitmap in the given resource.
  /// The resource is opened as a raw data stream and copied into the
  /// wallpaper; it must be a valid PNG or JPEG image.  On success, the intent
  /// Intent\#ACTION_WALLPAPER_CHANGED is broadcast.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param resid The resource ID of the bitmap to be used as the wallpaper image
  ///@throws IOException If an error occurs reverting to the built-in
  /// wallpaper.
  void setResource(int resid) => _setResource(reference, resid);

  static final _setResource_1 = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_app_WallpaperManager_setResource_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int setResource(int resid, int which)
  /// Version of \#setResource(int) that allows the caller to specify which
  /// of the supported wallpaper categories to set.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param resid The resource ID of the bitmap to be used as the wallpaper image
  ///@param which Flags indicating which wallpaper(s) to configure with the new imagery
  ///
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@see \#FLAG_LOCK
  ///@see \#FLAG_SYSTEM
  ///@return An integer ID assigned to the newly active wallpaper; or zero on failure.
  ///@throws IOException
  int setResource_1(int resid, int which) =>
      _setResource_1(reference, resid, which);

  static final _setBitmap = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperManager_setBitmap")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setBitmap(android.graphics.Bitmap bitmap)
  /// Change the current system wallpaper to a bitmap.  The given bitmap is
  /// converted to a PNG and stored as the wallpaper.  On success, the intent
  /// Intent\#ACTION_WALLPAPER_CHANGED is broadcast.
  ///
  /// This method is equivalent to calling
  /// \#setBitmap(Bitmap, Rect, boolean) and passing {@code null} for the
  /// {@code visibleCrop} rectangle and {@code true} for the {@code allowBackup}
  /// parameter.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param bitmap The bitmap to be used as the new system wallpaper.
  ///@throws IOException If an error occurs when attempting to set the wallpaper
  ///     to the provided image.
  void setBitmap(jni.JlObject bitmap) =>
      _setBitmap(reference, bitmap.reference);

  static final _setBitmap_1 = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_WallpaperManager_setBitmap_1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public int setBitmap(android.graphics.Bitmap fullImage, android.graphics.Rect visibleCropHint, boolean allowBackup)
  /// Change the current system wallpaper to a bitmap, specifying a hint about
  /// which subrectangle of the full image is to be visible.  The OS will then
  /// try to best present the given portion of the full image as the static system
  /// wallpaper image.  On success, the intent
  /// Intent\#ACTION_WALLPAPER_CHANGED is broadcast.
  ///
  /// Passing {@code null} as the {@code visibleHint} parameter is equivalent to
  /// passing (0, 0, {@code fullImage.getWidth()}, {@code fullImage.getHeight()}).
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param fullImage A bitmap that will supply the wallpaper imagery.
  ///@param visibleCropHint The rectangular subregion of {@code fullImage} that should be
  ///     displayed as wallpaper.  Passing {@code null} for this parameter means that
  ///     the full image should be displayed if possible given the image's and device's
  ///     aspect ratios, etc.
  ///@param allowBackup {@code true} if the OS is permitted to back up this wallpaper
  ///     image for restore to a future device; {@code false} otherwise.
  ///@return An integer ID assigned to the newly active wallpaper; or zero on failure.
  ///@throws IOException If an error occurs when attempting to set the wallpaper
  ///     to the provided image.
  ///@throws IllegalArgumentException If the {@code visibleCropHint} rectangle is
  ///     empty or invalid.
  int setBitmap_1(jni.JlObject fullImage, jni.JlObject visibleCropHint,
          bool allowBackup) =>
      _setBitmap_1(reference, fullImage.reference, visibleCropHint.reference,
          allowBackup ? 1 : 0);

  static final _setBitmap_2 = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Int32)>>("android_app_WallpaperManager_setBitmap_2")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int setBitmap(android.graphics.Bitmap fullImage, android.graphics.Rect visibleCropHint, boolean allowBackup, int which)
  /// Version of \#setBitmap(Bitmap, Rect, boolean) that allows the caller
  /// to specify which of the supported wallpaper categories to set.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param fullImage A bitmap that will supply the wallpaper imagery.
  ///@param visibleCropHint The rectangular subregion of {@code fullImage} that should be
  ///     displayed as wallpaper.  Passing {@code null} for this parameter means that
  ///     the full image should be displayed if possible given the image's and device's
  ///     aspect ratios, etc.
  ///@param allowBackup {@code true} if the OS is permitted to back up this wallpaper
  ///     image for restore to a future device; {@code false} otherwise.
  ///@param which Flags indicating which wallpaper(s) to configure with the new imagery.
  ///
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@see \#FLAG_LOCK
  ///@see \#FLAG_SYSTEM
  ///@return An integer ID assigned to the newly active wallpaper; or zero on failure.
  ///@throws IOException
  int setBitmap_2(jni.JlObject fullImage, jni.JlObject visibleCropHint,
          bool allowBackup, int which) =>
      _setBitmap_2(reference, fullImage.reference, visibleCropHint.reference,
          allowBackup ? 1 : 0, which);

  static final _setStream = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperManager_setStream")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setStream(java.io.InputStream bitmapData)
  /// Change the current system wallpaper to a specific byte stream.  The
  /// give InputStream is copied into persistent storage and will now be
  /// used as the wallpaper.  Currently it must be either a JPEG or PNG
  /// image.  On success, the intent Intent\#ACTION_WALLPAPER_CHANGED
  /// is broadcast.
  ///
  /// This method is equivalent to calling
  /// \#setStream(InputStream, Rect, boolean) and passing {@code null} for the
  /// {@code visibleCrop} rectangle and {@code true} for the {@code allowBackup}
  /// parameter.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param bitmapData A stream containing the raw data to install as a wallpaper.  This
  ///     data can be in any format handled by BitmapRegionDecoder.
  ///@throws IOException If an error occurs when attempting to set the wallpaper
  ///     based on the provided image data.
  void setStream(jni.JlObject bitmapData) =>
      _setStream(reference, bitmapData.reference);

  static final _setStream_1 = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_WallpaperManager_setStream_1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public int setStream(java.io.InputStream bitmapData, android.graphics.Rect visibleCropHint, boolean allowBackup)
  /// Change the current system wallpaper to a specific byte stream, specifying a
  /// hint about which subrectangle of the full image is to be visible.  The OS will
  /// then try to best present the given portion of the full image as the static system
  /// wallpaper image.  The data from the given InputStream is copied into persistent
  /// storage and will then be used as the system wallpaper.  Currently the data must
  /// be either a JPEG or PNG image.  On success, the intent
  /// Intent\#ACTION_WALLPAPER_CHANGED is broadcast.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param bitmapData A stream containing the raw data to install as a wallpaper.  This
  ///     data can be in any format handled by BitmapRegionDecoder.
  ///@param visibleCropHint The rectangular subregion of the streamed image that should be
  ///     displayed as wallpaper.  Passing {@code null} for this parameter means that
  ///     the full image should be displayed if possible given the image's and device's
  ///     aspect ratios, etc.
  ///@param allowBackup {@code true} if the OS is permitted to back up this wallpaper
  ///     image for restore to a future device; {@code false} otherwise.
  ///@return An integer ID assigned to the newly active wallpaper; or zero on failure.
  ///@see \#getWallpaperId(int)
  ///@throws IOException If an error occurs when attempting to set the wallpaper
  ///     based on the provided image data.
  ///@throws IllegalArgumentException If the {@code visibleCropHint} rectangle is
  ///     empty or invalid.
  int setStream_1(jni.JlObject bitmapData, jni.JlObject visibleCropHint,
          bool allowBackup) =>
      _setStream_1(reference, bitmapData.reference, visibleCropHint.reference,
          allowBackup ? 1 : 0);

  static final _setStream_2 = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Int32)>>("android_app_WallpaperManager_setStream_2")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int setStream(java.io.InputStream bitmapData, android.graphics.Rect visibleCropHint, boolean allowBackup, int which)
  /// Version of \#setStream(InputStream, Rect, boolean) that allows the caller
  /// to specify which of the supported wallpaper categories to set.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param bitmapData A stream containing the raw data to install as a wallpaper.  This
  ///     data can be in any format handled by BitmapRegionDecoder.
  ///@param visibleCropHint The rectangular subregion of the streamed image that should be
  ///     displayed as wallpaper.  Passing {@code null} for this parameter means that
  ///     the full image should be displayed if possible given the image's and device's
  ///     aspect ratios, etc.
  ///@param allowBackup {@code true} if the OS is permitted to back up this wallpaper
  ///     image for restore to a future device; {@code false} otherwise.
  ///@param which Flags indicating which wallpaper(s) to configure with the new imagery.
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@return An integer ID assigned to the newly active wallpaper; or zero on failure.
  ///@see \#getWallpaperId(int)
  ///@see \#FLAG_LOCK
  ///@see \#FLAG_SYSTEM
  ///@throws IOException
  int setStream_2(jni.JlObject bitmapData, jni.JlObject visibleCropHint,
          bool allowBackup, int which) =>
      _setStream_2(reference, bitmapData.reference, visibleCropHint.reference,
          allowBackup ? 1 : 0, which);

  static final _hasResourceWallpaper = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_WallpaperManager_hasResourceWallpaper")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean hasResourceWallpaper(int resid)
  /// Return whether any users are currently set to use the wallpaper
  /// with the given resource ID.  That is, their wallpaper has been
  /// set through \#setResource(int) with the same resource id.
  bool hasResourceWallpaper(int resid) =>
      _hasResourceWallpaper(reference, resid) != 0;

  static final _getDesiredMinimumWidth =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_WallpaperManager_getDesiredMinimumWidth")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getDesiredMinimumWidth()
  /// Returns the desired minimum width for the wallpaper. Callers of
  /// \#setBitmap(android.graphics.Bitmap) or
  /// \#setStream(java.io.InputStream) should check this value
  /// beforehand to make sure the supplied wallpaper respects the desired
  /// minimum width.
  ///
  /// If the returned value is <= 0, the caller should use the width of
  /// the default display instead.
  ///@return The desired minimum width for the wallpaper. This value should
  /// be honored by applications that set the wallpaper but it is not
  /// mandatory.
  int getDesiredMinimumWidth() => _getDesiredMinimumWidth(reference);

  static final _getDesiredMinimumHeight =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_WallpaperManager_getDesiredMinimumHeight")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getDesiredMinimumHeight()
  /// Returns the desired minimum height for the wallpaper. Callers of
  /// \#setBitmap(android.graphics.Bitmap) or
  /// \#setStream(java.io.InputStream) should check this value
  /// beforehand to make sure the supplied wallpaper respects the desired
  /// minimum height.
  ///
  /// If the returned value is <= 0, the caller should use the height of
  /// the default display instead.
  ///@return The desired minimum height for the wallpaper. This value should
  /// be honored by applications that set the wallpaper but it is not
  /// mandatory.
  int getDesiredMinimumHeight() => _getDesiredMinimumHeight(reference);

  static final _suggestDesiredDimensions = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_app_WallpaperManager_suggestDesiredDimensions")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void suggestDesiredDimensions(int minimumWidth, int minimumHeight)
  /// For use only by the current home application, to specify the size of
  /// wallpaper it would like to use.  This allows such applications to have
  /// a virtual wallpaper that is larger than the physical screen, matching
  /// the size of their workspace.
  ///
  /// Note developers, who don't seem to be reading this.  This is
  /// for _home apps_ to tell what size wallpaper they would like.
  /// Nobody else should be calling this!  Certainly not other non-home
  /// apps that change the wallpaper.  Those apps are supposed to
  /// __retrieve__ the suggested size so they can construct a wallpaper
  /// that matches it.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER_HINTS.
  ///@param minimumWidth Desired minimum width
  ///@param minimumHeight Desired minimum height
  void suggestDesiredDimensions(int minimumWidth, int minimumHeight) =>
      _suggestDesiredDimensions(reference, minimumWidth, minimumHeight);

  static final _setDisplayPadding = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperManager_setDisplayPadding")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setDisplayPadding(android.graphics.Rect padding)
  /// Specify extra padding that the wallpaper should have outside of the display.
  /// That is, the given padding supplies additional pixels the wallpaper should extend
  /// outside of the display itself.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER_HINTS.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER_HINTS
  ///@param padding The number of pixels the wallpaper should extend beyond the display,
  /// on its left, top, right, and bottom sides.
  void setDisplayPadding(jni.JlObject padding) =>
      _setDisplayPadding(reference, padding.reference);

  static final _clearWallpaper =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_WallpaperManager_clearWallpaper")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void clearWallpaper()
  /// Reset all wallpaper to the factory default.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  void clearWallpaper() => _clearWallpaper(reference);

  static final _setWallpaperOffsets = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Float, ffi.Float)>>(
          "android_app_WallpaperManager_setWallpaperOffsets")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, double, double)>();

  /// from: public void setWallpaperOffsets(android.os.IBinder windowToken, float xOffset, float yOffset)
  /// Set the display position of the current wallpaper within any larger space, when
  /// that wallpaper is visible behind the given window.  The X and Y offsets
  /// are floating point numbers ranging from 0 to 1, representing where the
  /// wallpaper should be positioned within the screen space.  These only
  /// make sense when the wallpaper is larger than the display.
  ///@param windowToken The window who these offsets should be associated
  /// with, as returned by android.view.View\#getWindowToken() View.getWindowToken().
  ///@param xOffset The offset along the X dimension, from 0 to 1.
  ///@param yOffset The offset along the Y dimension, from 0 to 1.
  void setWallpaperOffsets(
          os.IBinder windowToken, double xOffset, double yOffset) =>
      _setWallpaperOffsets(reference, windowToken.reference, xOffset, yOffset);

  static final _setWallpaperOffsetSteps = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Float, ffi.Float)>>(
          "android_app_WallpaperManager_setWallpaperOffsetSteps")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, double, double)>();

  /// from: public void setWallpaperOffsetSteps(float xStep, float yStep)
  /// For applications that use multiple virtual screens showing a wallpaper,
  /// specify the step size between virtual screens. For example, if the
  /// launcher has 3 virtual screens, it would specify an xStep of 0.5,
  /// since the X offset for those screens are 0.0, 0.5 and 1.0
  ///@param xStep The X offset delta from one screen to the next one
  ///@param yStep The Y offset delta from one screen to the next one
  void setWallpaperOffsetSteps(double xStep, double yStep) =>
      _setWallpaperOffsetSteps(reference, xStep, yStep);

  static final _sendWallpaperCommand = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperManager_sendWallpaperCommand")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void sendWallpaperCommand(android.os.IBinder windowToken, java.lang.String action, int x, int y, int z, android.os.Bundle extras)
  /// Send an arbitrary command to the current active wallpaper.
  ///@param windowToken The window who these offsets should be associated
  /// with, as returned by android.view.View\#getWindowToken() View.getWindowToken().
  ///@param action Name of the command to perform.  This must be a scoped
  /// name to avoid collisions, such as "com.mycompany.wallpaper.DOIT".
  ///@param x Arbitrary integer argument based on command.
  ///@param y Arbitrary integer argument based on command.
  ///@param z Arbitrary integer argument based on command.
  ///@param extras Optional additional information for the command, or null.
  void sendWallpaperCommand(os.IBinder windowToken, jni.JlString action, int x,
          int y, int z, os.Bundle extras) =>
      _sendWallpaperCommand(reference, windowToken.reference, action.reference,
          x, y, z, extras.reference);

  static final _isWallpaperSupported =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_WallpaperManager_isWallpaperSupported")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isWallpaperSupported()
  /// Returns whether wallpapers are supported for the calling user. If this function returns
  /// {@code false}, any attempts to changing the wallpaper will have no effect,
  /// and any attempt to obtain of the wallpaper will return {@code null}.
  bool isWallpaperSupported() => _isWallpaperSupported(reference) != 0;

  static final _isSetWallpaperAllowed =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_WallpaperManager_isSetWallpaperAllowed")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isSetWallpaperAllowed()
  /// Returns whether the calling package is allowed to set the wallpaper for the calling user.
  /// If this function returns {@code false}, any attempts to change the wallpaper will have
  /// no effect. Always returns {@code true} for device owner and profile owner.
  ///@see android.os.UserManager\#DISALLOW_SET_WALLPAPER
  bool isSetWallpaperAllowed() => _isSetWallpaperAllowed(reference) != 0;

  static final _clearWallpaperOffsets = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperManager_clearWallpaperOffsets")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void clearWallpaperOffsets(android.os.IBinder windowToken)
  /// Clear the offsets previously associated with this window through
  /// \#setWallpaperOffsets(IBinder, float, float).  This reverts
  /// the window to its default state, where it does not cause the wallpaper
  /// to scroll from whatever its last offsets were.
  ///@param windowToken The window who these offsets should be associated
  /// with, as returned by android.view.View\#getWindowToken() View.getWindowToken().
  void clearWallpaperOffsets(os.IBinder windowToken) =>
      _clearWallpaperOffsets(reference, windowToken.reference);

  static final _clear =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_WallpaperManager_clear")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void clear()
  /// Remove any currently set system wallpaper, reverting to the system's built-in
  /// wallpaper. On success, the intent Intent\#ACTION_WALLPAPER_CHANGED
  /// is broadcast.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@throws IOException If an error occurs reverting to the built-in
  /// wallpaper.
  void clear() => _clear(reference);

  static final _clear_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_WallpaperManager_clear_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void clear(int which)
  /// Remove one or more currently set wallpapers, reverting to the system default
  /// display for each one.  If \#FLAG_SYSTEM is set in the {@code which}
  /// parameter, the intent Intent\#ACTION_WALLPAPER_CHANGED will be broadcast
  /// upon success.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param which A bitwise combination of \#FLAG_SYSTEM or
  ///   \#FLAG_LOCK
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@throws IOException If an error occurs reverting to the built-in wallpaper.
  void clear_1(int which) => _clear_1(reference, which);
}

/// Interface definition for a callback to be invoked when colors change on a wallpaper.
class WallpaperManager_OnColorsChangedListener extends jni.JlObject {
  WallpaperManager_OnColorsChangedListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onColorsChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_WallpaperManager__OnColorsChangedListener_onColorsChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void onColorsChanged(android.app.WallpaperColors colors, int which)
  /// Called when colors change.
  /// A android.app.WallpaperColors object containing a simplified
  /// color histogram will be given.
  ///@param colors Wallpaper color info
  ///@param which A combination of \#FLAG_LOCK and \#FLAG_SYSTEM
  void onColorsChanged(WallpaperColors colors, int which) =>
      _onColorsChanged(reference, colors.reference, which);
}

/// Base class for Dialogs.
///
/// Note: Activities provide a facility to manage the creation, saving and
/// restoring of dialogs. See Activity\#onCreateDialog(int),
/// Activity\#onPrepareDialog(int, Dialog),
/// Activity\#showDialog(int), and Activity\#dismissDialog(int). If
/// these methods are used, \#getOwnerActivity() will return the Activity
/// that managed this dialog.
///
/// Often you will want to have a Dialog display on top of the current
/// input method, because there is no reason for it to accept text.  You can
/// do this by setting the WindowManager.LayoutParams\#FLAG_ALT_FOCUSABLE_IM WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM window flag (assuming
/// your Dialog takes input focus, as it the default) with the following code:
///
/// <pre>
/// getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,
///         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);</pre>
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about creating dialogs, read the
/// <a href="{@docRoot}guide/topics/ui/dialogs.html">Dialogs</a> developer guide.
///
/// </div>
class Dialog extends jni.JlObject {
  Dialog.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  /// Creates a dialog window that uses the default dialog theme.
  ///
  /// The supplied {@code context} is used to obtain the window manager and
  /// base theme used to present the dialog.
  ///@param context the context in which the dialog should run
  /// This value must never be {@code null}.
  ///@see android.R.styleable\#Theme_dialogTheme
  Dialog(content.Context context) : super.fromRef(_ctor(context.reference));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Dialog_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Context context, int themeResId)
  /// Creates a dialog window that uses a custom dialog style.
  ///
  /// The supplied {@code context} is used to obtain the window manager and
  /// base theme used to present the dialog.
  ///
  /// The supplied {@code theme} is applied on top of the context's theme. See
  /// <a href="{@docRoot}guide/topics/resources/available-resources.html\#stylesandthemes">
  /// Style and Theme Resources</a> for more information about defining and
  /// using styles.
  ///@param context the context in which the dialog should run
  /// This value must never be {@code null}.
  ///@param themeResId a style resource describing the theme to use for the
  ///              window, or {@code 0} to use the default dialog theme
  Dialog.ctor_1(content.Context context, int themeResId)
      : super.fromRef(_ctor_1(context.reference, themeResId));

  static final _ctor_2 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_new_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: protected void <init>(android.content.Context context, boolean cancelable, android.content.DialogInterface.OnCancelListener cancelListener)
  /// @param context This value must never be {@code null}.
  ///@param cancelListener This value may be {@code null}.
  Dialog.ctor_2(content.Context context, bool cancelable,
      content.DialogInterface_OnCancelListener cancelListener)
      : super.fromRef(_ctor_2(
            context.reference, cancelable ? 1 : 0, cancelListener.reference));

  static final _getContext = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_getContext")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.Context getContext()
  /// Retrieve the Context this Dialog is running in.
  ///@return Context The Context used by the Dialog.
  ///
  /// This value will never be {@code null}.
  content.Context getContext() =>
      content.Context.fromRef(_getContext(reference));

  static final _getActionBar = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_getActionBar")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.ActionBar getActionBar()
  /// Retrieve the ActionBar attached to this dialog, if present.
  ///@return The ActionBar attached to the dialog or null if no ActionBar is present.
  ActionBar getActionBar() => ActionBar.fromRef(_getActionBar(reference));

  static final _setOwnerActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_setOwnerActivity")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setOwnerActivity(android.app.Activity activity)
  /// Sets the Activity that owns this dialog. An example use: This Dialog will
  /// use the suggested volume control stream of the Activity.
  ///@param activity The Activity that owns this dialog.
  ///
  /// This value must never be {@code null}.
  void setOwnerActivity(Activity activity) =>
      _setOwnerActivity(reference, activity.reference);

  static final _getOwnerActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_getOwnerActivity")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Activity getOwnerActivity()
  /// Returns the Activity that owns this Dialog. For example, if
  /// Activity\#showDialog(int) is used to show this Dialog, that
  /// Activity will be the owner (by default). Depending on how this dialog was
  /// created, this may return null.
  ///@return The Activity that owns this Dialog.
  Activity getOwnerActivity() => Activity.fromRef(_getOwnerActivity(reference));

  static final _isShowing =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Dialog_isShowing")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isShowing()
  /// @return Whether the dialog is currently showing.
  bool isShowing() => _isShowing(reference) != 0;

  static final _create =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Dialog_create")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void create()
  /// Forces immediate creation of the dialog.
  ///
  /// Note that you should not override this method to perform dialog creation.
  /// Rather, override \#onCreate(Bundle).
  void create() => _create(reference);

  static final _show_ =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Dialog_show_")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void show()
  /// Start the dialog and display it on screen.  The window is placed in the
  /// application layer and opaque.  Note that you should not override this
  /// method to do initialization when the dialog is shown, instead implement
  /// that in \#onStart.
  void show_() => _show_(reference);

  static final _hide_ =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Dialog_hide_")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void hide()
  /// Hide the dialog, but do not dismiss it.
  void hide_() => _hide_(reference);

  static final _dismiss =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Dialog_dismiss")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dismiss()
  /// Dismiss this dialog, removing it from the screen. This method can be
  /// invoked safely from any thread.  Note that you should not override this
  /// method to do cleanup when the dialog is dismissed, instead implement
  /// that in \#onStop.
  void dismiss() => _dismiss(reference);

  static final _onCreate = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_onCreate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onCreate(android.os.Bundle savedInstanceState)
  /// Similar to Activity\#onCreate, you should initialize your dialog
  /// in this method, including calling \#setContentView.
  ///@param savedInstanceState If this dialog is being reinitialized after a
  ///     the hosting activity was previously shut down, holds the result from
  ///     the most recent call to \#onSaveInstanceState, or null if this
  ///     is the first time.
  void onCreate(os.Bundle savedInstanceState) =>
      _onCreate(reference, savedInstanceState.reference);

  static final _onStart =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Dialog_onStart")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStart()
  /// Called when the dialog is starting.
  void onStart() => _onStart(reference);

  static final _onStop =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Dialog_onStop")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStop()
  /// Called to tell you that you're stopping.
  void onStop() => _onStop(reference);

  static final _onSaveInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_onSaveInstanceState")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle onSaveInstanceState()
  /// Saves the state of the dialog into a bundle.
  ///
  /// The default implementation saves the state of its view hierarchy, so you'll
  /// likely want to call through to super if you override this to save additional
  /// state.
  ///@return A bundle with the state of the dialog.
  ///
  /// This value will never be {@code null}.
  os.Bundle onSaveInstanceState() =>
      os.Bundle.fromRef(_onSaveInstanceState(reference));

  static final _onRestoreInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_onRestoreInstanceState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onRestoreInstanceState(android.os.Bundle savedInstanceState)
  /// Restore the state of the dialog from a previously saved bundle.
  ///
  /// The default implementation restores the state of the dialog's view
  /// hierarchy that was saved in the default implementation of \#onSaveInstanceState(),
  /// so be sure to call through to super when overriding unless you want to
  /// do all restoring of state yourself.
  ///@param savedInstanceState The state of the dialog previously saved by
  ///     \#onSaveInstanceState().
  ///
  /// This value must never be {@code null}.
  void onRestoreInstanceState(os.Bundle savedInstanceState) =>
      _onRestoreInstanceState(reference, savedInstanceState.reference);

  static final _getWindow = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_getWindow")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.Window getWindow()
  /// Retrieve the current Window for the activity.  This can be used to
  /// directly access parts of the Window API that are not available
  /// through Activity/Screen.
  ///@return Window The current window, or null if the activity is not
  ///         visual.
  jni.JlObject getWindow() => jni.JlObject.fromRef(_getWindow(reference));

  static final _getCurrentFocus = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_getCurrentFocus")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View getCurrentFocus()
  /// Call android.view.Window\#getCurrentFocus on the
  /// Window if this Activity to return the currently focused view.
  ///@return View The current View with focus or null.
  ///@see \#getWindow
  ///@see android.view.Window\#getCurrentFocus
  jni.JlObject getCurrentFocus() =>
      jni.JlObject.fromRef(_getCurrentFocus(reference));

  static final _setContentView = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Dialog_setContentView")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setContentView(int layoutResID)
  /// Set the screen content from a layout resource.  The resource will be
  /// inflated, adding all top-level views to the screen.
  ///@param layoutResID Resource ID to be inflated.
  void setContentView(int layoutResID) =>
      _setContentView(reference, layoutResID);

  static final _setContentView_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_setContentView_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setContentView(android.view.View view)
  /// Set the screen content to an explicit view.  This view is placed
  /// directly into the screen's view hierarchy.  It can itself be a complex
  /// view hierarchy.
  ///@param view The desired content to display.
  ///
  /// This value must never be {@code null}.
  void setContentView_1(jni.JlObject view) =>
      _setContentView_1(reference, view.reference);

  static final _setContentView_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_setContentView_2")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setContentView(android.view.View view, android.view.ViewGroup.LayoutParams params)
  /// Set the screen content to an explicit view.  This view is placed
  /// directly into the screen's view hierarchy.  It can itself be a complex
  /// view hierarchy.
  ///@param view The desired content to display.
  /// This value must never be {@code null}.
  ///@param params Layout parameters for the view.
  ///
  /// This value may be {@code null}.
  void setContentView_2(jni.JlObject view, jni.JlObject params) =>
      _setContentView_2(reference, view.reference, params.reference);

  static final _addContentView = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_addContentView")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void addContentView(android.view.View view, android.view.ViewGroup.LayoutParams params)
  /// Add an additional content view to the screen.  Added after any existing
  /// ones in the screen -- existing views are NOT removed.
  ///@param view The desired content to display.
  /// This value must never be {@code null}.
  ///@param params Layout parameters for the view.
  ///
  /// This value may be {@code null}.
  void addContentView(jni.JlObject view, jni.JlObject params) =>
      _addContentView(reference, view.reference, params.reference);

  static final _setTitle = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_setTitle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTitle(java.lang.CharSequence title)
  /// Set the title text for this dialog's window.
  ///@param title The new text to display in the title.
  ///
  /// This value may be {@code null}.
  void setTitle(jni.JlObject title) => _setTitle(reference, title.reference);

  static final _setTitle_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Dialog_setTitle_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setTitle(int titleId)
  /// Set the title text for this dialog's window. The text is retrieved
  /// from the resources with the supplied identifier.
  ///@param titleId the title's text resource identifier
  void setTitle_1(int titleId) => _setTitle_1(reference, titleId);

  static final _onKeyDown = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_onKeyDown")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyDown(int keyCode, android.view.KeyEvent event)
  /// A key was pressed down.
  ///
  /// If the focused view didn't want this event, this method is called.
  ///
  /// Default implementation consumes KeyEvent\#KEYCODE_BACK KEYCODE_BACK
  /// and, as of android.os.Build.VERSION_CODES\#P P, KeyEvent\#KEYCODE_ESCAPE KEYCODE_ESCAPE to later handle them in \#onKeyUp.
  ///@see \#onKeyUp
  ///@see android.view.KeyEvent
  ///@param event This value must never be {@code null}.
  bool onKeyDown(int keyCode, jni.JlObject event) =>
      _onKeyDown(reference, keyCode, event.reference) != 0;

  static final _onKeyLongPress = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_onKeyLongPress")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyLongPress(int keyCode, android.view.KeyEvent event)
  /// Default implementation of KeyEvent.Callback\#onKeyLongPress(int, KeyEvent) KeyEvent.Callback.onKeyLongPress(): always returns false (doesn't handle
  /// the event).
  ///@param event This value must never be {@code null}.
  bool onKeyLongPress(int keyCode, jni.JlObject event) =>
      _onKeyLongPress(reference, keyCode, event.reference) != 0;

  static final _onKeyUp = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_onKeyUp")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyUp(int keyCode, android.view.KeyEvent event)
  /// A key was released.
  ///
  /// Default implementation consumes KeyEvent\#KEYCODE_BACK KEYCODE_BACK
  /// and, as of android.os.Build.VERSION_CODES\#P P, KeyEvent\#KEYCODE_ESCAPE KEYCODE_ESCAPE to close the dialog.
  ///@see \#onKeyDown
  ///@see android.view.KeyEvent
  ///@param event This value must never be {@code null}.
  bool onKeyUp(int keyCode, jni.JlObject event) =>
      _onKeyUp(reference, keyCode, event.reference) != 0;

  static final _onKeyMultiple = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_onKeyMultiple")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyMultiple(int keyCode, int repeatCount, android.view.KeyEvent event)
  /// Default implementation of KeyEvent.Callback\#onKeyMultiple(int, int, KeyEvent) KeyEvent.Callback.onKeyMultiple(): always returns false (doesn't handle
  /// the event).
  ///@param event This value must never be {@code null}.
  bool onKeyMultiple(int keyCode, int repeatCount, jni.JlObject event) =>
      _onKeyMultiple(reference, keyCode, repeatCount, event.reference) != 0;

  static final _onBackPressed =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Dialog_onBackPressed")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onBackPressed()
  /// Called when the dialog has detected the user's press of the back
  /// key.  The default implementation simply cancels the dialog (only if
  /// it is cancelable), but you can override this to do whatever you want.
  void onBackPressed() => _onBackPressed(reference);

  static final _onKeyShortcut = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_onKeyShortcut")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyShortcut(int keyCode, android.view.KeyEvent event)
  /// Called when a key shortcut event is not handled by any of the views in the Dialog.
  /// Override this method to implement global key shortcuts for the Dialog.
  /// Key shortcuts can also be implemented by setting the
  /// MenuItem\#setShortcut(char, char) shortcut property of menu items.
  ///@param keyCode The value in event.getKeyCode().
  ///@param event Description of the key event.
  /// This value must never be {@code null}.
  ///@return True if the key shortcut was handled.
  bool onKeyShortcut(int keyCode, jni.JlObject event) =>
      _onKeyShortcut(reference, keyCode, event.reference) != 0;

  static final _onTouchEvent = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_onTouchEvent")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onTouchEvent(android.view.MotionEvent event)
  /// Called when a touch screen event was not handled by any of the views
  /// under it. This is most useful to process touch events that happen outside
  /// of your window bounds, where there is no view to receive it.
  ///@param event The touch screen event being processed.
  /// This value must never be {@code null}.
  ///@return Return true if you have consumed the event, false if you haven't.
  ///         The default implementation will cancel the dialog when a touch
  ///         happens outside of the window bounds.
  bool onTouchEvent(jni.JlObject event) =>
      _onTouchEvent(reference, event.reference) != 0;

  static final _onTrackballEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_onTrackballEvent")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onTrackballEvent(android.view.MotionEvent event)
  /// Called when the trackball was moved and not handled by any of the
  /// views inside of the activity.  So, for example, if the trackball moves
  /// while focus is on a button, you will receive a call here because
  /// buttons do not normally do anything with trackball events.  The call
  /// here happens _before_ trackball movements are converted to
  /// DPAD key events, which then get sent back to the view hierarchy, and
  /// will be processed at the point for things like focus navigation.
  ///@param event The trackball event being processed.
  ///
  /// This value must never be {@code null}.
  ///@return Return true if you have consumed the event, false if you haven't.
  /// The default implementation always returns false.
  bool onTrackballEvent(jni.JlObject event) =>
      _onTrackballEvent(reference, event.reference) != 0;

  static final _onGenericMotionEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_onGenericMotionEvent")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onGenericMotionEvent(android.view.MotionEvent event)
  /// Called when a generic motion event was not handled by any of the
  /// views inside of the dialog.
  ///
  /// Generic motion events describe joystick movements, mouse hovers, track pad
  /// touches, scroll wheel movements and other input events.  The
  /// MotionEvent\#getSource() source of the motion event specifies
  /// the class of input that was received.  Implementations of this method
  /// must examine the bits in the source before processing the event.
  /// The following code example shows how this is done.
  ///
  ///
  /// Generic motion events with source class
  /// android.view.InputDevice\#SOURCE_CLASS_POINTER
  /// are delivered to the view under the pointer.  All other generic motion events are
  /// delivered to the focused view.
  ///
  ///
  /// See View\#onGenericMotionEvent(MotionEvent) for an example of how to
  /// handle this event.
  ///
  ///
  ///@param event The generic motion event being processed.
  ///
  /// This value must never be {@code null}.
  ///@return Return true if you have consumed the event, false if you haven't.
  /// The default implementation always returns false.
  bool onGenericMotionEvent(jni.JlObject event) =>
      _onGenericMotionEvent(reference, event.reference) != 0;

  static final _onWindowAttributesChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_onWindowAttributesChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onWindowAttributesChanged(android.view.WindowManager.LayoutParams params)
  void onWindowAttributesChanged(jni.JlObject params) =>
      _onWindowAttributesChanged(reference, params.reference);

  static final _onContentChanged =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Dialog_onContentChanged")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onContentChanged()
  void onContentChanged() => _onContentChanged(reference);

  static final _onWindowFocusChanged = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Dialog_onWindowFocusChanged")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onWindowFocusChanged(boolean hasFocus)
  void onWindowFocusChanged(bool hasFocus) =>
      _onWindowFocusChanged(reference, hasFocus ? 1 : 0);

  static final _onAttachedToWindow =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Dialog_onAttachedToWindow")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttachedToWindow()
  void onAttachedToWindow() => _onAttachedToWindow(reference);

  static final _onDetachedFromWindow =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Dialog_onDetachedFromWindow")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDetachedFromWindow()
  void onDetachedFromWindow() => _onDetachedFromWindow(reference);

  static final _dispatchKeyEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_dispatchKeyEvent")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchKeyEvent(android.view.KeyEvent event)
  /// Called to process key events.  You can override this to intercept all
  /// key events before they are dispatched to the window.  Be sure to call
  /// this implementation for key events that should be handled normally.
  ///@param event The key event.
  ///
  /// This value must never be {@code null}.
  ///@return boolean Return true if this event was consumed.
  bool dispatchKeyEvent(jni.JlObject event) =>
      _dispatchKeyEvent(reference, event.reference) != 0;

  static final _dispatchKeyShortcutEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_dispatchKeyShortcutEvent")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchKeyShortcutEvent(android.view.KeyEvent event)
  /// Called to process a key shortcut event.
  /// You can override this to intercept all key shortcut events before they are
  /// dispatched to the window.  Be sure to call this implementation for key shortcut
  /// events that should be handled normally.
  ///@param event The key shortcut event.
  /// This value must never be {@code null}.
  ///@return True if this event was consumed.
  bool dispatchKeyShortcutEvent(jni.JlObject event) =>
      _dispatchKeyShortcutEvent(reference, event.reference) != 0;

  static final _dispatchTouchEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_dispatchTouchEvent")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchTouchEvent(android.view.MotionEvent ev)
  /// Called to process touch screen events.  You can override this to
  /// intercept all touch screen events before they are dispatched to the
  /// window.  Be sure to call this implementation for touch screen events
  /// that should be handled normally.
  ///@param ev The touch screen event.
  ///
  /// This value must never be {@code null}.
  ///@return boolean Return true if this event was consumed.
  bool dispatchTouchEvent(jni.JlObject ev) =>
      _dispatchTouchEvent(reference, ev.reference) != 0;

  static final _dispatchTrackballEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_dispatchTrackballEvent")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchTrackballEvent(android.view.MotionEvent ev)
  /// Called to process trackball events.  You can override this to
  /// intercept all trackball events before they are dispatched to the
  /// window.  Be sure to call this implementation for trackball events
  /// that should be handled normally.
  ///@param ev The trackball event.
  ///
  /// This value must never be {@code null}.
  ///@return boolean Return true if this event was consumed.
  bool dispatchTrackballEvent(jni.JlObject ev) =>
      _dispatchTrackballEvent(reference, ev.reference) != 0;

  static final _dispatchGenericMotionEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_dispatchGenericMotionEvent")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchGenericMotionEvent(android.view.MotionEvent ev)
  /// Called to process generic motion events.  You can override this to
  /// intercept all generic motion events before they are dispatched to the
  /// window.  Be sure to call this implementation for generic motion events
  /// that should be handled normally.
  ///@param ev The generic motion event.
  ///
  /// This value must never be {@code null}.
  ///@return boolean Return true if this event was consumed.
  bool dispatchGenericMotionEvent(jni.JlObject ev) =>
      _dispatchGenericMotionEvent(reference, ev.reference) != 0;

  static final _dispatchPopulateAccessibilityEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_dispatchPopulateAccessibilityEvent")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)
  /// @param event This value must never be {@code null}.
  bool dispatchPopulateAccessibilityEvent(jni.JlObject event) =>
      _dispatchPopulateAccessibilityEvent(reference, event.reference) != 0;

  static final _onCreatePanelView = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Dialog_onCreatePanelView")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.View onCreatePanelView(int featureId)
  /// @see Activity\#onCreatePanelView(int)
  jni.JlObject onCreatePanelView(int featureId) =>
      jni.JlObject.fromRef(_onCreatePanelView(reference, featureId));

  static final _onCreatePanelMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_onCreatePanelMenu")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onCreatePanelMenu(int featureId, android.view.Menu menu)
  /// @see Activity\#onCreatePanelMenu(int, Menu)
  ///@param menu This value must never be {@code null}.
  bool onCreatePanelMenu(int featureId, jni.JlObject menu) =>
      _onCreatePanelMenu(reference, featureId, menu.reference) != 0;

  static final _onPreparePanel = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_onPreparePanel")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onPreparePanel(int featureId, android.view.View view, android.view.Menu menu)
  /// @see Activity\#onPreparePanel(int, View, Menu)
  bool onPreparePanel(int featureId, jni.JlObject view, jni.JlObject menu) =>
      _onPreparePanel(reference, featureId, view.reference, menu.reference) !=
      0;

  static final _onMenuOpened = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_onMenuOpened")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onMenuOpened(int featureId, android.view.Menu menu)
  /// @see Activity\#onMenuOpened(int, Menu)
  bool onMenuOpened(int featureId, jni.JlObject menu) =>
      _onMenuOpened(reference, featureId, menu.reference) != 0;

  static final _onMenuItemSelected = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_onMenuItemSelected")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onMenuItemSelected(int featureId, android.view.MenuItem item)
  /// @see Activity\#onMenuItemSelected(int, MenuItem)
  bool onMenuItemSelected(int featureId, jni.JlObject item) =>
      _onMenuItemSelected(reference, featureId, item.reference) != 0;

  static final _onPanelClosed = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_onPanelClosed")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPanelClosed(int featureId, android.view.Menu menu)
  /// @see Activity\#onPanelClosed(int, Menu)
  void onPanelClosed(int featureId, jni.JlObject menu) =>
      _onPanelClosed(reference, featureId, menu.reference);

  static final _onCreateOptionsMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_onCreateOptionsMenu")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onCreateOptionsMenu(android.view.Menu menu)
  /// It is usually safe to proxy this call to the owner activity's
  /// Activity\#onCreateOptionsMenu(Menu) if the client desires the same
  /// menu for this Dialog.
  ///@see Activity\#onCreateOptionsMenu(Menu)
  ///@see \#getOwnerActivity()
  ///@param menu This value must never be {@code null}.
  bool onCreateOptionsMenu(jni.JlObject menu) =>
      _onCreateOptionsMenu(reference, menu.reference) != 0;

  static final _onPrepareOptionsMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_onPrepareOptionsMenu")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onPrepareOptionsMenu(android.view.Menu menu)
  /// It is usually safe to proxy this call to the owner activity's
  /// Activity\#onPrepareOptionsMenu(Menu) if the client desires the
  /// same menu for this Dialog.
  ///@see Activity\#onPrepareOptionsMenu(Menu)
  ///@see \#getOwnerActivity()
  ///@param menu This value must never be {@code null}.
  bool onPrepareOptionsMenu(jni.JlObject menu) =>
      _onPrepareOptionsMenu(reference, menu.reference) != 0;

  static final _onOptionsItemSelected = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_onOptionsItemSelected")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onOptionsItemSelected(android.view.MenuItem item)
  /// @see Activity\#onOptionsItemSelected(MenuItem)
  ///@param item This value must never be {@code null}.
  bool onOptionsItemSelected(jni.JlObject item) =>
      _onOptionsItemSelected(reference, item.reference) != 0;

  static final _onOptionsMenuClosed = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_onOptionsMenuClosed")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onOptionsMenuClosed(android.view.Menu menu)
  /// @see Activity\#onOptionsMenuClosed(Menu)
  ///@param menu This value must never be {@code null}.
  void onOptionsMenuClosed(jni.JlObject menu) =>
      _onOptionsMenuClosed(reference, menu.reference);

  static final _openOptionsMenu =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Dialog_openOptionsMenu")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void openOptionsMenu()
  /// @see Activity\#openOptionsMenu()
  void openOptionsMenu() => _openOptionsMenu(reference);

  static final _closeOptionsMenu =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Dialog_closeOptionsMenu")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void closeOptionsMenu()
  /// @see Activity\#closeOptionsMenu()
  void closeOptionsMenu() => _closeOptionsMenu(reference);

  static final _invalidateOptionsMenu =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Dialog_invalidateOptionsMenu")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void invalidateOptionsMenu()
  /// @see Activity\#invalidateOptionsMenu()
  void invalidateOptionsMenu() => _invalidateOptionsMenu(reference);

  static final _onCreateContextMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_onCreateContextMenu")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreateContextMenu(android.view.ContextMenu menu, android.view.View v, android.view.ContextMenu.ContextMenuInfo menuInfo)
  /// @see Activity\#onCreateContextMenu(ContextMenu, View, ContextMenuInfo)
  void onCreateContextMenu(
          jni.JlObject menu, jni.JlObject v, jni.JlObject menuInfo) =>
      _onCreateContextMenu(
          reference, menu.reference, v.reference, menuInfo.reference);

  static final _registerForContextMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_registerForContextMenu")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerForContextMenu(android.view.View view)
  /// @see Activity\#registerForContextMenu(View)
  ///@param view This value must never be {@code null}.
  void registerForContextMenu(jni.JlObject view) =>
      _registerForContextMenu(reference, view.reference);

  static final _unregisterForContextMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_unregisterForContextMenu")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterForContextMenu(android.view.View view)
  /// @see Activity\#unregisterForContextMenu(View)
  ///@param view This value must never be {@code null}.
  void unregisterForContextMenu(jni.JlObject view) =>
      _unregisterForContextMenu(reference, view.reference);

  static final _openContextMenu = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_openContextMenu")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void openContextMenu(android.view.View view)
  /// @see Activity\#openContextMenu(View)
  ///@param view This value must never be {@code null}.
  void openContextMenu(jni.JlObject view) =>
      _openContextMenu(reference, view.reference);

  static final _onContextItemSelected = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_onContextItemSelected")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onContextItemSelected(android.view.MenuItem item)
  /// @see Activity\#onContextItemSelected(MenuItem)
  ///@param item This value must never be {@code null}.
  bool onContextItemSelected(jni.JlObject item) =>
      _onContextItemSelected(reference, item.reference) != 0;

  static final _onContextMenuClosed = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_onContextMenuClosed")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onContextMenuClosed(android.view.Menu menu)
  /// @see Activity\#onContextMenuClosed(Menu)
  ///@param menu This value must never be {@code null}.
  void onContextMenuClosed(jni.JlObject menu) =>
      _onContextMenuClosed(reference, menu.reference);

  static final _onSearchRequested = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_onSearchRequested")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onSearchRequested(android.view.SearchEvent searchEvent)
  /// This hook is called when the user signals the desire to start a search.
  ///@param searchEvent This value must never be {@code null}.
  bool onSearchRequested(jni.JlObject searchEvent) =>
      _onSearchRequested(reference, searchEvent.reference) != 0;

  static final _onSearchRequested_1 =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Dialog_onSearchRequested_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onSearchRequested()
  /// This hook is called when the user signals the desire to start a search.
  bool onSearchRequested_1() => _onSearchRequested_1(reference) != 0;

  static final _getSearchEvent = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Dialog_getSearchEvent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.view.SearchEvent getSearchEvent()
  /// During the onSearchRequested() callbacks, this function will return the
  /// SearchEvent that triggered the callback, if it exists.
  ///@return SearchEvent The SearchEvent that triggered the \#onSearchRequested callback.
  ///
  /// This value may be {@code null}.
  jni.JlObject getSearchEvent() =>
      jni.JlObject.fromRef(_getSearchEvent(reference));

  static final _onWindowStartingActionMode = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_onWindowStartingActionMode")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback)
  jni.JlObject onWindowStartingActionMode(jni.JlObject callback) =>
      jni.JlObject.fromRef(
          _onWindowStartingActionMode(reference, callback.reference));

  static final _onWindowStartingActionMode_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_Dialog_onWindowStartingActionMode_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback, int type)
  jni.JlObject onWindowStartingActionMode_1(jni.JlObject callback, int type) =>
      jni.JlObject.fromRef(
          _onWindowStartingActionMode_1(reference, callback.reference, type));

  static final _onActionModeStarted = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_onActionModeStarted")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onActionModeStarted(android.view.ActionMode mode)
  /// {@inheritDoc}
  ///
  /// Note that if you override this method you should always call through
  /// to the superclass implementation by calling super.onActionModeStarted(mode).
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onActionModeStarted(jni.JlObject mode) =>
      _onActionModeStarted(reference, mode.reference);

  static final _onActionModeFinished = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_onActionModeFinished")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onActionModeFinished(android.view.ActionMode mode)
  /// {@inheritDoc}
  ///
  /// Note that if you override this method you should always call through
  /// to the superclass implementation by calling super.onActionModeFinished(mode).
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onActionModeFinished(jni.JlObject mode) =>
      _onActionModeFinished(reference, mode.reference);

  static final _takeKeyEvents = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Dialog_takeKeyEvents")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void takeKeyEvents(boolean get)
  /// Request that key events come to this dialog. Use this if your
  /// dialog has no views with focus, but the dialog still wants
  /// a chance to process key events.
  ///@param get true if the dialog should receive key events, false otherwise
  ///@see android.view.Window\#takeKeyEvents
  void takeKeyEvents(bool get_) => _takeKeyEvents(reference, get_ ? 1 : 0);

  static final _requestWindowFeature = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Dialog_requestWindowFeature")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final boolean requestWindowFeature(int featureId)
  /// Enable extended window features.  This is a convenience for calling
  /// android.view.Window\#requestFeature getWindow().requestFeature().
  ///@param featureId The desired feature as defined in
  ///                  android.view.Window.
  ///@return Returns true if the requested feature is supported and now
  ///         enabled.
  ///@see android.view.Window\#requestFeature
  bool requestWindowFeature(int featureId) =>
      _requestWindowFeature(reference, featureId) != 0;

  static final _setFeatureDrawableResource = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_app_Dialog_setFeatureDrawableResource")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final void setFeatureDrawableResource(int featureId, int resId)
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawableResource.
  void setFeatureDrawableResource(int featureId, int resId) =>
      _setFeatureDrawableResource(reference, featureId, resId);

  static final _setFeatureDrawableUri = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_setFeatureDrawableUri")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setFeatureDrawableUri(int featureId, android.net.Uri uri)
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawableUri.
  ///@param uri This value may be {@code null}.
  void setFeatureDrawableUri(int featureId, jni.JlObject uri) =>
      _setFeatureDrawableUri(reference, featureId, uri.reference);

  static final _setFeatureDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_setFeatureDrawable")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setFeatureDrawable(int featureId, android.graphics.drawable.Drawable drawable)
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawable(int, Drawable).
  ///@param drawable This value may be {@code null}.
  void setFeatureDrawable(int featureId, jni.JlObject drawable) =>
      _setFeatureDrawable(reference, featureId, drawable.reference);

  static final _setFeatureDrawableAlpha = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_app_Dialog_setFeatureDrawableAlpha")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final void setFeatureDrawableAlpha(int featureId, int alpha)
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawableAlpha.
  void setFeatureDrawableAlpha(int featureId, int alpha) =>
      _setFeatureDrawableAlpha(reference, featureId, alpha);

  static final _getLayoutInflater = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_getLayoutInflater")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.LayoutInflater getLayoutInflater()
  /// @return This value will never be {@code null}.
  jni.JlObject getLayoutInflater() =>
      jni.JlObject.fromRef(_getLayoutInflater(reference));

  static final _setCancelable = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Dialog_setCancelable")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setCancelable(boolean flag)
  /// Sets whether this dialog is cancelable with the
  /// KeyEvent\#KEYCODE_BACK BACK key.
  void setCancelable(bool flag) => _setCancelable(reference, flag ? 1 : 0);

  static final _setCanceledOnTouchOutside = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Dialog_setCanceledOnTouchOutside")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setCanceledOnTouchOutside(boolean cancel)
  /// Sets whether this dialog is canceled when touched outside the window's
  /// bounds. If setting to true, the dialog is set to be cancelable if not
  /// already set.
  ///@param cancel Whether the dialog should be canceled when touched outside
  ///            the window.
  void setCanceledOnTouchOutside(bool cancel) =>
      _setCanceledOnTouchOutside(reference, cancel ? 1 : 0);

  static final _cancel =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Dialog_cancel")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void cancel()
  /// Cancel the dialog.  This is essentially the same as calling \#dismiss(), but it will
  /// also call your DialogInterface.OnCancelListener (if registered).
  void cancel() => _cancel(reference);

  static final _setOnCancelListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_setOnCancelListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnCancelListener(android.content.DialogInterface.OnCancelListener listener)
  /// Set a listener to be invoked when the dialog is canceled.
  ///
  /// This will only be invoked when the dialog is canceled.
  /// Cancel events alone will not capture all ways that
  /// the dialog might be dismissed. If the creator needs
  /// to know when a dialog is dismissed in general, use
  /// \#setOnDismissListener.
  ///
  ///@param listener The DialogInterface.OnCancelListener to use.
  ///
  /// This value may be {@code null}.
  void setOnCancelListener(content.DialogInterface_OnCancelListener listener) =>
      _setOnCancelListener(reference, listener.reference);

  static final _setCancelMessage = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_setCancelMessage")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setCancelMessage(android.os.Message msg)
  /// Set a message to be sent when the dialog is canceled.
  ///@param msg The msg to send when the dialog is canceled.
  /// This value may be {@code null}.
  ///@see \#setOnCancelListener(android.content.DialogInterface.OnCancelListener)
  void setCancelMessage(os.Message msg) =>
      _setCancelMessage(reference, msg.reference);

  static final _setOnDismissListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_setOnDismissListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnDismissListener(android.content.DialogInterface.OnDismissListener listener)
  /// Set a listener to be invoked when the dialog is dismissed.
  ///@param listener The DialogInterface.OnDismissListener to use.
  ///
  /// This value may be {@code null}.
  void setOnDismissListener(
          content.DialogInterface_OnDismissListener listener) =>
      _setOnDismissListener(reference, listener.reference);

  static final _setOnShowListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_setOnShowListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnShowListener(android.content.DialogInterface.OnShowListener listener)
  /// Sets a listener to be invoked when the dialog is shown.
  ///@param listener The DialogInterface.OnShowListener to use.
  ///
  /// This value may be {@code null}.
  void setOnShowListener(content.DialogInterface_OnShowListener listener) =>
      _setOnShowListener(reference, listener.reference);

  static final _setDismissMessage = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_setDismissMessage")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setDismissMessage(android.os.Message msg)
  /// Set a message to be sent when the dialog is dismissed.
  ///@param msg The msg to send when the dialog is dismissed.
  ///
  /// This value may be {@code null}.
  void setDismissMessage(os.Message msg) =>
      _setDismissMessage(reference, msg.reference);

  static final _setVolumeControlStream = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Dialog_setVolumeControlStream")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setVolumeControlStream(int streamType)
  /// By default, this will use the owner Activity's suggested stream type.
  ///@see Activity\#setVolumeControlStream(int)
  ///@see \#setOwnerActivity(Activity)
  void setVolumeControlStream(int streamType) =>
      _setVolumeControlStream(reference, streamType);

  static final _getVolumeControlStream =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Dialog_getVolumeControlStream")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getVolumeControlStream()
  /// @see Activity\#getVolumeControlStream()
  int getVolumeControlStream() => _getVolumeControlStream(reference);

  static final _setOnKeyListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Dialog_setOnKeyListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnKeyListener(android.content.DialogInterface.OnKeyListener onKeyListener)
  /// Sets the callback that will be called if a key is dispatched to the dialog.
  ///@param onKeyListener This value may be {@code null}.
  void setOnKeyListener(content.DialogInterface_OnKeyListener onKeyListener) =>
      _setOnKeyListener(reference, onKeyListener.reference);
}

/// Class that can be used to lock and unlock the keyboard. The
/// actual class to control the keyboard locking is
/// android.app.KeyguardManager.KeyguardLock.
class KeyguardManager extends jni.JlObject {
  KeyguardManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_KeyguardManager_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  KeyguardManager() : super.fromRef(_ctor());

  static final _createConfirmDeviceCredentialIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_KeyguardManager_createConfirmDeviceCredentialIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent createConfirmDeviceCredentialIntent(java.lang.CharSequence title, java.lang.CharSequence description)
  /// Get an intent to prompt the user to confirm credentials (pin, pattern or password)
  /// for the current user of the device. The caller is expected to launch this activity using
  /// android.app.Activity\#startActivityForResult(Intent, int) and check for
  /// android.app.Activity\#RESULT_OK if the user successfully completes the challenge.
  ///@return the intent for launching the activity or null if no password is required.
  content.Intent createConfirmDeviceCredentialIntent(
          jni.JlObject title, jni.JlObject description) =>
      content.Intent.fromRef(_createConfirmDeviceCredentialIntent(
          reference, title.reference, description.reference));

  static final _newKeyguardLock = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_KeyguardManager_newKeyguardLock")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.KeyguardManager.KeyguardLock newKeyguardLock(java.lang.String tag)
  /// @deprecated Use LayoutParams\#FLAG_DISMISS_KEYGUARD
  /// and/or LayoutParams\#FLAG_SHOW_WHEN_LOCKED
  /// instead; this allows you to seamlessly hide the keyguard as your application
  /// moves in and out of the foreground and does not require that any special
  /// permissions be requested.
  ///
  /// Enables you to lock or unlock the keyboard. Get an instance of this class by
  /// calling android.content.Context\#getSystemService(java.lang.String) Context.getSystemService().
  /// This class is wrapped by android.app.KeyguardManager KeyguardManager.
  ///@param tag A tag that informally identifies who you are (for debugging who
  ///   is disabling he keyguard).
  ///@return A KeyguardLock handle to use to disable and reenable the
  ///   keyguard.
  KeyguardManager_KeyguardLock newKeyguardLock(jni.JlString tag) =>
      KeyguardManager_KeyguardLock.fromRef(
          _newKeyguardLock(reference, tag.reference));

  static final _isKeyguardLocked =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_KeyguardManager_isKeyguardLocked")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isKeyguardLocked()
  /// Return whether the keyguard is currently locked.
  ///@return true if keyguard is locked.
  bool isKeyguardLocked() => _isKeyguardLocked(reference) != 0;

  static final _isKeyguardSecure =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_KeyguardManager_isKeyguardSecure")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isKeyguardSecure()
  /// Return whether the keyguard is secured by a PIN, pattern or password or a SIM card
  /// is currently locked.
  ///
  /// See also \#isDeviceSecure() which ignores SIM locked states.
  ///@return true if a PIN, pattern or password is set or a SIM card is locked.
  bool isKeyguardSecure() => _isKeyguardSecure(reference) != 0;

  static final _inKeyguardRestrictedInputMode =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_KeyguardManager_inKeyguardRestrictedInputMode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean inKeyguardRestrictedInputMode()
  /// @deprecated Use \#isKeyguardLocked() instead.
  ///
  /// If keyguard screen is showing or in restricted key input mode (i.e. in
  /// keyguard password emergency screen). When in such mode, certain keys,
  /// such as the Home key and the right soft keys, don't work.
  ///@return true if in keyguard restricted input mode.
  bool inKeyguardRestrictedInputMode() =>
      _inKeyguardRestrictedInputMode(reference) != 0;

  static final _isDeviceLocked =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_KeyguardManager_isDeviceLocked")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isDeviceLocked()
  /// Returns whether the device is currently locked and requires a PIN, pattern or
  /// password to unlock.
  ///@return true if unlocking the device currently requires a PIN, pattern or
  /// password.
  bool isDeviceLocked() => _isDeviceLocked(reference) != 0;

  static final _isDeviceSecure =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_KeyguardManager_isDeviceSecure")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isDeviceSecure()
  /// Returns whether the device is secured with a PIN, pattern or
  /// password.
  ///
  /// See also \#isKeyguardSecure which treats SIM locked states as secure.
  ///@return true if a PIN, pattern or password was set.
  bool isDeviceSecure() => _isDeviceSecure(reference) != 0;

  static final _requestDismissKeyguard = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_KeyguardManager_requestDismissKeyguard")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void requestDismissKeyguard(android.app.Activity activity, android.app.KeyguardManager.KeyguardDismissCallback callback)
  /// If the device is currently locked (see \#isKeyguardLocked(), requests the Keyguard to
  /// be dismissed.
  ///
  /// If the Keyguard is not secure or the device is currently in a trusted state, calling this
  /// method will immediately dismiss the Keyguard without any user interaction.
  ///
  /// If the Keyguard is secure and the device is not in a trusted state, this will bring up the
  /// UI so the user can enter their credentials.
  ///
  /// If the value set for the Activity attr android.R.attr\#turnScreenOn is true,
  /// the screen will turn on when the keyguard is dismissed.
  ///@param activity The activity requesting the dismissal. The activity must be either visible
  ///                 by using LayoutParams\#FLAG_SHOW_WHEN_LOCKED or must be in a state in
  ///                 which it would be visible if Keyguard would not be hiding it. If that's not
  ///                 the case, the request will fail immediately and
  ///                 KeyguardDismissCallback\#onDismissError will be invoked.
  /// This value must never be {@code null}.
  ///@param callback The callback to be called if the request to dismiss Keyguard was successful
  ///                 or {@code null} if the caller isn't interested in knowing the result. The
  ///                 callback will not be invoked if the activity was destroyed before the
  ///                 callback was received.
  ///
  /// This value may be {@code null}.
  void requestDismissKeyguard(Activity activity,
          KeyguardManager_KeyguardDismissCallback callback) =>
      _requestDismissKeyguard(
          reference, activity.reference, callback.reference);

  static final _exitKeyguardSecurely = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_KeyguardManager_exitKeyguardSecurely")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void exitKeyguardSecurely(android.app.KeyguardManager.OnKeyguardExitResult callback)
  /// Requires android.Manifest.permission\#DISABLE_KEYGUARD
  ///@deprecated Use LayoutParams\#FLAG_DISMISS_KEYGUARD
  /// and/or LayoutParams\#FLAG_SHOW_WHEN_LOCKED
  /// instead; this allows you to seamlessly hide the keyguard as your application
  /// moves in and out of the foreground and does not require that any special
  /// permissions be requested.
  ///
  /// Exit the keyguard securely.  The use case for this api is that, after
  /// disabling the keyguard, your app, which was granted permission to
  /// disable the keyguard and show a limited amount of information deemed
  /// safe without the user getting past the keyguard, needs to navigate to
  /// something that is not safe to view without getting past the keyguard.
  ///
  /// This will, if the keyguard is secure, bring up the unlock screen of
  /// the keyguard.
  ///@param callback Let's you know whether the operation was succesful and
  ///   it is safe to launch anything that would normally be considered safe
  ///   once the user has gotten past the keyguard.
  void exitKeyguardSecurely(KeyguardManager_OnKeyguardExitResult callback) =>
      _exitKeyguardSecurely(reference, callback.reference);
}

/// @deprecated Use KeyguardDismissCallback
/// Callback passed to KeyguardManager\#exitKeyguardSecurely to notify
/// caller of result.
class KeyguardManager_OnKeyguardExitResult extends jni.JlObject {
  KeyguardManager_OnKeyguardExitResult.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onKeyguardExitResult = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_KeyguardManager__OnKeyguardExitResult_onKeyguardExitResult")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void onKeyguardExitResult(boolean success)
  /// @param success True if the user was able to authenticate, false if
  ///   not.
  void onKeyguardExitResult(bool success) =>
      _onKeyguardExitResult(reference, success ? 1 : 0);
}

/// @deprecated Use LayoutParams\#FLAG_DISMISS_KEYGUARD
/// and/or LayoutParams\#FLAG_SHOW_WHEN_LOCKED
/// instead; this allows you to seamlessly hide the keyguard as your application
/// moves in and out of the foreground and does not require that any special
/// permissions be requested.
///
/// Handle returned by KeyguardManager\#newKeyguardLock that allows
/// you to disable / reenable the keyguard.
class KeyguardManager_KeyguardLock extends jni.JlObject {
  KeyguardManager_KeyguardLock.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_KeyguardManager__KeyguardLock_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(java.lang.String tag)
  KeyguardManager_KeyguardLock(jni.JlString tag)
      : super.fromRef(_ctor(tag.reference));

  static final _disableKeyguard =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_KeyguardManager__KeyguardLock_disableKeyguard")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void disableKeyguard()
  /// Disable the keyguard from showing.  If the keyguard is currently
  /// showing, hide it.  The keyguard will be prevented from showing again
  /// until \#reenableKeyguard() is called.
  ///
  /// A good place to call this is from android.app.Activity\#onResume()
  ///
  /// Note: This call has no effect while any android.app.admin.DevicePolicyManager
  /// is enabled that requires a password.
  ///
  /// Requires android.Manifest.permission\#DISABLE_KEYGUARD
  ///@see \#reenableKeyguard()
  void disableKeyguard() => _disableKeyguard(reference);

  static final _reenableKeyguard =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_KeyguardManager__KeyguardLock_reenableKeyguard")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void reenableKeyguard()
  /// Reenable the keyguard.  The keyguard will reappear if the previous
  /// call to \#disableKeyguard() caused it to be hidden.
  ///
  /// A good place to call this is from android.app.Activity\#onPause()
  ///
  /// Note: This call has no effect while any android.app.admin.DevicePolicyManager
  /// is enabled that requires a password.
  ///
  /// Requires android.Manifest.permission\#DISABLE_KEYGUARD
  ///@see \#disableKeyguard()
  void reenableKeyguard() => _reenableKeyguard(reference);
}

/// Callback passed to
/// KeyguardManager\#requestDismissKeyguard(Activity, KeyguardDismissCallback)
/// to notify caller of result.
class KeyguardManager_KeyguardDismissCallback extends jni.JlObject {
  KeyguardManager_KeyguardDismissCallback.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_KeyguardManager__KeyguardDismissCallback_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  KeyguardManager_KeyguardDismissCallback() : super.fromRef(_ctor());

  static final _onDismissError = jlookup<
              ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_KeyguardManager__KeyguardDismissCallback_onDismissError")
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDismissError()
  /// Called when dismissing Keyguard is currently not feasible, i.e. when Keyguard is not
  /// available, not showing or when the activity requesting the Keyguard dismissal isn't
  /// showing or isn't showing behind Keyguard.
  void onDismissError() => _onDismissError(reference);

  static final _onDismissSucceeded = jlookup<
              ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_KeyguardManager__KeyguardDismissCallback_onDismissSucceeded")
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDismissSucceeded()
  /// Called when dismissing Keyguard has succeeded and the device is now unlocked.
  void onDismissSucceeded() => _onDismissSucceeded(reference);

  static final _onDismissCancelled = jlookup<
              ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_KeyguardManager__KeyguardDismissCallback_onDismissCancelled")
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDismissCancelled()
  /// Called when dismissing Keyguard has been cancelled, i.e. when the user cancelled the
  /// operation or the bouncer was hidden for some other reason.
  void onDismissCancelled() => _onDismissCancelled(reference);
}

/// Provides information about the colors of a wallpaper.
///
/// Exposes the 3 most visually representative colors of a wallpaper. Can be either
/// WallpaperColors\#getPrimaryColor(), WallpaperColors\#getSecondaryColor()
/// or WallpaperColors\#getTertiaryColor().
class WallpaperColors extends jni.JlObject {
  WallpaperColors.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.WallpaperColors> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_WallpaperColors_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_WallpaperColors_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel parcel)
  WallpaperColors(os.Parcel parcel) : super.fromRef(_ctor(parcel.reference));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_WallpaperColors_new_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.graphics.Color primaryColor, android.graphics.Color secondaryColor, android.graphics.Color tertiaryColor)
  /// Constructs a new object from three colors.
  ///@param primaryColor Primary color.
  /// This value must never be {@code null}.
  ///@param secondaryColor Secondary color.
  /// This value may be {@code null}.
  ///@param tertiaryColor Tertiary color.
  /// This value may be {@code null}.
  ///@see WallpaperColors\#fromBitmap(Bitmap)
  ///@see WallpaperColors\#fromDrawable(Drawable)
  WallpaperColors.ctor_1(jni.JlObject primaryColor, jni.JlObject secondaryColor,
      jni.JlObject tertiaryColor)
      : super.fromRef(_ctor_1(primaryColor.reference, secondaryColor.reference,
            tertiaryColor.reference));

  static final _fromDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperColors_fromDrawable")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.WallpaperColors fromDrawable(android.graphics.drawable.Drawable drawable)
  /// Constructs WallpaperColors from a drawable.
  ///
  /// Main colors will be extracted from the drawable.
  ///@param drawable Source where to extract from.
  static WallpaperColors fromDrawable(jni.JlObject drawable) =>
      WallpaperColors.fromRef(_fromDrawable(drawable.reference));

  static final _fromBitmap = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperColors_fromBitmap")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.WallpaperColors fromBitmap(android.graphics.Bitmap bitmap)
  /// Constructs WallpaperColors from a bitmap.
  ///
  /// Main colors will be extracted from the bitmap.
  ///@param bitmap Source where to extract from.
  ///
  /// This value must never be {@code null}.
  static WallpaperColors fromBitmap(jni.JlObject bitmap) =>
      WallpaperColors.fromRef(_fromBitmap(bitmap.reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_WallpaperColors_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_WallpaperColors_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _getPrimaryColor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperColors_getPrimaryColor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Color getPrimaryColor()
  /// Gets the most visually representative color of the wallpaper.
  /// "Visually representative" means easily noticeable in the image,
  /// probably happening at high frequency.
  ///@return A color.
  ///
  /// This value will never be {@code null}.
  jni.JlObject getPrimaryColor() =>
      jni.JlObject.fromRef(_getPrimaryColor(reference));

  static final _getSecondaryColor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperColors_getSecondaryColor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Color getSecondaryColor()
  /// Gets the second most preeminent color of the wallpaper. Can be null.
  ///@return A color, may be null.
  jni.JlObject getSecondaryColor() =>
      jni.JlObject.fromRef(_getSecondaryColor(reference));

  static final _getTertiaryColor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperColors_getTertiaryColor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Color getTertiaryColor()
  /// Gets the third most preeminent color of the wallpaper. Can be null.
  ///@return A color, may be null.
  jni.JlObject getTertiaryColor() =>
      jni.JlObject.fromRef(_getTertiaryColor(reference));

  static final _equals_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperColors_equals_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object o)
  bool equals_1(jni.JlObject o) => _equals_1(reference, o.reference) != 0;

  static final _hashCode_1 =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_WallpaperColors_hashCode_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode_1() => _hashCode_1(reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperColors_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));
}

/// Utility class for constructing synthetic back stacks for cross-task navigation
/// on Android 3.0 and newer.
///
/// In API level 11 (Android 3.0/Honeycomb) the recommended conventions for
/// app navigation using the back key changed. The back key's behavior is local
/// to the current task and does not capture navigation across different tasks.
/// Navigating across tasks and easily reaching the previous task is accomplished
/// through the "recents" UI, accessible through the software-provided Recents key
/// on the navigation or system bar. On devices with the older hardware button configuration
/// the recents UI can be accessed with a long press on the Home key.
///
///
/// When crossing from one task stack to another post-Android 3.0,
/// the application should synthesize a back stack/history for the new task so that
/// the user may navigate out of the new task and back to the Launcher by repeated
/// presses of the back key. Back key presses should not navigate across task stacks.
///
///
/// TaskStackBuilder provides a way to obey the correct conventions
/// around cross-task navigation.
///
///
/// <div class="special reference">
/// <h3>About Navigation</h3>
/// For more detailed information about tasks, the back stack, and navigation design guidelines,
/// please read
/// <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back Stack</a>
/// from the developer guide and <a href="{@docRoot}design/patterns/navigation.html">Navigation</a>
/// from the design guide.
/// </div>
class TaskStackBuilder extends jni.JlObject {
  TaskStackBuilder.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_TaskStackBuilder_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.content.Context a)
  TaskStackBuilder(content.Context a) : super.fromRef(_ctor(a.reference));

  static final _create = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_TaskStackBuilder_create")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.TaskStackBuilder create(android.content.Context context)
  /// Return a new TaskStackBuilder for launching a fresh task stack consisting
  /// of a series of activities.
  ///@param context The context that will launch the new task stack or generate a PendingIntent
  ///@return A new TaskStackBuilder
  static TaskStackBuilder create(content.Context context) =>
      TaskStackBuilder.fromRef(_create(context.reference));

  static final _addNextIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_TaskStackBuilder_addNextIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.TaskStackBuilder addNextIntent(android.content.Intent nextIntent)
  /// Add a new Intent to the task stack. The most recently added Intent will invoke
  /// the Activity at the top of the final task stack.
  ///@param nextIntent Intent for the next Activity in the synthesized task stack
  ///@return This TaskStackBuilder for method chaining
  TaskStackBuilder addNextIntent(content.Intent nextIntent) =>
      TaskStackBuilder.fromRef(_addNextIntent(reference, nextIntent.reference));

  static final _addNextIntentWithParentStack = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_TaskStackBuilder_addNextIntentWithParentStack")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.TaskStackBuilder addNextIntentWithParentStack(android.content.Intent nextIntent)
  /// Add a new Intent with the resolved chain of parents for the target activity to
  /// the task stack.
  ///
  /// This is equivalent to calling \#addParentStack(ComponentName) addParentStack
  /// with the resolved ComponentName of nextIntent (if it can be resolved), followed by
  /// \#addNextIntent(Intent) addNextIntent with nextIntent.
  ///
  ///@param nextIntent Intent for the topmost Activity in the synthesized task stack.
  ///                   Its chain of parents as specified in the manifest will be added.
  ///@return This TaskStackBuilder for method chaining.
  TaskStackBuilder addNextIntentWithParentStack(content.Intent nextIntent) =>
      TaskStackBuilder.fromRef(
          _addNextIntentWithParentStack(reference, nextIntent.reference));

  static final _addParentStack = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_TaskStackBuilder_addParentStack")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.TaskStackBuilder addParentStack(android.app.Activity sourceActivity)
  /// Add the activity parent chain as specified by the
  /// Activity\#getParentActivityIntent() getParentActivityIntent() method of the activity
  /// specified and the android.R.attr\#parentActivityName parentActivityName attributes
  /// of each successive activity (or activity-alias) element in the application's manifest
  /// to the task stack builder.
  ///@param sourceActivity All parents of this activity will be added
  ///@return This TaskStackBuilder for method chaining
  TaskStackBuilder addParentStack(Activity sourceActivity) =>
      TaskStackBuilder.fromRef(
          _addParentStack(reference, sourceActivity.reference));

  static final _addParentStack_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_TaskStackBuilder_addParentStack_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.TaskStackBuilder addParentStack(java.lang.Class<?> sourceActivityClass)
  /// Add the activity parent chain as specified by the
  /// android.R.attr\#parentActivityName parentActivityName attribute of the activity
  /// (or activity-alias) element in the application's manifest to the task stack builder.
  ///@param sourceActivityClass All parents of this activity will be added
  ///@return This TaskStackBuilder for method chaining
  TaskStackBuilder addParentStack_1(jni.JlObject sourceActivityClass) =>
      TaskStackBuilder.fromRef(
          _addParentStack_1(reference, sourceActivityClass.reference));

  static final _addParentStack_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_TaskStackBuilder_addParentStack_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.TaskStackBuilder addParentStack(android.content.ComponentName sourceActivityName)
  /// Add the activity parent chain as specified by the
  /// android.R.attr\#parentActivityName parentActivityName attribute of the activity
  /// (or activity-alias) element in the application's manifest to the task stack builder.
  ///@param sourceActivityName Must specify an Activity component. All parents of
  ///                           this activity will be added
  ///@return This TaskStackBuilder for method chaining
  TaskStackBuilder addParentStack_2(content.ComponentName sourceActivityName) =>
      TaskStackBuilder.fromRef(
          _addParentStack_2(reference, sourceActivityName.reference));

  static final _getIntentCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_TaskStackBuilder_getIntentCount")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getIntentCount()
  /// @return the number of intents added so far.
  int getIntentCount() => _getIntentCount(reference);

  static final _editIntentAt = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_TaskStackBuilder_editIntentAt")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.Intent editIntentAt(int index)
  /// Return the intent at the specified index for modification.
  /// Useful if you need to modify the flags or extras of an intent that was previously added,
  /// for example with \#addParentStack(Activity).
  ///@param index Index from 0-getIntentCount()
  ///@return the intent at position index
  content.Intent editIntentAt(int index) =>
      content.Intent.fromRef(_editIntentAt(reference, index));

  static final _startActivities =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_TaskStackBuilder_startActivities")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivities()
  /// Start the task stack constructed by this builder.
  void startActivities() => _startActivities(reference);

  static final _startActivities_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_TaskStackBuilder_startActivities_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivities(android.os.Bundle options)
  /// Start the task stack constructed by this builder.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  void startActivities_1(os.Bundle options) =>
      _startActivities_1(reference, options.reference);

  static final _getPendingIntent = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_app_TaskStackBuilder_getPendingIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.app.PendingIntent getPendingIntent(int requestCode, int flags)
  /// Obtain a PendingIntent for launching the task constructed by this builder so far.
  ///@param requestCode Private request code for the sender
  ///@param flags May be PendingIntent\#FLAG_ONE_SHOT,
  ///              PendingIntent\#FLAG_NO_CREATE, PendingIntent\#FLAG_CANCEL_CURRENT,
  ///              PendingIntent\#FLAG_UPDATE_CURRENT, or any of the flags supported by
  ///              Intent\#fillIn(Intent, int) to control which unspecified parts of the
  ///              intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return The obtained PendingIntent
  PendingIntent getPendingIntent(int requestCode, int flags) =>
      PendingIntent.fromRef(_getPendingIntent(reference, requestCode, flags));

  static final _getPendingIntent_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_app_TaskStackBuilder_getPendingIntent_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent getPendingIntent(int requestCode, int flags, android.os.Bundle options)
  /// Obtain a PendingIntent for launching the task constructed by this builder so far.
  ///@param requestCode Private request code for the sender
  ///@param flags May be PendingIntent\#FLAG_ONE_SHOT,
  ///              PendingIntent\#FLAG_NO_CREATE, PendingIntent\#FLAG_CANCEL_CURRENT,
  ///              PendingIntent\#FLAG_UPDATE_CURRENT, or any of the flags supported by
  ///              Intent\#fillIn(Intent, int) to control which unspecified parts of the
  ///              intent that can be supplied when the actual send happens.
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///@return The obtained PendingIntent
  PendingIntent getPendingIntent_1(
          int requestCode, int flags, os.Bundle options) =>
      PendingIntent.fromRef(_getPendingIntent_1(
          reference, requestCode, flags, options.reference));

  static final _getIntents = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_TaskStackBuilder_getIntents")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent[] getIntents()
  /// Return an array containing the intents added to this builder. The intent at the
  /// root of the task stack will appear as the first item in the array and the
  /// intent at the top of the stack will appear as the last item.
  ///@return An array containing the intents added to this builder.
  ///
  /// This value will never be {@code null}.
  jni.JlObject getIntents() => jni.JlObject.fromRef(_getIntents(reference));
}

/// Class for interacting with the device's UI by simulation user actions and
/// introspection of the screen content. It relies on the platform accessibility
/// APIs to introspect the screen and to perform some actions on the remote view
/// tree. It also allows injecting of arbitrary raw input events simulating user
/// interaction with keyboards and touch devices. One can think of a UiAutomation
/// as a special type of android.accessibilityservice.AccessibilityService
/// which does not provide hooks for the service life cycle and exposes other
/// APIs that are useful for UI test automation.
///
/// The APIs exposed by this class are low-level to maximize flexibility when
/// developing UI test automation tools and libraries. Generally, a UiAutomation
/// client should be using a higher-level library or implement high-level functions.
/// For example, performing a tap on the screen requires construction and injecting
/// of a touch down and up events which have to be delivered to the system by a
/// call to \#injectInputEvent(InputEvent, boolean).
///
///
///
/// The APIs exposed by this class operate across applications enabling a client
/// to write tests that cover use cases spanning over multiple applications. For
/// example, going to the settings application to change a setting and then
/// interacting with another application whose behavior depends on that setting.
///
///
class UiAutomation extends jni.JlObject {
  UiAutomation.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES
  /// UiAutomation supresses accessibility services by default. This flag specifies that
  /// existing accessibility services should continue to run, and that new ones may start.
  /// This flag is set when obtaining the UiAutomation from
  /// Instrumentation\#getUiAutomation(int).
  static const FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES = 1;

  /// from: static public final int ROTATION_FREEZE_0
  /// Rotation constant: Freeze rotation to 0 degrees (natural orientation)
  static const ROTATION_FREEZE_0 = 0;

  /// from: static public final int ROTATION_FREEZE_180
  /// Rotation constant: Freeze rotation to 180 degrees .
  static const ROTATION_FREEZE_180 = 2;

  /// from: static public final int ROTATION_FREEZE_270
  /// Rotation constant: Freeze rotation to 270 degrees .
  static const ROTATION_FREEZE_270 = 3;

  /// from: static public final int ROTATION_FREEZE_90
  /// Rotation constant: Freeze rotation to 90 degrees .
  static const ROTATION_FREEZE_90 = 1;

  /// from: static public final int ROTATION_FREEZE_CURRENT
  /// Rotation constant: Freeze rotation to its current state.
  static const ROTATION_FREEZE_CURRENT = -1;

  /// from: static public final int ROTATION_UNFREEZE
  /// Rotation constant: Unfreeze rotation (rotating the device changes its rotation state).
  static const ROTATION_UNFREEZE = -2;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_UiAutomation_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  UiAutomation() : super.fromRef(_ctor());

  static final _setOnAccessibilityEventListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_UiAutomation_setOnAccessibilityEventListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnAccessibilityEventListener(android.app.UiAutomation.OnAccessibilityEventListener listener)
  /// Sets a callback for observing the stream of AccessibilityEvents.
  /// The callbacks are delivered on the main application thread.
  ///@param listener The callback.
  void setOnAccessibilityEventListener(
          UiAutomation_OnAccessibilityEventListener listener) =>
      _setOnAccessibilityEventListener(reference, listener.reference);

  static final _performGlobalAction = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_UiAutomation_performGlobalAction")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean performGlobalAction(int action)
  /// Performs a global action. Such an action can be performed at any moment
  /// regardless of the current application or user location in that application.
  /// For example going back, going home, opening recents, etc.
  ///@param action The action to perform.
  ///@return Whether the action was successfully performed.
  ///@see android.accessibilityservice.AccessibilityService\#GLOBAL_ACTION_BACK
  ///@see android.accessibilityservice.AccessibilityService\#GLOBAL_ACTION_HOME
  ///@see android.accessibilityservice.AccessibilityService\#GLOBAL_ACTION_NOTIFICATIONS
  ///@see android.accessibilityservice.AccessibilityService\#GLOBAL_ACTION_RECENTS
  bool performGlobalAction(int action) =>
      _performGlobalAction(reference, action) != 0;

  static final _findFocus = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_UiAutomation_findFocus")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.accessibility.AccessibilityNodeInfo findFocus(int focus)
  /// Find the view that has the specified focus type. The search is performed
  /// across all windows.
  ///
  /// <strong>Note:</strong> In order to access the windows you have to opt-in
  /// to retrieve the interactive windows by setting the
  /// AccessibilityServiceInfo\#FLAG_RETRIEVE_INTERACTIVE_WINDOWS flag.
  /// Otherwise, the search will be performed only in the active window.
  ///
  ///
  ///@param focus The focus to find. One of AccessibilityNodeInfo\#FOCUS_INPUT or
  ///         AccessibilityNodeInfo\#FOCUS_ACCESSIBILITY.
  ///@return The node info of the focused view or null.
  ///@see AccessibilityNodeInfo\#FOCUS_INPUT
  ///@see AccessibilityNodeInfo\#FOCUS_ACCESSIBILITY
  jni.JlObject findFocus(int focus) =>
      jni.JlObject.fromRef(_findFocus(reference, focus));

  static final _getServiceInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_UiAutomation_getServiceInfo")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.accessibilityservice.AccessibilityServiceInfo getServiceInfo()
  /// Gets the an AccessibilityServiceInfo describing this UiAutomation.
  /// This method is useful if one wants to change some of the dynamically
  /// configurable properties at runtime.
  ///@return The accessibility service info.
  ///@see AccessibilityServiceInfo
  jni.JlObject getServiceInfo() =>
      jni.JlObject.fromRef(_getServiceInfo(reference));

  static final _setServiceInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_UiAutomation_setServiceInfo")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setServiceInfo(android.accessibilityservice.AccessibilityServiceInfo info)
  /// Sets the AccessibilityServiceInfo that describes how this
  /// UiAutomation will be handled by the platform accessibility layer.
  ///@param info The info.
  ///@see AccessibilityServiceInfo
  void setServiceInfo(jni.JlObject info) =>
      _setServiceInfo(reference, info.reference);

  static final _getWindows = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_UiAutomation_getWindows")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.view.accessibility.AccessibilityWindowInfo> getWindows()
  /// Gets the windows on the screen. This method returns only the windows
  /// that a sighted user can interact with, as opposed to all windows.
  /// For example, if there is a modal dialog shown and the user cannot touch
  /// anything behind it, then only the modal window will be reported
  /// (assuming it is the top one). For convenience the returned windows
  /// are ordered in a descending layer order, which is the windows that
  /// are higher in the Z-order are reported first.
  ///
  /// <strong>Note:</strong> In order to access the windows you have to opt-in
  /// to retrieve the interactive windows by setting the
  /// AccessibilityServiceInfo\#FLAG_RETRIEVE_INTERACTIVE_WINDOWS flag.
  ///
  ///
  ///@return The windows if there are windows such, otherwise an empty list.
  jni.JlObject getWindows() => jni.JlObject.fromRef(_getWindows(reference));

  static final _getRootInActiveWindow = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_UiAutomation_getRootInActiveWindow")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.accessibility.AccessibilityNodeInfo getRootInActiveWindow()
  /// Gets the root AccessibilityNodeInfo in the active window.
  ///@return The root info.
  jni.JlObject getRootInActiveWindow() =>
      jni.JlObject.fromRef(_getRootInActiveWindow(reference));

  static final _injectInputEvent = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_UiAutomation_injectInputEvent")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean injectInputEvent(android.view.InputEvent event, boolean sync)
  /// A method for injecting an arbitrary input event.
  ///
  /// <strong>Note:</strong> It is caller's responsibility to recycle the event.
  ///
  ///
  ///@param event The event to inject.
  ///@param sync Whether to inject the event synchronously.
  ///@return Whether event injection succeeded.
  bool injectInputEvent(jni.JlObject event, bool sync_) =>
      _injectInputEvent(reference, event.reference, sync_ ? 1 : 0) != 0;

  static final _setRotation = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_UiAutomation_setRotation")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean setRotation(int rotation)
  /// Sets the device rotation. A client can freeze the rotation in
  /// desired state or freeze the rotation to its current state or
  /// unfreeze the rotation (rotating the device changes its rotation
  /// state).
  ///@param rotation The desired rotation.
  ///@return Whether the rotation was set successfully.
  ///@see \#ROTATION_FREEZE_0
  ///@see \#ROTATION_FREEZE_90
  ///@see \#ROTATION_FREEZE_180
  ///@see \#ROTATION_FREEZE_270
  ///@see \#ROTATION_FREEZE_CURRENT
  ///@see \#ROTATION_UNFREEZE
  bool setRotation(int rotation) => _setRotation(reference, rotation) != 0;

  static final _executeAndWaitForEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int64)>>(
          "android_app_UiAutomation_executeAndWaitForEvent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.accessibility.AccessibilityEvent executeAndWaitForEvent(java.lang.Runnable command, android.app.UiAutomation.AccessibilityEventFilter filter, long timeoutMillis)
  /// Executes a command and waits for a specific accessibility event up to a
  /// given wait timeout. To detect a sequence of events one can implement a
  /// filter that keeps track of seen events of the expected sequence and
  /// returns true after the last event of that sequence is received.
  ///
  /// <strong>Note:</strong> It is caller's responsibility to recycle the returned event.
  ///
  ///
  ///@param command The command to execute.
  ///@param filter Filter that recognizes the expected event.
  ///@param timeoutMillis The wait timeout in milliseconds.
  ///@throws TimeoutException If the expected event is not received within the timeout.
  jni.JlObject executeAndWaitForEvent(jni.JlObject command,
          UiAutomation_AccessibilityEventFilter filter, int timeoutMillis) =>
      jni.JlObject.fromRef(_executeAndWaitForEvent(
          reference, command.reference, filter.reference, timeoutMillis));

  static final _waitForIdle = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Int64)>>("android_app_UiAutomation_waitForIdle")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void waitForIdle(long idleTimeoutMillis, long globalTimeoutMillis)
  /// Waits for the accessibility event stream to become idle, which is not to
  /// have received an accessibility event within <code>idleTimeoutMillis</code>.
  /// The total time spent to wait for an idle accessibility event stream is bounded
  /// by the <code>globalTimeoutMillis</code>.
  ///@param idleTimeoutMillis The timeout in milliseconds between two events
  ///            to consider the device idle.
  ///@param globalTimeoutMillis The maximal global timeout in milliseconds in
  ///            which to wait for an idle state.
  ///@throws TimeoutException If no idle state was detected within
  ///            <code>globalTimeoutMillis.</code>
  void waitForIdle(int idleTimeoutMillis, int globalTimeoutMillis) =>
      _waitForIdle(reference, idleTimeoutMillis, globalTimeoutMillis);

  static final _takeScreenshot = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_UiAutomation_takeScreenshot")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap takeScreenshot()
  /// Takes a screenshot.
  ///@return The screenshot bitmap on success, null otherwise.
  jni.JlObject takeScreenshot() =>
      jni.JlObject.fromRef(_takeScreenshot(reference));

  static final _setRunAsMonkey = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_UiAutomation_setRunAsMonkey")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setRunAsMonkey(boolean enable)
  /// Sets whether this UiAutomation to run in a "monkey" mode. Applications can query whether
  /// they are executed in a "monkey" mode, i.e. run by a test framework, and avoid doing
  /// potentially undesirable actions such as calling 911 or posting on public forums etc.
  ///@param enable whether to run in a "monkey" mode or not. Default is not.
  ///@see ActivityManager\#isUserAMonkey()
  void setRunAsMonkey(bool enable) =>
      _setRunAsMonkey(reference, enable ? 1 : 0);

  static final _clearWindowContentFrameStats = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_UiAutomation_clearWindowContentFrameStats")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean clearWindowContentFrameStats(int windowId)
  /// Clears the frame statistics for the content of a given window. These
  /// statistics contain information about the most recently rendered content
  /// frames.
  ///@param windowId The window id.
  ///@return Whether the window is present and its frame statistics
  ///         were cleared.
  ///@see android.view.WindowContentFrameStats
  ///@see \#getWindowContentFrameStats(int)
  ///@see \#getWindows()
  ///@see AccessibilityWindowInfo\#getId() AccessibilityWindowInfo.getId()
  bool clearWindowContentFrameStats(int windowId) =>
      _clearWindowContentFrameStats(reference, windowId) != 0;

  static final _getWindowContentFrameStats = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_UiAutomation_getWindowContentFrameStats")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.WindowContentFrameStats getWindowContentFrameStats(int windowId)
  /// Gets the frame statistics for a given window. These statistics contain
  /// information about the most recently rendered content frames.
  ///
  /// A typical usage requires clearing the window frame statistics via \#clearWindowContentFrameStats(int) followed by an interaction with the UI and
  /// finally getting the window frame statistics via calling this method.
  ///
  ///
  /// <pre>
  /// // Assume we have at least one window.
  /// final int windowId = getWindows().get(0).getId();
  ///
  /// // Start with a clean slate.
  /// uiAutimation.clearWindowContentFrameStats(windowId);
  ///
  /// // Do stuff with the UI.
  ///
  /// // Get the frame statistics.
  /// WindowContentFrameStats stats = uiAutomation.getWindowContentFrameStats(windowId);
  /// </pre>
  ///@param windowId The window id.
  ///@return The window frame statistics, or null if the window is not present.
  ///@see android.view.WindowContentFrameStats
  ///@see \#clearWindowContentFrameStats(int)
  ///@see \#getWindows()
  ///@see AccessibilityWindowInfo\#getId() AccessibilityWindowInfo.getId()
  jni.JlObject getWindowContentFrameStats(int windowId) =>
      jni.JlObject.fromRef(_getWindowContentFrameStats(reference, windowId));

  static final _clearWindowAnimationFrameStats =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_UiAutomation_clearWindowAnimationFrameStats")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void clearWindowAnimationFrameStats()
  /// Clears the window animation rendering statistics. These statistics contain
  /// information about the most recently rendered window animation frames, i.e.
  /// for window transition animations.
  ///@see android.view.WindowAnimationFrameStats
  ///@see \#getWindowAnimationFrameStats()
  ///@see android.R.styleable\#WindowAnimation
  void clearWindowAnimationFrameStats() =>
      _clearWindowAnimationFrameStats(reference);

  static final _getWindowAnimationFrameStats = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_UiAutomation_getWindowAnimationFrameStats")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.WindowAnimationFrameStats getWindowAnimationFrameStats()
  /// Gets the window animation frame statistics. These statistics contain
  /// information about the most recently rendered window animation frames, i.e.
  /// for window transition animations.
  ///
  ///
  /// A typical usage requires clearing the window animation frame statistics via
  /// \#clearWindowAnimationFrameStats() followed by an interaction that causes
  /// a window transition which uses a window animation and finally getting the window
  /// animation frame statistics by calling this method.
  ///
  ///
  /// <pre>
  /// // Start with a clean slate.
  /// uiAutimation.clearWindowAnimationFrameStats();
  ///
  /// // Do stuff to trigger a window transition.
  ///
  /// // Get the frame statistics.
  /// WindowAnimationFrameStats stats = uiAutomation.getWindowAnimationFrameStats();
  /// </pre>
  ///@return The window animation frame statistics.
  ///@see android.view.WindowAnimationFrameStats
  ///@see \#clearWindowAnimationFrameStats()
  ///@see android.R.styleable\#WindowAnimation
  jni.JlObject getWindowAnimationFrameStats() =>
      jni.JlObject.fromRef(_getWindowAnimationFrameStats(reference));

  static final _grantRuntimePermission = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_UiAutomation_grantRuntimePermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void grantRuntimePermission(java.lang.String packageName, java.lang.String permission)
  /// Grants a runtime permission to a package.
  ///@param packageName The package to which to grant.
  ///@param permission The permission to grant.
  ///@throws SecurityException if unable to grant the permission.
  void grantRuntimePermission(
          jni.JlString packageName, jni.JlString permission) =>
      _grantRuntimePermission(
          reference, packageName.reference, permission.reference);

  static final _grantRuntimePermissionAsUser = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_UiAutomation_grantRuntimePermissionAsUser")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void grantRuntimePermissionAsUser(java.lang.String packageName, java.lang.String permission, android.os.UserHandle userHandle)
  /// Grants a runtime permission to a package for a user.
  ///@param packageName The package to which to grant.
  ///@param permission The permission to grant.
  ///@throws SecurityException if unable to grant the permission.
  void grantRuntimePermissionAsUser(jni.JlString packageName,
          jni.JlString permission, os.UserHandle userHandle) =>
      _grantRuntimePermissionAsUser(reference, packageName.reference,
          permission.reference, userHandle.reference);

  static final _revokeRuntimePermission = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_UiAutomation_revokeRuntimePermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void revokeRuntimePermission(java.lang.String packageName, java.lang.String permission)
  /// Revokes a runtime permission from a package.
  ///@param packageName The package to which to grant.
  ///@param permission The permission to grant.
  ///@throws SecurityException if unable to revoke the permission.
  void revokeRuntimePermission(
          jni.JlString packageName, jni.JlString permission) =>
      _revokeRuntimePermission(
          reference, packageName.reference, permission.reference);

  static final _revokeRuntimePermissionAsUser = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_UiAutomation_revokeRuntimePermissionAsUser")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void revokeRuntimePermissionAsUser(java.lang.String packageName, java.lang.String permission, android.os.UserHandle userHandle)
  /// Revokes a runtime permission from a package.
  ///@param packageName The package to which to grant.
  ///@param permission The permission to grant.
  ///@throws SecurityException if unable to revoke the permission.
  void revokeRuntimePermissionAsUser(jni.JlString packageName,
          jni.JlString permission, os.UserHandle userHandle) =>
      _revokeRuntimePermissionAsUser(reference, packageName.reference,
          permission.reference, userHandle.reference);

  static final _executeShellCommand = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_UiAutomation_executeShellCommand")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.ParcelFileDescriptor executeShellCommand(java.lang.String command)
  /// Executes a shell command. This method returns a file descriptor that points
  /// to the standard output stream. The command execution is similar to running
  /// "adb shell <command>" from a host connected to the device.
  ///
  /// <strong>Note:</strong> It is your responsibility to close the returned file
  /// descriptor once you are done reading.
  ///
  ///
  ///@param command The command to execute.
  ///@return A file descriptor to the standard output stream.
  os.ParcelFileDescriptor executeShellCommand(jni.JlString command) =>
      os.ParcelFileDescriptor.fromRef(
          _executeShellCommand(reference, command.reference));
}

/// Listener for observing the AccessibilityEvent stream.
class UiAutomation_OnAccessibilityEventListener extends jni.JlObject {
  UiAutomation_OnAccessibilityEventListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onAccessibilityEvent = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_UiAutomation__OnAccessibilityEventListener_onAccessibilityEvent")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)
  /// Callback for receiving an AccessibilityEvent.
  ///
  /// <strong>Note:</strong> This method is <strong>NOT</strong> executed
  /// on the main test thread. The client is responsible for proper
  /// synchronization.
  ///
  ///
  ///
  /// <strong>Note:</strong> It is responsibility of the client
  /// to recycle the received events to minimize object creation.
  ///
  ///
  ///@param event The received event.
  void onAccessibilityEvent(jni.JlObject event) =>
      _onAccessibilityEvent(reference, event.reference);
}

/// Listener for filtering accessibility events.
class UiAutomation_AccessibilityEventFilter extends jni.JlObject {
  UiAutomation_AccessibilityEventFilter.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _accept = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_UiAutomation__AccessibilityEventFilter_accept")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean accept(android.view.accessibility.AccessibilityEvent event)
  /// Callback for determining whether an event is accepted or
  /// it is filtered out.
  ///@param event The event to process.
  ///@return True if the event is accepted, false to filter it out.
  bool accept(jni.JlObject event) => _accept(reference, event.reference) != 0;
}

/// Helper class for showing "bread crumbs" representing the fragment
/// stack in an activity.  This is intended to be used with
/// ActionBar\#setCustomView(View) ActionBar.setCustomView(View) to place the bread crumbs in
/// the action bar.
///
/// The default style for this view is
/// android.R.style\#Widget_FragmentBreadCrumbs.
///@deprecated This widget is no longer supported.
class FragmentBreadCrumbs extends jni.JlObject {
  FragmentBreadCrumbs.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentBreadCrumbs_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  FragmentBreadCrumbs(content.Context context)
      : super.fromRef(_ctor(context.reference));

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentBreadCrumbs_new_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  FragmentBreadCrumbs.ctor_1(content.Context context, jni.JlObject attrs)
      : super.fromRef(_ctor_1(context.reference, attrs.reference));

  static final _ctor_2 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_FragmentBreadCrumbs_new_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  FragmentBreadCrumbs.ctor_2(
      content.Context context, jni.JlObject attrs, int defStyleAttr)
      : super.fromRef(
            _ctor_2(context.reference, attrs.reference, defStyleAttr));

  static final _setActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentBreadCrumbs_setActivity")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setActivity(android.app.Activity a)
  /// Attach the bread crumbs to their activity.  This must be called once
  /// when creating the bread crumbs.
  void setActivity(Activity a) => _setActivity(reference, a.reference);

  static final _setMaxVisible = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_FragmentBreadCrumbs_setMaxVisible")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setMaxVisible(int visibleCrumbs)
  /// The maximum number of breadcrumbs to show. Older fragment headers will be hidden from view.
  ///@param visibleCrumbs the number of visible breadcrumbs. This should be greater than zero.
  void setMaxVisible(int visibleCrumbs) =>
      _setMaxVisible(reference, visibleCrumbs);

  static final _setParentTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentBreadCrumbs_setParentTitle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setParentTitle(java.lang.CharSequence title, java.lang.CharSequence shortTitle, android.view.View.OnClickListener listener)
  /// Inserts an optional parent entry at the first position in the breadcrumbs. Selecting this
  /// entry will result in a call to the specified listener's
  /// android.view.View.OnClickListener\#onClick(View)
  /// method.
  ///@param title the title for the parent entry
  ///@param shortTitle the short title for the parent entry
  ///@param listener the android.view.View.OnClickListener to be called when clicked.
  /// A null will result in no action being taken when the parent entry is clicked.
  void setParentTitle(
          jni.JlObject title, jni.JlObject shortTitle, jni.JlObject listener) =>
      _setParentTitle(
          reference, title.reference, shortTitle.reference, listener.reference);

  static final _setOnBreadCrumbClickListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentBreadCrumbs_setOnBreadCrumbClickListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnBreadCrumbClickListener(android.app.FragmentBreadCrumbs.OnBreadCrumbClickListener listener)
  /// Sets a listener for clicks on the bread crumbs.  This will be called before
  /// the default click action is performed.
  ///@param listener The new listener to set.  Replaces any existing listener.
  void setOnBreadCrumbClickListener(
          FragmentBreadCrumbs_OnBreadCrumbClickListener listener) =>
      _setOnBreadCrumbClickListener(reference, listener.reference);

  static final _setTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentBreadCrumbs_setTitle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setTitle(java.lang.CharSequence title, java.lang.CharSequence shortTitle)
  /// Set a custom title for the bread crumbs.  This will be the first entry
  /// shown at the left, representing the root of the bread crumbs.  If the
  /// title is null, it will not be shown.
  void setTitle(jni.JlObject title, jni.JlObject shortTitle) =>
      _setTitle(reference, title.reference, shortTitle.reference);

  static final _onLayout = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("android_app_FragmentBreadCrumbs_onLayout")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, int, int, int, int)>();

  /// from: protected void onLayout(boolean changed, int l, int t, int r, int b)
  void onLayout(bool changed, int l, int t, int r, int b) =>
      _onLayout(reference, changed ? 1 : 0, l, t, r, b);

  static final _onMeasure = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_app_FragmentBreadCrumbs_onMeasure")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  void onMeasure(int widthMeasureSpec, int heightMeasureSpec) =>
      _onMeasure(reference, widthMeasureSpec, heightMeasureSpec);

  static final _onBackStackChanged =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentBreadCrumbs_onBackStackChanged")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onBackStackChanged()
  void onBackStackChanged() => _onBackStackChanged(reference);
}

/// Interface to intercept clicks on the bread crumbs.
///@deprecated This widget is no longer supported.
class FragmentBreadCrumbs_OnBreadCrumbClickListener extends jni.JlObject {
  FragmentBreadCrumbs_OnBreadCrumbClickListener.fromRef(
      ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onBreadCrumbClick = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_FragmentBreadCrumbs__OnBreadCrumbClickListener_onBreadCrumbClick")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract boolean onBreadCrumbClick(android.app.FragmentManager.BackStackEntry backStack, int flags)
  /// Called when a bread crumb is clicked.
  ///@param backStack The BackStackEntry whose bread crumb was clicked.
  /// May be null, if this bread crumb is for the root of the back stack.
  ///@param flags Additional information about the entry.  Currently
  /// always 0.
  ///@return Return true to consume this click.  Return to false to allow
  /// the default action (popping back stack to this entry) to occur.
  bool onBreadCrumbClick(FragmentManager_BackStackEntry backStack, int flags) =>
      _onBreadCrumbClick(reference, backStack.reference, flags) != 0;
}

/// Helper class for managing multiple running embedded activities in the same
/// process. This class is not normally used directly, but rather created for
/// you as part of the android.app.ActivityGroup implementation.
///@see ActivityGroup
///@deprecated Use the new Fragment and FragmentManager APIs
/// instead; these are also
/// available on older platforms through the Android compatibility package.
class LocalActivityManager extends jni.JlObject {
  LocalActivityManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_LocalActivityManager_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.app.Activity parent, boolean singleMode)
  /// Create a new LocalActivityManager for holding activities running within
  /// the given <var>parent</var>.
  ///@param parent the host of the embedded activities
  ///@param singleMode True if the LocalActivityManger should keep a maximum
  /// of one activity resumed
  LocalActivityManager(Activity parent, bool singleMode)
      : super.fromRef(_ctor(parent.reference, singleMode ? 1 : 0));

  static final _startActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_LocalActivityManager_startActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.Window startActivity(java.lang.String id, android.content.Intent intent)
  /// Start a new activity running in the group.  Every activity you start
  /// must have a unique string ID associated with it -- this is used to keep
  /// track of the activity, so that if you later call startActivity() again
  /// on it the same activity object will be retained.
  ///
  /// When there had previously been an activity started under this id,
  /// it may either be destroyed and a new one started, or the current
  /// one re-used, based on these conditions, in order:
  ///
  ///
  /// <ul>
  /// <li> If the Intent maps to a different activity component than is
  /// currently running, the current activity is finished and a new one
  /// started.
  /// <li> If the current activity uses a non-multiple launch mode (such
  /// as singleTop), or the Intent has the
  /// Intent\#FLAG_ACTIVITY_SINGLE_TOP flag set, then the current
  /// activity will remain running and its
  /// Activity\#onNewIntent(Intent) Activity.onNewIntent() method
  /// called.
  /// <li> If the new Intent is the same (excluding extras) as the previous
  /// one, and the new Intent does not have the
  /// Intent\#FLAG_ACTIVITY_CLEAR_TOP set, then the current activity
  /// will remain running as-is.
  /// <li> Otherwise, the current activity will be finished and a new
  /// one started.
  /// </ul>
  ///
  /// If the given Intent can not be resolved to an available Activity,
  /// this method throws android.content.ActivityNotFoundException.
  ///
  /// Warning: There is an issue where, if the Intent does not
  /// include an explicit component, we can restore the state for a different
  /// activity class than was previously running when the state was saved (if
  /// the set of available activities changes between those points).
  ///@param id Unique identifier of the activity to be started
  ///@param intent The Intent describing the activity to be started
  ///@return Returns the window of the activity.  The caller needs to take
  /// care of adding this window to a view hierarchy, and likewise dealing
  /// with removing the old window if the activity has changed.
  ///@throws android.content.ActivityNotFoundException
  jni.JlObject startActivity(jni.JlString id, content.Intent intent) =>
      jni.JlObject.fromRef(
          _startActivity(reference, id.reference, intent.reference));

  static final _destroyActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_LocalActivityManager_destroyActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.Window destroyActivity(java.lang.String id, boolean finish)
  /// Destroy the activity associated with a particular id.  This activity
  /// will go through the normal lifecycle events and fine onDestroy(), and
  /// then the id removed from the group.
  ///@param id Unique identifier of the activity to be destroyed
  ///@param finish If true, this activity will be finished, so its id and
  /// all state are removed from the group.
  ///@return Returns the window that was used to display the activity, or
  /// null if there was none.
  jni.JlObject destroyActivity(jni.JlString id, bool finish) =>
      jni.JlObject.fromRef(
          _destroyActivity(reference, id.reference, finish ? 1 : 0));

  static final _getCurrentActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_LocalActivityManager_getCurrentActivity")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity getCurrentActivity()
  /// Retrieve the Activity that is currently running.
  ///@return the currently running (resumed) Activity, or null if there is
  ///         not one
  ///@see \#startActivity
  ///@see \#getCurrentId
  Activity getCurrentActivity() =>
      Activity.fromRef(_getCurrentActivity(reference));

  static final _getCurrentId = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_LocalActivityManager_getCurrentId")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getCurrentId()
  /// Retrieve the ID of the activity that is currently running.
  ///@return the ID of the currently running (resumed) Activity, or null if
  ///         there is not one
  ///@see \#startActivity
  ///@see \#getCurrentActivity
  jni.JlString getCurrentId() => jni.JlString.fromRef(_getCurrentId(reference));

  static final _getActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_LocalActivityManager_getActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity getActivity(java.lang.String id)
  /// Return the Activity object associated with a string ID.
  ///@see \#startActivity
  ///@return the associated Activity object, or null if the id is unknown or
  ///         its activity is not currently instantiated
  Activity getActivity(jni.JlString id) =>
      Activity.fromRef(_getActivity(reference, id.reference));

  static final _dispatchCreate = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_LocalActivityManager_dispatchCreate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchCreate(android.os.Bundle state)
  /// Restore a state that was previously returned by \#saveInstanceState.  This
  /// adds to the activity group information about all activity IDs that had
  /// previously been saved, even if they have not been started yet, so if the
  /// user later navigates to them the correct state will be restored.
  ///
  /// Note: This does __not__ change the current running activity, or
  /// start whatever activity was previously running when the state was saved.
  /// That is up to the client to do, in whatever way it thinks is best.
  ///@param state a previously saved state; does nothing if this is null
  ///@see \#saveInstanceState
  void dispatchCreate(os.Bundle state) =>
      _dispatchCreate(reference, state.reference);

  static final _saveInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_LocalActivityManager_saveInstanceState")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle saveInstanceState()
  /// Retrieve the state of all activities known by the group.  For
  /// activities that have previously run and are now stopped or finished, the
  /// last saved state is used.  For the current running activity, its
  /// Activity\#onSaveInstanceState is called to retrieve its current state.
  ///@return a Bundle holding the newly created state of all known activities
  ///@see \#dispatchCreate
  os.Bundle saveInstanceState() =>
      os.Bundle.fromRef(_saveInstanceState(reference));

  static final _dispatchResume =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_LocalActivityManager_dispatchResume")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchResume()
  /// Called by the container activity in its Activity\#onResume so
  /// that LocalActivityManager can perform the corresponding action on the
  /// activities it holds.
  ///@see Activity\#onResume
  void dispatchResume() => _dispatchResume(reference);

  static final _dispatchPause = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_LocalActivityManager_dispatchPause")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void dispatchPause(boolean finishing)
  /// Called by the container activity in its Activity\#onPause so
  /// that LocalActivityManager can perform the corresponding action on the
  /// activities it holds.
  ///@param finishing set to true if the parent activity has been finished;
  ///                  this can be determined by calling
  ///                  Activity.isFinishing()
  ///@see Activity\#onPause
  ///@see Activity\#isFinishing
  void dispatchPause(bool finishing) =>
      _dispatchPause(reference, finishing ? 1 : 0);

  static final _dispatchStop =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_LocalActivityManager_dispatchStop")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchStop()
  /// Called by the container activity in its Activity\#onStop so
  /// that LocalActivityManager can perform the corresponding action on the
  /// activities it holds.
  ///@see Activity\#onStop
  void dispatchStop() => _dispatchStop(reference);

  static final _removeAllActivities =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_LocalActivityManager_removeAllActivities")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void removeAllActivities()
  /// Remove all activities from this LocalActivityManager, performing an
  /// Activity\#onDestroy on any that are currently instantiated.
  void removeAllActivities() => _removeAllActivities(reference);

  static final _dispatchDestroy = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_LocalActivityManager_dispatchDestroy")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void dispatchDestroy(boolean finishing)
  /// Called by the container activity in its Activity\#onDestroy so
  /// that LocalActivityManager can perform the corresponding action on the
  /// activities it holds.
  ///@see Activity\#onDestroy
  void dispatchDestroy(bool finishing) =>
      _dispatchDestroy(reference, finishing ? 1 : 0);
}

/// Convenience for implementing an activity that will be implemented
/// purely in native code.  That is, a game (or game-like thing).  There
/// is no need to derive from this class; you can simply declare it in your
/// manifest, and use the NDK APIs from there.
///
/// A <a href="https://github.com/googlesamples/android-ndk/tree/master/native-activity">sample
/// native activity</a> is available in the NDK samples.
class NativeActivity extends Activity {
  NativeActivity.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String META_DATA_FUNC_NAME
  /// Optional meta-that can be in the manifest for this component, specifying
  /// the name of the main entry point for this native activity in the
  /// \#META_DATA_LIB_NAME native code.  If not specified,
  /// "ANativeActivity_onCreate" is used.
  static const META_DATA_FUNC_NAME = "android.app.func_name";

  /// from: static public final java.lang.String META_DATA_LIB_NAME
  /// Optional meta-that can be in the manifest for this component, specifying
  /// the name of the native shared library to load.  If not specified,
  /// "main" is used.
  static const META_DATA_LIB_NAME = "android.app.lib_name";

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_NativeActivity_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  NativeActivity() : super.fromRef(_ctor());

  static final _onCreate = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NativeActivity_onCreate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onCreate(android.os.Bundle savedInstanceState)
  void onCreate(os.Bundle savedInstanceState) =>
      _onCreate(reference, savedInstanceState.reference);

  static final _onDestroy =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NativeActivity_onDestroy")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onDestroy()
  void onDestroy() => _onDestroy(reference);

  static final _onPause =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NativeActivity_onPause")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPause()
  void onPause() => _onPause(reference);

  static final _onResume =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NativeActivity_onResume")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onResume()
  void onResume() => _onResume(reference);

  static final _onSaveInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NativeActivity_onSaveInstanceState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onSaveInstanceState(android.os.Bundle outState)
  void onSaveInstanceState(os.Bundle outState) =>
      _onSaveInstanceState(reference, outState.reference);

  static final _onStart =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NativeActivity_onStart")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStart()
  void onStart() => _onStart(reference);

  static final _onStop =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NativeActivity_onStop")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStop()
  void onStop() => _onStop(reference);

  static final _onConfigurationChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NativeActivity_onConfigurationChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onConfigurationChanged(android.content.res.Configuration newConfig)
  void onConfigurationChanged(res.Configuration newConfig) =>
      _onConfigurationChanged(reference, newConfig.reference);

  static final _onLowMemory =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NativeActivity_onLowMemory")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onLowMemory()
  void onLowMemory() => _onLowMemory(reference);

  static final _onWindowFocusChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_NativeActivity_onWindowFocusChanged")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onWindowFocusChanged(boolean hasFocus)
  void onWindowFocusChanged(bool hasFocus) =>
      _onWindowFocusChanged(reference, hasFocus ? 1 : 0);

  static final _surfaceCreated = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NativeActivity_surfaceCreated")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void surfaceCreated(android.view.SurfaceHolder holder)
  void surfaceCreated(jni.JlObject holder) =>
      _surfaceCreated(reference, holder.reference);

  static final _surfaceChanged = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("android_app_NativeActivity_surfaceChanged")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void surfaceChanged(android.view.SurfaceHolder holder, int format, int width, int height)
  void surfaceChanged(jni.JlObject holder, int format, int width, int height) =>
      _surfaceChanged(reference, holder.reference, format, width, height);

  static final _surfaceRedrawNeeded = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NativeActivity_surfaceRedrawNeeded")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void surfaceRedrawNeeded(android.view.SurfaceHolder holder)
  void surfaceRedrawNeeded(jni.JlObject holder) =>
      _surfaceRedrawNeeded(reference, holder.reference);

  static final _surfaceDestroyed = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NativeActivity_surfaceDestroyed")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void surfaceDestroyed(android.view.SurfaceHolder holder)
  void surfaceDestroyed(jni.JlObject holder) =>
      _surfaceDestroyed(reference, holder.reference);

  static final _onInputQueueCreated = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NativeActivity_onInputQueueCreated")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onInputQueueCreated(android.view.InputQueue queue)
  void onInputQueueCreated(jni.JlObject queue) =>
      _onInputQueueCreated(reference, queue.reference);

  static final _onInputQueueDestroyed = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NativeActivity_onInputQueueDestroyed")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onInputQueueDestroyed(android.view.InputQueue queue)
  void onInputQueueDestroyed(jni.JlObject queue) =>
      _onInputQueueDestroyed(reference, queue.reference);

  static final _onGlobalLayout =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NativeActivity_onGlobalLayout")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onGlobalLayout()
  void onGlobalLayout() => _onGlobalLayout(reference);
}

/// Interface used to control the instantiation of manifest elements.
///@see \#instantiateApplication
///@see \#instantiateActivity
///@see \#instantiateService
///@see \#instantiateReceiver
///@see \#instantiateProvider
class AppComponentFactory extends jni.JlObject {
  AppComponentFactory.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_AppComponentFactory_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  AppComponentFactory() : super.fromRef(_ctor());

  static final _instantiateApplication = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AppComponentFactory_instantiateApplication")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Application instantiateApplication(java.lang.ClassLoader cl, java.lang.String className)
  /// Allows application to override the creation of the application object. This can be used to
  /// perform things such as dependency injection or class loader changes to these
  /// classes.
  ///
  /// This method is only intended to provide a hook for instantiation. It does not provide
  /// earlier access to the Application object. The returned object will not be initialized
  /// as a Context yet and should not be used to interact with other android APIs.
  ///@param cl The default classloader to use for instantiation.
  /// This value must never be {@code null}.
  ///@param className The class to be instantiated.
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  Application instantiateApplication(jni.JlObject cl, jni.JlString className) =>
      Application.fromRef(_instantiateApplication(
          reference, cl.reference, className.reference));

  static final _instantiateActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AppComponentFactory_instantiateActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity instantiateActivity(java.lang.ClassLoader cl, java.lang.String className, android.content.Intent intent)
  /// Allows application to override the creation of activities. This can be used to
  /// perform things such as dependency injection or class loader changes to these
  /// classes.
  ///
  /// This method is only intended to provide a hook for instantiation. It does not provide
  /// earlier access to the Activity object. The returned object will not be initialized
  /// as a Context yet and should not be used to interact with other android APIs.
  ///@param cl The default classloader to use for instantiation.
  /// This value must never be {@code null}.
  ///@param className The class to be instantiated.
  /// This value must never be {@code null}.
  ///@param intent Intent creating the class.
  ///
  /// This value may be {@code null}.
  ///@return This value will never be {@code null}.
  Activity instantiateActivity(
          jni.JlObject cl, jni.JlString className, content.Intent intent) =>
      Activity.fromRef(_instantiateActivity(
          reference, cl.reference, className.reference, intent.reference));

  static final _instantiateReceiver = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AppComponentFactory_instantiateReceiver")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.BroadcastReceiver instantiateReceiver(java.lang.ClassLoader cl, java.lang.String className, android.content.Intent intent)
  /// Allows application to override the creation of receivers. This can be used to
  /// perform things such as dependency injection or class loader changes to these
  /// classes.
  ///@param cl The default classloader to use for instantiation.
  /// This value must never be {@code null}.
  ///@param className The class to be instantiated.
  /// This value must never be {@code null}.
  ///@param intent Intent creating the class.
  ///
  /// This value may be {@code null}.
  ///@return This value will never be {@code null}.
  content.BroadcastReceiver instantiateReceiver(
          jni.JlObject cl, jni.JlString className, content.Intent intent) =>
      content.BroadcastReceiver.fromRef(_instantiateReceiver(
          reference, cl.reference, className.reference, intent.reference));

  static final _instantiateService = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AppComponentFactory_instantiateService")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Service instantiateService(java.lang.ClassLoader cl, java.lang.String className, android.content.Intent intent)
  /// Allows application to override the creation of services. This can be used to
  /// perform things such as dependency injection or class loader changes to these
  /// classes.
  ///
  /// This method is only intended to provide a hook for instantiation. It does not provide
  /// earlier access to the Service object. The returned object will not be initialized
  /// as a Context yet and should not be used to interact with other android APIs.
  ///@param cl The default classloader to use for instantiation.
  /// This value must never be {@code null}.
  ///@param className The class to be instantiated.
  /// This value must never be {@code null}.
  ///@param intent Intent creating the class.
  ///
  /// This value may be {@code null}.
  ///@return This value will never be {@code null}.
  Service instantiateService(
          jni.JlObject cl, jni.JlString className, content.Intent intent) =>
      Service.fromRef(_instantiateService(
          reference, cl.reference, className.reference, intent.reference));

  static final _instantiateProvider = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AppComponentFactory_instantiateProvider")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ContentProvider instantiateProvider(java.lang.ClassLoader cl, java.lang.String className)
  /// Allows application to override the creation of providers. This can be used to
  /// perform things such as dependency injection or class loader changes to these
  /// classes.
  ///
  /// This method is only intended to provide a hook for instantiation. It does not provide
  /// earlier access to the ContentProvider object. The returned object will not be initialized
  /// with a Context yet and should not be used to interact with other android APIs.
  ///@param cl The default classloader to use for instantiation.
  /// This value must never be {@code null}.
  ///@param className The class to be instantiated.
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  content.ContentProvider instantiateProvider(
          jni.JlObject cl, jni.JlString className) =>
      content.ContentProvider.fromRef(
          _instantiateProvider(reference, cl.reference, className.reference));
}

/// FragmentManagerNonConfig stores the retained instance fragments across
/// activity recreation events.
///
/// Apps should treat objects of this type as opaque, returned by
/// and passed to the state save and restore process for fragments in
/// FragmentController\#retainNonConfig() and
/// FragmentController\#restoreAllState(Parcelable, FragmentManagerNonConfig).
///
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.FragmentManagerNonConfig
class FragmentManagerNonConfig extends jni.JlObject {
  FragmentManagerNonConfig.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManagerNonConfig_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(java.util.List<android.app.Fragment> fragments, java.util.List<android.app.FragmentManagerNonConfig> childNonConfigs)
  FragmentManagerNonConfig(jni.JlObject fragments, jni.JlObject childNonConfigs)
      : super.fromRef(_ctor(fragments.reference, childNonConfigs.reference));
}

/// Describes an application error.
///
/// A report has a type, which is one of
/// <ul>
/// <li> \#TYPE_NONE uninitialized instance of ApplicationErrorReport.
/// <li> \#TYPE_CRASH application crash. Information about the crash
/// is stored in \#crashInfo.
/// <li> \#TYPE_ANR application not responding. Information about the
/// ANR is stored in \#anrInfo.
/// <li> \#TYPE_BATTERY user reported application is using too much
/// battery. Information about the battery use is stored in \#batteryInfo.
/// <li> \#TYPE_RUNNING_SERVICE user reported application is leaving an
/// unneeded serive running. Information about the battery use is stored in
/// \#runningServiceInfo.
/// </ul>
class ApplicationErrorReport extends jni.JlObject {
  ApplicationErrorReport.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.ApplicationErrorReport> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_ApplicationErrorReport_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int TYPE_ANR
  /// An error report about an application that's not responding.
  static const TYPE_ANR = 2;

  /// from: static public final int TYPE_BATTERY
  /// An error report about an application that's consuming too much battery.
  static const TYPE_BATTERY = 3;

  /// from: static public final int TYPE_CRASH
  /// An error report about an application crash.
  static const TYPE_CRASH = 1;

  /// from: static public final int TYPE_NONE
  /// Uninitialized error report.
  static const TYPE_NONE = 0;

  /// from: static public final int TYPE_RUNNING_SERVICE
  /// A report from a user to a developer about a running service that the
  /// user doesn't think should be running.
  static const TYPE_RUNNING_SERVICE = 5;

  /// from: public android.app.ApplicationErrorReport.AnrInfo anrInfo
  /// If this report is of type \#TYPE_ANR, contains an instance
  /// of AnrInfo describing the ANR; otherwise null.
  static final _getanrInfo = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport_anrInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  ApplicationErrorReport_AnrInfo get anrInfo =>
      ApplicationErrorReport_AnrInfo.fromRef(_getanrInfo(reference));
  static final _setanrInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport_anrInfo")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set anrInfo(ApplicationErrorReport_AnrInfo value) =>
      _setanrInfo(reference, value.reference);

  /// from: public android.app.ApplicationErrorReport.BatteryInfo batteryInfo
  /// If this report is of type \#TYPE_BATTERY, contains an instance
  /// of BatteryInfo; otherwise null.
  static final _getbatteryInfo = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport_batteryInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  ApplicationErrorReport_BatteryInfo get batteryInfo =>
      ApplicationErrorReport_BatteryInfo.fromRef(_getbatteryInfo(reference));
  static final _setbatteryInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport_batteryInfo")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set batteryInfo(ApplicationErrorReport_BatteryInfo value) =>
      _setbatteryInfo(reference, value.reference);

  /// from: public android.app.ApplicationErrorReport.CrashInfo crashInfo
  /// If this report is of type \#TYPE_CRASH, contains an instance
  /// of CrashInfo describing the crash; otherwise null.
  static final _getcrashInfo = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport_crashInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  ApplicationErrorReport_CrashInfo get crashInfo =>
      ApplicationErrorReport_CrashInfo.fromRef(_getcrashInfo(reference));
  static final _setcrashInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport_crashInfo")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set crashInfo(ApplicationErrorReport_CrashInfo value) =>
      _setcrashInfo(reference, value.reference);

  /// from: public java.lang.String installerPackageName
  /// Package name of the application which installed the application this
  /// report pertains to.
  /// This identifies which market the application came from.
  static final _getinstallerPackageName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport_installerPackageName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get installerPackageName =>
      jni.JlString.fromRef(_getinstallerPackageName(reference));
  static final _setinstallerPackageName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport_installerPackageName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set installerPackageName(jni.JlString value) =>
      _setinstallerPackageName(reference, value.reference);

  /// from: public java.lang.String packageName
  /// Package name of the application.
  static final _getpackageName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport_packageName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get packageName =>
      jni.JlString.fromRef(_getpackageName(reference));
  static final _setpackageName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport_packageName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set packageName(jni.JlString value) =>
      _setpackageName(reference, value.reference);

  /// from: public java.lang.String processName
  /// Process name of the application.
  static final _getprocessName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport_processName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get processName =>
      jni.JlString.fromRef(_getprocessName(reference));
  static final _setprocessName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport_processName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set processName(jni.JlString value) =>
      _setprocessName(reference, value.reference);

  /// from: public android.app.ApplicationErrorReport.RunningServiceInfo runningServiceInfo
  /// If this report is of type \#TYPE_RUNNING_SERVICE, contains an instance
  /// of RunningServiceInfo; otherwise null.
  static final _getrunningServiceInfo = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport_runningServiceInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  ApplicationErrorReport_RunningServiceInfo get runningServiceInfo =>
      ApplicationErrorReport_RunningServiceInfo.fromRef(
          _getrunningServiceInfo(reference));
  static final _setrunningServiceInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport_runningServiceInfo")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set runningServiceInfo(ApplicationErrorReport_RunningServiceInfo value) =>
      _setrunningServiceInfo(reference, value.reference);

  /// from: public boolean systemApp
  /// Set if the app is on the system image.
  static final _getsystemApp = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport_systemApp")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  bool get systemApp => _getsystemApp(reference) != 0;
  static final _setsystemApp = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_android_app_ApplicationErrorReport_systemApp")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set systemApp(bool value) => _setsystemApp(reference, value ? 1 : 0);

  /// from: public long time
  /// Time at which the error occurred.
  static final _gettime = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport_time")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get time => _gettime(reference);
  static final _settime = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("set_android_app_ApplicationErrorReport_time")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set time(int value) => _settime(reference, value);

  /// from: public int type
  /// Type of this report. Can be one of \#TYPE_NONE,
  /// \#TYPE_CRASH, \#TYPE_ANR, \#TYPE_BATTERY,
  /// or \#TYPE_RUNNING_SERVICE.
  static final _gettype = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport_type")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get type => _gettype(reference);
  static final _settype = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_app_ApplicationErrorReport_type")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set type(int value) => _settype(reference, value);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ApplicationErrorReport_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Create an uninitialized instance of ApplicationErrorReport.
  ApplicationErrorReport() : super.fromRef(_ctor());

  static final _getErrorReportReceiver = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ApplicationErrorReport_getErrorReportReceiver")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.content.ComponentName getErrorReportReceiver(android.content.Context context, java.lang.String packageName, int appFlags)
  static content.ComponentName getErrorReportReceiver(
          content.Context context, jni.JlString packageName, int appFlags) =>
      content.ComponentName.fromRef(_getErrorReportReceiver(
          context.reference, packageName.reference, appFlags));

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ApplicationErrorReport_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _readFromParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ApplicationErrorReport_readFromParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel in)
  void readFromParcel(os.Parcel in_) =>
      _readFromParcel(reference, in_.reference);

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ApplicationErrorReport_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _dump = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ApplicationErrorReport_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  /// Dump the report to a Printer.
  void dump(jni.JlObject pw, jni.JlString prefix) =>
      _dump(reference, pw.reference, prefix.reference);
}

/// Describes a running service report.
class ApplicationErrorReport_RunningServiceInfo extends jni.JlObject {
  ApplicationErrorReport_RunningServiceInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: public long durationMillis
  /// Duration in milliseconds that the service has been running.
  static final _getdurationMillis = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport__RunningServiceInfo_durationMillis")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get durationMillis => _getdurationMillis(reference);
  static final _setdurationMillis = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_app_ApplicationErrorReport__RunningServiceInfo_durationMillis")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set durationMillis(int value) => _setdurationMillis(reference, value);

  /// from: public java.lang.String serviceDetails
  /// Dump of debug information about the service.
  static final _getserviceDetails = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport__RunningServiceInfo_serviceDetails")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get serviceDetails =>
      jni.JlString.fromRef(_getserviceDetails(reference));
  static final _setserviceDetails = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport__RunningServiceInfo_serviceDetails")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set serviceDetails(jni.JlString value) =>
      _setserviceDetails(reference, value.reference);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ApplicationErrorReport__RunningServiceInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Create an uninitialized instance of RunningServiceInfo.
  ApplicationErrorReport_RunningServiceInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ApplicationErrorReport__RunningServiceInfo_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel in)
  /// Create an instance of RunningServiceInfo initialized from a Parcel.
  ApplicationErrorReport_RunningServiceInfo.ctor_1(os.Parcel in_)
      : super.fromRef(_ctor_1(in_.reference));

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ApplicationErrorReport__RunningServiceInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  /// Save a RunningServiceInfo instance to a parcel.
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _dump = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ApplicationErrorReport__RunningServiceInfo_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  /// Dump a BatteryInfo instance to a Printer.
  void dump(jni.JlObject pw, jni.JlString prefix) =>
      _dump(reference, pw.reference, prefix.reference);
}

/// Describes an application crash.
class ApplicationErrorReport_CrashInfo extends jni.JlObject {
  ApplicationErrorReport_CrashInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: public java.lang.String exceptionClassName
  /// Class name of the exception that caused the crash.
  static final _getexceptionClassName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport__CrashInfo_exceptionClassName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get exceptionClassName =>
      jni.JlString.fromRef(_getexceptionClassName(reference));
  static final _setexceptionClassName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport__CrashInfo_exceptionClassName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set exceptionClassName(jni.JlString value) =>
      _setexceptionClassName(reference, value.reference);

  /// from: public java.lang.String exceptionMessage
  /// Message stored in the exception.
  static final _getexceptionMessage = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport__CrashInfo_exceptionMessage")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get exceptionMessage =>
      jni.JlString.fromRef(_getexceptionMessage(reference));
  static final _setexceptionMessage = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport__CrashInfo_exceptionMessage")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set exceptionMessage(jni.JlString value) =>
      _setexceptionMessage(reference, value.reference);

  /// from: public java.lang.String stackTrace
  /// Stack trace.
  static final _getstackTrace = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport__CrashInfo_stackTrace")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get stackTrace =>
      jni.JlString.fromRef(_getstackTrace(reference));
  static final _setstackTrace = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport__CrashInfo_stackTrace")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set stackTrace(jni.JlString value) =>
      _setstackTrace(reference, value.reference);

  /// from: public java.lang.String throwClassName
  /// Class which the exception was thrown from.
  static final _getthrowClassName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport__CrashInfo_throwClassName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get throwClassName =>
      jni.JlString.fromRef(_getthrowClassName(reference));
  static final _setthrowClassName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport__CrashInfo_throwClassName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set throwClassName(jni.JlString value) =>
      _setthrowClassName(reference, value.reference);

  /// from: public java.lang.String throwFileName
  /// File which the exception was thrown from.
  static final _getthrowFileName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport__CrashInfo_throwFileName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get throwFileName =>
      jni.JlString.fromRef(_getthrowFileName(reference));
  static final _setthrowFileName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport__CrashInfo_throwFileName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set throwFileName(jni.JlString value) =>
      _setthrowFileName(reference, value.reference);

  /// from: public int throwLineNumber
  /// Line number the exception was thrown from.
  static final _getthrowLineNumber = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport__CrashInfo_throwLineNumber")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get throwLineNumber => _getthrowLineNumber(reference);
  static final _setthrowLineNumber = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ApplicationErrorReport__CrashInfo_throwLineNumber")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set throwLineNumber(int value) => _setthrowLineNumber(reference, value);

  /// from: public java.lang.String throwMethodName
  /// Method which the exception was thrown from.
  static final _getthrowMethodName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport__CrashInfo_throwMethodName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get throwMethodName =>
      jni.JlString.fromRef(_getthrowMethodName(reference));
  static final _setthrowMethodName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport__CrashInfo_throwMethodName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set throwMethodName(jni.JlString value) =>
      _setthrowMethodName(reference, value.reference);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ApplicationErrorReport__CrashInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Create an uninitialized instance of CrashInfo.
  ApplicationErrorReport_CrashInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ApplicationErrorReport__CrashInfo_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.Throwable tr)
  /// Create an instance of CrashInfo initialized from an exception.
  ApplicationErrorReport_CrashInfo.ctor_1(jni.JlObject tr)
      : super.fromRef(_ctor_1(tr.reference));

  static final _ctor_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ApplicationErrorReport__CrashInfo_new_2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel in)
  /// Create an instance of CrashInfo initialized from a Parcel.
  ApplicationErrorReport_CrashInfo.ctor_2(os.Parcel in_)
      : super.fromRef(_ctor_2(in_.reference));

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ApplicationErrorReport__CrashInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  /// Save a CrashInfo instance to a parcel.
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _dump = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ApplicationErrorReport__CrashInfo_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  /// Dump a CrashInfo instance to a Printer.
  void dump(jni.JlObject pw, jni.JlString prefix) =>
      _dump(reference, pw.reference, prefix.reference);
}

/// Describes a battery usage report.
class ApplicationErrorReport_BatteryInfo extends jni.JlObject {
  ApplicationErrorReport_BatteryInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: public java.lang.String checkinDetails
  /// Checkin details.
  static final _getcheckinDetails = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport__BatteryInfo_checkinDetails")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get checkinDetails =>
      jni.JlString.fromRef(_getcheckinDetails(reference));
  static final _setcheckinDetails = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport__BatteryInfo_checkinDetails")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set checkinDetails(jni.JlString value) =>
      _setcheckinDetails(reference, value.reference);

  /// from: public long durationMicros
  /// Duration in microseconds over which the process used the above
  /// percentage of battery.
  static final _getdurationMicros = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport__BatteryInfo_durationMicros")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get durationMicros => _getdurationMicros(reference);
  static final _setdurationMicros = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_app_ApplicationErrorReport__BatteryInfo_durationMicros")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set durationMicros(int value) => _setdurationMicros(reference, value);

  /// from: public java.lang.String usageDetails
  /// Dump of various info impacting battery use.
  static final _getusageDetails = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport__BatteryInfo_usageDetails")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get usageDetails =>
      jni.JlString.fromRef(_getusageDetails(reference));
  static final _setusageDetails = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport__BatteryInfo_usageDetails")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set usageDetails(jni.JlString value) =>
      _setusageDetails(reference, value.reference);

  /// from: public int usagePercent
  /// Percentage of the battery that was used up by the process.
  static final _getusagePercent = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport__BatteryInfo_usagePercent")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get usagePercent => _getusagePercent(reference);
  static final _setusagePercent = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ApplicationErrorReport__BatteryInfo_usagePercent")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set usagePercent(int value) => _setusagePercent(reference, value);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ApplicationErrorReport__BatteryInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Create an uninitialized instance of BatteryInfo.
  ApplicationErrorReport_BatteryInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ApplicationErrorReport__BatteryInfo_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel in)
  /// Create an instance of BatteryInfo initialized from a Parcel.
  ApplicationErrorReport_BatteryInfo.ctor_1(os.Parcel in_)
      : super.fromRef(_ctor_1(in_.reference));

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ApplicationErrorReport__BatteryInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  /// Save a BatteryInfo instance to a parcel.
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _dump = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ApplicationErrorReport__BatteryInfo_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  /// Dump a BatteryInfo instance to a Printer.
  void dump(jni.JlObject pw, jni.JlString prefix) =>
      _dump(reference, pw.reference, prefix.reference);
}

/// Describes an application not responding error.
class ApplicationErrorReport_AnrInfo extends jni.JlObject {
  ApplicationErrorReport_AnrInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: public java.lang.String activity
  /// Activity name.
  static final _getactivity = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport__AnrInfo_activity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get activity => jni.JlString.fromRef(_getactivity(reference));
  static final _setactivity = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport__AnrInfo_activity")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set activity(jni.JlString value) => _setactivity(reference, value.reference);

  /// from: public java.lang.String cause
  /// Description of the operation that timed out.
  static final _getcause = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport__AnrInfo_cause")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get cause => jni.JlString.fromRef(_getcause(reference));
  static final _setcause = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport__AnrInfo_cause")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set cause(jni.JlString value) => _setcause(reference, value.reference);

  /// from: public java.lang.String info
  /// Additional info, including CPU stats.
  static final _getinfo = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ApplicationErrorReport__AnrInfo_info")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get info => jni.JlString.fromRef(_getinfo(reference));
  static final _setinfo = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ApplicationErrorReport__AnrInfo_info")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set info(jni.JlString value) => _setinfo(reference, value.reference);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ApplicationErrorReport__AnrInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Create an uninitialized instance of AnrInfo.
  ApplicationErrorReport_AnrInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ApplicationErrorReport__AnrInfo_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel in)
  /// Create an instance of AnrInfo initialized from a Parcel.
  ApplicationErrorReport_AnrInfo.ctor_1(os.Parcel in_)
      : super.fromRef(_ctor_1(in_.reference));

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ApplicationErrorReport__AnrInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  /// Save an AnrInfo instance to a parcel.
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _dump = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ApplicationErrorReport__AnrInfo_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  /// Dump an AnrInfo instance to a Printer.
  void dump(jni.JlObject pw, jni.JlString prefix) =>
      _dump(reference, pw.reference, prefix.reference);
}

class MediaRouteButton extends jni.JlObject {
  MediaRouteButton.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_MediaRouteButton_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  MediaRouteButton(content.Context context)
      : super.fromRef(_ctor(context.reference));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_MediaRouteButton_new_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  MediaRouteButton.ctor_1(content.Context context, jni.JlObject attrs)
      : super.fromRef(_ctor_1(context.reference, attrs.reference));

  static final _ctor_2 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_MediaRouteButton_new_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  MediaRouteButton.ctor_2(
      content.Context context, jni.JlObject attrs, int defStyleAttr)
      : super.fromRef(
            _ctor_2(context.reference, attrs.reference, defStyleAttr));

  static final _ctor_3 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32)>>("android_app_MediaRouteButton_new_3")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  MediaRouteButton.ctor_3(content.Context context, jni.JlObject attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(_ctor_3(
            context.reference, attrs.reference, defStyleAttr, defStyleRes));

  static final _getRouteTypes =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_MediaRouteButton_getRouteTypes")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getRouteTypes()
  /// Gets the media route types for filtering the routes that the user can
  /// select using the media route chooser dialog.
  ///@return The route types.
  int getRouteTypes() => _getRouteTypes(reference);

  static final _setRouteTypes = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_MediaRouteButton_setRouteTypes")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setRouteTypes(int types)
  /// Sets the types of routes that will be shown in the media route chooser dialog
  /// launched by this button.
  ///@param types The route types to match.
  void setRouteTypes(int types) => _setRouteTypes(reference, types);

  static final _setExtendedSettingsClickListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_MediaRouteButton_setExtendedSettingsClickListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExtendedSettingsClickListener(android.view.View.OnClickListener listener)
  void setExtendedSettingsClickListener(jni.JlObject listener) =>
      _setExtendedSettingsClickListener(reference, listener.reference);

  static final _showDialog =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_MediaRouteButton_showDialog")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void showDialog()
  /// Show the route chooser or controller dialog.
  ///
  /// If the default route is selected or if the currently selected route does
  /// not match the \#getRouteTypes route types, then shows the route chooser dialog.
  /// Otherwise, shows the route controller dialog to offer the user
  /// a choice to disconnect from the route or perform other control actions
  /// such as setting the route's volume.
  ///
  ///
  /// This will attach a DialogFragment to the containing Activity.
  ///
  ///
  void showDialog() => _showDialog(reference);

  static final _setContentDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_MediaRouteButton_setContentDescription")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setContentDescription(java.lang.CharSequence contentDescription)
  void setContentDescription(jni.JlObject contentDescription) =>
      _setContentDescription(reference, contentDescription.reference);

  static final _performClick =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_MediaRouteButton_performClick")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean performClick()
  bool performClick() => _performClick(reference) != 0;

  static final _onCreateDrawableState = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_MediaRouteButton_onCreateDrawableState")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: protected int[] onCreateDrawableState(int extraSpace)
  jni.JlObject onCreateDrawableState(int extraSpace) =>
      jni.JlObject.fromRef(_onCreateDrawableState(reference, extraSpace));

  static final _drawableStateChanged =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_MediaRouteButton_drawableStateChanged")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void drawableStateChanged()
  void drawableStateChanged() => _drawableStateChanged(reference);

  static final _verifyDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_MediaRouteButton_verifyDrawable")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected boolean verifyDrawable(android.graphics.drawable.Drawable who)
  /// @param who This value must never be {@code null}.
  bool verifyDrawable(jni.JlObject who) =>
      _verifyDrawable(reference, who.reference) != 0;

  static final _jumpDrawablesToCurrentState =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_MediaRouteButton_jumpDrawablesToCurrentState")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void jumpDrawablesToCurrentState()
  void jumpDrawablesToCurrentState() => _jumpDrawablesToCurrentState(reference);

  static final _setVisibility = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_MediaRouteButton_setVisibility")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setVisibility(int visibility)
  void setVisibility(int visibility) => _setVisibility(reference, visibility);

  static final _onAttachedToWindow =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_MediaRouteButton_onAttachedToWindow")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttachedToWindow()
  void onAttachedToWindow() => _onAttachedToWindow(reference);

  static final _onDetachedFromWindow =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_MediaRouteButton_onDetachedFromWindow")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDetachedFromWindow()
  void onDetachedFromWindow() => _onDetachedFromWindow(reference);

  static final _onMeasure = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_app_MediaRouteButton_onMeasure")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  void onMeasure(int widthMeasureSpec, int heightMeasureSpec) =>
      _onMeasure(reference, widthMeasureSpec, heightMeasureSpec);

  static final _onDraw = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_MediaRouteButton_onDraw")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onDraw(android.graphics.Canvas canvas)
  void onDraw(jni.JlObject canvas) => _onDraw(reference, canvas.reference);
}

/// The media route action provider displays a MediaRouteButton media route button
/// in the application's ActionBar to allow the user to select routes and
/// to control the currently selected route.
///
/// The application must specify the kinds of routes that the user should be allowed
/// to select by specifying the route types with the \#setRouteTypes method.
///
///
/// Refer to MediaRouteButton for a description of the button that will
/// appear in the action bar menu.  Note that instead of disabling the button
/// when no routes are available, the action provider will instead make the
/// menu item invisible.  In this way, the button will only be visible when it
/// is possible for the user to discover and select a matching route.
///
///
class MediaRouteActionProvider extends jni.JlObject {
  MediaRouteActionProvider.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_MediaRouteActionProvider_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  MediaRouteActionProvider(content.Context context)
      : super.fromRef(_ctor(context.reference));

  static final _setRouteTypes = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_MediaRouteActionProvider_setRouteTypes")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setRouteTypes(int types)
  /// Sets the types of routes that will be shown in the media route chooser dialog
  /// launched by this button.
  ///@param types The route types to match.
  void setRouteTypes(int types) => _setRouteTypes(reference, types);

  static final _setExtendedSettingsClickListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_MediaRouteActionProvider_setExtendedSettingsClickListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExtendedSettingsClickListener(android.view.View.OnClickListener listener)
  void setExtendedSettingsClickListener(jni.JlObject listener) =>
      _setExtendedSettingsClickListener(reference, listener.reference);

  static final _onCreateActionView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_MediaRouteActionProvider_onCreateActionView")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View onCreateActionView()
  jni.JlObject onCreateActionView() =>
      jni.JlObject.fromRef(_onCreateActionView(reference));

  static final _onCreateActionView_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_MediaRouteActionProvider_onCreateActionView_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View onCreateActionView(android.view.MenuItem item)
  jni.JlObject onCreateActionView_1(jni.JlObject item) =>
      jni.JlObject.fromRef(_onCreateActionView_1(reference, item.reference));

  static final _onPerformDefaultAction =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_MediaRouteActionProvider_onPerformDefaultAction")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onPerformDefaultAction()
  bool onPerformDefaultAction() => _onPerformDefaultAction(reference) != 0;

  static final _overridesItemVisibility =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_MediaRouteActionProvider_overridesItemVisibility")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean overridesItemVisibility()
  bool overridesItemVisibility() => _overridesItemVisibility(reference) != 0;

  static final _isVisible =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_MediaRouteActionProvider_isVisible")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isVisible()
  bool isVisible() => _isVisible(reference) != 0;
}

/// This class provides access to the system search services.
///
/// In practice, you won't interact with this class directly, as search
/// services are provided through methods in android.app.Activity Activity
/// and the android.content.Intent\#ACTION_SEARCH ACTION_SEARCH
/// android.content.Intent Intent.
///
///
/// Configuration\#UI_MODE_TYPE_WATCH does not support this system service.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using the search dialog and adding search
/// suggestions in your application, read the
/// <a href="{@docRoot}guide/topics/search/index.html">Search</a> developer guide.
///
/// </div>
class SearchManager extends jni.JlObject {
  SearchManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_KEY
  /// Intent extra data key: Use this key with Intent.ACTION_SEARCH and
  /// android.content.Intent\#getIntExtra content.Intent.getIntExtra()
  /// to obtain the keycode that the user used to trigger this query.  It will be zero if the
  /// user simply pressed the "GO" button on the search UI.  This is primarily used in conjunction
  /// with the keycode attribute in the actionkey element of your searchable.xml configuration
  /// file.
  static const ACTION_KEY = "action_key";

  /// from: static public final java.lang.String ACTION_MSG
  /// Intent extra data key: Use this key with Intent.ACTION_SEARCH and
  /// android.content.Intent\#getStringExtra content.Intent.getStringExtra()
  /// to obtain the action message that was defined for a particular search action key and/or
  /// suggestion.  It will be null if the search was launched by typing "enter", touched the the
  /// "GO" button, or other means not involving any action key.
  static const ACTION_MSG = "action_msg";

  /// from: static public final java.lang.String APP_DATA
  /// Intent extra data key: Use this key with Intent.ACTION_SEARCH and
  /// android.content.Intent\#getBundleExtra content.Intent.getBundleExtra()
  /// to obtain any additional app-specific data that was inserted by the
  /// activity that launched the search.
  static const APP_DATA = "app_data";

  /// from: static public final java.lang.String CURSOR_EXTRA_KEY_IN_PROGRESS
  /// Boolean extra data key for a suggestion provider to return in Cursor\#getExtras to
  /// indicate that the search is not complete yet. This can be used by the search UI
  /// to indicate that a search is in progress. The suggestion provider can return partial results
  /// this way and send a change notification on the cursor when more results are available.
  static const CURSOR_EXTRA_KEY_IN_PROGRESS = "in_progress";

  /// from: static public final java.lang.String EXTRA_DATA_KEY
  /// Intent extra data key: This key will be used for the extra populated by the
  /// \#SUGGEST_COLUMN_INTENT_EXTRA_DATA column.
  static const EXTRA_DATA_KEY = "intent_extra_data_key";

  /// from: static public final java.lang.String EXTRA_NEW_SEARCH
  /// Boolean extra data key for Intent\#ACTION_WEB_SEARCH intents.  If {@code true},
  /// this search should open a new browser window, rather than using an existing one.
  static const EXTRA_NEW_SEARCH = "new_search";

  /// from: static public final java.lang.String EXTRA_SELECT_QUERY
  /// Boolean extra data key for \#INTENT_ACTION_GLOBAL_SEARCH intents. If {@code true},
  /// the initial query should be selected when the global search activity is started, so
  /// that the user can easily replace it with another query.
  static const EXTRA_SELECT_QUERY = "select_query";

  /// from: static public final java.lang.String EXTRA_WEB_SEARCH_PENDINGINTENT
  /// Extra data key for Intent\#ACTION_WEB_SEARCH. If set, the value must be a
  /// PendingIntent. The search activity handling the Intent\#ACTION_WEB_SEARCH
  /// intent will fill in and launch the pending intent. The data URI will be filled in with an
  /// http or https URI, and android.provider.Browser\#EXTRA_HEADERS may be filled in.
  static const EXTRA_WEB_SEARCH_PENDINGINTENT = "web_search_pendingintent";

  /// from: static public final int FLAG_QUERY_REFINEMENT
  /// Flag to specify that the entry can be used for query refinement, i.e., the query text
  /// in the search field can be replaced with the text in this entry, when a query refinement
  /// icon is clicked. The suggestion list should show such a clickable icon beside the entry.
  /// Use this flag as a bit-field for \#SUGGEST_COLUMN_FLAGS.
  static const FLAG_QUERY_REFINEMENT = 1;

  /// from: static public final java.lang.String INTENT_ACTION_GLOBAL_SEARCH
  /// Intent action for starting the global search activity.
  /// The global search provider should handle this intent.
  ///
  /// Supported extra data keys: \#QUERY,
  /// \#EXTRA_SELECT_QUERY,
  /// \#APP_DATA.
  static const INTENT_ACTION_GLOBAL_SEARCH =
      "android.search.action.GLOBAL_SEARCH";

  /// from: static public final java.lang.String INTENT_ACTION_SEARCHABLES_CHANGED
  /// Intent action broadcasted to inform that the searchables list or default have changed.
  /// Components should handle this intent if they cache any searchable data and wish to stay
  /// up to date on changes.
  static const INTENT_ACTION_SEARCHABLES_CHANGED =
      "android.search.action.SEARCHABLES_CHANGED";

  /// from: static public final java.lang.String INTENT_ACTION_SEARCH_SETTINGS
  /// Intent action for starting the global search settings activity.
  /// The global search provider should handle this intent.
  static const INTENT_ACTION_SEARCH_SETTINGS =
      "android.search.action.SEARCH_SETTINGS";

  /// from: static public final java.lang.String INTENT_ACTION_SEARCH_SETTINGS_CHANGED
  /// Intent action broadcasted to inform that the search settings have changed in some way.
  /// Either searchables have been enabled or disabled, or a different web search provider
  /// has been chosen.
  static const INTENT_ACTION_SEARCH_SETTINGS_CHANGED =
      "android.search.action.SETTINGS_CHANGED";

  /// from: static public final java.lang.String INTENT_ACTION_WEB_SEARCH_SETTINGS
  /// Intent action for starting a web search provider's settings activity.
  /// Web search providers should handle this intent if they have provider-specific
  /// settings to implement.
  static const INTENT_ACTION_WEB_SEARCH_SETTINGS =
      "android.search.action.WEB_SEARCH_SETTINGS";

  /// from: static public final java.lang.String INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED
  /// Intent action to be broadcast to inform that the global search provider
  /// has changed.
  static const INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED =
      "android.search.action.GLOBAL_SEARCH_ACTIVITY_CHANGED";

  /// from: static public final char MENU_KEY
  /// This is a shortcut definition for the default menu key to use for invoking search.
  ///
  /// See Menu.Item.setAlphabeticShortcut() for more information.
  static const MENU_KEY = "s";

  /// from: static public final int MENU_KEYCODE
  /// This is a shortcut definition for the default menu key to use for invoking search.
  ///
  /// See Menu.Item.setAlphabeticShortcut() for more information.
  static const MENU_KEYCODE = 47;

  /// from: static public final java.lang.String QUERY
  /// Intent extra data key: Use this key with
  /// android.content.Intent\#getStringExtra content.Intent.getStringExtra()
  /// to obtain the query string from Intent.ACTION_SEARCH.
  static const QUERY = "query";

  /// from: static public final java.lang.String SHORTCUT_MIME_TYPE
  /// MIME type for shortcut validation.  You'll use this in your suggestions content provider
  /// in the getType() function.
  static const SHORTCUT_MIME_TYPE =
      "vnd.android.cursor.item/vnd.android.search.suggest";

  /// from: static public final java.lang.String SUGGEST_COLUMN_AUDIO_CHANNEL_CONFIG
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content contains audio, you
  /// should provide this column to specify the audio channel configuration. The data in the
  /// column is string with format like "channels.subchannels" such as "1.0" or "5.1".
  static const SUGGEST_COLUMN_AUDIO_CHANNEL_CONFIG =
      "suggest_audio_channel_config";

  /// from: static public final java.lang.String SUGGEST_COLUMN_CONTENT_TYPE
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content is media type, you
  /// should provide this column so search app could understand more about your content. The data
  /// in the column must specify the MIME type of the content.
  static const SUGGEST_COLUMN_CONTENT_TYPE = "suggest_content_type";

  /// from: static public final java.lang.String SUGGEST_COLUMN_DURATION
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content is video or audio, you
  /// should provide this column to specify the duration of your content in milliseconds. The data
  /// in the column is of long type.
  static const SUGGEST_COLUMN_DURATION = "suggest_duration";

  /// from: static public final java.lang.String SUGGEST_COLUMN_FLAGS
  /// Column name for suggestions cursor. <i>Optional.</i> This column is used to specify
  /// additional flags per item. Multiple flags can be specified.
  ///
  /// Must be one of \#FLAG_QUERY_REFINEMENT or 0 to indicate no flags.
  ///
  ///
  static const SUGGEST_COLUMN_FLAGS = "suggest_flags";

  /// from: static public final java.lang.String SUGGEST_COLUMN_FORMAT
  /// Column name for suggestions cursor.  <i>Unused - can be null or column can be omitted.</i>
  static const SUGGEST_COLUMN_FORMAT = "suggest_format";

  /// from: static public final java.lang.String SUGGEST_COLUMN_ICON_1
  /// Column name for suggestions cursor.  <i>Optional.</i>  If your cursor includes this column,
  ///  then all suggestions will be provided in a format that includes space for two small icons,
  ///  one at the left and one at the right of each suggestion.  The data in the column must
  ///  be a resource ID of a drawable, or a URI in one of the following formats:
  ///
  /// <ul>
  /// <li>content (android.content.ContentResolver\#SCHEME_CONTENT)</li>
  /// <li>android.resource (android.content.ContentResolver\#SCHEME_ANDROID_RESOURCE)</li>
  /// <li>file (android.content.ContentResolver\#SCHEME_FILE)</li>
  /// </ul>
  ///
  /// See android.content.ContentResolver\#openAssetFileDescriptor(Uri, String)
  /// for more information on these schemes.
  static const SUGGEST_COLUMN_ICON_1 = "suggest_icon_1";

  /// from: static public final java.lang.String SUGGEST_COLUMN_ICON_2
  /// Column name for suggestions cursor.  <i>Optional.</i>  If your cursor includes this column,
  ///  then all suggestions will be provided in a format that includes space for two small icons,
  ///  one at the left and one at the right of each suggestion.  The data in the column must
  ///  be a resource ID of a drawable, or a URI in one of the following formats:
  ///
  /// <ul>
  /// <li>content (android.content.ContentResolver\#SCHEME_CONTENT)</li>
  /// <li>android.resource (android.content.ContentResolver\#SCHEME_ANDROID_RESOURCE)</li>
  /// <li>file (android.content.ContentResolver\#SCHEME_FILE)</li>
  /// </ul>
  ///
  /// See android.content.ContentResolver\#openAssetFileDescriptor(Uri, String)
  /// for more information on these schemes.
  static const SUGGEST_COLUMN_ICON_2 = "suggest_icon_2";

  /// from: static public final java.lang.String SUGGEST_COLUMN_INTENT_ACTION
  /// Column name for suggestions cursor.  <i>Optional.</i>  If this column exists <i>and</i>
  /// this element exists at the given row, this is the action that will be used when
  /// forming the suggestion's intent.  If the element is not provided, the action will be taken
  /// from the android:searchSuggestIntentAction field in your XML metadata.  <i>At least one of
  /// these must be present for the suggestion to generate an intent.</i>  Note:  If your action is
  /// the same for all suggestions, it is more efficient to specify it using XML metadata and omit
  /// it from the cursor.
  static const SUGGEST_COLUMN_INTENT_ACTION = "suggest_intent_action";

  /// from: static public final java.lang.String SUGGEST_COLUMN_INTENT_DATA
  /// Column name for suggestions cursor.  <i>Optional.</i>  If this column exists <i>and</i>
  /// this element exists at the given row, this is the data that will be used when
  /// forming the suggestion's intent.  If the element is not provided, the data will be taken
  /// from the android:searchSuggestIntentData field in your XML metadata.  If neither source
  /// is provided, the Intent's data field will be null.  Note:  If your data is
  /// the same for all suggestions, or can be described using a constant part and a specific ID,
  /// it is more efficient to specify it using XML metadata and omit it from the cursor.
  static const SUGGEST_COLUMN_INTENT_DATA = "suggest_intent_data";

  /// from: static public final java.lang.String SUGGEST_COLUMN_INTENT_DATA_ID
  /// Column name for suggestions cursor.  <i>Optional.</i>  If this column exists <i>and</i>
  /// this element exists at the given row, then "/" and this value will be appended to the data
  /// field in the Intent.  This should only be used if the data field has already been set to an
  /// appropriate base string.
  static const SUGGEST_COLUMN_INTENT_DATA_ID = "suggest_intent_data_id";

  /// from: static public final java.lang.String SUGGEST_COLUMN_INTENT_EXTRA_DATA
  /// Column name for suggestions cursor.  <i>Optional.</i>  If this column exists <i>and</i>
  /// this element exists at the given row, this is the data that will be used when
  /// forming the suggestion's intent. If not provided, the Intent's extra data field will be null.
  /// This column allows suggestions to provide additional arbitrary data which will be included as
  /// an extra under the key \#EXTRA_DATA_KEY.
  static const SUGGEST_COLUMN_INTENT_EXTRA_DATA = "suggest_intent_extra_data";

  /// from: static public final java.lang.String SUGGEST_COLUMN_IS_LIVE
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content is media type, you
  /// should provide this column to specify whether your content is live media such as live video
  /// or live audio. The value in the column is of integer type with value of either 0 indicating
  /// non-live content or 1 indicating live content.
  static const SUGGEST_COLUMN_IS_LIVE = "suggest_is_live";

  /// from: static public final java.lang.String SUGGEST_COLUMN_LAST_ACCESS_HINT
  /// Column name for suggestions cursor. <i>Optional.</i> This column may be
  /// used to specify the time in System\#currentTimeMillis System.currentTImeMillis() (wall time in UTC) when an item was last
  /// accessed within the results-providing application. If set, this may be
  /// used to show more-recently-used items first.
  static const SUGGEST_COLUMN_LAST_ACCESS_HINT = "suggest_last_access_hint";

  /// from: static public final java.lang.String SUGGEST_COLUMN_PRODUCTION_YEAR
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content is video or audio and
  /// has a known production year, you should provide this column to specify the production year
  /// of your content. The data in the column is of integer type.
  static const SUGGEST_COLUMN_PRODUCTION_YEAR = "suggest_production_year";

  /// from: static public final java.lang.String SUGGEST_COLUMN_PURCHASE_PRICE
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content is purchasable, you
  /// should provide this column to specify the displayable string representation of the purchase
  /// price of your content including the currency and the amount. If it's free, you should
  /// provide localized string to specify that it's free. This column can be omitted if the content
  /// is not applicable to purchase.
  static const SUGGEST_COLUMN_PURCHASE_PRICE = "suggest_purchase_price";

  /// from: static public final java.lang.String SUGGEST_COLUMN_QUERY
  /// Column name for suggestions cursor.  <i>Required if action is
  /// android.content.Intent\#ACTION_SEARCH ACTION_SEARCH, optional otherwise.</i>  If this
  /// column exists <i>and</i> this element exists at the given row, this is the data that will be
  /// used when forming the suggestion's query.
  static const SUGGEST_COLUMN_QUERY = "suggest_intent_query";

  /// from: static public final java.lang.String SUGGEST_COLUMN_RATING_SCORE
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content has a rating, you
  /// should provide this column to specify the rating score of your content. The data in the
  /// column is of float type. See android.media.Rating about valid rating scores for each
  /// rating style.
  static const SUGGEST_COLUMN_RATING_SCORE = "suggest_rating_score";

  /// from: static public final java.lang.String SUGGEST_COLUMN_RATING_STYLE
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content has a rating, you
  /// should provide this column to specify the rating style of your content. The data in the
  /// column must be one of the constant values specified in android.media.Rating
  static const SUGGEST_COLUMN_RATING_STYLE = "suggest_rating_style";

  /// from: static public final java.lang.String SUGGEST_COLUMN_RENTAL_PRICE
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content is rentable, you
  /// should provide this column to specify the displayable string representation of the rental
  /// price of your content including the currency and the amount. If it's free, you should
  /// provide localized string to specify that it's free. This column can be ommitted if the
  /// content is not applicable to rent.
  static const SUGGEST_COLUMN_RENTAL_PRICE = "suggest_rental_price";

  /// from: static public final java.lang.String SUGGEST_COLUMN_RESULT_CARD_IMAGE
  /// Column name for suggestions cursor.  <i>Optional.</i>  If your cursor includes this column,
  /// then the image will be displayed when forming the suggestion. The suggested dimension for
  /// the image is 270x400 px for portrait mode and 400x225 px for landscape mode. The data in the
  /// column must be a resource ID of a drawable, or a URI in one of the following formats:
  ///
  /// <ul>
  /// <li>content (android.content.ContentResolver\#SCHEME_CONTENT)</li>
  /// <li>android.resource (android.content.ContentResolver\#SCHEME_ANDROID_RESOURCE)</li>
  /// <li>file (android.content.ContentResolver\#SCHEME_FILE)</li>
  /// </ul>
  ///
  /// See android.content.ContentResolver\#openAssetFileDescriptor(Uri, String)
  /// for more information on these schemes.
  static const SUGGEST_COLUMN_RESULT_CARD_IMAGE = "suggest_result_card_image";

  /// from: static public final java.lang.String SUGGEST_COLUMN_SHORTCUT_ID
  /// Column name for suggestions cursor. <i>Optional.</i>  This column is used to indicate whether
  /// a search suggestion should be stored as a shortcut, and whether it should be refreshed.  If
  /// missing, the result will be stored as a shortcut and never validated.  If set to
  /// \#SUGGEST_NEVER_MAKE_SHORTCUT, the result will not be stored as a shortcut.
  /// Otherwise, the shortcut id will be used to check back for an up to date suggestion using
  /// \#SUGGEST_URI_PATH_SHORTCUT.
  static const SUGGEST_COLUMN_SHORTCUT_ID = "suggest_shortcut_id";

  /// from: static public final java.lang.String SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING
  /// Column name for suggestions cursor. <i>Optional.</i> This column is used to specify
  /// that a spinner should be shown in lieu of an icon2 while the shortcut of this suggestion
  /// is being refreshed.
  static const SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING =
      "suggest_spinner_while_refreshing";

  /// from: static public final java.lang.String SUGGEST_COLUMN_TEXT_1
  /// Column name for suggestions cursor.  <i>Required.</i>  This is the primary line of text that
  /// will be presented to the user as the suggestion.
  static const SUGGEST_COLUMN_TEXT_1 = "suggest_text_1";

  /// from: static public final java.lang.String SUGGEST_COLUMN_TEXT_2
  /// Column name for suggestions cursor.  <i>Optional.</i>  If your cursor includes this column,
  ///  then all suggestions will be provided in a two-line format.  The second line of text is in
  ///  a much smaller appearance.
  static const SUGGEST_COLUMN_TEXT_2 = "suggest_text_2";

  /// from: static public final java.lang.String SUGGEST_COLUMN_TEXT_2_URL
  /// Column name for suggestions cursor.  <i>Optional.</i> This is a URL that will be shown
  /// as the second line of text instead of \#SUGGEST_COLUMN_TEXT_2. This is a separate
  /// column so that the search UI knows to display the text as a URL, e.g. by using a different
  /// color. If this column is absent, or has the value {@code null},
  /// \#SUGGEST_COLUMN_TEXT_2 will be used instead.
  static const SUGGEST_COLUMN_TEXT_2_URL = "suggest_text_2_url";

  /// from: static public final java.lang.String SUGGEST_COLUMN_VIDEO_HEIGHT
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content is video, you should
  /// provide this column to specify the number of horizontal lines. The data in the column is of
  /// integer type.
  static const SUGGEST_COLUMN_VIDEO_HEIGHT = "suggest_video_height";

  /// from: static public final java.lang.String SUGGEST_COLUMN_VIDEO_WIDTH
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content is video, you should
  /// provide this column to specify the number of vertical lines. The data in the column is of
  /// integer type.
  static const SUGGEST_COLUMN_VIDEO_WIDTH = "suggest_video_width";

  /// from: static public final java.lang.String SUGGEST_MIME_TYPE
  /// MIME type for suggestions data.  You'll use this in your suggestions content provider
  /// in the getType() function.
  static const SUGGEST_MIME_TYPE =
      "vnd.android.cursor.dir/vnd.android.search.suggest";

  /// from: static public final java.lang.String SUGGEST_NEVER_MAKE_SHORTCUT
  /// Column value for suggestion column \#SUGGEST_COLUMN_SHORTCUT_ID when a suggestion
  /// should not be stored as a shortcut in global search.
  static const SUGGEST_NEVER_MAKE_SHORTCUT = "_-1";

  /// from: static public final java.lang.String SUGGEST_PARAMETER_LIMIT
  /// Query parameter added to suggestion queries to limit the number of suggestions returned.
  /// This limit is only advisory and suggestion providers may chose to ignore it.
  static const SUGGEST_PARAMETER_LIMIT = "limit";

  /// from: static public final java.lang.String SUGGEST_URI_PATH_QUERY
  /// Uri path for queried suggestions data.  This is the path that the search manager
  /// will use when querying your content provider for suggestions data based on user input
  /// (e.g. looking for partial matches).
  /// Typically you'll use this with a URI matcher.
  static const SUGGEST_URI_PATH_QUERY = "search_suggest_query";

  /// from: static public final java.lang.String SUGGEST_URI_PATH_SHORTCUT
  /// Uri path for shortcut validation.  This is the path that the search manager will use when
  /// querying your content provider to refresh a shortcutted suggestion result and to check if it
  /// is still valid.  When asked, a source may return an up to date result, or no result.  No
  /// result indicates the shortcut refers to a no longer valid sugggestion.
  ///@see \#SUGGEST_COLUMN_SHORTCUT_ID
  static const SUGGEST_URI_PATH_SHORTCUT = "search_suggest_shortcut";

  /// from: static public final java.lang.String USER_QUERY
  /// Intent extra data key: Use this key with
  /// android.content.Intent\#getStringExtra content.Intent.getStringExtra()
  /// to obtain the query string typed in by the user.
  /// This may be different from the value of \#QUERY
  /// if the intent is the result of selecting a suggestion.
  /// In that case, \#QUERY will contain the value of
  /// \#SUGGEST_COLUMN_QUERY for the suggestion, and
  /// \#USER_QUERY will contain the string typed by the
  /// user.
  static const USER_QUERY = "user_query";

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_SearchManager_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  SearchManager() : super.fromRef(_ctor());

  static final _startSearch = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_SearchManager_startSearch")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void startSearch(java.lang.String initialQuery, boolean selectInitialQuery, android.content.ComponentName launchActivity, android.os.Bundle appSearchData, boolean globalSearch)
  /// Launch search UI.
  ///
  /// The search manager will open a search widget in an overlapping
  /// window, and the underlying activity may be obscured.  The search
  /// entry state will remain in effect until one of the following events:
  /// <ul>
  /// <li>The user completes the search.  In most cases this will launch
  /// a search intent.</li>
  /// <li>The user uses the back, home, or other keys to exit the search.</li>
  /// <li>The application calls the \#stopSearch
  /// method, which will hide the search window and return focus to the
  /// activity from which it was launched.</li>
  ///
  /// Most applications will <i>not</i> use this interface to invoke search.
  /// The primary method for invoking search is to call
  /// android.app.Activity\#onSearchRequested Activity.onSearchRequested() or
  /// android.app.Activity\#startSearch Activity.startSearch().
  ///@param initialQuery A search string can be pre-entered here, but this
  /// is typically null or empty.
  ///@param selectInitialQuery If true, the intial query will be preselected, which means that
  /// any further typing will replace it.  This is useful for cases where an entire pre-formed
  /// query is being inserted.  If false, the selection point will be placed at the end of the
  /// inserted query.  This is useful when the inserted query is text that the user entered,
  /// and the user would expect to be able to keep typing.  <i>This parameter is only meaningful
  /// if initialQuery is a non-empty string.</i>
  ///@param launchActivity The ComponentName of the activity that has launched this search.
  ///@param appSearchData An application can insert application-specific
  /// context here, in order to improve quality or specificity of its own
  /// searches.  This data will be returned with SEARCH intent(s).  Null if
  /// no extra data is required.
  ///@param globalSearch If false, this will only launch the search that has been specifically
  /// defined by the application (which is usually defined as a local search).  If no default
  /// search is defined in the current application or activity, global search will be launched.
  /// If true, this will always launch a platform-global (e.g. web-based) search instead.
  ///@see android.app.Activity\#onSearchRequested
  ///@see \#stopSearch
  void startSearch(
          jni.JlString initialQuery,
          bool selectInitialQuery,
          content.ComponentName launchActivity,
          os.Bundle appSearchData,
          bool globalSearch) =>
      _startSearch(
          reference,
          initialQuery.reference,
          selectInitialQuery ? 1 : 0,
          launchActivity.reference,
          appSearchData.reference,
          globalSearch ? 1 : 0);

  static final _getGlobalSearchActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_SearchManager_getGlobalSearchActivity")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getGlobalSearchActivity()
  /// Gets the name of the global search activity.
  content.ComponentName getGlobalSearchActivity() =>
      content.ComponentName.fromRef(_getGlobalSearchActivity(reference));

  static final _triggerSearch = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_SearchManager_triggerSearch")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void triggerSearch(java.lang.String query, android.content.ComponentName launchActivity, android.os.Bundle appSearchData)
  /// Similar to \#startSearch but actually fires off the search query after invoking
  /// the search dialog.  Made available for testing purposes.
  ///@param query The query to trigger.  If empty, request will be ignored.
  ///@param launchActivity The ComponentName of the activity that has launched this search.
  ///@param appSearchData An application can insert application-specific
  /// context here, in order to improve quality or specificity of its own
  /// searches.  This data will be returned with SEARCH intent(s).  Null if
  /// no extra data is required.
  ///@see \#startSearch
  void triggerSearch(jni.JlString query, content.ComponentName launchActivity,
          os.Bundle appSearchData) =>
      _triggerSearch(reference, query.reference, launchActivity.reference,
          appSearchData.reference);

  static final _stopSearch =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchManager_stopSearch")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void stopSearch()
  /// Terminate search UI.
  ///
  /// Typically the user will terminate the search UI by launching a
  /// search or by canceling.  This function allows the underlying application
  /// or activity to cancel the search prematurely (for any reason).
  ///
  /// This function can be safely called at any time (even if no search is active.)
  ///
  /// Configuration\#UI_MODE_TYPE_TELEVISION does not support this method.
  ///@see \#startSearch
  void stopSearch() => _stopSearch(reference);

  static final _setOnDismissListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_SearchManager_setOnDismissListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnDismissListener(android.app.SearchManager.OnDismissListener listener)
  /// Set or clear the callback that will be invoked whenever the search UI is dismissed.
  ///
  /// Configuration\#UI_MODE_TYPE_TELEVISION does not support this method.
  ///@param listener The OnDismissListener to use, or null.
  void setOnDismissListener(SearchManager_OnDismissListener listener) =>
      _setOnDismissListener(reference, listener.reference);

  static final _setOnCancelListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_SearchManager_setOnCancelListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnCancelListener(android.app.SearchManager.OnCancelListener listener)
  /// Set or clear the callback that will be invoked whenever the search UI is canceled.
  ///
  /// Configuration\#UI_MODE_TYPE_TELEVISION does not support this method.
  ///@param listener The OnCancelListener to use, or null.
  void setOnCancelListener(SearchManager_OnCancelListener listener) =>
      _setOnCancelListener(reference, listener.reference);

  static final _onCancel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_SearchManager_onCancel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCancel(android.content.DialogInterface dialog)
  /// @deprecated This method is an obsolete internal implementation detail. Do not use.
  void onCancel(content.DialogInterface dialog) =>
      _onCancel(reference, dialog.reference);

  static final _onDismiss = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_SearchManager_onDismiss")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onDismiss(android.content.DialogInterface dialog)
  /// @deprecated This method is an obsolete internal implementation detail. Do not use.
  void onDismiss(content.DialogInterface dialog) =>
      _onDismiss(reference, dialog.reference);

  static final _getSearchableInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_SearchManager_getSearchableInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.SearchableInfo getSearchableInfo(android.content.ComponentName componentName)
  /// Gets information about a searchable activity.
  ///@param componentName The activity to get searchable information for.
  ///@return Searchable information, or <code>null</code> if the activity does not
  ///         exist, or is not searchable.
  SearchableInfo getSearchableInfo(content.ComponentName componentName) =>
      SearchableInfo.fromRef(
          _getSearchableInfo(reference, componentName.reference));

  static final _getSearchablesInGlobalSearch = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_SearchManager_getSearchablesInGlobalSearch")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.SearchableInfo> getSearchablesInGlobalSearch()
  /// Returns a list of the searchable activities that can be included in global search.
  ///@return a list containing searchable information for all searchable activities
  ///         that have the <code>android:includeInGlobalSearch</code> attribute set
  ///         in their searchable meta-data.
  jni.JlObject getSearchablesInGlobalSearch() =>
      jni.JlObject.fromRef(_getSearchablesInGlobalSearch(reference));
}

/// See SearchManager\#setOnDismissListener for configuring your activity to monitor
/// search UI state.
class SearchManager_OnDismissListener extends jni.JlObject {
  SearchManager_OnDismissListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onDismiss =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchManager__OnDismissListener_onDismiss")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onDismiss()
  /// This method will be called when the search UI is dismissed. To make use of it, you must
  /// implement this method in your activity, and call
  /// SearchManager\#setOnDismissListener to register it.
  void onDismiss() => _onDismiss(reference);
}

/// See SearchManager\#setOnCancelListener for configuring your activity to monitor
/// search UI state.
class SearchManager_OnCancelListener extends jni.JlObject {
  SearchManager_OnCancelListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onCancel =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchManager__OnCancelListener_onCancel")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onCancel()
  /// This method will be called when the search UI is canceled. To make use if it, you must
  /// implement this method in your activity, and call
  /// SearchManager\#setOnCancelListener to register it.
  void onCancel() => _onCancel(reference);
}

/// Rule instance information for zen mode.
class AutomaticZenRule extends jni.JlObject {
  AutomaticZenRule.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.AutomaticZenRule> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_AutomaticZenRule_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Uint8)>>("android_app_AutomaticZenRule_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void <init>(java.lang.String name, android.content.ComponentName owner, android.net.Uri conditionId, int interruptionFilter, boolean enabled)
  /// Creates an automatic zen rule.
  ///@param name The name of the rule.
  ///@param owner The Condition Provider service that owns this rule.
  ///@param conditionId A representation of the state that should cause the Condition Provider
  ///                    service to apply the given interruption filter.
  ///@param interruptionFilter The interruption filter defines which notifications are allowed to
  ///                           interrupt the user (e.g. via sound &amp; vibration) while this rule
  ///                           is active.
  ///@param enabled Whether the rule is enabled.
  AutomaticZenRule(jni.JlString name, content.ComponentName owner,
      jni.JlObject conditionId, int interruptionFilter, bool enabled)
      : super.fromRef(_ctor(name.reference, owner.reference,
            conditionId.reference, interruptionFilter, enabled ? 1 : 0));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_AutomaticZenRule_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel source)
  AutomaticZenRule.ctor_1(os.Parcel source)
      : super.fromRef(_ctor_1(source.reference));

  static final _getOwner = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_AutomaticZenRule_getOwner")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getOwner()
  /// Returns the ComponentName of the condition provider service that owns this rule.
  content.ComponentName getOwner() =>
      content.ComponentName.fromRef(_getOwner(reference));

  static final _getConditionId = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_AutomaticZenRule_getConditionId")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri getConditionId()
  /// Returns the representation of the state that causes this rule to become active.
  jni.JlObject getConditionId() =>
      jni.JlObject.fromRef(_getConditionId(reference));

  static final _getInterruptionFilter =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_AutomaticZenRule_getInterruptionFilter")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getInterruptionFilter()
  /// Returns the interruption filter that is applied when this rule is active.
  int getInterruptionFilter() => _getInterruptionFilter(reference);

  static final _getName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_AutomaticZenRule_getName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getName()
  /// Returns the name of this rule.
  jni.JlString getName() => jni.JlString.fromRef(_getName(reference));

  static final _isEnabled =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_AutomaticZenRule_isEnabled")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isEnabled()
  /// Returns whether this rule is enabled.
  bool isEnabled() => _isEnabled(reference) != 0;

  static final _getCreationTime =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_AutomaticZenRule_getCreationTime")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getCreationTime()
  /// Returns the time this rule was created, represented as milliseconds since the epoch.
  int getCreationTime() => _getCreationTime(reference);

  static final _setConditionId = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AutomaticZenRule_setConditionId")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setConditionId(android.net.Uri conditionId)
  /// Sets the representation of the state that causes this rule to become active.
  void setConditionId(jni.JlObject conditionId) =>
      _setConditionId(reference, conditionId.reference);

  static final _setInterruptionFilter = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_AutomaticZenRule_setInterruptionFilter")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setInterruptionFilter(int interruptionFilter)
  /// Sets the interruption filter that is applied when this rule is active.
  ///@param interruptionFilter The do not disturb mode to enter when this rule is active.
  ///
  /// Value is android.app.NotificationManager\#INTERRUPTION_FILTER_NONE, android.app.NotificationManager\#INTERRUPTION_FILTER_PRIORITY, android.app.NotificationManager\#INTERRUPTION_FILTER_ALARMS, android.app.NotificationManager\#INTERRUPTION_FILTER_ALL, or android.app.NotificationManager\#INTERRUPTION_FILTER_UNKNOWN
  void setInterruptionFilter(int interruptionFilter) =>
      _setInterruptionFilter(reference, interruptionFilter);

  static final _setName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AutomaticZenRule_setName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setName(java.lang.String name)
  /// Sets the name of this rule.
  void setName(jni.JlString name) => _setName(reference, name.reference);

  static final _setEnabled = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_AutomaticZenRule_setEnabled")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setEnabled(boolean enabled)
  /// Enables this rule.
  void setEnabled(bool enabled) => _setEnabled(reference, enabled ? 1 : 0);

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_AutomaticZenRule_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_AutomaticZenRule_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_AutomaticZenRule_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _equals_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AutomaticZenRule_equals_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object o)
  bool equals_1(jni.JlObject o) => _equals_1(reference, o.reference) != 0;

  static final _hashCode_1 =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_AutomaticZenRule_hashCode_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode_1() => _hashCode_1(reference);
}

/// A Service is an application component representing either an application's desire
/// to perform a longer-running operation while not interacting with the user
/// or to supply functionality for other applications to use.  Each service
/// class must have a corresponding
/// android.R.styleable\#AndroidManifestService &lt;service&gt;
/// declaration in its package's <code>AndroidManifest.xml</code>.  Services
/// can be started with
/// android.content.Context\#startService Context.startService() and
/// android.content.Context\#bindService Context.bindService().
///
/// Note that services, like other application objects, run in the main
/// thread of their hosting process.  This means that, if your service is going
/// to do any CPU intensive (such as MP3 playback) or blocking (such as
/// networking) operations, it should spawn its own thread in which to do that
/// work.  More information on this can be found in
/// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html">Processes and
/// Threads</a>.  The IntentService class is available
/// as a standard implementation of Service that has its own thread where it
/// schedules its work to be done.
///
///
/// Topics covered here:
/// <ol>
/// <li><a href="\#WhatIsAService">What is a Service?</a>
/// <li><a href="\#ServiceLifecycle">Service Lifecycle</a>
/// <li><a href="\#Permissions">Permissions</a>
/// <li><a href="\#ProcessLifecycle">Process Lifecycle</a>
/// <li><a href="\#LocalServiceSample">Local Service Sample</a>
/// <li><a href="\#RemoteMessengerServiceSample">Remote Messenger Service Sample</a>
/// </ol>
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For a detailed discussion about how to create services, read the
/// <a href="{@docRoot}guide/topics/fundamentals/services.html">Services</a> developer guide.
///
/// </div>
///
/// <a name="WhatIsAService"></a>
/// <h3>What is a Service?</h3>
///
/// Most confusion about the Service class actually revolves around what
/// it is _not_:
///
///
/// <ul>
/// <li> A Service is __not__ a separate process.  The Service object itself
/// does not imply it is running in its own process; unless otherwise specified,
/// it runs in the same process as the application it is part of.
/// <li> A Service is __not__ a thread.  It is not a means itself to do work off
/// of the main thread (to avoid Application Not Responding errors).
/// </ul>
///
/// Thus a Service itself is actually very simple, providing two main features:
///
///
/// <ul>
/// <li>A facility for the application to tell the system _about_
/// something it wants to be doing in the background (even when the user is not
/// directly interacting with the application).  This corresponds to calls to
/// android.content.Context\#startService Context.startService(), which
/// ask the system to schedule work for the service, to be run until the service
/// or someone else explicitly stop it.
/// <li>A facility for an application to expose some of its functionality to
/// other applications.  This corresponds to calls to
/// android.content.Context\#bindService Context.bindService(), which
/// allows a long-standing connection to be made to the service in order to
/// interact with it.
/// </ul>
///
/// When a Service component is actually created, for either of these reasons,
/// all that the system actually does is instantiate the component
/// and call its \#onCreate and any other appropriate callbacks on the
/// main thread.  It is up to the Service to implement these with the appropriate
/// behavior, such as creating a secondary thread in which it does its work.
///
///
/// Note that because Service itself is so simple, you can make your
/// interaction with it as simple or complicated as you want: from treating it
/// as a local Java object that you make direct method calls on (as illustrated
/// by <a href="\#LocalServiceSample">Local Service Sample</a>), to providing
/// a full remoteable interface using AIDL.
///
///
/// <a name="ServiceLifecycle"></a>
/// <h3>Service Lifecycle</h3>
///
/// There are two reasons that a service can be run by the system.  If someone
/// calls android.content.Context\#startService Context.startService() then the system will
/// retrieve the service (creating it and calling its \#onCreate method
/// if needed) and then call its \#onStartCommand method with the
/// arguments supplied by the client.  The service will at this point continue
/// running until android.content.Context\#stopService Context.stopService() or
/// \#stopSelf() is called.  Note that multiple calls to
/// Context.startService() do not nest (though they do result in multiple corresponding
/// calls to onStartCommand()), so no matter how many times it is started a service
/// will be stopped once Context.stopService() or stopSelf() is called; however,
/// services can use their \#stopSelf(int) method to ensure the service is
/// not stopped until started intents have been processed.
///
/// For started services, there are two additional major modes of operation
/// they can decide to run in, depending on the value they return from
/// onStartCommand(): \#START_STICKY is used for services that are
/// explicitly started and stopped as needed, while \#START_NOT_STICKY
/// or \#START_REDELIVER_INTENT are used for services that should only
/// remain running while processing any commands sent to them.  See the linked
/// documentation for more detail on the semantics.
///
/// Clients can also use android.content.Context\#bindService Context.bindService() to
/// obtain a persistent connection to a service.  This likewise creates the
/// service if it is not already running (calling \#onCreate while
/// doing so), but does not call onStartCommand().  The client will receive the
/// android.os.IBinder object that the service returns from its
/// \#onBind method, allowing the client to then make calls back
/// to the service.  The service will remain running as long as the connection
/// is established (whether or not the client retains a reference on the
/// service's IBinder).  Usually the IBinder returned is for a complex
/// interface that has been <a href="{@docRoot}guide/components/aidl.html">written
/// in aidl</a>.
///
/// A service can be both started and have connections bound to it.  In such
/// a case, the system will keep the service running as long as either it is
/// started _or_ there are one or more connections to it with the
/// android.content.Context\#BIND_AUTO_CREATE Context.BIND_AUTO_CREATE
/// flag.  Once neither
/// of these situations hold, the service's \#onDestroy method is called
/// and the service is effectively terminated.  All cleanup (stopping threads,
/// unregistering receivers) should be complete upon returning from onDestroy().
///
/// <a name="Permissions"></a>
/// <h3>Permissions</h3>
///
/// Global access to a service can be enforced when it is declared in its
/// manifest's android.R.styleable\#AndroidManifestService &lt;service&gt;
/// tag.  By doing so, other applications will need to declare a corresponding
/// android.R.styleable\#AndroidManifestUsesPermission &lt;uses-permission&gt;
/// element in their own manifest to be able to start, stop, or bind to
/// the service.
///
/// As of android.os.Build.VERSION_CODES\#GINGERBREAD, when using
/// Context\#startService(Intent) Context.startService(Intent), you can
/// also set Intent\#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION and/or Intent\#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION on the Intent.  This will grant the
/// Service temporary access to the specific URIs in the Intent.  Access will
/// remain until the Service has called \#stopSelf(int) for that start
/// command or a later one, or until the Service has been completely stopped.
/// This works for granting access to the other apps that have not requested
/// the permission protecting the Service, or even when the Service is not
/// exported at all.
///
/// In addition, a service can protect individual IPC calls into it with
/// permissions, by calling the
/// \#checkCallingPermission
/// method before executing the implementation of that call.
///
/// See the <a href="{@docRoot}guide/topics/security/security.html">Security and Permissions</a>
/// document for more information on permissions and security in general.
///
/// <a name="ProcessLifecycle"></a>
/// <h3>Process Lifecycle</h3>
///
/// The Android system will attempt to keep the process hosting a service
/// around as long as the service has been started or has clients bound to it.
/// When running low on memory and needing to kill existing processes, the
/// priority of a process hosting the service will be the higher of the
/// following possibilities:
///
/// <ul>
/// <li>If the service is currently executing code in its
/// \#onCreate onCreate(), \#onStartCommand onStartCommand(),
/// or \#onDestroy onDestroy() methods, then the hosting process will
/// be a foreground process to ensure this code can execute without
/// being killed.
/// <li>If the service has been started, then its hosting process is considered
/// to be less important than any processes that are currently visible to the
/// user on-screen, but more important than any process not visible.  Because
/// only a few processes are generally visible to the user, this means that
/// the service should not be killed except in low memory conditions.  However, since
/// the user is not directly aware of a background service, in that state it _is_
/// considered a valid candidate to kill, and you should be prepared for this to
/// happen.  In particular, long-running services will be increasingly likely to
/// kill and are guaranteed to be killed (and restarted if appropriate) if they
/// remain started long enough.
/// <li>If there are clients bound to the service, then the service's hosting
/// process is never less important than the most important client.  That is,
/// if one of its clients is visible to the user, then the service itself is
/// considered to be visible.  The way a client's importance impacts the service's
/// importance can be adjusted through Context\#BIND_ABOVE_CLIENT,
/// Context\#BIND_ALLOW_OOM_MANAGEMENT, Context\#BIND_WAIVE_PRIORITY,
/// Context\#BIND_IMPORTANT, and Context\#BIND_ADJUST_WITH_ACTIVITY.
/// <li>A started service can use the \#startForeground(int, Notification)
/// API to put the service in a foreground state, where the system considers
/// it to be something the user is actively aware of and thus not a candidate
/// for killing when low on memory.  (It is still theoretically possible for
/// the service to be killed under extreme memory pressure from the current
/// foreground application, but in practice this should not be a concern.)
/// </ul>
///
/// Note this means that most of the time your service is running, it may
/// be killed by the system if it is under heavy memory pressure.  If this
/// happens, the system will later try to restart the service.  An important
/// consequence of this is that if you implement \#onStartCommand onStartCommand()
/// to schedule work to be done asynchronously or in another thread, then you
/// may want to use \#START_FLAG_REDELIVERY to have the system
/// re-deliver an Intent for you so that it does not get lost if your service
/// is killed while processing it.
///
/// Other application components running in the same process as the service
/// (such as an android.app.Activity) can, of course, increase the
/// importance of the overall
/// process beyond just the importance of the service itself.
///
/// <a name="LocalServiceSample"></a>
/// <h3>Local Service Sample</h3>
///
/// One of the most common uses of a Service is as a secondary component
/// running alongside other parts of an application, in the same process as
/// the rest of the components.  All components of an .apk run in the same
/// process unless explicitly stated otherwise, so this is a typical situation.
///
/// When used in this way, by assuming the
/// components are in the same process, you can greatly simplify the interaction
/// between them: clients of the service can simply cast the IBinder they
/// receive from it to a concrete class published by the service.
///
/// An example of this use of a Service is shown here.  First is the Service
/// itself, publishing a custom class when bound:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/LocalService.java
///      service}
///
/// With that done, one can now write client code that directly accesses the
/// running service, such as:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/LocalServiceActivities.java
///      bind}
///
/// <a name="RemoteMessengerServiceSample"></a>
/// <h3>Remote Messenger Service Sample</h3>
///
/// If you need to be able to write a Service that can perform complicated
/// communication with clients in remote processes (beyond simply the use of
/// Context\#startService(Intent) Context.startService to send
/// commands to it), then you can use the android.os.Messenger class
/// instead of writing full AIDL files.
///
/// An example of a Service that uses Messenger as its client interface
/// is shown here.  First is the Service itself, publishing a Messenger to
/// an internal Handler when bound:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/MessengerService.java
///      service}
///
/// If we want to make this service run in a remote process (instead of the
/// standard one for its .apk), we can use <code>android:process</code> in its
/// manifest tag to specify one:
///
/// {@sample development/samples/ApiDemos/AndroidManifest.xml remote_service_declaration}
///
/// Note that the name "remote" chosen here is arbitrary, and you can use
/// other names if you want additional processes.  The ':' prefix appends the
/// name to your package's standard process name.
///
/// With that done, clients can now bind to the service and send messages
/// to it.  Note that this allows clients to register with it to receive
/// messages back as well:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/MessengerServiceActivities.java
///      bind}
class Service extends content.ContextWrapper {
  Service.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int START_CONTINUATION_MASK
  /// Bits returned by \#onStartCommand describing how to continue
  /// the service if it is killed.  May be \#START_STICKY,
  /// \#START_NOT_STICKY, \#START_REDELIVER_INTENT,
  /// or \#START_STICKY_COMPATIBILITY.
  static const START_CONTINUATION_MASK = 15;

  /// from: static public final int START_FLAG_REDELIVERY
  /// This flag is set in \#onStartCommand if the Intent is a
  /// re-delivery of a previously delivered intent, because the service
  /// had previously returned \#START_REDELIVER_INTENT but had been
  /// killed before calling \#stopSelf(int) for that Intent.
  static const START_FLAG_REDELIVERY = 1;

  /// from: static public final int START_FLAG_RETRY
  /// This flag is set in \#onStartCommand if the Intent is a
  /// retry because the original attempt never got to or returned from
  /// \#onStartCommand(Intent, int, int).
  static const START_FLAG_RETRY = 2;

  /// from: static public final int START_NOT_STICKY
  /// Constant to return from \#onStartCommand: if this service's
  /// process is killed while it is started (after returning from
  /// \#onStartCommand), and there are no new start intents to
  /// deliver to it, then take the service out of the started state and
  /// don't recreate until a future explicit call to
  /// Context\#startService Context.startService(Intent).  The
  /// service will not receive a \#onStartCommand(Intent, int, int)
  /// call with a null Intent because it will not be re-started if there
  /// are no pending Intents to deliver.
  ///
  /// This mode makes sense for things that want to do some work as a
  /// result of being started, but can be stopped when under memory pressure
  /// and will explicit start themselves again later to do more work.  An
  /// example of such a service would be one that polls for data from
  /// a server: it could schedule an alarm to poll every N minutes by having
  /// the alarm start its service.  When its \#onStartCommand is
  /// called from the alarm, it schedules a new alarm for N minutes later,
  /// and spawns a thread to do its networking.  If its process is killed
  /// while doing that check, the service will not be restarted until the
  /// alarm goes off.
  static const START_NOT_STICKY = 2;

  /// from: static public final int START_REDELIVER_INTENT
  /// Constant to return from \#onStartCommand: if this service's
  /// process is killed while it is started (after returning from
  /// \#onStartCommand), then it will be scheduled for a restart
  /// and the last delivered Intent re-delivered to it again via
  /// \#onStartCommand.  This Intent will remain scheduled for
  /// redelivery until the service calls \#stopSelf(int) with the
  /// start ID provided to \#onStartCommand.  The
  /// service will not receive a \#onStartCommand(Intent, int, int)
  /// call with a null Intent because it will will only be re-started if
  /// it is not finished processing all Intents sent to it (and any such
  /// pending events will be delivered at the point of restart).
  static const START_REDELIVER_INTENT = 3;

  /// from: static public final int START_STICKY
  /// Constant to return from \#onStartCommand: if this service's
  /// process is killed while it is started (after returning from
  /// \#onStartCommand), then leave it in the started state but
  /// don't retain this delivered intent.  Later the system will try to
  /// re-create the service.  Because it is in the started state, it will
  /// guarantee to call \#onStartCommand after creating the new
  /// service instance; if there are not any pending start commands to be
  /// delivered to the service, it will be called with a null intent
  /// object, so you must take care to check for this.
  ///
  /// This mode makes sense for things that will be explicitly started
  /// and stopped to run for arbitrary periods of time, such as a service
  /// performing background music playback.
  static const START_STICKY = 1;

  /// from: static public final int START_STICKY_COMPATIBILITY
  /// Constant to return from \#onStartCommand: compatibility
  /// version of \#START_STICKY that does not guarantee that
  /// \#onStartCommand will be called again after being killed.
  static const START_STICKY_COMPATIBILITY = 0;

  /// from: static public final int STOP_FOREGROUND_DETACH
  /// Flag for \#stopForeground(int): if set, the notification previously provided
  /// to \#startForeground will be detached from the service.  Only makes sense
  /// when \#STOP_FOREGROUND_REMOVE is __not__ set -- in this case, the notification
  /// will remain shown, but be completely detached from the service and so no longer changed
  /// except through direct calls to the notification manager.
  static const STOP_FOREGROUND_DETACH = 2;

  /// from: static public final int STOP_FOREGROUND_REMOVE
  /// Flag for \#stopForeground(int): if set, the notification previously provided
  /// to \#startForeground will be removed.  Otherwise it will remain
  /// until a later call (to \#startForeground(int, Notification) or
  /// \#stopForeground(int) removes it, or the service is destroyed.
  static const STOP_FOREGROUND_REMOVE = 1;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Service_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Service() : super.fromRef(_ctor());

  static final _getApplication = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Service_getApplication")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Application getApplication()
  /// Return the application that owns this service.
  Application getApplication() =>
      Application.fromRef(_getApplication(reference));

  static final _onCreate =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Service_onCreate")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreate()
  /// Called by the system when the service is first created.  Do not call this method directly.
  void onCreate() => _onCreate(reference);

  static final _onStart = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Service_onStart")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onStart(android.content.Intent intent, int startId)
  /// @deprecated Implement \#onStartCommand(Intent, int, int) instead.
  void onStart(content.Intent intent, int startId) =>
      _onStart(reference, intent.reference, startId);

  static final _onStartCommand = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32, ffi.Int32)>>("android_app_Service_onStartCommand")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int onStartCommand(android.content.Intent intent, int flags, int startId)
  /// Called by the system every time a client explicitly starts the service by calling
  /// android.content.Context\#startService, providing the arguments it supplied and a
  /// unique integer token representing the start request.  Do not call this method directly.
  ///
  /// For backwards compatibility, the default implementation calls
  /// \#onStart and returns either \#START_STICKY
  /// or \#START_STICKY_COMPATIBILITY.
  ///
  /// <p class="caution">Note that the system calls this on your
  /// service's main thread.  A service's main thread is the same
  /// thread where UI operations take place for Activities running in the
  /// same process.  You should always avoid stalling the main
  /// thread's event loop.  When doing long-running operations,
  /// network calls, or heavy disk I/O, you should kick off a new
  /// thread, or use android.os.AsyncTask.
  ///
  ///@param intent The Intent supplied to android.content.Context\#startService,
  /// as given.  This may be null if the service is being restarted after
  /// its process has gone away, and it had previously returned anything
  /// except \#START_STICKY_COMPATIBILITY.
  ///@param flags Additional data about this start request.
  /// Value is either <code>0</code> or a combination of android.app.Service\#START_FLAG_REDELIVERY, and android.app.Service\#START_FLAG_RETRY
  ///@param startId A unique integer representing this specific request to
  /// start.  Use with \#stopSelfResult(int).
  ///@return The return value indicates what semantics the system should
  /// use for the service's current started state.  It may be one of the
  /// constants associated with the \#START_CONTINUATION_MASK bits.
  ///
  /// Value is android.app.Service\#START_STICKY_COMPATIBILITY, android.app.Service\#START_STICKY, android.app.Service\#START_NOT_STICKY, or android.app.Service\#START_REDELIVER_INTENT
  ///@see \#stopSelfResult(int)
  int onStartCommand(content.Intent intent, int flags, int startId) =>
      _onStartCommand(reference, intent.reference, flags, startId);

  static final _onDestroy =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Service_onDestroy")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDestroy()
  /// Called by the system to notify a Service that it is no longer used and is being removed.  The
  /// service should clean up any resources it holds (threads, registered
  /// receivers, etc) at this point.  Upon return, there will be no more calls
  /// in to this Service object and it is effectively dead.  Do not call this method directly.
  void onDestroy() => _onDestroy(reference);

  static final _onConfigurationChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Service_onConfigurationChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onConfigurationChanged(android.content.res.Configuration newConfig)
  void onConfigurationChanged(res.Configuration newConfig) =>
      _onConfigurationChanged(reference, newConfig.reference);

  static final _onLowMemory =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Service_onLowMemory")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onLowMemory()
  void onLowMemory() => _onLowMemory(reference);

  static final _onTrimMemory = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Service_onTrimMemory")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onTrimMemory(int level)
  void onTrimMemory(int level) => _onTrimMemory(reference, level);

  static final _onBind = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Service_onBind")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.os.IBinder onBind(android.content.Intent intent)
  /// Return the communication channel to the service.  May return null if
  /// clients can not bind to the service.  The returned
  /// android.os.IBinder is usually for a complex interface
  /// that has been <a href="{@docRoot}guide/components/aidl.html">described using
  /// aidl</a>.
  ///
  /// _Note that unlike other application components, calls on to the
  /// IBinder interface returned here may not happen on the main thread
  /// of the process_.  More information about the main thread can be found in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html">Processes and
  /// Threads</a>.
  ///
  ///@param intent The Intent that was used to bind to this service,
  /// as given to android.content.Context\#bindService Context.bindService.  Note that any extras that were included with
  /// the Intent at that point will _not_ be seen here.
  ///@return Return an IBinder through which clients can call on to the
  ///         service.
  os.IBinder onBind(content.Intent intent) =>
      os.IBinder.fromRef(_onBind(reference, intent.reference));

  static final _onUnbind = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Service_onUnbind")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onUnbind(android.content.Intent intent)
  /// Called when all clients have disconnected from a particular interface
  /// published by the service.  The default implementation does nothing and
  /// returns false.
  ///@param intent The Intent that was used to bind to this service,
  /// as given to android.content.Context\#bindService Context.bindService.  Note that any extras that were included with
  /// the Intent at that point will _not_ be seen here.
  ///@return Return true if you would like to have the service's
  /// \#onRebind method later called when new clients bind to it.
  bool onUnbind(content.Intent intent) =>
      _onUnbind(reference, intent.reference) != 0;

  static final _onRebind = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Service_onRebind")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onRebind(android.content.Intent intent)
  /// Called when new clients have connected to the service, after it had
  /// previously been notified that all had disconnected in its
  /// \#onUnbind.  This will only be called if the implementation
  /// of \#onUnbind was overridden to return true.
  ///@param intent The Intent that was used to bind to this service,
  /// as given to android.content.Context\#bindService Context.bindService.  Note that any extras that were included with
  /// the Intent at that point will _not_ be seen here.
  void onRebind(content.Intent intent) =>
      _onRebind(reference, intent.reference);

  static final _onTaskRemoved = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Service_onTaskRemoved")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onTaskRemoved(android.content.Intent rootIntent)
  /// This is called if the service is currently running and the user has
  /// removed a task that comes from the service's application.  If you have
  /// set android.content.pm.ServiceInfo\#FLAG_STOP_WITH_TASK ServiceInfo.FLAG_STOP_WITH_TASK
  /// then you will not receive this callback; instead, the service will simply
  /// be stopped.
  ///@param rootIntent The original root Intent that was used to launch
  /// the task that is being removed.
  void onTaskRemoved(content.Intent rootIntent) =>
      _onTaskRemoved(reference, rootIntent.reference);

  static final _stopSelf =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Service_stopSelf")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final void stopSelf()
  /// Stop the service, if it was previously started.  This is the same as
  /// calling android.content.Context\#stopService for this particular service.
  ///@see \#stopSelfResult(int)
  void stopSelf() => _stopSelf(reference);

  static final _stopSelf_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Service_stopSelf_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void stopSelf(int startId)
  /// Old version of \#stopSelfResult that doesn't return a result.
  ///@see \#stopSelfResult
  void stopSelf_1(int startId) => _stopSelf_1(reference, startId);

  static final _stopSelfResult = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Service_stopSelfResult")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final boolean stopSelfResult(int startId)
  /// Stop the service if the most recent time it was started was
  /// <var>startId</var>.  This is the same as calling android.content.Context\#stopService for this particular service but allows you to
  /// safely avoid stopping if there is a start request from a client that you
  /// haven't yet seen in \#onStart.
  ///
  /// _Be careful about ordering of your calls to this function._.
  /// If you call this function with the most-recently received ID before
  /// you have called it for previously received IDs, the service will be
  /// immediately stopped anyway.  If you may end up processing IDs out
  /// of order (such as by dispatching them on separate threads), then you
  /// are responsible for stopping them in the same order you received them.
  ///
  ///@param startId The most recent start identifier received in \#onStart.
  ///@return Returns true if the startId matches the last start request
  /// and the service will be stopped, else false.
  ///@see \#stopSelf()
  bool stopSelfResult(int startId) => _stopSelfResult(reference, startId) != 0;

  static final _startForeground = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Service_startForeground")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final void startForeground(int id, android.app.Notification notification)
  /// If your service is started (running through Context\#startService(Intent)), then
  /// also make this service run in the foreground, supplying the ongoing
  /// notification to be shown to the user while in this state.
  /// By default started services are background, meaning that their process won't be given
  /// foreground CPU scheduling (unless something else in that process is foreground) and,
  /// if the system needs to kill them to reclaim more memory (such as to display a large page in a
  /// web browser), they can be killed without too much harm.  You use
  /// \#startForeground if killing your service would be disruptive to the user, such as
  /// if your service is performing background music playback, so the user
  /// would notice if their music stopped playing.
  ///
  /// Note that calling this method does _not_ put the service in the started state
  /// itself, even though the name sounds like it.  You must always call
  /// \#startService(Intent) first to tell the system it should keep the service running,
  /// and then use this method to tell it to keep it running harder.
  ///
  ///
  /// Apps targeting API android.os.Build.VERSION_CODES\#P or later must request
  /// the permission android.Manifest.permission\#FOREGROUND_SERVICE in order to use
  /// this API.
  ///
  ///@param id The identifier for this notification as per
  /// NotificationManager\#notify(int, Notification) NotificationManager.notify(int, Notification); must not be 0.
  ///@param notification The Notification to be displayed.
  ///@see \#stopForeground(boolean)
  void startForeground(int id, Notification notification) =>
      _startForeground(reference, id, notification.reference);

  static final _stopForeground = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Service_stopForeground")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void stopForeground(boolean removeNotification)
  /// Synonym for \#stopForeground(int).
  ///@param removeNotification If true, the \#STOP_FOREGROUND_REMOVE flag
  /// will be supplied.
  ///@see \#stopForeground(int)
  ///@see \#startForeground(int, Notification)
  void stopForeground(bool removeNotification) =>
      _stopForeground(reference, removeNotification ? 1 : 0);

  static final _stopForeground_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Service_stopForeground_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void stopForeground(int flags)
  /// Remove this service from foreground state, allowing it to be killed if
  /// more memory is needed.  This does not stop the service from running (for that
  /// you use \#stopSelf() or related methods), just takes it out of the
  /// foreground state.
  ///@param flags additional behavior options.
  /// Value is either <code>0</code> or a combination of android.app.Service\#STOP_FOREGROUND_REMOVE, and android.app.Service\#STOP_FOREGROUND_DETACH
  ///@see \#startForeground(int, Notification)
  void stopForeground_1(int flags) => _stopForeground_1(reference, flags);

  static final _dump = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Service_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void dump(java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  /// Print the Service's state into the given stream.  This gets invoked if
  /// you run "adb shell dumpsys activity service &lt;yourservicename&gt;"
  /// (note that for this command to work, the service must be running, and
  /// you must specify a fully-qualified service name).
  /// This is distinct from "dumpsys &lt;servicename&gt;", which only works for
  /// named system services and which invokes the IBinder\#dump method
  /// on the IBinder interface registered with ServiceManager.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer The PrintWriter to which you should dump your state.  This will be
  /// closed for you after you return.
  ///@param args additional arguments to the dump request.
  void dump(jni.JlObject fd, jni.JlObject writer, jni.JlObject args) =>
      _dump(reference, fd.reference, writer.reference, args.reference);
}

/// API for interacting with "application operation" tracking.
///
/// This API is not generally intended for third party application developers; most
/// features are only available to system applications.
class AppOpsManager extends jni.JlObject {
  AppOpsManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int MODE_ALLOWED
  /// Result from \#checkOp, \#noteOp, \#startOp: the given caller is
  /// allowed to perform the given operation.
  static const MODE_ALLOWED = 0;

  /// from: static public final int MODE_DEFAULT
  /// Result from \#checkOp, \#noteOp, \#startOp: the given caller should
  /// use its default security check.  This mode is not normally used; it should only be used
  /// with appop permissions, and callers must explicitly check for it and deal with it.
  static const MODE_DEFAULT = 3;

  /// from: static public final int MODE_ERRORED
  /// Result from \#checkOpNoThrow, \#noteOpNoThrow, \#startOpNoThrow: the
  /// given caller is not allowed to perform the given operation, and this attempt should
  /// cause it to have a fatal error, typically a SecurityException.
  static const MODE_ERRORED = 2;

  /// from: static public final int MODE_IGNORED
  /// Result from \#checkOp, \#noteOp, \#startOp: the given caller is
  /// not allowed to perform the given operation, and this attempt should
  /// _silently fail_ (it should not cause the app to crash).
  static const MODE_IGNORED = 1;

  /// from: static public final java.lang.String OPSTR_ADD_VOICEMAIL
  /// Required to access phone state related information.
  static const OPSTR_ADD_VOICEMAIL = "android:add_voicemail";

  /// from: static public final java.lang.String OPSTR_ANSWER_PHONE_CALLS
  /// Answer incoming phone calls
  static const OPSTR_ANSWER_PHONE_CALLS = "android:answer_phone_calls";

  /// from: static public final java.lang.String OPSTR_BODY_SENSORS
  /// Access to body sensors such as heart rate, etc.
  static const OPSTR_BODY_SENSORS = "android:body_sensors";

  /// from: static public final java.lang.String OPSTR_CALL_PHONE
  /// Allows an application to initiate a phone call.
  static const OPSTR_CALL_PHONE = "android:call_phone";

  /// from: static public final java.lang.String OPSTR_CAMERA
  /// Required to be able to access the camera device.
  static const OPSTR_CAMERA = "android:camera";

  /// from: static public final java.lang.String OPSTR_COARSE_LOCATION
  /// Access to coarse location information.
  static const OPSTR_COARSE_LOCATION = "android:coarse_location";

  /// from: static public final java.lang.String OPSTR_FINE_LOCATION
  /// Access to fine location information.
  static const OPSTR_FINE_LOCATION = "android:fine_location";

  /// from: static public final java.lang.String OPSTR_GET_USAGE_STATS
  /// Access to android.app.usage.UsageStatsManager.
  static const OPSTR_GET_USAGE_STATS = "android:get_usage_stats";

  /// from: static public final java.lang.String OPSTR_MOCK_LOCATION
  /// Inject mock location into the system.
  static const OPSTR_MOCK_LOCATION = "android:mock_location";

  /// from: static public final java.lang.String OPSTR_MONITOR_HIGH_POWER_LOCATION
  /// Continually monitoring location data with a relatively high power request.
  static const OPSTR_MONITOR_HIGH_POWER_LOCATION =
      "android:monitor_location_high_power";

  /// from: static public final java.lang.String OPSTR_MONITOR_LOCATION
  /// Continually monitoring location data.
  static const OPSTR_MONITOR_LOCATION = "android:monitor_location";

  /// from: static public final java.lang.String OPSTR_PICTURE_IN_PICTURE
  /// Access to picture-in-picture.
  static const OPSTR_PICTURE_IN_PICTURE = "android:picture_in_picture";

  /// from: static public final java.lang.String OPSTR_PROCESS_OUTGOING_CALLS
  /// Access APIs for diverting outgoing calls
  static const OPSTR_PROCESS_OUTGOING_CALLS = "android:process_outgoing_calls";

  /// from: static public final java.lang.String OPSTR_READ_CALENDAR
  /// Allows an application to read the user's calendar data.
  static const OPSTR_READ_CALENDAR = "android:read_calendar";

  /// from: static public final java.lang.String OPSTR_READ_CALL_LOG
  /// Allows an application to read the user's call log.
  static const OPSTR_READ_CALL_LOG = "android:read_call_log";

  /// from: static public final java.lang.String OPSTR_READ_CELL_BROADCASTS
  /// Read previously received cell broadcast messages.
  static const OPSTR_READ_CELL_BROADCASTS = "android:read_cell_broadcasts";

  /// from: static public final java.lang.String OPSTR_READ_CONTACTS
  /// Allows an application to read the user's contacts data.
  static const OPSTR_READ_CONTACTS = "android:read_contacts";

  /// from: static public final java.lang.String OPSTR_READ_EXTERNAL_STORAGE
  /// Read external storage.
  static const OPSTR_READ_EXTERNAL_STORAGE = "android:read_external_storage";

  /// from: static public final java.lang.String OPSTR_READ_PHONE_NUMBERS
  static const OPSTR_READ_PHONE_NUMBERS = "android:read_phone_numbers";

  /// from: static public final java.lang.String OPSTR_READ_PHONE_STATE
  /// Required to access phone state related information.
  static const OPSTR_READ_PHONE_STATE = "android:read_phone_state";

  /// from: static public final java.lang.String OPSTR_READ_SMS
  /// Allows an application to read SMS messages.
  static const OPSTR_READ_SMS = "android:read_sms";

  /// from: static public final java.lang.String OPSTR_RECEIVE_MMS
  /// Allows an application to receive MMS messages.
  static const OPSTR_RECEIVE_MMS = "android:receive_mms";

  /// from: static public final java.lang.String OPSTR_RECEIVE_SMS
  /// Allows an application to receive SMS messages.
  static const OPSTR_RECEIVE_SMS = "android:receive_sms";

  /// from: static public final java.lang.String OPSTR_RECEIVE_WAP_PUSH
  /// Allows an application to receive WAP push messages.
  static const OPSTR_RECEIVE_WAP_PUSH = "android:receive_wap_push";

  /// from: static public final java.lang.String OPSTR_RECORD_AUDIO
  /// Required to be able to access the microphone device.
  static const OPSTR_RECORD_AUDIO = "android:record_audio";

  /// from: static public final java.lang.String OPSTR_SEND_SMS
  /// Allows an application to send SMS messages.
  static const OPSTR_SEND_SMS = "android:send_sms";

  /// from: static public final java.lang.String OPSTR_SYSTEM_ALERT_WINDOW
  /// Required to draw on top of other apps.
  static const OPSTR_SYSTEM_ALERT_WINDOW = "android:system_alert_window";

  /// from: static public final java.lang.String OPSTR_USE_FINGERPRINT
  /// Use the fingerprint API.
  static const OPSTR_USE_FINGERPRINT = "android:use_fingerprint";

  /// from: static public final java.lang.String OPSTR_USE_SIP
  /// Access APIs for SIP calling over VOIP or WiFi
  static const OPSTR_USE_SIP = "android:use_sip";

  /// from: static public final java.lang.String OPSTR_WRITE_CALENDAR
  /// Allows an application to write to the user's calendar data.
  static const OPSTR_WRITE_CALENDAR = "android:write_calendar";

  /// from: static public final java.lang.String OPSTR_WRITE_CALL_LOG
  /// Allows an application to write to the user's call log.
  static const OPSTR_WRITE_CALL_LOG = "android:write_call_log";

  /// from: static public final java.lang.String OPSTR_WRITE_CONTACTS
  /// Allows an application to write to the user's contacts data.
  static const OPSTR_WRITE_CONTACTS = "android:write_contacts";

  /// from: static public final java.lang.String OPSTR_WRITE_EXTERNAL_STORAGE
  /// Write external storage.
  static const OPSTR_WRITE_EXTERNAL_STORAGE = "android:write_external_storage";

  /// from: static public final java.lang.String OPSTR_WRITE_SETTINGS
  /// Required to write/modify/update system settingss.
  static const OPSTR_WRITE_SETTINGS = "android:write_settings";

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_AppOpsManager_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  AppOpsManager() : super.fromRef(_ctor());

  static final _permissionToOp = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_AppOpsManager_permissionToOp")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String permissionToOp(java.lang.String permission)
  /// Gets the app op name associated with a given permission.
  /// The app op name is one of the public constants defined
  /// in this class such as \#OPSTR_COARSE_LOCATION.
  /// This API is intended to be used for mapping runtime
  /// permissions to the corresponding app op.
  ///@param permission The permission.
  ///@return The app op associated with the permission or null.
  static jni.JlString permissionToOp(jni.JlString permission) =>
      jni.JlString.fromRef(_permissionToOp(permission.reference));

  static final _startWatchingMode = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AppOpsManager_startWatchingMode")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startWatchingMode(java.lang.String op, java.lang.String packageName, android.app.AppOpsManager.OnOpChangedListener callback)
  /// Monitor for changes to the operating mode for the given op in the given app package.
  /// You can watch op changes only for your UID.
  ///@param op The operation to monitor, one of OPSTR_*.
  ///@param packageName The name of the application to monitor.
  ///@param callback Where to report changes.
  void startWatchingMode(jni.JlString op, jni.JlString packageName,
          AppOpsManager_OnOpChangedListener callback) =>
      _startWatchingMode(
          reference, op.reference, packageName.reference, callback.reference);

  static final _stopWatchingMode = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AppOpsManager_stopWatchingMode")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void stopWatchingMode(android.app.AppOpsManager.OnOpChangedListener callback)
  /// Stop monitoring that was previously started with \#startWatchingMode.  All
  /// monitoring associated with this callback will be removed.
  void stopWatchingMode(AppOpsManager_OnOpChangedListener callback) =>
      _stopWatchingMode(reference, callback.reference);

  static final _checkOp = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_AppOpsManager_checkOp")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int checkOp(java.lang.String op, int uid, java.lang.String packageName)
  /// Do a quick check for whether an application might be able to perform an operation.
  /// This is _not_ a security check; you must use \#noteOp(String, int, String)
  /// or \#startOp(String, int, String) for your actual security checks, which also
  /// ensure that the given uid and package name are consistent.  This function can just be
  /// used for a quick check to see if an operation has been disabled for the application,
  /// as an early reject of some work.  This does not modify the time stamp or other data
  /// about the operation.
  ///
  /// Important things this will not do (which you need to ultimate use
  /// \#noteOp(String, int, String) or \#startOp(String, int, String) to cover):
  ///
  /// <ul>
  ///     <li>Verifying the uid and package are consistent, so callers can't spoof
  ///     their identity.</li>
  ///     <li>Taking into account the current foreground/background state of the
  ///     app; apps whose mode varies by this state will always be reported
  ///     as \#MODE_ALLOWED.</li>
  /// </ul>
  ///@param op The operation to check.  One of the OPSTR_* constants.
  ///@param uid The user id of the application attempting to perform the operation.
  ///@param packageName The name of the application attempting to perform the operation.
  ///@return Returns \#MODE_ALLOWED if the operation is allowed, or
  /// \#MODE_IGNORED if it is not allowed and should be silently ignored (without
  /// causing the app to crash).
  ///@throws SecurityException If the app has been configured to crash on this op.
  int checkOp(jni.JlString op, int uid, jni.JlString packageName) =>
      _checkOp(reference, op.reference, uid, packageName.reference);

  static final _checkOpNoThrow = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AppOpsManager_checkOpNoThrow")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int checkOpNoThrow(java.lang.String op, int uid, java.lang.String packageName)
  /// Like \#checkOp but instead of throwing a SecurityException it
  /// returns \#MODE_ERRORED.
  int checkOpNoThrow(jni.JlString op, int uid, jni.JlString packageName) =>
      _checkOpNoThrow(reference, op.reference, uid, packageName.reference);

  static final _noteOp = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_AppOpsManager_noteOp")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int noteOp(java.lang.String op, int uid, java.lang.String packageName)
  /// Make note of an application performing an operation.  Note that you must pass
  /// in both the uid and name of the application to be checked; this function will verify
  /// that these two match, and if not, return \#MODE_IGNORED.  If this call
  /// succeeds, the last execution time of the operation for this app will be updated to
  /// the current time.
  ///@param op The operation to note.  One of the OPSTR_* constants.
  ///@param uid The user id of the application attempting to perform the operation.
  ///@param packageName The name of the application attempting to perform the operation.
  ///@return Returns \#MODE_ALLOWED if the operation is allowed, or
  /// \#MODE_IGNORED if it is not allowed and should be silently ignored (without
  /// causing the app to crash).
  ///@throws SecurityException If the app has been configured to crash on this op.
  int noteOp(jni.JlString op, int uid, jni.JlString packageName) =>
      _noteOp(reference, op.reference, uid, packageName.reference);

  static final _noteOpNoThrow = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AppOpsManager_noteOpNoThrow")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int noteOpNoThrow(java.lang.String op, int uid, java.lang.String packageName)
  /// Like \#noteOp but instead of throwing a SecurityException it
  /// returns \#MODE_ERRORED.
  int noteOpNoThrow(jni.JlString op, int uid, jni.JlString packageName) =>
      _noteOpNoThrow(reference, op.reference, uid, packageName.reference);

  static final _noteProxyOp = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AppOpsManager_noteProxyOp")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int noteProxyOp(java.lang.String op, java.lang.String proxiedPackageName)
  /// Make note of an application performing an operation on behalf of another
  /// application when handling an IPC. Note that you must pass the package name
  /// of the application that is being proxied while its UID will be inferred from
  /// the IPC state; this function will verify that the calling uid and proxied
  /// package name match, and if not, return \#MODE_IGNORED. If this call
  /// succeeds, the last execution time of the operation for the proxied app and
  /// your app will be updated to the current time.
  ///@param op The operation to note.  One of the OPSTR_* constants.
  ///@param proxiedPackageName The name of the application calling into the proxy application.
  ///@return Returns \#MODE_ALLOWED if the operation is allowed, or
  /// \#MODE_IGNORED if it is not allowed and should be silently ignored (without
  /// causing the app to crash).
  ///@throws SecurityException If the app has been configured to crash on this op.
  int noteProxyOp(jni.JlString op, jni.JlString proxiedPackageName) =>
      _noteProxyOp(reference, op.reference, proxiedPackageName.reference);

  static final _noteProxyOpNoThrow = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AppOpsManager_noteProxyOpNoThrow")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int noteProxyOpNoThrow(java.lang.String op, java.lang.String proxiedPackageName)
  /// Like \#noteProxyOp(String, String) but instead
  /// of throwing a SecurityException it returns \#MODE_ERRORED.
  int noteProxyOpNoThrow(jni.JlString op, jni.JlString proxiedPackageName) =>
      _noteProxyOpNoThrow(
          reference, op.reference, proxiedPackageName.reference);

  static final _startOp = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_AppOpsManager_startOp")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int startOp(java.lang.String op, int uid, java.lang.String packageName)
  /// Report that an application has started executing a long-running operation.  Note that you
  /// must pass in both the uid and name of the application to be checked; this function will
  /// verify that these two match, and if not, return \#MODE_IGNORED.  If this call
  /// succeeds, the last execution time of the operation for this app will be updated to
  /// the current time and the operation will be marked as "running".  In this case you must
  /// later call \#finishOp(String, int, String) to report when the application is no
  /// longer performing the operation.
  ///@param op The operation to start.  One of the OPSTR_* constants.
  ///@param uid The user id of the application attempting to perform the operation.
  ///@param packageName The name of the application attempting to perform the operation.
  ///@return Returns \#MODE_ALLOWED if the operation is allowed, or
  /// \#MODE_IGNORED if it is not allowed and should be silently ignored (without
  /// causing the app to crash).
  ///@throws SecurityException If the app has been configured to crash on this op.
  int startOp(jni.JlString op, int uid, jni.JlString packageName) =>
      _startOp(reference, op.reference, uid, packageName.reference);

  static final _startOpNoThrow = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AppOpsManager_startOpNoThrow")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int startOpNoThrow(java.lang.String op, int uid, java.lang.String packageName)
  /// Like \#startOp but instead of throwing a SecurityException it
  /// returns \#MODE_ERRORED.
  int startOpNoThrow(jni.JlString op, int uid, jni.JlString packageName) =>
      _startOpNoThrow(reference, op.reference, uid, packageName.reference);

  static final _finishOp = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_AppOpsManager_finishOp")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void finishOp(java.lang.String op, int uid, java.lang.String packageName)
  /// Report that an application is no longer performing an operation that had previously
  /// been started with \#startOp(String, int, String).  There is no validation of input
  /// or result; the parameters supplied here must be the exact same ones previously passed
  /// in when starting the operation.
  void finishOp(jni.JlString op, int uid, jni.JlString packageName) =>
      _finishOp(reference, op.reference, uid, packageName.reference);

  static final _checkPackage = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AppOpsManager_checkPackage")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void checkPackage(int uid, java.lang.String packageName)
  /// Do a quick check to validate if a package name belongs to a UID.
  ///@throws SecurityException if the package name doesn't belong to the given
  ///             UID, or if ownership cannot be verified.
  void checkPackage(int uid, jni.JlString packageName) =>
      _checkPackage(reference, uid, packageName.reference);
}

/// Callback for notification of changes to operation state.
class AppOpsManager_OnOpChangedListener extends jni.JlObject {
  AppOpsManager_OnOpChangedListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onOpChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AppOpsManager__OnOpChangedListener_onOpChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onOpChanged(java.lang.String op, java.lang.String packageName)
  void onOpChanged(jni.JlString op, jni.JlString packageName) =>
      _onOpChanged(reference, op.reference, packageName.reference);
}

/// Interface associated with an Activity or Fragment for managing
/// one or more android.content.Loader instances associated with it.  This
/// helps an application manage longer-running operations in conjunction with the
/// Activity or Fragment lifecycle; the most common use of this is with a
/// android.content.CursorLoader, however applications are free to write
/// their own loaders for loading other types of data.
///
/// While the LoaderManager API was introduced in
/// android.os.Build.VERSION_CODES\#HONEYCOMB, a version of the API
/// at is also available for use on older platforms through
/// android.support.v4.app.FragmentActivity.  See the blog post
/// <a href="http://android-developers.blogspot.com/2011/03/fragments-for-all.html">
/// Fragments For All</a> for more details.
///
/// As an example, here is the full implementation of a Fragment
/// that displays a android.widget.ListView containing the results of
/// a query against the contacts content provider.  It uses a
/// android.content.CursorLoader to manage the query on the provider.
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/LoaderCursor.java
///      fragment_cursor}
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using loaders, read the
/// <a href="{@docRoot}guide/topics/fundamentals/loaders.html">Loaders</a> developer guide.
///
/// </div>
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.LoaderManager
class LoaderManager extends jni.JlObject {
  LoaderManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_LoaderManager_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  LoaderManager() : super.fromRef(_ctor());

  static final _initLoader = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_LoaderManager_initLoader")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Loader<D> initLoader(int id, android.os.Bundle args, android.app.LoaderManager.LoaderCallbacks<D> callback)
  /// Ensures a loader is initialized and active.  If the loader doesn't
  /// already exist, one is created and (if the activity/fragment is currently
  /// started) starts the loader.  Otherwise the last created
  /// loader is re-used.
  ///
  /// In either case, the given callback is associated with the loader, and
  /// will be called as the loader state changes.  If at the point of call
  /// the caller is in its started state, and the requested loader
  /// already exists and has generated its data, then
  /// callback LoaderCallbacks\#onLoadFinished will
  /// be called immediately (inside of this function), so you must be prepared
  /// for this to happen.
  ///@param id A unique identifier for this loader.  Can be whatever you want.
  /// Identifiers are scoped to a particular LoaderManager instance.
  ///@param args Optional arguments to supply to the loader at construction.
  /// If a loader already exists (a new one does not need to be created), this
  /// parameter will be ignored and the last arguments continue to be used.
  ///@param callback Interface the LoaderManager will call to report about
  /// changes in the state of the loader.  Required.
  content.Loader initLoader(
          int id, os.Bundle args, LoaderManager_LoaderCallbacks callback) =>
      content.Loader.fromRef(
          _initLoader(reference, id, args.reference, callback.reference));

  static final _restartLoader = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_LoaderManager_restartLoader")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Loader<D> restartLoader(int id, android.os.Bundle args, android.app.LoaderManager.LoaderCallbacks<D> callback)
  /// Starts a new or restarts an existing android.content.Loader in
  /// this manager, registers the callbacks to it,
  /// and (if the activity/fragment is currently started) starts loading it.
  /// If a loader with the same id has previously been
  /// started it will automatically be destroyed when the new loader completes
  /// its work. The callback will be delivered before the old loader
  /// is destroyed.
  ///@param id A unique identifier for this loader.  Can be whatever you want.
  /// Identifiers are scoped to a particular LoaderManager instance.
  ///@param args Optional arguments to supply to the loader at construction.
  ///@param callback Interface the LoaderManager will call to report about
  /// changes in the state of the loader.  Required.
  content.Loader restartLoader(
          int id, os.Bundle args, LoaderManager_LoaderCallbacks callback) =>
      content.Loader.fromRef(
          _restartLoader(reference, id, args.reference, callback.reference));

  static final _destroyLoader = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_LoaderManager_destroyLoader")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void destroyLoader(int id)
  /// Stops and removes the loader with the given ID.  If this loader
  /// had previously reported data to the client through
  /// LoaderCallbacks\#onLoadFinished(Loader, Object), a call
  /// will be made to LoaderCallbacks\#onLoaderReset(Loader).
  void destroyLoader(int id) => _destroyLoader(reference, id);

  static final _getLoader = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_LoaderManager_getLoader")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.Loader<D> getLoader(int id)
  /// Return the Loader with the given id or null if no matching Loader
  /// is found.
  content.Loader getLoader(int id) =>
      content.Loader.fromRef(_getLoader(reference, id));

  static final _dump = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_LoaderManager_dump")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  /// Print the LoaderManager's state into the given stream.
  ///@param prefix Text to print at the front of each line.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer A PrintWriter to which the dump is to be set.
  ///@param args Additional arguments to the dump request.
  void dump(jni.JlString prefix, jni.JlObject fd, jni.JlObject writer,
          jni.JlObject args) =>
      _dump(reference, prefix.reference, fd.reference, writer.reference,
          args.reference);

  static final _enableDebugLogging =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
              "android_app_LoaderManager_enableDebugLogging")
          .asFunction<void Function(int)>();

  /// from: static public void enableDebugLogging(boolean enabled)
  /// Control whether the framework's internal loader manager debugging
  /// logs are turned on.  If enabled, you will see output in logcat as
  /// the framework performs loader operations.
  static void enableDebugLogging(bool enabled) =>
      _enableDebugLogging(enabled ? 1 : 0);
}

/// Callback interface for a client to interact with the manager.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">
///      Support Library</a> android.support.v4.app.LoaderManager.LoaderCallbacks
class LoaderManager_LoaderCallbacks extends jni.JlObject {
  LoaderManager_LoaderCallbacks.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onCreateLoader = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_app_LoaderManager__LoaderCallbacks_onCreateLoader")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Loader<D> onCreateLoader(int id, android.os.Bundle args)
  /// Instantiate and return a new Loader for the given ID.
  ///@param id The ID whose loader is to be created.
  ///@param args Any arguments supplied by the caller.
  ///@return Return a new Loader instance that is ready to start loading.
  content.Loader onCreateLoader(int id, os.Bundle args) =>
      content.Loader.fromRef(_onCreateLoader(reference, id, args.reference));

  static final _onLoaderReset = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_LoaderManager__LoaderCallbacks_onLoaderReset")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onLoaderReset(android.content.Loader<D> loader)
  /// Called when a previously created loader is being reset, and thus
  /// making its data unavailable.  The application should at this point
  /// remove any references it has to the Loader's data.
  ///@param loader The Loader that is being reset.
  void onLoaderReset(content.Loader loader) =>
      _onLoaderReset(reference, loader.reference);
}

/// Interface for interacting with Fragment objects inside of an
/// Activity
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using fragments, read the
/// <a href="{@docRoot}guide/components/fragments.html">Fragments</a> developer guide.
///
/// </div>
///
/// While the FragmentManager API was introduced in
/// android.os.Build.VERSION_CODES\#HONEYCOMB, a version of the API
/// at is also available for use on older platforms through
/// android.support.v4.app.FragmentActivity.  See the blog post
/// <a href="http://android-developers.blogspot.com/2011/03/fragments-for-all.html">
/// Fragments For All</a> for more details.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.FragmentManager for consistent behavior across all devices
///      and access to <a href="{@docRoot}topic/libraries/architecture/lifecycle.html">Lifecycle</a>.
class FragmentManager extends jni.JlObject {
  FragmentManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int POP_BACK_STACK_INCLUSIVE
  /// Flag for \#popBackStack(String, int)
  /// and \#popBackStack(int, int): If set, and the name or ID of
  /// a back stack entry has been supplied, then all matching entries will
  /// be consumed until one that doesn't match is found or the bottom of
  /// the stack is reached.  Otherwise, all entries up to but not including that entry
  /// will be removed.
  static const POP_BACK_STACK_INCLUSIVE = 1;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_FragmentManager_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  FragmentManager() : super.fromRef(_ctor());

  static final _beginTransaction = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager_beginTransaction")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction beginTransaction()
  /// Start a series of edit operations on the Fragments associated with
  /// this FragmentManager.
  ///
  /// Note: A fragment transaction can only be created/committed prior
  /// to an activity saving its state.  If you try to commit a transaction
  /// after Activity\#onSaveInstanceState Activity.onSaveInstanceState()
  /// (and prior to a following Activity\#onStart Activity.onStart
  /// or Activity\#onResume Activity.onResume(), you will get an error.
  /// This is because the framework takes care of saving your current fragments
  /// in the state, and if changes are made after the state is saved then they
  /// will be lost.
  ///
  FragmentTransaction beginTransaction() =>
      FragmentTransaction.fromRef(_beginTransaction(reference));

  static final _executePendingTransactions =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentManager_executePendingTransactions")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean executePendingTransactions()
  /// After a FragmentTransaction is committed with
  /// FragmentTransaction\#commit FragmentTransaction.commit(), it
  /// is scheduled to be executed asynchronously on the process's main thread.
  /// If you want to immediately executing any such pending operations, you
  /// can call this function (only from the main thread) to do so.  Note that
  /// all callbacks and other related behavior will be done from within this
  /// call, so be careful about where this is called from.
  ///
  /// This also forces the start of any postponed Transactions where
  /// Fragment\#postponeEnterTransition() has been called.
  ///@return Returns true if there were any pending transactions to be
  /// executed.
  bool executePendingTransactions() =>
      _executePendingTransactions(reference) != 0;

  static final _findFragmentById = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_FragmentManager_findFragmentById")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.Fragment findFragmentById(int id)
  /// Finds a fragment that was identified by the given id either when inflated
  /// from XML or as the container ID when added in a transaction.  This first
  /// searches through fragments that are currently added to the manager's
  /// activity; if no such fragment is found, then all fragments currently
  /// on the back stack associated with this ID are searched.
  ///@return The fragment if found or null otherwise.
  Fragment findFragmentById(int id) =>
      Fragment.fromRef(_findFragmentById(reference, id));

  static final _findFragmentByTag = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager_findFragmentByTag")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.Fragment findFragmentByTag(java.lang.String tag)
  /// Finds a fragment that was identified by the given tag either when inflated
  /// from XML or as supplied when added in a transaction.  This first
  /// searches through fragments that are currently added to the manager's
  /// activity; if no such fragment is found, then all fragments currently
  /// on the back stack are searched.
  ///@return The fragment if found or null otherwise.
  Fragment findFragmentByTag(jni.JlString tag) =>
      Fragment.fromRef(_findFragmentByTag(reference, tag.reference));

  static final _popBackStack =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentManager_popBackStack")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void popBackStack()
  /// Pop the top state off the back stack.  This function is asynchronous -- it
  /// enqueues the request to pop, but the action will not be performed until the
  /// application returns to its event loop.
  void popBackStack() => _popBackStack(reference);

  static final _popBackStackImmediate =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentManager_popBackStackImmediate")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean popBackStackImmediate()
  /// Like \#popBackStack(), but performs the operation immediately
  /// inside of the call.  This is like calling \#executePendingTransactions()
  /// afterwards without forcing the start of postponed Transactions.
  ///@return Returns true if there was something popped, else false.
  bool popBackStackImmediate() => _popBackStackImmediate(reference) != 0;

  static final _popBackStack_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_FragmentManager_popBackStack_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void popBackStack(java.lang.String name, int flags)
  /// Pop the last fragment transition from the manager's fragment
  /// back stack.  If there is nothing to pop, false is returned.
  /// This function is asynchronous -- it enqueues the
  /// request to pop, but the action will not be performed until the application
  /// returns to its event loop.
  ///@param name If non-null, this is the name of a previous back state
  /// to look for; if found, all states up to that state will be popped.  The
  /// \#POP_BACK_STACK_INCLUSIVE flag can be used to control whether
  /// the named state itself is popped. If null, only the top state is popped.
  ///@param flags Either 0 or \#POP_BACK_STACK_INCLUSIVE.
  void popBackStack_1(jni.JlString name, int flags) =>
      _popBackStack_1(reference, name.reference, flags);

  static final _popBackStackImmediate_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_FragmentManager_popBackStackImmediate_1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract boolean popBackStackImmediate(java.lang.String name, int flags)
  /// Like \#popBackStack(String, int), but performs the operation immediately
  /// inside of the call.  This is like calling \#executePendingTransactions()
  /// afterwards without forcing the start of postponed Transactions.
  ///@return Returns true if there was something popped, else false.
  bool popBackStackImmediate_1(jni.JlString name, int flags) =>
      _popBackStackImmediate_1(reference, name.reference, flags) != 0;

  static final _popBackStack_2 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_app_FragmentManager_popBackStack_2")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void popBackStack(int id, int flags)
  /// Pop all back stack states up to the one with the given identifier.
  /// This function is asynchronous -- it enqueues the
  /// request to pop, but the action will not be performed until the application
  /// returns to its event loop.
  ///@param id Identifier of the stated to be popped. If no identifier exists,
  /// false is returned.
  /// The identifier is the number returned by
  /// FragmentTransaction\#commit() FragmentTransaction.commit().  The
  /// \#POP_BACK_STACK_INCLUSIVE flag can be used to control whether
  /// the named state itself is popped.
  ///@param flags Either 0 or \#POP_BACK_STACK_INCLUSIVE.
  void popBackStack_2(int id, int flags) =>
      _popBackStack_2(reference, id, flags);

  static final _popBackStackImmediate_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_app_FragmentManager_popBackStackImmediate_2")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract boolean popBackStackImmediate(int id, int flags)
  /// Like \#popBackStack(int, int), but performs the operation immediately
  /// inside of the call.  This is like calling \#executePendingTransactions()
  /// afterwards without forcing the start of postponed Transactions.
  ///@return Returns true if there was something popped, else false.
  bool popBackStackImmediate_2(int id, int flags) =>
      _popBackStackImmediate_2(reference, id, flags) != 0;

  static final _getBackStackEntryCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentManager_getBackStackEntryCount")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getBackStackEntryCount()
  /// Return the number of entries currently in the back stack.
  int getBackStackEntryCount() => _getBackStackEntryCount(reference);

  static final _getBackStackEntryAt = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_FragmentManager_getBackStackEntryAt")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.FragmentManager.BackStackEntry getBackStackEntryAt(int index)
  /// Return the BackStackEntry at index <var>index</var> in the back stack;
  /// where the item on the bottom of the stack has index 0.
  FragmentManager_BackStackEntry getBackStackEntryAt(int index) =>
      FragmentManager_BackStackEntry.fromRef(
          _getBackStackEntryAt(reference, index));

  static final _addOnBackStackChangedListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager_addOnBackStackChangedListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void addOnBackStackChangedListener(android.app.FragmentManager.OnBackStackChangedListener listener)
  /// Add a new listener for changes to the fragment back stack.
  void addOnBackStackChangedListener(
          FragmentManager_OnBackStackChangedListener listener) =>
      _addOnBackStackChangedListener(reference, listener.reference);

  static final _removeOnBackStackChangedListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager_removeOnBackStackChangedListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void removeOnBackStackChangedListener(android.app.FragmentManager.OnBackStackChangedListener listener)
  /// Remove a listener that was previously added with
  /// \#addOnBackStackChangedListener(OnBackStackChangedListener).
  void removeOnBackStackChangedListener(
          FragmentManager_OnBackStackChangedListener listener) =>
      _removeOnBackStackChangedListener(reference, listener.reference);

  static final _putFragment = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager_putFragment")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void putFragment(android.os.Bundle bundle, java.lang.String key, android.app.Fragment fragment)
  /// Put a reference to a fragment in a Bundle.  This Bundle can be
  /// persisted as saved state, and when later restoring
  /// \#getFragment(Bundle, String) will return the current
  /// instance of the same fragment.
  ///@param bundle The bundle in which to put the fragment reference.
  ///@param key The name of the entry in the bundle.
  ///@param fragment The Fragment whose reference is to be stored.
  void putFragment(os.Bundle bundle, jni.JlString key, Fragment fragment) =>
      _putFragment(
          reference, bundle.reference, key.reference, fragment.reference);

  static final _getFragment = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager_getFragment")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.Fragment getFragment(android.os.Bundle bundle, java.lang.String key)
  /// Retrieve the current Fragment instance for a reference previously
  /// placed with \#putFragment(Bundle, String, Fragment).
  ///@param bundle The bundle from which to retrieve the fragment reference.
  ///@param key The name of the entry in the bundle.
  ///@return Returns the current Fragment instance that is associated with
  /// the given reference.
  Fragment getFragment(os.Bundle bundle, jni.JlString key) => Fragment.fromRef(
      _getFragment(reference, bundle.reference, key.reference));

  static final _getFragments = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager_getFragments")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.util.List<android.app.Fragment> getFragments()
  /// Get a list of all fragments that are currently added to the FragmentManager.
  /// This may include those that are hidden as well as those that are shown.
  /// This will not include any fragments only in the back stack, or fragments that
  /// are detached or removed.
  ///
  /// The order of the fragments in the list is the order in which they were
  /// added or attached.
  ///@return A list of all fragments that are added to the FragmentManager.
  jni.JlObject getFragments() => jni.JlObject.fromRef(_getFragments(reference));

  static final _saveFragmentInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager_saveFragmentInstanceState")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.Fragment.SavedState saveFragmentInstanceState(android.app.Fragment f)
  /// Save the current instance state of the given Fragment.  This can be
  /// used later when creating a new instance of the Fragment and adding
  /// it to the fragment manager, to have it create itself to match the
  /// current state returned here.  Note that there are limits on how
  /// this can be used:
  ///
  /// <ul>
  /// <li>The Fragment must currently be attached to the FragmentManager.
  /// <li>A new Fragment created using this saved state must be the same class
  /// type as the Fragment it was created from.
  /// <li>The saved state can not contain dependencies on other fragments --
  /// that is it can't use \#putFragment(Bundle, String, Fragment) to
  /// store a fragment reference because that reference may not be valid when
  /// this saved state is later used.  Likewise the Fragment's target and
  /// result code are not included in this state.
  /// </ul>
  ///@param f The Fragment whose state is to be saved.
  ///@return The generated state.  This will be null if there was no
  /// interesting state created by the fragment.
  Fragment_SavedState saveFragmentInstanceState(Fragment f) =>
      Fragment_SavedState.fromRef(
          _saveFragmentInstanceState(reference, f.reference));

  static final _isDestroyed =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentManager_isDestroyed")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isDestroyed()
  /// Returns true if the final Activity\#onDestroy() Activity.onDestroy()
  /// call has been made on the FragmentManager's Activity, so this instance is now dead.
  bool isDestroyed() => _isDestroyed(reference) != 0;

  static final _registerFragmentLifecycleCallbacks = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_FragmentManager_registerFragmentLifecycleCallbacks")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void registerFragmentLifecycleCallbacks(android.app.FragmentManager.FragmentLifecycleCallbacks cb, boolean recursive)
  /// Registers a FragmentLifecycleCallbacks to listen to fragment lifecycle events
  /// happening in this FragmentManager. All registered callbacks will be automatically
  /// unregistered when this FragmentManager is destroyed.
  ///@param cb Callbacks to register
  ///@param recursive true to automatically register this callback for all child FragmentManagers
  void registerFragmentLifecycleCallbacks(
          FragmentManager_FragmentLifecycleCallbacks cb, bool recursive) =>
      _registerFragmentLifecycleCallbacks(
          reference, cb.reference, recursive ? 1 : 0);

  static final _unregisterFragmentLifecycleCallbacks = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager_unregisterFragmentLifecycleCallbacks")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void unregisterFragmentLifecycleCallbacks(android.app.FragmentManager.FragmentLifecycleCallbacks cb)
  /// Unregisters a previously registered FragmentLifecycleCallbacks. If the callback
  /// was not previously registered this call has no effect. All registered callbacks will be
  /// automatically unregistered when this FragmentManager is destroyed.
  ///@param cb Callbacks to unregister
  void unregisterFragmentLifecycleCallbacks(
          FragmentManager_FragmentLifecycleCallbacks cb) =>
      _unregisterFragmentLifecycleCallbacks(reference, cb.reference);

  static final _getPrimaryNavigationFragment = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager_getPrimaryNavigationFragment")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.Fragment getPrimaryNavigationFragment()
  /// Return the currently active primary navigation fragment for this FragmentManager.
  ///
  /// The primary navigation fragment's
  /// Fragment\#getChildFragmentManager() child FragmentManager will be called first
  /// to process delegated navigation actions such as \#popBackStack() if no ID
  /// or transaction name is provided to pop to.
  ///
  ///@return the fragment designated as the primary navigation fragment
  Fragment getPrimaryNavigationFragment() =>
      Fragment.fromRef(_getPrimaryNavigationFragment(reference));

  static final _dump = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_FragmentManager_dump")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  /// Print the FragmentManager's state into the given stream.
  ///@param prefix Text to print at the front of each line.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer A PrintWriter to which the dump is to be set.
  ///@param args Additional arguments to the dump request.
  void dump(jni.JlString prefix, jni.JlObject fd, jni.JlObject writer,
          jni.JlObject args) =>
      _dump(reference, prefix.reference, fd.reference, writer.reference,
          args.reference);

  static final _enableDebugLogging =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
              "android_app_FragmentManager_enableDebugLogging")
          .asFunction<void Function(int)>();

  /// from: static public void enableDebugLogging(boolean enabled)
  /// Control whether the framework's internal fragment manager debugging
  /// logs are turned on.  If enabled, you will see output in logcat as
  /// the framework performs fragment operations.
  static void enableDebugLogging(bool enabled) =>
      _enableDebugLogging(enabled ? 1 : 0);

  static final _invalidateOptionsMenu =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentManager_invalidateOptionsMenu")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void invalidateOptionsMenu()
  /// Invalidate the attached activity's options menu as necessary.
  /// This may end up being deferred until we move to the resumed state.
  void invalidateOptionsMenu() => _invalidateOptionsMenu(reference);

  static final _isStateSaved =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentManager_isStateSaved")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isStateSaved()
  /// Returns {@code true} if the FragmentManager's state has already been saved
  /// by its host. Any operations that would change saved state should not be performed
  /// if this method returns true. For example, any popBackStack() method, such as
  /// \#popBackStackImmediate() or any FragmentTransaction using
  /// FragmentTransaction\#commit() instead of
  /// FragmentTransaction\#commitAllowingStateLoss() will change
  /// the state and will result in an error.
  ///@return true if this FragmentManager's state has already been saved by its host
  bool isStateSaved() => _isStateSaved(reference) != 0;
}

/// Interface to watch for changes to the back stack.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">
///      Support Library</a>
///      android.support.v4.app.FragmentManager.OnBackStackChangedListener
class FragmentManager_OnBackStackChangedListener extends jni.JlObject {
  FragmentManager_OnBackStackChangedListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onBackStackChanged = jlookup<
              ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__OnBackStackChangedListener_onBackStackChanged")
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onBackStackChanged()
  /// Called whenever the contents of the back stack change.
  void onBackStackChanged() => _onBackStackChanged(reference);
}

/// Callback interface for listening to fragment state changes that happen
/// within a given FragmentManager.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">
///      Support Library</a>
///      android.support.v4.app.FragmentManager.FragmentLifecycleCallbacks
class FragmentManager_FragmentLifecycleCallbacks extends jni.JlObject {
  FragmentManager_FragmentLifecycleCallbacks.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_FragmentManager__FragmentLifecycleCallbacks_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  FragmentManager_FragmentLifecycleCallbacks() : super.fromRef(_ctor());

  static final _onFragmentPreAttached = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__FragmentLifecycleCallbacks_onFragmentPreAttached")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentPreAttached(android.app.FragmentManager fm, android.app.Fragment f, android.content.Context context)
  /// Called right before the fragment's Fragment\#onAttach(Context) method is called.
  /// This is a good time to inject any required dependencies for the fragment before any of
  /// the fragment's lifecycle methods are invoked.
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  ///@param context Context that the Fragment is being attached to
  void onFragmentPreAttached(
          FragmentManager fm, Fragment f, content.Context context) =>
      _onFragmentPreAttached(
          reference, fm.reference, f.reference, context.reference);

  static final _onFragmentAttached = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__FragmentLifecycleCallbacks_onFragmentAttached")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentAttached(android.app.FragmentManager fm, android.app.Fragment f, android.content.Context context)
  /// Called after the fragment has been attached to its host. Its host will have had
  /// <code>onAttachFragment</code> called before this call happens.
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  ///@param context Context that the Fragment was attached to
  void onFragmentAttached(
          FragmentManager fm, Fragment f, content.Context context) =>
      _onFragmentAttached(
          reference, fm.reference, f.reference, context.reference);

  static final _onFragmentPreCreated = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__FragmentLifecycleCallbacks_onFragmentPreCreated")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentPreCreated(android.app.FragmentManager fm, android.app.Fragment f, android.os.Bundle savedInstanceState)
  /// Called right before the fragment's Fragment\#onCreate(Bundle) method is called.
  /// This is a good time to inject any required dependencies or perform other configuration
  /// for the fragment.
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  ///@param savedInstanceState Saved instance bundle from a previous instance
  void onFragmentPreCreated(
          FragmentManager fm, Fragment f, os.Bundle savedInstanceState) =>
      _onFragmentPreCreated(
          reference, fm.reference, f.reference, savedInstanceState.reference);

  static final _onFragmentCreated = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__FragmentLifecycleCallbacks_onFragmentCreated")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentCreated(android.app.FragmentManager fm, android.app.Fragment f, android.os.Bundle savedInstanceState)
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onCreate(Bundle). This will only happen once for any given
  /// fragment instance, though the fragment may be attached and detached multiple times.
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  ///@param savedInstanceState Saved instance bundle from a previous instance
  void onFragmentCreated(
          FragmentManager fm, Fragment f, os.Bundle savedInstanceState) =>
      _onFragmentCreated(
          reference, fm.reference, f.reference, savedInstanceState.reference);

  static final _onFragmentActivityCreated = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__FragmentLifecycleCallbacks_onFragmentActivityCreated")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentActivityCreated(android.app.FragmentManager fm, android.app.Fragment f, android.os.Bundle savedInstanceState)
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onActivityCreated(Bundle). This will only happen once for any given
  /// fragment instance, though the fragment may be attached and detached multiple times.
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  ///@param savedInstanceState Saved instance bundle from a previous instance
  void onFragmentActivityCreated(
          FragmentManager fm, Fragment f, os.Bundle savedInstanceState) =>
      _onFragmentActivityCreated(
          reference, fm.reference, f.reference, savedInstanceState.reference);

  static final _onFragmentViewCreated = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__FragmentLifecycleCallbacks_onFragmentViewCreated")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentViewCreated(android.app.FragmentManager fm, android.app.Fragment f, android.view.View v, android.os.Bundle savedInstanceState)
  /// Called after the fragment has returned a non-null view from the FragmentManager's
  /// request to Fragment\#onCreateView(LayoutInflater, ViewGroup, Bundle).
  ///@param fm Host FragmentManager
  ///@param f Fragment that created and owns the view
  ///@param v View returned by the fragment
  ///@param savedInstanceState Saved instance bundle from a previous instance
  void onFragmentViewCreated(FragmentManager fm, Fragment f, jni.JlObject v,
          os.Bundle savedInstanceState) =>
      _onFragmentViewCreated(reference, fm.reference, f.reference, v.reference,
          savedInstanceState.reference);

  static final _onFragmentStarted = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__FragmentLifecycleCallbacks_onFragmentStarted")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentStarted(android.app.FragmentManager fm, android.app.Fragment f)
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onStart().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentStarted(FragmentManager fm, Fragment f) =>
      _onFragmentStarted(reference, fm.reference, f.reference);

  static final _onFragmentResumed = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__FragmentLifecycleCallbacks_onFragmentResumed")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentResumed(android.app.FragmentManager fm, android.app.Fragment f)
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onResume().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentResumed(FragmentManager fm, Fragment f) =>
      _onFragmentResumed(reference, fm.reference, f.reference);

  static final _onFragmentPaused = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__FragmentLifecycleCallbacks_onFragmentPaused")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentPaused(android.app.FragmentManager fm, android.app.Fragment f)
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onPause().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentPaused(FragmentManager fm, Fragment f) =>
      _onFragmentPaused(reference, fm.reference, f.reference);

  static final _onFragmentStopped = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__FragmentLifecycleCallbacks_onFragmentStopped")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentStopped(android.app.FragmentManager fm, android.app.Fragment f)
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onStop().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentStopped(FragmentManager fm, Fragment f) =>
      _onFragmentStopped(reference, fm.reference, f.reference);

  static final _onFragmentSaveInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__FragmentLifecycleCallbacks_onFragmentSaveInstanceState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentSaveInstanceState(android.app.FragmentManager fm, android.app.Fragment f, android.os.Bundle outState)
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onSaveInstanceState(Bundle).
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  ///@param outState Saved state bundle for the fragment
  void onFragmentSaveInstanceState(
          FragmentManager fm, Fragment f, os.Bundle outState) =>
      _onFragmentSaveInstanceState(
          reference, fm.reference, f.reference, outState.reference);

  static final _onFragmentViewDestroyed = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__FragmentLifecycleCallbacks_onFragmentViewDestroyed")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentViewDestroyed(android.app.FragmentManager fm, android.app.Fragment f)
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onDestroyView().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentViewDestroyed(FragmentManager fm, Fragment f) =>
      _onFragmentViewDestroyed(reference, fm.reference, f.reference);

  static final _onFragmentDestroyed = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__FragmentLifecycleCallbacks_onFragmentDestroyed")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentDestroyed(android.app.FragmentManager fm, android.app.Fragment f)
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onDestroy().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentDestroyed(FragmentManager fm, Fragment f) =>
      _onFragmentDestroyed(reference, fm.reference, f.reference);

  static final _onFragmentDetached = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__FragmentLifecycleCallbacks_onFragmentDetached")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentDetached(android.app.FragmentManager fm, android.app.Fragment f)
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onDetach().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentDetached(FragmentManager fm, Fragment f) =>
      _onFragmentDetached(reference, fm.reference, f.reference);
}

/// Representation of an entry on the fragment back stack, as created
/// with FragmentTransaction\#addToBackStack(String) FragmentTransaction.addToBackStack().  Entries can later be
/// retrieved with FragmentManager\#getBackStackEntryAt(int) FragmentManager.getBackStackEntryAt().
///
/// Note that you should never hold on to a BackStackEntry object;
/// the identifier as returned by \#getId is the only thing that
/// will be persisted across activity instances.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">
///      Support Library</a> android.support.v4.app.FragmentManager.BackStackEntry
class FragmentManager_BackStackEntry extends jni.JlObject {
  FragmentManager_BackStackEntry.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _getId =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentManager__BackStackEntry_getId")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getId()
  /// Return the unique identifier for the entry.  This is the only
  /// representation of the entry that will persist across activity
  /// instances.
  int getId() => _getId(reference);

  static final _getName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__BackStackEntry_getName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getName()
  /// Get the name that was supplied to
  /// FragmentTransaction\#addToBackStack(String) FragmentTransaction.addToBackStack(String) when creating this entry.
  jni.JlString getName() => jni.JlString.fromRef(_getName(reference));

  static final _getBreadCrumbTitleRes = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__BackStackEntry_getBreadCrumbTitleRes")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getBreadCrumbTitleRes()
  /// Return the full bread crumb title resource identifier for the entry,
  /// or 0 if it does not have one.
  int getBreadCrumbTitleRes() => _getBreadCrumbTitleRes(reference);

  static final _getBreadCrumbShortTitleRes = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__BackStackEntry_getBreadCrumbShortTitleRes")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getBreadCrumbShortTitleRes()
  /// Return the short bread crumb title resource identifier for the entry,
  /// or 0 if it does not have one.
  int getBreadCrumbShortTitleRes() => _getBreadCrumbShortTitleRes(reference);

  static final _getBreadCrumbTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__BackStackEntry_getBreadCrumbTitle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.CharSequence getBreadCrumbTitle()
  /// Return the full bread crumb title for the entry, or null if it
  /// does not have one.
  jni.JlObject getBreadCrumbTitle() =>
      jni.JlObject.fromRef(_getBreadCrumbTitle(reference));

  static final _getBreadCrumbShortTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentManager__BackStackEntry_getBreadCrumbShortTitle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.CharSequence getBreadCrumbShortTitle()
  /// Return the short bread crumb title for the entry, or null if it
  /// does not have one.
  jni.JlObject getBreadCrumbShortTitle() =>
      jni.JlObject.fromRef(_getBreadCrumbShortTitle(reference));
}

/// The download manager is a system service that handles long-running HTTP downloads. Clients may
/// request that a URI be downloaded to a particular destination file. The download manager will
/// conduct the download in the background, taking care of HTTP interactions and retrying downloads
/// after failures or across connectivity changes and system reboots.
///
/// Apps that request downloads through this API should register a broadcast receiver for
/// \#ACTION_NOTIFICATION_CLICKED to appropriately handle when the user clicks on a running
/// download in a notification or from the downloads UI.
///
/// Note that the application must have the android.Manifest.permission\#INTERNET
/// permission to use this class.
class DownloadManager extends jni.JlObject {
  DownloadManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_DOWNLOAD_COMPLETE
  /// Broadcast intent action sent by the download manager when a download completes.
  static const ACTION_DOWNLOAD_COMPLETE =
      "android.intent.action.DOWNLOAD_COMPLETE";

  /// from: static public final java.lang.String ACTION_NOTIFICATION_CLICKED
  /// Broadcast intent action sent by the download manager when the user clicks on a running
  /// download, either from a system notification or from the downloads UI.
  static const ACTION_NOTIFICATION_CLICKED =
      "android.intent.action.DOWNLOAD_NOTIFICATION_CLICKED";

  /// from: static public final java.lang.String ACTION_VIEW_DOWNLOADS
  /// Intent action to launch an activity to display all downloads.
  static const ACTION_VIEW_DOWNLOADS = "android.intent.action.VIEW_DOWNLOADS";

  /// from: static public final java.lang.String COLUMN_BYTES_DOWNLOADED_SO_FAR
  /// Number of bytes download so far.
  static const COLUMN_BYTES_DOWNLOADED_SO_FAR = "bytes_so_far";

  /// from: static public final java.lang.String COLUMN_DESCRIPTION
  /// The client-supplied description of this download.  This will be displayed in system
  /// notifications.  Defaults to the empty string.
  static const COLUMN_DESCRIPTION = "description";

  /// from: static public final java.lang.String COLUMN_ID
  /// An identifier for a particular download, unique across the system.  Clients use this ID to
  /// make subsequent calls related to the download.
  static const COLUMN_ID = "_id";

  /// from: static public final java.lang.String COLUMN_LAST_MODIFIED_TIMESTAMP
  /// Timestamp when the download was last modified, in System\#currentTimeMillis System.currentTimeMillis() (wall clock time in UTC).
  static const COLUMN_LAST_MODIFIED_TIMESTAMP = "last_modified_timestamp";

  /// from: static public final java.lang.String COLUMN_LOCAL_FILENAME
  /// Path to the downloaded file on disk.
  ///
  /// Note that apps may not have filesystem permissions to directly access
  /// this path. Instead of trying to open this path directly, apps should use
  /// ContentResolver\#openFileDescriptor(Uri, String) to gain access.
  ///@deprecated apps should transition to using
  ///             ContentResolver\#openFileDescriptor(Uri, String)
  ///             instead.
  static const COLUMN_LOCAL_FILENAME = "local_filename";

  /// from: static public final java.lang.String COLUMN_LOCAL_URI
  /// Uri where downloaded file will be stored.  If a destination is supplied by client, that URI
  /// will be used here.  Otherwise, the value will initially be null and will be filled in with a
  /// generated URI once the download has started.
  static const COLUMN_LOCAL_URI = "local_uri";

  /// from: static public final java.lang.String COLUMN_MEDIAPROVIDER_URI
  /// The URI to the corresponding entry in MediaProvider for this downloaded entry. It is
  /// used to delete the entries from MediaProvider database when it is deleted from the
  /// downloaded list.
  static const COLUMN_MEDIAPROVIDER_URI = "mediaprovider_uri";

  /// from: static public final java.lang.String COLUMN_MEDIA_TYPE
  /// Internet Media Type of the downloaded file.  If no value is provided upon creation, this will
  /// initially be null and will be filled in based on the server's response once the download has
  /// started.
  ///@see <a href="http://www.ietf.org/rfc/rfc1590.txt">RFC 1590, defining Media Types</a>
  static const COLUMN_MEDIA_TYPE = "media_type";

  /// from: static public final java.lang.String COLUMN_REASON
  /// Provides more detail on the status of the download.  Its meaning depends on the value of
  /// \#COLUMN_STATUS.
  ///
  /// When \#COLUMN_STATUS is \#STATUS_FAILED, this indicates the type of error that
  /// occurred.  If an HTTP error occurred, this will hold the HTTP status code as defined in RFC
  /// 2616.  Otherwise, it will hold one of the ERROR_* constants.
  ///
  /// When \#COLUMN_STATUS is \#STATUS_PAUSED, this indicates why the download is
  /// paused.  It will hold one of the PAUSED_* constants.
  ///
  /// If \#COLUMN_STATUS is neither \#STATUS_FAILED nor \#STATUS_PAUSED, this
  /// column's value is undefined.
  ///@see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html\#sec6.1.1">RFC 2616
  /// status codes</a>
  static const COLUMN_REASON = "reason";

  /// from: static public final java.lang.String COLUMN_STATUS
  /// Current status of the download, as one of the STATUS_* constants.
  static const COLUMN_STATUS = "status";

  /// from: static public final java.lang.String COLUMN_TITLE
  /// The client-supplied title for this download.  This will be displayed in system notifications.
  /// Defaults to the empty string.
  static const COLUMN_TITLE = "title";

  /// from: static public final java.lang.String COLUMN_TOTAL_SIZE_BYTES
  /// Total size of the download in bytes.  This will initially be -1 and will be filled in once
  /// the download starts.
  static const COLUMN_TOTAL_SIZE_BYTES = "total_size";

  /// from: static public final java.lang.String COLUMN_URI
  /// URI to be downloaded.
  static const COLUMN_URI = "uri";

  /// from: static public final int ERROR_CANNOT_RESUME
  /// Value of \#COLUMN_REASON when some possibly transient error occurred but we can't
  /// resume the download.
  static const ERROR_CANNOT_RESUME = 1008;

  /// from: static public final int ERROR_DEVICE_NOT_FOUND
  /// Value of \#COLUMN_REASON when no external storage device was found. Typically,
  /// this is because the SD card is not mounted.
  static const ERROR_DEVICE_NOT_FOUND = 1007;

  /// from: static public final int ERROR_FILE_ALREADY_EXISTS
  /// Value of \#COLUMN_REASON when the requested destination file already exists (the
  /// download manager will not overwrite an existing file).
  static const ERROR_FILE_ALREADY_EXISTS = 1009;

  /// from: static public final int ERROR_FILE_ERROR
  /// Value of \#COLUMN_REASON when a storage issue arises which doesn't fit under any
  /// other error code. Use the more specific \#ERROR_INSUFFICIENT_SPACE and
  /// \#ERROR_DEVICE_NOT_FOUND when appropriate.
  static const ERROR_FILE_ERROR = 1001;

  /// from: static public final int ERROR_HTTP_DATA_ERROR
  /// Value of \#COLUMN_REASON when an error receiving or processing data occurred at
  /// the HTTP level.
  static const ERROR_HTTP_DATA_ERROR = 1004;

  /// from: static public final int ERROR_INSUFFICIENT_SPACE
  /// Value of \#COLUMN_REASON when there was insufficient storage space. Typically,
  /// this is because the SD card is full.
  static const ERROR_INSUFFICIENT_SPACE = 1006;

  /// from: static public final int ERROR_TOO_MANY_REDIRECTS
  /// Value of \#COLUMN_REASON when there were too many redirects.
  static const ERROR_TOO_MANY_REDIRECTS = 1005;

  /// from: static public final int ERROR_UNHANDLED_HTTP_CODE
  /// Value of \#COLUMN_REASON when an HTTP code was received that download manager
  /// can't handle.
  static const ERROR_UNHANDLED_HTTP_CODE = 1002;

  /// from: static public final int ERROR_UNKNOWN
  /// Value of COLUMN_ERROR_CODE when the download has completed with an error that doesn't fit
  /// under any other error code.
  static const ERROR_UNKNOWN = 1000;

  /// from: static public final java.lang.String EXTRA_DOWNLOAD_ID
  /// Intent extra included with \#ACTION_DOWNLOAD_COMPLETE intents, indicating the ID (as a
  /// long) of the download that just completed.
  static const EXTRA_DOWNLOAD_ID = "extra_download_id";

  /// from: static public final java.lang.String EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS
  /// When clicks on multiple notifications are received, the following
  /// provides an array of download ids corresponding to the download notification that was
  /// clicked. It can be retrieved by the receiver of this
  /// Intent using android.content.Intent\#getLongArrayExtra(String).
  static const EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS =
      "extra_click_download_ids";

  /// from: static public final java.lang.String INTENT_EXTRAS_SORT_BY_SIZE
  /// Intent extra included with \#ACTION_VIEW_DOWNLOADS to start DownloadApp in
  /// sort-by-size mode.
  static const INTENT_EXTRAS_SORT_BY_SIZE =
      "android.app.DownloadManager.extra_sortBySize";

  /// from: static public final int PAUSED_QUEUED_FOR_WIFI
  /// Value of \#COLUMN_REASON when the download exceeds a size limit for downloads over
  /// the mobile network and the download manager is waiting for a Wi-Fi connection to proceed.
  static const PAUSED_QUEUED_FOR_WIFI = 3;

  /// from: static public final int PAUSED_UNKNOWN
  /// Value of \#COLUMN_REASON when the download is paused for some other reason.
  static const PAUSED_UNKNOWN = 4;

  /// from: static public final int PAUSED_WAITING_FOR_NETWORK
  /// Value of \#COLUMN_REASON when the download is waiting for network connectivity to
  /// proceed.
  static const PAUSED_WAITING_FOR_NETWORK = 2;

  /// from: static public final int PAUSED_WAITING_TO_RETRY
  /// Value of \#COLUMN_REASON when the download is paused because some network error
  /// occurred and the download manager is waiting before retrying the request.
  static const PAUSED_WAITING_TO_RETRY = 1;

  /// from: static public final int STATUS_FAILED
  /// Value of \#COLUMN_STATUS when the download has failed (and will not be retried).
  static const STATUS_FAILED = 16;

  /// from: static public final int STATUS_PAUSED
  /// Value of \#COLUMN_STATUS when the download is waiting to retry or resume.
  static const STATUS_PAUSED = 4;

  /// from: static public final int STATUS_PENDING
  /// Value of \#COLUMN_STATUS when the download is waiting to start.
  static const STATUS_PENDING = 1;

  /// from: static public final int STATUS_RUNNING
  /// Value of \#COLUMN_STATUS when the download is currently running.
  static const STATUS_RUNNING = 2;

  /// from: static public final int STATUS_SUCCESSFUL
  /// Value of \#COLUMN_STATUS when the download has successfully completed.
  static const STATUS_SUCCESSFUL = 8;

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_DownloadManager_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.content.Context context)
  /// @hide
  DownloadManager(content.Context context)
      : super.fromRef(_ctor(context.reference));

  static final _enqueue = jlookup<
              ffi.NativeFunction<
                  ffi.Int64 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_DownloadManager_enqueue")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public long enqueue(android.app.DownloadManager.Request request)
  /// Enqueue a new download.  The download will start automatically once the download manager is
  /// ready to execute it and connectivity is available.
  ///@param request the parameters specifying this download
  ///@return an ID for the download, unique across the system.  This ID is used to make future
  /// calls related to this download.
  int enqueue(DownloadManager_Request request) =>
      _enqueue(reference, request.reference);

  static final _remove = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_DownloadManager_remove")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int remove(long[] ids)
  /// Cancel downloads and remove them from the download manager.  Each download will be stopped if
  /// it was running, and it will no longer be accessible through the download manager.
  /// If there is a downloaded file, partial or complete, it is deleted.
  ///@param ids the IDs of the downloads to remove
  ///@return the number of downloads actually removed
  int remove(jni.JlObject ids) => _remove(reference, ids.reference);

  static final _query = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_DownloadManager_query")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.database.Cursor query(android.app.DownloadManager.Query query)
  /// Query the download manager about downloads that have been requested.
  ///@param query parameters specifying filters for this query
  ///@return a Cursor over the result set of downloads, with columns consisting of all the
  /// COLUMN_* constants.
  jni.JlObject query(DownloadManager_Query query_) =>
      jni.JlObject.fromRef(_query(reference, query_.reference));

  static final _openDownloadedFile = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_app_DownloadManager_openDownloadedFile")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.os.ParcelFileDescriptor openDownloadedFile(long id)
  /// Open a downloaded file for reading.  The download must have completed.
  ///@param id the ID of the download
  ///@return a read-only ParcelFileDescriptor
  ///@throws FileNotFoundException if the destination file does not already exist
  os.ParcelFileDescriptor openDownloadedFile(int id) =>
      os.ParcelFileDescriptor.fromRef(_openDownloadedFile(reference, id));

  static final _getUriForDownloadedFile = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "android_app_DownloadManager_getUriForDownloadedFile")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.net.Uri getUriForDownloadedFile(long id)
  /// Returns the Uri of the given downloaded file id, if the file is
  /// downloaded successfully. Otherwise, null is returned.
  ///@param id the id of the downloaded file.
  ///@return the Uri of the given downloaded file id, if download was
  ///         successful. null otherwise.
  jni.JlObject getUriForDownloadedFile(int id) =>
      jni.JlObject.fromRef(_getUriForDownloadedFile(reference, id));

  static final _getMimeTypeForDownloadedFile = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "android_app_DownloadManager_getMimeTypeForDownloadedFile")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getMimeTypeForDownloadedFile(long id)
  /// Returns the media type of the given downloaded file id, if the file was
  /// downloaded successfully. Otherwise, null is returned.
  ///@param id the id of the downloaded file.
  ///@return the media type of the given downloaded file id, if download was successful. null
  /// otherwise.
  jni.JlString getMimeTypeForDownloadedFile(int id) =>
      jni.JlString.fromRef(_getMimeTypeForDownloadedFile(reference, id));

  static final _getMaxBytesOverMobile = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_DownloadManager_getMaxBytesOverMobile")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.Long getMaxBytesOverMobile(android.content.Context context)
  /// Returns maximum size, in bytes, of downloads that may go over a mobile connection; or null if
  /// there's no limit
  ///@param context the Context to use for accessing the ContentResolver
  ///@return maximum size, in bytes, of downloads that may go over a mobile connection; or null if
  /// there's no limit
  static jni.JlObject getMaxBytesOverMobile(content.Context context) =>
      jni.JlObject.fromRef(_getMaxBytesOverMobile(context.reference));

  static final _getRecommendedMaxBytesOverMobile = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_DownloadManager_getRecommendedMaxBytesOverMobile")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.Long getRecommendedMaxBytesOverMobile(android.content.Context context)
  /// Returns recommended maximum size, in bytes, of downloads that may go over a mobile
  /// connection; or null if there's no recommended limit.  The user will have the option to bypass
  /// this limit.
  ///@param context the Context to use for accessing the ContentResolver
  ///@return recommended maximum size, in bytes, of downloads that may go over a mobile
  /// connection; or null if there's no recommended limit.
  static jni.JlObject getRecommendedMaxBytesOverMobile(
          content.Context context) =>
      jni.JlObject.fromRef(
          _getRecommendedMaxBytesOverMobile(context.reference));

  static final _addCompletedDownload = jlookup<
              ffi.NativeFunction<
                  ffi.Int64 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Uint8,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int64,
                      ffi.Uint8)>>(
          "android_app_DownloadManager_addCompletedDownload")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int)>();

  /// from: public long addCompletedDownload(java.lang.String title, java.lang.String description, boolean isMediaScannerScannable, java.lang.String mimeType, java.lang.String path, long length, boolean showNotification)
  /// Adds a file to the downloads database system, so it could appear in Downloads App
  /// (and thus become eligible for management by the Downloads App).
  ///
  /// It is helpful to make the file scannable by MediaScanner by setting the param
  /// isMediaScannerScannable to true. It makes the file visible in media managing
  /// applications such as Gallery App, which could be a useful purpose of using this API.
  ///@param title the title that would appear for this file in Downloads App.
  ///@param description the description that would appear for this file in Downloads App.
  ///@param isMediaScannerScannable true if the file is to be scanned by MediaScanner. Files
  /// scanned by MediaScanner appear in the applications used to view media (for example,
  /// Gallery app).
  ///@param mimeType mimetype of the file.
  ///@param path absolute pathname to the file. The file should be world-readable, so that it can
  /// be managed by the Downloads App and any other app that is used to read it (for example,
  /// Gallery app to display the file, if the file contents represent a video/image).
  ///@param length length of the downloaded file
  ///@param showNotification true if a notification is to be sent, false otherwise
  ///@return an ID for the download entry added to the downloads app, unique across the system
  /// This ID is used to make future calls related to this download.
  int addCompletedDownload(
          jni.JlString title,
          jni.JlString description,
          bool isMediaScannerScannable,
          jni.JlString mimeType,
          jni.JlString path,
          int length,
          bool showNotification) =>
      _addCompletedDownload(
          reference,
          title.reference,
          description.reference,
          isMediaScannerScannable ? 1 : 0,
          mimeType.reference,
          path.reference,
          length,
          showNotification ? 1 : 0);

  static final _addCompletedDownload_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Int64 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Uint8,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int64,
                      ffi.Uint8,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_DownloadManager_addCompletedDownload_1")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public long addCompletedDownload(java.lang.String title, java.lang.String description, boolean isMediaScannerScannable, java.lang.String mimeType, java.lang.String path, long length, boolean showNotification, android.net.Uri uri, android.net.Uri referer)
  /// Adds a file to the downloads database system, so it could appear in Downloads App
  /// (and thus become eligible for management by the Downloads App).
  ///
  /// It is helpful to make the file scannable by MediaScanner by setting the param
  /// isMediaScannerScannable to true. It makes the file visible in media managing
  /// applications such as Gallery App, which could be a useful purpose of using this API.
  ///@param title the title that would appear for this file in Downloads App.
  ///@param description the description that would appear for this file in Downloads App.
  ///@param isMediaScannerScannable true if the file is to be scanned by MediaScanner. Files
  /// scanned by MediaScanner appear in the applications used to view media (for example,
  /// Gallery app).
  ///@param mimeType mimetype of the file.
  ///@param path absolute pathname to the file. The file should be world-readable, so that it can
  /// be managed by the Downloads App and any other app that is used to read it (for example,
  /// Gallery app to display the file, if the file contents represent a video/image).
  ///@param length length of the downloaded file
  ///@param showNotification true if a notification is to be sent, false otherwise
  ///@param uri the original HTTP URI of the download
  ///@param referer the HTTP Referer for the download
  ///@return an ID for the download entry added to the downloads app, unique across the system
  /// This ID is used to make future calls related to this download.
  int addCompletedDownload_1(
          jni.JlString title,
          jni.JlString description,
          bool isMediaScannerScannable,
          jni.JlString mimeType,
          jni.JlString path,
          int length,
          bool showNotification,
          jni.JlObject uri,
          jni.JlObject referer) =>
      _addCompletedDownload_1(
          reference,
          title.reference,
          description.reference,
          isMediaScannerScannable ? 1 : 0,
          mimeType.reference,
          path.reference,
          length,
          showNotification ? 1 : 0,
          uri.reference,
          referer.reference);
}

/// This class contains all the information necessary to request a new download. The URI is the
/// only required parameter.
///
/// Note that the default download destination is a shared volume where the system might delete
/// your file if it needs to reclaim space for system use. If this is a problem, use a location
/// on external storage (see \#setDestinationUri(Uri).
class DownloadManager_Request extends jni.JlObject {
  DownloadManager_Request.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final int NETWORK_MOBILE
  /// Bit flag for \#setAllowedNetworkTypes corresponding to
  /// ConnectivityManager\#TYPE_MOBILE.
  static const NETWORK_MOBILE = 1;

  /// from: static public final int NETWORK_WIFI
  /// Bit flag for \#setAllowedNetworkTypes corresponding to
  /// ConnectivityManager\#TYPE_WIFI.
  static const NETWORK_WIFI = 2;

  /// from: static public final int VISIBILITY_HIDDEN
  /// This download doesn't show in the UI or in the notifications.
  static const VISIBILITY_HIDDEN = 2;

  /// from: static public final int VISIBILITY_VISIBLE
  /// This download is visible but only shows in the notifications
  /// while it's in progress.
  static const VISIBILITY_VISIBLE = 0;

  /// from: static public final int VISIBILITY_VISIBLE_NOTIFY_COMPLETED
  /// This download is visible and shows in the notifications while
  /// in progress and after completion.
  static const VISIBILITY_VISIBLE_NOTIFY_COMPLETED = 1;

  /// from: static public final int VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION
  /// This download shows in the notifications after completion ONLY.
  /// It is usuable only with
  /// DownloadManager\#addCompletedDownload(String, String,
  /// boolean, String, String, long, boolean).
  static const VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION = 3;

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_DownloadManager__Request_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.net.Uri uri)
  /// @param uri the HTTP or HTTPS URI to download.
  DownloadManager_Request(jni.JlObject uri)
      : super.fromRef(_ctor(uri.reference));

  static final _setDestinationUri = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_DownloadManager__Request_setDestinationUri")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.DownloadManager.Request setDestinationUri(android.net.Uri uri)
  /// Set the local destination for the downloaded file. Must be a file URI to a path on
  /// external storage, and the calling application must have the WRITE_EXTERNAL_STORAGE
  /// permission.
  ///
  /// The downloaded file is not scanned by MediaScanner.
  /// But it can be made scannable by calling \#allowScanningByMediaScanner().
  ///
  /// By default, downloads are saved to a generated filename in the shared download cache and
  /// may be deleted by the system at any time to reclaim space.
  ///@return this object
  DownloadManager_Request setDestinationUri(jni.JlObject uri) =>
      DownloadManager_Request.fromRef(
          _setDestinationUri(reference, uri.reference));

  static final _setDestinationInExternalFilesDir = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_DownloadManager__Request_setDestinationInExternalFilesDir")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.DownloadManager.Request setDestinationInExternalFilesDir(android.content.Context context, java.lang.String dirType, java.lang.String subPath)
  /// Set the local destination for the downloaded file to a path within
  /// the application's external files directory (as returned by
  /// Context\#getExternalFilesDir(String).
  ///
  /// The downloaded file is not scanned by MediaScanner. But it can be
  /// made scannable by calling \#allowScanningByMediaScanner().
  ///@param context the Context to use in determining the external
  ///            files directory
  ///@param dirType the directory type to pass to
  ///            Context\#getExternalFilesDir(String)
  ///@param subPath the path within the external directory, including the
  ///            destination filename
  ///@return this object
  ///@throws IllegalStateException If the external storage directory
  ///             cannot be found or created.
  DownloadManager_Request setDestinationInExternalFilesDir(
          content.Context context,
          jni.JlString dirType,
          jni.JlString subPath) =>
      DownloadManager_Request.fromRef(_setDestinationInExternalFilesDir(
          reference, context.reference, dirType.reference, subPath.reference));

  static final _setDestinationInExternalPublicDir = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_DownloadManager__Request_setDestinationInExternalPublicDir")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.DownloadManager.Request setDestinationInExternalPublicDir(java.lang.String dirType, java.lang.String subPath)
  /// Set the local destination for the downloaded file to a path within
  /// the public external storage directory (as returned by
  /// Environment\#getExternalStoragePublicDirectory(String)).
  ///
  /// The downloaded file is not scanned by MediaScanner. But it can be
  /// made scannable by calling \#allowScanningByMediaScanner().
  ///@param dirType the directory type to pass to Environment\#getExternalStoragePublicDirectory(String)
  ///@param subPath the path within the external directory, including the
  ///            destination filename
  ///@return this object
  ///@throws IllegalStateException If the external storage directory
  ///             cannot be found or created.
  DownloadManager_Request setDestinationInExternalPublicDir(
          jni.JlString dirType, jni.JlString subPath) =>
      DownloadManager_Request.fromRef(_setDestinationInExternalPublicDir(
          reference, dirType.reference, subPath.reference));

  static final _allowScanningByMediaScanner = jlookup<
              ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_DownloadManager__Request_allowScanningByMediaScanner")
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void allowScanningByMediaScanner()
  /// If the file to be downloaded is to be scanned by MediaScanner, this method
  /// should be called before DownloadManager\#enqueue(Request) is called.
  void allowScanningByMediaScanner() => _allowScanningByMediaScanner(reference);

  static final _addRequestHeader = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_DownloadManager__Request_addRequestHeader")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.DownloadManager.Request addRequestHeader(java.lang.String header, java.lang.String value)
  /// Add an HTTP header to be included with the download request.  The header will be added to
  /// the end of the list.
  ///@param header HTTP header name
  ///@param value header value
  ///@return this object
  ///@see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html\#sec4.2">HTTP/1.1
  ///      Message Headers</a>
  DownloadManager_Request addRequestHeader(
          jni.JlString header, jni.JlString value) =>
      DownloadManager_Request.fromRef(
          _addRequestHeader(reference, header.reference, value.reference));

  static final _setTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_DownloadManager__Request_setTitle")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.DownloadManager.Request setTitle(java.lang.CharSequence title)
  /// Set the title of this download, to be displayed in notifications (if enabled).  If no
  /// title is given, a default one will be assigned based on the download filename, once the
  /// download starts.
  ///@return this object
  DownloadManager_Request setTitle(jni.JlObject title) =>
      DownloadManager_Request.fromRef(_setTitle(reference, title.reference));

  static final _setDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_DownloadManager__Request_setDescription")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.DownloadManager.Request setDescription(java.lang.CharSequence description)
  /// Set a description of this download, to be displayed in notifications (if enabled)
  ///@return this object
  DownloadManager_Request setDescription(jni.JlObject description) =>
      DownloadManager_Request.fromRef(
          _setDescription(reference, description.reference));

  static final _setMimeType = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_DownloadManager__Request_setMimeType")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.DownloadManager.Request setMimeType(java.lang.String mimeType)
  /// Set the MIME content type of this download.  This will override the content type declared
  /// in the server's response.
  ///@see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html\#sec3.7">HTTP/1.1
  ///      Media Types</a>
  ///@return this object
  DownloadManager_Request setMimeType(jni.JlString mimeType) =>
      DownloadManager_Request.fromRef(
          _setMimeType(reference, mimeType.reference));

  static final _setShowRunningNotification = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_DownloadManager__Request_setShowRunningNotification")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.DownloadManager.Request setShowRunningNotification(boolean show)
  /// Control whether a system notification is posted by the download manager while this
  /// download is running. If enabled, the download manager posts notifications about downloads
  /// through the system android.app.NotificationManager. By default, a notification is
  /// shown.
  ///
  /// If set to false, this requires the permission
  /// android.permission.DOWNLOAD_WITHOUT_NOTIFICATION.
  ///@param show whether the download manager should show a notification for this download.
  ///@return this object
  ///@deprecated use \#setNotificationVisibility(int)
  DownloadManager_Request setShowRunningNotification(bool show_) =>
      DownloadManager_Request.fromRef(
          _setShowRunningNotification(reference, show_ ? 1 : 0));

  static final _setNotificationVisibility = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_DownloadManager__Request_setNotificationVisibility")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.DownloadManager.Request setNotificationVisibility(int visibility)
  /// Control whether a system notification is posted by the download manager while this
  /// download is running or when it is completed.
  /// If enabled, the download manager posts notifications about downloads
  /// through the system android.app.NotificationManager.
  /// By default, a notification is shown only when the download is in progress.
  ///
  /// It can take the following values: \#VISIBILITY_HIDDEN,
  /// \#VISIBILITY_VISIBLE,
  /// \#VISIBILITY_VISIBLE_NOTIFY_COMPLETED.
  ///
  /// If set to \#VISIBILITY_HIDDEN, this requires the permission
  /// android.permission.DOWNLOAD_WITHOUT_NOTIFICATION.
  ///@param visibility the visibility setting value
  ///@return this object
  DownloadManager_Request setNotificationVisibility(int visibility) =>
      DownloadManager_Request.fromRef(
          _setNotificationVisibility(reference, visibility));

  static final _setAllowedNetworkTypes = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_DownloadManager__Request_setAllowedNetworkTypes")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.DownloadManager.Request setAllowedNetworkTypes(int flags)
  /// Restrict the types of networks over which this download may proceed.
  /// By default, all network types are allowed. Consider using
  /// \#setAllowedOverMetered(boolean) instead, since it's more
  /// flexible.
  ///
  /// As of android.os.Build.VERSION_CODES\#N, setting only the
  /// \#NETWORK_WIFI flag here is equivalent to calling
  /// \#setAllowedOverMetered(boolean) with {@code false}.
  ///@param flags any combination of the NETWORK_* bit flags.
  ///@return this object
  DownloadManager_Request setAllowedNetworkTypes(int flags) =>
      DownloadManager_Request.fromRef(
          _setAllowedNetworkTypes(reference, flags));

  static final _setAllowedOverRoaming = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_DownloadManager__Request_setAllowedOverRoaming")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.DownloadManager.Request setAllowedOverRoaming(boolean allowed)
  /// Set whether this download may proceed over a roaming connection.  By default, roaming is
  /// allowed.
  ///@param allowed whether to allow a roaming connection to be used
  ///@return this object
  DownloadManager_Request setAllowedOverRoaming(bool allowed) =>
      DownloadManager_Request.fromRef(
          _setAllowedOverRoaming(reference, allowed ? 1 : 0));

  static final _setAllowedOverMetered = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_DownloadManager__Request_setAllowedOverMetered")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.DownloadManager.Request setAllowedOverMetered(boolean allow)
  /// Set whether this download may proceed over a metered network
  /// connection. By default, metered networks are allowed.
  ///@see ConnectivityManager\#isActiveNetworkMetered()
  DownloadManager_Request setAllowedOverMetered(bool allow) =>
      DownloadManager_Request.fromRef(
          _setAllowedOverMetered(reference, allow ? 1 : 0));

  static final _setRequiresCharging = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_DownloadManager__Request_setRequiresCharging")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.DownloadManager.Request setRequiresCharging(boolean requiresCharging)
  /// Specify that to run this download, the device needs to be plugged in.
  /// This defaults to false.
  ///@param requiresCharging Whether or not the device is plugged in.
  ///@see android.app.job.JobInfo.Builder\#setRequiresCharging(boolean)
  DownloadManager_Request setRequiresCharging(bool requiresCharging) =>
      DownloadManager_Request.fromRef(
          _setRequiresCharging(reference, requiresCharging ? 1 : 0));

  static final _setRequiresDeviceIdle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_DownloadManager__Request_setRequiresDeviceIdle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.DownloadManager.Request setRequiresDeviceIdle(boolean requiresDeviceIdle)
  /// Specify that to run, the download needs the device to be in idle
  /// mode. This defaults to false.
  ///
  /// Idle mode is a loose definition provided by the system, which means
  /// that the device is not in use, and has not been in use for some time.
  ///@param requiresDeviceIdle Whether or not the device need be within an
  ///            idle maintenance window.
  ///@see android.app.job.JobInfo.Builder\#setRequiresDeviceIdle(boolean)
  DownloadManager_Request setRequiresDeviceIdle(bool requiresDeviceIdle) =>
      DownloadManager_Request.fromRef(
          _setRequiresDeviceIdle(reference, requiresDeviceIdle ? 1 : 0));

  static final _setVisibleInDownloadsUi = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_DownloadManager__Request_setVisibleInDownloadsUi")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.DownloadManager.Request setVisibleInDownloadsUi(boolean isVisible)
  /// Set whether this download should be displayed in the system's Downloads UI. True by
  /// default.
  ///@param isVisible whether to display this download in the Downloads UI
  ///@return this object
  DownloadManager_Request setVisibleInDownloadsUi(bool isVisible) =>
      DownloadManager_Request.fromRef(
          _setVisibleInDownloadsUi(reference, isVisible ? 1 : 0));
}

/// This class may be used to filter download manager queries.
class DownloadManager_Query extends jni.JlObject {
  DownloadManager_Query.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_DownloadManager__Query_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  DownloadManager_Query() : super.fromRef(_ctor());

  static final _setFilterById = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_DownloadManager__Query_setFilterById")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.DownloadManager.Query setFilterById(long[] ids)
  /// Include only the downloads with the given IDs.
  ///@return this object
  DownloadManager_Query setFilterById(jni.JlObject ids) =>
      DownloadManager_Query.fromRef(_setFilterById(reference, ids.reference));

  static final _setFilterByStatus = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_DownloadManager__Query_setFilterByStatus")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.DownloadManager.Query setFilterByStatus(int flags)
  /// Include only downloads with status matching any the given status flags.
  ///@param flags any combination of the STATUS_* bit flags
  ///@return this object
  DownloadManager_Query setFilterByStatus(int flags) =>
      DownloadManager_Query.fromRef(_setFilterByStatus(reference, flags));
}

/// An activity that displays a list of items by binding to a data source such as
/// an array or Cursor, and exposes event handlers when the user selects an item.
///
/// ListActivity hosts a android.widget.ListView ListView object that can
/// be bound to different data sources, typically either an array or a Cursor
/// holding query results. Binding, screen layout, and row layout are discussed
/// in the following sections.
///
/// <strong>Screen Layout</strong>
///
///
///
/// ListActivity has a default layout that consists of a single, full-screen list
/// in the center of the screen. However, if you desire, you can customize the
/// screen layout by setting your own view layout with setContentView() in
/// onCreate(). To do this, your own view MUST contain a ListView object with the
/// id "@android:id/list" (or android.R.id\#list if it's in code)
///
/// Optionally, your custom view can contain another view object of any type to
/// display when the list view is empty. This "empty list" notifier must have an
/// id "android:id/empty". Note that when an empty view is present, the list view
/// will be hidden when there is no data to display.
///
/// The following code demonstrates an (ugly) custom screen layout. It has a list
/// with a green background, and an alternate red "no data" message.
///
///
///
/// <pre>
/// &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
/// &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
///         android:orientation=&quot;vertical&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;match_parent&quot;
///         android:paddingLeft=&quot;8dp&quot;
///         android:paddingRight=&quot;8dp&quot;&gt;
///
///     &lt;ListView android:id=&quot;@android:id/list&quot;
///               android:layout_width=&quot;match_parent&quot;
///               android:layout_height=&quot;match_parent&quot;
///               android:background=&quot;\#00FF00&quot;
///               android:layout_weight=&quot;1&quot;
///               android:drawSelectorOnTop=&quot;false&quot;/&gt;
///
///     &lt;TextView android:id=&quot;@android:id/empty&quot;
///               android:layout_width=&quot;match_parent&quot;
///               android:layout_height=&quot;match_parent&quot;
///               android:background=&quot;\#FF0000&quot;
///               android:text=&quot;No data&quot;/&gt;
/// &lt;/LinearLayout&gt;
/// </pre>
///
///
/// <strong>Row Layout</strong>
///
///
///
/// You can specify the layout of individual rows in the list. You do this by
/// specifying a layout resource in the ListAdapter object hosted by the activity
/// (the ListAdapter binds the ListView to the data; more on this later).
///
/// A ListAdapter constructor takes a parameter that specifies a layout resource
/// for each row. It also has two additional parameters that let you specify
/// which data field to associate with which object in the row layout resource.
/// These two parameters are typically parallel arrays.
///
///
///
/// Android provides some standard row layout resources. These are in the
/// android.R.layout class, and have names such as simple_list_item_1,
/// simple_list_item_2, and two_line_list_item. The following layout XML is the
/// source for the resource two_line_list_item, which displays two data
/// fields,one above the other, for each list row.
///
///
///
/// <pre>
/// &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
/// &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
///     android:layout_width=&quot;match_parent&quot;
///     android:layout_height=&quot;wrap_content&quot;
///     android:orientation=&quot;vertical&quot;&gt;
///
///     &lt;TextView android:id=&quot;@+id/text1&quot;
///         android:textSize=&quot;16sp&quot;
///         android:textStyle=&quot;bold&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;wrap_content&quot;/&gt;
///
///     &lt;TextView android:id=&quot;@+id/text2&quot;
///         android:textSize=&quot;16sp&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;wrap_content&quot;/&gt;
/// &lt;/LinearLayout&gt;
/// </pre>
///
///
/// You must identify the data bound to each TextView object in this layout. The
/// syntax for this is discussed in the next section.
///
///
///
/// <strong>Binding to Data</strong>
///
///
///
/// You bind the ListActivity's ListView object to data using a class that
/// implements the android.widget.ListAdapter ListAdapter interface.
/// Android provides two standard list adapters:
/// android.widget.SimpleAdapter SimpleAdapter for static data (Maps),
/// and android.widget.SimpleCursorAdapter SimpleCursorAdapter for Cursor
/// query results.
///
///
///
/// The following code from a custom ListActivity demonstrates querying the
/// Contacts provider for all contacts, then binding the Name and Company fields
/// to a two line row layout in the activity's ListView.
///
///
///
/// <pre>
/// public class MyListAdapter extends ListActivity {
///
///     &\#064;Override
///     protected void onCreate(Bundle savedInstanceState){
///         super.onCreate(savedInstanceState);
///
///         // We'll define a custom screen layout here (the one shown above), but
///         // typically, you could just use the standard ListActivity layout.
///         setContentView(R.layout.custom_list_activity_view);
///
///         // Query for all people contacts using the android.provider.Contacts.People convenience class.
///         // Put a managed wrapper around the retrieved cursor so we don't have to worry about
///         // requerying or closing it as the activity changes state.
///         mCursor = this.getContentResolver().query(People.CONTENT_URI, null, null, null, null);
///         startManagingCursor(mCursor);
///
///         // Now create a new list adapter bound to the cursor.
///         // SimpleListAdapter is designed for binding to a Cursor.
///         ListAdapter adapter = new SimpleCursorAdapter(
///                 this, // Context.
///                 android.R.layout.two_line_list_item,  // Specify the row template to use (here, two columns bound to the two retrieved cursor
/// rows).
///                 mCursor,                                              // Pass in the cursor to bind to.
///                 new String[] {People.NAME, People.COMPANY},           // Array of cursor columns to bind to.
///                 new int[] {android.R.id.text1, android.R.id.text2});  // Parallel array of which template objects to bind to those columns.
///
///         // Bind to our new adapter.
///         setListAdapter(adapter);
///     }
/// }
/// </pre>
///@see \#setListAdapter
///@see android.widget.ListView
class ListActivity extends Activity {
  ListActivity.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ListActivity_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ListActivity() : super.fromRef(_ctor());

  static final _onListItemClick = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int64)>>("android_app_ListActivity_onListItemClick")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: protected void onListItemClick(android.widget.ListView l, android.view.View v, int position, long id)
  /// This method will be called when an item in the list is selected.
  /// Subclasses should override. Subclasses can call
  /// getListView().getItemAtPosition(position) if they need to access the
  /// data associated with the selected item.
  ///@param l The ListView where the click happened
  ///@param v The view that was clicked within the ListView
  ///@param position The position of the view in the list
  ///@param id The row id of the item that was clicked
  void onListItemClick(jni.JlObject l, jni.JlObject v, int position, int id) =>
      _onListItemClick(reference, l.reference, v.reference, position, id);

  static final _onRestoreInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ListActivity_onRestoreInstanceState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onRestoreInstanceState(android.os.Bundle state)
  /// Ensures the list view has been created before Activity restores all
  /// of the view states.
  ///@see Activity\#onRestoreInstanceState(Bundle)
  void onRestoreInstanceState(os.Bundle state) =>
      _onRestoreInstanceState(reference, state.reference);

  static final _onDestroy =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ListActivity_onDestroy")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onDestroy()
  /// @see Activity\#onDestroy()
  void onDestroy() => _onDestroy(reference);

  static final _onContentChanged =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ListActivity_onContentChanged")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onContentChanged()
  /// Updates the screen state (current list and other views) when the
  /// content changes.
  ///@see Activity\#onContentChanged()
  void onContentChanged() => _onContentChanged(reference);

  static final _setListAdapter = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ListActivity_setListAdapter")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setListAdapter(android.widget.ListAdapter adapter)
  /// Provide the cursor for the list view.
  void setListAdapter(jni.JlObject adapter) =>
      _setListAdapter(reference, adapter.reference);

  static final _setSelection = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ListActivity_setSelection")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setSelection(int position)
  /// Set the currently selected list item to the specified
  /// position with the adapter's data
  ///@param position
  void setSelection(int position) => _setSelection(reference, position);

  static final _getSelectedItemPosition =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ListActivity_getSelectedItemPosition")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getSelectedItemPosition()
  /// Get the position of the currently selected list item.
  int getSelectedItemPosition() => _getSelectedItemPosition(reference);

  static final _getSelectedItemId =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ListActivity_getSelectedItemId")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getSelectedItemId()
  /// Get the cursor row ID of the currently selected list item.
  int getSelectedItemId() => _getSelectedItemId(reference);

  static final _getListView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ListActivity_getListView")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.ListView getListView()
  /// Get the activity's list view widget.
  jni.JlObject getListView() => jni.JlObject.fromRef(_getListView(reference));

  static final _getListAdapter = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ListActivity_getListAdapter")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.ListAdapter getListAdapter()
  /// Get the ListAdapter associated with this activity's ListView.
  jni.JlObject getListAdapter() =>
      jni.JlObject.fromRef(_getListAdapter(reference));
}

/// Callbacks to a Fragment's container.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.FragmentContainer.
class FragmentContainer extends jni.JlObject {
  FragmentContainer.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_FragmentContainer_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  FragmentContainer() : super.fromRef(_ctor());

  static final _onHasView =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentContainer_onHasView")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean onHasView()
  /// Return {@code true} if the container holds any view.
  bool onHasView() => _onHasView(reference) != 0;
}

/// Provides an immutable reference to an entity that appears repeatedly on different surfaces of the
/// platform. For example, this could represent the sender of a message.
class Person extends jni.JlObject {
  Person.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.Person> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_Person_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Person_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Parcel in)
  Person(os.Parcel in_) : super.fromRef(_ctor(in_.reference));

  static final _toBuilder = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Person_toBuilder")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Person.Builder toBuilder()
  /// Creates and returns a new Builder initialized with this Person's data.
  Person_Builder toBuilder() => Person_Builder.fromRef(_toBuilder(reference));

  static final _getUri = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Person_getUri")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getUri()
  /// @return the uri provided for this person or {@code null} if no Uri was provided.
  jni.JlString getUri() => jni.JlString.fromRef(_getUri(reference));

  static final _getName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Person_getName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getName()
  /// @return the name provided for this person or {@code null} if no name was provided.
  jni.JlObject getName() => jni.JlObject.fromRef(_getName(reference));

  static final _getIcon = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Person_getIcon")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Icon getIcon()
  /// @return the icon provided for this person or {@code null} if no icon was provided.
  jni.JlObject getIcon() => jni.JlObject.fromRef(_getIcon(reference));

  static final _getKey = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Person_getKey")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getKey()
  /// @return the key provided for this person or {@code null} if no key was provided.
  jni.JlString getKey() => jni.JlString.fromRef(_getKey(reference));

  static final _isBot =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Person_isBot")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isBot()
  /// @return whether this Person is a machine.
  bool isBot() => _isBot(reference) != 0;

  static final _isImportant =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Person_isImportant")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isImportant()
  /// @return whether this Person is important.
  bool isImportant() => _isImportant(reference) != 0;

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Person_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Person_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  /// @param flags Value is either <code>0</code> or a combination of android.os.Parcelable\#PARCELABLE_WRITE_RETURN_VALUE, and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);
}

/// Builder for the immutable Person class.
class Person_Builder extends jni.JlObject {
  Person_Builder.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Person__Builder_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Creates a new, empty Builder.
  Person_Builder() : super.fromRef(_ctor());

  static final _setName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Person__Builder_setName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Person.Builder setName(java.lang.CharSequence name)
  /// Give this person a name.
  ///@param name the name of this person.
  ///
  /// This value may be {@code null}.
  ///@return This value will never be {@code null}.
  Person_Builder setName(jni.JlObject name) =>
      Person_Builder.fromRef(_setName(reference, name.reference));

  static final _setIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Person__Builder_setIcon")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Person.Builder setIcon(android.graphics.drawable.Icon icon)
  /// Add an icon for this person.
  /// <br/>
  /// The system will prefer this icon over any images that are resolved from the URI.
  ///@param icon the icon of the person.
  ///
  /// This value may be {@code null}.
  ///@return This value will never be {@code null}.
  Person_Builder setIcon(jni.JlObject icon) =>
      Person_Builder.fromRef(_setIcon(reference, icon.reference));

  static final _setUri = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Person__Builder_setUri")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Person.Builder setUri(java.lang.String uri)
  /// Set a URI associated with this person.
  ///
  /// <P>
  /// The person should be specified by the {@code String} representation of a
  /// android.provider.ContactsContract.Contacts\#CONTENT_LOOKUP_URI.
  /// </P>
  ///
  /// <P>The system will also attempt to resolve {@code mailto:} and {@code tel:} schema
  /// URIs. The path part of these URIs must exist in the contacts database, in the
  /// appropriate column, or the reference will be discarded as invalid. Telephone schema
  /// URIs will be resolved by android.provider.ContactsContract.PhoneLookup.
  /// </P>
  ///@param uri a URI for the person.
  ///
  /// This value may be {@code null}.
  ///@return This value will never be {@code null}.
  Person_Builder setUri(jni.JlString uri) =>
      Person_Builder.fromRef(_setUri(reference, uri.reference));

  static final _setKey = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Person__Builder_setKey")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Person.Builder setKey(java.lang.String key)
  /// Add a key to this person in order to uniquely identify it.
  /// This is especially useful if the name doesn't uniquely identify this person or if the
  /// display name is a short handle of the actual name.
  ///
  /// <P>If no key is provided, the name serves as the key for the purpose of
  /// identification.</P>
  ///@param key the key that uniquely identifies this person.
  ///
  /// This value may be {@code null}.
  ///@return This value will never be {@code null}.
  Person_Builder setKey(jni.JlString key) =>
      Person_Builder.fromRef(_setKey(reference, key.reference));

  static final _setImportant = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Person__Builder_setImportant")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Person.Builder setImportant(boolean isImportant)
  /// Sets whether this is an important person. Use this method to denote users who frequently
  /// interact with the user of this device when \#setUri(String) isn't provided with
  /// android.provider.ContactsContract.Contacts\#CONTENT_LOOKUP_URI, and instead with
  /// the {@code mailto:} or {@code tel:} schemas.
  ///@param isImportant {@code true} if this is an important person, {@code false} otherwise.
  ///@return This value will never be {@code null}.
  Person_Builder setImportant(bool isImportant) =>
      Person_Builder.fromRef(_setImportant(reference, isImportant ? 1 : 0));

  static final _setBot = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Person__Builder_setBot")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Person.Builder setBot(boolean isBot)
  /// Sets whether this person is a machine rather than a human.
  ///@param isBot {@code true} if this person is a machine, {@code false} otherwise.
  ///@return This value will never be {@code null}.
  Person_Builder setBot(bool isBot) =>
      Person_Builder.fromRef(_setBot(reference, isBot ? 1 : 0));

  static final _build = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_Person__Builder_build")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Person build()
  /// Creates and returns the Person this builder represents.
  ///@return This value will never be {@code null}.
  Person build() => Person.fromRef(_build(reference));
}

/// Interface for an Activity to interact with the user through voice.  Use
/// android.app.Activity\#getVoiceInteractor() Activity.getVoiceInteractor
/// to retrieve the interface, if the activity is currently involved in a voice interaction.
///
/// The voice interactor revolves around submitting voice interaction requests to the
/// back-end voice interaction service that is working with the user.  These requests are
/// submitted with \#submitRequest, providing a new instance of a
/// Request subclass describing the type of operation to perform -- currently the
/// possible requests are ConfirmationRequest and CommandRequest.
///
/// Once a request is submitted, the voice system will process it and eventually deliver
/// the result to the request object.  The application can cancel a pending request at any
/// time.
///
/// The VoiceInteractor is integrated with Activity's state saving mechanism, so that
/// if an activity is being restarted with retained state, it will retain the current
/// VoiceInteractor and any outstanding requests.  Because of this, you should always use
/// Request\#getActivity() Request.getActivity to get back to the activity of a
/// request, rather than holding on to the activity instance yourself, either explicitly
/// or implicitly through a non-static inner class.
class VoiceInteractor extends jni.JlObject {
  VoiceInteractor.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_VoiceInteractor_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  VoiceInteractor() : super.fromRef(_ctor());

  static final _submitRequest = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor_submitRequest")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean submitRequest(android.app.VoiceInteractor.Request request)
  bool submitRequest(VoiceInteractor_Request request) =>
      _submitRequest(reference, request.reference) != 0;

  static final _submitRequest_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor_submitRequest_1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean submitRequest(android.app.VoiceInteractor.Request request, java.lang.String name)
  /// Submit a new Request to the voice interaction service.  The request must be
  /// one of the available subclasses -- ConfirmationRequest, PickOptionRequest,
  /// CompleteVoiceRequest, AbortVoiceRequest, or CommandRequest.
  ///@param request The desired request to submit.
  ///@param name An optional name for this request, or null. This can be used later with
  /// \#getActiveRequests and \#getActiveRequest to find the request.
  ///@return Returns true of the request was successfully submitted, else false.
  bool submitRequest_1(VoiceInteractor_Request request, jni.JlString name) =>
      _submitRequest_1(reference, request.reference, name.reference) != 0;

  static final _getActiveRequests = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor_getActiveRequests")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.VoiceInteractor.Request[] getActiveRequests()
  /// Return all currently active requests.
  jni.JlObject getActiveRequests() =>
      jni.JlObject.fromRef(_getActiveRequests(reference));

  static final _getActiveRequest = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor_getActiveRequest")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.VoiceInteractor.Request getActiveRequest(java.lang.String name)
  /// Return any currently active request that was submitted with the given name.
  ///@param name The name used to submit the request, as per
  /// \#submitRequest(android.app.VoiceInteractor.Request, String).
  ///@return Returns the active request with that name, or null if there was none.
  VoiceInteractor_Request getActiveRequest(jni.JlString name) =>
      VoiceInteractor_Request.fromRef(
          _getActiveRequest(reference, name.reference));

  static final _supportsCommands = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor_supportsCommands")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean[] supportsCommands(java.lang.String[] commands)
  /// Queries the supported commands available from the VoiceInteractionService.
  /// The command is a string that describes the generic operation to be performed.
  /// An example might be "org.example.commands.PICK_DATE" to ask the user to pick
  /// a date.  (Note: This is not an actual working example.)
  ///@param commands The array of commands to query for support.
  ///@return Array of booleans indicating whether each command is supported or not.
  jni.JlObject supportsCommands(jni.JlObject commands) =>
      jni.JlObject.fromRef(_supportsCommands(reference, commands.reference));
}

/// Base class for voice interaction requests that can be submitted to the interactor.
/// Do not instantiate this directly -- instead, use the appropriate subclass.
class VoiceInteractor_Request extends jni.JlObject {
  VoiceInteractor_Request.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_VoiceInteractor__Request_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  VoiceInteractor_Request() : super.fromRef(_ctor());

  static final _getName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__Request_getName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getName()
  /// Return the name this request was submitted through
  /// \#submitRequest(android.app.VoiceInteractor.Request, String).
  jni.JlString getName() => jni.JlString.fromRef(_getName(reference));

  static final _cancel =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_VoiceInteractor__Request_cancel")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void cancel()
  /// Cancel this active request.
  void cancel() => _cancel(reference);

  static final _getContext = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__Request_getContext")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context getContext()
  /// Return the current Context this request is associated with.  May change
  /// if the activity hosting it goes through a configuration change.
  content.Context getContext() =>
      content.Context.fromRef(_getContext(reference));

  static final _getActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__Request_getActivity")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity getActivity()
  /// Return the current Activity this request is associated with.  Will change
  /// if the activity is restarted such as through a configuration change.
  Activity getActivity() => Activity.fromRef(_getActivity(reference));

  static final _onCancel =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_VoiceInteractor__Request_onCancel")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onCancel()
  /// Report from voice interaction service: this operation has been canceled, typically
  /// as a completion of a previous call to \#cancel or when the user explicitly
  /// cancelled.
  void onCancel() => _onCancel(reference);

  static final _onAttached = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__Request_onAttached")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttached(android.app.Activity activity)
  /// The request is now attached to an activity, or being re-attached to a new activity
  /// after a configuration change.
  void onAttached(Activity activity) =>
      _onAttached(reference, activity.reference);

  static final _onDetached =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_VoiceInteractor__Request_onDetached")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDetached()
  /// The request is being detached from an activity.
  void onDetached() => _onDetached(reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__Request_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));
}

/// A set of voice prompts to use with the voice interaction system to confirm an action, select
/// an option, or do similar operations. Multiple voice prompts may be provided for variety. A
/// visual prompt must be provided, which might not match the spoken version. For example, the
/// confirmation "Are you sure you want to purchase this item?" might use a visual label like
/// "Purchase item".
class VoiceInteractor_Prompt extends jni.JlObject {
  VoiceInteractor_Prompt.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.VoiceInteractor.Prompt> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_VoiceInteractor__Prompt_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__Prompt_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.CharSequence[] voicePrompts, java.lang.CharSequence visualPrompt)
  /// Constructs a prompt set.
  ///@param voicePrompts An array of one or more voice prompts. Must not be empty or null.
  /// This value must never be {@code null}.
  ///@param visualPrompt A prompt to display on the screen. Must not be null.
  ///
  /// This value must never be {@code null}.
  VoiceInteractor_Prompt(jni.JlObject voicePrompts, jni.JlObject visualPrompt)
      : super.fromRef(_ctor(voicePrompts.reference, visualPrompt.reference));

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__Prompt_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.CharSequence prompt)
  /// Constructs a prompt set with single prompt used for all interactions. This is most useful
  /// in test apps. Non-trivial apps should prefer the detailed constructor.
  ///@param prompt This value must never be {@code null}.
  VoiceInteractor_Prompt.ctor_1(jni.JlObject prompt)
      : super.fromRef(_ctor_1(prompt.reference));

  static final _getVoicePromptAt = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_VoiceInteractor__Prompt_getVoicePromptAt")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.CharSequence getVoicePromptAt(int index)
  /// Returns a prompt to use for voice interactions.
  ///@return This value will never be {@code null}.
  jni.JlObject getVoicePromptAt(int index) =>
      jni.JlObject.fromRef(_getVoicePromptAt(reference, index));

  static final _countVoicePrompts =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_VoiceInteractor__Prompt_countVoicePrompts")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int countVoicePrompts()
  /// Returns the number of different voice prompts.
  int countVoicePrompts() => _countVoicePrompts(reference);

  static final _getVisualPrompt = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__Prompt_getVisualPrompt")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getVisualPrompt()
  /// Returns the prompt to use for visual display.
  ///@return This value will never be {@code null}.
  jni.JlObject getVisualPrompt() =>
      jni.JlObject.fromRef(_getVisualPrompt(reference));

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__Prompt_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_VoiceInteractor__Prompt_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_VoiceInteractor__Prompt_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);
}

/// Select a single option from multiple potential options with the user via the trusted system
/// VoiceInteractionService. Typically, the application would present this visually as
/// a list view to allow selecting the option by touch.
/// The result of the confirmation will be returned through an asynchronous call to
/// either \#onPickOptionResult or \#onCancel() - these methods should
/// be overridden to define the application specific behavior.
class VoiceInteractor_PickOptionRequest extends VoiceInteractor_Request {
  VoiceInteractor_PickOptionRequest.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__PickOptionRequest_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.VoiceInteractor.Prompt prompt, android.app.VoiceInteractor.PickOptionRequest.Option[] options, android.os.Bundle extras)
  /// Create a new pick option request.
  ///@param prompt Optional question to be asked of the user when the options are
  ///     presented or null if nothing should be asked.
  /// This value may be {@code null}.
  ///@param options The set of Options the user is selecting from.
  ///@param extras Additional optional information or null.
  ///
  /// This value may be {@code null}.
  VoiceInteractor_PickOptionRequest(
      VoiceInteractor_Prompt prompt, jni.JlObject options, os.Bundle extras)
      : super.fromRef(
            _ctor(prompt.reference, options.reference, extras.reference));

  static final _onPickOptionResult = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__PickOptionRequest_onPickOptionResult")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onPickOptionResult(boolean finished, android.app.VoiceInteractor.PickOptionRequest.Option[] selections, android.os.Bundle result)
  /// Called when a single option is confirmed or narrowed to one of several options. Override
  /// this method to define the behavior when the user selects an option or narrows down the
  /// set of options.
  ///@param finished True if the voice interaction has finished making a selection, in
  ///     which case {@code selections} contains the final result.  If false, this request is
  ///     still active and you will continue to get calls on it.
  ///@param selections Either a single Option or one of several Options the
  ///     user has narrowed the choices down to.
  ///@param result Additional optional information.
  void onPickOptionResult(
          bool finished, jni.JlObject selections, os.Bundle result) =>
      _onPickOptionResult(
          reference, finished ? 1 : 0, selections.reference, result.reference);
}

/// Represents a single option that the user may select using their voice. The
/// \#getIndex() method should be used as a unique ID to identify the option
/// when it is returned from the voice interactor.
class VoiceInteractor_PickOptionRequest_Option extends jni.JlObject {
  VoiceInteractor_PickOptionRequest_Option.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.VoiceInteractor.PickOptionRequest.Option> CREATOR
  static final _getCREATOR = jlookup<
              ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
          "get_android_app_VoiceInteractor__PickOptionRequest__Option_CREATOR")
      .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_VoiceInteractor__PickOptionRequest__Option_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.CharSequence label, int index)
  /// Creates an option that a user can select with their voice by matching the label
  /// or one of several synonyms.
  ///@param label The label that will both be matched against what the user speaks
  ///     and displayed visually.
  ///@param index The location of this option within the overall set of options.
  ///     Can be used to help identify the option when it is returned from the
  ///     voice interactor.
  VoiceInteractor_PickOptionRequest_Option(jni.JlObject label, int index)
      : super.fromRef(_ctor(label.reference, index));

  static final _addSynonym = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__PickOptionRequest__Option_addSynonym")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.VoiceInteractor.PickOptionRequest.Option addSynonym(java.lang.CharSequence synonym)
  /// Add a synonym term to the option to indicate an alternative way the content
  /// may be matched.
  ///@param synonym The synonym that will be matched against what the user speaks,
  ///     but not displayed.
  VoiceInteractor_PickOptionRequest_Option addSynonym(jni.JlObject synonym) =>
      VoiceInteractor_PickOptionRequest_Option.fromRef(
          _addSynonym(reference, synonym.reference));

  static final _getLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__PickOptionRequest__Option_getLabel")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getLabel()
  jni.JlObject getLabel() => jni.JlObject.fromRef(_getLabel(reference));

  static final _getIndex =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_VoiceInteractor__PickOptionRequest__Option_getIndex")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getIndex()
  /// Return the index that was supplied in the constructor.
  /// If the option was constructed without an index, -1 is returned.
  int getIndex() => _getIndex(reference);

  static final _countSynonyms = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__PickOptionRequest__Option_countSynonyms")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int countSynonyms()
  int countSynonyms() => _countSynonyms(reference);

  static final _getSynonymAt = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_VoiceInteractor__PickOptionRequest__Option_getSynonymAt")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.CharSequence getSynonymAt(int index)
  jni.JlObject getSynonymAt(int index) =>
      jni.JlObject.fromRef(_getSynonymAt(reference, index));

  static final _setExtras = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__PickOptionRequest__Option_setExtras")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExtras(android.os.Bundle extras)
  /// Set optional extra information associated with this option.  Note that this
  /// method takes ownership of the supplied extras Bundle.
  void setExtras(os.Bundle extras) => _setExtras(reference, extras.reference);

  static final _getExtras = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__PickOptionRequest__Option_getExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getExtras()
  /// Return any optional extras information associated with this option, or null
  /// if there is none.  Note that this method returns a reference to the actual
  /// extras Bundle in the option, so modifications to it will directly modify the
  /// extras in the option.
  os.Bundle getExtras() => os.Bundle.fromRef(_getExtras(reference));

  static final _describeContents = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__PickOptionRequest__Option_describeContents")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_VoiceInteractor__PickOptionRequest__Option_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);
}

/// Confirms an operation with the user via the trusted system
/// VoiceInteractionService.  This allows an Activity to complete an unsafe operation that
/// would require the user to touch the screen when voice interaction mode is not enabled.
/// The result of the confirmation will be returned through an asynchronous call to
/// either \#onConfirmationResult(boolean, android.os.Bundle) or
/// \#onCancel() - these methods should be overridden to define the application specific
///  behavior.
///
/// In some cases this may be a simple yes / no confirmation or the confirmation could
/// include context information about how the action will be completed
/// (e.g. booking a cab might include details about how long until the cab arrives)
/// so the user can give a confirmation.
class VoiceInteractor_ConfirmationRequest extends VoiceInteractor_Request {
  VoiceInteractor_ConfirmationRequest.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__ConfirmationRequest_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.VoiceInteractor.Prompt prompt, android.os.Bundle extras)
  /// Create a new confirmation request.
  ///@param prompt Optional confirmation to speak to the user or null if nothing
  ///     should be spoken.
  /// This value may be {@code null}.
  ///@param extras Additional optional information or null.
  ///
  /// This value may be {@code null}.
  VoiceInteractor_ConfirmationRequest(
      VoiceInteractor_Prompt prompt, os.Bundle extras)
      : super.fromRef(_ctor(prompt.reference, extras.reference));

  static final _onConfirmationResult = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__ConfirmationRequest_onConfirmationResult")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onConfirmationResult(boolean confirmed, android.os.Bundle result)
  /// Handle the confirmation result. Override this method to define
  /// the behavior when the user confirms or rejects the operation.
  ///@param confirmed Whether the user confirmed or rejected the operation.
  ///@param result Additional result information or null.
  void onConfirmationResult(bool confirmed, os.Bundle result) =>
      _onConfirmationResult(reference, confirmed ? 1 : 0, result.reference);
}

/// Reports that the current interaction was successfully completed with voice, so the
/// application can report the final status to the user. When the response comes back, the
/// voice system has handled the request and is ready to switch; at that point the
/// application can start a new non-voice activity or finish.  Be sure when starting the new
/// activity to use android.content.Intent\#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK to keep the new activity out of the current voice
/// interaction task.
class VoiceInteractor_CompleteVoiceRequest extends VoiceInteractor_Request {
  VoiceInteractor_CompleteVoiceRequest.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__CompleteVoiceRequest_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.VoiceInteractor.Prompt prompt, android.os.Bundle extras)
  /// Create a new completed voice interaction request.
  ///@param prompt Optional message to speak to the user about the completion status of
  ///     the task or null if nothing should be spoken.
  /// This value may be {@code null}.
  ///@param extras Additional optional information or null.
  ///
  /// This value may be {@code null}.
  VoiceInteractor_CompleteVoiceRequest(
      VoiceInteractor_Prompt prompt, os.Bundle extras)
      : super.fromRef(_ctor(prompt.reference, extras.reference));

  static final _onCompleteResult = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__CompleteVoiceRequest_onCompleteResult")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCompleteResult(android.os.Bundle result)
  void onCompleteResult(os.Bundle result) =>
      _onCompleteResult(reference, result.reference);
}

/// Execute a vendor-specific command using the trusted system VoiceInteractionService.
/// This allows an Activity to request additional information from the user needed to
/// complete an action (e.g. booking a table might have several possible times that the
/// user could select from or an app might need the user to agree to a terms of service).
/// The result of the confirmation will be returned through an asynchronous call to
/// either \#onCommandResult(boolean, android.os.Bundle) or
/// \#onCancel().
///
/// The command is a string that describes the generic operation to be performed.
/// The command will determine how the properties in extras are interpreted and the set of
/// available commands is expected to grow over time.  An example might be
/// "com.google.voice.commands.REQUEST_NUMBER_BAGS" to request the number of bags as part of
/// airline check-in.  (This is not an actual working example.)
class VoiceInteractor_CommandRequest extends VoiceInteractor_Request {
  VoiceInteractor_CommandRequest.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__CommandRequest_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String command, android.os.Bundle args)
  /// Create a new generic command request.
  ///@param command The desired command to perform.
  ///@param args Additional arguments to control execution of the command.
  VoiceInteractor_CommandRequest(jni.JlString command, os.Bundle args)
      : super.fromRef(_ctor(command.reference, args.reference));

  static final _onCommandResult = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__CommandRequest_onCommandResult")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCommandResult(boolean isCompleted, android.os.Bundle result)
  /// Results for CommandRequest can be returned in partial chunks.
  /// The isCompleted is set to true iff all results have been returned, indicating the
  /// CommandRequest has completed.
  void onCommandResult(bool isCompleted, os.Bundle result) =>
      _onCommandResult(reference, isCompleted ? 1 : 0, result.reference);
}

/// Reports that the current interaction can not be complete with voice, so the
/// application will need to switch to a traditional input UI.  Applications should
/// only use this when they need to completely bail out of the voice interaction
/// and switch to a traditional UI.  When the response comes back, the voice
/// system has handled the request and is ready to switch; at that point the application
/// can start a new non-voice activity.  Be sure when starting the new activity
/// to use android.content.Intent\#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK to keep the new activity out of the current voice
/// interaction task.
class VoiceInteractor_AbortVoiceRequest extends VoiceInteractor_Request {
  VoiceInteractor_AbortVoiceRequest.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__AbortVoiceRequest_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.VoiceInteractor.Prompt prompt, android.os.Bundle extras)
  /// Create a new voice abort request.
  ///@param prompt Optional message to speak to the user indicating why the task could
  ///     not be completed by voice or null if nothing should be spoken.
  /// This value may be {@code null}.
  ///@param extras Additional optional information or null.
  ///
  /// This value may be {@code null}.
  VoiceInteractor_AbortVoiceRequest(
      VoiceInteractor_Prompt prompt, os.Bundle extras)
      : super.fromRef(_ctor(prompt.reference, extras.reference));

  static final _onAbortResult = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_VoiceInteractor__AbortVoiceRequest_onAbortResult")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onAbortResult(android.os.Bundle result)
  void onAbortResult(os.Bundle result) =>
      _onAbortResult(reference, result.reference);
}

/// This class provides access to the system alarm services.  These allow you
/// to schedule your application to be run at some point in the future.  When
/// an alarm goes off, the Intent that had been registered for it
/// is broadcast by the system, automatically starting the target application
/// if it is not already running.  Registered alarms are retained while the
/// device is asleep (and can optionally wake the device up if they go off
/// during that time), but will be cleared if it is turned off and rebooted.
///
/// The Alarm Manager holds a CPU wake lock as long as the alarm receiver's
/// onReceive() method is executing. This guarantees that the phone will not sleep
/// until you have finished handling the broadcast. Once onReceive() returns, the
/// Alarm Manager releases this wake lock. This means that the phone will in some
/// cases sleep as soon as your onReceive() method completes.  If your alarm receiver
/// called android.content.Context\#startService Context.startService(), it
/// is possible that the phone will sleep before the requested service is launched.
/// To prevent this, your BroadcastReceiver and Service will need to implement a
/// separate wake lock policy to ensure that the phone continues running until the
/// service becomes available.
///
/// __Note: The Alarm Manager is intended for cases where you want to have
/// your application code run at a specific time, even if your application is
/// not currently running.  For normal timing operations (ticks, timeouts,
/// etc) it is easier and much more efficient to use
/// android.os.Handler.__
///
/// <p class="caution"><strong>Note:</strong> Beginning with API 19
/// (android.os.Build.VERSION_CODES\#KITKAT) alarm delivery is inexact:
/// the OS will shift alarms in order to minimize wakeups and battery use.  There are
/// new APIs to support applications which need strict delivery guarantees; see
/// \#setWindow(int, long, long, PendingIntent) and
/// \#setExact(int, long, PendingIntent).  Applications whose {@code targetSdkVersion}
/// is earlier than API 19 will continue to see the previous behavior in which all
/// alarms are delivered exactly when requested.
class AlarmManager extends jni.JlObject {
  AlarmManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_NEXT_ALARM_CLOCK_CHANGED
  /// Broadcast Action: Sent after the value returned by
  /// \#getNextAlarmClock() has changed.
  ///
  /// <p class="note">This is a protected intent that can only be sent by the system.
  /// It is only sent to registered receivers.
  ///
  static const ACTION_NEXT_ALARM_CLOCK_CHANGED =
      "android.app.action.NEXT_ALARM_CLOCK_CHANGED";

  /// from: static public final int ELAPSED_REALTIME
  /// Alarm time in android.os.SystemClock\#elapsedRealtime SystemClock.elapsedRealtime() (time since boot, including sleep).
  /// This alarm does not wake the device up; if it goes off while the device
  /// is asleep, it will not be delivered until the next time the device
  /// wakes up.
  static const ELAPSED_REALTIME = 3;

  /// from: static public final int ELAPSED_REALTIME_WAKEUP
  /// Alarm time in android.os.SystemClock\#elapsedRealtime SystemClock.elapsedRealtime() (time since boot, including sleep),
  /// which will wake up the device when it goes off.
  static const ELAPSED_REALTIME_WAKEUP = 2;

  /// from: static public final long INTERVAL_DAY
  /// Available inexact recurrence interval recognized by
  /// \#setInexactRepeating(int, long, long, PendingIntent)
  /// when running on Android prior to API 19.
  static const INTERVAL_DAY = 86400000;

  /// from: static public final long INTERVAL_FIFTEEN_MINUTES
  /// Available inexact recurrence interval recognized by
  /// \#setInexactRepeating(int, long, long, PendingIntent)
  /// when running on Android prior to API 19.
  static const INTERVAL_FIFTEEN_MINUTES = 900000;

  /// from: static public final long INTERVAL_HALF_DAY
  /// Available inexact recurrence interval recognized by
  /// \#setInexactRepeating(int, long, long, PendingIntent)
  /// when running on Android prior to API 19.
  static const INTERVAL_HALF_DAY = 43200000;

  /// from: static public final long INTERVAL_HALF_HOUR
  /// Available inexact recurrence interval recognized by
  /// \#setInexactRepeating(int, long, long, PendingIntent)
  /// when running on Android prior to API 19.
  static const INTERVAL_HALF_HOUR = 1800000;

  /// from: static public final long INTERVAL_HOUR
  /// Available inexact recurrence interval recognized by
  /// \#setInexactRepeating(int, long, long, PendingIntent)
  /// when running on Android prior to API 19.
  static const INTERVAL_HOUR = 3600000;

  /// from: static public final int RTC
  /// Alarm time in System\#currentTimeMillis System.currentTimeMillis()
  /// (wall clock time in UTC).  This alarm does not wake the
  /// device up; if it goes off while the device is asleep, it will not be
  /// delivered until the next time the device wakes up.
  static const RTC = 1;

  /// from: static public final int RTC_WAKEUP
  /// Alarm time in System\#currentTimeMillis System.currentTimeMillis()
  /// (wall clock time in UTC), which will wake up the device when
  /// it goes off.
  static const RTC_WAKEUP = 0;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_AlarmManager_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  AlarmManager() : super.fromRef(_ctor());

  static final _set_ = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("android_app_AlarmManager_set_")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void set(int type, long triggerAtMillis, android.app.PendingIntent operation)
  /// Schedule an alarm.  __Note: for timing operations (ticks, timeouts,
  /// etc) it is easier and much more efficient to use android.os.Handler.__
  /// If there is already an alarm scheduled for the same IntentSender, that previous
  /// alarm will first be canceled.
  ///
  /// If the stated trigger time is in the past, the alarm will be triggered
  /// immediately.  If there is already an alarm for this Intent
  /// scheduled (with the equality of two intents being defined by
  /// Intent\#filterEquals), then it will be removed and replaced by
  /// this one.
  ///
  ///
  /// The alarm is an Intent broadcast that goes to a broadcast receiver that
  /// you registered with android.content.Context\#registerReceiver
  /// or through the &lt;receiver&gt; tag in an AndroidManifest.xml file.
  ///
  ///
  /// Alarm intents are delivered with a data extra of type int called
  /// Intent\#EXTRA_ALARM_COUNT Intent.EXTRA_ALARM_COUNT that indicates
  /// how many past alarm events have been accumulated into this intent
  /// broadcast.  Recurring alarms that have gone undelivered because the
  /// phone was asleep may have a count greater than one when delivered.
  ///
  /// <div class="note">
  ///
  /// __Note:__ Beginning in API 19, the trigger time passed to this method
  /// is treated as inexact: the alarm will not be delivered before this time, but
  /// may be deferred and delivered some time later.  The OS will use
  /// this policy in order to "batch" alarms together across the entire system,
  /// minimizing the number of times the device needs to "wake up" and minimizing
  /// battery use.  In general, alarms scheduled in the near future will not
  /// be deferred as long as alarms scheduled far in the future.
  ///
  ///
  /// With the new batching policy, delivery ordering guarantees are not as
  /// strong as they were previously.  If the application sets multiple alarms,
  /// it is possible that these alarms' _actual_ delivery ordering may not match
  /// the order of their _requested_ delivery times.  If your application has
  /// strong ordering requirements there are other APIs that you can use to get
  /// the necessary behavior; see \#setWindow(int, long, long, PendingIntent)
  /// and \#setExact(int, long, PendingIntent).
  ///
  ///
  /// Applications whose {@code targetSdkVersion} is before API 19 will
  /// continue to get the previous alarm behavior: all of their scheduled alarms
  /// will be treated as exact.
  /// </div>
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should go
  /// off, using the appropriate clock (depending on the alarm type).
  ///@param operation Action to perform when the alarm goes off;
  /// typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see android.os.Handler
  ///@see \#setExact
  ///@see \#setRepeating
  ///@see \#setWindow
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  void set_(int type, int triggerAtMillis, PendingIntent operation) =>
      _set_(reference, type, triggerAtMillis, operation.reference);

  static final _set__1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_AlarmManager_set__1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void set(int type, long triggerAtMillis, java.lang.String tag, android.app.AlarmManager.OnAlarmListener listener, android.os.Handler targetHandler)
  /// Direct callback version of \#set(int, long, PendingIntent).  Rather than
  /// supplying a PendingIntent to be sent when the alarm time is reached, this variant
  /// supplies an OnAlarmListener instance that will be invoked at that time.
  ///
  /// The OnAlarmListener's OnAlarmListener\#onAlarm() onAlarm() method will be
  /// invoked via the specified target Handler, or on the application's main looper
  /// if {@code null} is passed as the {@code targetHandler} parameter.
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should go
  ///         off, using the appropriate clock (depending on the alarm type).
  ///@param tag string describing the alarm, used for logging and battery-use
  ///         attribution
  ///@param listener OnAlarmListener instance whose
  ///         OnAlarmListener\#onAlarm() onAlarm() method will be
  ///         called when the alarm time is reached.  A given OnAlarmListener instance can
  ///         only be the target of a single pending alarm, just as a given PendingIntent
  ///         can only be used with one alarm at a time.
  ///@param targetHandler Handler on which to execute the listener's onAlarm()
  ///         callback, or {@code null} to run that callback on the main looper.
  void set__1(int type, int triggerAtMillis, jni.JlString tag,
          AlarmManager_OnAlarmListener listener, os.Handler targetHandler) =>
      _set__1(reference, type, triggerAtMillis, tag.reference,
          listener.reference, targetHandler.reference);

  static final _setRepeating = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int64,
                      ffi.Int64, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlarmManager_setRepeating")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void setRepeating(int type, long triggerAtMillis, long intervalMillis, android.app.PendingIntent operation)
  /// Schedule a repeating alarm.  __Note: for timing operations (ticks,
  /// timeouts, etc) it is easier and much more efficient to use
  /// android.os.Handler.__  If there is already an alarm scheduled
  /// for the same IntentSender, it will first be canceled.
  ///
  /// Like \#set, except you can also supply a period at which
  /// the alarm will automatically repeat.  This alarm continues
  /// repeating until explicitly removed with \#cancel.  If the stated
  /// trigger time is in the past, the alarm will be triggered immediately, with an
  /// alarm count depending on how far in the past the trigger time is relative
  /// to the repeat interval.
  ///
  /// If an alarm is delayed (by system sleep, for example, for non
  /// _WAKEUP alarm types), a skipped repeat will be delivered as soon as
  /// possible.  After that, future alarms will be delivered according to the
  /// original schedule; they do not drift over time.  For example, if you have
  /// set a recurring alarm for the top of every hour but the phone was asleep
  /// from 7:45 until 8:45, an alarm will be sent as soon as the phone awakens,
  /// then the next alarm will be sent at 9:00.
  ///
  /// If your application wants to allow the delivery times to drift in
  /// order to guarantee that at least a certain time interval always elapses
  /// between alarms, then the approach to take is to use one-time alarms,
  /// scheduling the next one yourself when handling each alarm delivery.
  ///
  /// <p class="note">
  /// __Note:__ as of API 19, all repeating alarms are inexact.  If your
  /// application needs precise delivery times then it must use one-time
  /// exact alarms, rescheduling each time as described above. Legacy applications
  /// whose {@code targetSdkVersion} is earlier than API 19 will continue to have all
  /// of their alarms, including repeating alarms, treated as exact.
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should first
  /// go off, using the appropriate clock (depending on the alarm type).
  ///@param intervalMillis interval in milliseconds between subsequent repeats
  /// of the alarm.
  ///@param operation Action to perform when the alarm goes off;
  /// typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see android.os.Handler
  ///@see \#set
  ///@see \#setExact
  ///@see \#setWindow
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  void setRepeating(int type, int triggerAtMillis, int intervalMillis,
          PendingIntent operation) =>
      _setRepeating(reference, type, triggerAtMillis, intervalMillis,
          operation.reference);

  static final _setWindow = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("android_app_AlarmManager_setWindow")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void setWindow(int type, long windowStartMillis, long windowLengthMillis, android.app.PendingIntent operation)
  /// Schedule an alarm to be delivered within a given window of time.  This method
  /// is similar to \#set(int, long, PendingIntent), but allows the
  /// application to precisely control the degree to which its delivery might be
  /// adjusted by the OS. This method allows an application to take advantage of the
  /// battery optimizations that arise from delivery batching even when it has
  /// modest timeliness requirements for its alarms.
  ///
  ///
  /// This method can also be used to achieve strict ordering guarantees among
  /// multiple alarms by ensuring that the windows requested for each alarm do
  /// not intersect.
  ///
  ///
  /// When precise delivery is not required, applications should use the standard
  /// \#set(int, long, PendingIntent) method.  This will give the OS the most
  /// flexibility to minimize wakeups and battery use.  For alarms that must be delivered
  /// at precisely-specified times with no acceptable variation, applications can use
  /// \#setExact(int, long, PendingIntent).
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param windowStartMillis The earliest time, in milliseconds, that the alarm should
  ///        be delivered, expressed in the appropriate clock's units (depending on the alarm
  ///        type).
  ///@param windowLengthMillis The length of the requested delivery window,
  ///        in milliseconds.  The alarm will be delivered no later than this many
  ///        milliseconds after {@code windowStartMillis}.  Note that this parameter
  ///        is a <i>duration,</i> not the timestamp of the end of the window.
  ///@param operation Action to perform when the alarm goes off;
  ///        typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see \#set
  ///@see \#setExact
  ///@see \#setRepeating
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  void setWindow(int type, int windowStartMillis, int windowLengthMillis,
          PendingIntent operation) =>
      _setWindow(reference, type, windowStartMillis, windowLengthMillis,
          operation.reference);

  static final _setWindow_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int64,
                      ffi.Int64,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AlarmManager_setWindow_1")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setWindow(int type, long windowStartMillis, long windowLengthMillis, java.lang.String tag, android.app.AlarmManager.OnAlarmListener listener, android.os.Handler targetHandler)
  /// Direct callback version of \#setWindow(int, long, long, PendingIntent).  Rather
  /// than supplying a PendingIntent to be sent when the alarm time is reached, this variant
  /// supplies an OnAlarmListener instance that will be invoked at that time.
  ///
  /// The OnAlarmListener OnAlarmListener\#onAlarm() onAlarm() method will be
  /// invoked via the specified target Handler, or on the application's main looper
  /// if {@code null} is passed as the {@code targetHandler} parameter.
  ///@param type Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  void setWindow_1(
          int type,
          int windowStartMillis,
          int windowLengthMillis,
          jni.JlString tag,
          AlarmManager_OnAlarmListener listener,
          os.Handler targetHandler) =>
      _setWindow_1(reference, type, windowStartMillis, windowLengthMillis,
          tag.reference, listener.reference, targetHandler.reference);

  static final _setExact = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("android_app_AlarmManager_setExact")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExact(int type, long triggerAtMillis, android.app.PendingIntent operation)
  /// Schedule an alarm to be delivered precisely at the stated time.
  ///
  ///
  /// This method is like \#set(int, long, PendingIntent), but does not permit
  /// the OS to adjust the delivery time.  The alarm will be delivered as nearly as
  /// possible to the requested trigger time.
  ///
  ///
  /// __Note:__ only alarms for which there is a strong demand for exact-time
  /// delivery (such as an alarm clock ringing at the requested time) should be
  /// scheduled as exact.  Applications are strongly discouraged from using exact
  /// alarms unnecessarily as they reduce the OS's ability to minimize battery use.
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should go
  ///        off, using the appropriate clock (depending on the alarm type).
  ///@param operation Action to perform when the alarm goes off;
  ///        typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see \#set
  ///@see \#setRepeating
  ///@see \#setWindow
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  void setExact(int type, int triggerAtMillis, PendingIntent operation) =>
      _setExact(reference, type, triggerAtMillis, operation.reference);

  static final _setExact_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int64,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AlarmManager_setExact_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExact(int type, long triggerAtMillis, java.lang.String tag, android.app.AlarmManager.OnAlarmListener listener, android.os.Handler targetHandler)
  /// Direct callback version of \#setExact(int, long, PendingIntent).  Rather
  /// than supplying a PendingIntent to be sent when the alarm time is reached, this variant
  /// supplies an OnAlarmListener instance that will be invoked at that time.
  ///
  /// The OnAlarmListener's OnAlarmListener\#onAlarm() onAlarm() method will be
  /// invoked via the specified target Handler, or on the application's main looper
  /// if {@code null} is passed as the {@code targetHandler} parameter.
  ///@param type Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  void setExact_1(int type, int triggerAtMillis, jni.JlString tag,
          AlarmManager_OnAlarmListener listener, os.Handler targetHandler) =>
      _setExact_1(reference, type, triggerAtMillis, tag.reference,
          listener.reference, targetHandler.reference);

  static final _setAlarmClock = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlarmManager_setAlarmClock")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setAlarmClock(android.app.AlarmManager.AlarmClockInfo info, android.app.PendingIntent operation)
  /// Schedule an alarm that represents an alarm clock, which will be used to notify the user
  /// when it goes off.  The expectation is that when this alarm triggers, the application will
  /// further wake up the device to tell the user about the alarm -- turning on the screen,
  /// playing a sound, vibrating, etc.  As such, the system will typically also use the
  /// information supplied here to tell the user about this upcoming alarm if appropriate.
  ///
  /// Due to the nature of this kind of alarm, similar to \#setExactAndAllowWhileIdle,
  /// these alarms will be allowed to trigger even if the system is in a low-power idle
  /// (a.k.a. doze) mode.  The system may also do some prep-work when it sees that such an
  /// alarm coming up, to reduce the amount of background work that could happen if this
  /// causes the device to fully wake up -- this is to avoid situations such as a large number
  /// of devices having an alarm set at the same time in the morning, all waking up at that
  /// time and suddenly swamping the network with pending background work.  As such, these
  /// types of alarms can be extremely expensive on battery use and should only be used for
  /// their intended purpose.
  ///
  ///
  ///
  /// This method is like \#setExact(int, long, PendingIntent), but implies
  /// \#RTC_WAKEUP.
  ///@param info
  ///@param operation Action to perform when the alarm goes off;
  ///        typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see \#set
  ///@see \#setRepeating
  ///@see \#setWindow
  ///@see \#setExact
  ///@see \#cancel
  ///@see \#getNextAlarmClock()
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  void setAlarmClock(
          AlarmManager_AlarmClockInfo info, PendingIntent operation) =>
      _setAlarmClock(reference, info.reference, operation.reference);

  static final _setInexactRepeating = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int64,
                      ffi.Int64, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlarmManager_setInexactRepeating")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void setInexactRepeating(int type, long triggerAtMillis, long intervalMillis, android.app.PendingIntent operation)
  /// Schedule a repeating alarm that has inexact trigger time requirements;
  /// for example, an alarm that repeats every hour, but not necessarily at
  /// the top of every hour.  These alarms are more power-efficient than
  /// the strict recurrences traditionally supplied by \#setRepeating, since the
  /// system can adjust alarms' delivery times to cause them to fire simultaneously,
  /// avoiding waking the device from sleep more than necessary.
  ///
  /// Your alarm's first trigger will not be before the requested time,
  /// but it might not occur for almost a full interval after that time.  In
  /// addition, while the overall period of the repeating alarm will be as
  /// requested, the time between any two successive firings of the alarm
  /// may vary.  If your application demands very low jitter, use
  /// one-shot alarms with an appropriate window instead; see \#setWindow(int, long, long, PendingIntent) and
  /// \#setExact(int, long, PendingIntent).
  ///
  /// <p class="note">
  /// As of API 19, all repeating alarms are inexact.  Because this method has
  /// been available since API 3, your application can safely call it and be
  /// assured that it will get similar behavior on both current and older versions
  /// of Android.
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should first
  /// go off, using the appropriate clock (depending on the alarm type).  This
  /// is inexact: the alarm will not fire before this time, but there may be a
  /// delay of almost an entire alarm interval before the first invocation of
  /// the alarm.
  ///@param intervalMillis interval in milliseconds between subsequent repeats
  /// of the alarm.  Prior to API 19, if this is one of INTERVAL_FIFTEEN_MINUTES,
  /// INTERVAL_HALF_HOUR, INTERVAL_HOUR, INTERVAL_HALF_DAY, or INTERVAL_DAY
  /// then the alarm will be phase-aligned with other alarms to reduce the
  /// number of wakeups.  Otherwise, the alarm will be set as though the
  /// application had called \#setRepeating.  As of API 19, all repeating
  /// alarms will be inexact and subject to batching with other alarms regardless
  /// of their stated repeat interval.
  ///@param operation Action to perform when the alarm goes off;
  /// typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see android.os.Handler
  ///@see \#set
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  ///@see \#INTERVAL_FIFTEEN_MINUTES
  ///@see \#INTERVAL_HALF_HOUR
  ///@see \#INTERVAL_HOUR
  ///@see \#INTERVAL_HALF_DAY
  ///@see \#INTERVAL_DAY
  void setInexactRepeating(int type, int triggerAtMillis, int intervalMillis,
          PendingIntent operation) =>
      _setInexactRepeating(reference, type, triggerAtMillis, intervalMillis,
          operation.reference);

  static final _setAndAllowWhileIdle = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int64,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AlarmManager_setAndAllowWhileIdle")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void setAndAllowWhileIdle(int type, long triggerAtMillis, android.app.PendingIntent operation)
  /// Like \#set(int, long, PendingIntent), but this alarm will be allowed to execute
  /// even when the system is in low-power idle (a.k.a. doze) modes.  This type of alarm must
  /// __only__ be used for situations where it is actually required that the alarm go off while
  /// in idle -- a reasonable example would be for a calendar notification that should make a
  /// sound so the user is aware of it.  When the alarm is dispatched, the app will also be
  /// added to the system's temporary whitelist for approximately 10 seconds to allow that
  /// application to acquire further wake locks in which to complete its work.
  ///
  ///
  /// These alarms can significantly impact the power use
  /// of the device when idle (and thus cause significant battery blame to the app scheduling
  /// them), so they should be used with care.  To reduce abuse, there are restrictions on how
  /// frequently these alarms will go off for a particular application.
  /// Under normal system operation, it will not dispatch these
  /// alarms more than about every minute (at which point every such pending alarm is
  /// dispatched); when in low-power idle modes this duration may be significantly longer,
  /// such as 15 minutes.
  ///
  ///
  /// Unlike other alarms, the system is free to reschedule this type of alarm to happen
  /// out of order with any other alarms, even those from the same app.  This will clearly happen
  /// when the device is idle (since this alarm can go off while idle, when any other alarms
  /// from the app will be held until later), but may also happen even when not idle.
  ///
  ///
  /// Regardless of the app's target SDK version, this call always allows batching of the
  /// alarm.
  ///
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should go
  /// off, using the appropriate clock (depending on the alarm type).
  ///@param operation Action to perform when the alarm goes off;
  /// typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see \#set(int, long, PendingIntent)
  ///@see \#setExactAndAllowWhileIdle
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  void setAndAllowWhileIdle(
          int type, int triggerAtMillis, PendingIntent operation) =>
      _setAndAllowWhileIdle(
          reference, type, triggerAtMillis, operation.reference);

  static final _setExactAndAllowWhileIdle = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int64,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_AlarmManager_setExactAndAllowWhileIdle")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExactAndAllowWhileIdle(int type, long triggerAtMillis, android.app.PendingIntent operation)
  /// Like \#setExact(int, long, PendingIntent), but this alarm will be allowed to execute
  /// even when the system is in low-power idle modes.  If you don't need exact scheduling of
  /// the alarm but still need to execute while idle, consider using
  /// \#setAndAllowWhileIdle.  This type of alarm must __only__
  /// be used for situations where it is actually required that the alarm go off while in
  /// idle -- a reasonable example would be for a calendar notification that should make a
  /// sound so the user is aware of it.  When the alarm is dispatched, the app will also be
  /// added to the system's temporary whitelist for approximately 10 seconds to allow that
  /// application to acquire further wake locks in which to complete its work.
  ///
  ///
  /// These alarms can significantly impact the power use
  /// of the device when idle (and thus cause significant battery blame to the app scheduling
  /// them), so they should be used with care.  To reduce abuse, there are restrictions on how
  /// frequently these alarms will go off for a particular application.
  /// Under normal system operation, it will not dispatch these
  /// alarms more than about every minute (at which point every such pending alarm is
  /// dispatched); when in low-power idle modes this duration may be significantly longer,
  /// such as 15 minutes.
  ///
  ///
  /// Unlike other alarms, the system is free to reschedule this type of alarm to happen
  /// out of order with any other alarms, even those from the same app.  This will clearly happen
  /// when the device is idle (since this alarm can go off while idle, when any other alarms
  /// from the app will be held until later), but may also happen even when not idle.
  /// Note that the OS will allow itself more flexibility for scheduling these alarms than
  /// regular exact alarms, since the application has opted into this behavior.  When the
  /// device is idle it may take even more liberties with scheduling in order to optimize
  /// for battery life.
  ///
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should go
  ///        off, using the appropriate clock (depending on the alarm type).
  ///@param operation Action to perform when the alarm goes off;
  ///        typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see \#set
  ///@see \#setRepeating
  ///@see \#setWindow
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  void setExactAndAllowWhileIdle(
          int type, int triggerAtMillis, PendingIntent operation) =>
      _setExactAndAllowWhileIdle(
          reference, type, triggerAtMillis, operation.reference);

  static final _cancel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_AlarmManager_cancel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void cancel(android.app.PendingIntent operation)
  /// Remove any alarms with a matching Intent.
  /// Any alarm, of any type, whose Intent matches this one (as defined by
  /// Intent\#filterEquals), will be canceled.
  ///@param operation IntentSender which matches a previously added
  /// IntentSender. This parameter must not be {@code null}.
  ///@see \#set
  void cancel(PendingIntent operation) =>
      _cancel(reference, operation.reference);

  static final _cancel_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_AlarmManager_cancel_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void cancel(android.app.AlarmManager.OnAlarmListener listener)
  /// Remove any alarm scheduled to be delivered to the given OnAlarmListener.
  ///@param listener OnAlarmListener instance that is the target of a currently-set alarm.
  void cancel_1(AlarmManager_OnAlarmListener listener) =>
      _cancel_1(reference, listener.reference);

  static final _setTime = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_app_AlarmManager_setTime")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setTime(long millis)
  /// Set the system wall clock time.
  /// Requires the permission android.permission.SET_TIME.
  ///@param millis time in milliseconds since the Epoch
  void setTime(int millis) => _setTime(reference, millis);

  static final _setTimeZone = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlarmManager_setTimeZone")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTimeZone(java.lang.String timeZone)
  /// Sets the system's persistent default time zone. This is the time zone for all apps, even
  /// after a reboot. Use java.util.TimeZone\#setDefault if you just want to change the
  /// time zone within your app, and even then prefer to pass an explicit
  /// java.util.TimeZone to APIs that require it rather than changing the time zone for
  /// all threads.
  ///
  ///  On android M and above, it is an error to pass in a non-Olson timezone to this
  /// function. Note that this is a bad idea on all Android releases because POSIX and
  /// the {@code TimeZone} class have opposite interpretations of {@code '+'} and {@code '-'}
  /// in the same non-Olson ID.
  ///@param timeZone one of the Olson ids from the list returned by
  ///     java.util.TimeZone\#getAvailableIDs
  void setTimeZone(jni.JlString timeZone) =>
      _setTimeZone(reference, timeZone.reference);

  static final _getNextAlarmClock = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_AlarmManager_getNextAlarmClock")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlarmManager.AlarmClockInfo getNextAlarmClock()
  /// Gets information about the next alarm clock currently scheduled.
  ///
  /// The alarm clocks considered are those scheduled by any application
  /// using the \#setAlarmClock method.
  ///@return An AlarmClockInfo object describing the next upcoming alarm
  ///   clock event that will occur.  If there are no alarm clock events currently
  ///   scheduled, this method will return {@code null}.
  ///@see \#setAlarmClock
  ///@see AlarmClockInfo
  ///@see \#ACTION_NEXT_ALARM_CLOCK_CHANGED
  AlarmManager_AlarmClockInfo getNextAlarmClock() =>
      AlarmManager_AlarmClockInfo.fromRef(_getNextAlarmClock(reference));
}

/// Direct-notification alarms: the requester must be running continuously from the
/// time the alarm is set to the time it is delivered, or delivery will fail.  Only
/// one-shot alarms can be set using this mechanism, not repeating alarms.
class AlarmManager_OnAlarmListener extends jni.JlObject {
  AlarmManager_OnAlarmListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onAlarm =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_AlarmManager__OnAlarmListener_onAlarm")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onAlarm()
  /// Callback method that is invoked by the system when the alarm time is reached.
  void onAlarm() => _onAlarm(reference);
}

/// An immutable description of a scheduled "alarm clock" event.
///@see AlarmManager\#setAlarmClock
///@see AlarmManager\#getNextAlarmClock
class AlarmManager_AlarmClockInfo extends jni.JlObject {
  AlarmManager_AlarmClockInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.AlarmManager.AlarmClockInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_AlarmManager__AlarmClockInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Int64, ffi.Pointer<ffi.Void>)>>(
          "android_app_AlarmManager__AlarmClockInfo_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(long triggerTime, android.app.PendingIntent showIntent)
  /// Creates a new alarm clock description.
  ///@param triggerTime time at which the underlying alarm is triggered in wall time
  ///                    milliseconds since the epoch
  ///@param showIntent an intent that can be used to show or edit details of
  ///                        the alarm clock.
  AlarmManager_AlarmClockInfo(int triggerTime, PendingIntent showIntent)
      : super.fromRef(_ctor(triggerTime, showIntent.reference));

  static final _getTriggerTime =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_AlarmManager__AlarmClockInfo_getTriggerTime")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTriggerTime()
  /// Returns the time at which the alarm is going to trigger.
  ///
  /// This value is UTC wall clock time in milliseconds, as returned by
  /// System\#currentTimeMillis() for example.
  int getTriggerTime() => _getTriggerTime(reference);

  static final _getShowIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_AlarmManager__AlarmClockInfo_getShowIntent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent getShowIntent()
  /// Returns an intent that can be used to show or edit details of the alarm clock in
  /// the application that scheduled it.
  ///
  /// <p class="note">Beware that any application can retrieve and send this intent,
  /// potentially with additional fields filled in. See
  /// PendingIntent\#send(android.content.Context, int, android.content.Intent) PendingIntent.send() and android.content.Intent\#fillIn Intent.fillIn()
  /// for details.
  PendingIntent getShowIntent() =>
      PendingIntent.fromRef(_getShowIntent(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_AlarmManager__AlarmClockInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_AlarmManager__AlarmClockInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);
}

/// Stub activity that launches another activity (and then finishes itself)
/// based on information in its component's manifest meta-data.  This is a
/// simple way to implement an alias-like mechanism.
///
/// To use this activity, you should include in the manifest for the associated
/// component an entry named "android.app.alias".  It is a reference to an XML
/// resource describing an intent that launches the real application.
class AliasActivity extends Activity {
  AliasActivity.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_AliasActivity_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  AliasActivity() : super.fromRef(_ctor());

  static final _onCreate = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_AliasActivity_onCreate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onCreate(android.os.Bundle savedInstanceState)
  void onCreate(os.Bundle savedInstanceState) =>
      _onCreate(reference, savedInstanceState.reference);
}

/// Class to notify the user of events that happen.  This is how you tell
/// the user that something has happened in the background. {@more }
///
/// Notifications can take different forms:
/// <ul>
///      <li>A persistent icon that goes in the status bar and is accessible
///          through the launcher, (when the user selects it, a designated Intent
///          can be launched),</li>
///      <li>Turning on or flashing LEDs on the device, or</li>
///      <li>Alerting the user by flashing the backlight, playing a sound,
///          or vibrating.</li>
/// </ul>
///
///
/// Each of the notify methods takes an int id parameter and optionally a
/// String tag parameter, which may be {@code null}.  These parameters
/// are used to form a pair (tag, id), or ({@code null}, id) if tag is
/// unspecified.  This pair identifies this notification from your app to the
/// system, so that pair should be unique within your app.  If you call one
/// of the notify methods with a (tag, id) pair that is currently active and
/// a new set of notification parameters, it will be updated.  For example,
/// if you pass a new status bar icon, the old icon in the status bar will
/// be replaced with the new one.  This is also the same tag and id you pass
/// to the \#cancel(int) or \#cancel(String, int) method to clear
/// this notification.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For a guide to creating notifications, read the
/// <a href="{@docRoot}guide/topics/ui/notifiers/notifications.html">Status Bar Notifications</a>
/// developer guide.
///
/// </div>
///@see android.app.Notification
class NotificationManager extends jni.JlObject {
  NotificationManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_APP_BLOCK_STATE_CHANGED
  /// Intent that is broadcast when an application is blocked or unblocked.
  ///
  /// This broadcast is only sent to the app whose block state has changed.
  ///
  /// Input: nothing
  /// Output: \#EXTRA_BLOCKED_STATE
  static const ACTION_APP_BLOCK_STATE_CHANGED =
      "android.app.action.APP_BLOCK_STATE_CHANGED";

  /// from: static public final java.lang.String ACTION_INTERRUPTION_FILTER_CHANGED
  /// Intent that is broadcast when the state of getCurrentInterruptionFilter() changes.
  /// This broadcast is only sent to registered receivers.
  static const ACTION_INTERRUPTION_FILTER_CHANGED =
      "android.app.action.INTERRUPTION_FILTER_CHANGED";

  /// from: static public final java.lang.String ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED
  /// Intent that is broadcast when a NotificationChannel is blocked
  /// (when NotificationChannel\#getImportance() is \#IMPORTANCE_NONE) or unblocked
  /// (when NotificationChannel\#getImportance() is anything other than
  /// \#IMPORTANCE_NONE).
  ///
  /// This broadcast is only sent to the app that owns the channel that has changed.
  ///
  /// Input: nothing
  /// Output: \#EXTRA_NOTIFICATION_CHANNEL_ID
  /// Output: \#EXTRA_BLOCKED_STATE
  static const ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED =
      "android.app.action.NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED";

  /// from: static public final java.lang.String ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED
  /// Intent that is broadcast when a NotificationChannelGroup is
  /// NotificationChannelGroup\#isBlocked() blocked or unblocked.
  ///
  /// This broadcast is only sent to the app that owns the channel group that has changed.
  ///
  /// Input: nothing
  /// Output: \#EXTRA_NOTIFICATION_CHANNEL_GROUP_ID
  /// Output: \#EXTRA_BLOCKED_STATE
  static const ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED =
      "android.app.action.NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED";

  /// from: static public final java.lang.String ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED
  /// Intent that is broadcast when the state of \#isNotificationPolicyAccessGranted()
  /// changes.
  ///
  /// This broadcast is only sent to registered receivers, and only to the apps that have changed.
  static const ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED =
      "android.app.action.NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED";

  /// from: static public final java.lang.String ACTION_NOTIFICATION_POLICY_CHANGED
  /// Intent that is broadcast when the state of getNotificationPolicy() changes.
  /// This broadcast is only sent to registered receivers.
  static const ACTION_NOTIFICATION_POLICY_CHANGED =
      "android.app.action.NOTIFICATION_POLICY_CHANGED";

  /// from: static public final java.lang.String EXTRA_BLOCKED_STATE
  /// Extra for \#ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED or
  /// \#ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED containing the new blocked
  /// state as a boolean.
  ///
  /// The value will be {@code true} if this channel or group is now blocked and {@code false} if
  /// this channel or group is now unblocked.
  static const EXTRA_BLOCKED_STATE = "android.app.extra.BLOCKED_STATE";

  /// from: static public final java.lang.String EXTRA_NOTIFICATION_CHANNEL_GROUP_ID
  /// Extra for \#ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED containing the id
  /// of the NotificationChannelGroup which has a new blocked state.
  ///
  /// The value will be the NotificationChannelGroup\#getId() of the group.
  static const EXTRA_NOTIFICATION_CHANNEL_GROUP_ID =
      "android.app.extra.NOTIFICATION_CHANNEL_GROUP_ID";

  /// from: static public final java.lang.String EXTRA_NOTIFICATION_CHANNEL_ID
  /// Extra for \#ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED containing the id of the
  /// NotificationChannel which has a new blocked state.
  ///
  /// The value will be the NotificationChannel\#getId() of the channel.
  static const EXTRA_NOTIFICATION_CHANNEL_ID =
      "android.app.extra.NOTIFICATION_CHANNEL_ID";

  /// from: static public final int IMPORTANCE_DEFAULT
  /// Default notification importance: shows everywhere, makes noise, but does not visually
  /// intrude.
  static const IMPORTANCE_DEFAULT = 3;

  /// from: static public final int IMPORTANCE_HIGH
  /// Higher notification importance: shows everywhere, makes noise and peeks. May use full screen
  /// intents.
  static const IMPORTANCE_HIGH = 4;

  /// from: static public final int IMPORTANCE_LOW
  /// Low notification importance: shows everywhere, but is not intrusive.
  static const IMPORTANCE_LOW = 2;

  /// from: static public final int IMPORTANCE_MAX
  /// Unused.
  static const IMPORTANCE_MAX = 5;

  /// from: static public final int IMPORTANCE_MIN
  /// Min notification importance: only shows in the shade, below the fold.  This should
  /// not be used with Service\#startForeground(int, Notification) Service.startForeground
  /// since a foreground service is supposed to be something the user cares about so it does
  /// not make semantic sense to mark its notification as minimum importance.  If you do this
  /// as of Android version android.os.Build.VERSION_CODES\#O, the system will show
  /// a higher-priority notification about your app running in the background.
  static const IMPORTANCE_MIN = 1;

  /// from: static public final int IMPORTANCE_NONE
  /// A notification with no importance: does not show in the shade.
  static const IMPORTANCE_NONE = 0;

  /// from: static public final int IMPORTANCE_UNSPECIFIED
  /// Value signifying that the user has not expressed an importance.
  ///
  /// This value is for persisting preferences, and should never be associated with
  /// an actual notification.
  static const IMPORTANCE_UNSPECIFIED = -1000;

  /// from: static public final int INTERRUPTION_FILTER_ALARMS
  /// \#getCurrentInterruptionFilter() Interruption filter constant -
  ///     Alarms only interruption filter - all notifications except those of category
  ///     Notification\#CATEGORY_ALARM are suppressed. Some audio streams are muted.
  static const INTERRUPTION_FILTER_ALARMS = 4;

  /// from: static public final int INTERRUPTION_FILTER_ALL
  /// \#getCurrentInterruptionFilter() Interruption filter constant -
  ///     Normal interruption filter - no notifications are suppressed.
  static const INTERRUPTION_FILTER_ALL = 1;

  /// from: static public final int INTERRUPTION_FILTER_NONE
  /// \#getCurrentInterruptionFilter() Interruption filter constant -
  ///     No interruptions filter - all notifications are suppressed and all audio streams (except
  ///     those used for phone calls) and vibrations are muted.
  static const INTERRUPTION_FILTER_NONE = 3;

  /// from: static public final int INTERRUPTION_FILTER_PRIORITY
  /// \#getCurrentInterruptionFilter() Interruption filter constant -
  ///     Priority interruption filter - all notifications are suppressed except those that match
  ///     the priority criteria. Some audio streams are muted. See
  ///     Policy\#priorityCallSenders, Policy\#priorityCategories,
  ///     Policy\#priorityMessageSenders to define or query this criteria. Users can
  ///     additionally specify packages that can bypass this interruption filter.
  static const INTERRUPTION_FILTER_PRIORITY = 2;

  /// from: static public final int INTERRUPTION_FILTER_UNKNOWN
  /// \#getCurrentInterruptionFilter() Interruption filter constant - returned when
  /// the value is unavailable for any reason.
  static const INTERRUPTION_FILTER_UNKNOWN = 0;

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.content.Context context, android.os.Handler handler)
  NotificationManager(content.Context context, os.Handler handler)
      : super.fromRef(_ctor(context.reference, handler.reference));

  static final _notify = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_notify")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void notify(int id, android.app.Notification notification)
  /// Post a notification to be shown in the status bar. If a notification with
  /// the same id has already been posted by your application and has not yet been canceled, it
  /// will be replaced by the updated information.
  ///@param id An identifier for this notification unique within your
  ///        application.
  ///@param notification A Notification object describing what to show the user. Must not
  ///        be null.
  void notify(int id, Notification notification) =>
      _notify(reference, id, notification.reference);

  static final _notify_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_notify_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void notify(java.lang.String tag, int id, android.app.Notification notification)
  /// Post a notification to be shown in the status bar. If a notification with
  /// the same tag and id has already been posted by your application and has not yet been
  /// canceled, it will be replaced by the updated information.
  ///
  /// All android.service.notification.NotificationListenerService listener services will
  /// be granted Intent\#FLAG_GRANT_READ_URI_PERMISSION access to any Uri uris
  /// provided on this notification or the
  /// NotificationChannel this notification is posted to using
  /// Context\#grantUriPermission(String, Uri, int). Permission will be revoked when the
  /// notification is canceled, or you can revoke permissions with
  /// Context\#revokeUriPermission(Uri, int).
  ///@param tag A string identifier for this notification.  May be {@code null}.
  ///@param id An identifier for this notification.  The pair (tag, id) must be unique
  ///        within your application.
  ///@param notification A Notification object describing what to
  ///        show the user. Must not be null.
  void notify_1(jni.JlString tag, int id, Notification notification) =>
      _notify_1(reference, tag.reference, id, notification.reference);

  static final _cancel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_NotificationManager_cancel")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void cancel(int id)
  /// Cancel a previously shown notification.  If it's transient, the view
  /// will be hidden.  If it's persistent, it will be removed from the status
  /// bar.
  void cancel(int id) => _cancel(reference, id);

  static final _cancel_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_NotificationManager_cancel_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void cancel(java.lang.String tag, int id)
  /// Cancel a previously shown notification.  If it's transient, the view
  /// will be hidden.  If it's persistent, it will be removed from the status
  /// bar.
  void cancel_1(jni.JlString tag, int id) =>
      _cancel_1(reference, tag.reference, id);

  static final _cancelAll =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NotificationManager_cancelAll")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void cancelAll()
  /// Cancel all previously shown notifications. See \#cancel for the
  /// detailed behavior.
  void cancelAll() => _cancelAll(reference);

  static final _createNotificationChannelGroup = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_createNotificationChannelGroup")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void createNotificationChannelGroup(android.app.NotificationChannelGroup group)
  /// Creates a group container for NotificationChannel objects.
  ///
  /// This can be used to rename an existing group.
  ///
  ///     Group information is only used for presentation, not for behavior. Groups are optional
  ///     for channels, and you can have a mix of channels that belong to groups and channels
  ///     that do not.
  ///
  ///
  ///
  ///     For example, if your application supports multiple accounts, and those accounts will
  ///     have similar channels, you can create a group for each account with account specific
  ///     labels instead of appending account information to each channel's label.
  ///
  ///
  ///@param group The group to create
  ///
  /// This value must never be {@code null}.
  void createNotificationChannelGroup(NotificationChannelGroup group) =>
      _createNotificationChannelGroup(reference, group.reference);

  static final _createNotificationChannelGroups = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_createNotificationChannelGroups")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void createNotificationChannelGroups(java.util.List<android.app.NotificationChannelGroup> groups)
  /// Creates multiple notification channel groups.
  ///@param groups The list of groups to create
  ///
  /// This value must never be {@code null}.
  void createNotificationChannelGroups(jni.JlObject groups) =>
      _createNotificationChannelGroups(reference, groups.reference);

  static final _createNotificationChannel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_createNotificationChannel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void createNotificationChannel(android.app.NotificationChannel channel)
  /// Creates a notification channel that notifications can be posted to.
  ///
  /// This can also be used to restore a deleted channel and to update an existing channel's
  /// name, description, group, and/or importance.
  ///
  /// The name and description should only be changed if the locale changes
  /// or in response to the user renaming this channel. For example, if a user has a channel
  /// named 'John Doe' that represents messages from a 'John Doe', and 'John Doe' changes his name
  /// to 'John Smith,' the channel can be renamed to match.
  ///
  /// The importance of an existing channel will only be changed if the new importance is lower
  /// than the current value and the user has not altered any settings on this channel.
  ///
  /// The group an existing channel will only be changed if the channel does not already
  /// belong to a group.
  ///
  /// All other fields are ignored for channels that already exist.
  ///@param channel the channel to create.  Note that the created channel may differ from this
  ///                 value. If the provided channel is malformed, a RemoteException will be
  ///                 thrown.
  ///
  /// This value must never be {@code null}.
  void createNotificationChannel(NotificationChannel channel) =>
      _createNotificationChannel(reference, channel.reference);

  static final _createNotificationChannels = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_createNotificationChannels")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void createNotificationChannels(java.util.List<android.app.NotificationChannel> channels)
  /// Creates multiple notification channels that different notifications can be posted to. See
  /// \#createNotificationChannel(NotificationChannel).
  ///@param channels the list of channels to attempt to create.
  ///
  /// This value must never be {@code null}.
  void createNotificationChannels(jni.JlObject channels) =>
      _createNotificationChannels(reference, channels.reference);

  static final _getNotificationChannel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_getNotificationChannel")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.NotificationChannel getNotificationChannel(java.lang.String channelId)
  /// Returns the notification channel settings for a given channel id.
  ///
  /// The channel must belong to your package, or it will not be returned.
  NotificationChannel getNotificationChannel(jni.JlString channelId) =>
      NotificationChannel.fromRef(
          _getNotificationChannel(reference, channelId.reference));

  static final _getNotificationChannels = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_getNotificationChannels")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.NotificationChannel> getNotificationChannels()
  /// Returns all notification channels belonging to the calling package.
  jni.JlObject getNotificationChannels() =>
      jni.JlObject.fromRef(_getNotificationChannels(reference));

  static final _deleteNotificationChannel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_deleteNotificationChannel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void deleteNotificationChannel(java.lang.String channelId)
  /// Deletes the given notification channel.
  ///
  /// If you \#createNotificationChannel(NotificationChannel) create a new channel with
  /// this same id, the deleted channel will be un-deleted with all of the same settings it
  /// had before it was deleted.
  void deleteNotificationChannel(jni.JlString channelId) =>
      _deleteNotificationChannel(reference, channelId.reference);

  static final _getNotificationChannelGroup = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_getNotificationChannelGroup")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.NotificationChannelGroup getNotificationChannelGroup(java.lang.String channelGroupId)
  /// Returns the notification channel group settings for a given channel group id.
  ///
  /// The channel group must belong to your package, or null will be returned.
  NotificationChannelGroup getNotificationChannelGroup(
          jni.JlString channelGroupId) =>
      NotificationChannelGroup.fromRef(
          _getNotificationChannelGroup(reference, channelGroupId.reference));

  static final _getNotificationChannelGroups = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_getNotificationChannelGroups")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.NotificationChannelGroup> getNotificationChannelGroups()
  /// Returns all notification channel groups belonging to the calling app.
  jni.JlObject getNotificationChannelGroups() =>
      jni.JlObject.fromRef(_getNotificationChannelGroups(reference));

  static final _deleteNotificationChannelGroup = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_deleteNotificationChannelGroup")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void deleteNotificationChannelGroup(java.lang.String groupId)
  /// Deletes the given notification channel group, and all notification channels that
  /// belong to it.
  void deleteNotificationChannelGroup(jni.JlString groupId) =>
      _deleteNotificationChannelGroup(reference, groupId.reference);

  static final _getAutomaticZenRules = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_getAutomaticZenRules")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Map<java.lang.String,android.app.AutomaticZenRule> getAutomaticZenRules()
  /// Returns AutomaticZenRules owned by the caller.
  ///
  ///
  /// Throws a SecurityException if policy access is granted to this package.
  /// See \#isNotificationPolicyAccessGranted.
  jni.JlObject getAutomaticZenRules() =>
      jni.JlObject.fromRef(_getAutomaticZenRules(reference));

  static final _getAutomaticZenRule = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_getAutomaticZenRule")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AutomaticZenRule getAutomaticZenRule(java.lang.String id)
  /// Returns the AutomaticZenRule with the given id, if it exists and the caller has access.
  ///
  ///
  /// Throws a SecurityException if policy access is granted to this package.
  /// See \#isNotificationPolicyAccessGranted.
  ///
  ///
  /// Returns null if there are no zen rules that match the given id, or if the calling package
  /// doesn't own the matching rule. See AutomaticZenRule\#getOwner.
  AutomaticZenRule getAutomaticZenRule(jni.JlString id) =>
      AutomaticZenRule.fromRef(_getAutomaticZenRule(reference, id.reference));

  static final _addAutomaticZenRule = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_addAutomaticZenRule")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String addAutomaticZenRule(android.app.AutomaticZenRule automaticZenRule)
  /// Creates the given zen rule.
  ///
  ///
  /// Throws a SecurityException if policy access is granted to this package.
  /// See \#isNotificationPolicyAccessGranted.
  ///@param automaticZenRule the rule to create.
  ///@return The id of the newly created rule; null if the rule could not be created.
  jni.JlString addAutomaticZenRule(AutomaticZenRule automaticZenRule) =>
      jni.JlString.fromRef(
          _addAutomaticZenRule(reference, automaticZenRule.reference));

  static final _updateAutomaticZenRule = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_updateAutomaticZenRule")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean updateAutomaticZenRule(java.lang.String id, android.app.AutomaticZenRule automaticZenRule)
  /// Updates the given zen rule.
  ///
  ///
  /// Throws a SecurityException if policy access is granted to this package.
  /// See \#isNotificationPolicyAccessGranted.
  ///
  ///
  /// Callers can only update rules that they own. See AutomaticZenRule\#getOwner.
  ///@param id The id of the rule to update
  ///@param automaticZenRule the rule to update.
  ///@return Whether the rule was successfully updated.
  bool updateAutomaticZenRule(
          jni.JlString id, AutomaticZenRule automaticZenRule) =>
      _updateAutomaticZenRule(
          reference, id.reference, automaticZenRule.reference) !=
      0;

  static final _removeAutomaticZenRule = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_removeAutomaticZenRule")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean removeAutomaticZenRule(java.lang.String id)
  /// Deletes the automatic zen rule with the given id.
  ///
  ///
  /// Throws a SecurityException if policy access is granted to this package.
  /// See \#isNotificationPolicyAccessGranted.
  ///
  ///
  /// Callers can only delete rules that they own. See AutomaticZenRule\#getOwner.
  ///@param id the id of the rule to delete.
  ///@return Whether the rule was successfully deleted.
  bool removeAutomaticZenRule(jni.JlString id) =>
      _removeAutomaticZenRule(reference, id.reference) != 0;

  static final _getImportance =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NotificationManager_getImportance")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getImportance()
  /// Returns the user specified importance for notifications from the calling
  /// package.
  ///@return Value is android.app.NotificationManager\#IMPORTANCE_UNSPECIFIED, android.app.NotificationManager\#IMPORTANCE_NONE, android.app.NotificationManager\#IMPORTANCE_MIN, android.app.NotificationManager\#IMPORTANCE_LOW, android.app.NotificationManager\#IMPORTANCE_DEFAULT, or android.app.NotificationManager\#IMPORTANCE_HIGH
  int getImportance() => _getImportance(reference);

  static final _areNotificationsEnabled =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NotificationManager_areNotificationsEnabled")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean areNotificationsEnabled()
  /// Returns whether notifications from the calling package are blocked.
  bool areNotificationsEnabled() => _areNotificationsEnabled(reference) != 0;

  static final _isNotificationPolicyAccessGranted = jlookup<
              ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_isNotificationPolicyAccessGranted")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isNotificationPolicyAccessGranted()
  /// Checks the ability to modify notification do not disturb policy for the calling package.
  ///
  ///
  /// Returns true if the calling package can modify notification policy.
  ///
  ///
  /// Apps can request policy access by sending the user to the activity that matches the system
  /// intent action android.provider.Settings\#ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS.
  ///
  ///
  /// Use \#ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED to listen for
  /// user grant or denial of this access.
  bool isNotificationPolicyAccessGranted() =>
      _isNotificationPolicyAccessGranted(reference) != 0;

  static final _isNotificationListenerAccessGranted = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_isNotificationListenerAccessGranted")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isNotificationListenerAccessGranted(android.content.ComponentName listener)
  /// Checks whether the user has approved a given
  /// android.service.notification.NotificationListenerService.
  ///
  ///
  /// The listener service must belong to the calling app.
  ///
  ///
  /// Apps can request notification listener access by sending the user to the activity that
  /// matches the system intent action
  /// android.provider.Settings\#ACTION_NOTIFICATION_LISTENER_SETTINGS.
  bool isNotificationListenerAccessGranted(content.ComponentName listener) =>
      _isNotificationListenerAccessGranted(reference, listener.reference) != 0;

  static final _getNotificationPolicy = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_getNotificationPolicy")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.NotificationManager.Policy getNotificationPolicy()
  /// Gets the current notification policy.
  ///
  ///
  NotificationManager_Policy getNotificationPolicy() =>
      NotificationManager_Policy.fromRef(_getNotificationPolicy(reference));

  static final _setNotificationPolicy = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_setNotificationPolicy")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setNotificationPolicy(android.app.NotificationManager.Policy policy)
  /// Sets the current notification policy.
  ///
  ///
  /// Only available if policy access is granted to this package.
  /// See \#isNotificationPolicyAccessGranted.
  ///@param policy The new desired policy.
  ///
  /// This value must never be {@code null}.
  void setNotificationPolicy(NotificationManager_Policy policy) =>
      _setNotificationPolicy(reference, policy.reference);

  static final _getActiveNotifications = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager_getActiveNotifications")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.service.notification.StatusBarNotification[] getActiveNotifications()
  /// Recover a list of active notifications: ones that have been posted by the calling app that
  /// have not yet been dismissed by the user or \#cancel(String, int)ed by the app.
  ///
  /// Each notification is embedded in a StatusBarNotification object, including the
  /// original <code>tag</code> and <code>id</code> supplied to
  /// \#notify(String, int, Notification) notify()
  /// (via StatusBarNotification\#getTag() getTag() and
  /// StatusBarNotification\#getId() getId()) as well as a copy of the original
  /// Notification object (via StatusBarNotification\#getNotification()).
  ///@return An array of StatusBarNotification.
  jni.JlObject getActiveNotifications() =>
      jni.JlObject.fromRef(_getActiveNotifications(reference));

  static final _getCurrentInterruptionFilter =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NotificationManager_getCurrentInterruptionFilter")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getCurrentInterruptionFilter()
  /// Gets the current notification interruption filter.
  ///
  /// The interruption filter defines which notifications are allowed to
  /// interrupt the user (e.g. via sound &amp; vibration) and is applied
  /// globally.
  ///@return Value is android.app.NotificationManager\#INTERRUPTION_FILTER_NONE, android.app.NotificationManager\#INTERRUPTION_FILTER_PRIORITY, android.app.NotificationManager\#INTERRUPTION_FILTER_ALARMS, android.app.NotificationManager\#INTERRUPTION_FILTER_ALL, or android.app.NotificationManager\#INTERRUPTION_FILTER_UNKNOWN
  int getCurrentInterruptionFilter() =>
      _getCurrentInterruptionFilter(reference);

  static final _setInterruptionFilter = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_NotificationManager_setInterruptionFilter")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setInterruptionFilter(int interruptionFilter)
  /// Sets the current notification interruption filter.
  ///
  /// The interruption filter defines which notifications are allowed to
  /// interrupt the user (e.g. via sound &amp; vibration) and is applied
  /// globally.
  ///
  /// Only available if policy access is granted to this package. See
  /// \#isNotificationPolicyAccessGranted.
  ///@param interruptionFilter Value is android.app.NotificationManager\#INTERRUPTION_FILTER_NONE, android.app.NotificationManager\#INTERRUPTION_FILTER_PRIORITY, android.app.NotificationManager\#INTERRUPTION_FILTER_ALARMS, android.app.NotificationManager\#INTERRUPTION_FILTER_ALL, or android.app.NotificationManager\#INTERRUPTION_FILTER_UNKNOWN
  void setInterruptionFilter(int interruptionFilter) =>
      _setInterruptionFilter(reference, interruptionFilter);
}

/// Notification policy configuration.  Represents user-preferences for notification
/// filtering.
class NotificationManager_Policy extends jni.JlObject {
  NotificationManager_Policy.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.NotificationManager.Policy> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_NotificationManager__Policy_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int PRIORITY_CATEGORY_ALARMS
  /// Alarms are prioritized
  static const PRIORITY_CATEGORY_ALARMS = 32;

  /// from: static public final int PRIORITY_CATEGORY_CALLS
  /// Calls are prioritized.
  static const PRIORITY_CATEGORY_CALLS = 8;

  /// from: static public final int PRIORITY_CATEGORY_EVENTS
  /// Event notifications are prioritized.
  static const PRIORITY_CATEGORY_EVENTS = 2;

  /// from: static public final int PRIORITY_CATEGORY_MEDIA
  /// Media, game, voice navigation are prioritized
  static const PRIORITY_CATEGORY_MEDIA = 64;

  /// from: static public final int PRIORITY_CATEGORY_MESSAGES
  /// Message notifications are prioritized.
  static const PRIORITY_CATEGORY_MESSAGES = 4;

  /// from: static public final int PRIORITY_CATEGORY_REMINDERS
  /// Reminder notifications are prioritized.
  static const PRIORITY_CATEGORY_REMINDERS = 1;

  /// from: static public final int PRIORITY_CATEGORY_REPEAT_CALLERS
  /// Calls from repeat callers are prioritized.
  static const PRIORITY_CATEGORY_REPEAT_CALLERS = 16;

  /// from: static public final int PRIORITY_CATEGORY_SYSTEM
  /// System (catch-all for non-never suppressible sounds) are prioritized
  static const PRIORITY_CATEGORY_SYSTEM = 128;

  /// from: static public final int PRIORITY_SENDERS_ANY
  /// Any sender is prioritized.
  static const PRIORITY_SENDERS_ANY = 0;

  /// from: static public final int PRIORITY_SENDERS_CONTACTS
  /// Saved contacts are prioritized.
  static const PRIORITY_SENDERS_CONTACTS = 1;

  /// from: static public final int PRIORITY_SENDERS_STARRED
  /// Only starred contacts are prioritized.
  static const PRIORITY_SENDERS_STARRED = 2;

  /// from: static public final int SUPPRESSED_EFFECT_AMBIENT
  /// Whether notification intercepted by DND are prevented from appearing on ambient displays
  /// on devices that support ambient display.
  static const SUPPRESSED_EFFECT_AMBIENT = 128;

  /// from: static public final int SUPPRESSED_EFFECT_BADGE
  /// Whether NotificationChannel\#canShowBadge() badges from
  /// notifications intercepted by DND are blocked on devices that support badging.
  static const SUPPRESSED_EFFECT_BADGE = 64;

  /// from: static public final int SUPPRESSED_EFFECT_FULL_SCREEN_INTENT
  /// Whether Notification\#fullScreenIntent full screen intents from
  /// notifications intercepted by DND are blocked.
  static const SUPPRESSED_EFFECT_FULL_SCREEN_INTENT = 4;

  /// from: static public final int SUPPRESSED_EFFECT_LIGHTS
  /// Whether NotificationChannel\#shouldShowLights() notification lights from
  /// notifications intercepted by DND are blocked.
  static const SUPPRESSED_EFFECT_LIGHTS = 8;

  /// from: static public final int SUPPRESSED_EFFECT_NOTIFICATION_LIST
  /// Whether notification intercepted by DND are prevented from appearing in notification
  /// list views like the notification shade or lockscreen on devices that support those
  /// views.
  static const SUPPRESSED_EFFECT_NOTIFICATION_LIST = 256;

  /// from: static public final int SUPPRESSED_EFFECT_PEEK
  /// Whether notifications intercepted by DND are prevented from peeking.
  static const SUPPRESSED_EFFECT_PEEK = 16;

  /// from: static public final int SUPPRESSED_EFFECT_SCREEN_OFF
  /// Whether notifications suppressed by DND should not interrupt visually (e.g.&nbsp;with
  /// notification lights or by turning the screen on) when the screen is off.
  ///@deprecated use \#SUPPRESSED_EFFECT_FULL_SCREEN_INTENT and
  /// \#SUPPRESSED_EFFECT_AMBIENT and \#SUPPRESSED_EFFECT_LIGHTS individually.
  static const SUPPRESSED_EFFECT_SCREEN_OFF = 1;

  /// from: static public final int SUPPRESSED_EFFECT_SCREEN_ON
  /// Whether notifications suppressed by DND should not interrupt visually when the screen
  /// is on (e.g.&nbsp;by peeking onto the screen).
  ///@deprecated use \#SUPPRESSED_EFFECT_PEEK.
  static const SUPPRESSED_EFFECT_SCREEN_ON = 2;

  /// from: static public final int SUPPRESSED_EFFECT_STATUS_BAR
  /// Whether notifications intercepted by DND are prevented from appearing in the status bar,
  /// on devices that support status bars.
  static const SUPPRESSED_EFFECT_STATUS_BAR = 32;

  /// from: public final int priorityCallSenders
  /// Notification senders to prioritize for calls. One of:
  /// PRIORITY_SENDERS_ANY, PRIORITY_SENDERS_CONTACTS, PRIORITY_SENDERS_STARRED
  static final _getpriorityCallSenders = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_NotificationManager__Policy_priorityCallSenders")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get priorityCallSenders => _getpriorityCallSenders(reference);

  /// from: public final int priorityCategories
  /// Notification categories to prioritize. Bitmask of PRIORITY_CATEGORY_* constants.
  static final _getpriorityCategories = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_NotificationManager__Policy_priorityCategories")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get priorityCategories => _getpriorityCategories(reference);

  /// from: public final int priorityMessageSenders
  /// Notification senders to prioritize for messages. One of:
  /// PRIORITY_SENDERS_ANY, PRIORITY_SENDERS_CONTACTS, PRIORITY_SENDERS_STARRED
  static final _getpriorityMessageSenders = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_NotificationManager__Policy_priorityMessageSenders")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get priorityMessageSenders => _getpriorityMessageSenders(reference);

  /// from: public final int suppressedVisualEffects
  /// Visual effects to suppress for a notification that is filtered by Do Not Disturb mode.
  /// Bitmask of SUPPRESSED_EFFECT_* constants.
  static final _getsuppressedVisualEffects = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_NotificationManager__Policy_suppressedVisualEffects")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get suppressedVisualEffects => _getsuppressedVisualEffects(reference);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Int32, ffi.Int32,
                  ffi.Int32)>>("android_app_NotificationManager__Policy_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int)>();

  /// from: public void <init>(int priorityCategories, int priorityCallSenders, int priorityMessageSenders)
  /// Constructs a policy for Do Not Disturb priority mode behavior.
  ///
  ///
  ///     Apps that target API levels below Build.VERSION_CODES\#P cannot
  ///     change user-designated values to allow or disallow
  ///     Policy\#PRIORITY_CATEGORY_ALARMS, Policy\#PRIORITY_CATEGORY_SYSTEM, and
  ///     Policy\#PRIORITY_CATEGORY_MEDIA from bypassing dnd.
  ///@param priorityCategories bitmask of categories of notifications that can bypass DND.
  ///@param priorityCallSenders which callers can bypass DND.
  ///@param priorityMessageSenders which message senders can bypass DND.
  NotificationManager_Policy(int priorityCategories, int priorityCallSenders,
      int priorityMessageSenders)
      : super.fromRef(_ctor(
            priorityCategories, priorityCallSenders, priorityMessageSenders));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Int32, ffi.Int32, ffi.Int32,
                  ffi.Int32)>>("android_app_NotificationManager__Policy_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int, int)>();

  /// from: public void <init>(int priorityCategories, int priorityCallSenders, int priorityMessageSenders, int suppressedVisualEffects)
  /// Constructs a policy for Do Not Disturb priority mode behavior.
  ///
  ///
  ///     Apps that target API levels below Build.VERSION_CODES\#P cannot
  ///     change user-designated values to allow or disallow
  ///     Policy\#PRIORITY_CATEGORY_ALARMS, Policy\#PRIORITY_CATEGORY_SYSTEM, and
  ///     Policy\#PRIORITY_CATEGORY_MEDIA from bypassing dnd.
  ///
  ///     Additionally, apps that target API levels below Build.VERSION_CODES\#P can
  ///     only modify the \#SUPPRESSED_EFFECT_SCREEN_ON and
  ///     \#SUPPRESSED_EFFECT_SCREEN_OFF bits of the suppressed visual effects field.
  ///     All other suppressed effects will be ignored and reconstituted from the screen on
  ///     and screen off values.
  ///
  ///     Apps that target Build.VERSION_CODES\#P or above can set any
  ///     suppressed visual effects. However, if any suppressed effects >
  ///     \#SUPPRESSED_EFFECT_SCREEN_ON are set, \#SUPPRESSED_EFFECT_SCREEN_ON
  ///     and \#SUPPRESSED_EFFECT_SCREEN_OFF will be ignored and reconstituted from
  ///     the more specific suppressed visual effect bits. Apps should migrate to targeting
  ///     specific effects instead of the deprecated \#SUPPRESSED_EFFECT_SCREEN_ON and
  ///     \#SUPPRESSED_EFFECT_SCREEN_OFF effects.
  ///@param priorityCategories bitmask of categories of notifications that can bypass DND.
  ///@param priorityCallSenders which callers can bypass DND.
  ///@param priorityMessageSenders which message senders can bypass DND.
  ///@param suppressedVisualEffects which visual interruptions should be suppressed from
  ///                                notifications that are filtered by DND.
  NotificationManager_Policy.ctor_1(
      int priorityCategories,
      int priorityCallSenders,
      int priorityMessageSenders,
      int suppressedVisualEffects)
      : super.fromRef(_ctor_1(priorityCategories, priorityCallSenders,
            priorityMessageSenders, suppressedVisualEffects));

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_NotificationManager__Policy_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NotificationManager__Policy_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _hashCode_1 =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NotificationManager__Policy_hashCode_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode_1() => _hashCode_1(reference);

  static final _equals_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager__Policy_equals_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object o)
  bool equals_1(jni.JlObject o) => _equals_1(reference, o.reference) != 0;

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationManager__Policy_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _suppressedEffectsToString = jlookup<
              ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int32)>>(
          "android_app_NotificationManager__Policy_suppressedEffectsToString")
      .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: static public java.lang.String suppressedEffectsToString(int effects)
  static jni.JlString suppressedEffectsToString(int effects) =>
      jni.JlString.fromRef(_suppressedEffectsToString(effects));

  static final _priorityCategoriesToString = jlookup<
              ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int32)>>(
          "android_app_NotificationManager__Policy_priorityCategoriesToString")
      .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: static public java.lang.String priorityCategoriesToString(int priorityCategories)
  static jni.JlString priorityCategoriesToString(int priorityCategories) =>
      jni.JlString.fromRef(_priorityCategoriesToString(priorityCategories));

  static final _prioritySendersToString =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int32)>>(
              "android_app_NotificationManager__Policy_prioritySendersToString")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: static public java.lang.String prioritySendersToString(int prioritySenders)
  static jni.JlString prioritySendersToString(int prioritySenders) =>
      jni.JlString.fromRef(_prioritySendersToString(prioritySenders));
}

/// Base class for presentations.
///
/// A presentation is a special kind of dialog whose purpose is to present
/// content on a secondary display.  A Presentation is associated with
/// the target Display at creation time and configures its context and
/// resource configuration according to the display's metrics.
///
///
/// Notably, the Context of a presentation is different from the context
/// of its containing Activity.  It is important to inflate the layout
/// of a presentation and load other resources using the presentation's own context
/// to ensure that assets of the correct size and density for the target display
/// are loaded.
///
///
/// A presentation is automatically canceled (see Dialog\#cancel()) when
/// the display to which it is attached is removed.  An activity should take
/// care of pausing and resuming whatever content is playing within the presentation
/// whenever the activity itself is paused or resumed.
///
///
///
/// <h3>Choosing a presentation display</h3>
///
/// Before showing a Presentation it's important to choose the Display
/// on which it will appear.  Choosing a presentation display is sometimes difficult
/// because there may be multiple displays attached.  Rather than trying to guess
/// which display is best, an application should let the system choose a suitable
/// presentation display.
///
///
/// There are two main ways to choose a Display.
///
///
///
/// <h4>Using the media router to choose a presentation display</h4>
///
/// The easiest way to choose a presentation display is to use the
/// android.media.MediaRouter MediaRouter API.  The media router service keeps
/// track of which audio and video routes are available on the system.
/// The media router sends notifications whenever routes are selected or unselected
/// or when the preferred presentation display of a route changes.
/// So an application can simply watch for these notifications and show or dismiss
/// a presentation on the preferred presentation display automatically.
///
///
/// The preferred presentation display is the display that the media router recommends
/// that the application should use if it wants to show content on the secondary display.
/// Sometimes there may not be a preferred presentation display in which
/// case the application should show its content locally without using a presentation.
///
///
/// Here's how to use the media router to create and show a presentation on the preferred
/// presentation display using android.media.MediaRouter.RouteInfo\#getPresentationDisplay().
///
///
/// <pre>
/// MediaRouter mediaRouter = (MediaRouter) context.getSystemService(Context.MEDIA_ROUTER_SERVICE);
/// MediaRouter.RouteInfo route = mediaRouter.getSelectedRoute();
/// if (route != null) {
///     Display presentationDisplay = route.getPresentationDisplay();
///     if (presentationDisplay != null) {
///         Presentation presentation = new MyPresentation(context, presentationDisplay);
///         presentation.show();
///     }
/// }</pre>
///
/// The following sample code from <code>ApiDemos</code> demonstrates how to use the media
/// router to automatically switch between showing content in the main activity and showing
/// the content in a presentation when a presentation display is available.
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/PresentationWithMediaRouterActivity.java
///      activity}
///
/// <h4>Using the display manager to choose a presentation display</h4>
///
/// Another way to choose a presentation display is to use the DisplayManager API
/// directly.  The display manager service provides functions to enumerate and describe all
/// displays that are attached to the system including displays that may be used
/// for presentations.
///
///
/// The display manager keeps track of all displays in the system.  However, not all
/// displays are appropriate for showing presentations.  For example, if an activity
/// attempted to show a presentation on the main display it might obscure its own content
/// (it's like opening a dialog on top of your activity).
///
///
/// Here's how to identify suitable displays for showing presentations using
/// DisplayManager\#getDisplays(String) and the
/// DisplayManager\#DISPLAY_CATEGORY_PRESENTATION category.
///
///
/// <pre>
/// DisplayManager displayManager = (DisplayManager) context.getSystemService(Context.DISPLAY_SERVICE);
/// Display[] presentationDisplays = displayManager.getDisplays(DisplayManager.DISPLAY_CATEGORY_PRESENTATION);
/// if (presentationDisplays.length > 0) {
///     // If there is more than one suitable presentation display, then we could consider
///     // giving the user a choice.  For this example, we simply choose the first display
///     // which is the one the system recommends as the preferred presentation display.
///     Display display = presentationDisplays[0];
///     Presentation presentation = new MyPresentation(context, presentationDisplay);
///     presentation.show();
/// }</pre>
///
/// The following sample code from <code>ApiDemos</code> demonstrates how to use the display
/// manager to enumerate displays and show content on multiple presentation displays
/// simultaneously.
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/PresentationActivity.java
///      activity}
///@see android.media.MediaRouter\#ROUTE_TYPE_LIVE_VIDEO for information on about live
/// video routes and how to obtain the preferred presentation display for the
/// current media route.
///@see DisplayManager for information on how to enumerate displays and receive
/// notifications when displays are added or removed.
class Presentation extends Dialog {
  Presentation.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_Presentation_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context outerContext, android.view.Display display)
  /// Creates a new presentation that is attached to the specified display
  /// using the default theme.
  ///@param outerContext The context of the application that is showing the presentation.
  /// The presentation will create its own context (see \#getContext()) based
  /// on this context and information about the associated display.
  ///@param display The display to which the presentation should be attached.
  Presentation(content.Context outerContext, jni.JlObject display)
      : super.fromRef(_ctor(outerContext.reference, display.reference));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Presentation_new_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Context outerContext, android.view.Display display, int theme)
  /// Creates a new presentation that is attached to the specified display
  /// using the optionally specified theme.
  ///@param outerContext The context of the application that is showing the presentation.
  /// The presentation will create its own context (see \#getContext()) based
  /// on this context and information about the associated display.
  ///@param display The display to which the presentation should be attached.
  ///@param theme A style resource describing the theme to use for the window.
  /// See <a href="{@docRoot}guide/topics/resources/available-resources.html\#stylesandthemes">
  /// Style and Theme Resources</a> for more information about defining and using
  /// styles.  This theme is applied on top of the current theme in
  /// <var>outerContext</var>.  If 0, the default presentation theme will be used.
  Presentation.ctor_1(
      content.Context outerContext, jni.JlObject display, int theme)
      : super.fromRef(
            _ctor_1(outerContext.reference, display.reference, theme));

  static final _getDisplay = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Presentation_getDisplay")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.Display getDisplay()
  /// Gets the Display that this presentation appears on.
  ///@return The display.
  jni.JlObject getDisplay() => jni.JlObject.fromRef(_getDisplay(reference));

  static final _getResources = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Presentation_getResources")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.Resources getResources()
  /// Gets the Resources that should be used to inflate the layout of this presentation.
  /// This resources object has been configured according to the metrics of the
  /// display that the presentation appears on.
  ///@return The presentation resources object.
  res.Resources getResources() =>
      res.Resources.fromRef(_getResources(reference));

  static final _onStart =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Presentation_onStart")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStart()
  void onStart() => _onStart(reference);

  static final _onStop =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Presentation_onStop")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStop()
  void onStop() => _onStop(reference);

  static final _show_ =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Presentation_show_")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void show()
  /// Inherited from Dialog\#show. Will throw
  /// android.view.WindowManager.InvalidDisplayException if the specified secondary
  /// Display can't be found.
  void show_() => _show_(reference);

  static final _onDisplayRemoved =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Presentation_onDisplayRemoved")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDisplayRemoved()
  /// Called by the system when the Display to which the presentation
  /// is attached has been removed.
  ///
  /// The system automatically calls \#cancel to dismiss the presentation
  /// after sending this event.
  ///@see \#getDisplay
  void onDisplayRemoved() => _onDisplayRemoved(reference);

  static final _onDisplayChanged =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Presentation_onDisplayChanged")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDisplayChanged()
  /// Called by the system when the properties of the Display to which
  /// the presentation is attached have changed.
  ///
  /// If the display metrics have changed (for example, if the display has been
  /// resized or rotated), then the system automatically calls
  /// \#cancel to dismiss the presentation.
  ///@see \#getDisplay
  void onDisplayChanged() => _onDisplayChanged(reference);
}

/// Specialization of SecurityException that is thrown when authentication is needed from the
/// end user before viewing the content.
///
/// This exception is only appropriate where there is a concrete action the user can take to
/// authorize and make forward progress, such as confirming or entering authentication credentials,
/// or granting access via other means.
/// <p class="note">
/// Note: legacy code that receives this exception may treat it as a general
/// SecurityException, and thus there is no guarantee that the action contained will be
/// invoked by the user.
///
///
class AuthenticationRequiredException extends jni.JlObject {
  AuthenticationRequiredException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.AuthenticationRequiredException> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_AuthenticationRequiredException_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_AuthenticationRequiredException_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.Throwable cause, android.app.PendingIntent userAction)
  /// Create an instance ready to be thrown.
  ///@param cause original cause with details designed for engineering
  ///            audiences.
  ///@param userAction primary action that will initiate the recovery. This
  ///            must launch an activity that is expected to set
  ///            Activity\#setResult(int) before finishing to
  ///            communicate the final status of the recovery. For example,
  ///            apps that observe Activity\#RESULT_OK may choose to
  ///            immediately retry their operation.
  AuthenticationRequiredException(jni.JlObject cause, PendingIntent userAction)
      : super.fromRef(_ctor(cause.reference, userAction.reference));

  static final _getUserAction = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_AuthenticationRequiredException_getUserAction")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent getUserAction()
  /// Return primary action that will initiate the authorization.
  PendingIntent getUserAction() =>
      PendingIntent.fromRef(_getUserAction(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_AuthenticationRequiredException_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_AuthenticationRequiredException_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);
}

/// This class provides access to the system uimode services.  These services
/// allow applications to control UI modes of the device.
/// It provides functionality to disable the car mode and it gives access to the
/// night mode settings.
///
/// These facilities are built on top of the underlying
/// android.content.Intent\#ACTION_DOCK_EVENT broadcasts that are sent when the user
/// physical places the device into and out of a dock.  When that happens,
/// the UiModeManager switches the system android.content.res.Configuration
/// to the appropriate UI mode, sends broadcasts about the mode switch, and
/// starts the corresponding mode activity if appropriate.  See the
/// broadcasts \#ACTION_ENTER_CAR_MODE and
/// \#ACTION_ENTER_DESK_MODE for more information.
///
/// In addition, the user may manually switch the system to car mode without
/// physically being in a dock.  While in car mode -- whether by manual action
/// from the user or being physically placed in a dock -- a notification is
/// displayed allowing the user to exit dock mode.  Thus the dock mode
/// represented here may be different than the current state of the underlying
/// dock event broadcast.
class UiModeManager extends jni.JlObject {
  UiModeManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public java.lang.String ACTION_ENTER_CAR_MODE
  /// Broadcast sent when the device's UI has switched to car mode, either
  /// by being placed in a car dock or explicit action of the user.  After
  /// sending the broadcast, the system will start the intent
  /// android.content.Intent\#ACTION_MAIN with category
  /// android.content.Intent\#CATEGORY_CAR_DOCK
  /// to display the car UI, which typically what an application would
  /// implement to provide their own interface.  However, applications can
  /// also monitor this Intent in order to be informed of mode changes or
  /// prevent the normal car UI from being displayed by setting the result
  /// of the broadcast to Activity\#RESULT_CANCELED.
  static final _getACTION_ENTER_CAR_MODE =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_UiModeManager_ACTION_ENTER_CAR_MODE")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get ACTION_ENTER_CAR_MODE =>
      jni.JlString.fromRef(_getACTION_ENTER_CAR_MODE());
  static final _setACTION_ENTER_CAR_MODE =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "set_android_app_UiModeManager_ACTION_ENTER_CAR_MODE")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();
  static set ACTION_ENTER_CAR_MODE(jni.JlString value) =>
      _setACTION_ENTER_CAR_MODE(value.reference);

  /// from: static public java.lang.String ACTION_ENTER_DESK_MODE
  /// Broadcast sent when the device's UI has switched to desk mode,
  /// by being placed in a desk dock.  After
  /// sending the broadcast, the system will start the intent
  /// android.content.Intent\#ACTION_MAIN with category
  /// android.content.Intent\#CATEGORY_DESK_DOCK
  /// to display the desk UI, which typically what an application would
  /// implement to provide their own interface.  However, applications can
  /// also monitor this Intent in order to be informed of mode changes or
  /// prevent the normal desk UI from being displayed by setting the result
  /// of the broadcast to Activity\#RESULT_CANCELED.
  static final _getACTION_ENTER_DESK_MODE =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_UiModeManager_ACTION_ENTER_DESK_MODE")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get ACTION_ENTER_DESK_MODE =>
      jni.JlString.fromRef(_getACTION_ENTER_DESK_MODE());
  static final _setACTION_ENTER_DESK_MODE =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "set_android_app_UiModeManager_ACTION_ENTER_DESK_MODE")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();
  static set ACTION_ENTER_DESK_MODE(jni.JlString value) =>
      _setACTION_ENTER_DESK_MODE(value.reference);

  /// from: static public java.lang.String ACTION_EXIT_CAR_MODE
  /// Broadcast sent when the device's UI has switch away from car mode back
  /// to normal mode.  Typically used by a car mode app, to dismiss itself
  /// when the user exits car mode.
  static final _getACTION_EXIT_CAR_MODE =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_UiModeManager_ACTION_EXIT_CAR_MODE")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get ACTION_EXIT_CAR_MODE =>
      jni.JlString.fromRef(_getACTION_EXIT_CAR_MODE());
  static final _setACTION_EXIT_CAR_MODE =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "set_android_app_UiModeManager_ACTION_EXIT_CAR_MODE")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();
  static set ACTION_EXIT_CAR_MODE(jni.JlString value) =>
      _setACTION_EXIT_CAR_MODE(value.reference);

  /// from: static public java.lang.String ACTION_EXIT_DESK_MODE
  /// Broadcast sent when the device's UI has switched away from desk mode back
  /// to normal mode.  Typically used by a desk mode app, to dismiss itself
  /// when the user exits desk mode.
  static final _getACTION_EXIT_DESK_MODE =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_UiModeManager_ACTION_EXIT_DESK_MODE")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get ACTION_EXIT_DESK_MODE =>
      jni.JlString.fromRef(_getACTION_EXIT_DESK_MODE());
  static final _setACTION_EXIT_DESK_MODE =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "set_android_app_UiModeManager_ACTION_EXIT_DESK_MODE")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();
  static set ACTION_EXIT_DESK_MODE(jni.JlString value) =>
      _setACTION_EXIT_DESK_MODE(value.reference);

  /// from: static public final int DISABLE_CAR_MODE_GO_HOME
  /// Flag for use with \#disableCarMode(int): go to the normal
  /// home activity as part of the disable.  Disabling this way ensures
  /// a clean transition between the current activity (in car mode) and
  /// the original home activity (which was typically last running without
  /// being in car mode).
  static const DISABLE_CAR_MODE_GO_HOME = 1;

  /// from: static public final int ENABLE_CAR_MODE_ALLOW_SLEEP
  /// Flag for use with \#enableCarMode(int): allow sleep mode while in car mode.
  /// By default, when this flag is not set, the system may hold a full wake lock to keep the
  /// screen turned on and prevent the system from entering sleep mode while in car mode.
  /// Setting this flag disables such behavior and the system may enter sleep mode
  /// if there is no other user activity and no other wake lock held.
  /// Setting this flag can be relevant for a car dock application that does not require the
  /// screen kept on.
  static const ENABLE_CAR_MODE_ALLOW_SLEEP = 2;

  /// from: static public final int ENABLE_CAR_MODE_GO_CAR_HOME
  /// Flag for use with \#enableCarMode(int): go to the car
  /// home activity as part of the enable.  Enabling this way ensures
  /// a clean transition between the current activity (in non-car-mode) and
  /// the car home activity that will serve as home while in car mode.  This
  /// will switch to the car home activity even if we are already in car mode.
  static const ENABLE_CAR_MODE_GO_CAR_HOME = 1;

  /// from: static public final int MODE_NIGHT_AUTO
  /// Constant for \#setNightMode(int) and \#getNightMode():
  /// automatically switch night mode on and off based on the time.
  static const MODE_NIGHT_AUTO = 0;

  /// from: static public final int MODE_NIGHT_NO
  /// Constant for \#setNightMode(int) and \#getNightMode():
  /// never run in night mode.
  static const MODE_NIGHT_NO = 1;

  /// from: static public final int MODE_NIGHT_YES
  /// Constant for \#setNightMode(int) and \#getNightMode():
  /// always run in night mode.
  static const MODE_NIGHT_YES = 2;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_UiModeManager_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  UiModeManager() : super.fromRef(_ctor());

  static final _enableCarMode = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_UiModeManager_enableCarMode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void enableCarMode(int flags)
  /// Force device into car mode, like it had been placed in the car dock.
  /// This will cause the device to switch to the car home UI as part of
  /// the mode switch.
  ///@param flags Must be 0.
  void enableCarMode(int flags) => _enableCarMode(reference, flags);

  static final _disableCarMode = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_UiModeManager_disableCarMode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void disableCarMode(int flags)
  /// Turn off special mode if currently in car mode.
  ///@param flags May be 0 or \#DISABLE_CAR_MODE_GO_HOME.
  void disableCarMode(int flags) => _disableCarMode(reference, flags);

  static final _getCurrentModeType =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_UiModeManager_getCurrentModeType")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getCurrentModeType()
  /// Return the current running mode type.  May be one of
  /// Configuration\#UI_MODE_TYPE_NORMAL Configuration.UI_MODE_TYPE_NORMAL,
  /// Configuration\#UI_MODE_TYPE_DESK Configuration.UI_MODE_TYPE_DESK,
  /// Configuration\#UI_MODE_TYPE_CAR Configuration.UI_MODE_TYPE_CAR,
  /// Configuration\#UI_MODE_TYPE_TELEVISION Configuration.UI_MODE_TYPE_TELEVISION,
  /// Configuration\#UI_MODE_TYPE_APPLIANCE Configuration.UI_MODE_TYPE_APPLIANCE,
  /// Configuration\#UI_MODE_TYPE_WATCH Configuration.UI_MODE_TYPE_WATCH, or
  /// Configuration\#UI_MODE_TYPE_VR_HEADSET Configuration.UI_MODE_TYPE_VR_HEADSET.
  int getCurrentModeType() => _getCurrentModeType(reference);

  static final _setNightMode = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_UiModeManager_setNightMode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setNightMode(int mode)
  /// Sets the night mode.
  ///
  /// The mode can be one of:
  /// <ul>
  ///   <li>_\#MODE_NIGHT_NO_ sets the device into
  ///       {@code notnight} mode</li>
  ///   <li>_\#MODE_NIGHT_YES_ sets the device into
  ///       {@code night} mode</li>
  ///   <li>_\#MODE_NIGHT_AUTO_ automatically switches between
  ///       {@code night} and {@code notnight} based on the device's current
  ///       location and certain other sensors</li>
  /// </ul>
  ///
  /// <strong>Note:</strong> On API 22 and below, changes to the night mode
  /// are only effective when the Configuration\#UI_MODE_TYPE_CAR car
  /// or Configuration\#UI_MODE_TYPE_DESK desk mode is enabled on a
  /// device. Starting in API 23, changes to night mode are always effective.
  ///@param mode the night mode to set
  /// Value is android.app.UiModeManager\#MODE_NIGHT_AUTO, android.app.UiModeManager\#MODE_NIGHT_NO, or android.app.UiModeManager\#MODE_NIGHT_YES
  ///@see \#getNightMode()
  void setNightMode(int mode) => _setNightMode(reference, mode);

  static final _getNightMode =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_UiModeManager_getNightMode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getNightMode()
  /// Returns the currently configured night mode.
  ///
  /// May be one of:
  /// <ul>
  ///   <li>\#MODE_NIGHT_NO</li>
  ///   <li>\#MODE_NIGHT_YES</li>
  ///   <li>\#MODE_NIGHT_AUTO</li>
  ///   <li>{@code -1} on error</li>
  /// </ul>
  ///@return the current night mode, or {@code -1} on error
  /// Value is android.app.UiModeManager\#MODE_NIGHT_AUTO, android.app.UiModeManager\#MODE_NIGHT_NO, or android.app.UiModeManager\#MODE_NIGHT_YES
  ///@see \#setNightMode(int)
  int getNightMode() => _getNightMode(reference);
}

/// A grouping of related notification channels. e.g., channels that all belong to a single account.
class NotificationChannelGroup extends jni.JlObject {
  NotificationChannelGroup.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.NotificationChannelGroup> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_NotificationChannelGroup_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannelGroup_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String id, java.lang.CharSequence name)
  /// Creates a notification channel group.
  ///@param id The id of the group. Must be unique per package.  the value may be truncated if
  ///           it is too long.
  ///@param name The user visible name of the group. You can rename this group when the system
  ///             locale changes by listening for the Intent\#ACTION_LOCALE_CHANGED
  ///             broadcast. The recommended maximum length is 40 characters; the value may be
  ///             truncated if it is too long.
  NotificationChannelGroup(jni.JlString id, jni.JlObject name)
      : super.fromRef(_ctor(id.reference, name.reference));

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_NotificationChannelGroup_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _getId = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannelGroup_getId")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getId()
  /// Returns the id of this group.
  jni.JlString getId() => jni.JlString.fromRef(_getId(reference));

  static final _getName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannelGroup_getName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getName()
  /// Returns the user visible name of this group.
  jni.JlObject getName() => jni.JlObject.fromRef(_getName(reference));

  static final _getDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannelGroup_getDescription")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getDescription()
  /// Returns the user visible description of this group.
  jni.JlString getDescription() =>
      jni.JlString.fromRef(_getDescription(reference));

  static final _getChannels = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannelGroup_getChannels")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.NotificationChannel> getChannels()
  /// Returns the list of channels that belong to this group
  jni.JlObject getChannels() => jni.JlObject.fromRef(_getChannels(reference));

  static final _isBlocked =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NotificationChannelGroup_isBlocked")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isBlocked()
  /// Returns whether or not notifications posted to NotificationChannel channels belonging
  /// to this group are blocked. This value is independent of
  /// NotificationManager\#areNotificationsEnabled() and
  /// NotificationChannel\#getImportance().
  bool isBlocked() => _isBlocked(reference) != 0;

  static final _setDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannelGroup_setDescription")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setDescription(java.lang.String description)
  /// Sets the user visible description of this group.
  ///
  /// The recommended maximum length is 300 characters; the value may be truncated if it is too
  /// long.
  void setDescription(jni.JlString description) =>
      _setDescription(reference, description.reference);

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NotificationChannelGroup_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _equals_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannelGroup_equals_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object o)
  bool equals_1(jni.JlObject o) => _equals_1(reference, o.reference) != 0;

  static final _hashCode_1 =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NotificationChannelGroup_hashCode_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode_1() => _hashCode_1(reference);

  static final _clone = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannelGroup_clone")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.NotificationChannelGroup clone()
  NotificationChannelGroup clone() =>
      NotificationChannelGroup.fromRef(_clone(reference));

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannelGroup_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));
}

/// A simple dialog containing an android.widget.DatePicker.
///
/// See the <a href="{@docRoot}guide/topics/ui/controls/pickers.html">Pickers</a>
/// guide.
class DatePickerDialog extends AlertDialog {
  DatePickerDialog.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_DatePickerDialog_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  /// Creates a new date picker dialog for the current date using the parent
  /// context's default date picker dialog theme.
  ///@param context the parent context
  ///
  /// This value must never be {@code null}.
  DatePickerDialog(content.Context context)
      : super.fromRef(_ctor(context.reference));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_DatePickerDialog_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Context context, int themeResId)
  /// Creates a new date picker dialog for the current date.
  ///@param context the parent context
  /// This value must never be {@code null}.
  ///@param themeResId the resource ID of the theme against which to inflate
  ///                   this dialog, or {@code 0} to use the parent
  ///                   {@code context}'s default alert dialog theme
  DatePickerDialog.ctor_1(content.Context context, int themeResId)
      : super.fromRef(_ctor_1(context.reference, themeResId));

  static final _ctor_2 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("android_app_DatePickerDialog_new_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void <init>(android.content.Context context, android.app.DatePickerDialog.OnDateSetListener listener, int year, int month, int dayOfMonth)
  /// Creates a new date picker dialog for the specified date using the parent
  /// context's default date picker dialog theme.
  ///@param context the parent context
  /// This value must never be {@code null}.
  ///@param listener the listener to call when the user sets the date
  /// This value may be {@code null}.
  ///@param year the initially selected year
  ///@param month the initially selected month (0-11 for compatibility with
  ///              Calendar\#MONTH)
  ///@param dayOfMonth the initially selected day of month (1-31, depending
  ///                   on month)
  DatePickerDialog.ctor_2(
      content.Context context,
      DatePickerDialog_OnDateSetListener listener,
      int year,
      int month,
      int dayOfMonth)
      : super.fromRef(_ctor_2(
            context.reference, listener.reference, year, month, dayOfMonth));

  static final _ctor_3 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("android_app_DatePickerDialog_new_3")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void <init>(android.content.Context context, int themeResId, android.app.DatePickerDialog.OnDateSetListener listener, int year, int monthOfYear, int dayOfMonth)
  /// Creates a new date picker dialog for the specified date.
  ///@param context the parent context
  /// This value must never be {@code null}.
  ///@param themeResId the resource ID of the theme against which to inflate
  ///                   this dialog, or {@code 0} to use the parent
  ///                   {@code context}'s default alert dialog theme
  ///@param listener the listener to call when the user sets the date
  /// This value may be {@code null}.
  ///@param year the initially selected year
  ///@param monthOfYear the initially selected month of the year (0-11 for
  ///                    compatibility with Calendar\#MONTH)
  ///@param dayOfMonth the initially selected day of month (1-31, depending
  ///                   on month)
  DatePickerDialog.ctor_3(
      content.Context context,
      int themeResId,
      DatePickerDialog_OnDateSetListener listener,
      int year,
      int monthOfYear,
      int dayOfMonth)
      : super.fromRef(_ctor_3(context.reference, themeResId, listener.reference,
            year, monthOfYear, dayOfMonth));

  static final _onDateChanged = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("android_app_DatePickerDialog_onDateChanged")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void onDateChanged(android.widget.DatePicker view, int year, int month, int dayOfMonth)
  /// @param view This value must never be {@code null}.
  void onDateChanged(jni.JlObject view, int year, int month, int dayOfMonth) =>
      _onDateChanged(reference, view.reference, year, month, dayOfMonth);

  static final _setOnDateSetListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_DatePickerDialog_setOnDateSetListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnDateSetListener(android.app.DatePickerDialog.OnDateSetListener listener)
  /// Sets the listener to call when the user sets the date.
  ///@param listener the listener to call when the user sets the date
  ///
  /// This value may be {@code null}.
  void setOnDateSetListener(DatePickerDialog_OnDateSetListener listener) =>
      _setOnDateSetListener(reference, listener.reference);

  static final _onClick = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_DatePickerDialog_onClick")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onClick(android.content.DialogInterface dialog, int which)
  /// @param dialog This value must never be {@code null}.
  void onClick(content.DialogInterface dialog, int which) =>
      _onClick(reference, dialog.reference, which);

  static final _getDatePicker = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_DatePickerDialog_getDatePicker")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.DatePicker getDatePicker()
  /// Returns the DatePicker contained in this dialog.
  ///@return the date picker
  ///
  /// This value will never be {@code null}.
  jni.JlObject getDatePicker() =>
      jni.JlObject.fromRef(_getDatePicker(reference));

  static final _updateDate = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32,
                  ffi.Int32)>>("android_app_DatePickerDialog_updateDate")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void updateDate(int year, int month, int dayOfMonth)
  /// Sets the current date.
  ///@param year the year
  ///@param month the month (0-11 for compatibility with
  ///              Calendar\#MONTH)
  ///@param dayOfMonth the day of month (1-31, depending on month)
  void updateDate(int year, int month, int dayOfMonth) =>
      _updateDate(reference, year, month, dayOfMonth);

  static final _onSaveInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_DatePickerDialog_onSaveInstanceState")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle onSaveInstanceState()
  os.Bundle onSaveInstanceState() =>
      os.Bundle.fromRef(_onSaveInstanceState(reference));

  static final _onRestoreInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_DatePickerDialog_onRestoreInstanceState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onRestoreInstanceState(android.os.Bundle savedInstanceState)
  void onRestoreInstanceState(os.Bundle savedInstanceState) =>
      _onRestoreInstanceState(reference, savedInstanceState.reference);
}

/// The listener used to indicate the user has finished selecting a date.
class DatePickerDialog_OnDateSetListener extends jni.JlObject {
  DatePickerDialog_OnDateSetListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onDateSet = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32, ffi.Int32)>>(
          "android_app_DatePickerDialog__OnDateSetListener_onDateSet")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public abstract void onDateSet(android.widget.DatePicker view, int year, int month, int dayOfMonth)
  /// @param view the picker associated with the dialog
  ///@param year the selected year
  ///@param month the selected month (0-11 for compatibility with
  ///              Calendar\#MONTH)
  ///@param dayOfMonth th selected day of the month (1-31, depending on
  ///                   month)
  void onDateSet(jni.JlObject view, int year, int month, int dayOfMonth) =>
      _onDateSet(reference, view.reference, year, month, dayOfMonth);
}

/// A dialog that prompts the user for the time of day using a
/// TimePicker.
///
///
/// See the <a href="{@docRoot}guide/topics/ui/controls/pickers.html">Pickers</a>
/// guide.
class TimePickerDialog extends AlertDialog {
  TimePickerDialog.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Uint8)>>("android_app_TimePickerDialog_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void <init>(android.content.Context context, android.app.TimePickerDialog.OnTimeSetListener listener, int hourOfDay, int minute, boolean is24HourView)
  /// Creates a new time picker dialog.
  ///@param context the parent context
  ///@param listener the listener to call when the time is set
  ///@param hourOfDay the initial hour
  ///@param minute the initial minute
  ///@param is24HourView whether this is a 24 hour view or AM/PM
  TimePickerDialog(
      content.Context context,
      TimePickerDialog_OnTimeSetListener listener,
      int hourOfDay,
      int minute,
      bool is24HourView)
      : super.fromRef(_ctor(context.reference, listener.reference, hourOfDay,
            minute, is24HourView ? 1 : 0));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Uint8)>>("android_app_TimePickerDialog_new_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void <init>(android.content.Context context, int themeResId, android.app.TimePickerDialog.OnTimeSetListener listener, int hourOfDay, int minute, boolean is24HourView)
  /// Creates a new time picker dialog with the specified theme.
  ///
  /// The theme is overlaid on top of the theme of the parent {@code context}.
  /// If {@code themeResId} is 0, the dialog will be inflated using the theme
  /// specified by the
  /// android.R.attr\#timePickerDialogTheme android:timePickerDialogTheme
  /// attribute on the parent {@code context}'s theme.
  ///@param context the parent context
  ///@param themeResId the resource ID of the theme to apply to this dialog
  ///@param listener the listener to call when the time is set
  ///@param hourOfDay the initial hour
  ///@param minute the initial minute
  ///@param is24HourView Whether this is a 24 hour view, or AM/PM.
  TimePickerDialog.ctor_1(
      content.Context context,
      int themeResId,
      TimePickerDialog_OnTimeSetListener listener,
      int hourOfDay,
      int minute,
      bool is24HourView)
      : super.fromRef(_ctor_1(context.reference, themeResId, listener.reference,
            hourOfDay, minute, is24HourView ? 1 : 0));

  static final _onTimeChanged = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32)>>("android_app_TimePickerDialog_onTimeChanged")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void onTimeChanged(android.widget.TimePicker view, int hourOfDay, int minute)
  void onTimeChanged(jni.JlObject view, int hourOfDay, int minute) =>
      _onTimeChanged(reference, view.reference, hourOfDay, minute);

  static final _show_ =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_TimePickerDialog_show_")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void show()
  void show_() => _show_(reference);

  static final _onClick = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_TimePickerDialog_onClick")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onClick(android.content.DialogInterface dialog, int which)
  void onClick(content.DialogInterface dialog, int which) =>
      _onClick(reference, dialog.reference, which);

  static final _updateTime = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_app_TimePickerDialog_updateTime")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void updateTime(int hourOfDay, int minuteOfHour)
  /// Sets the current time.
  ///@param hourOfDay The current hour within the day.
  ///@param minuteOfHour The current minute within the hour.
  void updateTime(int hourOfDay, int minuteOfHour) =>
      _updateTime(reference, hourOfDay, minuteOfHour);

  static final _onSaveInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_TimePickerDialog_onSaveInstanceState")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle onSaveInstanceState()
  os.Bundle onSaveInstanceState() =>
      os.Bundle.fromRef(_onSaveInstanceState(reference));

  static final _onRestoreInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_TimePickerDialog_onRestoreInstanceState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onRestoreInstanceState(android.os.Bundle savedInstanceState)
  void onRestoreInstanceState(os.Bundle savedInstanceState) =>
      _onRestoreInstanceState(reference, savedInstanceState.reference);
}

/// The callback interface used to indicate the user is done filling in
/// the time (e.g.&nbsp;they clicked on the 'OK' button).
class TimePickerDialog_OnTimeSetListener extends jni.JlObject {
  TimePickerDialog_OnTimeSetListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onTimeSet = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_app_TimePickerDialog__OnTimeSetListener_onTimeSet")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void onTimeSet(android.widget.TimePicker view, int hourOfDay, int minute)
  /// Called when the user is done setting a new time and the dialog has
  /// closed.
  ///@param view the view associated with this listener
  ///@param hourOfDay the hour that was set
  ///@param minute the minute that was set
  void onTimeSet(jni.JlObject view, int hourOfDay, int minute) =>
      _onTimeSet(reference, view.reference, hourOfDay, minute);
}

/// A fragment that displays a dialog window, floating on top of its
/// activity's window.  This fragment contains a Dialog object, which it
/// displays as appropriate based on the fragment's state.  Control of
/// the dialog (deciding when to show, hide, dismiss it) should be done through
/// the API here, not with direct calls on the dialog.
///
/// Implementations should override this class and implement
/// \#onCreateView(LayoutInflater, ViewGroup, Bundle) to supply the
/// content of the dialog.  Alternatively, they can override
/// \#onCreateDialog(Bundle) to create an entirely custom dialog, such
/// as an AlertDialog, with its own content.
///
/// Topics covered here:
/// <ol>
/// <li><a href="\#Lifecycle">Lifecycle</a>
/// <li><a href="\#BasicDialog">Basic Dialog</a>
/// <li><a href="\#AlertDialog">Alert Dialog</a>
/// <li><a href="\#DialogOrEmbed">Selecting Between Dialog or Embedding</a>
/// </ol>
///
/// <a name="Lifecycle"></a>
/// <h3>Lifecycle</h3>
///
/// DialogFragment does various things to keep the fragment's lifecycle
/// driving it, instead of the Dialog.  Note that dialogs are generally
/// autonomous entities -- they are their own window, receiving their own
/// input events, and often deciding on their own when to disappear (by
/// receiving a back key event or the user clicking on a button).
///
/// DialogFragment needs to ensure that what is happening with the Fragment
/// and Dialog states remains consistent.  To do this, it watches for dismiss
/// events from the dialog and takes care of removing its own state when they
/// happen.  This means you should use \#show(FragmentManager, String)
/// or \#show(FragmentTransaction, String) to add an instance of
/// DialogFragment to your UI, as these keep track of how DialogFragment should
/// remove itself when the dialog is dismissed.
///
/// <a name="BasicDialog"></a>
/// <h3>Basic Dialog</h3>
///
/// The simplest use of DialogFragment is as a floating container for the
/// fragment's view hierarchy.  A simple implementation may look like this:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentDialog.java
///      dialog}
///
/// An example showDialog() method on the Activity could be:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentDialog.java
///      add_dialog}
///
/// This removes any currently shown dialog, creates a new DialogFragment
/// with an argument, and shows it as a new state on the back stack.  When the
/// transaction is popped, the current DialogFragment and its Dialog will be
/// destroyed, and the previous one (if any) re-shown.  Note that in this case
/// DialogFragment will take care of popping the transaction of the Dialog
/// is dismissed separately from it.
///
/// <a name="AlertDialog"></a>
/// <h3>Alert Dialog</h3>
///
/// Instead of (or in addition to) implementing \#onCreateView to
/// generate the view hierarchy inside of a dialog, you may implement
/// \#onCreateDialog(Bundle) to create your own custom Dialog object.
///
/// This is most useful for creating an AlertDialog, allowing you
/// to display standard alerts to the user that are managed by a fragment.
/// A simple example implementation of this is:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentAlertDialog.java
///      dialog}
///
/// The activity creating this fragment may have the following methods to
/// show the dialog and receive results from it:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentAlertDialog.java
///      activity}
///
/// Note that in this case the fragment is not placed on the back stack, it
/// is just added as an indefinitely running fragment.  Because dialogs normally
/// are modal, this will still operate as a back stack, since the dialog will
/// capture user input until it is dismissed.  When it is dismissed, DialogFragment
/// will take care of removing itself from its fragment manager.
///
/// <a name="DialogOrEmbed"></a>
/// <h3>Selecting Between Dialog or Embedding</h3>
///
/// A DialogFragment can still optionally be used as a normal fragment, if
/// desired.  This is useful if you have a fragment that in some cases should
/// be shown as a dialog and others embedded in a larger UI.  This behavior
/// will normally be automatically selected for you based on how you are using
/// the fragment, but can be customized with \#setShowsDialog(boolean).
///
/// For example, here is a simple dialog fragment:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentDialogOrActivity.java
///      dialog}
///
/// An instance of this fragment can be created and shown as a dialog:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentDialogOrActivity.java
///      show_dialog}
///
/// It can also be added as content in a view hierarchy:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentDialogOrActivity.java
///      embed}
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.DialogFragment for consistent behavior across all devices
///      and access to <a href="{@docRoot}topic/libraries/architecture/lifecycle.html">Lifecycle</a>.
class DialogFragment extends Fragment {
  DialogFragment.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int STYLE_NORMAL
  /// Style for \#setStyle(int, int): a basic,
  /// normal dialog.
  static const STYLE_NORMAL = 0;

  /// from: static public final int STYLE_NO_FRAME
  /// Style for \#setStyle(int, int): don't draw
  /// any frame at all; the view hierarchy returned by \#onCreateView
  /// is entirely responsible for drawing the dialog.
  static const STYLE_NO_FRAME = 2;

  /// from: static public final int STYLE_NO_INPUT
  /// Style for \#setStyle(int, int): like
  /// \#STYLE_NO_FRAME, but also disables all input to the dialog.
  /// The user can not touch it, and its window will not receive input focus.
  static const STYLE_NO_INPUT = 3;

  /// from: static public final int STYLE_NO_TITLE
  /// Style for \#setStyle(int, int): don't include
  /// a title area.
  static const STYLE_NO_TITLE = 1;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_DialogFragment_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  DialogFragment() : super.fromRef(_ctor());

  static final _setStyle = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_app_DialogFragment_setStyle")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void setStyle(int style, int theme)
  /// Call to customize the basic appearance and behavior of the
  /// fragment's dialog.  This can be used for some common dialog behaviors,
  /// taking care of selecting flags, theme, and other options for you.  The
  /// same effect can be achieve by manually setting Dialog and Window
  /// attributes yourself.  Calling this after the fragment's Dialog is
  /// created will have no effect.
  ///@param style Selects a standard style: may be \#STYLE_NORMAL,
  /// \#STYLE_NO_TITLE, \#STYLE_NO_FRAME, or
  /// \#STYLE_NO_INPUT.
  ///@param theme Optional custom theme.  If 0, an appropriate theme (based
  /// on the style) will be selected for you.
  void setStyle(int style, int theme) => _setStyle(reference, style, theme);

  static final _show_ = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_DialogFragment_show_")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void show(android.app.FragmentManager manager, java.lang.String tag)
  /// Display the dialog, adding the fragment to the given FragmentManager.  This
  /// is a convenience for explicitly creating a transaction, adding the
  /// fragment to it with the given tag, and committing it.  This does
  /// _not_ add the transaction to the back stack.  When the fragment
  /// is dismissed, a new transaction will be executed to remove it from
  /// the activity.
  ///@param manager The FragmentManager this fragment will be added to.
  ///@param tag The tag for this fragment, as per
  /// FragmentTransaction\#add(Fragment, String) FragmentTransaction.add.
  void show_(FragmentManager manager, jni.JlString tag) =>
      _show_(reference, manager.reference, tag.reference);

  static final _show__1 = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_DialogFragment_show__1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int show(android.app.FragmentTransaction transaction, java.lang.String tag)
  /// Display the dialog, adding the fragment using an existing transaction
  /// and then committing the transaction.
  ///@param transaction An existing transaction in which to add the fragment.
  ///@param tag The tag for this fragment, as per
  /// FragmentTransaction\#add(Fragment, String) FragmentTransaction.add.
  ///@return Returns the identifier of the committed transaction, as per
  /// FragmentTransaction\#commit() FragmentTransaction.commit().
  int show__1(FragmentTransaction transaction, jni.JlString tag) =>
      _show__1(reference, transaction.reference, tag.reference);

  static final _dismiss =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_DialogFragment_dismiss")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dismiss()
  /// Dismiss the fragment and its dialog.  If the fragment was added to the
  /// back stack, all back stack state up to and including this entry will
  /// be popped.  Otherwise, a new transaction will be committed to remove
  /// the fragment.
  void dismiss() => _dismiss(reference);

  static final _dismissAllowingStateLoss =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_DialogFragment_dismissAllowingStateLoss")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dismissAllowingStateLoss()
  /// Version of \#dismiss() that uses
  /// FragmentTransaction\#commitAllowingStateLoss() FragmentTransaction.commitAllowingStateLoss().  See linked
  /// documentation for further details.
  void dismissAllowingStateLoss() => _dismissAllowingStateLoss(reference);

  static final _getDialog = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_DialogFragment_getDialog")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Dialog getDialog()
  Dialog getDialog() => Dialog.fromRef(_getDialog(reference));

  static final _getTheme =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_DialogFragment_getTheme")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getTheme()
  int getTheme() => _getTheme(reference);

  static final _setCancelable = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_DialogFragment_setCancelable")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setCancelable(boolean cancelable)
  /// Control whether the shown Dialog is cancelable.  Use this instead of
  /// directly calling Dialog\#setCancelable(boolean) Dialog.setCancelable(boolean), because DialogFragment needs to change
  /// its behavior based on this.
  ///@param cancelable If true, the dialog is cancelable.  The default
  /// is true.
  void setCancelable(bool cancelable) =>
      _setCancelable(reference, cancelable ? 1 : 0);

  static final _isCancelable =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_DialogFragment_isCancelable")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isCancelable()
  /// Return the current value of \#setCancelable(boolean).
  bool isCancelable() => _isCancelable(reference) != 0;

  static final _setShowsDialog = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_DialogFragment_setShowsDialog")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setShowsDialog(boolean showsDialog)
  /// Controls whether this fragment should be shown in a dialog.  If not
  /// set, no Dialog will be created in \#onActivityCreated(Bundle),
  /// and the fragment's view hierarchy will thus not be added to it.  This
  /// allows you to instead use it as a normal fragment (embedded inside of
  /// its activity).
  ///
  /// This is normally set for you based on whether the fragment is
  /// associated with a container view ID passed to
  /// FragmentTransaction\#add(int, Fragment) FragmentTransaction.add(int, Fragment).
  /// If the fragment was added with a container, setShowsDialog will be
  /// initialized to false; otherwise, it will be true.
  ///@param showsDialog If true, the fragment will be displayed in a Dialog.
  /// If false, no Dialog will be created and the fragment's view hierarchly
  /// left undisturbed.
  void setShowsDialog(bool showsDialog) =>
      _setShowsDialog(reference, showsDialog ? 1 : 0);

  static final _getShowsDialog =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_DialogFragment_getShowsDialog")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getShowsDialog()
  /// Return the current value of \#setShowsDialog(boolean).
  bool getShowsDialog() => _getShowsDialog(reference) != 0;

  static final _onAttach = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_DialogFragment_onAttach")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttach(android.content.Context context)
  void onAttach(content.Context context) =>
      _onAttach(reference, context.reference);

  static final _onDetach =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_DialogFragment_onDetach")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDetach()
  void onDetach() => _onDetach(reference);

  static final _onCreate = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_DialogFragment_onCreate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreate(android.os.Bundle savedInstanceState)
  void onCreate(os.Bundle savedInstanceState) =>
      _onCreate(reference, savedInstanceState.reference);

  static final _onGetLayoutInflater = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_DialogFragment_onGetLayoutInflater")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.LayoutInflater onGetLayoutInflater(android.os.Bundle savedInstanceState)
  /// @hide
  jni.JlObject onGetLayoutInflater(os.Bundle savedInstanceState) =>
      jni.JlObject.fromRef(
          _onGetLayoutInflater(reference, savedInstanceState.reference));

  static final _onCreateDialog = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_DialogFragment_onCreateDialog")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Dialog onCreateDialog(android.os.Bundle savedInstanceState)
  /// Override to build your own custom Dialog container.  This is typically
  /// used to show an AlertDialog instead of a generic Dialog; when doing so,
  /// \#onCreateView(LayoutInflater, ViewGroup, Bundle) does not need
  /// to be implemented since the AlertDialog takes care of its own content.
  ///
  /// This method will be called after \#onCreate(Bundle) and
  /// before \#onCreateView(LayoutInflater, ViewGroup, Bundle).  The
  /// default implementation simply instantiates and returns a Dialog
  /// class.
  ///
  /// _Note: DialogFragment own the Dialog\#setOnCancelListener Dialog.setOnCancelListener and Dialog\#setOnDismissListener Dialog.setOnDismissListener callbacks.  You must not set them yourself._
  /// To find out about these events, override \#onCancel(DialogInterface)
  /// and \#onDismiss(DialogInterface).
  ///
  ///@param savedInstanceState The last saved instance state of the Fragment,
  /// or null if this is a freshly created Fragment.
  ///@return Return a new Dialog instance to be displayed by the Fragment.
  Dialog onCreateDialog(os.Bundle savedInstanceState) =>
      Dialog.fromRef(_onCreateDialog(reference, savedInstanceState.reference));

  static final _onCancel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_DialogFragment_onCancel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCancel(android.content.DialogInterface dialog)
  void onCancel(content.DialogInterface dialog) =>
      _onCancel(reference, dialog.reference);

  static final _onDismiss = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_DialogFragment_onDismiss")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onDismiss(android.content.DialogInterface dialog)
  void onDismiss(content.DialogInterface dialog) =>
      _onDismiss(reference, dialog.reference);

  static final _onActivityCreated = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_DialogFragment_onActivityCreated")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onActivityCreated(android.os.Bundle savedInstanceState)
  void onActivityCreated(os.Bundle savedInstanceState) =>
      _onActivityCreated(reference, savedInstanceState.reference);

  static final _onStart =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_DialogFragment_onStart")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onStart()
  void onStart() => _onStart(reference);

  static final _onSaveInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_DialogFragment_onSaveInstanceState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onSaveInstanceState(android.os.Bundle outState)
  void onSaveInstanceState(os.Bundle outState) =>
      _onSaveInstanceState(reference, outState.reference);

  static final _onStop =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_DialogFragment_onStop")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onStop()
  void onStop() => _onStop(reference);

  static final _onDestroyView =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_DialogFragment_onDestroyView")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDestroyView()
  /// Remove dialog.
  void onDestroyView() => _onDestroyView(reference);

  static final _dump = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_DialogFragment_dump")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  void dump(jni.JlString prefix, jni.JlObject fd, jni.JlObject writer,
          jni.JlObject args) =>
      _dump(reference, prefix.reference, fd.reference, writer.reference,
          args.reference);
}

/// Represents a remote action that can be called from another process.  The action can have an
/// associated visualization including metadata like an icon or title.
class RemoteAction extends jni.JlObject {
  RemoteAction.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.RemoteAction> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_RemoteAction_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_RemoteAction_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.graphics.drawable.Icon icon, java.lang.CharSequence title, java.lang.CharSequence contentDescription, android.app.PendingIntent intent)
  /// @param icon This value must never be {@code null}.
  ///@param title This value must never be {@code null}.
  ///@param contentDescription This value must never be {@code null}.
  ///@param intent This value must never be {@code null}.
  RemoteAction(jni.JlObject icon, jni.JlObject title,
      jni.JlObject contentDescription, PendingIntent intent)
      : super.fromRef(_ctor(icon.reference, title.reference,
            contentDescription.reference, intent.reference));

  static final _setEnabled = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_RemoteAction_setEnabled")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setEnabled(boolean enabled)
  /// Sets whether this action is enabled.
  void setEnabled(bool enabled) => _setEnabled(reference, enabled ? 1 : 0);

  static final _isEnabled =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_RemoteAction_isEnabled")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isEnabled()
  /// Return whether this action is enabled.
  bool isEnabled() => _isEnabled(reference) != 0;

  static final _setShouldShowIcon = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_RemoteAction_setShouldShowIcon")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setShouldShowIcon(boolean shouldShowIcon)
  /// Sets whether the icon should be shown.
  void setShouldShowIcon(bool shouldShowIcon) =>
      _setShouldShowIcon(reference, shouldShowIcon ? 1 : 0);

  static final _shouldShowIcon =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_RemoteAction_shouldShowIcon")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldShowIcon()
  /// Return whether the icon should be shown.
  bool shouldShowIcon() => _shouldShowIcon(reference) != 0;

  static final _getIcon = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_RemoteAction_getIcon")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Icon getIcon()
  /// Return an icon representing the action.
  ///@return This value will never be {@code null}.
  jni.JlObject getIcon() => jni.JlObject.fromRef(_getIcon(reference));

  static final _getTitle = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_RemoteAction_getTitle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getTitle()
  /// Return an title representing the action.
  ///@return This value will never be {@code null}.
  jni.JlObject getTitle() => jni.JlObject.fromRef(_getTitle(reference));

  static final _getContentDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_RemoteAction_getContentDescription")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getContentDescription()
  /// Return a content description representing the action.
  ///@return This value will never be {@code null}.
  jni.JlObject getContentDescription() =>
      jni.JlObject.fromRef(_getContentDescription(reference));

  static final _getActionIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_RemoteAction_getActionIntent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent getActionIntent()
  /// Return the action intent.
  ///@return This value will never be {@code null}.
  PendingIntent getActionIntent() =>
      PendingIntent.fromRef(_getActionIntent(reference));

  static final _clone = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_RemoteAction_clone")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.RemoteAction clone()
  RemoteAction clone() => RemoteAction.fromRef(_clone(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_RemoteAction_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_RemoteAction_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os.Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags);

  static final _dump = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_RemoteAction_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(java.lang.String prefix, java.io.PrintWriter pw)
  void dump(jni.JlString prefix, jni.JlObject pw) =>
      _dump(reference, prefix.reference, pw.reference);
}

/// Provides integration points with a FragmentManager for a fragment host.
///
/// It is the responsibility of the host to take care of the Fragment's lifecycle.
/// The methods provided by FragmentController are for that purpose.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.FragmentController
class FragmentController extends jni.JlObject {
  FragmentController.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_FragmentController_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.app.FragmentHostCallback<?> callbacks)
  FragmentController(FragmentHostCallback callbacks)
      : super.fromRef(_ctor(callbacks.reference));

  static final _createController = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_createController")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public final android.app.FragmentController createController(android.app.FragmentHostCallback<?> callbacks)
  /// Returns a FragmentController.
  static FragmentController createController(FragmentHostCallback callbacks) =>
      FragmentController.fromRef(_createController(callbacks.reference));

  static final _getFragmentManager = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_getFragmentManager")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.FragmentManager getFragmentManager()
  /// Returns a FragmentManager for this controller.
  FragmentManager getFragmentManager() =>
      FragmentManager.fromRef(_getFragmentManager(reference));

  static final _getLoaderManager = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_getLoaderManager")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.LoaderManager getLoaderManager()
  /// Returns a LoaderManager.
  LoaderManager getLoaderManager() =>
      LoaderManager.fromRef(_getLoaderManager(reference));

  static final _findFragmentByWho = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_findFragmentByWho")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Fragment findFragmentByWho(java.lang.String who)
  /// Returns a fragment with the given identifier.
  ///@return This value may be {@code null}.
  Fragment findFragmentByWho(jni.JlString who) =>
      Fragment.fromRef(_findFragmentByWho(reference, who.reference));

  static final _attachHost = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_attachHost")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void attachHost(android.app.Fragment parent)
  /// Attaches the host to the FragmentManager for this controller. The host must be
  /// attached before the FragmentManager can be used to manage Fragments.
  void attachHost(Fragment parent) => _attachHost(reference, parent.reference);

  static final _onCreateView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_onCreateView")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View onCreateView(android.view.View parent, java.lang.String name, android.content.Context context, android.util.AttributeSet attrs)
  /// Instantiates a Fragment's view.
  ///@param parent The parent that the created view will be placed
  /// in; _note that this may be null_.
  ///@param name Tag name to be inflated.
  ///@param context The context the view is being created in.
  ///@param attrs Inflation attributes as specified in XML file.
  ///@return view the newly created view
  jni.JlObject onCreateView(jni.JlObject parent, jni.JlString name,
          content.Context context, jni.JlObject attrs) =>
      jni.JlObject.fromRef(_onCreateView(reference, parent.reference,
          name.reference, context.reference, attrs.reference));

  static final _noteStateNotSaved =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentController_noteStateNotSaved")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void noteStateNotSaved()
  /// Marks the fragment state as unsaved. This allows for "state loss" detection.
  void noteStateNotSaved() => _noteStateNotSaved(reference);

  static final _saveAllState = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_saveAllState")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Parcelable saveAllState()
  /// Saves the state for all Fragments.
  os.Parcelable saveAllState() =>
      os.Parcelable.fromRef(_saveAllState(reference));

  static final _restoreAllState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_restoreAllState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void restoreAllState(android.os.Parcelable state, java.util.List<android.app.Fragment> nonConfigList)
  /// Restores the saved state for all Fragments. The given Fragment list are Fragment
  /// instances retained across configuration changes.
  ///@see \#retainNonConfig()
  ///@deprecated use \#restoreAllState(Parcelable, FragmentManagerNonConfig)
  void restoreAllState(os.Parcelable state, jni.JlObject nonConfigList) =>
      _restoreAllState(reference, state.reference, nonConfigList.reference);

  static final _restoreAllState_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_restoreAllState_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void restoreAllState(android.os.Parcelable state, android.app.FragmentManagerNonConfig nonConfig)
  /// Restores the saved state for all Fragments. The given FragmentManagerNonConfig are Fragment
  /// instances retained across configuration changes, including nested fragments
  ///@see \#retainNestedNonConfig()
  void restoreAllState_1(
          os.Parcelable state, FragmentManagerNonConfig nonConfig) =>
      _restoreAllState_1(reference, state.reference, nonConfig.reference);

  static final _retainNonConfig = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_retainNonConfig")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.Fragment> retainNonConfig()
  /// Returns a list of Fragments that have opted to retain their instance across
  /// configuration changes.
  ///@deprecated use \#retainNestedNonConfig() to also track retained
  ///             nested child fragments
  jni.JlObject retainNonConfig() =>
      jni.JlObject.fromRef(_retainNonConfig(reference));

  static final _retainNestedNonConfig = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_retainNestedNonConfig")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.FragmentManagerNonConfig retainNestedNonConfig()
  /// Returns a nested tree of Fragments that have opted to retain their instance across
  /// configuration changes.
  FragmentManagerNonConfig retainNestedNonConfig() =>
      FragmentManagerNonConfig.fromRef(_retainNestedNonConfig(reference));

  static final _dispatchCreate =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentController_dispatchCreate")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchCreate()
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the create state.
  /// Call when Fragments should be created.
  ///@see Fragment\#onCreate(Bundle)
  void dispatchCreate() => _dispatchCreate(reference);

  static final _dispatchActivityCreated =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentController_dispatchActivityCreated")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchActivityCreated()
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the activity created state.
  /// Call when Fragments should be informed their host has been created.
  ///@see Fragment\#onActivityCreated(Bundle)
  void dispatchActivityCreated() => _dispatchActivityCreated(reference);

  static final _dispatchStart =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentController_dispatchStart")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchStart()
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the start state.
  /// Call when Fragments should be started.
  ///@see Fragment\#onStart()
  void dispatchStart() => _dispatchStart(reference);

  static final _dispatchResume =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentController_dispatchResume")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchResume()
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the resume state.
  /// Call when Fragments should be resumed.
  ///@see Fragment\#onResume()
  void dispatchResume() => _dispatchResume(reference);

  static final _dispatchPause =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentController_dispatchPause")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchPause()
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the pause state.
  /// Call when Fragments should be paused.
  ///@see Fragment\#onPause()
  void dispatchPause() => _dispatchPause(reference);

  static final _dispatchStop =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentController_dispatchStop")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchStop()
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the stop state.
  /// Call when Fragments should be stopped.
  ///@see Fragment\#onStop()
  void dispatchStop() => _dispatchStop(reference);

  static final _dispatchDestroyView =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentController_dispatchDestroyView")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchDestroyView()
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the destroy view state.
  /// Call when the Fragment's views should be destroyed.
  ///@see Fragment\#onDestroyView()
  void dispatchDestroyView() => _dispatchDestroyView(reference);

  static final _dispatchDestroy =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentController_dispatchDestroy")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchDestroy()
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the destroy state.
  /// Call when Fragments should be destroyed.
  ///@see Fragment\#onDestroy()
  void dispatchDestroy() => _dispatchDestroy(reference);

  static final _dispatchMultiWindowModeChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_FragmentController_dispatchMultiWindowModeChanged")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void dispatchMultiWindowModeChanged(boolean isInMultiWindowMode)
  /// Lets all Fragments managed by the controller's FragmentManager know the multi-window mode of
  /// the activity changed.
  /// Call when the multi-window mode of the activity changed.
  ///@see Fragment\#onMultiWindowModeChanged
  ///@deprecated use \#dispatchMultiWindowModeChanged(boolean, Configuration)
  void dispatchMultiWindowModeChanged(bool isInMultiWindowMode) =>
      _dispatchMultiWindowModeChanged(reference, isInMultiWindowMode ? 1 : 0);

  static final _dispatchMultiWindowModeChanged_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_dispatchMultiWindowModeChanged_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchMultiWindowModeChanged(boolean isInMultiWindowMode, android.content.res.Configuration newConfig)
  /// Lets all Fragments managed by the controller's FragmentManager know the multi-window mode of
  /// the activity changed.
  /// Call when the multi-window mode of the activity changed.
  ///@see Fragment\#onMultiWindowModeChanged
  void dispatchMultiWindowModeChanged_1(
          bool isInMultiWindowMode, res.Configuration newConfig) =>
      _dispatchMultiWindowModeChanged_1(
          reference, isInMultiWindowMode ? 1 : 0, newConfig.reference);

  static final _dispatchPictureInPictureModeChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_FragmentController_dispatchPictureInPictureModeChanged")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void dispatchPictureInPictureModeChanged(boolean isInPictureInPictureMode)
  /// Lets all Fragments managed by the controller's FragmentManager know the picture-in-picture
  /// mode of the activity changed.
  /// Call when the picture-in-picture mode of the activity changed.
  ///@see Fragment\#onPictureInPictureModeChanged
  ///@deprecated use \#dispatchPictureInPictureModeChanged(boolean, Configuration)
  void dispatchPictureInPictureModeChanged(bool isInPictureInPictureMode) =>
      _dispatchPictureInPictureModeChanged(
          reference, isInPictureInPictureMode ? 1 : 0);

  static final _dispatchPictureInPictureModeChanged_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_dispatchPictureInPictureModeChanged_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchPictureInPictureModeChanged(boolean isInPictureInPictureMode, android.content.res.Configuration newConfig)
  /// Lets all Fragments managed by the controller's FragmentManager know the picture-in-picture
  /// mode of the activity changed.
  /// Call when the picture-in-picture mode of the activity changed.
  ///@see Fragment\#onPictureInPictureModeChanged
  void dispatchPictureInPictureModeChanged_1(
          bool isInPictureInPictureMode, res.Configuration newConfig) =>
      _dispatchPictureInPictureModeChanged_1(
          reference, isInPictureInPictureMode ? 1 : 0, newConfig.reference);

  static final _dispatchConfigurationChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_dispatchConfigurationChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchConfigurationChanged(android.content.res.Configuration newConfig)
  /// Lets all Fragments managed by the controller's FragmentManager
  /// know a configuration change occurred.
  /// Call when there is a configuration change.
  ///@see Fragment\#onConfigurationChanged(Configuration)
  void dispatchConfigurationChanged(res.Configuration newConfig) =>
      _dispatchConfigurationChanged(reference, newConfig.reference);

  static final _dispatchLowMemory =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentController_dispatchLowMemory")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchLowMemory()
  /// Lets all Fragments managed by the controller's FragmentManager
  /// know the device is in a low memory condition.
  /// Call when the device is low on memory and Fragment's should trim
  /// their memory usage.
  ///@see Fragment\#onLowMemory()
  void dispatchLowMemory() => _dispatchLowMemory(reference);

  static final _dispatchTrimMemory = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_FragmentController_dispatchTrimMemory")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void dispatchTrimMemory(int level)
  /// Lets all Fragments managed by the controller's FragmentManager
  /// know they should trim their memory usage.
  /// Call when the Fragment can release allocated memory [such as if
  /// the Fragment is in the background].
  ///@see Fragment\#onTrimMemory(int)
  void dispatchTrimMemory(int level) => _dispatchTrimMemory(reference, level);

  static final _dispatchCreateOptionsMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_dispatchCreateOptionsMenu")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchCreateOptionsMenu(android.view.Menu menu, android.view.MenuInflater inflater)
  /// Lets all Fragments managed by the controller's FragmentManager
  /// know they should create an options menu.
  /// Call when the Fragment should create an options menu.
  ///@return {@code true} if the options menu contains items to display
  ///@see Fragment\#onCreateOptionsMenu(Menu, MenuInflater)
  bool dispatchCreateOptionsMenu(jni.JlObject menu, jni.JlObject inflater) =>
      _dispatchCreateOptionsMenu(
          reference, menu.reference, inflater.reference) !=
      0;

  static final _dispatchPrepareOptionsMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_dispatchPrepareOptionsMenu")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchPrepareOptionsMenu(android.view.Menu menu)
  /// Lets all Fragments managed by the controller's FragmentManager
  /// know they should prepare their options menu for display.
  /// Call immediately before displaying the Fragment's options menu.
  ///@return {@code true} if the options menu contains items to display
  ///@see Fragment\#onPrepareOptionsMenu(Menu)
  bool dispatchPrepareOptionsMenu(jni.JlObject menu) =>
      _dispatchPrepareOptionsMenu(reference, menu.reference) != 0;

  static final _dispatchOptionsItemSelected = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_dispatchOptionsItemSelected")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchOptionsItemSelected(android.view.MenuItem item)
  /// Sends an option item selection event to the Fragments managed by the
  /// controller's FragmentManager. Once the event has been consumed,
  /// no additional handling will be performed.
  /// Call immediately after an options menu item has been selected
  ///@return {@code true} if the options menu selection event was consumed
  ///@see Fragment\#onOptionsItemSelected(MenuItem)
  bool dispatchOptionsItemSelected(jni.JlObject item) =>
      _dispatchOptionsItemSelected(reference, item.reference) != 0;

  static final _dispatchContextItemSelected = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_dispatchContextItemSelected")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchContextItemSelected(android.view.MenuItem item)
  /// Sends a context item selection event to the Fragments managed by the
  /// controller's FragmentManager. Once the event has been consumed,
  /// no additional handling will be performed.
  /// Call immediately after an options menu item has been selected
  ///@return {@code true} if the context menu selection event was consumed
  ///@see Fragment\#onContextItemSelected(MenuItem)
  bool dispatchContextItemSelected(jni.JlObject item) =>
      _dispatchContextItemSelected(reference, item.reference) != 0;

  static final _dispatchOptionsMenuClosed = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_dispatchOptionsMenuClosed")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchOptionsMenuClosed(android.view.Menu menu)
  /// Lets all Fragments managed by the controller's FragmentManager
  /// know their options menu has closed.
  /// Call immediately after closing the Fragment's options menu.
  ///@see Fragment\#onOptionsMenuClosed(Menu)
  void dispatchOptionsMenuClosed(jni.JlObject menu) =>
      _dispatchOptionsMenuClosed(reference, menu.reference);

  static final _execPendingActions =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentController_execPendingActions")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean execPendingActions()
  /// Execute any pending actions for the Fragments managed by the
  /// controller's FragmentManager.
  /// Call when queued actions can be performed [eg when the
  /// Fragment moves into a start or resume state].
  ///@return {@code true} if queued actions were performed
  bool execPendingActions() => _execPendingActions(reference) != 0;

  static final _doLoaderStart =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentController_doLoaderStart")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void doLoaderStart()
  /// Starts the loaders.
  void doLoaderStart() => _doLoaderStart(reference);

  static final _doLoaderStop = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_FragmentController_doLoaderStop")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void doLoaderStop(boolean retain)
  /// Stops the loaders, optionally retaining their state. This is useful for keeping the
  /// loader state across configuration changes.
  ///@param retain When {@code true}, the loaders aren't stopped, but, their instances
  /// are retained in a started state
  void doLoaderStop(bool retain) => _doLoaderStop(reference, retain ? 1 : 0);

  static final _doLoaderDestroy =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentController_doLoaderDestroy")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void doLoaderDestroy()
  /// Destroys the loaders and, if their state is not being retained, removes them.
  void doLoaderDestroy() => _doLoaderDestroy(reference);

  static final _reportLoaderStart =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentController_reportLoaderStart")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void reportLoaderStart()
  /// Lets the loaders know the host is ready to receive notifications.
  void reportLoaderStart() => _reportLoaderStart(reference);

  static final _retainLoaderNonConfig = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_retainLoaderNonConfig")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.util.ArrayMap<java.lang.String,android.app.LoaderManager> retainLoaderNonConfig()
  /// Returns a list of LoaderManagers that have opted to retain their instance across
  /// configuration changes.
  jni.JlObject retainLoaderNonConfig() =>
      jni.JlObject.fromRef(_retainLoaderNonConfig(reference));

  static final _restoreLoaderNonConfig = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_restoreLoaderNonConfig")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void restoreLoaderNonConfig(android.util.ArrayMap<java.lang.String,android.app.LoaderManager> loaderManagers)
  /// Restores the saved state for all LoaderManagers. The given LoaderManager list are
  /// LoaderManager instances retained across configuration changes.
  ///@see \#retainLoaderNonConfig()
  void restoreLoaderNonConfig(jni.JlObject loaderManagers) =>
      _restoreLoaderNonConfig(reference, loaderManagers.reference);

  static final _dumpLoaders = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentController_dumpLoaders")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dumpLoaders(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  /// Dumps the current state of the loaders.
  void dumpLoaders(jni.JlString prefix, jni.JlObject fd, jni.JlObject writer,
          jni.JlObject args) =>
      _dumpLoaders(reference, prefix.reference, fd.reference, writer.reference,
          args.reference);
}

/// Integration points with the Fragment host.
///
/// Fragments may be hosted by any object; such as an Activity. In order to
/// host fragments, implement FragmentHostCallback, overriding the methods
/// applicable to the host.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.FragmentHostCallback
class FragmentHostCallback extends FragmentContainer {
  FragmentHostCallback.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_FragmentHostCallback_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Context context, android.os.Handler handler, int windowAnimations)
  FragmentHostCallback(
      content.Context context, os.Handler handler, int windowAnimations)
      : super.fromRef(
            _ctor(context.reference, handler.reference, windowAnimations));

  static final _onDump = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentHostCallback_onDump")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onDump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  /// Print internal state into the given stream.
  ///@param prefix Desired prefix to prepend at each line of output.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer The PrintWriter to which you should dump your state. This will be closed
  ///                  for you after you return.
  ///@param args additional arguments to the dump request.
  void onDump(jni.JlString prefix, jni.JlObject fd, jni.JlObject writer,
          jni.JlObject args) =>
      _onDump(reference, prefix.reference, fd.reference, writer.reference,
          args.reference);

  static final _onShouldSaveFragmentState = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentHostCallback_onShouldSaveFragmentState")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onShouldSaveFragmentState(android.app.Fragment fragment)
  /// Return {@code true} if the fragment's state needs to be saved.
  bool onShouldSaveFragmentState(Fragment fragment) =>
      _onShouldSaveFragmentState(reference, fragment.reference) != 0;

  static final _onGetLayoutInflater = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentHostCallback_onGetLayoutInflater")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.LayoutInflater onGetLayoutInflater()
  /// Return a LayoutInflater.
  /// See Activity\#getLayoutInflater().
  jni.JlObject onGetLayoutInflater() =>
      jni.JlObject.fromRef(_onGetLayoutInflater(reference));

  static final _onUseFragmentManagerInflaterFactory = jlookup<
              ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentHostCallback_onUseFragmentManagerInflaterFactory")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onUseFragmentManagerInflaterFactory()
  /// Return {@code true} if the FragmentManager's LayoutInflaterFactory should be used.
  bool onUseFragmentManagerInflaterFactory() =>
      _onUseFragmentManagerInflaterFactory(reference) != 0;

  static final _onInvalidateOptionsMenu =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentHostCallback_onInvalidateOptionsMenu")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onInvalidateOptionsMenu()
  /// Invalidates the activity's options menu.
  /// See Activity\#invalidateOptionsMenu()
  void onInvalidateOptionsMenu() => _onInvalidateOptionsMenu(reference);

  static final _onStartActivityFromFragment = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentHostCallback_onStartActivityFromFragment")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onStartActivityFromFragment(android.app.Fragment fragment, android.content.Intent intent, int requestCode, android.os.Bundle options)
  /// Starts a new Activity from the given fragment.
  /// See Activity\#startActivityForResult(Intent, int).
  void onStartActivityFromFragment(Fragment fragment, content.Intent intent,
          int requestCode, os.Bundle options) =>
      _onStartActivityFromFragment(reference, fragment.reference,
          intent.reference, requestCode, options.reference);

  static final _onStartIntentSenderFromFragment = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentHostCallback_onStartIntentSenderFromFragment")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onStartIntentSenderFromFragment(android.app.Fragment fragment, android.content.IntentSender intent, int requestCode, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, android.os.Bundle options)
  /// Starts a new IntentSender from the given fragment.
  /// See Activity\#startIntentSender(IntentSender, Intent, int, int, int, Bundle).
  ///@param fillInIntent This value may be {@code null}.
  void onStartIntentSenderFromFragment(
          Fragment fragment,
          content.IntentSender intent,
          int requestCode,
          content.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags,
          os.Bundle options) =>
      _onStartIntentSenderFromFragment(
          reference,
          fragment.reference,
          intent.reference,
          requestCode,
          fillInIntent.reference,
          flagsMask,
          flagsValues,
          extraFlags,
          options.reference);

  static final _onRequestPermissionsFromFragment = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32)>>(
          "android_app_FragmentHostCallback_onRequestPermissionsFromFragment")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onRequestPermissionsFromFragment(android.app.Fragment fragment, java.lang.String[] permissions, int requestCode)
  /// Requests permissions from the given fragment.
  /// See Activity\#requestPermissions(String[], int)
  ///@param fragment This value must never be {@code null}.
  ///@param permissions This value must never be {@code null}.
  void onRequestPermissionsFromFragment(
          Fragment fragment, jni.JlObject permissions, int requestCode) =>
      _onRequestPermissionsFromFragment(
          reference, fragment.reference, permissions.reference, requestCode);

  static final _onHasWindowAnimations =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentHostCallback_onHasWindowAnimations")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onHasWindowAnimations()
  /// Return {@code true} if there are window animations.
  bool onHasWindowAnimations() => _onHasWindowAnimations(reference) != 0;

  static final _onGetWindowAnimations =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentHostCallback_onGetWindowAnimations")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int onGetWindowAnimations()
  /// Return the window animations.
  int onGetWindowAnimations() => _onGetWindowAnimations(reference);

  static final _onAttachFragment = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentHostCallback_onAttachFragment")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttachFragment(android.app.Fragment fragment)
  /// Called when a Fragment is being attached to this host, immediately
  /// after the call to its Fragment\#onAttach(Context) method and before
  /// Fragment\#onCreate(Bundle).
  void onAttachFragment(Fragment fragment) =>
      _onAttachFragment(reference, fragment.reference);

  static final _onHasView =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentHostCallback_onHasView")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onHasView()
  bool onHasView() => _onHasView(reference) != 0;
}

/// API for performing a set of Fragment operations.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using fragments, read the
/// <a href="{@docRoot}guide/components/fragments.html">Fragments</a> developer
/// guide.
///
/// </div>
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.FragmentTransaction
class FragmentTransaction extends jni.JlObject {
  FragmentTransaction.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int TRANSIT_ENTER_MASK
  /// Bit mask that is set for all enter transitions.
  static const TRANSIT_ENTER_MASK = 4096;

  /// from: static public final int TRANSIT_EXIT_MASK
  /// Bit mask that is set for all exit transitions.
  static const TRANSIT_EXIT_MASK = 8192;

  /// from: static public final int TRANSIT_FRAGMENT_CLOSE
  /// Fragment is being removed from the stack
  static const TRANSIT_FRAGMENT_CLOSE = 8194;

  /// from: static public final int TRANSIT_FRAGMENT_FADE
  /// Fragment should simply fade in or out; that is, no strong navigation associated
  /// with it except that it is appearing or disappearing for some reason.
  static const TRANSIT_FRAGMENT_FADE = 4099;

  /// from: static public final int TRANSIT_FRAGMENT_OPEN
  /// Fragment is being added onto the stack
  static const TRANSIT_FRAGMENT_OPEN = 4097;

  /// from: static public final int TRANSIT_NONE
  /// No animation for transition.
  static const TRANSIT_NONE = 0;

  /// from: static public final int TRANSIT_UNSET
  /// Not set up for a transition.
  static const TRANSIT_UNSET = -1;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_FragmentTransaction_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  FragmentTransaction() : super.fromRef(_ctor());

  static final _add = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentTransaction_add")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction add(android.app.Fragment fragment, java.lang.String tag)
  /// Calls \#add(int, Fragment, String) with a 0 containerViewId.
  FragmentTransaction add(Fragment fragment, jni.JlString tag) =>
      FragmentTransaction.fromRef(
          _add(reference, fragment.reference, tag.reference));

  static final _add_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentTransaction_add_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction add(int containerViewId, android.app.Fragment fragment)
  /// Calls \#add(int, Fragment, String) with a null tag.
  FragmentTransaction add_1(int containerViewId, Fragment fragment) =>
      FragmentTransaction.fromRef(
          _add_1(reference, containerViewId, fragment.reference));

  static final _add_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentTransaction_add_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction add(int containerViewId, android.app.Fragment fragment, java.lang.String tag)
  /// Add a fragment to the activity state.  This fragment may optionally
  /// also have its view (if Fragment\#onCreateView Fragment.onCreateView
  /// returns non-null) inserted into a container view of the activity.
  ///@param containerViewId Optional identifier of the container this fragment is
  /// to be placed in.  If 0, it will not be placed in a container.
  ///@param fragment The fragment to be added.  This fragment must not already
  /// be added to the activity.
  ///@param tag Optional tag name for the fragment, to later retrieve the
  /// fragment with FragmentManager\#findFragmentByTag(String) FragmentManager.findFragmentByTag(String).
  ///@return Returns the same FragmentTransaction instance.
  FragmentTransaction add_2(
          int containerViewId, Fragment fragment, jni.JlString tag) =>
      FragmentTransaction.fromRef(_add_2(
          reference, containerViewId, fragment.reference, tag.reference));

  static final _replace = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentTransaction_replace")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction replace(int containerViewId, android.app.Fragment fragment)
  /// Calls \#replace(int, Fragment, String) with a null tag.
  FragmentTransaction replace(int containerViewId, Fragment fragment) =>
      FragmentTransaction.fromRef(
          _replace(reference, containerViewId, fragment.reference));

  static final _replace_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentTransaction_replace_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction replace(int containerViewId, android.app.Fragment fragment, java.lang.String tag)
  /// Replace an existing fragment that was added to a container.  This is
  /// essentially the same as calling \#remove(Fragment) for all
  /// currently added fragments that were added with the same containerViewId
  /// and then \#add(int, Fragment, String) with the same arguments
  /// given here.
  ///@param containerViewId Identifier of the container whose fragment(s) are
  /// to be replaced.
  ///@param fragment The new fragment to place in the container.
  ///@param tag Optional tag name for the fragment, to later retrieve the
  /// fragment with FragmentManager\#findFragmentByTag(String) FragmentManager.findFragmentByTag(String).
  ///@return Returns the same FragmentTransaction instance.
  FragmentTransaction replace_1(
          int containerViewId, Fragment fragment, jni.JlString tag) =>
      FragmentTransaction.fromRef(_replace_1(
          reference, containerViewId, fragment.reference, tag.reference));

  static final _remove = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentTransaction_remove")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction remove(android.app.Fragment fragment)
  /// Remove an existing fragment.  If it was added to a container, its view
  /// is also removed from that container.
  ///@param fragment The fragment to be removed.
  ///@return Returns the same FragmentTransaction instance.
  FragmentTransaction remove(Fragment fragment) =>
      FragmentTransaction.fromRef(_remove(reference, fragment.reference));

  static final _hide_ = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentTransaction_hide_")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction hide(android.app.Fragment fragment)
  /// Hides an existing fragment.  This is only relevant for fragments whose
  /// views have been added to a container, as this will cause the view to
  /// be hidden.
  ///@param fragment The fragment to be hidden.
  ///@return Returns the same FragmentTransaction instance.
  FragmentTransaction hide_(Fragment fragment) =>
      FragmentTransaction.fromRef(_hide_(reference, fragment.reference));

  static final _show_ = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentTransaction_show_")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction show(android.app.Fragment fragment)
  /// Shows a previously hidden fragment.  This is only relevant for fragments whose
  /// views have been added to a container, as this will cause the view to
  /// be shown.
  ///@param fragment The fragment to be shown.
  ///@return Returns the same FragmentTransaction instance.
  FragmentTransaction show_(Fragment fragment) =>
      FragmentTransaction.fromRef(_show_(reference, fragment.reference));

  static final _detach = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentTransaction_detach")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction detach(android.app.Fragment fragment)
  /// Detach the given fragment from the UI.  This is the same state as
  /// when it is put on the back stack: the fragment is removed from
  /// the UI, however its state is still being actively managed by the
  /// fragment manager.  When going into this state its view hierarchy
  /// is destroyed.
  ///@param fragment The fragment to be detached.
  ///@return Returns the same FragmentTransaction instance.
  FragmentTransaction detach(Fragment fragment) =>
      FragmentTransaction.fromRef(_detach(reference, fragment.reference));

  static final _attach = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentTransaction_attach")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction attach(android.app.Fragment fragment)
  /// Re-attach a fragment after it had previously been detached from
  /// the UI with \#detach(Fragment).  This
  /// causes its view hierarchy to be re-created, attached to the UI,
  /// and displayed.
  ///@param fragment The fragment to be attached.
  ///@return Returns the same FragmentTransaction instance.
  FragmentTransaction attach(Fragment fragment) =>
      FragmentTransaction.fromRef(_attach(reference, fragment.reference));

  static final _setPrimaryNavigationFragment = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentTransaction_setPrimaryNavigationFragment")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction setPrimaryNavigationFragment(android.app.Fragment fragment)
  /// Set a currently active fragment in this FragmentManager as the primary navigation fragment.
  ///
  /// The primary navigation fragment's
  /// Fragment\#getChildFragmentManager() child FragmentManager will be called first
  /// to process delegated navigation actions such as FragmentManager\#popBackStack()
  /// if no ID or transaction name is provided to pop to. Navigation operations outside of the
  /// fragment system may choose to delegate those actions to the primary navigation fragment
  /// as returned by FragmentManager\#getPrimaryNavigationFragment().
  ///
  ///
  /// The fragment provided must currently be added to the FragmentManager to be set as
  /// a primary navigation fragment, or previously added as part of this transaction.
  ///
  ///@param fragment the fragment to set as the primary navigation fragment
  ///@return the same FragmentTransaction instance
  FragmentTransaction setPrimaryNavigationFragment(Fragment fragment) =>
      FragmentTransaction.fromRef(
          _setPrimaryNavigationFragment(reference, fragment.reference));

  static final _isEmpty =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentTransaction_isEmpty")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isEmpty()
  /// @return <code>true</code> if this transaction contains no operations,
  /// <code>false</code> otherwise.
  bool isEmpty() => _isEmpty(reference) != 0;

  static final _setCustomAnimations = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_app_FragmentTransaction_setCustomAnimations")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract android.app.FragmentTransaction setCustomAnimations(int enter, int exit)
  /// Set specific animation resources to run for the fragments that are
  /// entering and exiting in this transaction. These animations will not be
  /// played when popping the back stack.
  FragmentTransaction setCustomAnimations(int enter, int exit) =>
      FragmentTransaction.fromRef(_setCustomAnimations(reference, enter, exit));

  static final _setCustomAnimations_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32)>>(
          "android_app_FragmentTransaction_setCustomAnimations_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: public abstract android.app.FragmentTransaction setCustomAnimations(int enter, int exit, int popEnter, int popExit)
  /// Set specific animation resources to run for the fragments that are
  /// entering and exiting in this transaction. The <code>popEnter</code>
  /// and <code>popExit</code> animations will be played for enter/exit
  /// operations specifically when popping the back stack.
  FragmentTransaction setCustomAnimations_1(
          int enter, int exit, int popEnter, int popExit) =>
      FragmentTransaction.fromRef(
          _setCustomAnimations_1(reference, enter, exit, popEnter, popExit));

  static final _setTransition = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_FragmentTransaction_setTransition")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.FragmentTransaction setTransition(int transit)
  /// Select a standard transition animation for this transaction.  May be
  /// one of \#TRANSIT_NONE, \#TRANSIT_FRAGMENT_OPEN,
  /// \#TRANSIT_FRAGMENT_CLOSE, or \#TRANSIT_FRAGMENT_FADE.
  ///@param transit Value is android.app.FragmentTransaction\#TRANSIT_NONE, android.app.FragmentTransaction\#TRANSIT_FRAGMENT_OPEN, android.app.FragmentTransaction\#TRANSIT_FRAGMENT_CLOSE, or android.app.FragmentTransaction\#TRANSIT_FRAGMENT_FADE
  FragmentTransaction setTransition(int transit) =>
      FragmentTransaction.fromRef(_setTransition(reference, transit));

  static final _addSharedElement = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentTransaction_addSharedElement")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction addSharedElement(android.view.View sharedElement, java.lang.String name)
  /// Used with to map a View from a removed or hidden Fragment to a View from a shown
  /// or added Fragment.
  ///@param sharedElement A View in a disappearing Fragment to match with a View in an
  ///                      appearing Fragment.
  ///@param name The transitionName for a View in an appearing Fragment to match to the shared
  ///             element.
  FragmentTransaction addSharedElement(
          jni.JlObject sharedElement, jni.JlString name) =>
      FragmentTransaction.fromRef(_addSharedElement(
          reference, sharedElement.reference, name.reference));

  static final _setTransitionStyle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_FragmentTransaction_setTransitionStyle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.FragmentTransaction setTransitionStyle(int styleRes)
  /// Set a custom style resource that will be used for resolving transit
  /// animations.
  FragmentTransaction setTransitionStyle(int styleRes) =>
      FragmentTransaction.fromRef(_setTransitionStyle(reference, styleRes));

  static final _addToBackStack = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentTransaction_addToBackStack")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction addToBackStack(java.lang.String name)
  /// Add this transaction to the back stack.  This means that the transaction
  /// will be remembered after it is committed, and will reverse its operation
  /// when later popped off the stack.
  ///@param name An optional name for this back stack state, or null.
  ///
  /// This value may be {@code null}.
  FragmentTransaction addToBackStack(jni.JlString name) =>
      FragmentTransaction.fromRef(_addToBackStack(reference, name.reference));

  static final _isAddToBackStackAllowed =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentTransaction_isAddToBackStackAllowed")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isAddToBackStackAllowed()
  /// Returns true if this FragmentTransaction is allowed to be added to the back
  /// stack. If this method would return false, \#addToBackStack(String)
  /// will throw IllegalStateException.
  ///@return True if \#addToBackStack(String) is permitted on this transaction.
  bool isAddToBackStackAllowed() => _isAddToBackStackAllowed(reference) != 0;

  static final _disallowAddToBackStack = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentTransaction_disallowAddToBackStack")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction disallowAddToBackStack()
  /// Disallow calls to \#addToBackStack(String). Any future calls to
  /// addToBackStack will throw IllegalStateException. If addToBackStack
  /// has already been called, this method will throw IllegalStateException.
  FragmentTransaction disallowAddToBackStack() =>
      FragmentTransaction.fromRef(_disallowAddToBackStack(reference));

  static final _setBreadCrumbTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_FragmentTransaction_setBreadCrumbTitle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.FragmentTransaction setBreadCrumbTitle(int res)
  /// Set the full title to show as a bread crumb when this transaction
  /// is on the back stack, as used by FragmentBreadCrumbs.
  ///@param res A string resource containing the title.
  FragmentTransaction setBreadCrumbTitle(int res_) =>
      FragmentTransaction.fromRef(_setBreadCrumbTitle(reference, res_));

  static final _setBreadCrumbTitle_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentTransaction_setBreadCrumbTitle_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction setBreadCrumbTitle(java.lang.CharSequence text)
  /// Like \#setBreadCrumbTitle(int) but taking a raw string; this
  /// method is _not_ recommended, as the string can not be changed
  /// later if the locale changes.
  FragmentTransaction setBreadCrumbTitle_1(jni.JlObject text) =>
      FragmentTransaction.fromRef(
          _setBreadCrumbTitle_1(reference, text.reference));

  static final _setBreadCrumbShortTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_FragmentTransaction_setBreadCrumbShortTitle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.FragmentTransaction setBreadCrumbShortTitle(int res)
  /// Set the short title to show as a bread crumb when this transaction
  /// is on the back stack, as used by FragmentBreadCrumbs.
  ///@param res A string resource containing the title.
  FragmentTransaction setBreadCrumbShortTitle(int res_) =>
      FragmentTransaction.fromRef(_setBreadCrumbShortTitle(reference, res_));

  static final _setBreadCrumbShortTitle_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentTransaction_setBreadCrumbShortTitle_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction setBreadCrumbShortTitle(java.lang.CharSequence text)
  /// Like \#setBreadCrumbShortTitle(int) but taking a raw string; this
  /// method is _not_ recommended, as the string can not be changed
  /// later if the locale changes.
  FragmentTransaction setBreadCrumbShortTitle_1(jni.JlObject text) =>
      FragmentTransaction.fromRef(
          _setBreadCrumbShortTitle_1(reference, text.reference));

  static final _setReorderingAllowed = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_FragmentTransaction_setReorderingAllowed")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.FragmentTransaction setReorderingAllowed(boolean reorderingAllowed)
  /// Sets whether or not to allow optimizing operations within and across
  /// transactions. This will remove redundant operations, eliminating
  /// operations that cancel. For example, if two transactions are executed
  /// together, one that adds a fragment A and the next replaces it with fragment B,
  /// the operations will cancel and only fragment B will be added. That means that
  /// fragment A may not go through the creation/destruction lifecycle.
  ///
  /// The side effect of removing redundant operations is that fragments may have state changes
  /// out of the expected order. For example, one transaction adds fragment A,
  /// a second adds fragment B, then a third removes fragment A. Without removing the redundant
  /// operations, fragment B could expect that while it is being created, fragment A will also
  /// exist because fragment A will be removed after fragment B was added.
  /// With removing redundant operations, fragment B cannot expect fragment A to exist when
  /// it has been created because fragment A's add/remove will be optimized out.
  ///
  /// It can also reorder the state changes of Fragments to allow for better Transitions.
  /// Added Fragments may have Fragment\#onCreate(Bundle) called before replaced
  /// Fragments have Fragment\#onDestroy() called.
  ///
  /// The default is {@code false} for applications targeting version
  /// versions prior to O and {@code true} for applications targeting O and
  /// later.
  ///@param reorderingAllowed {@code true} to enable optimizing out redundant operations
  ///                          or {@code false} to disable optimizing out redundant
  ///                          operations on this transaction.
  FragmentTransaction setReorderingAllowed(bool reorderingAllowed) =>
      FragmentTransaction.fromRef(
          _setReorderingAllowed(reference, reorderingAllowed ? 1 : 0));

  static final _runOnCommit = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_FragmentTransaction_runOnCommit")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction runOnCommit(java.lang.Runnable runnable)
  /// Add a Runnable to this transaction that will be run after this transaction has
  /// been committed. If fragment transactions are \#setReorderingAllowed(boolean) optimized
  /// this may be after other subsequent fragment operations have also taken place, or operations
  /// in this transaction may have been optimized out due to the presence of a subsequent
  /// fragment transaction in the batch.
  ///
  ///
  /// If a transaction is committed using \#commitAllowingStateLoss() this runnable
  /// may be executed when the FragmentManager is in a state where new transactions may not
  /// be committed without allowing state loss.
  ///
  ///
  /// <code>runOnCommit</code> may not be used with transactions
  /// \#addToBackStack(String) added to the back stack as Runnables cannot be persisted
  /// with back stack state. IllegalStateException will be thrown if
  /// \#addToBackStack(String) has been previously called for this transaction
  /// or if it is called after a call to <code>runOnCommit</code>.
  ///
  ///@param runnable Runnable to add
  ///@return this FragmentTransaction
  ///@throws IllegalStateException if \#addToBackStack(String) has been called
  FragmentTransaction runOnCommit(jni.JlObject runnable) =>
      FragmentTransaction.fromRef(_runOnCommit(reference, runnable.reference));

  static final _commit =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentTransaction_commit")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int commit()
  /// Schedules a commit of this transaction.  The commit does
  /// not happen immediately; it will be scheduled as work on the main thread
  /// to be done the next time that thread is ready.
  ///
  /// <p class="note">A transaction can only be committed with this method
  /// prior to its containing activity saving its state.  If the commit is
  /// attempted after that point, an exception will be thrown.  This is
  /// because the state after the commit can be lost if the activity needs to
  /// be restored from its state.  See \#commitAllowingStateLoss() for
  /// situations where it may be okay to lose the commit.
  ///
  ///@return Returns the identifier of this transaction's back stack entry,
  /// if \#addToBackStack(String) had been called.  Otherwise, returns
  /// a negative number.
  int commit() => _commit(reference);

  static final _commitAllowingStateLoss =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentTransaction_commitAllowingStateLoss")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int commitAllowingStateLoss()
  /// Like \#commit but allows the commit to be executed after an
  /// activity's state is saved.  This is dangerous because the commit can
  /// be lost if the activity needs to later be restored from its state, so
  /// this should only be used for cases where it is okay for the UI state
  /// to change unexpectedly on the user.
  int commitAllowingStateLoss() => _commitAllowingStateLoss(reference);

  static final _commitNow =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentTransaction_commitNow")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void commitNow()
  /// Commits this transaction synchronously. Any added fragments will be
  /// initialized and brought completely to the lifecycle state of their host
  /// and any removed fragments will be torn down accordingly before this
  /// call returns. Committing a transaction in this way allows fragments
  /// to be added as dedicated, encapsulated components that monitor the
  /// lifecycle state of their host while providing firmer ordering guarantees
  /// around when those fragments are fully initialized and ready. Fragments
  /// that manage views will have those views created and attached.
  ///
  /// Calling <code>commitNow</code> is preferable to calling
  /// \#commit() followed by FragmentManager\#executePendingTransactions()
  /// as the latter will have the side effect of attempting to commit _all_
  /// currently pending transactions whether that is the desired behavior
  /// or not.
  ///
  ///
  /// Transactions committed in this way may not be added to the
  /// FragmentManager's back stack, as doing so would break other expected
  /// ordering guarantees for other asynchronously committed transactions.
  /// This method will throw IllegalStateException if the transaction
  /// previously requested to be added to the back stack with
  /// \#addToBackStack(String).
  ///
  ///
  /// <p class="note">A transaction can only be committed with this method
  /// prior to its containing activity saving its state.  If the commit is
  /// attempted after that point, an exception will be thrown.  This is
  /// because the state after the commit can be lost if the activity needs to
  /// be restored from its state.  See \#commitAllowingStateLoss() for
  /// situations where it may be okay to lose the commit.
  ///
  void commitNow() => _commitNow(reference);

  static final _commitNowAllowingStateLoss =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_FragmentTransaction_commitNowAllowingStateLoss")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void commitNowAllowingStateLoss()
  /// Like \#commitNow but allows the commit to be executed after an
  /// activity's state is saved.  This is dangerous because the commit can
  /// be lost if the activity needs to later be restored from its state, so
  /// this should only be used for cases where it is okay for the UI state
  /// to change unexpectedly on the user.
  void commitNowAllowingStateLoss() => _commitNowAllowingStateLoss(reference);
}

/// Helper class for building an options Bundle that can be used with
/// android.content.Context\#startActivity(android.content.Intent, android.os.Bundle) Context.startActivity(Intent, Bundle) and related methods.
class ActivityOptions extends jni.JlObject {
  ActivityOptions.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String EXTRA_USAGE_TIME_REPORT
  /// A long in the extras delivered by \#requestUsageTimeReport that contains
  /// the total time (in ms) the user spent in the app flow.
  static const EXTRA_USAGE_TIME_REPORT = "android.activity.usage_time";

  /// from: static public final java.lang.String EXTRA_USAGE_TIME_REPORT_PACKAGES
  /// A Bundle in the extras delivered by \#requestUsageTimeReport that contains
  /// detailed information about the time spent in each package associated with the app;
  /// each key is a package name, whose value is a long containing the time (in ms).
  static const EXTRA_USAGE_TIME_REPORT_PACKAGES = "android.usage_time_packages";

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ActivityOptions_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  ActivityOptions() : super.fromRef(_ctor());

  static final _makeCustomAnimation = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_app_ActivityOptions_makeCustomAnimation")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: static public android.app.ActivityOptions makeCustomAnimation(android.content.Context context, int enterResId, int exitResId)
  /// Create an ActivityOptions specifying a custom animation to run when
  /// the activity is displayed.
  ///@param context Who is defining this.  This is the application that the
  /// animation resources will be loaded from.
  ///@param enterResId A resource ID of the animation resource to use for
  /// the incoming activity.  Use 0 for no animation.
  ///@param exitResId A resource ID of the animation resource to use for
  /// the outgoing activity.  Use 0 for no animation.
  ///@return Returns a new ActivityOptions object that you can use to
  /// supply these options as the options Bundle when starting an activity.
  static ActivityOptions makeCustomAnimation(
          content.Context context, int enterResId, int exitResId) =>
      ActivityOptions.fromRef(
          _makeCustomAnimation(context.reference, enterResId, exitResId));

  static final _makeScaleUpAnimation = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32)>>(
          "android_app_ActivityOptions_makeScaleUpAnimation")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: static public android.app.ActivityOptions makeScaleUpAnimation(android.view.View source, int startX, int startY, int width, int height)
  /// Create an ActivityOptions specifying an animation where the new
  /// activity is scaled from a small originating area of the screen to
  /// its final full representation.
  ///
  /// If the Intent this is being used with has not set its
  /// android.content.Intent\#setSourceBounds Intent.setSourceBounds,
  /// those bounds will be filled in for you based on the initial
  /// bounds passed in here.
  ///@param source The View that the new activity is animating from.  This
  /// defines the coordinate space for <var>startX</var> and <var>startY</var>.
  ///@param startX The x starting location of the new activity, relative to <var>source</var>.
  ///@param startY The y starting location of the activity, relative to <var>source</var>.
  ///@param width The initial width of the new activity.
  ///@param height The initial height of the new activity.
  ///@return Returns a new ActivityOptions object that you can use to
  /// supply these options as the options Bundle when starting an activity.
  static ActivityOptions makeScaleUpAnimation(
          jni.JlObject source, int startX, int startY, int width, int height) =>
      ActivityOptions.fromRef(_makeScaleUpAnimation(
          source.reference, startX, startY, width, height));

  static final _makeClipRevealAnimation = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32)>>(
          "android_app_ActivityOptions_makeClipRevealAnimation")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: static public android.app.ActivityOptions makeClipRevealAnimation(android.view.View source, int startX, int startY, int width, int height)
  /// Create an ActivityOptions specifying an animation where the new
  /// activity is revealed from a small originating area of the screen to
  /// its final full representation.
  ///@param source The View that the new activity is animating from.  This
  /// defines the coordinate space for <var>startX</var> and <var>startY</var>.
  ///@param startX The x starting location of the new activity, relative to <var>source</var>.
  ///@param startY The y starting location of the activity, relative to <var>source</var>.
  ///@param width The initial width of the new activity.
  ///@param height The initial height of the new activity.
  ///@return Returns a new ActivityOptions object that you can use to
  /// supply these options as the options Bundle when starting an activity.
  static ActivityOptions makeClipRevealAnimation(
          jni.JlObject source, int startX, int startY, int width, int height) =>
      ActivityOptions.fromRef(_makeClipRevealAnimation(
          source.reference, startX, startY, width, height));

  static final _makeThumbnailScaleUpAnimation = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_app_ActivityOptions_makeThumbnailScaleUpAnimation")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: static public android.app.ActivityOptions makeThumbnailScaleUpAnimation(android.view.View source, android.graphics.Bitmap thumbnail, int startX, int startY)
  /// Create an ActivityOptions specifying an animation where a thumbnail
  /// is scaled from a given position to the new activity window that is
  /// being started.
  ///
  /// If the Intent this is being used with has not set its
  /// android.content.Intent\#setSourceBounds Intent.setSourceBounds,
  /// those bounds will be filled in for you based on the initial
  /// thumbnail location and size provided here.
  ///@param source The View that this thumbnail is animating from.  This
  /// defines the coordinate space for <var>startX</var> and <var>startY</var>.
  ///@param thumbnail The bitmap that will be shown as the initial thumbnail
  /// of the animation.
  ///@param startX The x starting location of the bitmap, relative to <var>source</var>.
  ///@param startY The y starting location of the bitmap, relative to <var>source</var>.
  ///@return Returns a new ActivityOptions object that you can use to
  /// supply these options as the options Bundle when starting an activity.
  static ActivityOptions makeThumbnailScaleUpAnimation(jni.JlObject source,
          jni.JlObject thumbnail, int startX, int startY) =>
      ActivityOptions.fromRef(_makeThumbnailScaleUpAnimation(
          source.reference, thumbnail.reference, startX, startY));

  static final _makeSceneTransitionAnimation = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityOptions_makeSceneTransitionAnimation")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.ActivityOptions makeSceneTransitionAnimation(android.app.Activity activity, android.view.View sharedElement, java.lang.String sharedElementName)
  /// Create an ActivityOptions to transition between Activities using cross-Activity scene
  /// animations. This method carries the position of one shared element to the started Activity.
  /// The position of <code>sharedElement</code> will be used as the epicenter for the
  /// exit Transition. The position of the shared element in the launched Activity will be the
  /// epicenter of its entering Transition.
  ///
  /// This requires android.view.Window\#FEATURE_ACTIVITY_TRANSITIONS to be
  /// enabled on the calling Activity to cause an exit transition. The same must be in
  /// the called Activity to get an entering transition.
  ///
  ///@param activity The Activity whose window contains the shared elements.
  ///@param sharedElement The View to transition to the started Activity.
  ///@param sharedElementName The shared element name as used in the target Activity. This
  ///                          must not be null.
  ///@return Returns a new ActivityOptions object that you can use to
  ///         supply these options as the options Bundle when starting an activity.
  ///@see android.transition.Transition\#setEpicenterCallback(
  ///          android.transition.Transition.EpicenterCallback)
  static ActivityOptions makeSceneTransitionAnimation(Activity activity,
          jni.JlObject sharedElement, jni.JlString sharedElementName) =>
      ActivityOptions.fromRef(_makeSceneTransitionAnimation(activity.reference,
          sharedElement.reference, sharedElementName.reference));

  static final _makeSceneTransitionAnimation_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityOptions_makeSceneTransitionAnimation_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.ActivityOptions makeSceneTransitionAnimation(android.app.Activity activity, android.util.Pair<android.view.View,java.lang.String>[] sharedElements)
  /// Create an ActivityOptions to transition between Activities using cross-Activity scene
  /// animations. This method carries the position of multiple shared elements to the started
  /// Activity. The position of the first element in sharedElements
  /// will be used as the epicenter for the exit Transition. The position of the associated
  /// shared element in the launched Activity will be the epicenter of its entering Transition.
  ///
  /// This requires android.view.Window\#FEATURE_ACTIVITY_TRANSITIONS to be
  /// enabled on the calling Activity to cause an exit transition. The same must be in
  /// the called Activity to get an entering transition.
  ///
  ///@param activity The Activity whose window contains the shared elements.
  ///@param sharedElements The names of the shared elements to transfer to the called
  ///                       Activity and their associated Views. The Views must each have
  ///                       a unique shared element name.
  ///@return Returns a new ActivityOptions object that you can use to
  ///         supply these options as the options Bundle when starting an activity.
  ///@see android.transition.Transition\#setEpicenterCallback(
  ///          android.transition.Transition.EpicenterCallback)
  static ActivityOptions makeSceneTransitionAnimation_1(
          Activity activity, jni.JlObject sharedElements) =>
      ActivityOptions.fromRef(_makeSceneTransitionAnimation_1(
          activity.reference, sharedElements.reference));

  static final _makeTaskLaunchBehind =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ActivityOptions_makeTaskLaunchBehind")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.app.ActivityOptions makeTaskLaunchBehind()
  /// If set along with Intent.FLAG_ACTIVITY_NEW_DOCUMENT then the task being launched will not be
  /// presented to the user but will instead be only available through the recents task list.
  /// In addition, the new task wil be affiliated with the launching activity's task.
  /// Affiliated tasks are grouped together in the recents task list.
  ///
  /// This behavior is not supported for activities with android.R.styleable\#AndroidManifestActivity_launchMode launchMode values of
  /// <code>singleInstance</code> or <code>singleTask</code>.
  static ActivityOptions makeTaskLaunchBehind() =>
      ActivityOptions.fromRef(_makeTaskLaunchBehind());

  static final _makeBasic =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ActivityOptions_makeBasic")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.app.ActivityOptions makeBasic()
  /// Create a basic ActivityOptions that has no special animation associated with it.
  /// Other options can still be set.
  static ActivityOptions makeBasic() => ActivityOptions.fromRef(_makeBasic());

  static final _setLaunchBounds = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityOptions_setLaunchBounds")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.ActivityOptions setLaunchBounds(android.graphics.Rect screenSpacePixelRect)
  /// Sets the bounds (window size) that the activity should be launched in.
  /// Rect position should be provided in pixels and in screen coordinates.
  /// Set to null explicitly for fullscreen.
  ///
  /// <strong>NOTE:<strong/> This value is ignored on devices that don't have
  /// android.content.pm.PackageManager\#FEATURE_FREEFORM_WINDOW_MANAGEMENT or
  /// android.content.pm.PackageManager\#FEATURE_PICTURE_IN_PICTURE enabled.
  ///@param screenSpacePixelRect Launch bounds to use for the activity or null for fullscreen.
  ///
  /// This value may be {@code null}.
  ActivityOptions setLaunchBounds(jni.JlObject screenSpacePixelRect) =>
      ActivityOptions.fromRef(
          _setLaunchBounds(reference, screenSpacePixelRect.reference));

  static final _getLaunchBounds = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityOptions_getLaunchBounds")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Rect getLaunchBounds()
  /// Returns the bounds that should be used to launch the activity.
  ///@see \#setLaunchBounds(Rect)
  ///@return Bounds used to launch the activity.
  ///
  /// This value may be {@code null}.
  jni.JlObject getLaunchBounds() =>
      jni.JlObject.fromRef(_getLaunchBounds(reference));

  static final _getLockTaskMode =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityOptions_getLockTaskMode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getLockTaskMode()
  /// Gets whether the activity is to be launched into LockTask mode.
  ///@return {@code true} if the activity is to be launched into LockTask mode.
  ///@see Activity\#startLockTask()
  ///@see android.app.admin.DevicePolicyManager\#setLockTaskPackages(ComponentName, String[])
  bool getLockTaskMode() => _getLockTaskMode(reference) != 0;

  static final _setLockTaskEnabled = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_ActivityOptions_setLockTaskEnabled")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.ActivityOptions setLockTaskEnabled(boolean lockTaskMode)
  /// Sets whether the activity is to be launched into LockTask mode.
  ///
  /// Use this option to start an activity in LockTask mode. Note that only apps permitted by
  /// android.app.admin.DevicePolicyManager can run in LockTask mode. Therefore, if
  /// android.app.admin.DevicePolicyManager\#isLockTaskPermitted(String) returns
  /// {@code false} for the package of the target activity, a SecurityException will be
  /// thrown during Context\#startActivity(Intent, Bundle). This method doesn't affect
  /// activities that are already running \u2014 relaunch the activity to run in lock task mode.
  ///
  /// Defaults to {@code false} if not set.
  ///@param lockTaskMode {@code true} if the activity is to be launched into LockTask mode.
  ///@return {@code this} ActivityOptions instance.
  ///@see Activity\#startLockTask()
  ///@see android.app.admin.DevicePolicyManager\#setLockTaskPackages(ComponentName, String[])
  ActivityOptions setLockTaskEnabled(bool lockTaskMode) =>
      ActivityOptions.fromRef(
          _setLockTaskEnabled(reference, lockTaskMode ? 1 : 0));

  static final _getLaunchDisplayId =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityOptions_getLaunchDisplayId")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLaunchDisplayId()
  /// Gets the id of the display where activity should be launched.
  ///@return The id of the display where activity should be launched,
  ///         android.view.Display\#INVALID_DISPLAY if not set.
  ///@see \#setLaunchDisplayId(int)
  int getLaunchDisplayId() => _getLaunchDisplayId(reference);

  static final _setLaunchDisplayId = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ActivityOptions_setLaunchDisplayId")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.ActivityOptions setLaunchDisplayId(int launchDisplayId)
  /// Sets the id of the display where activity should be launched.
  /// An app can launch activities on public displays or private displays that are owned by the app
  /// or where an app already has activities. Otherwise, trying to launch on a private display
  /// or providing an invalid display id will result in an exception.
  ///
  /// Setting launch display id will be ignored on devices that don't have
  /// android.content.pm.PackageManager\#FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS.
  ///@param launchDisplayId The id of the display where the activity should be launched.
  ///@return {@code this} ActivityOptions instance.
  ActivityOptions setLaunchDisplayId(int launchDisplayId) =>
      ActivityOptions.fromRef(_setLaunchDisplayId(reference, launchDisplayId));

  static final _update = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_ActivityOptions_update")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void update(android.app.ActivityOptions otherOptions)
  /// Update the current values in this ActivityOptions from those supplied
  /// in <var>otherOptions</var>.  Any values
  /// defined in <var>otherOptions</var> replace those in the base options.
  void update(ActivityOptions otherOptions) =>
      _update(reference, otherOptions.reference);

  static final _toBundle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityOptions_toBundle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle toBundle()
  /// Returns the created options as a Bundle, which can be passed to
  /// android.content.Context\#startActivity(android.content.Intent, android.os.Bundle) Context.startActivity(Intent, Bundle) and related methods.
  /// Note that the returned Bundle is still owned by the ActivityOptions
  /// object; you must not modify it, but can supply it to the startActivity
  /// methods that take an options Bundle.
  os.Bundle toBundle() => os.Bundle.fromRef(_toBundle(reference));

  static final _requestUsageTimeReport = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityOptions_requestUsageTimeReport")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void requestUsageTimeReport(android.app.PendingIntent receiver)
  /// Ask the the system track that time the user spends in the app being launched, and
  /// report it back once done.  The report will be sent to the given receiver, with
  /// the extras \#EXTRA_USAGE_TIME_REPORT and \#EXTRA_USAGE_TIME_REPORT_PACKAGES
  /// filled in.
  ///
  /// The time interval tracked is from launching this activity until the user leaves
  /// that activity's flow.  They are considered to stay in the flow as long as
  /// new activities are being launched or returned to from the original flow,
  /// even if this crosses package or task boundaries.  For example, if the originator
  /// starts an activity to view an image, and while there the user selects to share,
  /// which launches their email app in a new task, and they complete the share, the
  /// time during that entire operation will be included until they finally hit back from
  /// the original image viewer activity.
  ///
  ///
  /// The user is considered to complete a flow once they switch to another
  /// activity that is not part of the tracked flow.  This may happen, for example, by
  /// using the notification shade, launcher, or recents to launch or switch to another
  /// app.  Simply going in to these navigation elements does not break the flow (although
  /// the launcher and recents stops time tracking of the session); it is the act of
  /// going somewhere else that completes the tracking.
  ///
  ///@param receiver A broadcast receiver that willl receive the report.
  void requestUsageTimeReport(PendingIntent receiver) =>
      _requestUsageTimeReport(reference, receiver.reference);

  static final _setAppVerificationBundle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityOptions_setAppVerificationBundle")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.ActivityOptions setAppVerificationBundle(android.os.Bundle bundle)
  /// Set the Bundle that is provided to the app installer for additional verification
  /// if the call to Context\#startActivity results in an app being installed.
  ///
  /// This Bundle is not provided to any other app besides the installer.
  ActivityOptions setAppVerificationBundle(os.Bundle bundle) =>
      ActivityOptions.fromRef(
          _setAppVerificationBundle(reference, bundle.reference));

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityOptions_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// @hide
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));
}

/// Base class for implementing application instrumentation code.  When running
/// with instrumentation turned on, this class will be instantiated for you
/// before any of the application code, allowing you to monitor all of the
/// interaction the system has with the application.  An Instrumentation
/// implementation is described to the system through an AndroidManifest.xml's
/// &lt;instrumentation&gt; tag.
class Instrumentation extends jni.JlObject {
  Instrumentation.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String REPORT_KEY_IDENTIFIER
  /// If included in the status or final bundle sent to an IInstrumentationWatcher, this key
  /// identifies the class that is writing the report.  This can be used to provide more structured
  /// logging or reporting capabilities in the IInstrumentationWatcher.
  static const REPORT_KEY_IDENTIFIER = "id";

  /// from: static public final java.lang.String REPORT_KEY_STREAMRESULT
  /// If included in the status or final bundle sent to an IInstrumentationWatcher, this key
  /// identifies a string which can simply be printed to the output stream.  Using these streams
  /// provides a "pretty printer" version of the status & final packets.  Any bundles including
  /// this key should also include the complete set of raw key/value pairs, so that the
  /// instrumentation can also be launched, and results collected, by an automated system.
  static const REPORT_KEY_STREAMRESULT = "stream";

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Instrumentation_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Instrumentation() : super.fromRef(_ctor());

  static final _onCreate = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_onCreate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreate(android.os.Bundle arguments)
  /// Called when the instrumentation is starting, before any application code
  /// has been loaded.  Usually this will be implemented to simply call
  /// \#start to begin the instrumentation thread, which will then
  /// continue execution in \#onStart.
  ///
  /// If you do not need your own thread -- that is you are writing your
  /// instrumentation to be completely asynchronous (returning to the event
  /// loop so that the application can run), you can simply begin your
  /// instrumentation here, for example call Context\#startActivity to
  /// begin the appropriate first activity of the application.
  ///@param arguments Any additional arguments that were supplied when the
  ///                  instrumentation was started.
  void onCreate(os.Bundle arguments) =>
      _onCreate(reference, arguments.reference);

  static final _start =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Instrumentation_start")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void start()
  /// Create and start a new thread in which to run instrumentation.  This new
  /// thread will call to \#onStart where you can implement the
  /// instrumentation.
  void start() => _start(reference);

  static final _onStart =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Instrumentation_onStart")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onStart()
  /// Method where the instrumentation thread enters execution.  This allows
  /// you to run your instrumentation code in a separate thread than the
  /// application, so that it can perform blocking operation such as
  /// \#sendKeySync or \#startActivitySync.
  ///
  /// You will typically want to call finish() when this function is done,
  /// to end your instrumentation.
  void onStart() => _onStart(reference);

  static final _onException = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_onException")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onException(java.lang.Object obj, java.lang.Throwable e)
  /// This is called whenever the system captures an unhandled exception that
  /// was thrown by the application.  The default implementation simply
  /// returns false, allowing normal system handling of the exception to take
  /// place.
  ///@param obj The client object that generated the exception.  May be an
  ///            Application, Activity, BroadcastReceiver, Service, or null.
  ///@param e The exception that was thrown.
  ///@return To allow normal system exception process to occur, return false.
  ///         If true is returned, the system will proceed as if the exception
  ///         didn't happen.
  bool onException(jni.JlObject obj, jni.JlObject e) =>
      _onException(reference, obj.reference, e.reference) != 0;

  static final _sendStatus = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_sendStatus")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void sendStatus(int resultCode, android.os.Bundle results)
  /// Provide a status report about the application.
  ///@param resultCode Current success/failure of instrumentation.
  ///@param results Any results to send back to the code that started the instrumentation.
  void sendStatus(int resultCode, os.Bundle results) =>
      _sendStatus(reference, resultCode, results.reference);

  static final _addResults = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_addResults")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void addResults(android.os.Bundle results)
  /// Report some results in the middle of instrumentation execution.  Later results (including
  /// those provided by \#finish) will be combined with Bundle\#putAll.
  void addResults(os.Bundle results) =>
      _addResults(reference, results.reference);

  static final _finish = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_Instrumentation_finish")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void finish(int resultCode, android.os.Bundle results)
  /// Terminate instrumentation of the application.  This will cause the
  /// application process to exit, removing this instrumentation from the next
  /// time the application is started.  If multiple processes are currently running
  /// for this instrumentation, all of those processes will be killed.
  ///@param resultCode Overall success/failure of instrumentation.
  ///@param results Any results to send back to the code that started the
  ///                instrumentation.
  void finish(int resultCode, os.Bundle results) =>
      _finish(reference, resultCode, results.reference);

  static final _setAutomaticPerformanceSnapshots =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Instrumentation_setAutomaticPerformanceSnapshots")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void setAutomaticPerformanceSnapshots()
  void setAutomaticPerformanceSnapshots() =>
      _setAutomaticPerformanceSnapshots(reference);

  static final _startPerformanceSnapshot =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Instrumentation_startPerformanceSnapshot")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void startPerformanceSnapshot()
  void startPerformanceSnapshot() => _startPerformanceSnapshot(reference);

  static final _endPerformanceSnapshot =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Instrumentation_endPerformanceSnapshot")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void endPerformanceSnapshot()
  void endPerformanceSnapshot() => _endPerformanceSnapshot(reference);

  static final _onDestroy =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Instrumentation_onDestroy")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDestroy()
  /// Called when the instrumented application is stopping, after all of the
  /// normal application cleanup has occurred.
  void onDestroy() => _onDestroy(reference);

  static final _getContext = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_getContext")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context getContext()
  /// Return the Context of this instrumentation's package.  Note that this is
  /// often different than the Context of the application being
  /// instrumentated, since the instrumentation code often lives is a
  /// different package than that of the application it is running against.
  /// See \#getTargetContext to retrieve a Context for the target
  /// application.
  ///@return The instrumentation's package context.
  ///@see \#getTargetContext
  content.Context getContext() =>
      content.Context.fromRef(_getContext(reference));

  static final _getComponentName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_getComponentName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getComponentName()
  /// Returns complete component name of this instrumentation.
  ///@return Returns the complete component name for this instrumentation.
  content.ComponentName getComponentName() =>
      content.ComponentName.fromRef(_getComponentName(reference));

  static final _getTargetContext = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_getTargetContext")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context getTargetContext()
  /// Return a Context for the target application being instrumented.  Note
  /// that this is often different than the Context of the instrumentation
  /// code, since the instrumentation code often lives is a different package
  /// than that of the application it is running against. See
  /// \#getContext to retrieve a Context for the instrumentation code.
  ///@return A Context in the target application.
  ///@see \#getContext
  content.Context getTargetContext() =>
      content.Context.fromRef(_getTargetContext(reference));

  static final _getProcessName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_getProcessName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getProcessName()
  /// Return the name of the process this instrumentation is running in.  Note this should
  /// only be used for testing and debugging.  If you are thinking about using this to,
  /// for example, conditionalize what is initialized in an Application class, it is strongly
  /// recommended to instead use lazy initialization (such as a getter for the state that
  /// only creates it when requested).  This can greatly reduce the work your process does
  /// when created for secondary things, such as to receive a broadcast.
  jni.JlString getProcessName() =>
      jni.JlString.fromRef(_getProcessName(reference));

  static final _isProfiling =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Instrumentation_isProfiling")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isProfiling()
  /// Check whether this instrumentation was started with profiling enabled.
  ///@return Returns true if profiling was enabled when starting, else false.
  bool isProfiling() => _isProfiling(reference) != 0;

  static final _startProfiling =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Instrumentation_startProfiling")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void startProfiling()
  /// This method will start profiling if isProfiling() returns true. You should
  /// only call this method if you set the handleProfiling attribute in the
  /// manifest file for this Instrumentation to true.
  void startProfiling() => _startProfiling(reference);

  static final _stopProfiling =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Instrumentation_stopProfiling")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void stopProfiling()
  /// Stops profiling if isProfiling() returns true.
  void stopProfiling() => _stopProfiling(reference);

  static final _setInTouchMode = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Instrumentation_setInTouchMode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setInTouchMode(boolean inTouch)
  /// Force the global system in or out of touch mode.  This can be used if
  /// your instrumentation relies on the UI being in one more or the other
  /// when it starts.
  ///@param inTouch Set to true to be in touch mode, false to be in
  /// focus mode.
  void setInTouchMode(bool inTouch) =>
      _setInTouchMode(reference, inTouch ? 1 : 0);

  static final _waitForIdle = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_waitForIdle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void waitForIdle(java.lang.Runnable recipient)
  /// Schedule a callback for when the application's main thread goes idle
  /// (has no more events to process).
  ///@param recipient Called the next time the thread's message queue is
  ///                  idle.
  void waitForIdle(jni.JlObject recipient) =>
      _waitForIdle(reference, recipient.reference);

  static final _waitForIdleSync =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Instrumentation_waitForIdleSync")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void waitForIdleSync()
  /// Synchronously wait for the application to be idle.  Can not be called
  /// from the main application thread -- use \#start to execute
  /// instrumentation in its own thread.
  void waitForIdleSync() => _waitForIdleSync(reference);

  static final _runOnMainSync = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_runOnMainSync")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void runOnMainSync(java.lang.Runnable runner)
  /// Execute a call on the application's main thread, blocking until it is
  /// complete.  Useful for doing things that are not thread-safe, such as
  /// looking at or modifying the view hierarchy.
  ///@param runner The code to run on the main thread.
  void runOnMainSync(jni.JlObject runner) =>
      _runOnMainSync(reference, runner.reference);

  static final _startActivitySync = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_startActivitySync")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity startActivitySync(android.content.Intent intent)
  /// Start a new activity and wait for it to begin running before returning.
  /// In addition to being synchronous, this method as some semantic
  /// differences from the standard Context\#startActivity call: the
  /// activity component is resolved before talking with the activity manager
  /// (its class name is specified in the Intent that this method ultimately
  /// starts), and it does not allow you to start activities that run in a
  /// different process.  In addition, if the given Intent resolves to
  /// multiple activities, instead of displaying a dialog for the user to
  /// select an activity, an exception will be thrown.
  ///
  /// The function returns as soon as the activity goes idle following the
  /// call to its Activity\#onCreate.  Generally this means it has gone
  /// through the full initialization including Activity\#onResume and
  /// drawn and displayed its initial window.
  ///@param intent Description of the activity to start.
  ///@see Context\#startActivity
  ///@see \#startActivitySync(Intent, Bundle)
  Activity startActivitySync(content.Intent intent) =>
      Activity.fromRef(_startActivitySync(reference, intent.reference));

  static final _startActivitySync_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_startActivitySync_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity startActivitySync(android.content.Intent intent, android.os.Bundle options)
  /// Start a new activity and wait for it to begin running before returning.
  /// In addition to being synchronous, this method as some semantic
  /// differences from the standard Context\#startActivity call: the
  /// activity component is resolved before talking with the activity manager
  /// (its class name is specified in the Intent that this method ultimately
  /// starts), and it does not allow you to start activities that run in a
  /// different process.  In addition, if the given Intent resolves to
  /// multiple activities, instead of displaying a dialog for the user to
  /// select an activity, an exception will be thrown.
  ///
  /// The function returns as soon as the activity goes idle following the
  /// call to its Activity\#onCreate.  Generally this means it has gone
  /// through the full initialization including Activity\#onResume and
  /// drawn and displayed its initial window.
  ///@param intent Description of the activity to start.
  /// This value must never be {@code null}.
  ///@param options Additional options for how the Activity should be started.
  /// May be null if there are no options.  See android.app.ActivityOptions
  /// for how to build the Bundle supplied here; there are no supported definitions
  /// for building it manually.
  ///
  /// This value may be {@code null}.
  ///@see Context\#startActivity(Intent, Bundle)
  Activity startActivitySync_1(content.Intent intent, os.Bundle options) =>
      Activity.fromRef(
          _startActivitySync_1(reference, intent.reference, options.reference));

  static final _addMonitor = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_addMonitor")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void addMonitor(android.app.Instrumentation.ActivityMonitor monitor)
  /// Add a new ActivityMonitor that will be checked whenever an
  /// activity is started.  The monitor is added
  /// after any existing ones; the monitor will be hit only if none of the
  /// existing monitors can themselves handle the Intent.
  ///@param monitor The new ActivityMonitor to see.
  ///@see \#addMonitor(IntentFilter, ActivityResult, boolean)
  ///@see \#checkMonitorHit
  void addMonitor(Instrumentation_ActivityMonitor monitor) =>
      _addMonitor(reference, monitor.reference);

  static final _addMonitor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Instrumentation_addMonitor_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Instrumentation.ActivityMonitor addMonitor(android.content.IntentFilter filter, android.app.Instrumentation.ActivityResult result, boolean block)
  /// A convenience wrapper for \#addMonitor(ActivityMonitor) that
  /// creates an intent filter matching ActivityMonitor for you and
  /// returns it.
  ///@param filter The set of intents this monitor is responsible for.
  ///@param result A canned result to return if the monitor is hit; can
  ///               be null.
  ///@param block Controls whether the monitor should block the activity
  ///              start (returning its canned result) or let the call
  ///              proceed.
  ///@return The newly created and added activity monitor.
  ///@see \#addMonitor(ActivityMonitor)
  ///@see \#checkMonitorHit
  Instrumentation_ActivityMonitor addMonitor_1(content.IntentFilter filter,
          Instrumentation_ActivityResult result, bool block) =>
      Instrumentation_ActivityMonitor.fromRef(_addMonitor_1(
          reference, filter.reference, result.reference, block ? 1 : 0));

  static final _addMonitor_2 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_Instrumentation_addMonitor_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Instrumentation.ActivityMonitor addMonitor(java.lang.String cls, android.app.Instrumentation.ActivityResult result, boolean block)
  /// A convenience wrapper for \#addMonitor(ActivityMonitor) that
  /// creates a class matching ActivityMonitor for you and returns it.
  ///@param cls The activity class this monitor is responsible for.
  ///@param result A canned result to return if the monitor is hit; can
  ///               be null.
  ///@param block Controls whether the monitor should block the activity
  ///              start (returning its canned result) or let the call
  ///              proceed.
  ///@return The newly created and added activity monitor.
  ///@see \#addMonitor(ActivityMonitor)
  ///@see \#checkMonitorHit
  Instrumentation_ActivityMonitor addMonitor_2(jni.JlString cls,
          Instrumentation_ActivityResult result, bool block) =>
      Instrumentation_ActivityMonitor.fromRef(_addMonitor_2(
          reference, cls.reference, result.reference, block ? 1 : 0));

  static final _checkMonitorHit = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Instrumentation_checkMonitorHit")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean checkMonitorHit(android.app.Instrumentation.ActivityMonitor monitor, int minHits)
  /// Test whether an existing ActivityMonitor has been hit.  If the
  /// monitor has been hit at least <var>minHits</var> times, then it will be
  /// removed from the activity monitor list and true returned.  Otherwise it
  /// is left as-is and false is returned.
  ///@param monitor The ActivityMonitor to check.
  ///@param minHits The minimum number of hits required.
  ///@return True if the hit count has been reached, else false.
  ///@see \#addMonitor
  bool checkMonitorHit(Instrumentation_ActivityMonitor monitor, int minHits) =>
      _checkMonitorHit(reference, monitor.reference, minHits) != 0;

  static final _waitForMonitor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_waitForMonitor")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity waitForMonitor(android.app.Instrumentation.ActivityMonitor monitor)
  /// Wait for an existing ActivityMonitor to be hit.  Once the
  /// monitor has been hit, it is removed from the activity monitor list and
  /// the first created Activity object that matched it is returned.
  ///@param monitor The ActivityMonitor to wait for.
  ///@return The Activity object that matched the monitor.
  Activity waitForMonitor(Instrumentation_ActivityMonitor monitor) =>
      Activity.fromRef(_waitForMonitor(reference, monitor.reference));

  static final _waitForMonitorWithTimeout = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "android_app_Instrumentation_waitForMonitorWithTimeout")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Activity waitForMonitorWithTimeout(android.app.Instrumentation.ActivityMonitor monitor, long timeOut)
  /// Wait for an existing ActivityMonitor to be hit till the timeout
  /// expires.  Once the monitor has been hit, it is removed from the activity
  /// monitor list and the first created Activity object that matched it is
  /// returned.  If the timeout expires, a null object is returned.
  ///@param monitor The ActivityMonitor to wait for.
  ///@param timeOut The timeout value in milliseconds.
  ///@return The Activity object that matched the monitor.
  Activity waitForMonitorWithTimeout(
          Instrumentation_ActivityMonitor monitor, int timeOut) =>
      Activity.fromRef(
          _waitForMonitorWithTimeout(reference, monitor.reference, timeOut));

  static final _removeMonitor = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_removeMonitor")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void removeMonitor(android.app.Instrumentation.ActivityMonitor monitor)
  /// Remove an ActivityMonitor that was previously added with
  /// \#addMonitor.
  ///@param monitor The monitor to remove.
  ///@see \#addMonitor
  void removeMonitor(Instrumentation_ActivityMonitor monitor) =>
      _removeMonitor(reference, monitor.reference);

  static final _invokeMenuActionSync = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_app_Instrumentation_invokeMenuActionSync")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public boolean invokeMenuActionSync(android.app.Activity targetActivity, int id, int flag)
  /// Execute a particular menu item.
  ///@param targetActivity The activity in question.
  ///@param id The identifier associated with the menu item.
  ///@param flag Additional flags, if any.
  ///@return Whether the invocation was successful (for example, it could be
  ///         false if item is disabled).
  bool invokeMenuActionSync(Activity targetActivity, int id, int flag) =>
      _invokeMenuActionSync(reference, targetActivity.reference, id, flag) != 0;

  static final _invokeContextMenuAction = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_app_Instrumentation_invokeContextMenuAction")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public boolean invokeContextMenuAction(android.app.Activity targetActivity, int id, int flag)
  /// Show the context menu for the currently focused view and executes a
  /// particular context menu item.
  ///@param targetActivity The activity in question.
  ///@param id The identifier associated with the context menu item.
  ///@param flag Additional flags, if any.
  ///@return Whether the invocation was successful (for example, it could be
  ///         false if item is disabled).
  bool invokeContextMenuAction(Activity targetActivity, int id, int flag) =>
      _invokeContextMenuAction(reference, targetActivity.reference, id, flag) !=
      0;

  static final _sendStringSync = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_sendStringSync")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void sendStringSync(java.lang.String text)
  /// Sends the key events corresponding to the text to the app being
  /// instrumented.
  ///@param text The text to be sent.
  void sendStringSync(jni.JlString text) =>
      _sendStringSync(reference, text.reference);

  static final _sendKeySync = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_sendKeySync")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void sendKeySync(android.view.KeyEvent event)
  /// Send a key event to the currently focused window/view and wait for it to
  /// be processed.  Finished at some point after the recipient has returned
  /// from its event processing, though it may _not_ have completely
  /// finished reacting from the event -- for example, if it needs to update
  /// its display as a result, it may still be in the process of doing that.
  ///@param event The event to send to the current focus.
  void sendKeySync(jni.JlObject event) =>
      _sendKeySync(reference, event.reference);

  static final _sendKeyDownUpSync = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Instrumentation_sendKeyDownUpSync")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void sendKeyDownUpSync(int key)
  /// Sends an up and down key event sync to the currently focused window.
  ///@param key The integer keycode for the event.
  void sendKeyDownUpSync(int key) => _sendKeyDownUpSync(reference, key);

  static final _sendCharacterSync = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Instrumentation_sendCharacterSync")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void sendCharacterSync(int keyCode)
  /// Higher-level method for sending both the down and up key events for a
  /// particular character key code.  Equivalent to creating both KeyEvent
  /// objects by hand and calling \#sendKeySync.  The event appears
  /// as if it came from keyboard 0, the built in one.
  ///@param keyCode The key code of the character to send.
  void sendCharacterSync(int keyCode) => _sendCharacterSync(reference, keyCode);

  static final _sendPointerSync = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_sendPointerSync")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void sendPointerSync(android.view.MotionEvent event)
  /// Dispatch a pointer event. Finished at some point after the recipient has
  /// returned from its event processing, though it may _not_ have
  /// completely finished reacting from the event -- for example, if it needs
  /// to update its display as a result, it may still be in the process of
  /// doing that.
  ///@param event A motion event describing the pointer action.  (As noted in
  /// MotionEvent\#obtain(long, long, int, float, float, int), be sure to use
  /// SystemClock\#uptimeMillis() as the timebase.
  void sendPointerSync(jni.JlObject event) =>
      _sendPointerSync(reference, event.reference);

  static final _sendTrackballEventSync = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_sendTrackballEventSync")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void sendTrackballEventSync(android.view.MotionEvent event)
  /// Dispatch a trackball event. Finished at some point after the recipient has
  /// returned from its event processing, though it may _not_ have
  /// completely finished reacting from the event -- for example, if it needs
  /// to update its display as a result, it may still be in the process of
  /// doing that.
  ///@param event A motion event describing the trackball action.  (As noted in
  /// MotionEvent\#obtain(long, long, int, float, float, int), be sure to use
  /// SystemClock\#uptimeMillis() as the timebase.
  void sendTrackballEventSync(jni.JlObject event) =>
      _sendTrackballEventSync(reference, event.reference);

  static final _newApplication = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_newApplication")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Application newApplication(java.lang.ClassLoader cl, java.lang.String className, android.content.Context context)
  /// Perform instantiation of the process's Application object.  The
  /// default implementation provides the normal system behavior.
  ///@param cl The ClassLoader with which to instantiate the object.
  ///@param className The name of the class implementing the Application
  ///                  object.
  ///@param context The context to initialize the application with
  ///@return The newly instantiated Application object.
  Application newApplication(
          jni.JlObject cl, jni.JlString className, content.Context context) =>
      Application.fromRef(_newApplication(
          reference, cl.reference, className.reference, context.reference));

  static final _newApplication_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_newApplication_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.Application newApplication(java.lang.Class<?> clazz, android.content.Context context)
  /// Perform instantiation of the process's Application object.  The
  /// default implementation provides the normal system behavior.
  ///@param clazz The class used to create an Application object from.
  ///@param context The context to initialize the application with
  ///@return The newly instantiated Application object.
  static Application newApplication_1(
          jni.JlObject clazz, content.Context context) =>
      Application.fromRef(
          _newApplication_1(clazz.reference, context.reference));

  static final _callApplicationOnCreate = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_callApplicationOnCreate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callApplicationOnCreate(android.app.Application app)
  /// Perform calling of the application's Application\#onCreate
  /// method.  The default implementation simply calls through to that method.
  ///
  /// Note: This method will be called immediately after \#onCreate(Bundle).
  /// Often instrumentation tests start their test thread in onCreate(); you
  /// need to be careful of races between these.  (Well between it and
  /// everything else, but let's start here.)
  ///@param app The application being created.
  void callApplicationOnCreate(Application app) =>
      _callApplicationOnCreate(reference, app.reference);

  static final _newActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_newActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity newActivity(java.lang.Class<?> clazz, android.content.Context context, android.os.IBinder token, android.app.Application application, android.content.Intent intent, android.content.pm.ActivityInfo info, java.lang.CharSequence title, android.app.Activity parent, java.lang.String id, java.lang.Object lastNonConfigurationInstance)
  /// Perform instantiation of an Activity object.  This method is intended for use with
  /// unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
  /// locally but will be missing some of the linkages necessary for use within the system.
  ///@param clazz The Class of the desired Activity
  ///@param context The base context for the activity to use
  ///@param token The token for this activity to communicate with
  ///@param application The application object (if any)
  ///@param intent The intent that started this Activity
  ///@param info ActivityInfo from the manifest
  ///@param title The title, typically retrieved from the ActivityInfo record
  ///@param parent The parent Activity (if any)
  ///@param id The embedded Id (if any)
  ///@param lastNonConfigurationInstance Arbitrary object that will be
  /// available via Activity\#getLastNonConfigurationInstance() Activity.getLastNonConfigurationInstance().
  ///@return Returns the instantiated activity
  ///@throws InstantiationException
  ///@throws IllegalAccessException
  Activity newActivity(
          jni.JlObject clazz,
          content.Context context,
          os.IBinder token,
          Application application,
          content.Intent intent,
          pm.ActivityInfo info,
          jni.JlObject title,
          Activity parent,
          jni.JlString id,
          jni.JlObject lastNonConfigurationInstance) =>
      Activity.fromRef(_newActivity(
          reference,
          clazz.reference,
          context.reference,
          token.reference,
          application.reference,
          intent.reference,
          info.reference,
          title.reference,
          parent.reference,
          id.reference,
          lastNonConfigurationInstance.reference));

  static final _newActivity_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_newActivity_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity newActivity(java.lang.ClassLoader cl, java.lang.String className, android.content.Intent intent)
  /// Perform instantiation of the process's Activity object.  The
  /// default implementation provides the normal system behavior.
  ///@param cl The ClassLoader with which to instantiate the object.
  ///@param className The name of the class implementing the Activity
  ///                  object.
  ///@param intent The Intent object that specified the activity class being
  ///               instantiated.
  ///@return The newly instantiated Activity object.
  Activity newActivity_1(
          jni.JlObject cl, jni.JlString className, content.Intent intent) =>
      Activity.fromRef(_newActivity_1(
          reference, cl.reference, className.reference, intent.reference));

  static final _callActivityOnCreate = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_callActivityOnCreate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnCreate(android.app.Activity activity, android.os.Bundle icicle)
  /// Perform calling of an activity's Activity\#onCreate
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being created.
  ///@param icicle The previously frozen state (or null) to pass through to onCreate().
  void callActivityOnCreate(Activity activity, os.Bundle icicle) =>
      _callActivityOnCreate(reference, activity.reference, icicle.reference);

  static final _callActivityOnCreate_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_callActivityOnCreate_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnCreate(android.app.Activity activity, android.os.Bundle icicle, android.os.PersistableBundle persistentState)
  /// Perform calling of an activity's Activity\#onCreate
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being created.
  ///@param icicle The previously frozen state (or null) to pass through to
  ///@param persistentState The previously persisted state (or null)
  void callActivityOnCreate_1(Activity activity, os.Bundle icicle,
          os.PersistableBundle persistentState) =>
      _callActivityOnCreate_1(reference, activity.reference, icicle.reference,
          persistentState.reference);

  static final _callActivityOnDestroy = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_callActivityOnDestroy")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnDestroy(android.app.Activity activity)
  void callActivityOnDestroy(Activity activity) =>
      _callActivityOnDestroy(reference, activity.reference);

  static final _callActivityOnRestoreInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_callActivityOnRestoreInstanceState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnRestoreInstanceState(android.app.Activity activity, android.os.Bundle savedInstanceState)
  /// Perform calling of an activity's Activity\#onRestoreInstanceState
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being restored.
  ///@param savedInstanceState The previously saved state being restored.
  void callActivityOnRestoreInstanceState(
          Activity activity, os.Bundle savedInstanceState) =>
      _callActivityOnRestoreInstanceState(
          reference, activity.reference, savedInstanceState.reference);

  static final _callActivityOnRestoreInstanceState_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_callActivityOnRestoreInstanceState_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnRestoreInstanceState(android.app.Activity activity, android.os.Bundle savedInstanceState, android.os.PersistableBundle persistentState)
  /// Perform calling of an activity's Activity\#onRestoreInstanceState
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being restored.
  ///@param savedInstanceState The previously saved state being restored.
  ///@param persistentState The previously persisted state (or null)
  void callActivityOnRestoreInstanceState_1(Activity activity,
          os.Bundle savedInstanceState, os.PersistableBundle persistentState) =>
      _callActivityOnRestoreInstanceState_1(reference, activity.reference,
          savedInstanceState.reference, persistentState.reference);

  static final _callActivityOnPostCreate = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_callActivityOnPostCreate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnPostCreate(android.app.Activity activity, android.os.Bundle icicle)
  /// Perform calling of an activity's Activity\#onPostCreate method.
  /// The default implementation simply calls through to that method.
  ///@param activity The activity being created.
  ///@param icicle The previously frozen state (or null) to pass through to
  ///               onPostCreate().
  void callActivityOnPostCreate(Activity activity, os.Bundle icicle) =>
      _callActivityOnPostCreate(
          reference, activity.reference, icicle.reference);

  static final _callActivityOnPostCreate_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_callActivityOnPostCreate_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnPostCreate(android.app.Activity activity, android.os.Bundle icicle, android.os.PersistableBundle persistentState)
  /// Perform calling of an activity's Activity\#onPostCreate method.
  /// The default implementation simply calls through to that method.
  ///@param activity The activity being created.
  ///@param icicle The previously frozen state (or null) to pass through to
  ///               onPostCreate().
  void callActivityOnPostCreate_1(Activity activity, os.Bundle icicle,
          os.PersistableBundle persistentState) =>
      _callActivityOnPostCreate_1(reference, activity.reference,
          icicle.reference, persistentState.reference);

  static final _callActivityOnNewIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_callActivityOnNewIntent")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnNewIntent(android.app.Activity activity, android.content.Intent intent)
  /// Perform calling of an activity's Activity\#onNewIntent
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity receiving a new Intent.
  ///@param intent The new intent being received.
  void callActivityOnNewIntent(Activity activity, content.Intent intent) =>
      _callActivityOnNewIntent(reference, activity.reference, intent.reference);

  static final _callActivityOnStart = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_callActivityOnStart")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnStart(android.app.Activity activity)
  /// Perform calling of an activity's Activity\#onStart
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being started.
  void callActivityOnStart(Activity activity) =>
      _callActivityOnStart(reference, activity.reference);

  static final _callActivityOnRestart = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_callActivityOnRestart")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnRestart(android.app.Activity activity)
  /// Perform calling of an activity's Activity\#onRestart
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being restarted.
  void callActivityOnRestart(Activity activity) =>
      _callActivityOnRestart(reference, activity.reference);

  static final _callActivityOnResume = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_callActivityOnResume")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnResume(android.app.Activity activity)
  /// Perform calling of an activity's Activity\#onResume method.  The
  /// default implementation simply calls through to that method.
  ///@param activity The activity being resumed.
  void callActivityOnResume(Activity activity) =>
      _callActivityOnResume(reference, activity.reference);

  static final _callActivityOnStop = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_callActivityOnStop")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnStop(android.app.Activity activity)
  /// Perform calling of an activity's Activity\#onStop
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being stopped.
  void callActivityOnStop(Activity activity) =>
      _callActivityOnStop(reference, activity.reference);

  static final _callActivityOnSaveInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_callActivityOnSaveInstanceState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnSaveInstanceState(android.app.Activity activity, android.os.Bundle outState)
  /// Perform calling of an activity's Activity\#onSaveInstanceState
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being saved.
  ///@param outState The bundle to pass to the call.
  void callActivityOnSaveInstanceState(Activity activity, os.Bundle outState) =>
      _callActivityOnSaveInstanceState(
          reference, activity.reference, outState.reference);

  static final _callActivityOnSaveInstanceState_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_callActivityOnSaveInstanceState_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnSaveInstanceState(android.app.Activity activity, android.os.Bundle outState, android.os.PersistableBundle outPersistentState)
  /// Perform calling of an activity's Activity\#onSaveInstanceState
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being saved.
  ///@param outState The bundle to pass to the call.
  ///@param outPersistentState The persistent bundle to pass to the call.
  void callActivityOnSaveInstanceState_1(Activity activity, os.Bundle outState,
          os.PersistableBundle outPersistentState) =>
      _callActivityOnSaveInstanceState_1(reference, activity.reference,
          outState.reference, outPersistentState.reference);

  static final _callActivityOnPause = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_callActivityOnPause")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnPause(android.app.Activity activity)
  /// Perform calling of an activity's Activity\#onPause method.  The
  /// default implementation simply calls through to that method.
  ///@param activity The activity being paused.
  void callActivityOnPause(Activity activity) =>
      _callActivityOnPause(reference, activity.reference);

  static final _callActivityOnUserLeaving = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_callActivityOnUserLeaving")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnUserLeaving(android.app.Activity activity)
  /// Perform calling of an activity's Activity\#onUserLeaveHint method.
  /// The default implementation simply calls through to that method.
  ///@param activity The activity being notified that the user has navigated away
  void callActivityOnUserLeaving(Activity activity) =>
      _callActivityOnUserLeaving(reference, activity.reference);

  static final _startAllocCounting =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Instrumentation_startAllocCounting")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void startAllocCounting()
  void startAllocCounting() => _startAllocCounting(reference);

  static final _stopAllocCounting =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Instrumentation_stopAllocCounting")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void stopAllocCounting()
  void stopAllocCounting() => _stopAllocCounting(reference);

  static final _getAllocCounts = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_getAllocCounts")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getAllocCounts()
  /// Returns a bundle with the current results from the allocation counting.
  os.Bundle getAllocCounts() => os.Bundle.fromRef(_getAllocCounts(reference));

  static final _getBinderCounts = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_getBinderCounts")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getBinderCounts()
  /// Returns a bundle with the counts for various binder counts for this process. Currently the only two that are
  /// reported are the number of send and the number of received transactions.
  os.Bundle getBinderCounts() => os.Bundle.fromRef(_getBinderCounts(reference));

  static final _getUiAutomation = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_getUiAutomation")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.UiAutomation getUiAutomation()
  /// Gets the UiAutomation instance with no flags set.
  ///
  /// <strong>Note:</strong> The APIs exposed via the returned UiAutomation
  /// work across application boundaries while the APIs exposed by the instrumentation
  /// do not. For example, Instrumentation\#sendPointerSync(MotionEvent) will
  /// not allow you to inject the event in an app different from the instrumentation
  /// target, while UiAutomation\#injectInputEvent(android.view.InputEvent, boolean)
  /// will work regardless of the current application.
  ///
  ///
  ///
  /// A typical test case should be using either the UiAutomation or
  /// Instrumentation APIs. Using both APIs at the same time is not
  /// a mistake by itself but a client has to be aware of the APIs limitations.
  ///
  ///
  ///
  /// Equivalent to {@code getUiAutomation(0)}. If a UiAutomation exists with different
  /// flags, the flags on that instance will be changed, and then it will be returned.
  ///
  ///
  ///@return The UI automation instance.
  ///@see UiAutomation
  UiAutomation getUiAutomation() =>
      UiAutomation.fromRef(_getUiAutomation(reference));

  static final _getUiAutomation_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Instrumentation_getUiAutomation_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.UiAutomation getUiAutomation(int flags)
  /// Gets the UiAutomation instance with flags set.
  ///
  /// <strong>Note:</strong> The APIs exposed via the returned UiAutomation
  /// work across application boundaries while the APIs exposed by the instrumentation
  /// do not. For example, Instrumentation\#sendPointerSync(MotionEvent) will
  /// not allow you to inject the event in an app different from the instrumentation
  /// target, while UiAutomation\#injectInputEvent(android.view.InputEvent, boolean)
  /// will work regardless of the current application.
  ///
  ///
  ///
  /// A typical test case should be using either the UiAutomation or
  /// Instrumentation APIs. Using both APIs at the same time is not
  /// a mistake by itself but a client has to be aware of the APIs limitations.
  ///
  ///
  ///
  /// If a UiAutomation exists with different flags, the flags on that instance will be
  /// changed, and then it will be returned.
  ///
  ///
  ///@param flags The flags to be passed to the UiAutomation, for example
  ///        UiAutomation\#FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES.
  ///
  /// Value is 0, or android.app.UiAutomation\#FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES
  ///@return The UI automation instance.
  ///@see UiAutomation
  UiAutomation getUiAutomation_1(int flags) =>
      UiAutomation.fromRef(_getUiAutomation_1(reference, flags));

  static final _acquireLooperManager = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation_acquireLooperManager")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.TestLooperManager acquireLooperManager(android.os.Looper looper)
  /// Takes control of the execution of messages on the specified looper until
  /// TestLooperManager\#release is called.
  os.TestLooperManager acquireLooperManager(os.Looper looper) =>
      os.TestLooperManager.fromRef(
          _acquireLooperManager(reference, looper.reference));
}

/// Description of a Activity execution result to return to the original
/// activity.
class Instrumentation_ActivityResult extends jni.JlObject {
  Instrumentation_ActivityResult.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation__ActivityResult_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int resultCode, android.content.Intent resultData)
  /// Create a new activity result.  See Activity\#setResult for
  /// more information.
  ///@param resultCode The result code to propagate back to the
  /// originating activity, often RESULT_CANCELED or RESULT_OK
  ///@param resultData The data to propagate back to the originating
  /// activity.
  Instrumentation_ActivityResult(int resultCode, content.Intent resultData)
      : super.fromRef(_ctor(resultCode, resultData.reference));

  static final _getResultCode =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Instrumentation__ActivityResult_getResultCode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getResultCode()
  /// Retrieve the result code contained in this result.
  int getResultCode() => _getResultCode(reference);

  static final _getResultData = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation__ActivityResult_getResultData")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent getResultData()
  /// Retrieve the data contained in this result.
  content.Intent getResultData() =>
      content.Intent.fromRef(_getResultData(reference));
}

/// Information about a particular kind of Intent that is being monitored.
/// An instance of this class is added to the
/// current instrumentation through \#addMonitor; after being added,
/// when a new activity is being started the monitor will be checked and, if
/// matching, its hit count updated and (optionally) the call stopped and a
/// canned result returned.
///
/// An ActivityMonitor can also be used to look for the creation of an
/// activity, through the \#waitForActivity method.  This will return
/// after a matching activity has been created with that activity object.
class Instrumentation_ActivityMonitor extends jni.JlObject {
  Instrumentation_ActivityMonitor.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Instrumentation__ActivityMonitor_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.IntentFilter which, android.app.Instrumentation.ActivityResult result, boolean block)
  /// Create a new ActivityMonitor that looks for a particular kind of
  /// intent to be started.
  ///@param which The set of intents this monitor is responsible for.
  ///@param result A canned result to return if the monitor is hit; can
  ///               be null.
  ///@param block Controls whether the monitor should block the activity
  ///              start (returning its canned result) or let the call
  ///              proceed.
  ///@see Instrumentation\#addMonitor
  Instrumentation_ActivityMonitor(content.IntentFilter which,
      Instrumentation_ActivityResult result, bool block)
      : super.fromRef(_ctor(which.reference, result.reference, block ? 1 : 0));

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_Instrumentation__ActivityMonitor_new_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String cls, android.app.Instrumentation.ActivityResult result, boolean block)
  /// Create a new ActivityMonitor that looks for a specific activity
  /// class to be started.
  ///@param cls The activity class this monitor is responsible for.
  ///@param result A canned result to return if the monitor is hit; can
  ///               be null.
  ///@param block Controls whether the monitor should block the activity
  ///              start (returning its canned result) or let the call
  ///              proceed.
  ///@see Instrumentation\#addMonitor
  Instrumentation_ActivityMonitor.ctor_1(
      jni.JlString cls, Instrumentation_ActivityResult result, bool block)
      : super.fromRef(_ctor_1(cls.reference, result.reference, block ? 1 : 0));

  static final _ctor_2 =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Instrumentation__ActivityMonitor_new_2")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Create a new ActivityMonitor that can be used for intercepting any activity to be
  /// started.
  ///
  ///  When an activity is started, \#onStartActivity(Intent) will be called on
  /// instances created using this constructor to see if it is a hit.
  ///@see \#onStartActivity(Intent)
  Instrumentation_ActivityMonitor.ctor_2() : super.fromRef(_ctor_2());

  static final _getFilter = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation__ActivityMonitor_getFilter")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.IntentFilter getFilter()
  /// Retrieve the filter associated with this ActivityMonitor.
  content.IntentFilter getFilter() =>
      content.IntentFilter.fromRef(_getFilter(reference));

  static final _getResult = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation__ActivityMonitor_getResult")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Instrumentation.ActivityResult getResult()
  /// Retrieve the result associated with this ActivityMonitor, or null if
  /// none.
  Instrumentation_ActivityResult getResult() =>
      Instrumentation_ActivityResult.fromRef(_getResult(reference));

  static final _isBlocking =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Instrumentation__ActivityMonitor_isBlocking")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isBlocking()
  /// Check whether this monitor blocks activity starts (not allowing the
  /// actual activity to run) or allows them to execute normally.
  bool isBlocking() => _isBlocking(reference) != 0;

  static final _getHits =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Instrumentation__ActivityMonitor_getHits")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getHits()
  /// Retrieve the number of times the monitor has been hit so far.
  int getHits() => _getHits(reference);

  static final _getLastActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation__ActivityMonitor_getLastActivity")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Activity getLastActivity()
  /// Retrieve the most recent activity class that was seen by this
  /// monitor.
  Activity getLastActivity() => Activity.fromRef(_getLastActivity(reference));

  static final _waitForActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation__ActivityMonitor_waitForActivity")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Activity waitForActivity()
  /// Block until an Activity is created that matches this monitor,
  /// returning the resulting activity.
  ///@return Activity
  Activity waitForActivity() => Activity.fromRef(_waitForActivity(reference));

  static final _waitForActivityWithTimeout = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "android_app_Instrumentation__ActivityMonitor_waitForActivityWithTimeout")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final android.app.Activity waitForActivityWithTimeout(long timeOut)
  /// Block until an Activity is created that matches this monitor,
  /// returning the resulting activity or till the timeOut period expires.
  /// If the timeOut expires before the activity is started, return null.
  ///@param timeOut Time to wait in milliseconds before the activity is created.
  ///@return Activity
  Activity waitForActivityWithTimeout(int timeOut) =>
      Activity.fromRef(_waitForActivityWithTimeout(reference, timeOut));

  static final _onStartActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Instrumentation__ActivityMonitor_onStartActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Instrumentation.ActivityResult onStartActivity(android.content.Intent intent)
  /// Used for intercepting any started activity.
  ///
  ///  A non-null return value here will be considered a hit for this monitor.
  /// By default this will return {@code null} and subclasses can override this to return
  /// a non-null value if the intent needs to be intercepted.
  ///
  ///  Whenever a new activity is started, this method will be called on instances created
  /// using \#Instrumentation.ActivityMonitor() to check if there is a match. In case
  /// of a match, the activity start will be blocked and the returned result will be used.
  ///@param intent The intent used for starting the activity.
  ///@return The ActivityResult that needs to be used in case of a match.
  Instrumentation_ActivityResult onStartActivity(content.Intent intent) =>
      Instrumentation_ActivityResult.fromRef(
          _onStartActivity(reference, intent.reference));
}

/// IntentService is a base class for Services that handle asynchronous
/// requests (expressed as Intents) on demand.  Clients send requests
/// through android.content.Context\#startService(Intent) calls; the
/// service is started as needed, handles each Intent in turn using a worker
/// thread, and stops itself when it runs out of work.
///
/// This "work queue processor" pattern is commonly used to offload tasks
/// from an application's main thread.  The IntentService class exists to
/// simplify this pattern and take care of the mechanics.  To use it, extend
/// IntentService and implement \#onHandleIntent(Intent).  IntentService
/// will receive the Intents, launch a worker thread, and stop the service as
/// appropriate.
///
/// All requests are handled on a single worker thread -- they may take as
/// long as necessary (and will not block the application's main loop), but
/// only one request will be processed at a time.
///
/// <p class="note">__Note:__ IntentService is subject to all the
/// <a href="/preview/features/background.html">background execution limits</a>
/// imposed with Android 8.0 (API level 26). In most cases, you are better off
/// using android.support.v4.app.JobIntentService, which uses jobs
/// instead of services when running on Android 8.0 or higher.
///
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For a detailed discussion about how to create services, read the
/// <a href="{@docRoot}guide/components/services.html">Services</a> developer
/// guide.
///
/// </div>
///@see android.support.v4.app.JobIntentService
///@see android.os.AsyncTask
class IntentService extends Service {
  IntentService.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_IntentService_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String name)
  /// Creates an IntentService.  Invoked by your subclass's constructor.
  ///@param name Used to name the worker thread, important only for debugging.
  IntentService(jni.JlString name) : super.fromRef(_ctor(name.reference));

  static final _setIntentRedelivery = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_IntentService_setIntentRedelivery")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setIntentRedelivery(boolean enabled)
  /// Sets intent redelivery preferences.  Usually called from the constructor
  /// with your preferred semantics.
  ///
  /// If enabled is true,
  /// \#onStartCommand(Intent, int, int) will return
  /// Service\#START_REDELIVER_INTENT, so if this process dies before
  /// \#onHandleIntent(Intent) returns, the process will be restarted
  /// and the intent redelivered.  If multiple Intents have been sent, only
  /// the most recent one is guaranteed to be redelivered.
  ///
  /// If enabled is false (the default),
  /// \#onStartCommand(Intent, int, int) will return
  /// Service\#START_NOT_STICKY, and if the process dies, the Intent
  /// dies along with it.
  void setIntentRedelivery(bool enabled) =>
      _setIntentRedelivery(reference, enabled ? 1 : 0);

  static final _onCreate =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_IntentService_onCreate")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreate()
  void onCreate() => _onCreate(reference);

  static final _onStart = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_IntentService_onStart")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onStart(android.content.Intent intent, int startId)
  /// @param intent This value may be {@code null}.
  void onStart(content.Intent intent, int startId) =>
      _onStart(reference, intent.reference, startId);

  static final _onStartCommand = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32)>>("android_app_IntentService_onStartCommand")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int onStartCommand(android.content.Intent intent, int flags, int startId)
  /// You should not override this method for your IntentService. Instead,
  /// override \#onHandleIntent, which the system calls when the IntentService
  /// receives a start request.
  ///@see android.app.Service\#onStartCommand
  ///@param intent This value may be {@code null}.
  int onStartCommand(content.Intent intent, int flags, int startId) =>
      _onStartCommand(reference, intent.reference, flags, startId);

  static final _onDestroy =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_IntentService_onDestroy")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDestroy()
  void onDestroy() => _onDestroy(reference);

  static final _onBind = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_IntentService_onBind")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.IBinder onBind(android.content.Intent intent)
  /// Unless you provide binding for your service, you don't need to implement this
  /// method, because the default implementation returns null.
  ///@see android.app.Service\#onBind
  os.IBinder onBind(content.Intent intent) =>
      os.IBinder.fromRef(_onBind(reference, intent.reference));

  static final _onHandleIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_IntentService_onHandleIntent")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected abstract void onHandleIntent(android.content.Intent intent)
  /// This method is invoked on the worker thread with a request to process.
  /// Only one Intent is processed at a time, but the processing happens on a
  /// worker thread that runs independently from other application logic.
  /// So, if this code takes a long time, it will hold up other requests to
  /// the same IntentService, but it will not hold up anything else.
  /// When all requests have been handled, the IntentService stops itself,
  /// so you should not call \#stopSelf.
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param intent The value passed to android.content.Context\#startService(Intent).
  ///               This may be null if the service is being restarted after
  ///               its process has gone away; see
  ///               android.app.Service\#onStartCommand
  ///               for details.
  ///
  /// This value may be {@code null}.
  void onHandleIntent(content.Intent intent) =>
      _onHandleIntent(reference, intent.reference);
}

/// A representation of settings that apply to a collection of similarly themed notifications.
class NotificationChannel extends jni.JlObject {
  NotificationChannel.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.NotificationChannel> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_NotificationChannel_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final java.lang.String DEFAULT_CHANNEL_ID
  /// The id of the default channel for an app. This id is reserved by the system. All
  /// notifications posted from apps targeting android.os.Build.VERSION_CODES\#N_MR1 or
  /// earlier without a notification channel specified are posted to this channel.
  static const DEFAULT_CHANNEL_ID = "miscellaneous";

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_NotificationChannel_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String id, java.lang.CharSequence name, int importance)
  /// Creates a notification channel.
  ///@param id The id of the channel. Must be unique per package. The value may be truncated if
  ///           it is too long.
  ///@param name The user visible name of the channel. You can rename this channel when the system
  ///             locale changes by listening for the Intent\#ACTION_LOCALE_CHANGED
  ///             broadcast. The recommended maximum length is 40 characters; the value may be
  ///             truncated if it is too long.
  ///@param importance The importance of the channel. This controls how interruptive notifications
  ///                   posted to this channel are.
  ///
  /// Value is android.app.NotificationManager\#IMPORTANCE_UNSPECIFIED, android.app.NotificationManager\#IMPORTANCE_NONE, android.app.NotificationManager\#IMPORTANCE_MIN, android.app.NotificationManager\#IMPORTANCE_LOW, android.app.NotificationManager\#IMPORTANCE_DEFAULT, or android.app.NotificationManager\#IMPORTANCE_HIGH
  NotificationChannel(jni.JlString id, jni.JlObject name, int importance)
      : super.fromRef(_ctor(id.reference, name.reference, importance));

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_NotificationChannel_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _setName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannel_setName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setName(java.lang.CharSequence name)
  /// Sets the user visible name of this channel.
  ///
  /// The recommended maximum length is 40 characters; the value may be truncated if it is too
  /// long.
  void setName(jni.JlObject name) => _setName(reference, name.reference);

  static final _setDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannel_setDescription")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setDescription(java.lang.String description)
  /// Sets the user visible description of this channel.
  ///
  /// The recommended maximum length is 300 characters; the value may be truncated if it is too
  /// long.
  void setDescription(jni.JlString description) =>
      _setDescription(reference, description.reference);

  static final _setGroup = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannel_setGroup")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setGroup(java.lang.String groupId)
  /// Sets what group this channel belongs to.
  ///
  /// Group information is only used for presentation, not for behavior.
  ///
  /// Only modifiable before the channel is submitted to
  /// NotificationManager\#createNotificationChannel(NotificationChannel), unless the
  /// channel is not currently part of a group.
  ///@param groupId the id of a group created by
  /// NotificationManager\#createNotificationChannelGroup(NotificationChannelGroup).
  void setGroup(jni.JlString groupId) =>
      _setGroup(reference, groupId.reference);

  static final _setShowBadge = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_NotificationChannel_setShowBadge")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setShowBadge(boolean showBadge)
  /// Sets whether notifications posted to this channel can appear as application icon badges
  /// in a Launcher.
  ///
  /// Only modifiable before the channel is submitted to
  /// NotificationManager\#createNotificationChannel(NotificationChannel).
  ///@param showBadge true if badges should be allowed to be shown.
  void setShowBadge(bool showBadge) =>
      _setShowBadge(reference, showBadge ? 1 : 0);

  static final _setSound = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannel_setSound")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setSound(android.net.Uri sound, android.media.AudioAttributes audioAttributes)
  /// Sets the sound that should be played for notifications posted to this channel and its
  /// audio attributes. Notification channels with an \#getImportance() importance of at
  /// least NotificationManager\#IMPORTANCE_DEFAULT should have a sound.
  ///
  /// Only modifiable before the channel is submitted to
  /// NotificationManager\#createNotificationChannel(NotificationChannel).
  void setSound(jni.JlObject sound, jni.JlObject audioAttributes) =>
      _setSound(reference, sound.reference, audioAttributes.reference);

  static final _enableLights = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_NotificationChannel_enableLights")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void enableLights(boolean lights)
  /// Sets whether notifications posted to this channel should display notification lights,
  /// on devices that support that feature.
  ///
  /// Only modifiable before the channel is submitted to
  /// NotificationManager\#createNotificationChannel(NotificationChannel).
  void enableLights(bool lights) => _enableLights(reference, lights ? 1 : 0);

  static final _setLightColor = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_NotificationChannel_setLightColor")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setLightColor(int argb)
  /// Sets the notification light color for notifications posted to this channel, if lights are
  /// \#enableLights(boolean) enabled on this channel and the device supports that feature.
  ///
  /// Only modifiable before the channel is submitted to
  /// NotificationManager\#createNotificationChannel(NotificationChannel).
  void setLightColor(int argb) => _setLightColor(reference, argb);

  static final _enableVibration = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_NotificationChannel_enableVibration")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void enableVibration(boolean vibration)
  /// Sets whether notification posted to this channel should vibrate. The vibration pattern can
  /// be set with \#setVibrationPattern(long[]).
  ///
  /// Only modifiable before the channel is submitted to
  /// NotificationManager\#createNotificationChannel(NotificationChannel).
  void enableVibration(bool vibration) =>
      _enableVibration(reference, vibration ? 1 : 0);

  static final _setVibrationPattern = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannel_setVibrationPattern")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setVibrationPattern(long[] vibrationPattern)
  /// Sets the vibration pattern for notifications posted to this channel. If the provided
  /// pattern is valid (non-null, non-empty), will \#enableVibration(boolean) enable
  /// vibration} as well. Otherwise, vibration will be disabled.
  ///
  /// Only modifiable before the channel is submitted to
  /// NotificationManager\#createNotificationChannel(NotificationChannel).
  void setVibrationPattern(jni.JlObject vibrationPattern) =>
      _setVibrationPattern(reference, vibrationPattern.reference);

  static final _setImportance = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_NotificationChannel_setImportance")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setImportance(int importance)
  /// Sets the level of interruption of this notification channel.
  ///
  /// Only modifiable before the channel is submitted to
  /// NotificationManager\#createNotificationChannel(NotificationChannel).
  ///@param importance the amount the user should be interrupted by
  ///            notifications from this channel.
  ///
  /// Value is android.app.NotificationManager\#IMPORTANCE_UNSPECIFIED, android.app.NotificationManager\#IMPORTANCE_NONE, android.app.NotificationManager\#IMPORTANCE_MIN, android.app.NotificationManager\#IMPORTANCE_LOW, android.app.NotificationManager\#IMPORTANCE_DEFAULT, or android.app.NotificationManager\#IMPORTANCE_HIGH
  void setImportance(int importance) => _setImportance(reference, importance);

  static final _setBypassDnd = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_NotificationChannel_setBypassDnd")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setBypassDnd(boolean bypassDnd)
  /// Sets whether or not notifications posted to this channel can interrupt the user in
  /// android.app.NotificationManager.Policy\#INTERRUPTION_FILTER_PRIORITY mode.
  ///
  /// Only modifiable by the system and notification ranker.
  void setBypassDnd(bool bypassDnd) =>
      _setBypassDnd(reference, bypassDnd ? 1 : 0);

  static final _setLockscreenVisibility = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_NotificationChannel_setLockscreenVisibility")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setLockscreenVisibility(int lockscreenVisibility)
  /// Sets whether notifications posted to this channel appear on the lockscreen or not, and if so,
  /// whether they appear in a redacted form. See e.g. Notification\#VISIBILITY_SECRET.
  ///
  /// Only modifiable by the system and notification ranker.
  void setLockscreenVisibility(int lockscreenVisibility) =>
      _setLockscreenVisibility(reference, lockscreenVisibility);

  static final _getId = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannel_getId")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getId()
  /// Returns the id of this channel.
  jni.JlString getId() => jni.JlString.fromRef(_getId(reference));

  static final _getName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannel_getName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getName()
  /// Returns the user visible name of this channel.
  jni.JlObject getName() => jni.JlObject.fromRef(_getName(reference));

  static final _getDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannel_getDescription")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getDescription()
  /// Returns the user visible description of this channel.
  jni.JlString getDescription() =>
      jni.JlString.fromRef(_getDescription(reference));

  static final _getImportance =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NotificationChannel_getImportance")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getImportance()
  /// Returns the user specified importance e.g.&nbsp;NotificationManager\#IMPORTANCE_LOW for
  /// notifications posted to this channel. Note: This value might be >
  /// NotificationManager\#IMPORTANCE_NONE, but notifications posted to this channel will
  /// not be shown to the user if the parent NotificationChannelGroup or app is blocked.
  /// See NotificationChannelGroup\#isBlocked() and
  /// NotificationManager\#areNotificationsEnabled().
  int getImportance() => _getImportance(reference);

  static final _canBypassDnd =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NotificationChannel_canBypassDnd")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean canBypassDnd()
  /// Whether or not notifications posted to this channel can bypass the Do Not Disturb
  /// NotificationManager\#INTERRUPTION_FILTER_PRIORITY mode.
  bool canBypassDnd() => _canBypassDnd(reference) != 0;

  static final _getSound = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannel_getSound")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri getSound()
  /// Returns the notification sound for this channel.
  jni.JlObject getSound() => jni.JlObject.fromRef(_getSound(reference));

  static final _getAudioAttributes = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannel_getAudioAttributes")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.media.AudioAttributes getAudioAttributes()
  /// Returns the audio attributes for sound played by notifications posted to this channel.
  jni.JlObject getAudioAttributes() =>
      jni.JlObject.fromRef(_getAudioAttributes(reference));

  static final _shouldShowLights =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NotificationChannel_shouldShowLights")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldShowLights()
  /// Returns whether notifications posted to this channel trigger notification lights.
  bool shouldShowLights() => _shouldShowLights(reference) != 0;

  static final _getLightColor =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NotificationChannel_getLightColor")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLightColor()
  /// Returns the notification light color for notifications posted to this channel. Irrelevant
  /// unless \#shouldShowLights().
  int getLightColor() => _getLightColor(reference);

  static final _shouldVibrate =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NotificationChannel_shouldVibrate")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldVibrate()
  /// Returns whether notifications posted to this channel always vibrate.
  bool shouldVibrate() => _shouldVibrate(reference) != 0;

  static final _getVibrationPattern = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannel_getVibrationPattern")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long[] getVibrationPattern()
  /// Returns the vibration pattern for notifications posted to this channel. Will be ignored if
  /// vibration is not enabled (\#shouldVibrate().
  jni.JlObject getVibrationPattern() =>
      jni.JlObject.fromRef(_getVibrationPattern(reference));

  static final _getLockscreenVisibility =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NotificationChannel_getLockscreenVisibility")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLockscreenVisibility()
  /// Returns whether or not notifications posted to this channel are shown on the lockscreen in
  /// full or redacted form.
  int getLockscreenVisibility() => _getLockscreenVisibility(reference);

  static final _canShowBadge =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NotificationChannel_canShowBadge")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean canShowBadge()
  /// Returns whether notifications posted to this channel can appear as badges in a Launcher
  /// application.
  ///
  /// Note that badging may be disabled for other reasons.
  bool canShowBadge() => _canShowBadge(reference) != 0;

  static final _getGroup = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannel_getGroup")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getGroup()
  /// Returns what group this channel belongs to.
  ///
  /// This is used only for visually grouping channels in the UI.
  jni.JlString getGroup() => jni.JlString.fromRef(_getGroup(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NotificationChannel_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _equals_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannel_equals_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object o)
  bool equals_1(jni.JlObject o) => _equals_1(reference, o.reference) != 0;

  static final _hashCode_1 =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_NotificationChannel_hashCode_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode_1() => _hashCode_1(reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_NotificationChannel_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));
}

/// A fragment that displays a list of items by binding to a data source such as
/// an array or Cursor, and exposes event handlers when the user selects an item.
///
/// ListFragment hosts a android.widget.ListView ListView object that can
/// be bound to different data sources, typically either an array or a Cursor
/// holding query results. Binding, screen layout, and row layout are discussed
/// in the following sections.
///
/// <strong>Screen Layout</strong>
///
///
///
/// ListFragment has a default layout that consists of a single list view.
/// However, if you desire, you can customize the fragment layout by returning
/// your own view hierarchy from \#onCreateView.
/// To do this, your view hierarchy _must_ contain a ListView object with the
/// id "@android:id/list" (or android.R.id\#list if it's in code)
///
/// Optionally, your view hierarchy can contain another view object of any type to
/// display when the list view is empty. This "empty list" notifier must have an
/// id "android:empty". Note that when an empty view is present, the list view
/// will be hidden when there is no data to display.
///
/// The following code demonstrates an (ugly) custom list layout. It has a list
/// with a green background, and an alternate red "no data" message.
///
///
///
/// <pre>
/// &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
/// &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
///         android:orientation=&quot;vertical&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;match_parent&quot;
///         android:paddingLeft=&quot;8dp&quot;
///         android:paddingRight=&quot;8dp&quot;&gt;
///
///     &lt;ListView android:id=&quot;@id/android:list&quot;
///               android:layout_width=&quot;match_parent&quot;
///               android:layout_height=&quot;match_parent&quot;
///               android:background=&quot;\#00FF00&quot;
///               android:layout_weight=&quot;1&quot;
///               android:drawSelectorOnTop=&quot;false&quot;/&gt;
///
///     &lt;TextView android:id=&quot;@id/android:empty&quot;
///               android:layout_width=&quot;match_parent&quot;
///               android:layout_height=&quot;match_parent&quot;
///               android:background=&quot;\#FF0000&quot;
///               android:text=&quot;No data&quot;/&gt;
/// &lt;/LinearLayout&gt;
/// </pre>
///
///
/// <strong>Row Layout</strong>
///
///
///
/// You can specify the layout of individual rows in the list. You do this by
/// specifying a layout resource in the ListAdapter object hosted by the fragment
/// (the ListAdapter binds the ListView to the data; more on this later).
///
/// A ListAdapter constructor takes a parameter that specifies a layout resource
/// for each row. It also has two additional parameters that let you specify
/// which data field to associate with which object in the row layout resource.
/// These two parameters are typically parallel arrays.
///
///
///
/// Android provides some standard row layout resources. These are in the
/// android.R.layout class, and have names such as simple_list_item_1,
/// simple_list_item_2, and two_line_list_item. The following layout XML is the
/// source for the resource two_line_list_item, which displays two data
/// fields,one above the other, for each list row.
///
///
///
/// <pre>
/// &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
/// &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
///     android:layout_width=&quot;match_parent&quot;
///     android:layout_height=&quot;wrap_content&quot;
///     android:orientation=&quot;vertical&quot;&gt;
///
///     &lt;TextView android:id=&quot;@+id/text1&quot;
///         android:textSize=&quot;16sp&quot;
///         android:textStyle=&quot;bold&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;wrap_content&quot;/&gt;
///
///     &lt;TextView android:id=&quot;@+id/text2&quot;
///         android:textSize=&quot;16sp&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;wrap_content&quot;/&gt;
/// &lt;/LinearLayout&gt;
/// </pre>
///
///
/// You must identify the data bound to each TextView object in this layout. The
/// syntax for this is discussed in the next section.
///
///
///
/// <strong>Binding to Data</strong>
///
///
///
/// You bind the ListFragment's ListView object to data using a class that
/// implements the android.widget.ListAdapter ListAdapter interface.
/// Android provides two standard list adapters:
/// android.widget.SimpleAdapter SimpleAdapter for static data (Maps),
/// and android.widget.SimpleCursorAdapter SimpleCursorAdapter for Cursor
/// query results.
///
///
///
/// You __must__ use
/// \#setListAdapter(ListAdapter) ListFragment.setListAdapter() to
/// associate the list with an adapter.  Do not directly call
/// ListView\#setAdapter(ListAdapter) ListView.setAdapter() or else
/// important initialization will be skipped.
///
///
///@see \#setListAdapter
///@see android.widget.ListView
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.ListFragment for consistent behavior across all devices
///      and access to <a href="{@docRoot}topic/libraries/architecture/lifecycle.html">Lifecycle</a>.
class ListFragment extends Fragment {
  ListFragment.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ListFragment_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ListFragment() : super.fromRef(_ctor());

  static final _onCreateView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_ListFragment_onCreateView")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View onCreateView(android.view.LayoutInflater inflater, android.view.ViewGroup container, android.os.Bundle savedInstanceState)
  /// Provide default implementation to return a simple list view.  Subclasses
  /// can override to replace with their own layout.  If doing so, the
  /// returned view hierarchy _must_ have a ListView whose id
  /// is android.R.id\#list android.R.id.list and can optionally
  /// have a sibling view id android.R.id\#empty android.R.id.empty
  /// that is to be shown when the list is empty.
  ///
  /// If you are overriding this method with your own custom content,
  /// consider including the standard layout android.R.layout\#list_content
  /// in your layout file, so that you continue to retain all of the standard
  /// behavior of ListFragment.  In particular, this is currently the only
  /// way to have the built-in indeterminant progress state be shown.
  jni.JlObject onCreateView(jni.JlObject inflater, jni.JlObject container,
          os.Bundle savedInstanceState) =>
      jni.JlObject.fromRef(_onCreateView(reference, inflater.reference,
          container.reference, savedInstanceState.reference));

  static final _onViewCreated = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ListFragment_onViewCreated")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onViewCreated(android.view.View view, android.os.Bundle savedInstanceState)
  /// Attach to list view once the view hierarchy has been created.
  void onViewCreated(jni.JlObject view, os.Bundle savedInstanceState) =>
      _onViewCreated(reference, view.reference, savedInstanceState.reference);

  static final _onDestroyView =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ListFragment_onDestroyView")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDestroyView()
  /// Detach from list view.
  void onDestroyView() => _onDestroyView(reference);

  static final _onListItemClick = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int64)>>("android_app_ListFragment_onListItemClick")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void onListItemClick(android.widget.ListView l, android.view.View v, int position, long id)
  /// This method will be called when an item in the list is selected.
  /// Subclasses should override. Subclasses can call
  /// getListView().getItemAtPosition(position) if they need to access the
  /// data associated with the selected item.
  ///@param l The ListView where the click happened
  ///@param v The view that was clicked within the ListView
  ///@param position The position of the view in the list
  ///@param id The row id of the item that was clicked
  void onListItemClick(jni.JlObject l, jni.JlObject v, int position, int id) =>
      _onListItemClick(reference, l.reference, v.reference, position, id);

  static final _setListAdapter = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ListFragment_setListAdapter")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setListAdapter(android.widget.ListAdapter adapter)
  /// Provide the cursor for the list view.
  void setListAdapter(jni.JlObject adapter) =>
      _setListAdapter(reference, adapter.reference);

  static final _setSelection = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ListFragment_setSelection")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setSelection(int position)
  /// Set the currently selected list item to the specified
  /// position with the adapter's data
  ///@param position
  void setSelection(int position) => _setSelection(reference, position);

  static final _getSelectedItemPosition =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ListFragment_getSelectedItemPosition")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getSelectedItemPosition()
  /// Get the position of the currently selected list item.
  int getSelectedItemPosition() => _getSelectedItemPosition(reference);

  static final _getSelectedItemId =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ListFragment_getSelectedItemId")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getSelectedItemId()
  /// Get the cursor row ID of the currently selected list item.
  int getSelectedItemId() => _getSelectedItemId(reference);

  static final _getListView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ListFragment_getListView")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.ListView getListView()
  /// Get the fragment's list view widget.
  jni.JlObject getListView() => jni.JlObject.fromRef(_getListView(reference));

  static final _setEmptyText = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ListFragment_setEmptyText")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setEmptyText(java.lang.CharSequence text)
  /// The default content for a ListFragment has a TextView that can
  /// be shown when the list is empty.  If you would like to have it
  /// shown, call this method to supply the text it should use.
  void setEmptyText(jni.JlObject text) =>
      _setEmptyText(reference, text.reference);

  static final _setListShown = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_ListFragment_setListShown")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setListShown(boolean shown)
  /// Control whether the list is being displayed.  You can make it not
  /// displayed if you are waiting for the initial data to show in it.  During
  /// this time an indeterminant progress indicator will be shown instead.
  ///
  /// Applications do not normally need to use this themselves.  The default
  /// behavior of ListFragment is to start with the list not being shown, only
  /// showing it once an adapter is given with \#setListAdapter(ListAdapter).
  /// If the list at that point had not been shown, when it does get shown
  /// it will be do without the user ever seeing the hidden state.
  ///@param shown If true, the list view is shown; if false, the progress
  /// indicator.  The initial value is true.
  void setListShown(bool shown) => _setListShown(reference, shown ? 1 : 0);

  static final _setListShownNoAnimation = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_ListFragment_setListShownNoAnimation")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setListShownNoAnimation(boolean shown)
  /// Like \#setListShown(boolean), but no animation is used when
  /// transitioning from the previous state.
  void setListShownNoAnimation(bool shown) =>
      _setListShownNoAnimation(reference, shown ? 1 : 0);

  static final _getListAdapter = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ListFragment_getListAdapter")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.ListAdapter getListAdapter()
  /// Get the ListAdapter associated with this fragment's ListView.
  jni.JlObject getListAdapter() =>
      jni.JlObject.fromRef(_getListAdapter(reference));
}

/// Searchability meta-data for an activity. Only applications that search other applications
/// should need to use this class.
/// See <a href="{@docRoot}guide/topics/search/searchable-config.html">Searchable Configuration</a>
/// for more information about declaring searchability meta-data for your application.
///@see SearchManager\#getSearchableInfo(ComponentName)
///@see SearchManager\#getSearchablesInGlobalSearch()
class SearchableInfo extends jni.JlObject {
  SearchableInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.SearchableInfo> CREATOR
  /// Support for parcelable and aidl operations.
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_SearchableInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_SearchableInfo_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Parcel in)
  /// Instantiates a new SearchableInfo from the data in a Parcel that was
  /// previously written with \#writeToParcel(Parcel, int).
  ///@param in The Parcel containing the previously written SearchableInfo,
  /// positioned at the location in the buffer where it was written.
  SearchableInfo(os.Parcel in_) : super.fromRef(_ctor(in_.reference));

  static final _getSuggestAuthority = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_SearchableInfo_getSuggestAuthority")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSuggestAuthority()
  /// Gets the search suggestion content provider authority.
  ///@return The search suggestions authority, or {@code null} if not set.
  ///@see android.R.styleable\#Searchable_searchSuggestAuthority
  jni.JlString getSuggestAuthority() =>
      jni.JlString.fromRef(_getSuggestAuthority(reference));

  static final _getSuggestPackage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_SearchableInfo_getSuggestPackage")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSuggestPackage()
  /// Gets the name of the package where the suggestion provider lives,
  /// or {@code null}.
  jni.JlString getSuggestPackage() =>
      jni.JlString.fromRef(_getSuggestPackage(reference));

  static final _getSearchActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_SearchableInfo_getSearchActivity")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getSearchActivity()
  /// Gets the component name of the searchable activity.
  ///@return A component name, never {@code null}.
  content.ComponentName getSearchActivity() =>
      content.ComponentName.fromRef(_getSearchActivity(reference));

  static final _shouldRewriteQueryFromData =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchableInfo_shouldRewriteQueryFromData")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldRewriteQueryFromData()
  /// Checks whether the text in the query field should come from the suggestion intent data.
  ///@see android.R.styleable\#Searchable_searchMode
  bool shouldRewriteQueryFromData() =>
      _shouldRewriteQueryFromData(reference) != 0;

  static final _shouldRewriteQueryFromText =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchableInfo_shouldRewriteQueryFromText")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldRewriteQueryFromText()
  /// Checks whether the text in the query field should come from the suggestion title.
  ///@see android.R.styleable\#Searchable_searchMode
  bool shouldRewriteQueryFromText() =>
      _shouldRewriteQueryFromText(reference) != 0;

  static final _getSettingsDescriptionId =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchableInfo_getSettingsDescriptionId")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getSettingsDescriptionId()
  /// Gets the resource id of the description string to use for this source in system search
  /// settings, or {@code 0} if none has been specified.
  ///@see android.R.styleable\#Searchable_searchSettingsDescription
  int getSettingsDescriptionId() => _getSettingsDescriptionId(reference);

  static final _getSuggestPath = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_SearchableInfo_getSuggestPath")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSuggestPath()
  /// Gets the content provider path for obtaining search suggestions.
  ///@return The suggestion path, or {@code null} if not set.
  ///@see android.R.styleable\#Searchable_searchSuggestPath
  jni.JlString getSuggestPath() =>
      jni.JlString.fromRef(_getSuggestPath(reference));

  static final _getSuggestSelection = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_SearchableInfo_getSuggestSelection")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSuggestSelection()
  /// Gets the selection for obtaining search suggestions.
  ///@see android.R.styleable\#Searchable_searchSuggestSelection
  jni.JlString getSuggestSelection() =>
      jni.JlString.fromRef(_getSuggestSelection(reference));

  static final _getSuggestIntentAction = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_SearchableInfo_getSuggestIntentAction")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSuggestIntentAction()
  /// Gets the optional intent action for use with these suggestions. This is
  /// useful if all intents will have the same action
  /// (e.g. android.content.Intent\#ACTION_VIEW)
  ///
  /// This can be overriden in any given suggestion using the column
  /// SearchManager\#SUGGEST_COLUMN_INTENT_ACTION.
  ///@return The default intent action, or {@code null} if not set.
  ///@see android.R.styleable\#Searchable_searchSuggestIntentAction
  jni.JlString getSuggestIntentAction() =>
      jni.JlString.fromRef(_getSuggestIntentAction(reference));

  static final _getSuggestIntentData = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_SearchableInfo_getSuggestIntentData")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSuggestIntentData()
  /// Gets the optional intent data for use with these suggestions.  This is
  /// useful if all intents will have similar data URIs,
  /// but you'll likely need to provide a specific ID as well via the column
  /// SearchManager\#SUGGEST_COLUMN_INTENT_DATA_ID, which will be appended to the
  /// intent data URI.
  ///
  /// This can be overriden in any given suggestion using the column
  /// SearchManager\#SUGGEST_COLUMN_INTENT_DATA.
  ///@return The default intent data, or {@code null} if not set.
  ///@see android.R.styleable\#Searchable_searchSuggestIntentData
  jni.JlString getSuggestIntentData() =>
      jni.JlString.fromRef(_getSuggestIntentData(reference));

  static final _getSuggestThreshold =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchableInfo_getSuggestThreshold")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getSuggestThreshold()
  /// Gets the suggestion threshold.
  ///@return The suggestion threshold, or {@code 0} if not set.
  ///@see android.R.styleable\#Searchable_searchSuggestThreshold
  int getSuggestThreshold() => _getSuggestThreshold(reference);

  static final _getHintId =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchableInfo_getHintId")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getHintId()
  /// Gets the resource id of the hint text. This must be
  /// read using the searchable Activity's resources.
  ///@return A resource id, or {@code 0} if no hint was specified.
  ///@see android.R.styleable\#Searchable_hint
  int getHintId() => _getHintId(reference);

  static final _getVoiceSearchEnabled =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchableInfo_getVoiceSearchEnabled")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getVoiceSearchEnabled()
  /// Checks if the searchable activity wants the voice search button to be shown.
  ///@see android.R.styleable\#Searchable_voiceSearchMode
  bool getVoiceSearchEnabled() => _getVoiceSearchEnabled(reference) != 0;

  static final _getVoiceSearchLaunchWebSearch =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchableInfo_getVoiceSearchLaunchWebSearch")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getVoiceSearchLaunchWebSearch()
  /// Checks if voice search should start web search.
  ///@see android.R.styleable\#Searchable_voiceSearchMode
  bool getVoiceSearchLaunchWebSearch() =>
      _getVoiceSearchLaunchWebSearch(reference) != 0;

  static final _getVoiceSearchLaunchRecognizer =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchableInfo_getVoiceSearchLaunchRecognizer")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getVoiceSearchLaunchRecognizer()
  /// Checks if voice search should start in-app search.
  ///@see android.R.styleable\#Searchable_voiceSearchMode
  bool getVoiceSearchLaunchRecognizer() =>
      _getVoiceSearchLaunchRecognizer(reference) != 0;

  static final _getVoiceLanguageModeId =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchableInfo_getVoiceLanguageModeId")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getVoiceLanguageModeId()
  /// Gets the resource id of the voice search language model string.
  ///@return A resource id, or {@code 0} if no language model was specified.
  ///@see android.R.styleable\#Searchable_voiceLanguageModel
  int getVoiceLanguageModeId() => _getVoiceLanguageModeId(reference);

  static final _getVoicePromptTextId =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchableInfo_getVoicePromptTextId")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getVoicePromptTextId()
  /// Gets the resource id of the voice prompt text string.
  ///@return A resource id, or {@code 0} if no voice prompt text was specified.
  ///@see android.R.styleable\#Searchable_voicePromptText
  int getVoicePromptTextId() => _getVoicePromptTextId(reference);

  static final _getVoiceLanguageId =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchableInfo_getVoiceLanguageId")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getVoiceLanguageId()
  /// Gets the resource id of the spoken language to recognize in voice search.
  ///@return A resource id, or {@code 0} if no language was specified.
  ///@see android.R.styleable\#Searchable_voiceLanguage
  int getVoiceLanguageId() => _getVoiceLanguageId(reference);

  static final _getVoiceMaxResults =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchableInfo_getVoiceMaxResults")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getVoiceMaxResults()
  /// The maximum number of voice recognition results to return.
  ///@return the max results count, if specified in the searchable
  ///         activity's metadata, or {@code 0} if not specified.
  ///@see android.R.styleable\#Searchable_voiceMaxResults
  int getVoiceMaxResults() => _getVoiceMaxResults(reference);

  static final _getInputType =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchableInfo_getInputType")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getInputType()
  /// Gets the input type as specified in the searchable attributes. This will default to
  /// InputType\#TYPE_CLASS_TEXT if not specified (which is appropriate
  /// for free text input).
  ///@return the input type
  ///@see android.R.styleable\#Searchable_inputType
  int getInputType() => _getInputType(reference);

  static final _getImeOptions =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchableInfo_getImeOptions")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getImeOptions()
  /// Gets the input method options specified in the searchable attributes.
  /// This will default to EditorInfo\#IME_ACTION_GO if not specified (which is
  /// appropriate for a search box).
  ///@return the input type
  ///@see android.R.styleable\#Searchable_imeOptions
  int getImeOptions() => _getImeOptions(reference);

  static final _shouldIncludeInGlobalSearch =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchableInfo_shouldIncludeInGlobalSearch")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldIncludeInGlobalSearch()
  /// Checks whether the searchable should be included in global search.
  ///@return The value of the android.R.styleable\#Searchable_includeInGlobalSearch
  ///         attribute, or {@code false} if the attribute is not set.
  ///@see android.R.styleable\#Searchable_includeInGlobalSearch
  bool shouldIncludeInGlobalSearch() =>
      _shouldIncludeInGlobalSearch(reference) != 0;

  static final _queryAfterZeroResults =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchableInfo_queryAfterZeroResults")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean queryAfterZeroResults()
  /// Checks whether this searchable activity should be queried for suggestions if a prefix
  /// of the query has returned no results.
  ///@see android.R.styleable\#Searchable_queryAfterZeroResults
  bool queryAfterZeroResults() => _queryAfterZeroResults(reference) != 0;

  static final _autoUrlDetect =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchableInfo_autoUrlDetect")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean autoUrlDetect()
  /// Checks whether this searchable activity has auto URL detection turned on.
  ///@see android.R.styleable\#Searchable_autoUrlDetect
  bool autoUrlDetect() => _autoUrlDetect(reference) != 0;

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_SearchableInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_SearchableInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);
}

/// An activity that displays an expandable list of items by binding to a data
/// source implementing the ExpandableListAdapter, and exposes event handlers
/// when the user selects an item.
///
/// ExpandableListActivity hosts a
/// android.widget.ExpandableListView ExpandableListView object that can
/// be bound to different data sources that provide a two-levels of data (the
/// top-level is group, and below each group are children). Binding, screen
/// layout, and row layout are discussed in the following sections.
///
/// <strong>Screen Layout</strong>
///
///
///
/// ExpandableListActivity has a default layout that consists of a single,
/// full-screen, centered expandable list. However, if you desire, you can
/// customize the screen layout by setting your own view layout with
/// setContentView() in onCreate(). To do this, your own view MUST contain an
/// ExpandableListView object with the id "@android:id/list" (or
/// android.R.id\#list if it's in code)
///
/// Optionally, your custom view can contain another view object of any type to
/// display when the list view is empty. This "empty list" notifier must have an
/// id "android:empty". Note that when an empty view is present, the expandable
/// list view will be hidden when there is no data to display.
///
/// The following code demonstrates an (ugly) custom screen layout. It has a list
/// with a green background, and an alternate red "no data" message.
///
///
///
/// <pre>
/// &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
/// &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
///         android:orientation=&quot;vertical&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;match_parent&quot;
///         android:paddingLeft=&quot;8dp&quot;
///         android:paddingRight=&quot;8dp&quot;&gt;
///
///     &lt;ExpandableListView android:id=&quot;@id/android:list&quot;
///               android:layout_width=&quot;match_parent&quot;
///               android:layout_height=&quot;match_parent&quot;
///               android:background=&quot;\#00FF00&quot;
///               android:layout_weight=&quot;1&quot;
///               android:drawSelectorOnTop=&quot;false&quot;/&gt;
///
///     &lt;TextView android:id=&quot;@id/android:empty&quot;
///               android:layout_width=&quot;match_parent&quot;
///               android:layout_height=&quot;match_parent&quot;
///               android:background=&quot;\#FF0000&quot;
///               android:text=&quot;No data&quot;/&gt;
/// &lt;/LinearLayout&gt;
/// </pre>
///
///
/// <strong>Row Layout</strong>
///
///
/// The ExpandableListAdapter set in the ExpandableListActivity
/// via \#setListAdapter(ExpandableListAdapter) provides the Views
/// for each row. This adapter has separate methods for providing the group
/// Views and child Views. There are a couple provided
/// ExpandableListAdapters that simplify use of adapters:
/// SimpleCursorTreeAdapter and SimpleExpandableListAdapter.
///
/// With these, you can specify the layout of individual rows for groups and
/// children in the list. These constructor takes a few parameters that specify
/// layout resources for groups and children. It also has additional parameters
/// that let you specify which data field to associate with which object in the
/// row layout resource. The SimpleCursorTreeAdapter fetches data from
/// Cursors and the SimpleExpandableListAdapter fetches data
/// from Lists of Maps.
///
///
///
/// Android provides some standard row layout resources. These are in the
/// android.R.layout class, and have names such as simple_list_item_1,
/// simple_list_item_2, and two_line_list_item. The following layout XML is the
/// source for the resource two_line_list_item, which displays two data
/// fields,one above the other, for each list row.
///
///
///
/// <pre>
/// &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
/// &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
///     android:layout_width=&quot;match_parent&quot;
///     android:layout_height=&quot;wrap_content&quot;
///     android:orientation=&quot;vertical&quot;&gt;
///
///     &lt;TextView android:id=&quot;@+id/text1&quot;
///         android:textSize=&quot;16sp&quot;
///         android:textStyle=&quot;bold&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;wrap_content&quot;/&gt;
///
///     &lt;TextView android:id=&quot;@+id/text2&quot;
///         android:textSize=&quot;16sp&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;wrap_content&quot;/&gt;
/// &lt;/LinearLayout&gt;
/// </pre>
///
///
/// You must identify the data bound to each TextView object in this layout. The
/// syntax for this is discussed in the next section.
///
///
///
/// <strong>Binding to Data</strong>
///
///
///
/// You bind the ExpandableListActivity's ExpandableListView object to data using
/// a class that implements the
/// android.widget.ExpandableListAdapter ExpandableListAdapter interface.
/// Android provides two standard list adapters:
/// android.widget.SimpleExpandableListAdapter SimpleExpandableListAdapter
/// for static data (Maps), and
/// android.widget.SimpleCursorTreeAdapter SimpleCursorTreeAdapter for
/// Cursor query results.
///
///
///@see \#setListAdapter
///@see android.widget.ExpandableListView
class ExpandableListActivity extends Activity {
  ExpandableListActivity.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ExpandableListActivity_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ExpandableListActivity() : super.fromRef(_ctor());

  static final _onCreateContextMenu = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_ExpandableListActivity_onCreateContextMenu")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreateContextMenu(android.view.ContextMenu menu, android.view.View v, android.view.ContextMenu.ContextMenuInfo menuInfo)
  /// Override this to populate the context menu when an item is long pressed. menuInfo
  /// will contain an android.widget.ExpandableListView.ExpandableListContextMenuInfo
  /// whose packedPosition is a packed position
  /// that should be used with ExpandableListView\#getPackedPositionType(long) and
  /// the other similar methods.
  ///
  /// {@inheritDoc}
  void onCreateContextMenu(
          jni.JlObject menu, jni.JlObject v, jni.JlObject menuInfo) =>
      _onCreateContextMenu(
          reference, menu.reference, v.reference, menuInfo.reference);

  static final _onChildClick = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int64)>>(
          "android_app_ExpandableListActivity_onChildClick")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public boolean onChildClick(android.widget.ExpandableListView parent, android.view.View v, int groupPosition, int childPosition, long id)
  /// Override this for receiving callbacks when a child has been clicked.
  ///
  /// {@inheritDoc}
  bool onChildClick(jni.JlObject parent, jni.JlObject v, int groupPosition,
          int childPosition, int id) =>
      _onChildClick(reference, parent.reference, v.reference, groupPosition,
          childPosition, id) !=
      0;

  static final _onGroupCollapse = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ExpandableListActivity_onGroupCollapse")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onGroupCollapse(int groupPosition)
  /// Override this for receiving callbacks when a group has been collapsed.
  void onGroupCollapse(int groupPosition) =>
      _onGroupCollapse(reference, groupPosition);

  static final _onGroupExpand = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ExpandableListActivity_onGroupExpand")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onGroupExpand(int groupPosition)
  /// Override this for receiving callbacks when a group has been expanded.
  void onGroupExpand(int groupPosition) =>
      _onGroupExpand(reference, groupPosition);

  static final _onRestoreInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ExpandableListActivity_onRestoreInstanceState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onRestoreInstanceState(android.os.Bundle state)
  /// Ensures the expandable list view has been created before Activity restores all
  /// of the view states.
  ///@see Activity\#onRestoreInstanceState(Bundle)
  void onRestoreInstanceState(os.Bundle state) =>
      _onRestoreInstanceState(reference, state.reference);

  static final _onContentChanged =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ExpandableListActivity_onContentChanged")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onContentChanged()
  /// Updates the screen state (current list and other views) when the
  /// content changes.
  ///@see Activity\#onContentChanged()
  void onContentChanged() => _onContentChanged(reference);

  static final _setListAdapter = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ExpandableListActivity_setListAdapter")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setListAdapter(android.widget.ExpandableListAdapter adapter)
  /// Provide the adapter for the expandable list.
  void setListAdapter(jni.JlObject adapter) =>
      _setListAdapter(reference, adapter.reference);

  static final _getExpandableListView = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ExpandableListActivity_getExpandableListView")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.ExpandableListView getExpandableListView()
  /// Get the activity's expandable list view widget.  This can be used to get the selection,
  /// set the selection, and many other useful functions.
  ///@see ExpandableListView
  jni.JlObject getExpandableListView() =>
      jni.JlObject.fromRef(_getExpandableListView(reference));

  static final _getExpandableListAdapter = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ExpandableListActivity_getExpandableListAdapter")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.ExpandableListAdapter getExpandableListAdapter()
  /// Get the ExpandableListAdapter associated with this activity's
  /// ExpandableListView.
  jni.JlObject getExpandableListAdapter() =>
      jni.JlObject.fromRef(_getExpandableListAdapter(reference));

  static final _getSelectedId =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ExpandableListActivity_getSelectedId")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getSelectedId()
  /// Gets the ID of the currently selected group or child.
  ///@return The ID of the currently selected group or child.
  int getSelectedId() => _getSelectedId(reference);

  static final _getSelectedPosition =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ExpandableListActivity_getSelectedPosition")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getSelectedPosition()
  /// Gets the position (in packed position representation) of the currently
  /// selected group or child. Use
  /// ExpandableListView\#getPackedPositionType,
  /// ExpandableListView\#getPackedPositionGroup, and
  /// ExpandableListView\#getPackedPositionChild to unpack the returned
  /// packed position.
  ///@return A packed position representation containing the currently
  ///         selected group or child's position and type.
  int getSelectedPosition() => _getSelectedPosition(reference);

  static final _setSelectedChild = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32, ffi.Uint8)>>(
          "android_app_ExpandableListActivity_setSelectedChild")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public boolean setSelectedChild(int groupPosition, int childPosition, boolean shouldExpandGroup)
  /// Sets the selection to the specified child. If the child is in a collapsed
  /// group, the group will only be expanded and child subsequently selected if
  /// shouldExpandGroup is set to true, otherwise the method will return false.
  ///@param groupPosition The position of the group that contains the child.
  ///@param childPosition The position of the child within the group.
  ///@param shouldExpandGroup Whether the child's group should be expanded if
  ///            it is collapsed.
  ///@return Whether the selection was successfully set on the child.
  bool setSelectedChild(
          int groupPosition, int childPosition, bool shouldExpandGroup) =>
      _setSelectedChild(
          reference, groupPosition, childPosition, shouldExpandGroup ? 1 : 0) !=
      0;

  static final _setSelectedGroup = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ExpandableListActivity_setSelectedGroup")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setSelectedGroup(int groupPosition)
  /// Sets the selection to the specified group.
  ///@param groupPosition The position of the group that should be selected.
  void setSelectedGroup(int groupPosition) =>
      _setSelectedGroup(reference, groupPosition);
}

/// Base class for maintaining global application state. You can provide your own
/// implementation by creating a subclass and specifying the fully-qualified name
/// of this subclass as the <code>"android:name"</code> attribute in your
/// AndroidManifest.xml's <code>&lt;application&gt;</code> tag. The Application
/// class, or your subclass of the Application class, is instantiated before any
/// other class when the process for your application/package is created.
///
/// <p class="note"><strong>Note: </strong>There is normally no need to subclass
/// Application.  In most situations, static singletons can provide the same
/// functionality in a more modular way.  If your singleton needs a global
/// context (for example to register broadcast receivers), include
/// android.content.Context\#getApplicationContext() Context.getApplicationContext()
/// as a android.content.Context argument when invoking your singleton's
/// <code>getInstance()</code> method.
///
///
class Application extends content.ContextWrapper {
  Application.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Application_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Application() : super.fromRef(_ctor());

  static final _onCreate =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Application_onCreate")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreate()
  /// Called when the application is starting, before any activity, service,
  /// or receiver objects (excluding content providers) have been created.
  ///
  /// Implementations should be as quick as possible (for example using
  /// lazy initialization of state) since the time spent in this function
  /// directly impacts the performance of starting the first activity,
  /// service, or receiver in a process.
  ///
  ///
  /// If you override this method, be sure to call {@code super.onCreate()}.
  ///
  ///
  /// <p class="note">Be aware that direct boot may also affect callback order on
  /// Android android.os.Build.VERSION_CODES\#N and later devices.
  /// Until the user unlocks the device, only direct boot aware components are
  /// allowed to run. You should consider that all direct boot unaware
  /// components, including such android.content.ContentProvider, are
  /// disabled until user unlock happens, especially when component callback
  /// order matters.
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onCreate() => _onCreate(reference);

  static final _onTerminate =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Application_onTerminate")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onTerminate()
  /// This method is for use in emulated process environments.  It will
  /// never be called on a production Android device, where processes are
  /// removed by simply killing them; no user code (including this callback)
  /// is executed when doing so.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onTerminate() => _onTerminate(reference);

  static final _onConfigurationChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Application_onConfigurationChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onConfigurationChanged(android.content.res.Configuration newConfig)
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  void onConfigurationChanged(res.Configuration newConfig) =>
      _onConfigurationChanged(reference, newConfig.reference);

  static final _onLowMemory =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_Application_onLowMemory")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onLowMemory()
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  void onLowMemory() => _onLowMemory(reference);

  static final _onTrimMemory = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_Application_onTrimMemory")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onTrimMemory(int level)
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  void onTrimMemory(int level) => _onTrimMemory(reference, level);

  static final _registerComponentCallbacks = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Application_registerComponentCallbacks")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerComponentCallbacks(android.content.ComponentCallbacks callback)
  void registerComponentCallbacks(content.ComponentCallbacks callback) =>
      _registerComponentCallbacks(reference, callback.reference);

  static final _unregisterComponentCallbacks = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Application_unregisterComponentCallbacks")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterComponentCallbacks(android.content.ComponentCallbacks callback)
  void unregisterComponentCallbacks(content.ComponentCallbacks callback) =>
      _unregisterComponentCallbacks(reference, callback.reference);

  static final _registerActivityLifecycleCallbacks = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Application_registerActivityLifecycleCallbacks")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerActivityLifecycleCallbacks(android.app.Application.ActivityLifecycleCallbacks callback)
  void registerActivityLifecycleCallbacks(
          Application_ActivityLifecycleCallbacks callback) =>
      _registerActivityLifecycleCallbacks(reference, callback.reference);

  static final _unregisterActivityLifecycleCallbacks = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Application_unregisterActivityLifecycleCallbacks")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterActivityLifecycleCallbacks(android.app.Application.ActivityLifecycleCallbacks callback)
  void unregisterActivityLifecycleCallbacks(
          Application_ActivityLifecycleCallbacks callback) =>
      _unregisterActivityLifecycleCallbacks(reference, callback.reference);

  static final _registerOnProvideAssistDataListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Application_registerOnProvideAssistDataListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerOnProvideAssistDataListener(android.app.Application.OnProvideAssistDataListener callback)
  void registerOnProvideAssistDataListener(
          Application_OnProvideAssistDataListener callback) =>
      _registerOnProvideAssistDataListener(reference, callback.reference);

  static final _unregisterOnProvideAssistDataListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Application_unregisterOnProvideAssistDataListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterOnProvideAssistDataListener(android.app.Application.OnProvideAssistDataListener callback)
  void unregisterOnProvideAssistDataListener(
          Application_OnProvideAssistDataListener callback) =>
      _unregisterOnProvideAssistDataListener(reference, callback.reference);

  static final _getProcessName =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_Application_getProcessName")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public java.lang.String getProcessName()
  /// Returns the name of the current process. A package's default process name
  /// is the same as its package name. Non-default processes will look like
  /// "$PACKAGE_NAME:$NAME", where $NAME corresponds to an android:process
  /// attribute within AndroidManifest.xml.
  static jni.JlString getProcessName() =>
      jni.JlString.fromRef(_getProcessName());
}

/// Callback interface for use with Application\#registerOnProvideAssistDataListener
/// and Application\#unregisterOnProvideAssistDataListener.
class Application_OnProvideAssistDataListener extends jni.JlObject {
  Application_OnProvideAssistDataListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onProvideAssistData = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Application__OnProvideAssistDataListener_onProvideAssistData")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onProvideAssistData(android.app.Activity activity, android.os.Bundle data)
  /// This is called when the user is requesting an assist, to build a full
  /// Intent\#ACTION_ASSIST Intent with all of the context of the current
  /// application.  You can override this method to place into the bundle anything
  /// you would like to appear in the Intent\#EXTRA_ASSIST_CONTEXT part
  /// of the assist Intent.
  void onProvideAssistData(Activity activity, os.Bundle data) =>
      _onProvideAssistData(reference, activity.reference, data.reference);
}

class Application_ActivityLifecycleCallbacks extends jni.JlObject {
  Application_ActivityLifecycleCallbacks.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onActivityCreated = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Application__ActivityLifecycleCallbacks_onActivityCreated")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onActivityCreated(android.app.Activity activity, android.os.Bundle savedInstanceState)
  void onActivityCreated(Activity activity, os.Bundle savedInstanceState) =>
      _onActivityCreated(
          reference, activity.reference, savedInstanceState.reference);

  static final _onActivityStarted = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Application__ActivityLifecycleCallbacks_onActivityStarted")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onActivityStarted(android.app.Activity activity)
  void onActivityStarted(Activity activity) =>
      _onActivityStarted(reference, activity.reference);

  static final _onActivityResumed = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Application__ActivityLifecycleCallbacks_onActivityResumed")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onActivityResumed(android.app.Activity activity)
  void onActivityResumed(Activity activity) =>
      _onActivityResumed(reference, activity.reference);

  static final _onActivityPaused = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Application__ActivityLifecycleCallbacks_onActivityPaused")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onActivityPaused(android.app.Activity activity)
  void onActivityPaused(Activity activity) =>
      _onActivityPaused(reference, activity.reference);

  static final _onActivityStopped = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Application__ActivityLifecycleCallbacks_onActivityStopped")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onActivityStopped(android.app.Activity activity)
  void onActivityStopped(Activity activity) =>
      _onActivityStopped(reference, activity.reference);

  static final _onActivitySaveInstanceState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Application__ActivityLifecycleCallbacks_onActivitySaveInstanceState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onActivitySaveInstanceState(android.app.Activity activity, android.os.Bundle outState)
  void onActivitySaveInstanceState(Activity activity, os.Bundle outState) =>
      _onActivitySaveInstanceState(
          reference, activity.reference, outState.reference);

  static final _onActivityDestroyed = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_Application__ActivityLifecycleCallbacks_onActivityDestroyed")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onActivityDestroyed(android.app.Activity activity)
  void onActivityDestroyed(Activity activity) =>
      _onActivityDestroyed(reference, activity.reference);
}

///
/// This class gives information about, and interacts
/// with, activities, services, and the containing
/// process.
///
///
///
///
/// A number of the methods in this class are for
/// debugging or informational purposes and they should
/// not be used to affect any runtime behavior of
/// your app. These methods are called out as such in
/// the method level documentation.
///
///
///
///
/// Most application developers should not have the need to
/// use this class, most of whose methods are for specialized
/// use cases. However, a few methods are more broadly applicable.
/// For instance, android.app.ActivityManager\#isLowRamDevice() isLowRamDevice()
/// enables your app to detect whether it is running on a low-memory device,
/// and behave accordingly.
/// android.app.ActivityManager\#clearApplicationUserData() clearApplicationUserData()
/// is for apps with reset-data functionality.
///
///
///
///
/// In some special use cases, where an app interacts with
/// its Task stack, the app may use the
/// android.app.ActivityManager.AppTask and
/// android.app.ActivityManager.RecentTaskInfo inner
/// classes. However, in general, the methods in this class should
/// be used for testing and debugging purposes only.
///
///
class ActivityManager extends jni.JlObject {
  ActivityManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_REPORT_HEAP_LIMIT
  /// Action an app can implement to handle reports from \#setWatchHeapLimit(long).
  /// If your package has an activity handling this action, it will be launched with the
  /// heap data provided to it the same way as Intent\#ACTION_SEND.  Note that to
  /// match the activty must support this action and a MIME type of "*&\#47;*".
  static const ACTION_REPORT_HEAP_LIMIT =
      "android.app.action.REPORT_HEAP_LIMIT";

  /// from: static public final int LOCK_TASK_MODE_LOCKED
  /// Full lock task mode is active.
  static const LOCK_TASK_MODE_LOCKED = 1;

  /// from: static public final int LOCK_TASK_MODE_NONE
  /// Lock task mode is not active.
  static const LOCK_TASK_MODE_NONE = 0;

  /// from: static public final int LOCK_TASK_MODE_PINNED
  /// App pinning mode is active.
  static const LOCK_TASK_MODE_PINNED = 2;

  /// from: static public final java.lang.String META_HOME_ALTERNATE
  /// <a href="{@docRoot}guide/topics/manifest/meta-data-element.html">{@code
  /// <meta-data>}</a> name for a 'home' Activity that declares a package that is to be
  /// uninstalled in lieu of the declaring one.  The package named here must be
  /// signed with the same certificate as the one declaring the {@code <meta-data>}.
  static const META_HOME_ALTERNATE = "android.app.home.alternate";

  /// from: static public final int MOVE_TASK_NO_USER_ACTION
  /// Flag for \#moveTaskToFront(int, int): don't count this as a
  /// user-instigated action, so the current activity will not receive a
  /// hint that the user is leaving.
  static const MOVE_TASK_NO_USER_ACTION = 2;

  /// from: static public final int MOVE_TASK_WITH_HOME
  /// Flag for \#moveTaskToFront(int, int): also move the "home"
  /// activity along with the task, so it is positioned immediately behind
  /// the task.
  static const MOVE_TASK_WITH_HOME = 1;

  /// from: static public final int RECENT_IGNORE_UNAVAILABLE
  /// Provides a list that does not contain any
  /// recent tasks that currently are not available to the user.
  static const RECENT_IGNORE_UNAVAILABLE = 2;

  /// from: static public final int RECENT_WITH_EXCLUDED
  /// Flag for use with \#getRecentTasks: return all tasks, even those
  /// that have set their
  /// android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS flag.
  static const RECENT_WITH_EXCLUDED = 1;

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_ActivityManager_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.content.Context context, android.os.Handler handler)
  ActivityManager(content.Context context, os.Handler handler)
      : super.fromRef(_ctor(context.reference, handler.reference));

  static final _getMemoryClass =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityManager_getMemoryClass")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getMemoryClass()
  /// Return the approximate per-application memory class of the current
  /// device.  This gives you an idea of how hard a memory limit you should
  /// impose on your application to let the overall system work best.  The
  /// returned value is in megabytes; the baseline Android memory class is
  /// 16 (which happens to be the Java heap limit of those devices); some
  /// devices with more memory may return 24 or even higher numbers.
  int getMemoryClass() => _getMemoryClass(reference);

  static final _getLargeMemoryClass =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityManager_getLargeMemoryClass")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLargeMemoryClass()
  /// Return the approximate per-application memory class of the current
  /// device when an application is running with a large heap.  This is the
  /// space available for memory-intensive applications; most applications
  /// should not need this amount of memory, and should instead stay with the
  /// \#getMemoryClass() limit.  The returned value is in megabytes.
  /// This may be the same size as \#getMemoryClass() on memory
  /// constrained devices, or it may be significantly larger on devices with
  /// a large amount of available RAM.
  ///
  /// This is the size of the application's Dalvik heap if it has
  /// specified <code>android:largeHeap="true"</code> in its manifest.
  int getLargeMemoryClass() => _getLargeMemoryClass(reference);

  static final _isLowRamDevice =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityManager_isLowRamDevice")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isLowRamDevice()
  /// Returns true if this is a low-RAM device.  Exactly whether a device is low-RAM
  /// is ultimately up to the device configuration, but currently it generally means
  /// something with 1GB or less of RAM.  This is mostly intended to be used by apps
  /// to determine whether they should turn off certain features that require more RAM.
  bool isLowRamDevice() => _isLowRamDevice(reference) != 0;

  static final _getRecentTasks = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_app_ActivityManager_getRecentTasks")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public java.util.List<android.app.ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum, int flags)
  ///
  ///Return a list of the tasks that the user has recently launched, with
  /// the most recent being first and older ones after in order.
  ///
  /// __Note: this method is only intended for debugging and presenting
  /// task management user interfaces__.  This should never be used for
  /// core logic in an application, such as deciding between different
  /// behaviors based on the information found here.  Such uses are
  /// _not_ supported, and will likely break in the future.  For
  /// example, if multiple applications can be actively running at the
  /// same time, assumptions made about the meaning of the data here for
  /// purposes of control flow will be incorrect.
  ///
  ///@deprecated As of android.os.Build.VERSION_CODES\#LOLLIPOP, this method is
  /// no longer available to third party applications: the introduction of
  /// document-centric recents means
  /// it can leak personal information to the caller.  For backwards compatibility,
  /// it will still return a small subset of its data: at least the caller's
  /// own tasks (though see \#getAppTasks() for the correct supported
  /// way to retrieve that information), and possibly some other tasks
  /// such as home that are known to not be sensitive.
  ///@param maxNum The maximum number of entries to return in the list.  The
  /// actual number returned may be smaller, depending on how many tasks the
  /// user has started and the maximum number the system can remember.
  ///@param flags Information about what to return.  May be any combination
  /// of \#RECENT_WITH_EXCLUDED and \#RECENT_IGNORE_UNAVAILABLE.
  ///@return Returns a list of RecentTaskInfo records describing each of
  /// the recent tasks.
  jni.JlObject getRecentTasks(int maxNum, int flags) =>
      jni.JlObject.fromRef(_getRecentTasks(reference, maxNum, flags));

  static final _getAppTasks = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager_getAppTasks")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.ActivityManager.AppTask> getAppTasks()
  /// Get the list of tasks associated with the calling application.
  ///@return The list of tasks associated with the application making this call.
  ///@throws SecurityException
  jni.JlObject getAppTasks() => jni.JlObject.fromRef(_getAppTasks(reference));

  static final _getAppTaskThumbnailSize = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager_getAppTaskThumbnailSize")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.util.Size getAppTaskThumbnailSize()
  /// Return the current design dimensions for AppTask thumbnails, for use
  /// with \#addAppTask.
  jni.JlObject getAppTaskThumbnailSize() =>
      jni.JlObject.fromRef(_getAppTaskThumbnailSize(reference));

  static final _addAppTask = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager_addAppTask")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int addAppTask(android.app.Activity activity, android.content.Intent intent, android.app.ActivityManager.TaskDescription description, android.graphics.Bitmap thumbnail)
  /// Add a new AppTask for the calling application.  This will create a new
  /// recents entry that is added to the __end__ of all existing recents.
  ///@param activity The activity that is adding the entry.   This is used to help determine
  /// the context that the new recents entry will be in.
  /// This value must never be {@code null}.
  ///@param intent The Intent that describes the recents entry.  This is the same Intent that
  /// you would have used to launch the activity for it.  In generally you will want to set
  /// both Intent\#FLAG_ACTIVITY_NEW_DOCUMENT and
  /// Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS; the latter is required since this recents
  /// entry will exist without an activity, so it doesn't make sense to not retain it when
  /// its activity disappears.  The given Intent here also must have an explicit ComponentName
  /// set on it.
  /// This value must never be {@code null}.
  ///@param description Optional additional description information.
  /// This value may be {@code null}.
  ///@param thumbnail Thumbnail to use for the recents entry.  Should be the size given by
  /// \#getAppTaskThumbnailSize().  If the bitmap is not that exact size, it will be
  /// recreated in your process, probably in a way you don't like, before the recents entry
  /// is added.
  ///
  /// This value must never be {@code null}.
  ///@return Returns the task id of the newly added app task, or -1 if the add failed.  The
  /// most likely cause of failure is that there is no more room for more tasks for your app.
  int addAppTask(
          Activity activity,
          content.Intent intent,
          ActivityManager_TaskDescription description,
          jni.JlObject thumbnail) =>
      _addAppTask(reference, activity.reference, intent.reference,
          description.reference, thumbnail.reference);

  static final _getRunningTasks = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ActivityManager_getRunningTasks")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.util.List<android.app.ActivityManager.RunningTaskInfo> getRunningTasks(int maxNum)
  /// Return a list of the tasks that are currently running, with
  /// the most recent being first and older ones after in order.  Note that
  /// "running" does not mean any of the task's code is currently loaded or
  /// activity -- the task may have been frozen by the system, so that it
  /// can be restarted in its previous state when next brought to the
  /// foreground.
  ///
  /// __Note: this method is only intended for debugging and presenting
  /// task management user interfaces__.  This should never be used for
  /// core logic in an application, such as deciding between different
  /// behaviors based on the information found here.  Such uses are
  /// _not_ supported, and will likely break in the future.  For
  /// example, if multiple applications can be actively running at the
  /// same time, assumptions made about the meaning of the data here for
  /// purposes of control flow will be incorrect.
  ///
  ///@deprecated As of android.os.Build.VERSION_CODES\#LOLLIPOP, this method
  /// is no longer available to third party
  /// applications: the introduction of document-centric recents means
  /// it can leak person information to the caller.  For backwards compatibility,
  /// it will still return a small subset of its data: at least the caller's
  /// own tasks, and possibly some other tasks
  /// such as home that are known to not be sensitive.
  ///@param maxNum The maximum number of entries to return in the list.  The
  /// actual number returned may be smaller, depending on how many tasks the
  /// user has started.
  ///@return Returns a list of RunningTaskInfo records describing each of
  /// the running tasks.
  jni.JlObject getRunningTasks(int maxNum) =>
      jni.JlObject.fromRef(_getRunningTasks(reference, maxNum));

  static final _moveTaskToFront = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_app_ActivityManager_moveTaskToFront")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void moveTaskToFront(int taskId, int flags)
  /// Equivalent to calling \#moveTaskToFront(int, int, Bundle)
  /// with a null options argument.
  ///
  /// Requires android.Manifest.permission\#REORDER_TASKS
  ///@param taskId The identifier of the task to be moved, as found in
  /// RunningTaskInfo or RecentTaskInfo.
  ///@param flags Additional operational flags.
  ///
  /// Value is either <code>0</code> or a combination of android.app.ActivityManager\#MOVE_TASK_WITH_HOME, and android.app.ActivityManager\#MOVE_TASK_NO_USER_ACTION
  void moveTaskToFront(int taskId, int flags) =>
      _moveTaskToFront(reference, taskId, flags);

  static final _moveTaskToFront_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager_moveTaskToFront_1")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void moveTaskToFront(int taskId, int flags, android.os.Bundle options)
  /// Ask that the task associated with a given task ID be moved to the
  /// front of the stack, so it is now visible to the user.
  ///
  /// Requires android.Manifest.permission\#REORDER_TASKS
  ///@param taskId The identifier of the task to be moved, as found in
  /// RunningTaskInfo or RecentTaskInfo.
  ///@param flags Additional operational flags.
  /// Value is either <code>0</code> or a combination of android.app.ActivityManager\#MOVE_TASK_WITH_HOME, and android.app.ActivityManager\#MOVE_TASK_NO_USER_ACTION
  ///@param options Additional options for the operation, either null or
  /// as per Context\#startActivity(Intent, android.os.Bundle) Context.startActivity(Intent, Bundle).
  void moveTaskToFront_1(int taskId, int flags, os.Bundle options) =>
      _moveTaskToFront_1(reference, taskId, flags, options.reference);

  static final _getRunningServices = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_ActivityManager_getRunningServices")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.util.List<android.app.ActivityManager.RunningServiceInfo> getRunningServices(int maxNum)
  /// Return a list of the services that are currently running.
  ///
  /// __Note: this method is only intended for debugging or implementing
  /// service management type user interfaces.__
  ///
  ///@deprecated As of android.os.Build.VERSION_CODES\#O, this method
  /// is no longer available to third party applications.  For backwards compatibility,
  /// it will still return the caller's own services.
  ///@param maxNum The maximum number of entries to return in the list.  The
  /// actual number returned may be smaller, depending on how many services
  /// are running.
  ///@return Returns a list of RunningServiceInfo records describing each of
  /// the running tasks.
  jni.JlObject getRunningServices(int maxNum) =>
      jni.JlObject.fromRef(_getRunningServices(reference, maxNum));

  static final _getRunningServiceControlPanel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager_getRunningServiceControlPanel")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent getRunningServiceControlPanel(android.content.ComponentName service)
  /// Returns a PendingIntent you can start to show a control panel for the
  /// given running service.  If the service does not have a control panel,
  /// null is returned.
  PendingIntent getRunningServiceControlPanel(content.ComponentName service) =>
      PendingIntent.fromRef(
          _getRunningServiceControlPanel(reference, service.reference));

  static final _getMemoryInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager_getMemoryInfo")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void getMemoryInfo(android.app.ActivityManager.MemoryInfo outInfo)
  /// Return general information about the memory state of the system.  This
  /// can be used to help decide how to manage your own memory, though note
  /// that polling is not recommended and
  /// android.content.ComponentCallbacks2\#onTrimMemory(int) ComponentCallbacks2.onTrimMemory(int) is the preferred way to do this.
  /// Also see \#getMyMemoryState for how to retrieve the current trim
  /// level of your process as needed, which gives a better hint for how to
  /// manage its memory.
  void getMemoryInfo(ActivityManager_MemoryInfo outInfo) =>
      _getMemoryInfo(reference, outInfo.reference);

  static final _clearApplicationUserData =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityManager_clearApplicationUserData")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean clearApplicationUserData()
  /// Permits an application to erase its own data from disk.  This is equivalent to
  /// the user choosing to clear the app's data from within the device settings UI.  It
  /// erases all dynamic data associated with the app -- its private data and data in its
  /// private area on external storage -- but does not remove the installed application
  /// itself, nor any OBB files. It also revokes all runtime permissions that the app has acquired,
  /// clears all notifications and removes all Uri grants related to this application.
  ///@return {@code true} if the application successfully requested that the application's
  ///     data be erased; {@code false} otherwise.
  bool clearApplicationUserData() => _clearApplicationUserData(reference) != 0;

  static final _getProcessesInErrorState = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager_getProcessesInErrorState")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.ActivityManager.ProcessErrorStateInfo> getProcessesInErrorState()
  /// Returns a list of any processes that are currently in an error condition.  The result
  /// will be null if all processes are running properly at this time.
  ///@return Returns a list of ProcessErrorStateInfo records, or null if there are no
  /// current error conditions (it will not return an empty list).  This list ordering is not
  /// specified.
  jni.JlObject getProcessesInErrorState() =>
      jni.JlObject.fromRef(_getProcessesInErrorState(reference));

  static final _isBackgroundRestricted =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityManager_isBackgroundRestricted")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isBackgroundRestricted()
  /// Query whether the user has enabled background restrictions for this app.
  ///
  ///  The user may chose to do this, if they see that an app is consuming an unreasonable
  /// amount of battery while in the background.
  ///
  ///
  ///  If true, any work that the app tries to do will be aggressively restricted while it is in
  /// the background. At a minimum, jobs and alarms will not execute and foreground services
  /// cannot be started unless an app activity is in the foreground.
  ///
  ///
  /// __ Note that these restrictions stay in effect even when the device is charging.__
  ///
  ///@return true if user has enforced background restrictions for this app, false otherwise.
  bool isBackgroundRestricted() => _isBackgroundRestricted(reference) != 0;

  static final _getRunningAppProcesses = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager_getRunningAppProcesses")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.ActivityManager.RunningAppProcessInfo> getRunningAppProcesses()
  /// Returns a list of application processes that are running on the device.
  ///
  /// __Note: this method is only intended for debugging or building
  /// a user-facing process management UI.__
  ///
  ///@return Returns a list of RunningAppProcessInfo records, or null if there are no
  /// running processes (it will not return an empty list).  This list ordering is not
  /// specified.
  jni.JlObject getRunningAppProcesses() =>
      jni.JlObject.fromRef(_getRunningAppProcesses(reference));

  static final _getMyMemoryState =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityManager_getMyMemoryState")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void getMyMemoryState(android.app.ActivityManager.RunningAppProcessInfo outState)
  /// Return global memory state information for the calling process.  This
  /// does not fill in all fields of the RunningAppProcessInfo.  The
  /// only fields that will be filled in are
  /// RunningAppProcessInfo\#pid,
  /// RunningAppProcessInfo\#uid,
  /// RunningAppProcessInfo\#lastTrimLevel,
  /// RunningAppProcessInfo\#importance,
  /// RunningAppProcessInfo\#lru, and
  /// RunningAppProcessInfo\#importanceReasonCode.
  static void getMyMemoryState(
          ActivityManager_RunningAppProcessInfo outState) =>
      _getMyMemoryState(outState.reference);

  static final _getProcessMemoryInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager_getProcessMemoryInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Debug.MemoryInfo[] getProcessMemoryInfo(int[] pids)
  /// Return information about the memory usage of one or more processes.
  ///
  /// __Note: this method is only intended for debugging or building
  /// a user-facing process management UI.__
  ///
  ///@param pids The pids of the processes whose memory usage is to be
  /// retrieved.
  ///@return Returns an array of memory information, one for each
  /// requested pid.
  jni.JlObject getProcessMemoryInfo(jni.JlObject pids) =>
      jni.JlObject.fromRef(_getProcessMemoryInfo(reference, pids.reference));

  static final _restartPackage = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager_restartPackage")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void restartPackage(java.lang.String packageName)
  /// @deprecated This is now just a wrapper for
  /// \#killBackgroundProcesses(String); the previous behavior here
  /// is no longer available to applications because it allows them to
  /// break other applications by removing their alarms, stopping their
  /// services, etc.
  void restartPackage(jni.JlString packageName) =>
      _restartPackage(reference, packageName.reference);

  static final _killBackgroundProcesses = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager_killBackgroundProcesses")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void killBackgroundProcesses(java.lang.String packageName)
  /// Have the system immediately kill all background processes associated
  /// with the given package.  This is the same as the kernel killing those
  /// processes to reclaim memory; the system will take care of restarting
  /// these processes in the future as needed.
  ///
  /// Requires android.Manifest.permission\#KILL_BACKGROUND_PROCESSES
  ///@param packageName The name of the package whose processes are to
  /// be killed.
  void killBackgroundProcesses(jni.JlString packageName) =>
      _killBackgroundProcesses(reference, packageName.reference);

  static final _getDeviceConfigurationInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager_getDeviceConfigurationInfo")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ConfigurationInfo getDeviceConfigurationInfo()
  /// Get the device configuration attributes.
  pm.ConfigurationInfo getDeviceConfigurationInfo() =>
      pm.ConfigurationInfo.fromRef(_getDeviceConfigurationInfo(reference));

  static final _getLauncherLargeIconDensity =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityManager_getLauncherLargeIconDensity")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLauncherLargeIconDensity()
  /// Get the preferred density of icons for the launcher. This is used when
  /// custom drawables are created (e.g., for shortcuts).
  ///@return density in terms of DPI
  int getLauncherLargeIconDensity() => _getLauncherLargeIconDensity(reference);

  static final _getLauncherLargeIconSize =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityManager_getLauncherLargeIconSize")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLauncherLargeIconSize()
  /// Get the preferred launcher icon size. This is used when custom drawables
  /// are created (e.g., for shortcuts).
  ///@return dimensions of square icons in terms of pixels
  int getLauncherLargeIconSize() => _getLauncherLargeIconSize(reference);

  static final _isUserAMonkey =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function()>>(
              "android_app_ActivityManager_isUserAMonkey")
          .asFunction<int Function()>();

  /// from: static public boolean isUserAMonkey()
  /// Returns "true" if the user interface is currently being messed with
  /// by a monkey.
  static bool isUserAMonkey() => _isUserAMonkey() != 0;

  static final _isRunningInTestHarness =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function()>>(
              "android_app_ActivityManager_isRunningInTestHarness")
          .asFunction<int Function()>();

  /// from: static public boolean isRunningInTestHarness()
  /// Returns "true" if device is running in a test harness.
  static bool isRunningInTestHarness() => _isRunningInTestHarness() != 0;

  static final _dumpPackageState = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager_dumpPackageState")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dumpPackageState(java.io.FileDescriptor fd, java.lang.String packageName)
  /// Perform a system dump of various state associated with the given application
  /// package name.  This call blocks while the dump is being performed, so should
  /// not be done on a UI thread.  The data will be written to the given file
  /// descriptor as text.
  /// Requires android.Manifest.permission\#DUMP
  ///@param fd The file descriptor that the dump should be written to.  The file
  /// descriptor is _not_ closed by this function; the caller continues to
  /// own it.
  ///@param packageName The name of the package that is to be dumped.
  void dumpPackageState(jni.JlObject fd, jni.JlString packageName) =>
      _dumpPackageState(reference, fd.reference, packageName.reference);

  static final _setWatchHeapLimit = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_app_ActivityManager_setWatchHeapLimit")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setWatchHeapLimit(long pssSize)
  /// Request that the system start watching for the calling process to exceed a pss
  /// size as given here.  Once called, the system will look for any occasions where it
  /// sees the associated process with a larger pss size and, when this happens, automatically
  /// pull a heap dump from it and allow the user to share the data.  Note that this request
  /// continues running even if the process is killed and restarted.  To remove the watch,
  /// use \#clearWatchHeapLimit().
  ///
  /// This API only work if the calling process has been marked as
  /// ApplicationInfo\#FLAG_DEBUGGABLE or this is running on a debuggable
  /// (userdebug or eng) build.
  ///
  ///
  /// Callers can optionally implement \#ACTION_REPORT_HEAP_LIMIT to directly
  /// handle heap limit reports themselves.
  ///
  ///@param pssSize The size in bytes to set the limit at.
  void setWatchHeapLimit(int pssSize) => _setWatchHeapLimit(reference, pssSize);

  static final _clearWatchHeapLimit =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityManager_clearWatchHeapLimit")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void clearWatchHeapLimit()
  /// Clear a heap watch limit previously set by \#setWatchHeapLimit(long).
  void clearWatchHeapLimit() => _clearWatchHeapLimit(reference);

  static final _isInLockTaskMode =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityManager_isInLockTaskMode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isInLockTaskMode()
  /// Return whether currently in lock task mode.  When in this mode
  /// no new tasks can be created or switched to.
  ///@see Activity\#startLockTask()
  ///@deprecated Use \#getLockTaskModeState instead.
  bool isInLockTaskMode() => _isInLockTaskMode(reference) != 0;

  static final _getLockTaskModeState =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityManager_getLockTaskModeState")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLockTaskModeState()
  /// Return the current state of task locking. The three possible outcomes
  /// are \#LOCK_TASK_MODE_NONE, \#LOCK_TASK_MODE_LOCKED
  /// and \#LOCK_TASK_MODE_PINNED.
  ///@see Activity\#startLockTask()
  int getLockTaskModeState() => _getLockTaskModeState(reference);

  static final _setVrThread =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
              "android_app_ActivityManager_setVrThread")
          .asFunction<void Function(int)>();

  /// from: static public void setVrThread(int tid)
  /// Enable more aggressive scheduling for latency-sensitive low-runtime VR threads. Only one
  /// thread can be a VR thread in a process at a time, and that thread may be subject to
  /// restrictions on the amount of time it can run.
  ///
  /// If persistent VR mode is set, whatever thread has been granted aggressive scheduling via this
  /// method will return to normal operation, and calling this method will do nothing while
  /// persistent VR mode is enabled.
  ///
  /// To reset the VR thread for an application, a tid of 0 can be passed.
  ///@see android.os.Process\#myTid()
  ///@param tid tid of the VR thread
  static void setVrThread(int tid) => _setVrThread(tid);
}

/// Information you can set and retrieve about the current activity within the recent task list.
class ActivityManager_TaskDescription extends jni.JlObject {
  ActivityManager_TaskDescription.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.TaskDescription> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_ActivityManager__TaskDescription_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ActivityManager__TaskDescription_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String label, android.graphics.Bitmap icon, int colorPrimary)
  /// Creates the TaskDescription to the specified values.
  ///@param label A label and description of the current state of this task.
  ///@param icon An icon that represents the current state of this task.
  ///@param colorPrimary A color to override the theme's primary color.  This color must be
  ///                     opaque.
  ///@deprecated use TaskDescription constructor with icon resource instead
  ActivityManager_TaskDescription(
      jni.JlString label, jni.JlObject icon, int colorPrimary)
      : super.fromRef(_ctor(label.reference, icon.reference, colorPrimary));

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_app_ActivityManager__TaskDescription_new_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void <init>(java.lang.String label, int iconRes, int colorPrimary)
  /// Creates the TaskDescription to the specified values.
  ///@param label A label and description of the current state of this task.
  ///@param iconRes A drawable resource of an icon that represents the current state of this
  ///                activity.
  ///@param colorPrimary A color to override the theme's primary color.  This color must be
  ///                     opaque.
  ActivityManager_TaskDescription.ctor_1(
      jni.JlString label, int iconRes, int colorPrimary)
      : super.fromRef(_ctor_1(label.reference, iconRes, colorPrimary));

  static final _ctor_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__TaskDescription_new_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String label, android.graphics.Bitmap icon)
  /// Creates the TaskDescription to the specified values.
  ///@param label A label and description of the current state of this activity.
  ///@param icon An icon that represents the current state of this activity.
  ///@deprecated use TaskDescription constructor with icon resource instead
  ActivityManager_TaskDescription.ctor_2(jni.JlString label, jni.JlObject icon)
      : super.fromRef(_ctor_2(label.reference, icon.reference));

  static final _ctor_3 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ActivityManager__TaskDescription_new_3")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String label, int iconRes)
  /// Creates the TaskDescription to the specified values.
  ///@param label A label and description of the current state of this activity.
  ///@param iconRes A drawable resource of an icon that represents the current state of this
  ///                activity.
  ActivityManager_TaskDescription.ctor_3(jni.JlString label, int iconRes)
      : super.fromRef(_ctor_3(label.reference, iconRes));

  static final _ctor_4 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__TaskDescription_new_4")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String label)
  /// Creates the TaskDescription to the specified values.
  ///@param label A label and description of the current state of this activity.
  ActivityManager_TaskDescription.ctor_4(jni.JlString label)
      : super.fromRef(_ctor_4(label.reference));

  static final _ctor_5 =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ActivityManager__TaskDescription_new_5")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Creates an empty TaskDescription.
  ActivityManager_TaskDescription.ctor_5() : super.fromRef(_ctor_5());

  static final _ctor_6 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__TaskDescription_new_6")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.ActivityManager.TaskDescription td)
  /// Creates a copy of another TaskDescription.
  ActivityManager_TaskDescription.ctor_6(ActivityManager_TaskDescription td)
      : super.fromRef(_ctor_6(td.reference));

  static final _getLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__TaskDescription_getLabel")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getLabel()
  /// @return The label and description of the current state of this task.
  jni.JlString getLabel() => jni.JlString.fromRef(_getLabel(reference));

  static final _getIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__TaskDescription_getIcon")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap getIcon()
  /// @return The icon that represents the current state of this task.
  jni.JlObject getIcon() => jni.JlObject.fromRef(_getIcon(reference));

  static final _getPrimaryColor =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityManager__TaskDescription_getPrimaryColor")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getPrimaryColor()
  /// @return The color override on the theme's primary color.
  int getPrimaryColor() => _getPrimaryColor(reference);

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityManager__TaskDescription_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ActivityManager__TaskDescription_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _readFromParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__TaskDescription_readFromParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(os.Parcel source) =>
      _readFromParcel(reference, source.reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__TaskDescription_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));
}

/// Information you can retrieve about a particular task that is currently
/// "running" in the system.  Note that a running task does not mean the
/// given task actually has a process it is actively running in; it simply
/// means that the user has gone to it and never closed it, but currently
/// the system may have killed its process and is only holding on to its
/// last state in order to restart it when the user returns.
class ActivityManager_RunningTaskInfo extends jni.JlObject {
  ActivityManager_RunningTaskInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.RunningTaskInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_ActivityManager__RunningTaskInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: public android.content.ComponentName baseActivity
  /// The component launched as the first activity in the task.  This can
  /// be considered the "application" of this task.
  static final _getbaseActivity = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningTaskInfo_baseActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  content.ComponentName get baseActivity =>
      content.ComponentName.fromRef(_getbaseActivity(reference));
  static final _setbaseActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__RunningTaskInfo_baseActivity")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set baseActivity(content.ComponentName value) =>
      _setbaseActivity(reference, value.reference);

  /// from: public java.lang.CharSequence description
  /// Description of the task's current state.
  static final _getdescription = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningTaskInfo_description")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get description =>
      jni.JlObject.fromRef(_getdescription(reference));
  static final _setdescription = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__RunningTaskInfo_description")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set description(jni.JlObject value) =>
      _setdescription(reference, value.reference);

  /// from: public int id
  /// A unique identifier for this task.
  static final _getid = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningTaskInfo_id")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get id => _getid(reference);
  static final _setid = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RunningTaskInfo_id")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set id(int value) => _setid(reference, value);

  /// from: public int numActivities
  /// Number of activities in this task.
  static final _getnumActivities = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningTaskInfo_numActivities")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get numActivities => _getnumActivities(reference);
  static final _setnumActivities = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RunningTaskInfo_numActivities")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set numActivities(int value) => _setnumActivities(reference, value);

  /// from: public int numRunning
  /// Number of activities that are currently running (not stopped
  /// and persisted) in this task.
  static final _getnumRunning = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningTaskInfo_numRunning")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get numRunning => _getnumRunning(reference);
  static final _setnumRunning = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RunningTaskInfo_numRunning")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set numRunning(int value) => _setnumRunning(reference, value);

  /// from: public android.graphics.Bitmap thumbnail
  /// Thumbnail representation of the task's current state.  Currently
  /// always null.
  static final _getthumbnail = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningTaskInfo_thumbnail")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get thumbnail => jni.JlObject.fromRef(_getthumbnail(reference));
  static final _setthumbnail = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__RunningTaskInfo_thumbnail")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set thumbnail(jni.JlObject value) =>
      _setthumbnail(reference, value.reference);

  /// from: public android.content.ComponentName topActivity
  /// The activity component at the top of the history stack of the task.
  /// This is what the user is currently doing.
  static final _gettopActivity = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningTaskInfo_topActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  content.ComponentName get topActivity =>
      content.ComponentName.fromRef(_gettopActivity(reference));
  static final _settopActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__RunningTaskInfo_topActivity")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set topActivity(content.ComponentName value) =>
      _settopActivity(reference, value.reference);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ActivityManager__RunningTaskInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ActivityManager_RunningTaskInfo() : super.fromRef(_ctor());

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityManager__RunningTaskInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ActivityManager__RunningTaskInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _readFromParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__RunningTaskInfo_readFromParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(os.Parcel source) =>
      _readFromParcel(reference, source.reference);
}

/// Information you can retrieve about a particular Service that is
/// currently running in the system.
class ActivityManager_RunningServiceInfo extends jni.JlObject {
  ActivityManager_RunningServiceInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.RunningServiceInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_ActivityManager__RunningServiceInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int FLAG_FOREGROUND
  /// Bit for \#flags: set if the service has asked to
  /// run as a foreground process.
  static const FLAG_FOREGROUND = 2;

  /// from: static public final int FLAG_PERSISTENT_PROCESS
  /// Bit for \#flags: set if the service is running in a
  /// persistent process.
  static const FLAG_PERSISTENT_PROCESS = 8;

  /// from: static public final int FLAG_STARTED
  /// Bit for \#flags: set if this service has been
  /// explicitly started.
  static const FLAG_STARTED = 1;

  /// from: static public final int FLAG_SYSTEM_PROCESS
  /// Bit for \#flags: set if the service is running in a
  /// core system process.
  static const FLAG_SYSTEM_PROCESS = 4;

  /// from: public long activeSince
  /// The time when the service was first made active, either by someone
  /// starting or binding to it.  This
  /// is in units of android.os.SystemClock\#elapsedRealtime().
  static final _getactiveSince = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningServiceInfo_activeSince")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get activeSince => _getactiveSince(reference);
  static final _setactiveSince = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_app_ActivityManager__RunningServiceInfo_activeSince")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set activeSince(int value) => _setactiveSince(reference, value);

  /// from: public int clientCount
  /// Number of clients connected to the service.
  static final _getclientCount = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningServiceInfo_clientCount")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get clientCount => _getclientCount(reference);
  static final _setclientCount = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RunningServiceInfo_clientCount")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set clientCount(int value) => _setclientCount(reference, value);

  /// from: public int clientLabel
  /// For special services that are bound to by system code, this is
  /// a string resource providing a user-visible label for who the
  /// client is.
  static final _getclientLabel = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningServiceInfo_clientLabel")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get clientLabel => _getclientLabel(reference);
  static final _setclientLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RunningServiceInfo_clientLabel")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set clientLabel(int value) => _setclientLabel(reference, value);

  /// from: public java.lang.String clientPackage
  /// For special services that are bound to by system code, this is
  /// the package that holds the binding.
  static final _getclientPackage = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningServiceInfo_clientPackage")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get clientPackage =>
      jni.JlString.fromRef(_getclientPackage(reference));
  static final _setclientPackage = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__RunningServiceInfo_clientPackage")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set clientPackage(jni.JlString value) =>
      _setclientPackage(reference, value.reference);

  /// from: public int crashCount
  /// Number of times the service's process has crashed while the service
  /// is running.
  static final _getcrashCount = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningServiceInfo_crashCount")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get crashCount => _getcrashCount(reference);
  static final _setcrashCount = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RunningServiceInfo_crashCount")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set crashCount(int value) => _setcrashCount(reference, value);

  /// from: public int flags
  /// Running flags.
  static final _getflags = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningServiceInfo_flags")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get flags => _getflags(reference);
  static final _setflags = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RunningServiceInfo_flags")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set flags(int value) => _setflags(reference, value);

  /// from: public boolean foreground
  /// Set to true if the service has asked to run as a foreground process.
  static final _getforeground = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningServiceInfo_foreground")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  bool get foreground => _getforeground(reference) != 0;
  static final _setforeground = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_android_app_ActivityManager__RunningServiceInfo_foreground")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set foreground(bool value) => _setforeground(reference, value ? 1 : 0);

  /// from: public long lastActivityTime
  /// The time when there was last activity in the service (either
  /// explicit requests to start it or clients binding to it).  This
  /// is in units of android.os.SystemClock\#uptimeMillis().
  static final _getlastActivityTime = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningServiceInfo_lastActivityTime")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get lastActivityTime => _getlastActivityTime(reference);
  static final _setlastActivityTime = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_app_ActivityManager__RunningServiceInfo_lastActivityTime")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set lastActivityTime(int value) => _setlastActivityTime(reference, value);

  /// from: public int pid
  /// If non-zero, this is the process the service is running in.
  static final _getpid = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningServiceInfo_pid")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get pid => _getpid(reference);
  static final _setpid = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RunningServiceInfo_pid")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set pid(int value) => _setpid(reference, value);

  /// from: public java.lang.String process
  /// The name of the process this service runs in.
  static final _getprocess = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningServiceInfo_process")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get process => jni.JlString.fromRef(_getprocess(reference));
  static final _setprocess = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__RunningServiceInfo_process")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set process(jni.JlString value) => _setprocess(reference, value.reference);

  /// from: public long restarting
  /// If non-zero, this service is not currently running, but scheduled to
  /// restart at the given time.
  static final _getrestarting = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningServiceInfo_restarting")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get restarting => _getrestarting(reference);
  static final _setrestarting = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_app_ActivityManager__RunningServiceInfo_restarting")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set restarting(int value) => _setrestarting(reference, value);

  /// from: public android.content.ComponentName service
  /// The service component.
  static final _getservice = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningServiceInfo_service")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  content.ComponentName get service =>
      content.ComponentName.fromRef(_getservice(reference));
  static final _setservice = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__RunningServiceInfo_service")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set service(content.ComponentName value) =>
      _setservice(reference, value.reference);

  /// from: public boolean started
  /// Set to true if this service has been explicitly started.
  static final _getstarted = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningServiceInfo_started")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  bool get started => _getstarted(reference) != 0;
  static final _setstarted = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_android_app_ActivityManager__RunningServiceInfo_started")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set started(bool value) => _setstarted(reference, value ? 1 : 0);

  /// from: public int uid
  /// The UID that owns this service.
  static final _getuid = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningServiceInfo_uid")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get uid => _getuid(reference);
  static final _setuid = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RunningServiceInfo_uid")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set uid(int value) => _setuid(reference, value);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ActivityManager__RunningServiceInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ActivityManager_RunningServiceInfo() : super.fromRef(_ctor());

  static final _describeContents = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__RunningServiceInfo_describeContents")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ActivityManager__RunningServiceInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _readFromParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__RunningServiceInfo_readFromParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(os.Parcel source) =>
      _readFromParcel(reference, source.reference);
}

/// Information you can retrieve about a running process.
class ActivityManager_RunningAppProcessInfo extends jni.JlObject {
  ActivityManager_RunningAppProcessInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.RunningAppProcessInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_ActivityManager__RunningAppProcessInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int IMPORTANCE_BACKGROUND
  /// @deprecated Renamed to \#IMPORTANCE_CACHED.
  static const IMPORTANCE_BACKGROUND = 400;

  /// from: static public final int IMPORTANCE_CACHED
  /// Constant for \#importance: This process process contains
  /// cached code that is expendable, not actively running any app components
  /// we care about.
  static const IMPORTANCE_CACHED = 400;

  /// from: static public final int IMPORTANCE_CANT_SAVE_STATE
  /// Constant for \#importance: This process is running an
  /// application that can not save its state, and thus can't be killed
  /// while in the background.  This will be used with apps that have
  /// android.R.attr\#cantSaveState set on their application tag.
  static const IMPORTANCE_CANT_SAVE_STATE = 350;

  /// from: static public final int IMPORTANCE_EMPTY
  /// Constant for \#importance: This process is empty of any
  /// actively running code.
  ///@deprecated This value is no longer reported, use \#IMPORTANCE_CACHED instead.
  static const IMPORTANCE_EMPTY = 500;

  /// from: static public final int IMPORTANCE_FOREGROUND
  /// Constant for \#importance: This process is running the
  /// foreground UI; that is, it is the thing currently at the top of the screen
  /// that the user is interacting with.
  static const IMPORTANCE_FOREGROUND = 100;

  /// from: static public final int IMPORTANCE_FOREGROUND_SERVICE
  /// Constant for \#importance: This process is running a foreground
  /// service, for example to perform music playback even while the user is
  /// not immediately in the app.  This generally indicates that the process
  /// is doing something the user actively cares about.
  static const IMPORTANCE_FOREGROUND_SERVICE = 125;

  /// from: static public final int IMPORTANCE_GONE
  /// Constant for \#importance: This process does not exist.
  static const IMPORTANCE_GONE = 1000;

  /// from: static public final int IMPORTANCE_PERCEPTIBLE
  /// Constant for \#importance: This process is not something the user
  /// is directly aware of, but is otherwise perceptible to them to some degree.
  static const IMPORTANCE_PERCEPTIBLE = 230;

  /// from: static public final int IMPORTANCE_PERCEPTIBLE_PRE_26
  /// Constant for \#importance: \#IMPORTANCE_PERCEPTIBLE had this wrong value
  /// before Build.VERSION_CODES\#O.  Since the Build.VERSION_CODES\#O SDK,
  /// the value of \#IMPORTANCE_PERCEPTIBLE has been fixed.
  ///
  /// The system will return this value instead of \#IMPORTANCE_PERCEPTIBLE
  /// on Android versions below Build.VERSION_CODES\#O.
  ///
  /// On Android version Build.VERSION_CODES\#O and later, this value will still be
  /// returned for apps with the target API level below Build.VERSION_CODES\#O.
  /// For apps targeting version Build.VERSION_CODES\#O and later,
  /// the correct value \#IMPORTANCE_PERCEPTIBLE will be returned.
  static const IMPORTANCE_PERCEPTIBLE_PRE_26 = 130;

  /// from: static public final int IMPORTANCE_SERVICE
  /// Constant for \#importance: This process is contains services
  /// that should remain running.  These are background services apps have
  /// started, not something the user is aware of, so they may be killed by
  /// the system relatively freely (though it is generally desired that they
  /// stay running as long as they want to).
  static const IMPORTANCE_SERVICE = 300;

  /// from: static public final int IMPORTANCE_TOP_SLEEPING
  /// Constant for \#importance: This process is running the foreground
  /// UI, but the device is asleep so it is not visible to the user.  Though the
  /// system will try hard to keep its process from being killed, in all other
  /// ways we consider it a kind of cached process, with the limitations that go
  /// along with that state: network access, running background services, etc.
  static const IMPORTANCE_TOP_SLEEPING = 325;

  /// from: static public final int IMPORTANCE_TOP_SLEEPING_PRE_28
  /// @deprecated Pre-android.os.Build.VERSION_CODES\#P version of
  /// \#IMPORTANCE_TOP_SLEEPING.  As of Android
  /// android.os.Build.VERSION_CODES\#P, this is considered much less
  /// important since we want to reduce what apps can do when the screen is off.
  static const IMPORTANCE_TOP_SLEEPING_PRE_28 = 150;

  /// from: static public final int IMPORTANCE_VISIBLE
  /// Constant for \#importance: This process is running something
  /// that is actively visible to the user, though not in the immediate
  /// foreground.  This may be running a window that is behind the current
  /// foreground (so paused and with its state saved, not interacting with
  /// the user, but visible to them to some degree); it may also be running
  /// other services under the system's control that it inconsiders important.
  static const IMPORTANCE_VISIBLE = 200;

  /// from: static public final int REASON_PROVIDER_IN_USE
  /// Constant for \#importanceReasonCode: one of the application's
  /// content providers is being used by another process.  The pid of
  /// the client process is in \#importanceReasonPid and the
  /// target provider in this process is in
  /// \#importanceReasonComponent.
  static const REASON_PROVIDER_IN_USE = 1;

  /// from: static public final int REASON_SERVICE_IN_USE
  /// Constant for \#importanceReasonCode: one of the application's
  /// content providers is being used by another process.  The pid of
  /// the client process is in \#importanceReasonPid and the
  /// target provider in this process is in
  /// \#importanceReasonComponent.
  static const REASON_SERVICE_IN_USE = 2;

  /// from: static public final int REASON_UNKNOWN
  /// Constant for \#importanceReasonCode: nothing special has
  /// been specified for the reason for this level.
  static const REASON_UNKNOWN = 0;

  /// from: public int importance
  /// The relative importance level that the system places on this process.
  /// These constants are numbered so that "more important" values are
  /// always smaller than "less important" values.
  ///
  /// Value is android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_FOREGROUND, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_FOREGROUND_SERVICE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_TOP_SLEEPING, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_VISIBLE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_PERCEPTIBLE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_CANT_SAVE_STATE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_SERVICE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_CACHED, or android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_GONE
  static final _getimportance = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningAppProcessInfo_importance")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get importance => _getimportance(reference);
  static final _setimportance = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RunningAppProcessInfo_importance")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set importance(int value) => _setimportance(reference, value);

  /// from: public int importanceReasonCode
  /// The reason for \#importance, if any.
  static final _getimportanceReasonCode = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningAppProcessInfo_importanceReasonCode")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get importanceReasonCode => _getimportanceReasonCode(reference);
  static final _setimportanceReasonCode = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RunningAppProcessInfo_importanceReasonCode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set importanceReasonCode(int value) =>
      _setimportanceReasonCode(reference, value);

  /// from: public android.content.ComponentName importanceReasonComponent
  /// For the specified values of \#importanceReasonCode, this
  /// is the name of the component that is being used in this process.
  static final _getimportanceReasonComponent = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningAppProcessInfo_importanceReasonComponent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  content.ComponentName get importanceReasonComponent =>
      content.ComponentName.fromRef(_getimportanceReasonComponent(reference));
  static final _setimportanceReasonComponent = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__RunningAppProcessInfo_importanceReasonComponent")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set importanceReasonComponent(content.ComponentName value) =>
      _setimportanceReasonComponent(reference, value.reference);

  /// from: public int importanceReasonPid
  /// For the specified values of \#importanceReasonCode, this
  /// is the process ID of the other process that is a client of this
  /// process.  This will be 0 if no other process is using this one.
  static final _getimportanceReasonPid = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningAppProcessInfo_importanceReasonPid")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get importanceReasonPid => _getimportanceReasonPid(reference);
  static final _setimportanceReasonPid = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RunningAppProcessInfo_importanceReasonPid")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set importanceReasonPid(int value) =>
      _setimportanceReasonPid(reference, value);

  /// from: public int lastTrimLevel
  /// Last memory trim level reported to the process: corresponds to
  /// the values supplied to android.content.ComponentCallbacks2\#onTrimMemory(int) ComponentCallbacks2.onTrimMemory(int).
  static final _getlastTrimLevel = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningAppProcessInfo_lastTrimLevel")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get lastTrimLevel => _getlastTrimLevel(reference);
  static final _setlastTrimLevel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RunningAppProcessInfo_lastTrimLevel")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set lastTrimLevel(int value) => _setlastTrimLevel(reference, value);

  /// from: public int lru
  /// An additional ordering within a particular \#importance
  /// category, providing finer-grained information about the relative
  /// utility of processes within a category.  This number means nothing
  /// except that a smaller values are more recently used (and thus
  /// more important).  Currently an LRU value is only maintained for
  /// the \#IMPORTANCE_CACHED category, though others may
  /// be maintained in the future.
  static final _getlru = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningAppProcessInfo_lru")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get lru => _getlru(reference);
  static final _setlru = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RunningAppProcessInfo_lru")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set lru(int value) => _setlru(reference, value);

  /// from: public int pid
  /// The pid of this process; 0 if none
  static final _getpid = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningAppProcessInfo_pid")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get pid => _getpid(reference);
  static final _setpid = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RunningAppProcessInfo_pid")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set pid(int value) => _setpid(reference, value);

  /// from: public java.lang.String[] pkgList
  /// All packages that have been loaded into the process.
  static final _getpkgList = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningAppProcessInfo_pkgList")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get pkgList => jni.JlObject.fromRef(_getpkgList(reference));
  static final _setpkgList = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__RunningAppProcessInfo_pkgList")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set pkgList(jni.JlObject value) => _setpkgList(reference, value.reference);

  /// from: public java.lang.String processName
  /// The name of the process that this object is associated with
  static final _getprocessName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningAppProcessInfo_processName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get processName =>
      jni.JlString.fromRef(_getprocessName(reference));
  static final _setprocessName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__RunningAppProcessInfo_processName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set processName(jni.JlString value) =>
      _setprocessName(reference, value.reference);

  /// from: public int uid
  /// The user id of this process.
  static final _getuid = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RunningAppProcessInfo_uid")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get uid => _getuid(reference);
  static final _setuid = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RunningAppProcessInfo_uid")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set uid(int value) => _setuid(reference, value);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ActivityManager__RunningAppProcessInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ActivityManager_RunningAppProcessInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__RunningAppProcessInfo_new_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String pProcessName, int pPid, java.lang.String[] pArr)
  ActivityManager_RunningAppProcessInfo.ctor_1(
      jni.JlString pProcessName, int pPid, jni.JlObject pArr)
      : super.fromRef(_ctor_1(pProcessName.reference, pPid, pArr.reference));

  static final _describeContents = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__RunningAppProcessInfo_describeContents")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ActivityManager__RunningAppProcessInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _readFromParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__RunningAppProcessInfo_readFromParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(os.Parcel source) =>
      _readFromParcel(reference, source.reference);
}

/// Information you can retrieve about tasks that the user has most recently
/// started or visited.
class ActivityManager_RecentTaskInfo extends jni.JlObject {
  ActivityManager_RecentTaskInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.RecentTaskInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_ActivityManager__RecentTaskInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: public int affiliatedTaskId
  /// Task affiliation for grouping with other tasks.
  static final _getaffiliatedTaskId = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RecentTaskInfo_affiliatedTaskId")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get affiliatedTaskId => _getaffiliatedTaskId(reference);
  static final _setaffiliatedTaskId = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RecentTaskInfo_affiliatedTaskId")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set affiliatedTaskId(int value) => _setaffiliatedTaskId(reference, value);

  /// from: public android.content.ComponentName baseActivity
  /// The component launched as the first activity in the task.
  /// This can be considered the "application" of this task.
  static final _getbaseActivity = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RecentTaskInfo_baseActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  content.ComponentName get baseActivity =>
      content.ComponentName.fromRef(_getbaseActivity(reference));
  static final _setbaseActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__RecentTaskInfo_baseActivity")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set baseActivity(content.ComponentName value) =>
      _setbaseActivity(reference, value.reference);

  /// from: public android.content.Intent baseIntent
  /// The original Intent used to launch the task.  You can use this
  /// Intent to re-launch the task (if it is no longer running) or bring
  /// the current task to the front.
  static final _getbaseIntent = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RecentTaskInfo_baseIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  content.Intent get baseIntent =>
      content.Intent.fromRef(_getbaseIntent(reference));
  static final _setbaseIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__RecentTaskInfo_baseIntent")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set baseIntent(content.Intent value) =>
      _setbaseIntent(reference, value.reference);

  /// from: public java.lang.CharSequence description
  /// Description of the task's last state.
  static final _getdescription = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RecentTaskInfo_description")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get description =>
      jni.JlObject.fromRef(_getdescription(reference));
  static final _setdescription = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__RecentTaskInfo_description")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set description(jni.JlObject value) =>
      _setdescription(reference, value.reference);

  /// from: public int id
  /// If this task is currently running, this is the identifier for it.
  /// If it is not running, this will be -1.
  static final _getid = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RecentTaskInfo_id")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get id => _getid(reference);
  static final _setid = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RecentTaskInfo_id")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set id(int value) => _setid(reference, value);

  /// from: public int numActivities
  /// Number of activities in this task.
  static final _getnumActivities = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RecentTaskInfo_numActivities")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get numActivities => _getnumActivities(reference);
  static final _setnumActivities = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RecentTaskInfo_numActivities")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set numActivities(int value) => _setnumActivities(reference, value);

  /// from: public android.content.ComponentName origActivity
  /// If this task was started from an alias, this is the actual
  /// activity component that was initially started; the component of
  /// the baseIntent in this case is the name of the actual activity
  /// implementation that the alias referred to.  Otherwise, this is null.
  static final _getorigActivity = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RecentTaskInfo_origActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  content.ComponentName get origActivity =>
      content.ComponentName.fromRef(_getorigActivity(reference));
  static final _setorigActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__RecentTaskInfo_origActivity")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set origActivity(content.ComponentName value) =>
      _setorigActivity(reference, value.reference);

  /// from: public int persistentId
  /// The true identifier of this task, valid even if it is not running.
  static final _getpersistentId = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RecentTaskInfo_persistentId")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get persistentId => _getpersistentId(reference);
  static final _setpersistentId = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__RecentTaskInfo_persistentId")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set persistentId(int value) => _setpersistentId(reference, value);

  /// from: public android.app.ActivityManager.TaskDescription taskDescription
  /// The recent activity values for the highest activity in the stack to have set the values.
  /// Activity\#setTaskDescription(android.app.ActivityManager.TaskDescription).
  static final _gettaskDescription = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RecentTaskInfo_taskDescription")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  ActivityManager_TaskDescription get taskDescription =>
      ActivityManager_TaskDescription.fromRef(_gettaskDescription(reference));
  static final _settaskDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__RecentTaskInfo_taskDescription")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set taskDescription(ActivityManager_TaskDescription value) =>
      _settaskDescription(reference, value.reference);

  /// from: public android.content.ComponentName topActivity
  /// The activity component at the top of the history stack of the task.
  /// This is what the user is currently doing.
  static final _gettopActivity = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__RecentTaskInfo_topActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  content.ComponentName get topActivity =>
      content.ComponentName.fromRef(_gettopActivity(reference));
  static final _settopActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__RecentTaskInfo_topActivity")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set topActivity(content.ComponentName value) =>
      _settopActivity(reference, value.reference);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ActivityManager__RecentTaskInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ActivityManager_RecentTaskInfo() : super.fromRef(_ctor());

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityManager__RecentTaskInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ActivityManager__RecentTaskInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _readFromParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__RecentTaskInfo_readFromParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(os.Parcel source) =>
      _readFromParcel(reference, source.reference);
}

/// Information you can retrieve about any processes that are in an error condition.
class ActivityManager_ProcessErrorStateInfo extends jni.JlObject {
  ActivityManager_ProcessErrorStateInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final int CRASHED
  static const CRASHED = 1;

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.ProcessErrorStateInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_ActivityManager__ProcessErrorStateInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int NOT_RESPONDING
  static const NOT_RESPONDING = 2;

  /// from: static public final int NO_ERROR
  /// Condition codes
  static const NO_ERROR = 0;

  /// from: public int condition
  /// The condition that the process is in.
  static final _getcondition = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__ProcessErrorStateInfo_condition")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get condition => _getcondition(reference);
  static final _setcondition = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__ProcessErrorStateInfo_condition")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set condition(int value) => _setcondition(reference, value);

  /// from: public byte[] crashData
  /// to be deprecated: This value will always be null.
  static final _getcrashData = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__ProcessErrorStateInfo_crashData")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get crashData => jni.JlObject.fromRef(_getcrashData(reference));
  static final _setcrashData = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__ProcessErrorStateInfo_crashData")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set crashData(jni.JlObject value) =>
      _setcrashData(reference, value.reference);

  /// from: public java.lang.String longMsg
  /// A long message describing the error condition.
  static final _getlongMsg = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__ProcessErrorStateInfo_longMsg")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get longMsg => jni.JlString.fromRef(_getlongMsg(reference));
  static final _setlongMsg = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__ProcessErrorStateInfo_longMsg")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set longMsg(jni.JlString value) => _setlongMsg(reference, value.reference);

  /// from: public int pid
  /// The pid of this process; 0 if none
  static final _getpid = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__ProcessErrorStateInfo_pid")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get pid => _getpid(reference);
  static final _setpid = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__ProcessErrorStateInfo_pid")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set pid(int value) => _setpid(reference, value);

  /// from: public java.lang.String processName
  /// The process name in which the crash or error occurred.
  static final _getprocessName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__ProcessErrorStateInfo_processName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get processName =>
      jni.JlString.fromRef(_getprocessName(reference));
  static final _setprocessName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__ProcessErrorStateInfo_processName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set processName(jni.JlString value) =>
      _setprocessName(reference, value.reference);

  /// from: public java.lang.String shortMsg
  /// A short message describing the error condition.
  static final _getshortMsg = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__ProcessErrorStateInfo_shortMsg")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get shortMsg => jni.JlString.fromRef(_getshortMsg(reference));
  static final _setshortMsg = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__ProcessErrorStateInfo_shortMsg")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set shortMsg(jni.JlString value) => _setshortMsg(reference, value.reference);

  /// from: public java.lang.String stackTrace
  /// The stack trace where the error originated.  May be null.
  static final _getstackTrace = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__ProcessErrorStateInfo_stackTrace")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get stackTrace =>
      jni.JlString.fromRef(_getstackTrace(reference));
  static final _setstackTrace = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__ProcessErrorStateInfo_stackTrace")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set stackTrace(jni.JlString value) =>
      _setstackTrace(reference, value.reference);

  /// from: public java.lang.String tag
  /// The activity name associated with the error, if known.  May be null.
  static final _gettag = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__ProcessErrorStateInfo_tag")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get tag => jni.JlString.fromRef(_gettag(reference));
  static final _settag = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_app_ActivityManager__ProcessErrorStateInfo_tag")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set tag(jni.JlString value) => _settag(reference, value.reference);

  /// from: public int uid
  /// The kernel user-ID that has been assigned to this process;
  /// currently this is not a unique ID (multiple applications can have
  /// the same uid).
  static final _getuid = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__ProcessErrorStateInfo_uid")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get uid => _getuid(reference);
  static final _setuid = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_app_ActivityManager__ProcessErrorStateInfo_uid")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set uid(int value) => _setuid(reference, value);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ActivityManager__ProcessErrorStateInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ActivityManager_ProcessErrorStateInfo() : super.fromRef(_ctor());

  static final _describeContents = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__ProcessErrorStateInfo_describeContents")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ActivityManager__ProcessErrorStateInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _readFromParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__ProcessErrorStateInfo_readFromParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(os.Parcel source) =>
      _readFromParcel(reference, source.reference);
}

/// Information you can retrieve about the available memory through
/// ActivityManager\#getMemoryInfo.
class ActivityManager_MemoryInfo extends jni.JlObject {
  ActivityManager_MemoryInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.MemoryInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_ActivityManager__MemoryInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: public long availMem
  /// The available memory on the system.  This number should not
  /// be considered absolute: due to the nature of the kernel, a significant
  /// portion of this memory is actually in use and needed for the overall
  /// system to run well.
  static final _getavailMem = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__MemoryInfo_availMem")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get availMem => _getavailMem(reference);
  static final _setavailMem = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_app_ActivityManager__MemoryInfo_availMem")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set availMem(int value) => _setavailMem(reference, value);

  /// from: public boolean lowMemory
  /// Set to true if the system considers itself to currently be in a low
  /// memory situation.
  static final _getlowMemory = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__MemoryInfo_lowMemory")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  bool get lowMemory => _getlowMemory(reference) != 0;
  static final _setlowMemory = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_android_app_ActivityManager__MemoryInfo_lowMemory")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set lowMemory(bool value) => _setlowMemory(reference, value ? 1 : 0);

  /// from: public long threshold
  /// The threshold of \#availMem at which we consider memory to be
  /// low and start killing background services and other non-extraneous
  /// processes.
  static final _getthreshold = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__MemoryInfo_threshold")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get threshold => _getthreshold(reference);
  static final _setthreshold = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_app_ActivityManager__MemoryInfo_threshold")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set threshold(int value) => _setthreshold(reference, value);

  /// from: public long totalMem
  /// The total memory accessible by the kernel.  This is basically the
  /// RAM size of the device, not including below-kernel fixed allocations
  /// like DMA buffers, RAM for the baseband CPU, etc.
  static final _gettotalMem = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_app_ActivityManager__MemoryInfo_totalMem")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get totalMem => _gettotalMem(reference);
  static final _settotalMem = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_app_ActivityManager__MemoryInfo_totalMem")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set totalMem(int value) => _settotalMem(reference, value);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ActivityManager__MemoryInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ActivityManager_MemoryInfo() : super.fromRef(_ctor());

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityManager__MemoryInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_ActivityManager__MemoryInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _readFromParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__MemoryInfo_readFromParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(os.Parcel source) =>
      _readFromParcel(reference, source.reference);
}

/// The AppTask allows you to manage your own application's tasks.
/// See android.app.ActivityManager\#getAppTasks()
class ActivityManager_AppTask extends jni.JlObject {
  ActivityManager_AppTask.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_ActivityManager__AppTask_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  ActivityManager_AppTask() : super.fromRef(_ctor());

  static final _finishAndRemoveTask =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityManager__AppTask_finishAndRemoveTask")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void finishAndRemoveTask()
  /// Finishes all activities in this task and removes it from the recent tasks list.
  void finishAndRemoveTask() => _finishAndRemoveTask(reference);

  static final _getTaskInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__AppTask_getTaskInfo")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.ActivityManager.RecentTaskInfo getTaskInfo()
  /// Get the RecentTaskInfo associated with this task.
  ///@return The RecentTaskInfo for this task, or null if the task no longer exists.
  ActivityManager_RecentTaskInfo getTaskInfo() =>
      ActivityManager_RecentTaskInfo.fromRef(_getTaskInfo(reference));

  static final _moveToFront =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_ActivityManager__AppTask_moveToFront")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void moveToFront()
  /// Bring this task to the foreground.  If it contains activities, they will be
  /// brought to the foreground with it and their instances re-created if needed.
  /// If it doesn't contain activities, the root activity of the task will be
  /// re-launched.
  void moveToFront() => _moveToFront(reference);

  static final _startActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_ActivityManager__AppTask_startActivity")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivity(android.content.Context context, android.content.Intent intent, android.os.Bundle options)
  /// Start an activity in this task.  Brings the task to the foreground.  If this task
  /// is not currently active (that is, its id < 0), then a new activity for the given
  /// Intent will be launched as the root of the task and the task brought to the
  /// foreground.  Otherwise, if this task is currently active and the Intent does not specify
  /// an activity to launch in a new task, then a new activity for the given Intent will
  /// be launched on top of the task and the task brought to the foreground.  If this
  /// task is currently active and the Intent specifies Intent\#FLAG_ACTIVITY_NEW_TASK
  /// or would otherwise be launched in to a new task, then the activity not launched but
  /// this task be brought to the foreground and a new intent delivered to the top
  /// activity if appropriate.
  ///
  /// In other words, you generally want to use an Intent here that does not specify
  /// Intent\#FLAG_ACTIVITY_NEW_TASK or Intent\#FLAG_ACTIVITY_NEW_DOCUMENT,
  /// and let the system do the right thing.
  ///
  ///@param intent The Intent describing the new activity to be launched on the task.
  ///@param options Optional launch options.
  ///@see Activity\#startActivity(android.content.Intent, android.os.Bundle)
  void startActivity(
          content.Context context, content.Intent intent, os.Bundle options) =>
      _startActivity(
          reference, context.reference, intent.reference, options.reference);

  static final _setExcludeFromRecents = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_ActivityManager__AppTask_setExcludeFromRecents")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setExcludeFromRecents(boolean exclude)
  /// Modify the Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS flag in the root
  /// Intent of this AppTask.
  ///@param exclude If true, Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS will
  /// be set; otherwise, it will be cleared.
  void setExcludeFromRecents(bool exclude) =>
      _setExcludeFromRecents(reference, exclude ? 1 : 0);
}

/// A description of an Intent and target action to perform with it.  Instances
/// of this class are created with \#getActivity, \#getActivities,
/// \#getBroadcast, and \#getService; the returned object can be
/// handed to other applications so that they can perform the action you
/// described on your behalf at a later time.
///
/// By giving a PendingIntent to another application,
/// you are granting it the right to perform the operation you have specified
/// as if the other application was yourself (with the same permissions and
/// identity).  As such, you should be careful about how you build the PendingIntent:
/// almost always, for example, the base Intent you supply should have the component
/// name explicitly set to one of your own components, to ensure it is ultimately
/// sent there and nowhere else.
///
/// A PendingIntent itself is simply a reference to a token maintained by
/// the system describing the original data used to retrieve it.  This means
/// that, even if its owning application's process is killed, the
/// PendingIntent itself will remain usable from other processes that
/// have been given it.  If the creating application later re-retrieves the
/// same kind of PendingIntent (same operation, same Intent action, data,
/// categories, and components, and same flags), it will receive a PendingIntent
/// representing the same token if that is still valid, and can thus call
/// \#cancel to remove it.
///
/// Because of this behavior, it is important to know when two Intents
/// are considered to be the same for purposes of retrieving a PendingIntent.
/// A common mistake people make is to create multiple PendingIntent objects
/// with Intents that only vary in their "extra" contents, expecting to get
/// a different PendingIntent each time.  This does _not_ happen.  The
/// parts of the Intent that are used for matching are the same ones defined
/// by Intent\#filterEquals(Intent) Intent.filterEquals.  If you use two
/// Intent objects that are equivalent as per
/// Intent\#filterEquals(Intent) Intent.filterEquals, then you will get
/// the same PendingIntent for both of them.
///
/// There are two typical ways to deal with this.
///
/// If you truly need multiple distinct PendingIntent objects active at
/// the same time (such as to use as two notifications that are both shown
/// at the same time), then you will need to ensure there is something that
/// is different about them to associate them with different PendingIntents.
/// This may be any of the Intent attributes considered by
/// Intent\#filterEquals(Intent) Intent.filterEquals, or different
/// request code integers supplied to \#getActivity, \#getActivities,
/// \#getBroadcast, or \#getService.
///
/// If you only need one PendingIntent active at a time for any of the
/// Intents you will use, then you can alternatively use the flags
/// \#FLAG_CANCEL_CURRENT or \#FLAG_UPDATE_CURRENT to either
/// cancel or modify whatever current PendingIntent is associated with the
/// Intent you are supplying.
class PendingIntent extends jni.JlObject {
  PendingIntent.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.PendingIntent> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_PendingIntent_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int FLAG_CANCEL_CURRENT
  /// Flag indicating that if the described PendingIntent already exists,
  /// the current one should be canceled before generating a new one.
  /// For use with \#getActivity, \#getBroadcast, and
  /// \#getService. You can use
  /// this to retrieve a new PendingIntent when you are only changing the
  /// extra data in the Intent; by canceling the previous pending intent,
  /// this ensures that only entities given the new data will be able to
  /// launch it.  If this assurance is not an issue, consider
  /// \#FLAG_UPDATE_CURRENT.
  static const FLAG_CANCEL_CURRENT = 268435456;

  /// from: static public final int FLAG_IMMUTABLE
  /// Flag indicating that the created PendingIntent should be immutable.
  /// This means that the additional intent argument passed to the send
  /// methods to fill in unpopulated properties of this intent will be
  /// ignored.
  static const FLAG_IMMUTABLE = 67108864;

  /// from: static public final int FLAG_NO_CREATE
  /// Flag indicating that if the described PendingIntent does not
  /// already exist, then simply return null instead of creating it.
  /// For use with \#getActivity, \#getBroadcast, and
  /// \#getService.
  static const FLAG_NO_CREATE = 536870912;

  /// from: static public final int FLAG_ONE_SHOT
  /// Flag indicating that this PendingIntent can be used only once.
  /// For use with \#getActivity, \#getBroadcast, and
  /// \#getService. If set, after
  /// \#send() is called on it, it will be automatically
  /// canceled for you and any future attempt to send through it will fail.
  static const FLAG_ONE_SHOT = 1073741824;

  /// from: static public final int FLAG_UPDATE_CURRENT
  /// Flag indicating that if the described PendingIntent already exists,
  /// then keep it but replace its extra data with what is in this new
  /// Intent. For use with \#getActivity, \#getBroadcast, and
  /// \#getService. This can be used if you are creating intents where only the
  /// extras change, and don't care that any entities that received your
  /// previous PendingIntent will be able to launch it with your new
  /// extras even if they are not explicitly given to it.
  static const FLAG_UPDATE_CURRENT = 134217728;

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_PendingIntent_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.IBinder target, java.lang.Object cookie)
  PendingIntent(os.IBinder target, jni.JlObject cookie)
      : super.fromRef(_ctor(target.reference, cookie.reference));

  static final _getActivity = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_PendingIntent_getActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.app.PendingIntent getActivity(android.content.Context context, int requestCode, android.content.Intent intent, int flags)
  /// Retrieve a PendingIntent that will start a new activity, like calling
  /// Context\#startActivity(Intent) Context.startActivity(Intent).
  /// Note that the activity will be started outside of the context of an
  /// existing activity, so you must use the Intent\#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK launch flag in the Intent.
  ///
  /// <p class="note">For security reasons, the android.content.Intent
  /// you supply here should almost always be an _explicit intent_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should start
  /// the activity.
  ///@param requestCode Private request code for the sender
  ///@param intent Intent of the activity to be launched.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getActivity(content.Context context, int requestCode,
          content.Intent intent, int flags) =>
      PendingIntent.fromRef(_getActivity(
          context.reference, requestCode, intent.reference, flags));

  static final _getActivity_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_PendingIntent_getActivity_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.PendingIntent getActivity(android.content.Context context, int requestCode, android.content.Intent intent, int flags, android.os.Bundle options)
  /// Retrieve a PendingIntent that will start a new activity, like calling
  /// Context\#startActivity(Intent) Context.startActivity(Intent).
  /// Note that the activity will be started outside of the context of an
  /// existing activity, so you must use the Intent\#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK launch flag in the Intent.
  ///
  /// <p class="note">For security reasons, the android.content.Intent
  /// you supply here should almost always be an _explicit intent_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should start
  /// the activity.
  ///@param requestCode Private request code for the sender
  ///@param intent Intent of the activity to be launched.
  /// This value must never be {@code null}.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@param options Additional options for how the Activity should be started.
  /// May be null if there are no options.
  ///
  /// This value may be {@code null}.
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getActivity_1(content.Context context, int requestCode,
          content.Intent intent, int flags, os.Bundle options) =>
      PendingIntent.fromRef(_getActivity_1(context.reference, requestCode,
          intent.reference, flags, options.reference));

  static final _getActivities = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_PendingIntent_getActivities")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.app.PendingIntent getActivities(android.content.Context context, int requestCode, android.content.Intent[] intents, int flags)
  /// Like \#getActivity(Context, int, Intent, int), but allows an
  /// array of Intents to be supplied.  The last Intent in the array is
  /// taken as the primary key for the PendingIntent, like the single Intent
  /// given to \#getActivity(Context, int, Intent, int).  Upon sending
  /// the resulting PendingIntent, all of the Intents are started in the same
  /// way as they would be by passing them to Context\#startActivities(Intent[]).
  ///
  /// <p class="note">
  /// The _first_ intent in the array will be started outside of the context of an
  /// existing activity, so you must use the Intent\#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK launch flag in the Intent.  (Activities after
  /// the first in the array are started in the context of the previous activity
  /// in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
  ///
  ///
  ///
  /// <p class="note">
  /// The _last_ intent in the array represents the key for the
  /// PendingIntent.  In other words, it is the significant element for matching
  /// (as done with the single intent given to \#getActivity(Context, int, Intent, int),
  /// its content will be the subject of replacement by
  /// \#send(Context, int, Intent) and \#FLAG_UPDATE_CURRENT, etc.
  /// This is because it is the most specific of the supplied intents, and the
  /// UI the user actually sees when the intents are started.
  ///
  ///
  ///
  /// <p class="note">For security reasons, the android.content.Intent objects
  /// you supply here should almost always be _explicit intents_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should start
  /// the activity.
  ///@param requestCode Private request code for the sender
  ///@param intents Array of Intents of the activities to be launched.
  /// This value must never be {@code null}.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getActivities(content.Context context, int requestCode,
          jni.JlObject intents, int flags) =>
      PendingIntent.fromRef(_getActivities(
          context.reference, requestCode, intents.reference, flags));

  static final _getActivities_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_PendingIntent_getActivities_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.PendingIntent getActivities(android.content.Context context, int requestCode, android.content.Intent[] intents, int flags, android.os.Bundle options)
  /// Like \#getActivity(Context, int, Intent, int), but allows an
  /// array of Intents to be supplied.  The last Intent in the array is
  /// taken as the primary key for the PendingIntent, like the single Intent
  /// given to \#getActivity(Context, int, Intent, int).  Upon sending
  /// the resulting PendingIntent, all of the Intents are started in the same
  /// way as they would be by passing them to Context\#startActivities(Intent[]).
  ///
  /// <p class="note">
  /// The _first_ intent in the array will be started outside of the context of an
  /// existing activity, so you must use the Intent\#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK launch flag in the Intent.  (Activities after
  /// the first in the array are started in the context of the previous activity
  /// in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
  ///
  ///
  ///
  /// <p class="note">
  /// The _last_ intent in the array represents the key for the
  /// PendingIntent.  In other words, it is the significant element for matching
  /// (as done with the single intent given to \#getActivity(Context, int, Intent, int),
  /// its content will be the subject of replacement by
  /// \#send(Context, int, Intent) and \#FLAG_UPDATE_CURRENT, etc.
  /// This is because it is the most specific of the supplied intents, and the
  /// UI the user actually sees when the intents are started.
  ///
  ///
  ///
  /// <p class="note">For security reasons, the android.content.Intent objects
  /// you supply here should almost always be _explicit intents_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should start
  /// the activity.
  ///@param requestCode Private request code for the sender
  ///@param intents Array of Intents of the activities to be launched.
  /// This value must never be {@code null}.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// \#FLAG_IMMUTABLE or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@param options This value may be {@code null}.
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getActivities_1(content.Context context, int requestCode,
          jni.JlObject intents, int flags, os.Bundle options) =>
      PendingIntent.fromRef(_getActivities_1(context.reference, requestCode,
          intents.reference, flags, options.reference));

  static final _getBroadcast = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_PendingIntent_getBroadcast")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.app.PendingIntent getBroadcast(android.content.Context context, int requestCode, android.content.Intent intent, int flags)
  /// Retrieve a PendingIntent that will perform a broadcast, like calling
  /// Context\#sendBroadcast(Intent) Context.sendBroadcast().
  ///
  /// <p class="note">For security reasons, the android.content.Intent
  /// you supply here should almost always be an _explicit intent_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should perform
  /// the broadcast.
  ///@param requestCode Private request code for the sender
  ///@param intent The Intent to be broadcast.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// \#FLAG_IMMUTABLE or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getBroadcast(content.Context context, int requestCode,
          content.Intent intent, int flags) =>
      PendingIntent.fromRef(_getBroadcast(
          context.reference, requestCode, intent.reference, flags));

  static final _getService = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_PendingIntent_getService")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.app.PendingIntent getService(android.content.Context context, int requestCode, android.content.Intent intent, int flags)
  /// Retrieve a PendingIntent that will start a service, like calling
  /// Context\#startService Context.startService().  The start
  /// arguments given to the service will come from the extras of the Intent.
  ///
  /// <p class="note">For security reasons, the android.content.Intent
  /// you supply here should almost always be an _explicit intent_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should start
  /// the service.
  ///@param requestCode Private request code for the sender
  ///@param intent An Intent describing the service to be started.
  /// This value must never be {@code null}.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// \#FLAG_IMMUTABLE or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getService(content.Context context, int requestCode,
          content.Intent intent, int flags) =>
      PendingIntent.fromRef(
          _getService(context.reference, requestCode, intent.reference, flags));

  static final _getForegroundService = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_PendingIntent_getForegroundService")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.app.PendingIntent getForegroundService(android.content.Context context, int requestCode, android.content.Intent intent, int flags)
  /// Retrieve a PendingIntent that will start a foreground service, like calling
  /// Context\#startForegroundService Context.startForegroundService().  The start
  /// arguments given to the service will come from the extras of the Intent.
  ///
  /// <p class="note">For security reasons, the android.content.Intent
  /// you supply here should almost always be an _explicit intent_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should start
  /// the service.
  ///@param requestCode Private request code for the sender
  ///@param intent An Intent describing the service to be started.
  /// This value must never be {@code null}.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// \#FLAG_IMMUTABLE or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getForegroundService(content.Context context,
          int requestCode, content.Intent intent, int flags) =>
      PendingIntent.fromRef(_getForegroundService(
          context.reference, requestCode, intent.reference, flags));

  static final _getIntentSender = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_PendingIntent_getIntentSender")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.IntentSender getIntentSender()
  /// Retrieve a IntentSender object that wraps the existing sender of the PendingIntent
  ///@return Returns a IntentSender object that wraps the sender of PendingIntent
  content.IntentSender getIntentSender() =>
      content.IntentSender.fromRef(_getIntentSender(reference));

  static final _cancel =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_PendingIntent_cancel")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void cancel()
  /// Cancel a currently active PendingIntent.  Only the original application
  /// owning a PendingIntent can cancel it.
  void cancel() => _cancel(reference);

  static final _send =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_PendingIntent_send")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void send()
  /// Perform the operation associated with this PendingIntent.
  ///@see \#send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send() => _send(reference);

  static final _send_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_PendingIntent_send_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void send(int code)
  /// Perform the operation associated with this PendingIntent.
  ///@param code Result code to supply back to the PendingIntent's target.
  ///@see \#send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send_1(int code) => _send_1(reference, code);

  static final _send_2 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_app_PendingIntent_send_2")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void send(android.content.Context context, int code, android.content.Intent intent)
  /// Perform the operation associated with this PendingIntent, allowing the
  /// caller to specify information about the Intent to use.
  ///@param context The Context of the caller.
  ///@param code Result code to supply back to the PendingIntent's target.
  ///@param intent Additional Intent data.  See Intent\#fillIn Intent.fillIn() for information on how this is applied to the
  /// original Intent. If flag \#FLAG_IMMUTABLE was set when this
  /// pending intent was created, this argument will be ignored.
  ///
  /// This value may be {@code null}.
  ///@see \#send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send_2(content.Context context, int code, content.Intent intent) =>
      _send_2(reference, context.reference, code, intent.reference);

  static final _send_3 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_PendingIntent_send_3")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void send(int code, android.app.PendingIntent.OnFinished onFinished, android.os.Handler handler)
  /// Perform the operation associated with this PendingIntent, allowing the
  /// caller to be notified when the send has completed.
  ///@param code Result code to supply back to the PendingIntent's target.
  ///@param onFinished The object to call back on when the send has
  /// completed, or null for no callback.
  /// This value may be {@code null}.
  ///@param handler Handler identifying the thread on which the callback
  /// should happen.  If null, the callback will happen from the thread
  /// pool of the process.
  ///
  /// This value may be {@code null}.
  ///@see \#send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send_3(
          int code, PendingIntent_OnFinished onFinished, os.Handler handler) =>
      _send_3(reference, code, onFinished.reference, handler.reference);

  static final _send_4 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_PendingIntent_send_4")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void send(android.content.Context context, int code, android.content.Intent intent, android.app.PendingIntent.OnFinished onFinished, android.os.Handler handler)
  /// Perform the operation associated with this PendingIntent, allowing the
  /// caller to specify information about the Intent to use and be notified
  /// when the send has completed.
  ///
  /// For the intent parameter, a PendingIntent
  /// often has restrictions on which fields can be supplied here, based on
  /// how the PendingIntent was retrieved in \#getActivity,
  /// \#getBroadcast, or \#getService.
  ///@param context The Context of the caller.  This may be null if
  /// <var>intent</var> is also null.
  ///@param code Result code to supply back to the PendingIntent's target.
  ///@param intent Additional Intent data.  See Intent\#fillIn Intent.fillIn() for information on how this is applied to the
  /// original Intent.  Use null to not modify the original Intent.
  /// If flag \#FLAG_IMMUTABLE was set when this pending intent was
  /// created, this argument will be ignored.
  /// This value may be {@code null}.
  ///@param onFinished The object to call back on when the send has
  /// completed, or null for no callback.
  /// This value may be {@code null}.
  ///@param handler Handler identifying the thread on which the callback
  /// should happen.  If null, the callback will happen from the thread
  /// pool of the process.
  ///
  /// This value may be {@code null}.
  ///@see \#send()
  ///@see \#send(int)
  ///@see \#send(Context, int, Intent)
  ///@see \#send(int, android.app.PendingIntent.OnFinished, Handler)
  ///@see \#send(Context, int, Intent, OnFinished, Handler, String)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send_4(content.Context context, int code, content.Intent intent,
          PendingIntent_OnFinished onFinished, os.Handler handler) =>
      _send_4(reference, context.reference, code, intent.reference,
          onFinished.reference, handler.reference);

  static final _send_5 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_PendingIntent_send_5")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void send(android.content.Context context, int code, android.content.Intent intent, android.app.PendingIntent.OnFinished onFinished, android.os.Handler handler, java.lang.String requiredPermission)
  /// Perform the operation associated with this PendingIntent, allowing the
  /// caller to specify information about the Intent to use and be notified
  /// when the send has completed.
  ///
  /// For the intent parameter, a PendingIntent
  /// often has restrictions on which fields can be supplied here, based on
  /// how the PendingIntent was retrieved in \#getActivity,
  /// \#getBroadcast, or \#getService.
  ///@param context The Context of the caller.  This may be null if
  /// <var>intent</var> is also null.
  ///@param code Result code to supply back to the PendingIntent's target.
  ///@param intent Additional Intent data.  See Intent\#fillIn Intent.fillIn() for information on how this is applied to the
  /// original Intent.  Use null to not modify the original Intent.
  /// If flag \#FLAG_IMMUTABLE was set when this pending intent was
  /// created, this argument will be ignored.
  /// This value may be {@code null}.
  ///@param onFinished The object to call back on when the send has
  /// completed, or null for no callback.
  /// This value may be {@code null}.
  ///@param handler Handler identifying the thread on which the callback
  /// should happen.  If null, the callback will happen from the thread
  /// pool of the process.
  /// This value may be {@code null}.
  ///@param requiredPermission Name of permission that a recipient of the PendingIntent
  /// is required to hold.  This is only valid for broadcast intents, and
  /// corresponds to the permission argument in
  /// Context\#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String).
  /// If null, no permission is required.
  ///
  /// This value may be {@code null}.
  ///@see \#send()
  ///@see \#send(int)
  ///@see \#send(Context, int, Intent)
  ///@see \#send(int, android.app.PendingIntent.OnFinished, Handler)
  ///@see \#send(Context, int, Intent, OnFinished, Handler)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send_5(
          content.Context context,
          int code,
          content.Intent intent,
          PendingIntent_OnFinished onFinished,
          os.Handler handler,
          jni.JlString requiredPermission) =>
      _send_5(
          reference,
          context.reference,
          code,
          intent.reference,
          onFinished.reference,
          handler.reference,
          requiredPermission.reference);

  static final _send_6 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_PendingIntent_send_6")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void send(android.content.Context context, int code, android.content.Intent intent, android.app.PendingIntent.OnFinished onFinished, android.os.Handler handler, java.lang.String requiredPermission, android.os.Bundle options)
  /// Perform the operation associated with this PendingIntent, allowing the
  /// caller to specify information about the Intent to use and be notified
  /// when the send has completed.
  ///
  /// For the intent parameter, a PendingIntent
  /// often has restrictions on which fields can be supplied here, based on
  /// how the PendingIntent was retrieved in \#getActivity,
  /// \#getBroadcast, or \#getService.
  ///@param context The Context of the caller.  This may be null if
  /// <var>intent</var> is also null.
  ///@param code Result code to supply back to the PendingIntent's target.
  ///@param intent Additional Intent data.  See Intent\#fillIn Intent.fillIn() for information on how this is applied to the
  /// original Intent.  Use null to not modify the original Intent.
  /// If flag \#FLAG_IMMUTABLE was set when this pending intent was
  /// created, this argument will be ignored.
  /// This value may be {@code null}.
  ///@param onFinished The object to call back on when the send has
  /// completed, or null for no callback.
  /// This value may be {@code null}.
  ///@param handler Handler identifying the thread on which the callback
  /// should happen.  If null, the callback will happen from the thread
  /// pool of the process.
  /// This value may be {@code null}.
  ///@param requiredPermission Name of permission that a recipient of the PendingIntent
  /// is required to hold.  This is only valid for broadcast intents, and
  /// corresponds to the permission argument in
  /// Context\#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String).
  /// If null, no permission is required.
  /// This value may be {@code null}.
  ///@param options Additional options the caller would like to provide to modify the sending
  /// behavior.  May be built from an ActivityOptions to apply to an activity start.
  ///
  /// This value may be {@code null}.
  ///@see \#send()
  ///@see \#send(int)
  ///@see \#send(Context, int, Intent)
  ///@see \#send(int, android.app.PendingIntent.OnFinished, Handler)
  ///@see \#send(Context, int, Intent, OnFinished, Handler)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send_6(
          content.Context context,
          int code,
          content.Intent intent,
          PendingIntent_OnFinished onFinished,
          os.Handler handler,
          jni.JlString requiredPermission,
          os.Bundle options) =>
      _send_6(
          reference,
          context.reference,
          code,
          intent.reference,
          onFinished.reference,
          handler.reference,
          requiredPermission.reference,
          options.reference);

  static final _getTargetPackage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_PendingIntent_getTargetPackage")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getTargetPackage()
  /// @deprecated Renamed to \#getCreatorPackage().
  jni.JlString getTargetPackage() =>
      jni.JlString.fromRef(_getTargetPackage(reference));

  static final _getCreatorPackage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_PendingIntent_getCreatorPackage")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getCreatorPackage()
  /// Return the package name of the application that created this
  /// PendingIntent, that is the identity under which you will actually be
  /// sending the Intent.  The returned string is supplied by the system, so
  /// that an application can not spoof its package.
  ///
  /// <p class="note">Be careful about how you use this.  All this tells you is
  /// who created the PendingIntent.  It does <strong>not</strong> tell you who
  /// handed the PendingIntent to you: that is, PendingIntent objects are intended to be
  /// passed between applications, so the PendingIntent you receive from an application
  /// could actually be one it received from another application, meaning the result
  /// you get here will identify the original application.  Because of this, you should
  /// only use this information to identify who you expect to be interacting with
  /// through a \#send call, not who gave you the PendingIntent.
  ///
  ///@return The package name of the PendingIntent, or null if there is
  /// none associated with it.
  jni.JlString getCreatorPackage() =>
      jni.JlString.fromRef(_getCreatorPackage(reference));

  static final _getCreatorUid =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_PendingIntent_getCreatorUid")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getCreatorUid()
  /// Return the uid of the application that created this
  /// PendingIntent, that is the identity under which you will actually be
  /// sending the Intent.  The returned integer is supplied by the system, so
  /// that an application can not spoof its uid.
  ///
  /// <p class="note">Be careful about how you use this.  All this tells you is
  /// who created the PendingIntent.  It does <strong>not</strong> tell you who
  /// handed the PendingIntent to you: that is, PendingIntent objects are intended to be
  /// passed between applications, so the PendingIntent you receive from an application
  /// could actually be one it received from another application, meaning the result
  /// you get here will identify the original application.  Because of this, you should
  /// only use this information to identify who you expect to be interacting with
  /// through a \#send call, not who gave you the PendingIntent.
  ///
  ///@return The uid of the PendingIntent, or -1 if there is
  /// none associated with it.
  int getCreatorUid() => _getCreatorUid(reference);

  static final _getCreatorUserHandle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_PendingIntent_getCreatorUserHandle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.UserHandle getCreatorUserHandle()
  /// Return the user handle of the application that created this
  /// PendingIntent, that is the user under which you will actually be
  /// sending the Intent.  The returned UserHandle is supplied by the system, so
  /// that an application can not spoof its user.  See
  /// android.os.Process\#myUserHandle() Process.myUserHandle() for
  /// more explanation of user handles.
  ///
  /// <p class="note">Be careful about how you use this.  All this tells you is
  /// who created the PendingIntent.  It does <strong>not</strong> tell you who
  /// handed the PendingIntent to you: that is, PendingIntent objects are intended to be
  /// passed between applications, so the PendingIntent you receive from an application
  /// could actually be one it received from another application, meaning the result
  /// you get here will identify the original application.  Because of this, you should
  /// only use this information to identify who you expect to be interacting with
  /// through a \#send call, not who gave you the PendingIntent.
  ///
  ///@return The user handle of the PendingIntent, or null if there is
  /// none associated with it.
  os.UserHandle getCreatorUserHandle() =>
      os.UserHandle.fromRef(_getCreatorUserHandle(reference));

  static final _equals_1 = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_PendingIntent_equals_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object otherObj)
  /// Comparison operator on two PendingIntent objects, such that true
  /// is returned then they both represent the same operation from the
  /// same package.  This allows you to use \#getActivity,
  /// \#getBroadcast, or \#getService multiple times (even
  /// across a process being killed), resulting in different PendingIntent
  /// objects but whose equals() method identifies them as being the same
  /// operation.
  bool equals_1(jni.JlObject otherObj) =>
      _equals_1(reference, otherObj.reference) != 0;

  static final _hashCode_1 =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_PendingIntent_hashCode_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode_1() => _hashCode_1(reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_PendingIntent_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_PendingIntent_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_PendingIntent_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os.Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags);

  static final _writePendingIntentOrNullToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_PendingIntent_writePendingIntentOrNullToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void writePendingIntentOrNullToParcel(android.app.PendingIntent sender, android.os.Parcel out)
  /// Convenience function for writing either a PendingIntent or null pointer to
  /// a Parcel.  You must use this with \#readPendingIntentOrNullFromParcel
  /// for later reading it.
  ///@param sender The PendingIntent to write, or null.
  /// This value may be {@code null}.
  ///@param out Where to write the PendingIntent.
  ///
  /// This value must never be {@code null}.
  static void writePendingIntentOrNullToParcel(
          PendingIntent sender, os.Parcel out) =>
      _writePendingIntentOrNullToParcel(sender.reference, out.reference);

  static final _readPendingIntentOrNullFromParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_PendingIntent_readPendingIntentOrNullFromParcel")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.PendingIntent readPendingIntentOrNullFromParcel(android.os.Parcel in)
  /// Convenience function for reading either a PendingIntent or null pointer from
  /// a Parcel.  You must have previously written the PendingIntent with
  /// \#writePendingIntentOrNullToParcel.
  ///@param in The Parcel containing the written PendingIntent.
  ///
  /// This value must never be {@code null}.
  ///@return Returns the PendingIntent read from the Parcel, or null if null had
  /// been written.
  static PendingIntent readPendingIntentOrNullFromParcel(os.Parcel in_) =>
      PendingIntent.fromRef(_readPendingIntentOrNullFromParcel(in_.reference));
}

/// Callback interface for discovering when a send operation has
/// completed.  Primarily for use with a PendingIntent that is
/// performing a broadcast, this provides the same information as
/// calling Context\#sendOrderedBroadcast(Intent, String,
/// android.content.BroadcastReceiver, Handler, int, String, Bundle) Context.sendBroadcast() with a final BroadcastReceiver.
class PendingIntent_OnFinished extends jni.JlObject {
  PendingIntent_OnFinished.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onSendFinished = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_app_PendingIntent__OnFinished_onSendFinished")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onSendFinished(android.app.PendingIntent pendingIntent, android.content.Intent intent, int resultCode, java.lang.String resultData, android.os.Bundle resultExtras)
  /// Called when a send operation as completed.
  ///@param pendingIntent The PendingIntent this operation was sent through.
  ///@param intent The original Intent that was sent.
  ///@param resultCode The final result code determined by the send.
  ///@param resultData The final data collected by a broadcast.
  ///@param resultExtras The final extras collected by a broadcast.
  void onSendFinished(PendingIntent pendingIntent, content.Intent intent,
          int resultCode, jni.JlString resultData, os.Bundle resultExtras) =>
      _onSendFinished(reference, pendingIntent.reference, intent.reference,
          resultCode, resultData.reference, resultExtras.reference);
}

/// Exception thrown when trying to send through a PendingIntent that
/// has been canceled or is otherwise no longer able to execute the request.
class PendingIntent_CanceledException extends jni.JlObject {
  PendingIntent_CanceledException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_PendingIntent__CanceledException_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  PendingIntent_CanceledException() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_PendingIntent__CanceledException_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String name)
  PendingIntent_CanceledException.ctor_1(jni.JlString name)
      : super.fromRef(_ctor_1(name.reference));

  static final _ctor_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_PendingIntent__CanceledException_new_2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.Exception cause)
  PendingIntent_CanceledException.ctor_2(jni.JlObject cause)
      : super.fromRef(_ctor_2(cause.reference));
}

/// This class is used to specify meta information of a wallpaper service.
class WallpaperInfo extends jni.JlObject {
  WallpaperInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.app.WallpaperInfo> CREATOR
  /// Used to make this class parcelable.
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_WallpaperInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_WallpaperInfo_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context, android.content.pm.ResolveInfo service)
  /// Constructor.
  ///@param context The Context in which we are parsing the wallpaper.
  ///@param service The ResolveInfo returned from the package manager about
  /// this wallpaper's component.
  WallpaperInfo(content.Context context, pm.ResolveInfo service)
      : super.fromRef(_ctor(context.reference, service.reference));

  static final _getPackageName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperInfo_getPackageName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPackageName()
  /// Return the .apk package that implements this wallpaper.
  jni.JlString getPackageName() =>
      jni.JlString.fromRef(_getPackageName(reference));

  static final _getServiceName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperInfo_getServiceName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getServiceName()
  /// Return the class name of the service component that implements
  /// this wallpaper.
  jni.JlString getServiceName() =>
      jni.JlString.fromRef(_getServiceName(reference));

  static final _getServiceInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperInfo_getServiceInfo")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ServiceInfo getServiceInfo()
  /// Return the raw information about the Service implementing this
  /// wallpaper.  Do not modify the returned object.
  pm.ServiceInfo getServiceInfo() =>
      pm.ServiceInfo.fromRef(_getServiceInfo(reference));

  static final _getComponent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperInfo_getComponent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getComponent()
  /// Return the component of the service that implements this wallpaper.
  content.ComponentName getComponent() =>
      content.ComponentName.fromRef(_getComponent(reference));

  static final _loadLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperInfo_loadLabel")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence loadLabel(android.content.pm.PackageManager pm)
  /// Load the user-displayed label for this wallpaper.
  ///@param pm Supply a PackageManager used to load the wallpaper's
  /// resources.
  jni.JlObject loadLabel(pm.PackageManager pm_) =>
      jni.JlObject.fromRef(_loadLabel(reference, pm_.reference));

  static final _loadIcon = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_WallpaperInfo_loadIcon")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable loadIcon(android.content.pm.PackageManager pm)
  /// Load the user-displayed icon for this wallpaper.
  ///@param pm Supply a PackageManager used to load the wallpaper's
  /// resources.
  jni.JlObject loadIcon(pm.PackageManager pm_) =>
      jni.JlObject.fromRef(_loadIcon(reference, pm_.reference));

  static final _loadThumbnail = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperInfo_loadThumbnail")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable loadThumbnail(android.content.pm.PackageManager pm)
  /// Load the thumbnail image for this wallpaper.
  ///@param pm Supply a PackageManager used to load the wallpaper's
  /// resources.
  jni.JlObject loadThumbnail(pm.PackageManager pm_) =>
      jni.JlObject.fromRef(_loadThumbnail(reference, pm_.reference));

  static final _loadAuthor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperInfo_loadAuthor")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence loadAuthor(android.content.pm.PackageManager pm)
  /// Return a string indicating the author(s) of this wallpaper.
  jni.JlObject loadAuthor(pm.PackageManager pm_) =>
      jni.JlObject.fromRef(_loadAuthor(reference, pm_.reference));

  static final _loadDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperInfo_loadDescription")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence loadDescription(android.content.pm.PackageManager pm)
  /// Return a brief summary of this wallpaper's behavior.
  jni.JlObject loadDescription(pm.PackageManager pm_) =>
      jni.JlObject.fromRef(_loadDescription(reference, pm_.reference));

  static final _loadContextUri = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperInfo_loadContextUri")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri loadContextUri(android.content.pm.PackageManager pm)
  /// Returns an URI that specifies a link for further context about this wallpaper.
  ///@param pm An instance of PackageManager to retrieve the URI.
  ///@return The URI.
  jni.JlObject loadContextUri(pm.PackageManager pm_) =>
      jni.JlObject.fromRef(_loadContextUri(reference, pm_.reference));

  static final _loadContextDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperInfo_loadContextDescription")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence loadContextDescription(android.content.pm.PackageManager pm)
  /// Retrieves a title of the URI that specifies a link for further context about this wallpaper.
  ///@param pm An instance of PackageManager to retrieve the title.
  ///@return The title.
  jni.JlObject loadContextDescription(pm.PackageManager pm_) =>
      jni.JlObject.fromRef(_loadContextDescription(reference, pm_.reference));

  static final _getShowMetadataInPreview =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_WallpaperInfo_getShowMetadataInPreview")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getShowMetadataInPreview()
  /// Queries whether any metadata should be shown when previewing the wallpaper. If this value is
  /// set to true, any component that shows a preview of this live wallpaper should also show
  /// accompanying information like \#loadLabel,
  /// \#loadDescription, \#loadAuthor and
  /// \#loadContextDescription(PackageManager), so the user gets to know further information
  /// about this wallpaper.
  ///@return Whether any metadata should be shown when previewing the wallpaper.
  bool getShowMetadataInPreview() => _getShowMetadataInPreview(reference) != 0;

  static final _getSettingsActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperInfo_getSettingsActivity")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSettingsActivity()
  /// Return the class name of an activity that provides a settings UI for
  /// the wallpaper.  You can launch this activity be starting it with
  /// an android.content.Intent whose action is MAIN and with an
  /// explicit android.content.ComponentName
  /// composed of \#getPackageName and the class name returned here.
  ///
  /// A null will be returned if there is no settings activity associated
  /// with the wallpaper.
  jni.JlString getSettingsActivity() =>
      jni.JlString.fromRef(_getSettingsActivity(reference));

  static final _dump = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_WallpaperInfo_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  void dump(jni.JlObject pw, jni.JlString prefix) =>
      _dump(reference, pw.reference, prefix.reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_WallpaperInfo_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_WallpaperInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  /// Used to package this object into a Parcel.
  ///@param dest The Parcel to be written.
  ///@param flags The flags used for parceling.
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_WallpaperInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);
}
