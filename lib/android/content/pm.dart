// Autogenerated by jni_gen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_element

import "dart:ffi" as ffi;

import "package:jni/jni.dart" as jni;

import "package:content_plugin/android/os.dart" as os;

import "package:content_plugin/android/content.dart" as content;

import "package:content_plugin/android/content/res.dart" as res;
import "../../init.dart" show jlookup;

/// Encapsulates a package and its version code.
class VersionedPackage extends jni.JlObject {
  VersionedPackage.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.VersionedPackage> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_VersionedPackage_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_pm_VersionedPackage_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String packageName, int versionCode)
  /// Creates a new instance. Use PackageManager\#VERSION_CODE_HIGHEST
  /// to refer to the highest version code of this package.
  ///@param packageName The package name.
  /// This value must never be {@code null}.
  ///@param versionCode The version code.
  ///
  /// Value is PackageManager.VERSION_CODE_HIGHEST or greater
  VersionedPackage(jni.JlString packageName, int versionCode)
      : super.fromRef(_ctor(packageName.reference, versionCode));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_content_pm_VersionedPackage_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String packageName, long versionCode)
  /// Creates a new instance. Use PackageManager\#VERSION_CODE_HIGHEST
  /// to refer to the highest version code of this package.
  ///@param packageName The package name.
  /// This value must never be {@code null}.
  ///@param versionCode The version code.
  ///
  /// Value is PackageManager.VERSION_CODE_HIGHEST or greater
  VersionedPackage.ctor_1(jni.JlString packageName, int versionCode)
      : super.fromRef(_ctor_1(packageName.reference, versionCode));

  static final _getPackageName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_VersionedPackage_getPackageName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPackageName()
  /// Gets the package name.
  ///@return The package name.
  ///
  /// This value will never be {@code null}.
  jni.JlString getPackageName() =>
      jni.JlString.fromRef(_getPackageName(reference));

  static final _getVersionCode =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_VersionedPackage_getVersionCode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getVersionCode()
  /// @deprecated use \#getLongVersionCode() instead.
  ///@return Value is PackageManager.VERSION_CODE_HIGHEST or greater
  int getVersionCode() => _getVersionCode(reference);

  static final _getLongVersionCode =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_VersionedPackage_getLongVersionCode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getLongVersionCode()
  /// Gets the version code.
  ///@return The version code.
  ///
  /// Value is PackageManager.VERSION_CODE_HIGHEST or greater
  int getLongVersionCode() => _getLongVersionCode(reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_VersionedPackage_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_VersionedPackage_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_VersionedPackage_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  void writeToParcel(os.Parcel parcel, int flags) =>
      _writeToParcel(reference, parcel.reference, flags);
}

/// Information you can retrieve about hardware configuration preferences
/// declared by an application. This corresponds to information collected from the
/// AndroidManifest.xml's &lt;uses-configuration&gt; and &lt;uses-feature&gt; tags.
class ConfigurationInfo extends jni.JlObject {
  ConfigurationInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.ConfigurationInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_ConfigurationInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int GL_ES_VERSION_UNDEFINED
  /// Default value for \#reqGlEsVersion;
  static const GL_ES_VERSION_UNDEFINED = 0;

  /// from: static public final int INPUT_FEATURE_FIVE_WAY_NAV
  /// Value for \#reqInputFeatures: if set, indicates that the application
  /// requires a five way navigation device
  static const INPUT_FEATURE_FIVE_WAY_NAV = 2;

  /// from: static public final int INPUT_FEATURE_HARD_KEYBOARD
  /// Value for \#reqInputFeatures: if set, indicates that the application
  /// requires a hard keyboard
  static const INPUT_FEATURE_HARD_KEYBOARD = 1;

  /// from: public int reqGlEsVersion
  /// The GLES version used by an application. The upper order 16 bits represent the
  /// major version and the lower order 16 bits the minor version.
  static final _getreqGlEsVersion = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ConfigurationInfo_reqGlEsVersion")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get reqGlEsVersion => _getreqGlEsVersion(reference);
  static final _setreqGlEsVersion = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ConfigurationInfo_reqGlEsVersion")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set reqGlEsVersion(int value) => _setreqGlEsVersion(reference, value);

  /// from: public int reqInputFeatures
  /// Flags associated with the input features.  Any combination of
  /// \#INPUT_FEATURE_HARD_KEYBOARD,
  /// \#INPUT_FEATURE_FIVE_WAY_NAV
  static final _getreqInputFeatures = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ConfigurationInfo_reqInputFeatures")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get reqInputFeatures => _getreqInputFeatures(reference);
  static final _setreqInputFeatures = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ConfigurationInfo_reqInputFeatures")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set reqInputFeatures(int value) => _setreqInputFeatures(reference, value);

  /// from: public int reqKeyboardType
  /// Application's input method preference.
  /// One of: android.content.res.Configuration\#KEYBOARD_UNDEFINED,
  /// android.content.res.Configuration\#KEYBOARD_NOKEYS,
  /// android.content.res.Configuration\#KEYBOARD_QWERTY,
  /// android.content.res.Configuration\#KEYBOARD_12KEY
  static final _getreqKeyboardType = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ConfigurationInfo_reqKeyboardType")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get reqKeyboardType => _getreqKeyboardType(reference);
  static final _setreqKeyboardType = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ConfigurationInfo_reqKeyboardType")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set reqKeyboardType(int value) => _setreqKeyboardType(reference, value);

  /// from: public int reqNavigation
  /// A flag indicating whether any keyboard is available.
  /// one of: android.content.res.Configuration\#NAVIGATION_UNDEFINED,
  /// android.content.res.Configuration\#NAVIGATION_DPAD,
  /// android.content.res.Configuration\#NAVIGATION_TRACKBALL,
  /// android.content.res.Configuration\#NAVIGATION_WHEEL
  static final _getreqNavigation = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ConfigurationInfo_reqNavigation")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get reqNavigation => _getreqNavigation(reference);
  static final _setreqNavigation = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ConfigurationInfo_reqNavigation")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set reqNavigation(int value) => _setreqNavigation(reference, value);

  /// from: public int reqTouchScreen
  /// The kind of touch screen attached to the device.
  /// One of: android.content.res.Configuration\#TOUCHSCREEN_NOTOUCH,
  /// android.content.res.Configuration\#TOUCHSCREEN_STYLUS,
  /// android.content.res.Configuration\#TOUCHSCREEN_FINGER.
  static final _getreqTouchScreen = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ConfigurationInfo_reqTouchScreen")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get reqTouchScreen => _getreqTouchScreen(reference);
  static final _setreqTouchScreen = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ConfigurationInfo_reqTouchScreen")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set reqTouchScreen(int value) => _setreqTouchScreen(reference, value);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_ConfigurationInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ConfigurationInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ConfigurationInfo_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.pm.ConfigurationInfo orig)
  ConfigurationInfo.ctor_1(ConfigurationInfo orig)
      : super.fromRef(_ctor_1(orig.reference));

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ConfigurationInfo_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ConfigurationInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_ConfigurationInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(os.Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags);

  static final _getGlEsVersion = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ConfigurationInfo_getGlEsVersion")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getGlEsVersion()
  /// This method extracts the major and minor version of reqGLEsVersion attribute
  /// and returns it as a string. Say reqGlEsVersion value of 0x00010002 is returned
  /// as 1.2
  ///@return String representation of the reqGlEsVersion attribute
  jni.JlString getGlEsVersion() =>
      jni.JlString.fromRef(_getGlEsVersion(reference));
}

/// Information you can retrieve about a particular application
/// activity or receiver. This corresponds to information collected
/// from the AndroidManifest.xml's &lt;activity&gt; and
/// &lt;receiver&gt; tags.
class ActivityInfo extends ComponentInfo {
  ActivityInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int COLOR_MODE_DEFAULT
  /// Value for \#colorMode indicating that the activity should use the
  /// default color mode (sRGB, low dynamic range).
  ///@see android.R.attr\#colorMode
  static const COLOR_MODE_DEFAULT = 0;

  /// from: static public final int COLOR_MODE_HDR
  /// Value of \#colorMode indicating that the activity should use a
  /// high dynamic range if the presentation display supports it.
  ///@see android.R.attr\#colorMode
  static const COLOR_MODE_HDR = 2;

  /// from: static public final int COLOR_MODE_WIDE_COLOR_GAMUT
  /// Value of \#colorMode indicating that the activity should use a
  /// wide color gamut if the presentation display supports it.
  ///@see android.R.attr\#colorMode
  static const COLOR_MODE_WIDE_COLOR_GAMUT = 1;

  /// from: static public final int CONFIG_COLOR_MODE
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle the change to the display color gamut or dynamic
  /// range. Set from the android.R.attr\#configChanges attribute.
  static const CONFIG_COLOR_MODE = 16384;

  /// from: static public final int CONFIG_DENSITY
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle density changes. Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_DENSITY = 4096;

  /// from: static public final int CONFIG_FONT_SCALE
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the font scaling factor.  Set from the
  /// android.R.attr\#configChanges attribute.  This is
  /// not a core resource configuration, but a higher-level value, so its
  /// constant starts at the high bits.
  static const CONFIG_FONT_SCALE = 1073741824;

  /// from: static public final int CONFIG_KEYBOARD
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the keyboard type.  Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_KEYBOARD = 16;

  /// from: static public final int CONFIG_KEYBOARD_HIDDEN
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the keyboard or navigation being hidden/exposed.
  /// Note that inspite of the name, this applies to the changes to any
  /// hidden states: keyboard or navigation.
  /// Set from the android.R.attr\#configChanges attribute.
  static const CONFIG_KEYBOARD_HIDDEN = 32;

  /// from: static public final int CONFIG_LAYOUT_DIRECTION
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle the change to layout direction. Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_LAYOUT_DIRECTION = 8192;

  /// from: static public final int CONFIG_LOCALE
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the locale.  Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_LOCALE = 4;

  /// from: static public final int CONFIG_MCC
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the IMSI MCC.  Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_MCC = 1;

  /// from: static public final int CONFIG_MNC
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the IMSI MNC.  Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_MNC = 2;

  /// from: static public final int CONFIG_NAVIGATION
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the navigation type.  Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_NAVIGATION = 64;

  /// from: static public final int CONFIG_ORIENTATION
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the screen orientation.  Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_ORIENTATION = 128;

  /// from: static public final int CONFIG_SCREEN_LAYOUT
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the screen layout.  Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_SCREEN_LAYOUT = 256;

  /// from: static public final int CONFIG_SCREEN_SIZE
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle the screen size. Set from the
  /// android.R.attr\#configChanges attribute.  This will be
  /// set by default for applications that target an earlier version
  /// than android.os.Build.VERSION_CODES\#HONEYCOMB_MR2...
  /// __however__, you will not see the bit set here becomes some
  /// applications incorrectly compare \#configChanges against
  /// an absolute value rather than correctly masking out the bits
  /// they are interested in.  Please don't do that, thanks.
  static const CONFIG_SCREEN_SIZE = 1024;

  /// from: static public final int CONFIG_SMALLEST_SCREEN_SIZE
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle the smallest screen size. Set from the
  /// android.R.attr\#configChanges attribute.  This will be
  /// set by default for applications that target an earlier version
  /// than android.os.Build.VERSION_CODES\#HONEYCOMB_MR2...
  /// __however__, you will not see the bit set here becomes some
  /// applications incorrectly compare \#configChanges against
  /// an absolute value rather than correctly masking out the bits
  /// they are interested in.  Please don't do that, thanks.
  static const CONFIG_SMALLEST_SCREEN_SIZE = 2048;

  /// from: static public final int CONFIG_TOUCHSCREEN
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle changes to the touchscreen type.  Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_TOUCHSCREEN = 8;

  /// from: static public final int CONFIG_UI_MODE
  /// Bit in \#configChanges that indicates that the activity
  /// can itself handle the ui mode. Set from the
  /// android.R.attr\#configChanges attribute.
  static const CONFIG_UI_MODE = 512;

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.ActivityInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_ActivityInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int DOCUMENT_LAUNCH_ALWAYS
  /// Constant corresponding to <code>always</code> in
  /// the android.R.attr\#documentLaunchMode attribute.
  static const DOCUMENT_LAUNCH_ALWAYS = 2;

  /// from: static public final int DOCUMENT_LAUNCH_INTO_EXISTING
  /// Constant corresponding to <code>intoExisting</code> in
  /// the android.R.attr\#documentLaunchMode attribute.
  static const DOCUMENT_LAUNCH_INTO_EXISTING = 1;

  /// from: static public final int DOCUMENT_LAUNCH_NEVER
  /// Constant corresponding to <code>never</code> in
  /// the android.R.attr\#documentLaunchMode attribute.
  static const DOCUMENT_LAUNCH_NEVER = 3;

  /// from: static public final int DOCUMENT_LAUNCH_NONE
  /// Constant corresponding to <code>none</code> in
  /// the android.R.attr\#documentLaunchMode attribute.
  static const DOCUMENT_LAUNCH_NONE = 0;

  /// from: static public final int FLAG_ALLOW_TASK_REPARENTING
  /// Bit in \#flags that indicates that the activity can be moved
  /// between tasks based on its task affinity.  Set from the
  /// android.R.attr\#allowTaskReparenting attribute.
  static const FLAG_ALLOW_TASK_REPARENTING = 64;

  /// from: static public final int FLAG_ALWAYS_RETAIN_TASK_STATE
  /// Bit in \#flags indicating that, when the activity is the root
  /// of a task, that task's stack should never be cleared when it is
  /// relaunched from home.  Set from the
  /// android.R.attr\#alwaysRetainTaskState attribute.
  static const FLAG_ALWAYS_RETAIN_TASK_STATE = 8;

  /// from: static public final int FLAG_AUTO_REMOVE_FROM_RECENTS
  /// Bit in \#flags indicating that tasks started with this activity are to be
  /// removed from the recent list of tasks when the last activity in the task is finished.
  /// Corresponds to android.R.attr\#autoRemoveFromRecents
  static const FLAG_AUTO_REMOVE_FROM_RECENTS = 8192;

  /// from: static public final int FLAG_CLEAR_TASK_ON_LAUNCH
  /// Bit in \#flags indicating that, when the activity is the root
  /// of a task, that task's stack should be cleared each time the user
  /// re-launches it from home.  As a result, the user will always
  /// return to the original activity at the top of the task.
  /// This flag only applies to activities that
  /// are used to start the root of a new task.  Set from the
  /// android.R.attr\#clearTaskOnLaunch attribute.
  static const FLAG_CLEAR_TASK_ON_LAUNCH = 4;

  /// from: static public final int FLAG_ENABLE_VR_MODE
  /// Bit in \#flags indicating that this activity should be run with VR mode enabled.
  ///
  /// {@see android.app.Activity\#setVrMode(boolean)}.
  static const FLAG_ENABLE_VR_MODE = 32768;

  /// from: static public final int FLAG_EXCLUDE_FROM_RECENTS
  /// Bit in \#flags that indicates that the activity should not
  /// appear in the list of recently launched activities.  Set from the
  /// android.R.attr\#excludeFromRecents attribute.
  static const FLAG_EXCLUDE_FROM_RECENTS = 32;

  /// from: static public final int FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS
  /// Bit in \#flags indicating that, when a request to close system
  /// windows happens, this activity is finished.
  /// Set from the
  /// android.R.attr\#finishOnCloseSystemDialogs attribute.
  static const FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS = 256;

  /// from: static public final int FLAG_FINISH_ON_TASK_LAUNCH
  /// Bit in \#flags indicating that, when the activity's task is
  /// relaunched from home, this activity should be finished.
  /// Set from the
  /// android.R.attr\#finishOnTaskLaunch attribute.
  static const FLAG_FINISH_ON_TASK_LAUNCH = 2;

  /// from: static public final int FLAG_HARDWARE_ACCELERATED
  /// Value for \#flags: true when the application's rendering should
  /// be hardware accelerated.
  static const FLAG_HARDWARE_ACCELERATED = 512;

  /// from: static public final int FLAG_IMMERSIVE
  /// Bit in \#flags corresponding to an immersive activity
  /// that wishes not to be interrupted by notifications.
  /// Applications that hide the system notification bar with
  /// android.view.WindowManager.LayoutParams\#FLAG_FULLSCREEN
  /// may still be interrupted by high-priority notifications; for example, an
  /// incoming phone call may use
  /// android.app.Notification\#fullScreenIntent fullScreenIntent
  /// to present a full-screen in-call activity to the user, pausing the
  /// current activity as a side-effect. An activity with
  /// \#FLAG_IMMERSIVE set, however, will not be interrupted; the
  /// notification may be shown in some other way (such as a small floating
  /// "toast" window).
  ///
  /// Note that this flag will always reflect the Activity's
  /// <code>android:immersive</code> manifest definition, even if the Activity's
  /// immersive state is changed at runtime via
  /// android.app.Activity\#setImmersive(boolean).
  ///@see android.app.Notification\#FLAG_HIGH_PRIORITY
  ///@see android.app.Activity\#setImmersive(boolean)
  static const FLAG_IMMERSIVE = 2048;

  /// from: static public final int FLAG_MULTIPROCESS
  /// Bit in \#flags indicating whether this activity is able to
  /// run in multiple processes.  If
  /// true, the system may instantiate it in the some process as the
  /// process starting it in order to conserve resources.  If false, the
  /// default, it always runs in \#processName.  Set from the
  /// android.R.attr\#multiprocess attribute.
  static const FLAG_MULTIPROCESS = 1;

  /// from: static public final int FLAG_NO_HISTORY
  /// Bit in \#flags indicating that, when the user navigates away
  /// from an activity, it should be finished.
  /// Set from the
  /// android.R.attr\#noHistory attribute.
  static const FLAG_NO_HISTORY = 128;

  /// from: static public final int FLAG_RELINQUISH_TASK_IDENTITY
  /// Bit in \#flags: If set, a task rooted at this activity will have its
  /// baseIntent replaced by the activity immediately above this. Each activity may further
  /// relinquish its identity to the activity above it using this flag. Set from the
  /// android.R.attr\#relinquishTaskIdentity attribute.
  static const FLAG_RELINQUISH_TASK_IDENTITY = 4096;

  /// from: static public final int FLAG_RESUME_WHILE_PAUSING
  /// Bit in \#flags indicating that this activity can start is creation/resume
  /// while the previous activity is still pausing.  Corresponds to
  /// android.R.attr\#resumeWhilePausing
  static const FLAG_RESUME_WHILE_PAUSING = 16384;

  /// from: static public final int FLAG_SINGLE_USER
  /// Bit in \#flags: If set, a single instance of the receiver will
  /// run for all users on the device.  Set from the
  /// android.R.attr\#singleUser attribute.  Note that this flag is
  /// only relevant for ActivityInfo structures that are describing receiver
  /// components; it is not applied to activities.
  static const FLAG_SINGLE_USER = 1073741824;

  /// from: static public final int FLAG_STATE_NOT_NEEDED
  /// Bit in \#flags indicating that the activity's state
  /// is not required to be saved, so that if there is a failure the
  /// activity will not be removed from the activity stack.  Set from the
  /// android.R.attr\#stateNotNeeded attribute.
  static const FLAG_STATE_NOT_NEEDED = 16;

  /// from: static public final int LAUNCH_MULTIPLE
  /// Constant corresponding to <code>standard</code> in
  /// the android.R.attr\#launchMode attribute.
  static const LAUNCH_MULTIPLE = 0;

  /// from: static public final int LAUNCH_SINGLE_INSTANCE
  /// Constant corresponding to <code>singleInstance</code> in
  /// the android.R.attr\#launchMode attribute.
  static const LAUNCH_SINGLE_INSTANCE = 3;

  /// from: static public final int LAUNCH_SINGLE_TASK
  /// Constant corresponding to <code>singleTask</code> in
  /// the android.R.attr\#launchMode attribute.
  static const LAUNCH_SINGLE_TASK = 2;

  /// from: static public final int LAUNCH_SINGLE_TOP
  /// Constant corresponding to <code>singleTop</code> in
  /// the android.R.attr\#launchMode attribute.
  static const LAUNCH_SINGLE_TOP = 1;

  /// from: static public final int PERSIST_ACROSS_REBOOTS
  /// Constant corresponding to <code>persistAcrossReboots</code> in
  /// the android.R.attr\#persistableMode attribute.
  static const PERSIST_ACROSS_REBOOTS = 2;

  /// from: static public final int PERSIST_NEVER
  /// Constant corresponding to <code>doNotPersist</code> in
  /// the android.R.attr\#persistableMode attribute.
  static const PERSIST_NEVER = 1;

  /// from: static public final int PERSIST_ROOT_ONLY
  /// Constant corresponding to <code>persistRootOnly</code> in
  /// the android.R.attr\#persistableMode attribute.
  static const PERSIST_ROOT_ONLY = 0;

  /// from: static public final int SCREEN_ORIENTATION_BEHIND
  /// Constant corresponding to <code>behind</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_BEHIND = 3;

  /// from: static public final int SCREEN_ORIENTATION_FULL_SENSOR
  /// Constant corresponding to <code>fullSensor</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_FULL_SENSOR = 10;

  /// from: static public final int SCREEN_ORIENTATION_FULL_USER
  /// Constant corresponding to <code>fullUser</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_FULL_USER = 13;

  /// from: static public final int SCREEN_ORIENTATION_LANDSCAPE
  /// Constant corresponding to <code>landscape</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_LANDSCAPE = 0;

  /// from: static public final int SCREEN_ORIENTATION_LOCKED
  /// Constant corresponding to <code>locked</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_LOCKED = 14;

  /// from: static public final int SCREEN_ORIENTATION_NOSENSOR
  /// Constant corresponding to <code>nosensor</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_NOSENSOR = 5;

  /// from: static public final int SCREEN_ORIENTATION_PORTRAIT
  /// Constant corresponding to <code>portrait</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_PORTRAIT = 1;

  /// from: static public final int SCREEN_ORIENTATION_REVERSE_LANDSCAPE
  /// Constant corresponding to <code>reverseLandscape</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_REVERSE_LANDSCAPE = 8;

  /// from: static public final int SCREEN_ORIENTATION_REVERSE_PORTRAIT
  /// Constant corresponding to <code>reversePortrait</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_REVERSE_PORTRAIT = 9;

  /// from: static public final int SCREEN_ORIENTATION_SENSOR
  /// Constant corresponding to <code>sensor</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_SENSOR = 4;

  /// from: static public final int SCREEN_ORIENTATION_SENSOR_LANDSCAPE
  /// Constant corresponding to <code>sensorLandscape</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_SENSOR_LANDSCAPE = 6;

  /// from: static public final int SCREEN_ORIENTATION_SENSOR_PORTRAIT
  /// Constant corresponding to <code>sensorPortrait</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_SENSOR_PORTRAIT = 7;

  /// from: static public final int SCREEN_ORIENTATION_UNSPECIFIED
  /// Constant corresponding to <code>unspecified</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_UNSPECIFIED = -1;

  /// from: static public final int SCREEN_ORIENTATION_USER
  /// Constant corresponding to <code>user</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_USER = 2;

  /// from: static public final int SCREEN_ORIENTATION_USER_LANDSCAPE
  /// Constant corresponding to <code>userLandscape</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_USER_LANDSCAPE = 11;

  /// from: static public final int SCREEN_ORIENTATION_USER_PORTRAIT
  /// Constant corresponding to <code>userPortrait</code> in
  /// the android.R.attr\#screenOrientation attribute.
  static const SCREEN_ORIENTATION_USER_PORTRAIT = 12;

  /// from: static public final int UIOPTION_SPLIT_ACTION_BAR_WHEN_NARROW
  /// Flag for use with \#uiOptions.
  /// Indicates that the action bar should put all action items in a separate bar when
  /// the screen is narrow.
  /// This value corresponds to "splitActionBarWhenNarrow" for the \#uiOptions XML
  /// attribute.
  static const UIOPTION_SPLIT_ACTION_BAR_WHEN_NARROW = 1;

  /// from: public int colorMode
  /// The color mode requested by this activity. The target display may not be
  /// able to honor the request.
  ///
  /// Value is android.content.pm.ActivityInfo\#COLOR_MODE_DEFAULT, android.content.pm.ActivityInfo\#COLOR_MODE_WIDE_COLOR_GAMUT, or android.content.pm.ActivityInfo\#COLOR_MODE_HDR
  static final _getcolorMode = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo_colorMode")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get colorMode => _getcolorMode(reference);
  static final _setcolorMode = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_ActivityInfo_colorMode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set colorMode(int value) => _setcolorMode(reference, value);

  /// from: public int configChanges
  /// Bit mask of kinds of configuration changes that this activity
  /// can handle itself (without being restarted by the system).
  /// Contains any combination of \#CONFIG_FONT_SCALE,
  /// \#CONFIG_MCC, \#CONFIG_MNC,
  /// \#CONFIG_LOCALE, \#CONFIG_TOUCHSCREEN,
  /// \#CONFIG_KEYBOARD, \#CONFIG_NAVIGATION,
  /// \#CONFIG_ORIENTATION, \#CONFIG_SCREEN_LAYOUT,
  /// \#CONFIG_DENSITY, \#CONFIG_LAYOUT_DIRECTION and
  /// \#CONFIG_COLOR_MODE.
  /// Set from the android.R.attr\#configChanges attribute.
  static final _getconfigChanges = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo_configChanges")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get configChanges => _getconfigChanges(reference);
  static final _setconfigChanges = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ActivityInfo_configChanges")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set configChanges(int value) => _setconfigChanges(reference, value);

  /// from: public int documentLaunchMode
  /// The document launch mode style requested by the activity. From the
  /// android.R.attr\#documentLaunchMode attribute, one of
  /// \#DOCUMENT_LAUNCH_NONE, \#DOCUMENT_LAUNCH_INTO_EXISTING,
  /// \#DOCUMENT_LAUNCH_ALWAYS.
  ///
  /// Modes DOCUMENT_LAUNCH_ALWAYS
  /// and DOCUMENT_LAUNCH_INTO_EXISTING are equivalent to android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT Intent.FLAG_ACTIVITY_NEW_DOCUMENT with and without android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK Intent.FLAG_ACTIVITY_MULTIPLE_TASK respectively.
  static final _getdocumentLaunchMode = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo_documentLaunchMode")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get documentLaunchMode => _getdocumentLaunchMode(reference);
  static final _setdocumentLaunchMode = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ActivityInfo_documentLaunchMode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set documentLaunchMode(int value) => _setdocumentLaunchMode(reference, value);

  /// from: public int flags
  /// Options that have been set in the activity declaration in the
  /// manifest.
  /// These include:
  /// \#FLAG_MULTIPROCESS,
  /// \#FLAG_FINISH_ON_TASK_LAUNCH, \#FLAG_CLEAR_TASK_ON_LAUNCH,
  /// \#FLAG_ALWAYS_RETAIN_TASK_STATE,
  /// \#FLAG_STATE_NOT_NEEDED, \#FLAG_EXCLUDE_FROM_RECENTS,
  /// \#FLAG_ALLOW_TASK_REPARENTING, \#FLAG_NO_HISTORY,
  /// \#FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS,
  /// \#FLAG_HARDWARE_ACCELERATED, \#FLAG_SINGLE_USER.
  static final _getflags = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo_flags")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get flags => _getflags(reference);
  static final _setflags = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_ActivityInfo_flags")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set flags(int value) => _setflags(reference, value);

  /// from: public int launchMode
  /// The launch mode style requested by the activity.  From the
  /// android.R.attr\#launchMode attribute, one of
  /// \#LAUNCH_MULTIPLE,
  /// \#LAUNCH_SINGLE_TOP, \#LAUNCH_SINGLE_TASK, or
  /// \#LAUNCH_SINGLE_INSTANCE.
  static final _getlaunchMode = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo_launchMode")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get launchMode => _getlaunchMode(reference);
  static final _setlaunchMode = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_ActivityInfo_launchMode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set launchMode(int value) => _setlaunchMode(reference, value);

  /// from: public int maxRecents
  /// The maximum number of tasks rooted at this activity that can be in the recent task list.
  /// Refer to android.R.attr\#maxRecents.
  static final _getmaxRecents = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo_maxRecents")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get maxRecents => _getmaxRecents(reference);
  static final _setmaxRecents = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_ActivityInfo_maxRecents")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set maxRecents(int value) => _setmaxRecents(reference, value);

  /// from: public java.lang.String parentActivityName
  /// If defined, the activity named here is the logical parent of this activity.
  static final _getparentActivityName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo_parentActivityName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get parentActivityName =>
      jni.JlString.fromRef(_getparentActivityName(reference));
  static final _setparentActivityName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ActivityInfo_parentActivityName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set parentActivityName(jni.JlString value) =>
      _setparentActivityName(reference, value.reference);

  /// from: public java.lang.String permission
  /// Optional name of a permission required to be able to access this
  /// Activity.  From the "permission" attribute.
  static final _getpermission = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo_permission")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get permission =>
      jni.JlString.fromRef(_getpermission(reference));
  static final _setpermission = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ActivityInfo_permission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set permission(jni.JlString value) =>
      _setpermission(reference, value.reference);

  /// from: public int persistableMode
  /// Value indicating how this activity is to be persisted across
  /// reboots for restoring in the Recents list.
  /// android.R.attr\#persistableMode
  static final _getpersistableMode = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo_persistableMode")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get persistableMode => _getpersistableMode(reference);
  static final _setpersistableMode = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ActivityInfo_persistableMode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set persistableMode(int value) => _setpersistableMode(reference, value);

  /// from: public int screenOrientation
  /// The preferred screen orientation this activity would like to run in.
  /// From the android.R.attr\#screenOrientation attribute, one of
  /// \#SCREEN_ORIENTATION_UNSPECIFIED,
  /// \#SCREEN_ORIENTATION_LANDSCAPE,
  /// \#SCREEN_ORIENTATION_PORTRAIT,
  /// \#SCREEN_ORIENTATION_USER,
  /// \#SCREEN_ORIENTATION_BEHIND,
  /// \#SCREEN_ORIENTATION_SENSOR,
  /// \#SCREEN_ORIENTATION_NOSENSOR,
  /// \#SCREEN_ORIENTATION_SENSOR_LANDSCAPE,
  /// \#SCREEN_ORIENTATION_SENSOR_PORTRAIT,
  /// \#SCREEN_ORIENTATION_REVERSE_LANDSCAPE,
  /// \#SCREEN_ORIENTATION_REVERSE_PORTRAIT,
  /// \#SCREEN_ORIENTATION_FULL_SENSOR,
  /// \#SCREEN_ORIENTATION_USER_LANDSCAPE,
  /// \#SCREEN_ORIENTATION_USER_PORTRAIT,
  /// \#SCREEN_ORIENTATION_FULL_USER,
  /// \#SCREEN_ORIENTATION_LOCKED,
  ///
  /// Value is android.content.pm.ActivityInfo.SCREEN_ORIENTATION_UNSET, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_UNSPECIFIED, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_BEHIND, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_NOSENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_REVERSE_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_REVERSE_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_FULL_SENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_FULL_USER, or android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_LOCKED
  static final _getscreenOrientation = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo_screenOrientation")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get screenOrientation => _getscreenOrientation(reference);
  static final _setscreenOrientation = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ActivityInfo_screenOrientation")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set screenOrientation(int value) => _setscreenOrientation(reference, value);

  /// from: public int softInputMode
  /// The desired soft input mode for this activity's main window.
  /// Set from the android.R.attr\#windowSoftInputMode attribute
  /// in the activity's manifest.  May be any of the same values allowed
  /// for android.view.WindowManager.LayoutParams\#softInputMode WindowManager.LayoutParams.softInputMode.  If 0 (unspecified),
  /// the mode from the theme will be used.
  ///
  /// Value is either <code>0</code> or a combination of android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_UNSPECIFIED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_UNCHANGED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_HIDDEN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_ALWAYS_HIDDEN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_VISIBLE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_STATE_ALWAYS_VISIBLE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_UNSPECIFIED, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_RESIZE, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_PAN, android.view.WindowManager.LayoutParams\#SOFT_INPUT_ADJUST_NOTHING, and android.view.WindowManager.LayoutParams\#SOFT_INPUT_IS_FORWARD_NAVIGATION
  static final _getsoftInputMode = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo_softInputMode")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get softInputMode => _getsoftInputMode(reference);
  static final _setsoftInputMode = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ActivityInfo_softInputMode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set softInputMode(int value) => _setsoftInputMode(reference, value);

  /// from: public java.lang.String targetActivity
  /// If this is an activity alias, this is the real activity class to run
  /// for it.  Otherwise, this is null.
  static final _gettargetActivity = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo_targetActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get targetActivity =>
      jni.JlString.fromRef(_gettargetActivity(reference));
  static final _settargetActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ActivityInfo_targetActivity")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set targetActivity(jni.JlString value) =>
      _settargetActivity(reference, value.reference);

  /// from: public java.lang.String taskAffinity
  /// The affinity this activity has for another task in the system.  The
  /// string here is the name of the task, often the package name of the
  /// overall package.  If null, the activity has no affinity.  Set from the
  /// android.R.attr\#taskAffinity attribute.
  static final _gettaskAffinity = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo_taskAffinity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get taskAffinity =>
      jni.JlString.fromRef(_gettaskAffinity(reference));
  static final _settaskAffinity = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ActivityInfo_taskAffinity")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set taskAffinity(jni.JlString value) =>
      _settaskAffinity(reference, value.reference);

  /// from: public int theme
  /// A style resource identifier (in the package's resources) of this
  /// activity's theme.  From the "theme" attribute or, if not set, 0.
  static final _gettheme = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo_theme")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get theme => _gettheme(reference);
  static final _settheme = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_ActivityInfo_theme")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set theme(int value) => _settheme(reference, value);

  /// from: public int uiOptions
  /// The desired extra UI options for this activity and its main window.
  /// Set from the android.R.attr\#uiOptions attribute in the
  /// activity's manifest.
  static final _getuiOptions = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo_uiOptions")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get uiOptions => _getuiOptions(reference);
  static final _setuiOptions = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_ActivityInfo_uiOptions")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set uiOptions(int value) => _setuiOptions(reference, value);

  /// from: public android.content.pm.ActivityInfo.WindowLayout windowLayout
  /// Information about desired position and size of activity on the display when
  /// it is first started.
  static final _getwindowLayout = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo_windowLayout")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  ActivityInfo_WindowLayout get windowLayout =>
      ActivityInfo_WindowLayout.fromRef(_getwindowLayout(reference));
  static final _setwindowLayout = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ActivityInfo_windowLayout")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set windowLayout(ActivityInfo_WindowLayout value) =>
      _setwindowLayout(reference, value.reference);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_ActivityInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ActivityInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ActivityInfo_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.pm.ActivityInfo orig)
  ActivityInfo.ctor_1(ActivityInfo orig)
      : super.fromRef(_ctor_1(orig.reference));

  static final _getThemeResource =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ActivityInfo_getThemeResource")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getThemeResource()
  /// Return the theme resource identifier to use for this activity.  If
  /// the activity defines a theme, that is used; else, the application
  /// theme is used.
  ///@return The theme associated with this activity.
  int getThemeResource() => _getThemeResource(reference);

  static final _dump = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ActivityInfo_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  void dump(jni.JlObject pw, jni.JlString prefix) =>
      _dump(reference, pw.reference, prefix.reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ActivityInfo_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ActivityInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_pm_ActivityInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(os.Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags);
}

/// Contains information about position and size of the activity on the display.
///
/// Used in freeform mode to set desired position when activity is first launched.
/// It describes how big the activity wants to be in both width and height,
/// the minimal allowed size, and the gravity to be applied.
///@attr ref android.R.styleable\#AndroidManifestLayout_defaultWidth
///@attr ref android.R.styleable\#AndroidManifestLayout_defaultHeight
///@attr ref android.R.styleable\#AndroidManifestLayout_gravity
///@attr ref android.R.styleable\#AndroidManifestLayout_minWidth
///@attr ref android.R.styleable\#AndroidManifestLayout_minHeight
class ActivityInfo_WindowLayout extends jni.JlObject {
  ActivityInfo_WindowLayout.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: public final int gravity
  /// Gravity of activity.
  /// Currently android.view.Gravity\#TOP, android.view.Gravity\#BOTTOM,
  /// android.view.Gravity\#LEFT and android.view.Gravity\#RIGHT are supported.
  ///@attr ref android.R.styleable\#AndroidManifestLayout_gravity
  static final _getgravity = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo__WindowLayout_gravity")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get gravity => _getgravity(reference);

  /// from: public final int height
  /// Height of activity in pixels.
  ///@attr ref android.R.styleable\#AndroidManifestLayout_defaultHeight
  static final _getheight = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo__WindowLayout_height")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get height => _getheight(reference);

  /// from: public final float heightFraction
  /// Height of activity as a fraction of available display height.
  /// If both \#height and this value are set this one will be preferred.
  ///@attr ref android.R.styleable\#AndroidManifestLayout_defaultHeight
  static final _getheightFraction = jlookup<
          ffi.NativeFunction<
              ffi.Float Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo__WindowLayout_heightFraction")
      .asFunction<
          double Function(
    ffi.Pointer<ffi.Void>,
  )>();
  double get heightFraction => _getheightFraction(reference);

  /// from: public final int minHeight
  /// Minimal height of activity in pixels to be able to display its content.
  ///
  /// <strong>NOTE:</strong> A task's root activity value is applied to all additional
  /// activities launched in the task. That is if the root activity of a task set minimal
  /// height, then the system will set the same minimal height on all other activities in the
  /// task. It will also ignore any other minimal height attributes of non-root activities.
  ///@attr ref android.R.styleable\#AndroidManifestLayout_minHeight
  static final _getminHeight = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo__WindowLayout_minHeight")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get minHeight => _getminHeight(reference);

  /// from: public final int minWidth
  /// Minimal width of activity in pixels to be able to display its content.
  ///
  /// <strong>NOTE:</strong> A task's root activity value is applied to all additional
  /// activities launched in the task. That is if the root activity of a task set minimal
  /// width, then the system will set the same minimal width on all other activities in the
  /// task. It will also ignore any other minimal width attributes of non-root activities.
  ///@attr ref android.R.styleable\#AndroidManifestLayout_minWidth
  static final _getminWidth = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo__WindowLayout_minWidth")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get minWidth => _getminWidth(reference);

  /// from: public final int width
  /// Width of activity in pixels.
  ///@attr ref android.R.styleable\#AndroidManifestLayout_defaultWidth
  static final _getwidth = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo__WindowLayout_width")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get width => _getwidth(reference);

  /// from: public final float widthFraction
  /// Width of activity as a fraction of available display width.
  /// If both \#width and this value are set this one will be preferred.
  ///@attr ref android.R.styleable\#AndroidManifestLayout_defaultWidth
  static final _getwidthFraction = jlookup<
          ffi.NativeFunction<
              ffi.Float Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ActivityInfo__WindowLayout_widthFraction")
      .asFunction<
          double Function(
    ffi.Pointer<ffi.Void>,
  )>();
  double get widthFraction => _getwidthFraction(reference);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Int32, ffi.Float,
                      ffi.Int32, ffi.Float, ffi.Int32, ffi.Int32, ffi.Int32)>>(
          "android_content_pm_ActivityInfo__WindowLayout_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              int, double, int, double, int, int, int)>();

  /// from: public void <init>(int width, float widthFraction, int height, float heightFraction, int gravity, int minWidth, int minHeight)
  ActivityInfo_WindowLayout(int width, double widthFraction, int height,
      double heightFraction, int gravity, int minWidth, int minHeight)
      : super.fromRef(_ctor(width, widthFraction, height, heightFraction,
            gravity, minWidth, minHeight));
}

/// Class for retrieving a list of launchable activities for the current user and any associated
/// managed profiles that are visible to the current user, which can be retrieved with
/// \#getProfiles. This is mainly for use by launchers.
///
/// Apps can be queried for each user profile.
/// Since the PackageManager will not deliver package broadcasts for other profiles, you can register
/// for package changes here.
///
/// To watch for managed profiles being added or removed, register for the following broadcasts:
/// Intent\#ACTION_MANAGED_PROFILE_ADDED and Intent\#ACTION_MANAGED_PROFILE_REMOVED.
///
/// Note as of Android O, apps on a managed profile are no longer allowed to access apps on the
/// main profile.  Apps can only access profiles returned by \#getProfiles().
class LauncherApps extends jni.JlObject {
  LauncherApps.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_CONFIRM_PIN_APPWIDGET
  /// Activity Action: For the default launcher to show the confirmation dialog to create
  /// a pinned app widget.
  ///
  /// See the android.appwidget.AppWidgetManager\#requestPinAppWidget javadoc for
  /// details.
  ///
  ///
  /// Use \#getPinItemRequest(Intent) to get a PinItemRequest object,
  /// and call PinItemRequest\#accept(Bundle)
  /// if the user accepts.  If the user doesn't accept, no further action is required.
  ///@see \#EXTRA_PIN_ITEM_REQUEST
  static const ACTION_CONFIRM_PIN_APPWIDGET =
      "android.content.pm.action.CONFIRM_PIN_APPWIDGET";

  /// from: static public final java.lang.String ACTION_CONFIRM_PIN_SHORTCUT
  /// Activity Action: For the default launcher to show the confirmation dialog to create
  /// a pinned shortcut.
  ///
  /// See the ShortcutManager javadoc for details.
  ///
  ///
  /// Use \#getPinItemRequest(Intent) to get a PinItemRequest object,
  /// and call PinItemRequest\#accept(Bundle)
  /// if the user accepts.  If the user doesn't accept, no further action is required.
  ///@see \#EXTRA_PIN_ITEM_REQUEST
  static const ACTION_CONFIRM_PIN_SHORTCUT =
      "android.content.pm.action.CONFIRM_PIN_SHORTCUT";

  /// from: static public final java.lang.String EXTRA_PIN_ITEM_REQUEST
  /// An extra for \#ACTION_CONFIRM_PIN_SHORTCUT &amp; \#ACTION_CONFIRM_PIN_APPWIDGET
  /// containing a PinItemRequest of appropriate type asked to pin.
  ///
  /// A helper function \#getPinItemRequest(Intent) can be used
  /// instead of using this constant directly.
  ///@see \#ACTION_CONFIRM_PIN_SHORTCUT
  ///@see \#ACTION_CONFIRM_PIN_APPWIDGET
  static const EXTRA_PIN_ITEM_REQUEST =
      "android.content.pm.extra.PIN_ITEM_REQUEST";

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.content.Context context)
  /// @hide
  LauncherApps(content.Context context)
      : super.fromRef(_ctor(context.reference));

  static final _getProfiles = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_getProfiles")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.os.UserHandle> getProfiles()
  /// Return a list of profiles that the caller can access via the LauncherApps APIs.
  ///
  /// If the caller is running on a managed profile, it'll return only the current profile.
  /// Otherwise it'll return the same list as UserManager\#getUserProfiles() would.
  jni.JlObject getProfiles() => jni.JlObject.fromRef(_getProfiles(reference));

  static final _getActivityList = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_getActivityList")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.content.pm.LauncherActivityInfo> getActivityList(java.lang.String packageName, android.os.UserHandle user)
  /// Retrieves a list of launchable activities that match Intent\#ACTION_MAIN and
  /// Intent\#CATEGORY_LAUNCHER, for a specified user.
  ///@param packageName The specific package to query. If null, it checks all installed packages
  ///            in the profile.
  ///@param user The UserHandle of the profile.
  ///@return List of launchable activities. Can be an empty list but will not be null.
  jni.JlObject getActivityList(jni.JlString packageName, os.UserHandle user) =>
      jni.JlObject.fromRef(
          _getActivityList(reference, packageName.reference, user.reference));

  static final _resolveActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_resolveActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.LauncherActivityInfo resolveActivity(android.content.Intent intent, android.os.UserHandle user)
  /// Returns the activity info for a given intent and user handle, if it resolves. Otherwise it
  /// returns null.
  ///@param intent The intent to find a match for.
  ///@param user The profile to look in for a match.
  ///@return An activity info object if there is a match.
  LauncherActivityInfo resolveActivity(
          content.Intent intent, os.UserHandle user) =>
      LauncherActivityInfo.fromRef(
          _resolveActivity(reference, intent.reference, user.reference));

  static final _startMainActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_startMainActivity")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startMainActivity(android.content.ComponentName component, android.os.UserHandle user, android.graphics.Rect sourceBounds, android.os.Bundle opts)
  /// Starts a Main activity in the specified profile.
  ///@param component The ComponentName of the activity to launch
  ///@param user The UserHandle of the profile
  ///@param sourceBounds The Rect containing the source bounds of the clicked icon
  ///@param opts Options to pass to startActivity
  void startMainActivity(content.ComponentName component, os.UserHandle user,
          jni.JlObject sourceBounds, os.Bundle opts) =>
      _startMainActivity(reference, component.reference, user.reference,
          sourceBounds.reference, opts.reference);

  static final _startAppDetailsActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_startAppDetailsActivity")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startAppDetailsActivity(android.content.ComponentName component, android.os.UserHandle user, android.graphics.Rect sourceBounds, android.os.Bundle opts)
  /// Starts the settings activity to show the application details for a
  /// package in the specified profile.
  ///@param component The ComponentName of the package to launch settings for.
  ///@param user The UserHandle of the profile
  ///@param sourceBounds The Rect containing the source bounds of the clicked icon
  ///@param opts Options to pass to startActivity
  void startAppDetailsActivity(content.ComponentName component,
          os.UserHandle user, jni.JlObject sourceBounds, os.Bundle opts) =>
      _startAppDetailsActivity(reference, component.reference, user.reference,
          sourceBounds.reference, opts.reference);

  static final _getShortcutConfigActivityList = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_getShortcutConfigActivityList")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.content.pm.LauncherActivityInfo> getShortcutConfigActivityList(java.lang.String packageName, android.os.UserHandle user)
  /// Retrieves a list of config activities for creating ShortcutInfo.
  ///@param packageName The specific package to query. If null, it checks all installed packages
  ///            in the profile.
  /// This value may be {@code null}.
  ///@param user The UserHandle of the profile.
  /// This value must never be {@code null}.
  ///@return List of config activities. Can be an empty list but will not be null.
  ///@see Intent\#ACTION_CREATE_SHORTCUT
  ///@see \#getShortcutConfigActivityIntent(LauncherActivityInfo)
  jni.JlObject getShortcutConfigActivityList(
          jni.JlString packageName, os.UserHandle user) =>
      jni.JlObject.fromRef(_getShortcutConfigActivityList(
          reference, packageName.reference, user.reference));

  static final _getShortcutConfigActivityIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_getShortcutConfigActivityIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.IntentSender getShortcutConfigActivityIntent(android.content.pm.LauncherActivityInfo info)
  /// Returns an intent sender which can be used to start the configure activity for creating
  /// custom shortcuts. Use this method if the provider is in another profile as you are not
  /// allowed to start an activity in another profile.
  ///
  /// The caller should receive PinItemRequest in onActivityResult on
  /// android.app.Activity\#RESULT_OK.
  ///
  /// Callers must be allowed to access the shortcut information, as defined in \#hasShortcutHostPermission().
  ///@param info a configuration activity returned by \#getShortcutConfigActivityList
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalStateException when the user is locked or not running.
  ///@throws SecurityException if \#hasShortcutHostPermission() is false.
  ///@see \#getPinItemRequest(Intent)
  ///@see Intent\#ACTION_CREATE_SHORTCUT
  ///@see android.app.Activity\#startIntentSenderForResult
  ///@return This value may be {@code null}.
  content.IntentSender getShortcutConfigActivityIntent(
          LauncherActivityInfo info) =>
      content.IntentSender.fromRef(
          _getShortcutConfigActivityIntent(reference, info.reference));

  static final _isPackageEnabled = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_isPackageEnabled")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isPackageEnabled(java.lang.String packageName, android.os.UserHandle user)
  /// Checks if the package is installed and enabled for a profile.
  ///@param packageName The package to check.
  ///@param user The UserHandle of the profile.
  ///@return true if the package exists and is enabled.
  bool isPackageEnabled(jni.JlString packageName, os.UserHandle user) =>
      _isPackageEnabled(reference, packageName.reference, user.reference) != 0;

  static final _getSuspendedPackageLauncherExtras = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_getSuspendedPackageLauncherExtras")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getSuspendedPackageLauncherExtras(java.lang.String packageName, android.os.UserHandle user)
  /// Gets the launcher extras supplied to the system when the given package was suspended via
  /// {@code PackageManager\#setPackagesSuspended(String[], boolean, PersistableBundle,
  /// PersistableBundle, String)}.
  ///
  /// The contents of this Bundle are supposed to be a contract between the suspending
  /// app and the launcher.
  ///
  /// Note: This just returns whatever extras were provided to the system, _which might
  /// even be {@code null}._
  ///@param packageName The package for which to fetch the launcher extras.
  ///@param user The UserHandle of the profile.
  ///@return A Bundle of launcher extras. Or {@code null} if the package is not currently
  ///         suspended.
  ///@see Callback\#onPackagesSuspended(String[], UserHandle, Bundle)
  ///@see PackageManager\#isPackageSuspended()
  os.Bundle getSuspendedPackageLauncherExtras(
          jni.JlString packageName, os.UserHandle user) =>
      os.Bundle.fromRef(_getSuspendedPackageLauncherExtras(
          reference, packageName.reference, user.reference));

  static final _getApplicationInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_getApplicationInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ApplicationInfo getApplicationInfo(java.lang.String packageName, int flags, android.os.UserHandle user)
  /// Returns ApplicationInfo about an application installed for a specific user profile.
  ///@param packageName The package name of the application
  /// This value must never be {@code null}.
  ///@param flags Additional option flags PackageManager\#getApplicationInfo
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@param user The UserHandle of the profile.
  ///
  /// This value must never be {@code null}.
  ///@return ApplicationInfo containing information about the package. Returns
  ///         {@code null} if the package isn't installed for the given profile, or the profile
  ///         isn't enabled.
  ApplicationInfo getApplicationInfo(
          jni.JlString packageName, int flags, os.UserHandle user) =>
      ApplicationInfo.fromRef(_getApplicationInfo(
          reference, packageName.reference, flags, user.reference));

  static final _isActivityEnabled = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_isActivityEnabled")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isActivityEnabled(android.content.ComponentName component, android.os.UserHandle user)
  /// Checks if the activity exists and it enabled for a profile.
  ///@param component The activity to check.
  ///@param user The UserHandle of the profile.
  ///@return true if the activity exists and is enabled.
  bool isActivityEnabled(content.ComponentName component, os.UserHandle user) =>
      _isActivityEnabled(reference, component.reference, user.reference) != 0;

  static final _hasShortcutHostPermission =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_LauncherApps_hasShortcutHostPermission")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasShortcutHostPermission()
  /// Returns whether the caller can access the shortcut information.  Access is currently
  /// available to:
  ///
  /// <ul>
  ///     <li>The current launcher (or default launcher if there is no set current launcher).</li>
  ///     <li>The currently active voice interaction service.</li>
  /// </ul>
  ///
  /// Note when this method returns {@code false}, it may be a temporary situation because
  /// the user is trying a new launcher application.  The user may decide to change the default
  /// launcher back to the calling application again, so even if a launcher application loses
  /// this permission, it does __not__ have to purge pinned shortcut information.
  /// If the calling launcher application contains pinned shortcuts, they will still work,
  /// even though the caller no longer has the shortcut host permission.
  ///@throws IllegalStateException when the user is locked.
  ///@see ShortcutManager
  bool hasShortcutHostPermission() =>
      _hasShortcutHostPermission(reference) != 0;

  static final _getShortcuts = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_getShortcuts")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.content.pm.ShortcutInfo> getShortcuts(android.content.pm.LauncherApps.ShortcutQuery query, android.os.UserHandle user)
  /// Returns ShortcutInfos that match {@code query}.
  ///
  /// Callers must be allowed to access the shortcut information, as defined in \#hasShortcutHostPermission().
  ///@param query result includes shortcuts matching this query.
  /// This value must never be {@code null}.
  ///@param user The UserHandle of the profile.
  ///
  /// This value must never be {@code null}.
  ///@return the IDs of ShortcutInfos that match the query.
  /// This value may be {@code null}.
  ///@throws IllegalStateException when the user is locked, or when the {@code user} user
  /// is locked or not running.
  ///@see ShortcutManager
  jni.JlObject getShortcuts(
          LauncherApps_ShortcutQuery query, os.UserHandle user) =>
      jni.JlObject.fromRef(
          _getShortcuts(reference, query.reference, user.reference));

  static final _pinShortcuts = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_pinShortcuts")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void pinShortcuts(java.lang.String packageName, java.util.List<java.lang.String> shortcutIds, android.os.UserHandle user)
  /// Pin shortcuts on a package.
  ///
  /// This API is __NOT__ cumulative; this will replace all pinned shortcuts for the package.
  /// However, different launchers may have different set of pinned shortcuts.
  ///
  /// The calling launcher application must be allowed to access the shortcut information,
  /// as defined in \#hasShortcutHostPermission().
  ///@param packageName The target package name.
  /// This value must never be {@code null}.
  ///@param shortcutIds The IDs of the shortcut to be pinned.
  /// This value must never be {@code null}.
  ///@param user The UserHandle of the profile.
  /// This value must never be {@code null}.
  ///@throws IllegalStateException when the user is locked, or when the {@code user} user
  /// is locked or not running.
  ///@see ShortcutManager
  void pinShortcuts(jni.JlString packageName, jni.JlObject shortcutIds,
          os.UserHandle user) =>
      _pinShortcuts(reference, packageName.reference, shortcutIds.reference,
          user.reference);

  static final _getShortcutIconDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_LauncherApps_getShortcutIconDrawable")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.drawable.Drawable getShortcutIconDrawable(android.content.pm.ShortcutInfo shortcut, int density)
  /// Returns the icon for this shortcut, without any badging for the profile.
  ///
  /// The calling launcher application must be allowed to access the shortcut information,
  /// as defined in \#hasShortcutHostPermission().
  ///@param density The preferred density of the icon, zero for default density. Use
  /// density DPI values from DisplayMetrics.
  ///@param shortcut This value must never be {@code null}.
  ///@return The drawable associated with the shortcut.
  ///@throws IllegalStateException when the user is locked, or when the {@code user} user
  /// is locked or not running.
  ///@see ShortcutManager
  ///@see \#getShortcutBadgedIconDrawable(ShortcutInfo, int)
  ///@see DisplayMetrics
  jni.JlObject getShortcutIconDrawable(ShortcutInfo shortcut, int density) =>
      jni.JlObject.fromRef(
          _getShortcutIconDrawable(reference, shortcut.reference, density));

  static final _getShortcutBadgedIconDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_LauncherApps_getShortcutBadgedIconDrawable")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.drawable.Drawable getShortcutBadgedIconDrawable(android.content.pm.ShortcutInfo shortcut, int density)
  /// Returns the shortcut icon with badging appropriate for the profile.
  ///
  /// The calling launcher application must be allowed to access the shortcut information,
  /// as defined in \#hasShortcutHostPermission().
  ///@param density Optional density for the icon, or 0 to use the default density. Use
  ///@return A badged icon for the shortcut.
  ///@throws IllegalStateException when the user is locked, or when the {@code user} user
  /// is locked or not running.
  ///@see ShortcutManager
  ///@see \#getShortcutIconDrawable(ShortcutInfo, int)
  ///@see DisplayMetrics
  jni.JlObject getShortcutBadgedIconDrawable(
          ShortcutInfo shortcut, int density) =>
      jni.JlObject.fromRef(_getShortcutBadgedIconDrawable(
          reference, shortcut.reference, density));

  static final _startShortcut = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_startShortcut")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startShortcut(java.lang.String packageName, java.lang.String shortcutId, android.graphics.Rect sourceBounds, android.os.Bundle startActivityOptions, android.os.UserHandle user)
  /// Starts a shortcut.
  ///
  /// The calling launcher application must be allowed to access the shortcut information,
  /// as defined in \#hasShortcutHostPermission().
  ///@param packageName The target shortcut package name.
  /// This value must never be {@code null}.
  ///@param shortcutId The target shortcut ID.
  /// This value must never be {@code null}.
  ///@param sourceBounds The Rect containing the source bounds of the clicked icon.
  /// This value may be {@code null}.
  ///@param startActivityOptions Options to pass to startActivity.
  /// This value may be {@code null}.
  ///@param user The UserHandle of the profile.
  /// This value must never be {@code null}.
  ///@throws IllegalStateException when the user is locked, or when the {@code user} user
  /// is locked or not running.
  ///@throws android.content.ActivityNotFoundException failed to start shortcut. (e.g.
  /// the shortcut no longer exists, is disabled, the intent receiver activity doesn't exist, etc)
  void startShortcut(
          jni.JlString packageName,
          jni.JlString shortcutId,
          jni.JlObject sourceBounds,
          os.Bundle startActivityOptions,
          os.UserHandle user) =>
      _startShortcut(
          reference,
          packageName.reference,
          shortcutId.reference,
          sourceBounds.reference,
          startActivityOptions.reference,
          user.reference);

  static final _startShortcut_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_startShortcut_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startShortcut(android.content.pm.ShortcutInfo shortcut, android.graphics.Rect sourceBounds, android.os.Bundle startActivityOptions)
  /// Launches a shortcut.
  ///
  /// The calling launcher application must be allowed to access the shortcut information,
  /// as defined in \#hasShortcutHostPermission().
  ///@param shortcut The target shortcut.
  /// This value must never be {@code null}.
  ///@param sourceBounds The Rect containing the source bounds of the clicked icon.
  /// This value may be {@code null}.
  ///@param startActivityOptions Options to pass to startActivity.
  /// This value may be {@code null}.
  ///@throws IllegalStateException when the user is locked, or when the {@code user} user
  /// is locked or not running.
  ///@throws android.content.ActivityNotFoundException failed to start shortcut. (e.g.
  /// the shortcut no longer exists, is disabled, the intent receiver activity doesn't exist, etc)
  void startShortcut_1(ShortcutInfo shortcut, jni.JlObject sourceBounds,
          os.Bundle startActivityOptions) =>
      _startShortcut_1(reference, shortcut.reference, sourceBounds.reference,
          startActivityOptions.reference);

  static final _registerCallback = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_registerCallback")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerCallback(android.content.pm.LauncherApps.Callback callback)
  /// Registers a callback for changes to packages in current and managed profiles.
  ///@param callback The callback to register.
  void registerCallback(LauncherApps_Callback callback) =>
      _registerCallback(reference, callback.reference);

  static final _registerCallback_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_registerCallback_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void registerCallback(android.content.pm.LauncherApps.Callback callback, android.os.Handler handler)
  /// Registers a callback for changes to packages in current and managed profiles.
  ///@param callback The callback to register.
  ///@param handler that should be used to post callbacks on, may be null.
  void registerCallback_1(LauncherApps_Callback callback, os.Handler handler) =>
      _registerCallback_1(reference, callback.reference, handler.reference);

  static final _unregisterCallback = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_unregisterCallback")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterCallback(android.content.pm.LauncherApps.Callback callback)
  /// Unregisters a callback that was previously registered.
  ///@param callback The callback to unregister.
  ///@see \#registerCallback(Callback)
  void unregisterCallback(LauncherApps_Callback callback) =>
      _unregisterCallback(reference, callback.reference);

  static final _getPinItemRequest = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps_getPinItemRequest")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.LauncherApps.PinItemRequest getPinItemRequest(android.content.Intent intent)
  /// A helper method to extract a PinItemRequest set to
  /// the \#EXTRA_PIN_ITEM_REQUEST extra.
  LauncherApps_PinItemRequest getPinItemRequest(content.Intent intent) =>
      LauncherApps_PinItemRequest.fromRef(
          _getPinItemRequest(reference, intent.reference));
}

/// Represents a query passed to \#getShortcuts(ShortcutQuery, UserHandle).
class LauncherApps_ShortcutQuery extends jni.JlObject {
  LauncherApps_ShortcutQuery.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final int FLAG_GET_KEY_FIELDS_ONLY
  /// Requests "key" fields only.  See ShortcutInfo\#hasKeyFieldsOnly()'s javadoc to
  /// see which fields fields "key".
  /// This allows quicker access to shortcut information in order to
  /// determine whether the caller's in-memory cache needs to be updated.
  ///
  /// Typically, launcher applications cache all or most shortcut information
  /// in memory in order to show shortcuts without a delay.
  ///
  /// When a given launcher application wants to update its cache, such as when its process
  /// restarts, it can fetch shortcut information with this flag.
  /// The application can then check ShortcutInfo\#getLastChangedTimestamp() for each
  /// shortcut, fetching a shortcut's non-key information only if that shortcut has been
  /// updated.
  ///@see ShortcutManager
  static const FLAG_GET_KEY_FIELDS_ONLY = 4;

  /// from: static public final int FLAG_MATCH_DYNAMIC
  /// Include dynamic shortcuts in the result.
  static const FLAG_MATCH_DYNAMIC = 1;

  /// from: static public final int FLAG_MATCH_MANIFEST
  /// Include manifest shortcuts in the result.
  static const FLAG_MATCH_MANIFEST = 8;

  /// from: static public final int FLAG_MATCH_PINNED
  /// Include pinned shortcuts in the result.
  ///
  /// If you are the selected assistant app, and wishes to fetch all shortcuts that the
  /// user owns on the launcher (or by other launchers, in case the user has multiple), use
  /// \#FLAG_MATCH_PINNED_BY_ANY_LAUNCHER instead.
  ///
  /// If you're a regular launcher app, there's no way to get shortcuts pinned by other
  /// launchers, and \#FLAG_MATCH_PINNED_BY_ANY_LAUNCHER will be ignored. So use this
  /// flag to get own pinned shortcuts.
  static const FLAG_MATCH_PINNED = 2;

  /// from: static public final int FLAG_MATCH_PINNED_BY_ANY_LAUNCHER
  /// Include all pinned shortcuts by any launchers, not just by the caller,
  /// in the result.
  ///
  /// The caller must be the selected assistant app to use this flag, or have the system
  /// {@code ACCESS_SHORTCUTS} permission.
  ///
  /// If you are the selected assistant app, and wishes to fetch all shortcuts that the
  /// user owns on the launcher (or by other launchers, in case the user has multiple), use
  /// \#FLAG_MATCH_PINNED_BY_ANY_LAUNCHER instead.
  ///
  /// If you're a regular launcher app (or any app that's not the selected assistant app)
  /// then this flag will be ignored.
  static const FLAG_MATCH_PINNED_BY_ANY_LAUNCHER = 1024;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_LauncherApps__ShortcutQuery_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  LauncherApps_ShortcutQuery() : super.fromRef(_ctor());

  static final _setChangedSince = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "android_content_pm_LauncherApps__ShortcutQuery_setChangedSince")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.pm.LauncherApps.ShortcutQuery setChangedSince(long changedSince)
  /// If non-zero, returns only shortcuts that have been added or updated
  /// since the given timestamp, expressed in milliseconds since the Epoch&mdash;see
  /// System\#currentTimeMillis().
  LauncherApps_ShortcutQuery setChangedSince(int changedSince) =>
      LauncherApps_ShortcutQuery.fromRef(
          _setChangedSince(reference, changedSince));

  static final _setPackage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps__ShortcutQuery_setPackage")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.LauncherApps.ShortcutQuery setPackage(java.lang.String packageName)
  /// If non-null, returns only shortcuts from the package.
  ///@param packageName This value may be {@code null}.
  LauncherApps_ShortcutQuery setPackage(jni.JlString packageName) =>
      LauncherApps_ShortcutQuery.fromRef(
          _setPackage(reference, packageName.reference));

  static final _setShortcutIds = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps__ShortcutQuery_setShortcutIds")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.LauncherApps.ShortcutQuery setShortcutIds(java.util.List<java.lang.String> shortcutIds)
  /// If non-null, return only the specified shortcuts by ID.  When setting this field,
  /// a package name must also be set with \#setPackage.
  ///@param shortcutIds This value may be {@code null}.
  LauncherApps_ShortcutQuery setShortcutIds(jni.JlObject shortcutIds) =>
      LauncherApps_ShortcutQuery.fromRef(
          _setShortcutIds(reference, shortcutIds.reference));

  static final _setActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps__ShortcutQuery_setActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.LauncherApps.ShortcutQuery setActivity(android.content.ComponentName activity)
  /// If non-null, returns only shortcuts associated with the activity; i.e.
  /// ShortcutInfos whose ShortcutInfo\#getActivity() are equal
  /// to {@code activity}.
  ///@param activity This value may be {@code null}.
  LauncherApps_ShortcutQuery setActivity(content.ComponentName activity) =>
      LauncherApps_ShortcutQuery.fromRef(
          _setActivity(reference, activity.reference));

  static final _setQueryFlags = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_LauncherApps__ShortcutQuery_setQueryFlags")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.pm.LauncherApps.ShortcutQuery setQueryFlags(int queryFlags)
  /// Set query options.  At least one of the {@code MATCH} flags should be set.  Otherwise,
  /// no shortcuts will be returned.
  ///
  /// <ul>
  ///     <li>\#FLAG_MATCH_DYNAMIC
  ///     <li>\#FLAG_MATCH_PINNED
  ///     <li>\#FLAG_MATCH_MANIFEST
  ///     <li>\#FLAG_GET_KEY_FIELDS_ONLY
  /// </ul>
  ///@param queryFlags Value is either <code>0</code> or a combination of android.content.pm.LauncherApps.ShortcutQuery\#FLAG_MATCH_DYNAMIC, android.content.pm.LauncherApps.ShortcutQuery\#FLAG_MATCH_PINNED, android.content.pm.LauncherApps.ShortcutQuery\#FLAG_MATCH_MANIFEST, android.content.pm.LauncherApps.ShortcutQuery\#FLAG_GET_KEY_FIELDS_ONLY, and android.content.pm.LauncherApps.ShortcutQuery\#FLAG_MATCH_MANIFEST
  LauncherApps_ShortcutQuery setQueryFlags(int queryFlags) =>
      LauncherApps_ShortcutQuery.fromRef(_setQueryFlags(reference, queryFlags));
}

/// Represents a "pin shortcut" or a "pin appwidget" request made by an app, which is sent with
/// an \#ACTION_CONFIRM_PIN_SHORTCUT or \#ACTION_CONFIRM_PIN_APPWIDGET intent
/// respectively to the default launcher app.
///
/// <h3>Request of the \#REQUEST_TYPE_SHORTCUT type.
///
/// A \#REQUEST_TYPE_SHORTCUT request represents a request to pin a
/// ShortcutInfo.  If the launcher accepts a request, call \#accept(),
/// or \#accept(Bundle) with a null or empty Bundle.  No options are defined for
/// pin-shortcuts requests.
///
/// \#getShortcutInfo() always returns a non-null ShortcutInfo for this type.
///
/// The launcher may receive a request with a ShortcutInfo that is already pinned, in
/// which case ShortcutInfo\#isPinned() returns true.  This means the user wants to create
/// another pinned shortcut for a shortcut that's already pinned.  If the launcher accepts it,
/// \#accept() must still be called even though the shortcut is already pinned, and
/// create a new pinned shortcut icon for it.
///
/// See also ShortcutManager for more details.
///
/// <h3>Request of the \#REQUEST_TYPE_APPWIDGET type.
///
/// A \#REQUEST_TYPE_SHORTCUT request represents a request to pin a
/// an AppWidget.  If the launcher accepts a request, call \#accept(Bundle) with
/// the appwidget integer ID set to the
/// android.appwidget.AppWidgetManager\#EXTRA_APPWIDGET_ID extra.
///
/// \#getAppWidgetProviderInfo(Context) always returns a non-null
/// AppWidgetProviderInfo for this type.
///
/// See also AppWidgetManager for more details.
///@see \#EXTRA_PIN_ITEM_REQUEST
///@see \#getPinItemRequest(Intent)
class LauncherApps_PinItemRequest extends jni.JlObject {
  LauncherApps_PinItemRequest.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.LauncherApps.PinItemRequest> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_LauncherApps__PinItemRequest_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int REQUEST_TYPE_APPWIDGET
  /// This is a request to pin app widget.
  static const REQUEST_TYPE_APPWIDGET = 2;

  /// from: static public final int REQUEST_TYPE_SHORTCUT
  /// This is a request to pin shortcut.
  static const REQUEST_TYPE_SHORTCUT = 1;

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps__PinItemRequest_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Parcel source)
  LauncherApps_PinItemRequest(os.Parcel source)
      : super.fromRef(_ctor(source.reference));

  static final _getRequestType =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_LauncherApps__PinItemRequest_getRequestType")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getRequestType()
  /// Represents the type of a request, which is one of the {@code REQUEST_TYPE_} constants.
  ///@return one of the {@code REQUEST_TYPE_} constants.
  ///
  /// Value is android.content.pm.LauncherApps.PinItemRequest\#REQUEST_TYPE_SHORTCUT, or android.content.pm.LauncherApps.PinItemRequest\#REQUEST_TYPE_APPWIDGET
  int getRequestType() => _getRequestType(reference);

  static final _getShortcutInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps__PinItemRequest_getShortcutInfo")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ShortcutInfo getShortcutInfo()
  /// ShortcutInfo sent by the requesting app.
  /// Always non-null for a \#REQUEST_TYPE_SHORTCUT request, and always null for a
  /// different request type.
  ///@return requested ShortcutInfo when a request is of the
  /// \#REQUEST_TYPE_SHORTCUT type.  Null otherwise.
  ShortcutInfo getShortcutInfo() =>
      ShortcutInfo.fromRef(_getShortcutInfo(reference));

  static final _getAppWidgetProviderInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps__PinItemRequest_getAppWidgetProviderInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.appwidget.AppWidgetProviderInfo getAppWidgetProviderInfo(android.content.Context context)
  /// AppWidgetProviderInfo sent by the requesting app.
  /// Always non-null for a \#REQUEST_TYPE_APPWIDGET request, and always null for a
  /// different request type.
  ///
  /// Launcher should not show any configuration activity associated with the provider, and
  /// assume that the widget is already fully configured. Upon accepting the widget, it should
  /// pass the widgetId in \#accept(Bundle).
  ///@return requested AppWidgetProviderInfo when a request is of the
  /// \#REQUEST_TYPE_APPWIDGET type.  Null otherwise.
  jni.JlObject getAppWidgetProviderInfo(content.Context context) =>
      jni.JlObject.fromRef(
          _getAppWidgetProviderInfo(reference, context.reference));

  static final _getExtras = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps__PinItemRequest_getExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getExtras()
  /// Any extras sent by the requesting app.
  ///@return For a shortcut request, this method always return null.  For an AppWidget
  /// request, this method returns the extras passed to the
  /// android.appwidget.AppWidgetManager\#requestPinAppWidget(
  /// ComponentName, Bundle, PendingIntent) API.  See AppWidgetManager for details.
  os.Bundle getExtras() => os.Bundle.fromRef(_getExtras(reference));

  static final _isValid =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_LauncherApps__PinItemRequest_isValid")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isValid()
  /// Return whether a request is still valid.
  ///@return {@code TRUE} if a request is valid and \#accept(Bundle) may be called.
  bool isValid() => _isValid(reference) != 0;

  static final _accept = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps__PinItemRequest_accept")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean accept(android.os.Bundle options)
  /// Called by the receiving launcher app when the user accepts the request.
  ///@param options must be set for a \#REQUEST_TYPE_APPWIDGET request.
  ///
  /// This value may be {@code null}.
  ///@return {@code TRUE} if the shortcut or the AppWidget has actually been pinned.
  /// {@code FALSE} if the item hasn't been pinned, for example, because the request had
  /// already been canceled, in which case the launcher must not pin the requested item.
  bool accept(os.Bundle options) => _accept(reference, options.reference) != 0;

  static final _accept_1 =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_LauncherApps__PinItemRequest_accept_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean accept()
  /// Called by the receiving launcher app when the user accepts the request, with no options.
  ///@return {@code TRUE} if the shortcut or the AppWidget has actually been pinned.
  /// {@code FALSE} if the item hasn't been pinned, for example, because the request had
  /// already been canceled, in which case the launcher must not pin the requested item.
  bool accept_1() => _accept_1(reference) != 0;

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_LauncherApps__PinItemRequest_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _describeContents = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps__PinItemRequest_describeContents")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);
}

/// Callbacks for package changes to this and related managed profiles.
class LauncherApps_Callback extends jni.JlObject {
  LauncherApps_Callback.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_LauncherApps__Callback_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  LauncherApps_Callback() : super.fromRef(_ctor());

  static final _onPackageRemoved = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps__Callback_onPackageRemoved")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onPackageRemoved(java.lang.String packageName, android.os.UserHandle user)
  /// Indicates that a package was removed from the specified profile.
  ///
  /// If a package is removed while being updated onPackageChanged will be
  /// called instead.
  ///@param packageName The name of the package that was removed.
  ///@param user The UserHandle of the profile that generated the change.
  void onPackageRemoved(jni.JlString packageName, os.UserHandle user) =>
      _onPackageRemoved(reference, packageName.reference, user.reference);

  static final _onPackageAdded = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps__Callback_onPackageAdded")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onPackageAdded(java.lang.String packageName, android.os.UserHandle user)
  /// Indicates that a package was added to the specified profile.
  ///
  /// If a package is added while being updated then onPackageChanged will be
  /// called instead.
  ///@param packageName The name of the package that was added.
  ///@param user The UserHandle of the profile that generated the change.
  void onPackageAdded(jni.JlString packageName, os.UserHandle user) =>
      _onPackageAdded(reference, packageName.reference, user.reference);

  static final _onPackageChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps__Callback_onPackageChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onPackageChanged(java.lang.String packageName, android.os.UserHandle user)
  /// Indicates that a package was modified in the specified profile.
  /// This can happen, for example, when the package is updated or when
  /// one or more components are enabled or disabled.
  ///@param packageName The name of the package that has changed.
  ///@param user The UserHandle of the profile that generated the change.
  void onPackageChanged(jni.JlString packageName, os.UserHandle user) =>
      _onPackageChanged(reference, packageName.reference, user.reference);

  static final _onPackagesAvailable = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Uint8)>>(
          "android_content_pm_LauncherApps__Callback_onPackagesAvailable")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void onPackagesAvailable(java.lang.String[] packageNames, android.os.UserHandle user, boolean replacing)
  /// Indicates that one or more packages have become available. For
  /// example, this can happen when a removable storage card has
  /// reappeared.
  ///@param packageNames The names of the packages that have become
  ///            available.
  ///@param user The UserHandle of the profile that generated the change.
  ///@param replacing Indicates whether these packages are replacing
  ///            existing ones.
  void onPackagesAvailable(
          jni.JlObject packageNames, os.UserHandle user, bool replacing) =>
      _onPackagesAvailable(
          reference, packageNames.reference, user.reference, replacing ? 1 : 0);

  static final _onPackagesUnavailable = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Uint8)>>(
          "android_content_pm_LauncherApps__Callback_onPackagesUnavailable")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void onPackagesUnavailable(java.lang.String[] packageNames, android.os.UserHandle user, boolean replacing)
  /// Indicates that one or more packages have become unavailable. For
  /// example, this can happen when a removable storage card has been
  /// removed.
  ///@param packageNames The names of the packages that have become
  ///            unavailable.
  ///@param user The UserHandle of the profile that generated the change.
  ///@param replacing Indicates whether the packages are about to be
  ///            replaced with new versions.
  void onPackagesUnavailable(
          jni.JlObject packageNames, os.UserHandle user, bool replacing) =>
      _onPackagesUnavailable(
          reference, packageNames.reference, user.reference, replacing ? 1 : 0);

  static final _onPackagesSuspended = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps__Callback_onPackagesSuspended")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onPackagesSuspended(java.lang.String[] packageNames, android.os.UserHandle user)
  /// Indicates that one or more packages have been suspended. For
  /// example, this can happen when a Device Administrator suspends
  /// an applicaton.
  ///
  /// Note: On devices running android.os.Build.VERSION_CODES\#P Android P or higher,
  /// any apps that override \#onPackagesSuspended(String[], UserHandle, Bundle) will
  /// not receive this callback.
  ///@param packageNames The names of the packages that have just been
  ///            suspended.
  ///@param user The UserHandle of the profile that generated the change.
  void onPackagesSuspended(jni.JlObject packageNames, os.UserHandle user) =>
      _onPackagesSuspended(reference, packageNames.reference, user.reference);

  static final _onPackagesSuspended_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps__Callback_onPackagesSuspended_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPackagesSuspended(java.lang.String[] packageNames, android.os.UserHandle user, android.os.Bundle launcherExtras)
  /// Indicates that one or more packages have been suspended. A device administrator or an app
  /// with {@code android.permission.SUSPEND_APPS} can do this.
  ///
  /// A suspending app with the permission {@code android.permission.SUSPEND_APPS} can
  /// optionally provide a Bundle of extra information that it deems helpful for the
  /// launcher to handle the suspended state of these packages. The contents of this
  /// Bundle are supposed to be a contract between the suspending app and the launcher.
  ///@param packageNames The names of the packages that have just been suspended.
  ///@param user the user for which the given packages were suspended.
  ///@param launcherExtras A Bundle of extras for the launcher, if provided to the
  ///                      system, {@code null} otherwise.
  /// This value may be {@code null}.
  ///@see PackageManager\#isPackageSuspended()
  ///@see \#getSuspendedPackageLauncherExtras(String, UserHandle)
  void onPackagesSuspended_1(jni.JlObject packageNames, os.UserHandle user,
          os.Bundle launcherExtras) =>
      _onPackagesSuspended_1(reference, packageNames.reference, user.reference,
          launcherExtras.reference);

  static final _onPackagesUnsuspended = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps__Callback_onPackagesUnsuspended")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onPackagesUnsuspended(java.lang.String[] packageNames, android.os.UserHandle user)
  /// Indicates that one or more packages have been unsuspended. For
  /// example, this can happen when a Device Administrator unsuspends
  /// an applicaton.
  ///@param packageNames The names of the packages that have just been
  ///            unsuspended.
  ///@param user The UserHandle of the profile that generated the change.
  void onPackagesUnsuspended(jni.JlObject packageNames, os.UserHandle user) =>
      _onPackagesUnsuspended(reference, packageNames.reference, user.reference);

  static final _onShortcutsChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherApps__Callback_onShortcutsChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onShortcutsChanged(java.lang.String packageName, java.util.List<android.content.pm.ShortcutInfo> shortcuts, android.os.UserHandle user)
  /// Indicates that one or more shortcuts of any kind (dynamic, pinned, or manifest)
  /// have been added, updated or removed.
  ///
  /// Only the applications that are allowed to access the shortcut information,
  /// as defined in \#hasShortcutHostPermission(), will receive it.
  ///@param packageName The name of the package that has the shortcuts.
  /// This value must never be {@code null}.
  ///@param shortcuts All shortcuts from the package (dynamic, manifest and/or pinned).
  ///    Only "key" information will be provided, as defined in
  ///    ShortcutInfo\#hasKeyFieldsOnly().
  /// This value must never be {@code null}.
  ///@param user The UserHandle of the profile that generated the change.
  ///
  /// This value must never be {@code null}.
  ///@see ShortcutManager
  void onShortcutsChanged(jni.JlString packageName, jni.JlObject shortcuts,
          os.UserHandle user) =>
      _onShortcutsChanged(reference, packageName.reference, shortcuts.reference,
          user.reference);
}

/// A set of features that can be requested by an application. This corresponds
/// to information collected from the
/// AndroidManifest.xml's {@code <feature-group>} tag.
class FeatureGroupInfo extends jni.JlObject {
  FeatureGroupInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.FeatureGroupInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_FeatureGroupInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: public android.content.pm.FeatureInfo[] features
  /// The list of features that are required by this group.
  ///@see FeatureInfo\#FLAG_REQUIRED
  static final _getfeatures = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_FeatureGroupInfo_features")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get features => jni.JlObject.fromRef(_getfeatures(reference));
  static final _setfeatures = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_FeatureGroupInfo_features")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set features(jni.JlObject value) => _setfeatures(reference, value.reference);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_FeatureGroupInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  FeatureGroupInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_FeatureGroupInfo_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.pm.FeatureGroupInfo other)
  FeatureGroupInfo.ctor_1(FeatureGroupInfo other)
      : super.fromRef(_ctor_1(other.reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_FeatureGroupInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_FeatureGroupInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);
}

/// Information pertaining to the signing certificates used to sign a package.
class SigningInfo extends jni.JlObject {
  SigningInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.SigningInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_SigningInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_SigningInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  SigningInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_SigningInfo_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.pm.SigningInfo orig)
  SigningInfo.ctor_1(SigningInfo orig) : super.fromRef(_ctor_1(orig.reference));

  static final _hasMultipleSigners =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_SigningInfo_hasMultipleSigners")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasMultipleSigners()
  /// Although relatively uncommon, packages may be signed by more than one signer, in which case
  /// their identity is viewed as being the set of all signers, not just any one.
  bool hasMultipleSigners() => _hasMultipleSigners(reference) != 0;

  static final _hasPastSigningCertificates =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_SigningInfo_hasPastSigningCertificates")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasPastSigningCertificates()
  /// APK Signature Scheme v3 enables packages to provide a proof-of-rotation record that the
  /// platform verifies, and uses, to allow the use of new signing certificates.  This is only
  /// available to packages that are not signed by multiple signers.  In the event of a change to a
  /// new signing certificate, the package's past signing certificates are presented as well.  Any
  /// check of a package's signing certificate should also include a search through its entire
  /// signing history, since it could change to a new signing certificate at any time.
  bool hasPastSigningCertificates() =>
      _hasPastSigningCertificates(reference) != 0;

  static final _getSigningCertificateHistory = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_SigningInfo_getSigningCertificateHistory")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.Signature[] getSigningCertificateHistory()
  /// Returns the signing certificates this package has proven it is authorized to use. This
  /// includes both the signing certificate associated with the signer of the package and the past
  /// signing certificates it included as its proof of signing certificate rotation.  This method
  /// is the preferred replacement for the {@code GET_SIGNATURES} flag used with PackageManager\#getPackageInfo(String, int).  When determining if a package is signed by a
  /// desired certificate, the returned array should be checked to determine if it is one of the
  /// entries.
  ///
  /// <note>
  ///     This method returns null if the package is signed by multiple signing certificates, as
  ///     opposed to being signed by one current signer and also providing the history of past
  ///     signing certificates.  \#hasMultipleSigners() may be used to determine if this
  ///     package is signed by multiple signers.  Packages which are signed by multiple signers
  ///     cannot change their signing certificates and their {@code Signature} array should be
  ///     checked to make sure that every entry matches the looked-for signing certificates.
  /// </note>
  jni.JlObject getSigningCertificateHistory() =>
      jni.JlObject.fromRef(_getSigningCertificateHistory(reference));

  static final _getApkContentsSigners = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_SigningInfo_getApkContentsSigners")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.Signature[] getApkContentsSigners()
  /// Returns the signing certificates used to sign the APK contents of this application.  Not
  /// including any past signing certificates the package proved it is authorized to use.
  /// <note>
  ///     This method should not be used unless \#hasMultipleSigners() returns true,
  ///     indicating that \#getSigningCertificateHistory() cannot be used, otherwise \#getSigningCertificateHistory() should be preferred.
  /// </note>
  jni.JlObject getApkContentsSigners() =>
      jni.JlObject.fromRef(_getApkContentsSigners(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_SigningInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_pm_SigningInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(os.Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags);
}

/// Information you can retrieve about a particular security permission
/// known to the system.  This corresponds to information collected from the
/// AndroidManifest.xml's &lt;permission&gt; tags.
class PermissionInfo extends PackageItemInfo {
  PermissionInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.PermissionInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_PermissionInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int FLAG_COSTS_MONEY
  /// Flag for \#flags, corresponding to <code>costsMoney</code>
  /// value of android.R.attr\#permissionFlags.
  static const FLAG_COSTS_MONEY = 1;

  /// from: static public final int FLAG_INSTALLED
  /// Flag for \#flags, indicating that this permission has been
  /// installed into the system's globally defined permissions.
  static const FLAG_INSTALLED = 1073741824;

  /// from: static public final int PROTECTION_DANGEROUS
  /// Dangerous value for \#protectionLevel, corresponding
  /// to the <code>dangerous</code> value of
  /// android.R.attr\#protectionLevel.
  static const PROTECTION_DANGEROUS = 1;

  /// from: static public final int PROTECTION_FLAG_APPOP
  /// Additional flag for \#protectionLevel, corresponding
  /// to the <code>appop</code> value of
  /// android.R.attr\#protectionLevel.
  static const PROTECTION_FLAG_APPOP = 64;

  /// from: static public final int PROTECTION_FLAG_DEVELOPMENT
  /// Additional flag for \#protectionLevel, corresponding
  /// to the <code>development</code> value of
  /// android.R.attr\#protectionLevel.
  static const PROTECTION_FLAG_DEVELOPMENT = 32;

  /// from: static public final int PROTECTION_FLAG_INSTALLER
  /// Additional flag for \#protectionLevel, corresponding
  /// to the <code>installer</code> value of
  /// android.R.attr\#protectionLevel.
  static const PROTECTION_FLAG_INSTALLER = 256;

  /// from: static public final int PROTECTION_FLAG_INSTANT
  /// Additional flag for \#protectionLevel, corresponding
  /// to the <code>instant</code> value of
  /// android.R.attr\#protectionLevel.
  static const PROTECTION_FLAG_INSTANT = 4096;

  /// from: static public final int PROTECTION_FLAG_PRE23
  /// Additional flag for \#protectionLevel, corresponding
  /// to the <code>pre23</code> value of
  /// android.R.attr\#protectionLevel.
  static const PROTECTION_FLAG_PRE23 = 128;

  /// from: static public final int PROTECTION_FLAG_PREINSTALLED
  /// Additional flag for \#protectionLevel, corresponding
  /// to the <code>preinstalled</code> value of
  /// android.R.attr\#protectionLevel.
  static const PROTECTION_FLAG_PREINSTALLED = 1024;

  /// from: static public final int PROTECTION_FLAG_PRIVILEGED
  /// Additional flag for \#protectionLevel, corresponding
  /// to the <code>privileged</code> value of
  /// android.R.attr\#protectionLevel.
  static const PROTECTION_FLAG_PRIVILEGED = 16;

  /// from: static public final int PROTECTION_FLAG_RUNTIME_ONLY
  /// Additional flag for \#protectionLevel, corresponding
  /// to the <code>runtime</code> value of
  /// android.R.attr\#protectionLevel.
  static const PROTECTION_FLAG_RUNTIME_ONLY = 8192;

  /// from: static public final int PROTECTION_FLAG_SETUP
  /// Additional flag for \#protectionLevel, corresponding
  /// to the <code>setup</code> value of
  /// android.R.attr\#protectionLevel.
  static const PROTECTION_FLAG_SETUP = 2048;

  /// from: static public final int PROTECTION_FLAG_SYSTEM
  /// @deprecated Old name for \#PROTECTION_FLAG_PRIVILEGED, which
  /// is now very confusing because it only applies to privileged apps, not all
  /// apps on the system image.
  static const PROTECTION_FLAG_SYSTEM = 16;

  /// from: static public final int PROTECTION_FLAG_VERIFIER
  /// Additional flag for \#protectionLevel, corresponding
  /// to the <code>verifier</code> value of
  /// android.R.attr\#protectionLevel.
  static const PROTECTION_FLAG_VERIFIER = 512;

  /// from: static public final int PROTECTION_MASK_BASE
  /// Mask for \#protectionLevel: the basic protection type.
  ///@deprecated Use \#getProtection() instead.
  static const PROTECTION_MASK_BASE = 15;

  /// from: static public final int PROTECTION_MASK_FLAGS
  /// Mask for \#protectionLevel: additional flag bits.
  ///@deprecated Use \#getProtectionFlags() instead.
  static const PROTECTION_MASK_FLAGS = 65520;

  /// from: static public final int PROTECTION_NORMAL
  /// A normal application value for \#protectionLevel, corresponding
  /// to the <code>normal</code> value of
  /// android.R.attr\#protectionLevel.
  static const PROTECTION_NORMAL = 0;

  /// from: static public final int PROTECTION_SIGNATURE
  /// System-level value for \#protectionLevel, corresponding
  /// to the <code>signature</code> value of
  /// android.R.attr\#protectionLevel.
  static const PROTECTION_SIGNATURE = 2;

  /// from: static public final int PROTECTION_SIGNATURE_OR_SYSTEM
  /// @deprecated Use \#PROTECTION_SIGNATURE|\#PROTECTION_FLAG_PRIVILEGED
  /// instead.
  static const PROTECTION_SIGNATURE_OR_SYSTEM = 3;

  /// from: public int descriptionRes
  /// A string resource identifier (in the package's resources) of this
  /// permission's description.  From the "description" attribute or,
  /// if not set, 0.
  static final _getdescriptionRes = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PermissionInfo_descriptionRes")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get descriptionRes => _getdescriptionRes(reference);
  static final _setdescriptionRes = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_PermissionInfo_descriptionRes")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set descriptionRes(int value) => _setdescriptionRes(reference, value);

  /// from: public int flags
  /// Additional flags about this permission as given by
  /// android.R.attr\#permissionFlags.
  static final _getflags = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PermissionInfo_flags")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get flags => _getflags(reference);
  static final _setflags = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_PermissionInfo_flags")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set flags(int value) => _setflags(reference, value);

  /// from: public java.lang.String group
  /// The group this permission is a part of, as per
  /// android.R.attr\#permissionGroup.
  static final _getgroup = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PermissionInfo_group")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get group => jni.JlString.fromRef(_getgroup(reference));
  static final _setgroup = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PermissionInfo_group")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set group(jni.JlString value) => _setgroup(reference, value.reference);

  /// from: public java.lang.CharSequence nonLocalizedDescription
  /// The description string provided in the AndroidManifest file, if any.  You
  /// probably don't want to use this, since it will be null if the description
  /// is in a resource.  You probably want
  /// PermissionInfo\#loadDescription instead.
  static final _getnonLocalizedDescription = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PermissionInfo_nonLocalizedDescription")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get nonLocalizedDescription =>
      jni.JlObject.fromRef(_getnonLocalizedDescription(reference));
  static final _setnonLocalizedDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PermissionInfo_nonLocalizedDescription")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set nonLocalizedDescription(jni.JlObject value) =>
      _setnonLocalizedDescription(reference, value.reference);

  /// from: public int protectionLevel
  /// The level of access this permission is protecting, as per
  /// android.R.attr\#protectionLevel. Consists of
  /// a base permission type and zero or more flags. Use the following functions
  /// to extract them.
  ///
  /// <pre>
  /// int basePermissionType = permissionInfo.getProtection();
  /// int permissionFlags = permissionInfo.getProtectionFlags();
  /// </pre>
  ///
  ///
  ///Base permission types are \#PROTECTION_NORMAL,
  /// \#PROTECTION_DANGEROUS, \#PROTECTION_SIGNATURE
  /// and the deprecated \#PROTECTION_SIGNATURE_OR_SYSTEM.
  /// Flags are listed under android.R.attr\#protectionLevel.
  ///@deprecated Use \#getProtection() and \#getProtectionFlags() instead.
  static final _getprotectionLevel = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PermissionInfo_protectionLevel")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get protectionLevel => _getprotectionLevel(reference);
  static final _setprotectionLevel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_PermissionInfo_protectionLevel")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set protectionLevel(int value) => _setprotectionLevel(reference, value);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_PermissionInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  PermissionInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PermissionInfo_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.pm.PermissionInfo orig)
  PermissionInfo.ctor_1(PermissionInfo orig)
      : super.fromRef(_ctor_1(orig.reference));

  static final _loadDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PermissionInfo_loadDescription")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence loadDescription(android.content.pm.PackageManager pm)
  /// Retrieve the textual description of this permission.  This
  /// will call back on the given PackageManager to load the description from
  /// the application.
  ///@param pm A PackageManager from which the label can be loaded; usually
  /// the PackageManager from which you originally retrieved this item.
  ///@return Returns a CharSequence containing the permission's description.
  /// If there is no description, null is returned.
  jni.JlObject loadDescription(PackageManager pm) =>
      jni.JlObject.fromRef(_loadDescription(reference, pm.reference));

  static final _getProtection =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PermissionInfo_getProtection")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getProtection()
  /// Return the base permission type.
  ///@return Value is android.content.pm.PermissionInfo\#PROTECTION_NORMAL, android.content.pm.PermissionInfo\#PROTECTION_DANGEROUS, android.content.pm.PermissionInfo\#PROTECTION_SIGNATURE, or android.content.pm.PermissionInfo\#PROTECTION_SIGNATURE_OR_SYSTEM
  int getProtection() => _getProtection(reference);

  static final _getProtectionFlags =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PermissionInfo_getProtectionFlags")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getProtectionFlags()
  /// Return the additional flags in \#protectionLevel.
  ///@return Value is either <code>0</code> or a combination of android.content.pm.PermissionInfo\#PROTECTION_FLAG_PRIVILEGED, android.content.pm.PermissionInfo\#PROTECTION_FLAG_SYSTEM, android.content.pm.PermissionInfo\#PROTECTION_FLAG_DEVELOPMENT, android.content.pm.PermissionInfo\#PROTECTION_FLAG_APPOP, android.content.pm.PermissionInfo\#PROTECTION_FLAG_PRE23, android.content.pm.PermissionInfo\#PROTECTION_FLAG_INSTALLER, android.content.pm.PermissionInfo\#PROTECTION_FLAG_VERIFIER, android.content.pm.PermissionInfo\#PROTECTION_FLAG_PREINSTALLED, android.content.pm.PermissionInfo\#PROTECTION_FLAG_SETUP, android.content.pm.PermissionInfo\#PROTECTION_FLAG_INSTANT, android.content.pm.PermissionInfo\#PROTECTION_FLAG_RUNTIME_ONLY, android.content.pm.PermissionInfo.PROTECTION_FLAG_OEM, android.content.pm.PermissionInfo.PROTECTION_FLAG_VENDOR_PRIVILEGED, and android.content.pm.PermissionInfo.PROTECTION_FLAG_SYSTEM_TEXT_CLASSIFIER
  int getProtectionFlags() => _getProtectionFlags(reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PermissionInfo_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PermissionInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PermissionInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(os.Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags);
}

/// Information you can retrieve about a particular application
/// service. This corresponds to information collected from the
/// AndroidManifest.xml's &lt;service&gt; tags.
class ServiceInfo extends ComponentInfo {
  ServiceInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.ServiceInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_ServiceInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int FLAG_EXTERNAL_SERVICE
  /// Bit in \#flags: If set, the service can be bound and run in the
  /// calling application's package, rather than the package in which it is
  /// declared.  Set from android.R.attr\#externalService attribute.
  static const FLAG_EXTERNAL_SERVICE = 4;

  /// from: static public final int FLAG_ISOLATED_PROCESS
  /// Bit in \#flags: If set, the service will run in its own
  /// isolated process.  Set from the
  /// android.R.attr\#isolatedProcess attribute.
  static const FLAG_ISOLATED_PROCESS = 2;

  /// from: static public final int FLAG_SINGLE_USER
  /// Bit in \#flags: If set, a single instance of the service will
  /// run for all users on the device.  Set from the
  /// android.R.attr\#singleUser attribute.
  static const FLAG_SINGLE_USER = 1073741824;

  /// from: static public final int FLAG_STOP_WITH_TASK
  /// Bit in \#flags: If set, the service will automatically be
  /// stopped by the system if the user removes a task that is rooted
  /// in one of the application's activities.  Set from the
  /// android.R.attr\#stopWithTask attribute.
  static const FLAG_STOP_WITH_TASK = 1;

  /// from: public int flags
  /// Options that have been set in the service declaration in the
  /// manifest.
  /// These include:
  /// \#FLAG_STOP_WITH_TASK, \#FLAG_ISOLATED_PROCESS,
  /// \#FLAG_SINGLE_USER.
  static final _getflags = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ServiceInfo_flags")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get flags => _getflags(reference);
  static final _setflags = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_ServiceInfo_flags")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set flags(int value) => _setflags(reference, value);

  /// from: public java.lang.String permission
  /// Optional name of a permission required to be able to access this
  /// Service.  From the "permission" attribute.
  static final _getpermission = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ServiceInfo_permission")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get permission =>
      jni.JlString.fromRef(_getpermission(reference));
  static final _setpermission = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ServiceInfo_permission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set permission(jni.JlString value) =>
      _setpermission(reference, value.reference);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_ServiceInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ServiceInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ServiceInfo_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.pm.ServiceInfo orig)
  ServiceInfo.ctor_1(ServiceInfo orig) : super.fromRef(_ctor_1(orig.reference));

  static final _dump = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ServiceInfo_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  void dump(jni.JlObject pw, jni.JlString prefix) =>
      _dump(reference, pw.reference, prefix.reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ServiceInfo_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ServiceInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_pm_ServiceInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(os.Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags);
}

/// This class provides information for a shared library. There are
/// three types of shared libraries: builtin - non-updatable part of
/// the OS; dynamic - updatable backwards-compatible dynamically linked;
/// static - updatable non backwards-compatible emulating static linking.
class SharedLibraryInfo extends jni.JlObject {
  SharedLibraryInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.SharedLibraryInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_SharedLibraryInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int TYPE_BUILTIN
  /// Shared library type: this library is a part of the OS
  /// and cannot be updated or uninstalled.
  static const TYPE_BUILTIN = 0;

  /// from: static public final int TYPE_DYNAMIC
  /// Shared library type: this library is backwards-compatible, can
  /// be updated, and updates can be uninstalled. Clients link against
  /// the latest version of the library.
  static const TYPE_DYNAMIC = 1;

  /// from: static public final int TYPE_STATIC
  /// Shared library type: this library is <strong>not</strong> backwards
  /// -compatible, can be updated and updates can be uninstalled. Clients
  /// link against a specific version of the library.
  static const TYPE_STATIC = 2;

  /// from: static public final int VERSION_UNDEFINED
  /// Constant for referring to an undefined version.
  static const VERSION_UNDEFINED = -1;

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_SharedLibraryInfo_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Parcel parcel)
  SharedLibraryInfo(os.Parcel parcel) : super.fromRef(_ctor(parcel.reference));

  static final _getType =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_SharedLibraryInfo_getType")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getType()
  /// Gets the type of this library.
  ///@return The library type.
  ///
  /// Value is either <code>0</code> or a combination of android.content.pm.SharedLibraryInfo\#TYPE_BUILTIN, android.content.pm.SharedLibraryInfo\#TYPE_DYNAMIC, and android.content.pm.SharedLibraryInfo\#TYPE_STATIC
  int getType() => _getType(reference);

  static final _getName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_SharedLibraryInfo_getName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getName()
  /// Gets the library name an app defines in its manifest
  /// to depend on the library.
  ///@return The name.
  jni.JlString getName() => jni.JlString.fromRef(_getName(reference));

  static final _getVersion =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_SharedLibraryInfo_getVersion")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getVersion()
  /// @deprecated Use \#getLongVersion() instead.
  ///@return Value is -1 or greater
  int getVersion() => _getVersion(reference);

  static final _getLongVersion =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_SharedLibraryInfo_getLongVersion")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getLongVersion()
  /// Gets the version of the library. For \#TYPE_STATIC static libraries
  /// this is the declared version and for \#TYPE_DYNAMIC dynamic and
  /// \#TYPE_BUILTIN builtin it is \#VERSION_UNDEFINED as these
  /// are not versioned.
  ///@return The version.
  ///
  /// Value is -1 or greater
  int getLongVersion() => _getLongVersion(reference);

  static final _getDeclaringPackage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_SharedLibraryInfo_getDeclaringPackage")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.VersionedPackage getDeclaringPackage()
  /// Gets the package that declares the library.
  ///@return The package declaring the library.
  ///
  /// This value will never be {@code null}.
  VersionedPackage getDeclaringPackage() =>
      VersionedPackage.fromRef(_getDeclaringPackage(reference));

  static final _getDependentPackages = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_SharedLibraryInfo_getDependentPackages")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.content.pm.VersionedPackage> getDependentPackages()
  /// Gets the packages that depend on the library.
  ///@return The dependent packages.
  ///
  /// This value will never be {@code null}.
  jni.JlObject getDependentPackages() =>
      jni.JlObject.fromRef(_getDependentPackages(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_SharedLibraryInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_SharedLibraryInfo_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_SharedLibraryInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  void writeToParcel(os.Parcel parcel, int flags) =>
      _writeToParcel(reference, parcel.reference, flags);
}

/// Class for handling cross profile operations. Apps can use this class to interact with its
/// instance in any profile that is in \#getTargetUserProfiles(). For example, app can
/// use this class to start its main activity in managed profile.
class CrossProfileApps extends jni.JlObject {
  CrossProfileApps.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_CrossProfileApps_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  CrossProfileApps() : super.fromRef(_ctor());

  static final _startMainActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_CrossProfileApps_startMainActivity")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startMainActivity(android.content.ComponentName component, android.os.UserHandle targetUser)
  /// Starts the specified main activity of the caller package in the specified profile.
  ///@param component The ComponentName of the activity to launch, it must be exported and has
  ///        action android.content.Intent\#ACTION_MAIN, category
  ///        android.content.Intent\#CATEGORY_LAUNCHER. Otherwise, SecurityException will
  ///        be thrown.
  /// This value must never be {@code null}.
  ///@param targetUser The UserHandle of the profile, must be one of the users returned by
  ///        \#getTargetUserProfiles(), otherwise a SecurityException will
  ///        be thrown.
  ///
  /// This value must never be {@code null}.
  void startMainActivity(
          content.ComponentName component, os.UserHandle targetUser) =>
      _startMainActivity(reference, component.reference, targetUser.reference);

  static final _getTargetUserProfiles = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_CrossProfileApps_getTargetUserProfiles")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.os.UserHandle> getTargetUserProfiles()
  /// Return a list of user profiles that that the caller can use when calling other APIs in this
  /// class.
  ///
  /// A user profile would be considered as a valid target user profile, provided that:
  /// <ul>
  /// <li>It gets caller app installed</li>
  /// <li>It is not equal to the calling user</li>
  /// <li>It is in the same profile group of calling user profile</li>
  /// <li>It is enabled</li>
  /// </ul>
  ///@see UserManager\#getUserProfiles()
  ///@return This value will never be {@code null}.
  jni.JlObject getTargetUserProfiles() =>
      jni.JlObject.fromRef(_getTargetUserProfiles(reference));

  static final _getProfileSwitchingLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_CrossProfileApps_getProfileSwitchingLabel")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getProfileSwitchingLabel(android.os.UserHandle userHandle)
  /// Return a label that calling app can show to user for the semantic of profile switching --
  /// launching its own activity in specified user profile. For example, it may return
  /// "Switch to work" if the given user handle is the managed profile one.
  ///@param userHandle The UserHandle of the target profile, must be one of the users returned by
  ///        \#getTargetUserProfiles(), otherwise a SecurityException will
  ///        be thrown.
  /// This value must never be {@code null}.
  ///@return a label that calling app can show user for the semantic of launching its own
  ///         activity in the specified user profile.
  ///
  /// This value will never be {@code null}.
  ///@see \#startMainActivity(ComponentName, UserHandle, Rect, Bundle)
  jni.JlObject getProfileSwitchingLabel(os.UserHandle userHandle) =>
      jni.JlObject.fromRef(
          _getProfileSwitchingLabel(reference, userHandle.reference));

  static final _getProfileSwitchingIconDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_CrossProfileApps_getProfileSwitchingIconDrawable")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable getProfileSwitchingIconDrawable(android.os.UserHandle userHandle)
  /// Return a drawable that calling app can show to user for the semantic of profile switching --
  /// launching its own activity in specified user profile. For example, it may return a briefcase
  /// icon if the given user handle is the managed profile one.
  ///@param userHandle The UserHandle of the target profile, must be one of the users returned by
  ///        \#getTargetUserProfiles(), otherwise a SecurityException will
  ///        be thrown.
  /// This value must never be {@code null}.
  ///@return an icon that calling app can show user for the semantic of launching its own
  ///         activity in specified user profile.
  ///
  /// This value will never be {@code null}.
  ///@see \#startMainActivity(ComponentName, UserHandle)
  jni.JlObject getProfileSwitchingIconDrawable(os.UserHandle userHandle) =>
      jni.JlObject.fromRef(
          _getProfileSwitchingIconDrawable(reference, userHandle.reference));
}

/// Represents a shortcut that can be published via ShortcutManager.
///@see ShortcutManager
class ShortcutInfo extends jni.JlObject {
  ShortcutInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.ShortcutInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_ShortcutInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int DISABLED_REASON_APP_CHANGED
  /// Shortcut has been disabled due to changes to the publisher app. (e.g. a manifest shortcut
  /// no longer exists.)
  static const DISABLED_REASON_APP_CHANGED = 2;

  /// from: static public final int DISABLED_REASON_BACKUP_NOT_SUPPORTED
  /// Shortcut has not been restored because the publisher app does not support backup and restore.
  static const DISABLED_REASON_BACKUP_NOT_SUPPORTED = 101;

  /// from: static public final int DISABLED_REASON_BY_APP
  /// Shortcut has been disabled by the publisher app with the
  /// ShortcutManager\#disableShortcuts(List) API.
  static const DISABLED_REASON_BY_APP = 1;

  /// from: static public final int DISABLED_REASON_NOT_DISABLED
  /// Shortcut is not disabled.
  static const DISABLED_REASON_NOT_DISABLED = 0;

  /// from: static public final int DISABLED_REASON_OTHER_RESTORE_ISSUE
  /// Shortcut has not been restored for unknown reason.
  static const DISABLED_REASON_OTHER_RESTORE_ISSUE = 103;

  /// from: static public final int DISABLED_REASON_SIGNATURE_MISMATCH
  /// Shortcut has not been restored because the publisher app's signature has changed.
  static const DISABLED_REASON_SIGNATURE_MISMATCH = 102;

  /// from: static public final int DISABLED_REASON_UNKNOWN
  /// Shortcut is disabled for an unknown reason.
  static const DISABLED_REASON_UNKNOWN = 3;

  /// from: static public final int DISABLED_REASON_VERSION_LOWER
  /// Shortcut has been restored from the previous device, but the publisher app on the current
  /// device is of a lower version. The shortcut will not be usable until the app is upgraded to
  /// the same version or higher.
  static const DISABLED_REASON_VERSION_LOWER = 100;

  /// from: static public final java.lang.String SHORTCUT_CATEGORY_CONVERSATION
  /// Shortcut category for messaging related actions, such as chat.
  static const SHORTCUT_CATEGORY_CONVERSATION = "android.shortcut.conversation";

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.content.pm.ShortcutInfo.Builder b)
  ShortcutInfo(ShortcutInfo_Builder b) : super.fromRef(_ctor(b.reference));

  static final _getId = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo_getId")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getId()
  /// Returns the ID of a shortcut.
  ///
  /// Shortcut IDs are unique within each publisher app and must be stable across
  /// devices so that shortcuts will still be valid when restored on a different device.
  /// See ShortcutManager for details.
  ///@return This value will never be {@code null}.
  jni.JlString getId() => jni.JlString.fromRef(_getId(reference));

  static final _getPackage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo_getPackage")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPackage()
  /// Return the package name of the publisher app.
  ///@return This value will never be {@code null}.
  jni.JlString getPackage() => jni.JlString.fromRef(_getPackage(reference));

  static final _getActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo_getActivity")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getActivity()
  /// Return the target activity.
  ///
  /// This has nothing to do with the activity that this shortcut will launch.
  /// Launcher apps should show the launcher icon for the returned activity alongside
  /// this shortcut.
  ///@see Builder\#setActivity
  ///@return This value may be {@code null}.
  content.ComponentName getActivity() =>
      content.ComponentName.fromRef(_getActivity(reference));

  static final _getShortLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo_getShortLabel")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getShortLabel()
  /// Return the short description of a shortcut.
  ///@see Builder\#setShortLabel(CharSequence)
  ///@return This value may be {@code null}.
  jni.JlObject getShortLabel() =>
      jni.JlObject.fromRef(_getShortLabel(reference));

  static final _getLongLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo_getLongLabel")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getLongLabel()
  /// Return the long description of a shortcut.
  ///@see Builder\#setLongLabel(CharSequence)
  ///@return This value may be {@code null}.
  jni.JlObject getLongLabel() => jni.JlObject.fromRef(_getLongLabel(reference));

  static final _getDisabledMessage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo_getDisabledMessage")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getDisabledMessage()
  /// Return the message that should be shown when the user attempts to start a shortcut
  /// that is disabled.
  ///@see Builder\#setDisabledMessage(CharSequence)
  ///@return This value may be {@code null}.
  jni.JlObject getDisabledMessage() =>
      jni.JlObject.fromRef(_getDisabledMessage(reference));

  static final _getDisabledReason =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ShortcutInfo_getDisabledReason")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getDisabledReason()
  /// Returns why a shortcut has been disabled.
  ///@return Value is android.content.pm.ShortcutInfo\#DISABLED_REASON_NOT_DISABLED, android.content.pm.ShortcutInfo\#DISABLED_REASON_BY_APP, android.content.pm.ShortcutInfo\#DISABLED_REASON_APP_CHANGED, android.content.pm.ShortcutInfo\#DISABLED_REASON_UNKNOWN, android.content.pm.ShortcutInfo\#DISABLED_REASON_VERSION_LOWER, android.content.pm.ShortcutInfo\#DISABLED_REASON_BACKUP_NOT_SUPPORTED, android.content.pm.ShortcutInfo\#DISABLED_REASON_SIGNATURE_MISMATCH, or android.content.pm.ShortcutInfo\#DISABLED_REASON_OTHER_RESTORE_ISSUE
  int getDisabledReason() => _getDisabledReason(reference);

  static final _getCategories = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo_getCategories")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Set<java.lang.String> getCategories()
  /// Return the shortcut's categories.
  ///@see Builder\#setCategories(Set)
  ///@return This value may be {@code null}.
  jni.JlObject getCategories() =>
      jni.JlObject.fromRef(_getCategories(reference));

  static final _getIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo_getIntent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent getIntent()
  /// Returns the intent that is executed when the user selects this shortcut.
  /// If setIntents() was used, then return the last intent in the array.
  ///
  /// Launcher apps __cannot__ see the intent.  If a ShortcutInfo is
  /// obtained via LauncherApps, then this method will always return null.
  /// Launchers can only start a shortcut intent with LauncherApps\#startShortcut.
  ///@see Builder\#setIntent(Intent)
  content.Intent getIntent() => content.Intent.fromRef(_getIntent(reference));

  static final _getIntents = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo_getIntents")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent[] getIntents()
  /// Return the intent set with Builder\#setIntents(Intent[]).
  ///
  /// Launcher apps __cannot__ see the intents.  If a ShortcutInfo is
  /// obtained via LauncherApps, then this method will always return null.
  /// Launchers can only start a shortcut intent with LauncherApps\#startShortcut.
  ///@see Builder\#setIntents(Intent[])
  jni.JlObject getIntents() => jni.JlObject.fromRef(_getIntents(reference));

  static final _getRank =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ShortcutInfo_getRank")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getRank()
  /// "Rank" of a shortcut, which is a non-negative, sequential value that's unique for each
  /// \#getActivity for each of the two types of shortcuts (static and dynamic).
  ///
  /// Because static shortcuts and dynamic shortcuts have overlapping ranks,
  /// when a launcher app shows shortcuts for an activity, it should first show
  /// the static shortcuts, followed by the dynamic shortcuts.  Within each of those categories,
  /// shortcuts should be sorted by rank in ascending order.
  ///
  /// _Floating shortcuts_, or shortcuts that are neither static nor dynamic, will all
  /// have rank 0, because they aren't sorted.
  ///
  /// See the ShortcutManager's class javadoc for details.
  ///@see Builder\#setRank(int)
  int getRank() => _getRank(reference);

  static final _getExtras = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo_getExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.PersistableBundle getExtras()
  /// Extras that the app can set for any purpose.
  ///@see Builder\#setExtras(PersistableBundle)
  ///@return This value may be {@code null}.
  os.PersistableBundle getExtras() =>
      os.PersistableBundle.fromRef(_getExtras(reference));

  static final _getUserHandle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo_getUserHandle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.UserHandle getUserHandle()
  /// UserHandle on which the publisher created this shortcut.
  os.UserHandle getUserHandle() =>
      os.UserHandle.fromRef(_getUserHandle(reference));

  static final _getLastChangedTimestamp =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ShortcutInfo_getLastChangedTimestamp")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getLastChangedTimestamp()
  /// Last time when any of the fields was updated.
  int getLastChangedTimestamp() => _getLastChangedTimestamp(reference);

  static final _isDynamic =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ShortcutInfo_isDynamic")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isDynamic()
  /// Return whether a shortcut is dynamic.
  bool isDynamic() => _isDynamic(reference) != 0;

  static final _isPinned =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ShortcutInfo_isPinned")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isPinned()
  /// Return whether a shortcut is pinned.
  bool isPinned() => _isPinned(reference) != 0;

  static final _isDeclaredInManifest =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ShortcutInfo_isDeclaredInManifest")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isDeclaredInManifest()
  /// Return whether a shortcut is static; that is, whether a shortcut is
  /// published from AndroidManifest.xml.  If {@code true}, the shortcut is
  /// also \#isImmutable().
  ///
  /// When an app is upgraded and a shortcut is no longer published from AndroidManifest.xml,
  /// this will be set to {@code false}.  If the shortcut is not pinned, then it'll disappear.
  /// However, if it's pinned, it will still be visible, \#isEnabled() will be
  /// {@code false} and \#isImmutable() will be {@code true}.
  bool isDeclaredInManifest() => _isDeclaredInManifest(reference) != 0;

  static final _isImmutable =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ShortcutInfo_isImmutable")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isImmutable()
  /// Return if a shortcut is immutable, in which case it cannot be modified with any of
  /// ShortcutManager APIs.
  ///
  /// All static shortcuts are immutable.  When a static shortcut is pinned and is then
  /// disabled because it doesn't appear in AndroidManifest.xml for a newer version of the
  /// app, \#isDeclaredInManifest() returns {@code false}, but the shortcut
  /// is still immutable.
  ///
  /// All shortcuts originally published via the ShortcutManager APIs
  /// are all mutable.
  bool isImmutable() => _isImmutable(reference) != 0;

  static final _isEnabled =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ShortcutInfo_isEnabled")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isEnabled()
  /// Returns {@code false} if a shortcut is disabled with
  /// ShortcutManager\#disableShortcuts.
  bool isEnabled() => _isEnabled(reference) != 0;

  static final _hasKeyFieldsOnly =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ShortcutInfo_hasKeyFieldsOnly")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasKeyFieldsOnly()
  /// Return whether a shortcut only contains "key" information only or not.  If true, only the
  /// following fields are available.
  /// <ul>
  ///     <li>\#getId()
  ///     <li>\#getPackage()
  ///     <li>\#getActivity()
  ///     <li>\#getLastChangedTimestamp()
  ///     <li>\#isDynamic()
  ///     <li>\#isPinned()
  ///     <li>\#isDeclaredInManifest()
  ///     <li>\#isImmutable()
  ///     <li>\#isEnabled()
  ///     <li>\#getUserHandle()
  /// </ul>
  ///
  /// For performance reasons, shortcuts passed to
  /// LauncherApps.Callback\#onShortcutsChanged(String, List, UserHandle) as well as those
  /// returned from LauncherApps\#getShortcuts(ShortcutQuery, UserHandle)
  /// while using the ShortcutQuery\#FLAG_GET_KEY_FIELDS_ONLY option contain only key
  /// information.
  bool hasKeyFieldsOnly() => _hasKeyFieldsOnly(reference) != 0;

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_pm_ShortcutInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ShortcutInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// Return a string representation, intended for logging.  Some fields will be retracted.
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));
}

/// Builder class for ShortcutInfo objects.
///@see ShortcutManager
class ShortcutInfo_Builder extends jni.JlObject {
  ShortcutInfo_Builder.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo__Builder_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context, java.lang.String id)
  /// Constructor.
  ///@param context Client context.
  ///@param id ID of the shortcut.
  ShortcutInfo_Builder(content.Context context, jni.JlString id)
      : super.fromRef(_ctor(context.reference, id.reference));

  static final _setActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo__Builder_setActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ShortcutInfo.Builder setActivity(android.content.ComponentName activity)
  /// Sets the target activity.  A shortcut will be shown along with this activity's icon
  /// on the launcher.
  ///
  /// When selecting a target activity, keep the following in mind:
  /// <ul>
  /// <li>All dynamic shortcuts must have a target activity.  When a shortcut with no target
  /// activity is published using
  /// ShortcutManager\#addDynamicShortcuts(List) or
  /// ShortcutManager\#setDynamicShortcuts(List),
  /// the first main activity defined in the app's <code>AndroidManifest.xml</code>
  /// file is used.
  ///
  /// <li>Only "main" activities&mdash;ones that define the Intent\#ACTION_MAIN
  /// and Intent\#CATEGORY_LAUNCHER intent filters&mdash;can be target
  /// activities.
  ///
  /// <li>By default, the first main activity defined in the app's manifest is
  /// the target activity.
  ///
  /// <li>A target activity must belong to the publisher app.
  /// </ul>
  ///@see ShortcutInfo\#getActivity()
  ///@param activity This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  ShortcutInfo_Builder setActivity(content.ComponentName activity) =>
      ShortcutInfo_Builder.fromRef(_setActivity(reference, activity.reference));

  static final _setIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo__Builder_setIcon")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ShortcutInfo.Builder setIcon(android.graphics.drawable.Icon icon)
  /// Sets an icon of a shortcut.
  ///
  /// Icons are not available on ShortcutInfo instances
  /// returned by ShortcutManager or LauncherApps.  The default launcher
  /// app can use LauncherApps\#getShortcutIconDrawable(ShortcutInfo, int)
  /// or LauncherApps\#getShortcutBadgedIconDrawable(ShortcutInfo, int) to fetch
  /// shortcut icons.
  ///
  /// Tints set with Icon\#setTint or Icon\#setTintList are not supported
  /// and will be ignored.
  ///
  /// Only icons created with Icon\#createWithBitmap(Bitmap),
  /// Icon\#createWithAdaptiveBitmap(Bitmap)
  /// and Icon\#createWithResource are supported.
  /// Other types, such as URI-based icons, are not supported.
  ///@see LauncherApps\#getShortcutIconDrawable(ShortcutInfo, int)
  ///@see LauncherApps\#getShortcutBadgedIconDrawable(ShortcutInfo, int)
  ///@return This value will never be {@code null}.
  ShortcutInfo_Builder setIcon(jni.JlObject icon) =>
      ShortcutInfo_Builder.fromRef(_setIcon(reference, icon.reference));

  static final _setShortLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo__Builder_setShortLabel")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ShortcutInfo.Builder setShortLabel(java.lang.CharSequence shortLabel)
  /// Sets the short title of a shortcut.
  ///
  /// This is a mandatory field when publishing a new shortcut with
  /// ShortcutManager\#addDynamicShortcuts(List) or
  /// ShortcutManager\#setDynamicShortcuts(List).
  ///
  /// This field is intended to be a concise description of a shortcut.
  ///
  /// The recommended maximum length is 10 characters.
  ///@see ShortcutInfo\#getShortLabel()
  ///@param shortLabel This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  ShortcutInfo_Builder setShortLabel(jni.JlObject shortLabel) =>
      ShortcutInfo_Builder.fromRef(
          _setShortLabel(reference, shortLabel.reference));

  static final _setLongLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo__Builder_setLongLabel")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ShortcutInfo.Builder setLongLabel(java.lang.CharSequence longLabel)
  /// Sets the text of a shortcut.
  ///
  /// This field is intended to be more descriptive than the shortcut title.  The launcher
  /// shows this instead of the short title when it has enough space.
  ///
  /// The recommend maximum length is 25 characters.
  ///@see ShortcutInfo\#getLongLabel()
  ///@param longLabel This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  ShortcutInfo_Builder setLongLabel(jni.JlObject longLabel) =>
      ShortcutInfo_Builder.fromRef(
          _setLongLabel(reference, longLabel.reference));

  static final _setDisabledMessage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo__Builder_setDisabledMessage")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ShortcutInfo.Builder setDisabledMessage(java.lang.CharSequence disabledMessage)
  /// Sets the message that should be shown when the user attempts to start a shortcut that
  /// is disabled.
  ///@see ShortcutInfo\#getDisabledMessage()
  ///@param disabledMessage This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  ShortcutInfo_Builder setDisabledMessage(jni.JlObject disabledMessage) =>
      ShortcutInfo_Builder.fromRef(
          _setDisabledMessage(reference, disabledMessage.reference));

  static final _setCategories = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo__Builder_setCategories")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ShortcutInfo.Builder setCategories(java.util.Set<java.lang.String> categories)
  /// Sets categories for a shortcut.  Launcher apps may use this information to
  /// categorize shortcuts.
  ///@see \#SHORTCUT_CATEGORY_CONVERSATION
  ///@see ShortcutInfo\#getCategories()
  ///@return This value will never be {@code null}.
  ShortcutInfo_Builder setCategories(jni.JlObject categories) =>
      ShortcutInfo_Builder.fromRef(
          _setCategories(reference, categories.reference));

  static final _setIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo__Builder_setIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ShortcutInfo.Builder setIntent(android.content.Intent intent)
  /// Sets the intent of a shortcut.  Alternatively, \#setIntents(Intent[]) can be used
  /// to launch an activity with other activities in the back stack.
  ///
  /// This is a mandatory field when publishing a new shortcut with
  /// ShortcutManager\#addDynamicShortcuts(List) or
  /// ShortcutManager\#setDynamicShortcuts(List).
  ///
  /// A shortcut can launch any intent that the publisher app has permission to
  /// launch.  For example, a shortcut can launch an unexported activity within the publisher
  /// app.  A shortcut intent doesn't have to point at the target activity.
  ///
  /// The given {@code intent} can contain extras, but these extras must contain values
  /// of primitive types in order for the system to persist these values.
  ///@see ShortcutInfo\#getIntent()
  ///@see \#setIntents(Intent[])
  ///@param intent This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  ShortcutInfo_Builder setIntent(content.Intent intent) =>
      ShortcutInfo_Builder.fromRef(_setIntent(reference, intent.reference));

  static final _setIntents = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo__Builder_setIntents")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ShortcutInfo.Builder setIntents(android.content.Intent[] intents)
  /// Sets multiple intents instead of a single intent, in order to launch an activity with
  /// other activities in back stack.  Use TaskStackBuilder to build intents. The
  /// last element in the list represents the only intent that doesn't place an activity on
  /// the back stack.
  /// See the ShortcutManager javadoc for details.
  ///@see Builder\#setIntent(Intent)
  ///@see ShortcutInfo\#getIntents()
  ///@see Context\#startActivities(Intent[])
  ///@see TaskStackBuilder
  ///@param intents This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  ShortcutInfo_Builder setIntents(jni.JlObject intents) =>
      ShortcutInfo_Builder.fromRef(_setIntents(reference, intents.reference));

  static final _setRank = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_ShortcutInfo__Builder_setRank")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.pm.ShortcutInfo.Builder setRank(int rank)
  /// "Rank" of a shortcut, which is a non-negative value that's used by the launcher app
  /// to sort shortcuts.
  ///
  /// See ShortcutInfo\#getRank() for details.
  ///@return This value will never be {@code null}.
  ShortcutInfo_Builder setRank(int rank) =>
      ShortcutInfo_Builder.fromRef(_setRank(reference, rank));

  static final _setExtras = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo__Builder_setExtras")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ShortcutInfo.Builder setExtras(android.os.PersistableBundle extras)
  /// Extras that the app can set for any purpose.
  ///
  /// Apps can store arbitrary shortcut metadata in extras and retrieve the
  /// metadata later using ShortcutInfo\#getExtras().
  ///@param extras This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  ShortcutInfo_Builder setExtras(os.PersistableBundle extras) =>
      ShortcutInfo_Builder.fromRef(_setExtras(reference, extras.reference));

  static final _build = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutInfo__Builder_build")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ShortcutInfo build()
  /// Creates a ShortcutInfo instance.
  ///@return This value will never be {@code null}.
  ShortcutInfo build() => ShortcutInfo.fromRef(_build(reference));
}

/// Base class containing information common to all package items held by
/// the package manager.  This provides a very common basic set of attributes:
/// a label, icon, and meta-data.  This class is not intended
/// to be used by itself; it is simply here to share common definitions
/// between all items returned by the package manager.  As such, it does not
/// itself implement Parcelable, but does provide convenience methods to assist
/// in the implementation of Parcelable in subclasses.
class PackageItemInfo extends jni.JlObject {
  PackageItemInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: public int banner
  /// A drawable resource identifier (in the package's resources) of this
  /// component's banner.  From the "banner" attribute or, if not set, 0.
  static final _getbanner = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageItemInfo_banner")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get banner => _getbanner(reference);
  static final _setbanner = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_PackageItemInfo_banner")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set banner(int value) => _setbanner(reference, value);

  /// from: public int icon
  /// A drawable resource identifier (in the package's resources) of this
  /// component's icon.  From the "icon" attribute or, if not set, 0.
  static final _geticon = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageItemInfo_icon")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get icon => _geticon(reference);
  static final _seticon = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_PackageItemInfo_icon")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set icon(int value) => _seticon(reference, value);

  /// from: public int labelRes
  /// A string resource identifier (in the package's resources) of this
  /// component's label.  From the "label" attribute or, if not set, 0.
  static final _getlabelRes = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageItemInfo_labelRes")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get labelRes => _getlabelRes(reference);
  static final _setlabelRes = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_PackageItemInfo_labelRes")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set labelRes(int value) => _setlabelRes(reference, value);

  /// from: public int logo
  /// A drawable resource identifier (in the package's resources) of this
  /// component's logo. Logos may be larger/wider than icons and are
  /// displayed by certain UI elements in place of a name or name/icon
  /// combination. From the "logo" attribute or, if not set, 0.
  static final _getlogo = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageItemInfo_logo")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get logo => _getlogo(reference);
  static final _setlogo = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_PackageItemInfo_logo")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set logo(int value) => _setlogo(reference, value);

  /// from: public android.os.Bundle metaData
  /// Additional meta-data associated with this component.  This field
  /// will only be filled in if you set the
  /// PackageManager\#GET_META_DATA flag when requesting the info.
  static final _getmetaData = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageItemInfo_metaData")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  os.Bundle get metaData => os.Bundle.fromRef(_getmetaData(reference));
  static final _setmetaData = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageItemInfo_metaData")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set metaData(os.Bundle value) => _setmetaData(reference, value.reference);

  /// from: public java.lang.String name
  /// Public name of this item. From the "android:name" attribute.
  static final _getname = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageItemInfo_name")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get name => jni.JlString.fromRef(_getname(reference));
  static final _setname = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageItemInfo_name")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set name(jni.JlString value) => _setname(reference, value.reference);

  /// from: public java.lang.CharSequence nonLocalizedLabel
  /// The string provided in the AndroidManifest file, if any.  You
  /// probably don't want to use this.  You probably want
  /// PackageManager\#getApplicationLabel
  static final _getnonLocalizedLabel = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageItemInfo_nonLocalizedLabel")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get nonLocalizedLabel =>
      jni.JlObject.fromRef(_getnonLocalizedLabel(reference));
  static final _setnonLocalizedLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageItemInfo_nonLocalizedLabel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set nonLocalizedLabel(jni.JlObject value) =>
      _setnonLocalizedLabel(reference, value.reference);

  /// from: public java.lang.String packageName
  /// Name of the package that this item is in.
  static final _getpackageName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageItemInfo_packageName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get packageName =>
      jni.JlString.fromRef(_getpackageName(reference));
  static final _setpackageName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageItemInfo_packageName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set packageName(jni.JlString value) =>
      _setpackageName(reference, value.reference);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_PackageItemInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  PackageItemInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageItemInfo_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.pm.PackageItemInfo orig)
  PackageItemInfo.ctor_1(PackageItemInfo orig)
      : super.fromRef(_ctor_1(orig.reference));

  static final _ctor_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageItemInfo_new_2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void <init>(android.os.Parcel source)
  PackageItemInfo.ctor_2(os.Parcel source)
      : super.fromRef(_ctor_2(source.reference));

  static final _loadLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageItemInfo_loadLabel")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence loadLabel(android.content.pm.PackageManager pm)
  /// Retrieve the current textual label associated with this item.  This
  /// will call back on the given PackageManager to load the label from
  /// the application.
  ///@param pm A PackageManager from which the label can be loaded; usually
  /// the PackageManager from which you originally retrieved this item.
  ///
  /// This value must never be {@code null}.
  ///@return Returns a CharSequence containing the item's label.  If the
  /// item does not have a label, its name is returned.
  ///
  /// This value will never be {@code null}.
  jni.JlObject loadLabel(PackageManager pm) =>
      jni.JlObject.fromRef(_loadLabel(reference, pm.reference));

  static final _loadIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageItemInfo_loadIcon")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable loadIcon(android.content.pm.PackageManager pm)
  /// Retrieve the current graphical icon associated with this item.  This
  /// will call back on the given PackageManager to load the icon from
  /// the application.
  ///@param pm A PackageManager from which the icon can be loaded; usually
  /// the PackageManager from which you originally retrieved this item.
  ///@return Returns a Drawable containing the item's icon.  If the
  /// item does not have an icon, the item's default icon is returned
  /// such as the default activity icon.
  jni.JlObject loadIcon(PackageManager pm) =>
      jni.JlObject.fromRef(_loadIcon(reference, pm.reference));

  static final _loadUnbadgedIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageItemInfo_loadUnbadgedIcon")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable loadUnbadgedIcon(android.content.pm.PackageManager pm)
  /// Retrieve the current graphical icon associated with this item without
  /// the addition of a work badge if applicable.
  /// This will call back on the given PackageManager to load the icon from
  /// the application.
  ///@param pm A PackageManager from which the icon can be loaded; usually
  /// the PackageManager from which you originally retrieved this item.
  ///@return Returns a Drawable containing the item's icon.  If the
  /// item does not have an icon, the item's default icon is returned
  /// such as the default activity icon.
  jni.JlObject loadUnbadgedIcon(PackageManager pm) =>
      jni.JlObject.fromRef(_loadUnbadgedIcon(reference, pm.reference));

  static final _loadBanner = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageItemInfo_loadBanner")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable loadBanner(android.content.pm.PackageManager pm)
  /// Retrieve the current graphical banner associated with this item.  This
  /// will call back on the given PackageManager to load the banner from
  /// the application.
  ///@param pm A PackageManager from which the banner can be loaded; usually
  /// the PackageManager from which you originally retrieved this item.
  ///@return Returns a Drawable containing the item's banner.  If the item
  /// does not have a banner, this method will return null.
  jni.JlObject loadBanner(PackageManager pm) =>
      jni.JlObject.fromRef(_loadBanner(reference, pm.reference));

  static final _loadLogo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageItemInfo_loadLogo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable loadLogo(android.content.pm.PackageManager pm)
  /// Retrieve the current graphical logo associated with this item. This
  /// will call back on the given PackageManager to load the logo from
  /// the application.
  ///@param pm A PackageManager from which the logo can be loaded; usually
  /// the PackageManager from which you originally retrieved this item.
  ///@return Returns a Drawable containing the item's logo. If the item
  /// does not have a logo, this method will return null.
  jni.JlObject loadLogo(PackageManager pm) =>
      jni.JlObject.fromRef(_loadLogo(reference, pm.reference));

  static final _loadXmlMetaData = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageItemInfo_loadXmlMetaData")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.XmlResourceParser loadXmlMetaData(android.content.pm.PackageManager pm, java.lang.String name)
  /// Load an XML resource attached to the meta-data of this item.  This will
  /// retrieved the name meta-data entry, and if defined call back on the
  /// given PackageManager to load its XML file from the application.
  ///@param pm A PackageManager from which the XML can be loaded; usually
  /// the PackageManager from which you originally retrieved this item.
  ///@param name Name of the meta-date you would like to load.
  ///@return Returns an XmlPullParser you can use to parse the XML file
  /// assigned as the given meta-data.  If the meta-data name is not defined
  /// or the XML resource could not be found, null is returned.
  res.XmlResourceParser loadXmlMetaData(PackageManager pm, jni.JlString name) =>
      res.XmlResourceParser.fromRef(
          _loadXmlMetaData(reference, pm.reference, name.reference));

  static final _dumpFront = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageItemInfo_dumpFront")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void dumpFront(android.util.Printer pw, java.lang.String prefix)
  void dumpFront(jni.JlObject pw, jni.JlString prefix) =>
      _dumpFront(reference, pw.reference, prefix.reference);

  static final _dumpBack = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageItemInfo_dumpBack")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void dumpBack(android.util.Printer pw, java.lang.String prefix)
  void dumpBack(jni.JlObject pw, jni.JlString prefix) =>
      _dumpBack(reference, pw.reference, prefix.reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageItemInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(os.Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags);
}

class PackageItemInfo_DisplayNameComparator extends jni.JlObject {
  PackageItemInfo_DisplayNameComparator.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageItemInfo__DisplayNameComparator_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.pm.PackageManager pm)
  PackageItemInfo_DisplayNameComparator(PackageManager pm)
      : super.fromRef(_ctor(pm.reference));

  static final _compare = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageItemInfo__DisplayNameComparator_compare")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final int compare(android.content.pm.PackageItemInfo aa, android.content.pm.PackageItemInfo ab)
  int compare(PackageItemInfo aa, PackageItemInfo ab) =>
      _compare(reference, aa.reference, ab.reference);
}

/// Information that is returned from resolving an intent
/// against an IntentFilter. This partially corresponds to
/// information collected from the AndroidManifest.xml's
/// &lt;intent&gt; tags.
class ResolveInfo extends jni.JlObject {
  ResolveInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.ResolveInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_ResolveInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: public android.content.pm.ActivityInfo activityInfo
  /// The activity or broadcast receiver that corresponds to this resolution
  /// match, if this resolution is for an activity or broadcast receiver.
  /// Exactly one of \#activityInfo, \#serviceInfo, or
  /// \#providerInfo will be non-null.
  static final _getactivityInfo = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ResolveInfo_activityInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  ActivityInfo get activityInfo =>
      ActivityInfo.fromRef(_getactivityInfo(reference));
  static final _setactivityInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ResolveInfo_activityInfo")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set activityInfo(ActivityInfo value) =>
      _setactivityInfo(reference, value.reference);

  /// from: public android.content.IntentFilter filter
  /// The IntentFilter that was matched for this ResolveInfo.
  static final _getfilter = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ResolveInfo_filter")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  content.IntentFilter get filter =>
      content.IntentFilter.fromRef(_getfilter(reference));
  static final _setfilter = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ResolveInfo_filter")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set filter(content.IntentFilter value) =>
      _setfilter(reference, value.reference);

  /// from: public int icon
  /// A drawable resource identifier (in the package's resources) of this
  /// match's icon.  From the "icon" attribute or, if not set, 0. It is
  /// set only if the icon can be obtained by resource id alone.
  static final _geticon = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ResolveInfo_icon")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get icon => _geticon(reference);
  static final _seticon = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_ResolveInfo_icon")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set icon(int value) => _seticon(reference, value);

  /// from: public boolean isDefault
  /// This filter has specified the Intent.CATEGORY_DEFAULT, meaning it
  /// would like to be considered a default action that the user can
  /// perform on this data.
  static final _getisDefault = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ResolveInfo_isDefault")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  bool get isDefault => _getisDefault(reference) != 0;
  static final _setisDefault = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("set_android_content_pm_ResolveInfo_isDefault")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set isDefault(bool value) => _setisDefault(reference, value ? 1 : 0);

  /// from: public boolean isInstantAppAvailable
  /// Whether or not an instant app is available for the resolved intent.
  static final _getisInstantAppAvailable = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ResolveInfo_isInstantAppAvailable")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  bool get isInstantAppAvailable => _getisInstantAppAvailable(reference) != 0;
  static final _setisInstantAppAvailable = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_android_content_pm_ResolveInfo_isInstantAppAvailable")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set isInstantAppAvailable(bool value) =>
      _setisInstantAppAvailable(reference, value ? 1 : 0);

  /// from: public int labelRes
  /// A string resource identifier (in the package's resources) of this
  /// match's label.  From the "label" attribute or, if not set, 0.
  static final _getlabelRes = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ResolveInfo_labelRes")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get labelRes => _getlabelRes(reference);
  static final _setlabelRes = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_ResolveInfo_labelRes")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set labelRes(int value) => _setlabelRes(reference, value);

  /// from: public int match
  /// The system's evaluation of how well the activity matches the
  /// IntentFilter.  This is a match constant, a combination of
  /// IntentFilter\#MATCH_CATEGORY_MASK IntentFilter.MATCH_CATEGORY_MASK
  /// and IntentFilter\#MATCH_ADJUSTMENT_MASK IntentFiler.MATCH_ADJUSTMENT_MASK.
  static final _getmatch = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ResolveInfo_match")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get match => _getmatch(reference);
  static final _setmatch = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_ResolveInfo_match")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set match(int value) => _setmatch(reference, value);

  /// from: public java.lang.CharSequence nonLocalizedLabel
  /// The actual string retrieve from <var>labelRes</var> or null if none
  /// was provided.
  static final _getnonLocalizedLabel = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ResolveInfo_nonLocalizedLabel")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get nonLocalizedLabel =>
      jni.JlObject.fromRef(_getnonLocalizedLabel(reference));
  static final _setnonLocalizedLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ResolveInfo_nonLocalizedLabel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set nonLocalizedLabel(jni.JlObject value) =>
      _setnonLocalizedLabel(reference, value.reference);

  /// from: public int preferredOrder
  /// Order of result according to the user's preference.  If the user
  /// has not set a preference for this result, the value is 0; higher
  /// values are a higher priority.
  static final _getpreferredOrder = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ResolveInfo_preferredOrder")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get preferredOrder => _getpreferredOrder(reference);
  static final _setpreferredOrder = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ResolveInfo_preferredOrder")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set preferredOrder(int value) => _setpreferredOrder(reference, value);

  /// from: public int priority
  /// The declared priority of this match.  Comes from the "priority"
  /// attribute or, if not set, defaults to 0.  Higher values are a higher
  /// priority.
  static final _getpriority = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ResolveInfo_priority")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get priority => _getpriority(reference);
  static final _setpriority = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_ResolveInfo_priority")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set priority(int value) => _setpriority(reference, value);

  /// from: public android.content.pm.ProviderInfo providerInfo
  /// The provider that corresponds to this resolution match, if this
  /// resolution is for a provider. Exactly one of \#activityInfo,
  /// \#serviceInfo, or \#providerInfo will be non-null.
  static final _getproviderInfo = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ResolveInfo_providerInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  ProviderInfo get providerInfo =>
      ProviderInfo.fromRef(_getproviderInfo(reference));
  static final _setproviderInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ResolveInfo_providerInfo")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set providerInfo(ProviderInfo value) =>
      _setproviderInfo(reference, value.reference);

  /// from: public java.lang.String resolvePackageName
  /// Optional -- if non-null, the \#labelRes and \#icon
  /// resources will be loaded from this package, rather than the one
  /// containing the resolved component.
  static final _getresolvePackageName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ResolveInfo_resolvePackageName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get resolvePackageName =>
      jni.JlString.fromRef(_getresolvePackageName(reference));
  static final _setresolvePackageName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ResolveInfo_resolvePackageName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set resolvePackageName(jni.JlString value) =>
      _setresolvePackageName(reference, value.reference);

  /// from: public android.content.pm.ServiceInfo serviceInfo
  /// The service that corresponds to this resolution match, if this resolution
  /// is for a service. Exactly one of \#activityInfo,
  /// \#serviceInfo, or \#providerInfo will be non-null.
  static final _getserviceInfo = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ResolveInfo_serviceInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  ServiceInfo get serviceInfo =>
      ServiceInfo.fromRef(_getserviceInfo(reference));
  static final _setserviceInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ResolveInfo_serviceInfo")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set serviceInfo(ServiceInfo value) =>
      _setserviceInfo(reference, value.reference);

  /// from: public int specificIndex
  /// Only set when returned by
  /// PackageManager\#queryIntentActivityOptions, this tells you
  /// which of the given specific intents this result came from.  0 is the
  /// first in the list, < 0 means it came from the generic Intent query.
  static final _getspecificIndex = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ResolveInfo_specificIndex")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get specificIndex => _getspecificIndex(reference);
  static final _setspecificIndex = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ResolveInfo_specificIndex")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set specificIndex(int value) => _setspecificIndex(reference, value);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_ResolveInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ResolveInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ResolveInfo_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.pm.ResolveInfo orig)
  ResolveInfo.ctor_1(ResolveInfo orig) : super.fromRef(_ctor_1(orig.reference));

  static final _loadLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ResolveInfo_loadLabel")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence loadLabel(android.content.pm.PackageManager pm)
  /// Retrieve the current textual label associated with this resolution.  This
  /// will call back on the given PackageManager to load the label from
  /// the application.
  ///@param pm A PackageManager from which the label can be loaded; usually
  /// the PackageManager from which you originally retrieved this item.
  ///@return Returns a CharSequence containing the resolutions's label.  If the
  /// item does not have a label, its name is returned.
  jni.JlObject loadLabel(PackageManager pm) =>
      jni.JlObject.fromRef(_loadLabel(reference, pm.reference));

  static final _loadIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ResolveInfo_loadIcon")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable loadIcon(android.content.pm.PackageManager pm)
  /// Retrieve the current graphical icon associated with this resolution.  This
  /// will call back on the given PackageManager to load the icon from
  /// the application.
  ///@param pm A PackageManager from which the icon can be loaded; usually
  /// the PackageManager from which you originally retrieved this item.
  ///@return Returns a Drawable containing the resolution's icon.  If the
  /// item does not have an icon, the default activity icon is returned.
  jni.JlObject loadIcon(PackageManager pm) =>
      jni.JlObject.fromRef(_loadIcon(reference, pm.reference));

  static final _getIconResource =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ResolveInfo_getIconResource")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getIconResource()
  /// Return the icon resource identifier to use for this match.  If the
  /// match defines an icon, that is used; else if the activity defines
  /// an icon, that is used; else, the application icon is used.
  ///@return The icon associated with this match.
  int getIconResource() => _getIconResource(reference);

  static final _dump = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ResolveInfo_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  void dump(jni.JlObject pw, jni.JlString prefix) =>
      _dump(reference, pw.reference, prefix.reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ResolveInfo_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ResolveInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_pm_ResolveInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(os.Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags);
}

class ResolveInfo_DisplayNameComparator extends jni.JlObject {
  ResolveInfo_DisplayNameComparator.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ResolveInfo__DisplayNameComparator_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.pm.PackageManager pm)
  ResolveInfo_DisplayNameComparator(PackageManager pm)
      : super.fromRef(_ctor(pm.reference));

  static final _compare = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ResolveInfo__DisplayNameComparator_compare")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final int compare(android.content.pm.ResolveInfo a, android.content.pm.ResolveInfo b)
  int compare(ResolveInfo a, ResolveInfo b) =>
      _compare(reference, a.reference, b.reference);
}

/// Information you can retrieve about a particular security permission
/// group known to the system.  This corresponds to information collected from the
/// AndroidManifest.xml's &lt;permission-group&gt; tags.
class PermissionGroupInfo extends PackageItemInfo {
  PermissionGroupInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.PermissionGroupInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_PermissionGroupInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int FLAG_PERSONAL_INFO
  /// Flag for \#flags, corresponding to <code>personalInfo</code>
  /// value of android.R.attr\#permissionGroupFlags.
  static const FLAG_PERSONAL_INFO = 1;

  /// from: public int descriptionRes
  /// A string resource identifier (in the package's resources) of this
  /// permission's description.  From the "description" attribute or,
  /// if not set, 0.
  static final _getdescriptionRes = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PermissionGroupInfo_descriptionRes")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get descriptionRes => _getdescriptionRes(reference);
  static final _setdescriptionRes = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_PermissionGroupInfo_descriptionRes")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set descriptionRes(int value) => _setdescriptionRes(reference, value);

  /// from: public int flags
  /// Additional flags about this group as given by
  /// android.R.attr\#permissionGroupFlags.
  static final _getflags = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PermissionGroupInfo_flags")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get flags => _getflags(reference);
  static final _setflags = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_PermissionGroupInfo_flags")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set flags(int value) => _setflags(reference, value);

  /// from: public java.lang.CharSequence nonLocalizedDescription
  /// The description string provided in the AndroidManifest file, if any.  You
  /// probably don't want to use this, since it will be null if the description
  /// is in a resource.  You probably want
  /// PermissionInfo\#loadDescription instead.
  static final _getnonLocalizedDescription = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PermissionGroupInfo_nonLocalizedDescription")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get nonLocalizedDescription =>
      jni.JlObject.fromRef(_getnonLocalizedDescription(reference));
  static final _setnonLocalizedDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PermissionGroupInfo_nonLocalizedDescription")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set nonLocalizedDescription(jni.JlObject value) =>
      _setnonLocalizedDescription(reference, value.reference);

  /// from: public int priority
  /// Prioritization of this group, for visually sorting with other groups.
  static final _getpriority = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PermissionGroupInfo_priority")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get priority => _getpriority(reference);
  static final _setpriority = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_PermissionGroupInfo_priority")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set priority(int value) => _setpriority(reference, value);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_PermissionGroupInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  PermissionGroupInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PermissionGroupInfo_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.pm.PermissionGroupInfo orig)
  PermissionGroupInfo.ctor_1(PermissionGroupInfo orig)
      : super.fromRef(_ctor_1(orig.reference));

  static final _loadDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PermissionGroupInfo_loadDescription")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence loadDescription(android.content.pm.PackageManager pm)
  /// Retrieve the textual description of this permission.  This
  /// will call back on the given PackageManager to load the description from
  /// the application.
  ///@param pm A PackageManager from which the label can be loaded; usually
  /// the PackageManager from which you originally retrieved this item.
  ///@return Returns a CharSequence containing the permission's description.
  /// If there is no description, null is returned.
  jni.JlObject loadDescription(PackageManager pm) =>
      jni.JlObject.fromRef(_loadDescription(reference, pm.reference));

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PermissionGroupInfo_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PermissionGroupInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PermissionGroupInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(os.Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags);
}

/// A special subclass of Intent that can have a custom label/icon
/// associated with it.  Primarily for use with Intent\#ACTION_CHOOSER.
class LabeledIntent extends content.Intent {
  LabeledIntent.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.LabeledIntent> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_LabeledIntent_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32)>>("android_content_pm_LabeledIntent_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void <init>(android.content.Intent origIntent, java.lang.String sourcePackage, int labelRes, int icon)
  /// Create a labeled intent from the given intent, supplying the label
  /// and icon resources for it.
  ///@param origIntent The original Intent to copy.
  ///@param sourcePackage The package in which the label and icon live.
  ///@param labelRes Resource containing the label, or 0 if none.
  ///@param icon Resource containing the icon, or 0 if none.
  LabeledIntent(content.Intent origIntent, jni.JlString sourcePackage,
      int labelRes, int icon)
      : super.fromRef(_ctor(
            origIntent.reference, sourcePackage.reference, labelRes, icon));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_pm_LabeledIntent_new_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Intent origIntent, java.lang.String sourcePackage, java.lang.CharSequence nonLocalizedLabel, int icon)
  /// Create a labeled intent from the given intent, supplying a textual
  /// label and icon resource for it.
  ///@param origIntent The original Intent to copy.
  ///@param sourcePackage The package in which the label and icon live.
  ///@param nonLocalizedLabel Concrete text to use for the label.
  ///@param icon Resource containing the icon, or 0 if none.
  LabeledIntent.ctor_1(content.Intent origIntent, jni.JlString sourcePackage,
      jni.JlObject nonLocalizedLabel, int icon)
      : super.fromRef(_ctor_1(origIntent.reference, sourcePackage.reference,
            nonLocalizedLabel.reference, icon));

  static final _ctor_2 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_content_pm_LabeledIntent_new_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void <init>(java.lang.String sourcePackage, int labelRes, int icon)
  /// Create a labeled intent with no intent data but supplying the label
  /// and icon resources for it.
  ///@param sourcePackage The package in which the label and icon live.
  ///@param labelRes Resource containing the label, or 0 if none.
  ///@param icon Resource containing the icon, or 0 if none.
  LabeledIntent.ctor_2(jni.JlString sourcePackage, int labelRes, int icon)
      : super.fromRef(_ctor_2(sourcePackage.reference, labelRes, icon));

  static final _ctor_3 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_pm_LabeledIntent_new_3")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String sourcePackage, java.lang.CharSequence nonLocalizedLabel, int icon)
  /// Create a labeled intent with no intent data but supplying a textual
  /// label and icon resource for it.
  ///@param sourcePackage The package in which the label and icon live.
  ///@param nonLocalizedLabel Concrete text to use for the label.
  ///@param icon Resource containing the icon, or 0 if none.
  LabeledIntent.ctor_3(
      jni.JlString sourcePackage, jni.JlObject nonLocalizedLabel, int icon)
      : super.fromRef(_ctor_3(
            sourcePackage.reference, nonLocalizedLabel.reference, icon));

  static final _getSourcePackage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LabeledIntent_getSourcePackage")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSourcePackage()
  /// Return the name of the package holding label and icon resources.
  jni.JlString getSourcePackage() =>
      jni.JlString.fromRef(_getSourcePackage(reference));

  static final _getLabelResource =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_LabeledIntent_getLabelResource")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLabelResource()
  /// Return any resource identifier that has been given for the label text.
  int getLabelResource() => _getLabelResource(reference);

  static final _getNonLocalizedLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LabeledIntent_getNonLocalizedLabel")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getNonLocalizedLabel()
  /// Return any concrete text that has been given for the label text.
  jni.JlObject getNonLocalizedLabel() =>
      jni.JlObject.fromRef(_getNonLocalizedLabel(reference));

  static final _getIconResource =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_LabeledIntent_getIconResource")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getIconResource()
  /// Return any resource identifier that has been given for the label icon.
  int getIconResource() => _getIconResource(reference);

  static final _loadLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LabeledIntent_loadLabel")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence loadLabel(android.content.pm.PackageManager pm)
  /// Retrieve the label associated with this object.  If the object does
  /// not have a label, null will be returned, in which case you will probably
  /// want to load the label from the underlying resolved info for the Intent.
  jni.JlObject loadLabel(PackageManager pm) =>
      jni.JlObject.fromRef(_loadLabel(reference, pm.reference));

  static final _loadIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LabeledIntent_loadIcon")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable loadIcon(android.content.pm.PackageManager pm)
  /// Retrieve the icon associated with this object.  If the object does
  /// not have a icon, null will be returned, in which case you will probably
  /// want to load the icon from the underlying resolved info for the Intent.
  jni.JlObject loadIcon(PackageManager pm) =>
      jni.JlObject.fromRef(_loadIcon(reference, pm.reference));

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_pm_LabeledIntent_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(os.Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags);

  static final _readFromParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LabeledIntent_readFromParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel in)
  void readFromParcel(os.Parcel in_) =>
      _readFromParcel(reference, in_.reference);
}

/// Holds information about a specific
/// android.content.ContentProvider content provider. This is returned by
/// android.content.pm.PackageManager\#resolveContentProvider(java.lang.String, int) PackageManager.resolveContentProvider().
class ProviderInfo extends ComponentInfo {
  ProviderInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.ProviderInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_ProviderInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int FLAG_SINGLE_USER
  /// Bit in \#flags: If set, a single instance of the provider will
  /// run for all users on the device.  Set from the
  /// android.R.attr\#singleUser attribute.
  static const FLAG_SINGLE_USER = 1073741824;

  /// from: public java.lang.String authority
  /// The name provider is published under content://
  static final _getauthority = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ProviderInfo_authority")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get authority => jni.JlString.fromRef(_getauthority(reference));
  static final _setauthority = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ProviderInfo_authority")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set authority(jni.JlString value) =>
      _setauthority(reference, value.reference);

  /// from: public int flags
  /// Options that have been set in the provider declaration in the
  /// manifest.
  /// These include: \#FLAG_SINGLE_USER.
  static final _getflags = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ProviderInfo_flags")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get flags => _getflags(reference);
  static final _setflags = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_ProviderInfo_flags")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set flags(int value) => _setflags(reference, value);

  /// from: public boolean grantUriPermissions
  /// If true, additional permissions to specific Uris in this content
  /// provider can be granted, as per the
  /// android.R.styleable\#AndroidManifestProvider_grantUriPermissions grantUriPermissions attribute.
  static final _getgrantUriPermissions = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ProviderInfo_grantUriPermissions")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  bool get grantUriPermissions => _getgrantUriPermissions(reference) != 0;
  static final _setgrantUriPermissions = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_android_content_pm_ProviderInfo_grantUriPermissions")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set grantUriPermissions(bool value) =>
      _setgrantUriPermissions(reference, value ? 1 : 0);

  /// from: public int initOrder
  /// Used to control initialization order of single-process providers
  ///  running in the same process.  Higher goes first.
  static final _getinitOrder = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ProviderInfo_initOrder")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get initOrder => _getinitOrder(reference);
  static final _setinitOrder = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_ProviderInfo_initOrder")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set initOrder(int value) => _setinitOrder(reference, value);

  /// from: public boolean isSyncable
  /// Whether or not this provider is syncable.
  ///@deprecated This flag is now being ignored. The current way to make a provider
  /// syncable is to provide a SyncAdapter service for a given provider/account type.
  static final _getisSyncable = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ProviderInfo_isSyncable")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  bool get isSyncable => _getisSyncable(reference) != 0;
  static final _setisSyncable = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("set_android_content_pm_ProviderInfo_isSyncable")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set isSyncable(bool value) => _setisSyncable(reference, value ? 1 : 0);

  /// from: public boolean multiprocess
  /// If true, this content provider allows multiple instances of itself
  ///  to run in different process.  If false, a single instances is always
  ///  run in \#processName.
  static final _getmultiprocess = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ProviderInfo_multiprocess")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  bool get multiprocess => _getmultiprocess(reference) != 0;
  static final _setmultiprocess = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_android_content_pm_ProviderInfo_multiprocess")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set multiprocess(bool value) => _setmultiprocess(reference, value ? 1 : 0);

  /// from: public android.content.pm.PathPermission[] pathPermissions
  /// If non-null, these are path-specific permissions that are allowed for
  /// accessing the provider.  Any permissions listed here will allow a
  /// holding client to access the provider, and the provider will check
  /// the URI it provides when making calls against the patterns here.
  static final _getpathPermissions = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ProviderInfo_pathPermissions")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get pathPermissions =>
      jni.JlObject.fromRef(_getpathPermissions(reference));
  static final _setpathPermissions = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ProviderInfo_pathPermissions")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set pathPermissions(jni.JlObject value) =>
      _setpathPermissions(reference, value.reference);

  /// from: public java.lang.String readPermission
  /// Optional permission required for read-only access this content
  /// provider.
  static final _getreadPermission = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ProviderInfo_readPermission")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get readPermission =>
      jni.JlString.fromRef(_getreadPermission(reference));
  static final _setreadPermission = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ProviderInfo_readPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set readPermission(jni.JlString value) =>
      _setreadPermission(reference, value.reference);

  /// from: public android.os.PatternMatcher[] uriPermissionPatterns
  /// If non-null, these are the patterns that are allowed for granting URI
  /// permissions.  Any URI that does not match one of these patterns will not
  /// allowed to be granted.  If null, all URIs are allowed.  The
  /// PackageManager\#GET_URI_PERMISSION_PATTERNS PackageManager.GET_URI_PERMISSION_PATTERNS flag must be specified for
  /// this field to be filled in.
  static final _geturiPermissionPatterns = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ProviderInfo_uriPermissionPatterns")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get uriPermissionPatterns =>
      jni.JlObject.fromRef(_geturiPermissionPatterns(reference));
  static final _seturiPermissionPatterns = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ProviderInfo_uriPermissionPatterns")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set uriPermissionPatterns(jni.JlObject value) =>
      _seturiPermissionPatterns(reference, value.reference);

  /// from: public java.lang.String writePermission
  /// Optional permission required for read/write access this content
  /// provider.
  static final _getwritePermission = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ProviderInfo_writePermission")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get writePermission =>
      jni.JlString.fromRef(_getwritePermission(reference));
  static final _setwritePermission = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ProviderInfo_writePermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set writePermission(jni.JlString value) =>
      _setwritePermission(reference, value.reference);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_ProviderInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ProviderInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ProviderInfo_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.pm.ProviderInfo orig)
  ProviderInfo.ctor_1(ProviderInfo orig)
      : super.fromRef(_ctor_1(orig.reference));

  static final _dump = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ProviderInfo_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  void dump(jni.JlObject pw, jni.JlString prefix) =>
      _dump(reference, pw.reference, prefix.reference);

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ProviderInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_pm_ProviderInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int parcelableFlags)
  void writeToParcel(os.Parcel out, int parcelableFlags) =>
      _writeToParcel(reference, out.reference, parcelableFlags);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ProviderInfo_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));
}

/// Description of permissions needed to access a particular path
/// in a ProviderInfo.
class PathPermission extends os.PatternMatcher {
  PathPermission.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.PathPermission> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_PathPermission_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PathPermission_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String pattern, int type, java.lang.String readPermission, java.lang.String writePermission)
  PathPermission(jni.JlString pattern, int type, jni.JlString readPermission,
      jni.JlString writePermission)
      : super.fromRef(_ctor(pattern.reference, type, readPermission.reference,
            writePermission.reference));

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PathPermission_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel src)
  PathPermission.ctor_1(os.Parcel src) : super.fromRef(_ctor_1(src.reference));

  static final _getReadPermission = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PathPermission_getReadPermission")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getReadPermission()
  jni.JlString getReadPermission() =>
      jni.JlString.fromRef(_getReadPermission(reference));

  static final _getWritePermission = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PathPermission_getWritePermission")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getWritePermission()
  jni.JlString getWritePermission() =>
      jni.JlString.fromRef(_getWritePermission(reference));

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PathPermission_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);
}

/// Definition of a single optional hardware or software feature of an Android
/// device.
///
/// This object is used to represent both features supported by a device and
/// features requested by an app. Apps can request that certain features be
/// available as a prerequisite to being installed through the
/// {@code uses-feature} tag in their manifests.
///
/// Starting in android.os.Build.VERSION_CODES\#N, features can have a
/// version, which must always be backwards compatible. That is, a device
/// claiming to support version 3 of a specific feature must support apps
/// requesting version 1 of that feature.
class FeatureInfo extends jni.JlObject {
  FeatureInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.FeatureInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_FeatureInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int FLAG_REQUIRED
  /// Set on \#flags if this feature has been required by the application.
  static const FLAG_REQUIRED = 1;

  /// from: static public final int GL_ES_VERSION_UNDEFINED
  /// Default value for \#reqGlEsVersion;
  static const GL_ES_VERSION_UNDEFINED = 0;

  /// from: public int flags
  /// Additional flags.  May be zero or more of \#FLAG_REQUIRED.
  static final _getflags = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_FeatureInfo_flags")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get flags => _getflags(reference);
  static final _setflags = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_FeatureInfo_flags")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set flags(int value) => _setflags(reference, value);

  /// from: public java.lang.String name
  /// The name of this feature, for example "android.hardware.camera".  If
  /// this is null, then this is an OpenGL ES version feature as described
  /// in \#reqGlEsVersion.
  static final _getname = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_FeatureInfo_name")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get name => jni.JlString.fromRef(_getname(reference));
  static final _setname = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_FeatureInfo_name")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set name(jni.JlString value) => _setname(reference, value.reference);

  /// from: public int reqGlEsVersion
  /// The GLES version used by an application. The upper order 16 bits represent the
  /// major version and the lower order 16 bits the minor version.  Only valid
  /// if \#name is null.
  static final _getreqGlEsVersion = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_FeatureInfo_reqGlEsVersion")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get reqGlEsVersion => _getreqGlEsVersion(reference);
  static final _setreqGlEsVersion = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_FeatureInfo_reqGlEsVersion")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set reqGlEsVersion(int value) => _setreqGlEsVersion(reference, value);

  /// from: public int version
  /// If this object represents a feature supported by a device, this is the
  /// maximum version of this feature supported by the device. The device
  /// implicitly supports all older versions of this feature.
  ///
  /// If this object represents a feature requested by an app, this is the
  /// minimum version of the feature required by the app.
  ///
  /// When a feature version is undefined by a device, it's assumed to be
  /// version 0.
  static final _getversion = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_FeatureInfo_version")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get version => _getversion(reference);
  static final _setversion = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_FeatureInfo_version")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set version(int value) => _setversion(reference, value);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_FeatureInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  FeatureInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_FeatureInfo_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.pm.FeatureInfo orig)
  FeatureInfo.ctor_1(FeatureInfo orig) : super.fromRef(_ctor_1(orig.reference));

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_FeatureInfo_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_FeatureInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_pm_FeatureInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(os.Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags);

  static final _getGlEsVersion = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_FeatureInfo_getGlEsVersion")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getGlEsVersion()
  /// This method extracts the major and minor version of reqGLEsVersion attribute
  /// and returns it as a string. Say reqGlEsVersion value of 0x00010002 is returned
  /// as 1.2
  ///@return String representation of the reqGlEsVersion attribute
  jni.JlString getGlEsVersion() =>
      jni.JlString.fromRef(_getGlEsVersion(reference));
}

/// Base class containing information common to all application components
/// (ActivityInfo, ServiceInfo).  This class is not intended
/// to be used by itself; it is simply here to share common definitions
/// between all application components.  As such, it does not itself
/// implement Parcelable, but does provide convenience methods to assist
/// in the implementation of Parcelable in subclasses.
class ComponentInfo extends PackageItemInfo {
  ComponentInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: public android.content.pm.ApplicationInfo applicationInfo
  /// Global information about the application/package this component is a
  /// part of.
  static final _getapplicationInfo = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ComponentInfo_applicationInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  ApplicationInfo get applicationInfo =>
      ApplicationInfo.fromRef(_getapplicationInfo(reference));
  static final _setapplicationInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ComponentInfo_applicationInfo")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set applicationInfo(ApplicationInfo value) =>
      _setapplicationInfo(reference, value.reference);

  /// from: public int descriptionRes
  /// A string resource identifier (in the package's resources) containing
  /// a user-readable description of the component.  From the "description"
  /// attribute or, if not set, 0.
  static final _getdescriptionRes = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ComponentInfo_descriptionRes")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get descriptionRes => _getdescriptionRes(reference);
  static final _setdescriptionRes = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ComponentInfo_descriptionRes")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set descriptionRes(int value) => _setdescriptionRes(reference, value);

  /// from: public boolean directBootAware
  /// Indicates if this component is aware of direct boot lifecycle, and can be
  /// safely run before the user has entered their credentials (such as a lock
  /// pattern or PIN).
  static final _getdirectBootAware = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ComponentInfo_directBootAware")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  bool get directBootAware => _getdirectBootAware(reference) != 0;
  static final _setdirectBootAware = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_android_content_pm_ComponentInfo_directBootAware")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set directBootAware(bool value) =>
      _setdirectBootAware(reference, value ? 1 : 0);

  /// from: public boolean enabled
  /// Indicates whether or not this component may be instantiated.  Note that this value can be
  /// overridden by the one in its parent ApplicationInfo.
  static final _getenabled = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ComponentInfo_enabled")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  bool get enabled => _getenabled(reference) != 0;
  static final _setenabled = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("set_android_content_pm_ComponentInfo_enabled")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set enabled(bool value) => _setenabled(reference, value ? 1 : 0);

  /// from: public boolean exported
  /// Set to true if this component is available for use by other applications.
  /// Comes from android.R.attr\#exported android:exported of the
  /// &lt;activity&gt;, &lt;receiver&gt;, &lt;service&gt;, or
  /// &lt;provider&gt; tag.
  static final _getexported = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ComponentInfo_exported")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  bool get exported => _getexported(reference) != 0;
  static final _setexported = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("set_android_content_pm_ComponentInfo_exported")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set exported(bool value) => _setexported(reference, value ? 1 : 0);

  /// from: public java.lang.String processName
  /// The name of the process this component should run in.
  /// From the "android:process" attribute or, if not set, the same
  /// as <var>applicationInfo.processName</var>.
  static final _getprocessName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ComponentInfo_processName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get processName =>
      jni.JlString.fromRef(_getprocessName(reference));
  static final _setprocessName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ComponentInfo_processName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set processName(jni.JlString value) =>
      _setprocessName(reference, value.reference);

  /// from: public java.lang.String splitName
  /// The name of the split in which this component is declared.
  /// Null if the component was declared in the base APK.
  static final _getsplitName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ComponentInfo_splitName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get splitName => jni.JlString.fromRef(_getsplitName(reference));
  static final _setsplitName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ComponentInfo_splitName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set splitName(jni.JlString value) =>
      _setsplitName(reference, value.reference);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_ComponentInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ComponentInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ComponentInfo_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.pm.ComponentInfo orig)
  ComponentInfo.ctor_1(ComponentInfo orig)
      : super.fromRef(_ctor_1(orig.reference));

  static final _ctor_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ComponentInfo_new_2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void <init>(android.os.Parcel source)
  ComponentInfo.ctor_2(os.Parcel source)
      : super.fromRef(_ctor_2(source.reference));

  static final _isEnabled =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ComponentInfo_isEnabled")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isEnabled()
  /// Return whether this component and its enclosing application are enabled.
  bool isEnabled() => _isEnabled(reference) != 0;

  static final _getIconResource =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ComponentInfo_getIconResource")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getIconResource()
  /// Return the icon resource identifier to use for this component.  If
  /// the component defines an icon, that is used; else, the application
  /// icon is used.
  ///@return The icon associated with this component.
  int getIconResource() => _getIconResource(reference);

  static final _getLogoResource =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ComponentInfo_getLogoResource")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getLogoResource()
  /// Return the logo resource identifier to use for this component.  If
  /// the component defines a logo, that is used; else, the application
  /// logo is used.
  ///@return The logo associated with this component.
  int getLogoResource() => _getLogoResource(reference);

  static final _getBannerResource =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ComponentInfo_getBannerResource")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getBannerResource()
  /// Return the banner resource identifier to use for this component. If the
  /// component defines a banner, that is used; else, the application banner is
  /// used.
  ///@return The banner associated with this component.
  int getBannerResource() => _getBannerResource(reference);

  static final _dumpFront = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ComponentInfo_dumpFront")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void dumpFront(android.util.Printer pw, java.lang.String prefix)
  void dumpFront(jni.JlObject pw, jni.JlString prefix) =>
      _dumpFront(reference, pw.reference, prefix.reference);

  static final _dumpBack = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ComponentInfo_dumpBack")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void dumpBack(android.util.Printer pw, java.lang.String prefix)
  void dumpBack(jni.JlObject pw, jni.JlString prefix) =>
      _dumpBack(reference, pw.reference, prefix.reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_pm_ComponentInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(os.Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags);
}

/// Class for retrieving various kinds of information related to the application
/// packages that are currently installed on the device.
///
/// You can find this class through Context\#getPackageManager.
class PackageManager extends jni.JlObject {
  PackageManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int CERT_INPUT_RAW_X509
  /// Certificate input bytes: the input bytes represent an encoded X.509 Certificate which could
  /// be generated using an {@code CertificateFactory}
  static const CERT_INPUT_RAW_X509 = 0;

  /// from: static public final int CERT_INPUT_SHA256
  /// Certificate input bytes: the input bytes represent the SHA256 output of an encoded X.509
  /// Certificate.
  static const CERT_INPUT_SHA256 = 1;

  /// from: static public final int COMPONENT_ENABLED_STATE_DEFAULT
  /// Flag for \#setApplicationEnabledSetting(String, int, int) and
  /// \#setComponentEnabledSetting(ComponentName, int, int): This
  /// component or application is in its default enabled state (as specified in
  /// its manifest).
  ///
  /// Explicitly setting the component state to this value restores it's
  /// enabled state to whatever is set in the manifest.
  static const COMPONENT_ENABLED_STATE_DEFAULT = 0;

  /// from: static public final int COMPONENT_ENABLED_STATE_DISABLED
  /// Flag for \#setApplicationEnabledSetting(String, int, int)
  /// and \#setComponentEnabledSetting(ComponentName, int, int): This
  /// component or application has been explicitly disabled, regardless of
  /// what it has specified in its manifest.
  static const COMPONENT_ENABLED_STATE_DISABLED = 2;

  /// from: static public final int COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED
  /// Flag for \#setApplicationEnabledSetting(String, int, int) only: This
  /// application should be considered, until the point where the user actually
  /// wants to use it.  This means that it will not normally show up to the user
  /// (such as in the launcher), but various parts of the user interface can
  /// use \#GET_DISABLED_UNTIL_USED_COMPONENTS to still see it and allow
  /// the user to select it (as for example an IME, device admin, etc).  Such code,
  /// once the user has selected the app, should at that point also make it enabled.
  /// This option currently <strong>can not</strong> be used with
  /// \#setComponentEnabledSetting(ComponentName, int, int).
  static const COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED = 4;

  /// from: static public final int COMPONENT_ENABLED_STATE_DISABLED_USER
  /// Flag for \#setApplicationEnabledSetting(String, int, int) only: The
  /// user has explicitly disabled the application, regardless of what it has
  /// specified in its manifest.  Because this is due to the user's request,
  /// they may re-enable it if desired through the appropriate system UI.  This
  /// option currently <strong>cannot</strong> be used with
  /// \#setComponentEnabledSetting(ComponentName, int, int).
  static const COMPONENT_ENABLED_STATE_DISABLED_USER = 3;

  /// from: static public final int COMPONENT_ENABLED_STATE_ENABLED
  /// Flag for \#setApplicationEnabledSetting(String, int, int)
  /// and \#setComponentEnabledSetting(ComponentName, int, int): This
  /// component or application has been explictily enabled, regardless of
  /// what it has specified in its manifest.
  static const COMPONENT_ENABLED_STATE_ENABLED = 1;

  /// from: static public final int DONT_KILL_APP
  /// Flag parameter for
  /// \#setComponentEnabledSetting(android.content.ComponentName, int, int) to indicate
  /// that you don't want to kill the app containing the component.  Be careful when you set this
  /// since changing component states can make the containing application's behavior unpredictable.
  static const DONT_KILL_APP = 1;

  /// from: static public final java.lang.String EXTRA_VERIFICATION_ID
  /// Extra field name for the ID of a package pending verification. Passed to
  /// a package verifier and is used to call back to
  /// PackageManager\#verifyPendingInstall(int, int)
  static const EXTRA_VERIFICATION_ID =
      "android.content.pm.extra.VERIFICATION_ID";

  /// from: static public final java.lang.String EXTRA_VERIFICATION_RESULT
  /// Extra field name for the result of a verification, either
  /// \#VERIFICATION_ALLOW, or \#VERIFICATION_REJECT.
  /// Passed to package verifiers after a package is verified.
  static const EXTRA_VERIFICATION_RESULT =
      "android.content.pm.extra.VERIFICATION_RESULT";

  /// from: static public final java.lang.String FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device supports running activities on secondary displays.
  static const FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS =
      "android.software.activities_on_secondary_displays";

  /// from: static public final java.lang.String FEATURE_APP_WIDGETS
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports app widgets.
  static const FEATURE_APP_WIDGETS = "android.software.app_widgets";

  /// from: static public final java.lang.String FEATURE_AUDIO_LOW_LATENCY
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature: The device's
  /// audio pipeline is low-latency, more suitable for audio applications sensitive to delays or
  /// lag in sound input or output.
  static const FEATURE_AUDIO_LOW_LATENCY = "android.hardware.audio.low_latency";

  /// from: static public final java.lang.String FEATURE_AUDIO_OUTPUT
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes at least one form of audio
  /// output, as defined in the Android Compatibility Definition Document (CDD)
  /// <a href="https://source.android.com/compatibility/android-cdd\#7_8_audio">section 7.8 Audio</a>.
  static const FEATURE_AUDIO_OUTPUT = "android.hardware.audio.output";

  /// from: static public final java.lang.String FEATURE_AUDIO_PRO
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device has professional audio level of functionality and performance.
  static const FEATURE_AUDIO_PRO = "android.hardware.audio.pro";

  /// from: static public final java.lang.String FEATURE_AUTOFILL
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device supports autofill of user credentials, addresses, credit cards, etc
  /// via integration with android.service.autofill.AutofillService autofill
  /// providers.
  static const FEATURE_AUTOFILL = "android.software.autofill";

  /// from: static public final java.lang.String FEATURE_AUTOMOTIVE
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: This is a device dedicated to showing UI
  /// on a vehicle headunit. A headunit here is defined to be inside a
  /// vehicle that may or may not be moving. A headunit uses either a
  /// primary display in the center console and/or additional displays in
  /// the instrument cluster or elsewhere in the vehicle. Headunit display(s)
  /// have limited size and resolution. The user will likely be focused on
  /// driving so limiting driver distraction is a primary concern. User input
  /// can be a variety of hard buttons, touch, rotary controllers and even mouse-
  /// like interfaces.
  static const FEATURE_AUTOMOTIVE = "android.hardware.type.automotive";

  /// from: static public final java.lang.String FEATURE_BACKUP
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device can perform backup and restore operations on installed applications.
  static const FEATURE_BACKUP = "android.software.backup";

  /// from: static public final java.lang.String FEATURE_BLUETOOTH
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device is capable of communicating with
  /// other devices via Bluetooth.
  static const FEATURE_BLUETOOTH = "android.hardware.bluetooth";

  /// from: static public final java.lang.String FEATURE_BLUETOOTH_LE
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device is capable of communicating with
  /// other devices via Bluetooth Low Energy radio.
  static const FEATURE_BLUETOOTH_LE = "android.hardware.bluetooth_le";

  /// from: static public final java.lang.String FEATURE_CAMERA
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device has a camera facing away
  /// from the screen.
  static const FEATURE_CAMERA = "android.hardware.camera";

  /// from: static public final java.lang.String FEATURE_CAMERA_ANY
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device has at least one camera pointing in
  /// some direction, or can support an external camera being connected to it.
  static const FEATURE_CAMERA_ANY = "android.hardware.camera.any";

  /// from: static public final java.lang.String FEATURE_CAMERA_AR
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature: At least one
  /// of the cameras on the device supports the
  /// android.hardware.camera2.CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_MOTION_TRACKING MOTION_TRACKING capability level.
  static const FEATURE_CAMERA_AR = "android.hardware.camera.ar";

  /// from: static public final java.lang.String FEATURE_CAMERA_AUTOFOCUS
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device's camera supports auto-focus.
  static const FEATURE_CAMERA_AUTOFOCUS = "android.hardware.camera.autofocus";

  /// from: static public final java.lang.String FEATURE_CAMERA_CAPABILITY_MANUAL_POST_PROCESSING
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature: At least one
  /// of the cameras on the device supports the
  /// android.hardware.camera2.CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING manual post-processing
  /// capability level.
  static const FEATURE_CAMERA_CAPABILITY_MANUAL_POST_PROCESSING =
      "android.hardware.camera.capability.manual_post_processing";

  /// from: static public final java.lang.String FEATURE_CAMERA_CAPABILITY_MANUAL_SENSOR
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature: At least one
  /// of the cameras on the device supports the
  /// android.hardware.camera2.CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR manual sensor
  /// capability level.
  static const FEATURE_CAMERA_CAPABILITY_MANUAL_SENSOR =
      "android.hardware.camera.capability.manual_sensor";

  /// from: static public final java.lang.String FEATURE_CAMERA_CAPABILITY_RAW
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature: At least one
  /// of the cameras on the device supports the
  /// android.hardware.camera2.CameraMetadata\#REQUEST_AVAILABLE_CAPABILITIES_RAW RAW
  /// capability level.
  static const FEATURE_CAMERA_CAPABILITY_RAW =
      "android.hardware.camera.capability.raw";

  /// from: static public final java.lang.String FEATURE_CAMERA_EXTERNAL
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device can support having an external camera connected to it.
  /// The external camera may not always be connected or available to applications to use.
  static const FEATURE_CAMERA_EXTERNAL = "android.hardware.camera.external";

  /// from: static public final java.lang.String FEATURE_CAMERA_FLASH
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device's camera supports flash.
  static const FEATURE_CAMERA_FLASH = "android.hardware.camera.flash";

  /// from: static public final java.lang.String FEATURE_CAMERA_FRONT
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device has a front facing camera.
  static const FEATURE_CAMERA_FRONT = "android.hardware.camera.front";

  /// from: static public final java.lang.String FEATURE_CAMERA_LEVEL_FULL
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature: At least one
  /// of the cameras on the device supports the
  /// android.hardware.camera2.CameraCharacteristics\#INFO_SUPPORTED_HARDWARE_LEVEL full hardware
  /// capability level.
  static const FEATURE_CAMERA_LEVEL_FULL = "android.hardware.camera.level.full";

  /// from: static public final java.lang.String FEATURE_CANT_SAVE_STATE
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports the
  /// android.R.attr\#cantSaveState API.
  static const FEATURE_CANT_SAVE_STATE = "android.software.cant_save_state";

  /// from: static public final java.lang.String FEATURE_COMPANION_DEVICE_SETUP
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device supports android.companion.CompanionDeviceManager\#associate associating
  /// with devices via android.companion.CompanionDeviceManager.
  static const FEATURE_COMPANION_DEVICE_SETUP =
      "android.software.companion_device_setup";

  /// from: static public final java.lang.String FEATURE_CONNECTION_SERVICE
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The Connection Service API is enabled on the device.
  static const FEATURE_CONNECTION_SERVICE =
      "android.software.connectionservice";

  /// from: static public final java.lang.String FEATURE_CONSUMER_IR
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device is capable of communicating with
  /// consumer IR devices.
  static const FEATURE_CONSUMER_IR = "android.hardware.consumerir";

  /// from: static public final java.lang.String FEATURE_DEVICE_ADMIN
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports device policy enforcement via device admins.
  static const FEATURE_DEVICE_ADMIN = "android.software.device_admin";

  /// from: static public final java.lang.String FEATURE_EMBEDDED
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: This is a device for IoT and may not have an UI. An embedded
  /// device is defined as a full stack Android device with or without a display and no
  /// user-installable apps.
  static const FEATURE_EMBEDDED = "android.hardware.type.embedded";

  /// from: static public final java.lang.String FEATURE_ETHERNET
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: This device supports ethernet.
  static const FEATURE_ETHERNET = "android.hardware.ethernet";

  /// from: static public final java.lang.String FEATURE_FAKETOUCH
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device does not have a touch screen, but
  /// does support touch emulation for basic events. For instance, the
  /// device might use a mouse or remote control to drive a cursor, and
  /// emulate basic touch pointer events like down, up, drag, etc. All
  /// devices that support android.hardware.touchscreen or a sub-feature are
  /// presumed to also support faketouch.
  static const FEATURE_FAKETOUCH = "android.hardware.faketouch";

  /// from: static public final java.lang.String FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device does not have a touch screen, but
  /// does support touch emulation for basic events that supports distinct
  /// tracking of two or more fingers.  This is an extension of
  /// \#FEATURE_FAKETOUCH for input devices with this capability.  Note
  /// that unlike a distinct multitouch screen as defined by
  /// \#FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT, these kinds of input
  /// devices will not actually provide full two-finger gestures since the
  /// input is being transformed to cursor movement on the screen.  That is,
  /// single finger gestures will move a cursor; two-finger swipes will
  /// result in single-finger touch events; other two-finger gestures will
  /// result in the corresponding two-finger touch event.
  static const FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT =
      "android.hardware.faketouch.multitouch.distinct";

  /// from: static public final java.lang.String FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device does not have a touch screen, but
  /// does support touch emulation for basic events that supports tracking
  /// a hand of fingers (5 or more fingers) fully independently.
  /// This is an extension of
  /// \#FEATURE_FAKETOUCH for input devices with this capability.  Note
  /// that unlike a multitouch screen as defined by
  /// \#FEATURE_TOUCHSCREEN_MULTITOUCH_JAZZHAND, not all two finger
  /// gestures can be detected due to the limitations described for
  /// \#FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT.
  static const FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND =
      "android.hardware.faketouch.multitouch.jazzhand";

  /// from: static public final java.lang.String FEATURE_FINGERPRINT
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device has biometric hardware to detect a fingerprint.
  static const FEATURE_FINGERPRINT = "android.hardware.fingerprint";

  /// from: static public final java.lang.String FEATURE_FREEFORM_WINDOW_MANAGEMENT
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports freeform window management.
  /// Windows have title bars and can be moved and resized.
  static const FEATURE_FREEFORM_WINDOW_MANAGEMENT =
      "android.software.freeform_window_management";

  /// from: static public final java.lang.String FEATURE_GAMEPAD
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device has all of the inputs necessary to be considered a compatible game controller, or
  /// includes a compatible game controller in the box.
  static const FEATURE_GAMEPAD = "android.hardware.gamepad";

  /// from: static public final java.lang.String FEATURE_HIFI_SENSORS
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports high fidelity sensor processing
  /// capabilities.
  static const FEATURE_HIFI_SENSORS = "android.hardware.sensor.hifi_sensors";

  /// from: static public final java.lang.String FEATURE_HOME_SCREEN
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports a home screen that is replaceable
  /// by third party applications.
  static const FEATURE_HOME_SCREEN = "android.software.home_screen";

  /// from: static public final java.lang.String FEATURE_INPUT_METHODS
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports adding new input methods implemented
  /// with the android.inputmethodservice.InputMethodService API.
  static const FEATURE_INPUT_METHODS = "android.software.input_methods";

  /// from: static public final java.lang.String FEATURE_LEANBACK
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports leanback UI. This is
  /// typically used in a living room television experience, but is a software
  /// feature unlike \#FEATURE_TELEVISION. Devices running with this
  /// feature will use resources associated with the "television" UI mode.
  static const FEATURE_LEANBACK = "android.software.leanback";

  /// from: static public final java.lang.String FEATURE_LEANBACK_ONLY
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports only leanback UI. Only
  /// applications designed for this experience should be run, though this is
  /// not enforced by the system.
  static const FEATURE_LEANBACK_ONLY = "android.software.leanback_only";

  /// from: static public final java.lang.String FEATURE_LIVE_TV
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports live TV and can display
  /// contents from TV inputs implemented with the
  /// android.media.tv.TvInputService API.
  static const FEATURE_LIVE_TV = "android.software.live_tv";

  /// from: static public final java.lang.String FEATURE_LIVE_WALLPAPER
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports live wallpapers.
  static const FEATURE_LIVE_WALLPAPER = "android.software.live_wallpaper";

  /// from: static public final java.lang.String FEATURE_LOCATION
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports one or more methods of
  /// reporting current location.
  static const FEATURE_LOCATION = "android.hardware.location";

  /// from: static public final java.lang.String FEATURE_LOCATION_GPS
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device has a Global Positioning System
  /// receiver and can report precise location.
  static const FEATURE_LOCATION_GPS = "android.hardware.location.gps";

  /// from: static public final java.lang.String FEATURE_LOCATION_NETWORK
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device can report location with coarse
  /// accuracy using a network-based geolocation system.
  static const FEATURE_LOCATION_NETWORK = "android.hardware.location.network";

  /// from: static public final java.lang.String FEATURE_MANAGED_USERS
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device supports creating secondary users and managed profiles via
  /// DevicePolicyManager.
  static const FEATURE_MANAGED_USERS = "android.software.managed_users";

  /// from: static public final java.lang.String FEATURE_MICROPHONE
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device can record audio via a
  /// microphone.
  static const FEATURE_MICROPHONE = "android.hardware.microphone";

  /// from: static public final java.lang.String FEATURE_MIDI
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device has a full implementation of the android.media.midi.* APIs.
  static const FEATURE_MIDI = "android.software.midi";

  /// from: static public final java.lang.String FEATURE_NFC
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device can communicate using Near-Field
  /// Communications (NFC).
  static const FEATURE_NFC = "android.hardware.nfc";

  /// from: static public final java.lang.String FEATURE_NFC_HOST_CARD_EMULATION
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports host-
  /// based NFC card emulation.
  static const FEATURE_NFC_HOST_CARD_EMULATION = "android.hardware.nfc.hce";

  /// from: static public final java.lang.String FEATURE_NFC_HOST_CARD_EMULATION_NFCF
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports host-
  /// based NFC-F card emulation.
  static const FEATURE_NFC_HOST_CARD_EMULATION_NFCF =
      "android.hardware.nfc.hcef";

  /// from: static public final java.lang.String FEATURE_OPENGLES_EXTENSION_PACK
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports the OpenGL ES
  /// <a href="http://www.khronos.org/registry/gles/extensions/ANDROID/ANDROID_extension_pack_es31a.txt">
  /// Android Extension Pack</a>.
  static const FEATURE_OPENGLES_EXTENSION_PACK =
      "android.hardware.opengles.aep";

  /// from: static public final java.lang.String FEATURE_PC
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: This is a device dedicated to be primarily used
  /// with keyboard, mouse or touchpad. This includes traditional desktop
  /// computers, laptops and variants such as convertibles or detachables.
  /// Due to the larger screen, the device will most likely use the
  /// \#FEATURE_FREEFORM_WINDOW_MANAGEMENT feature as well.
  static const FEATURE_PC = "android.hardware.type.pc";

  /// from: static public final java.lang.String FEATURE_PICTURE_IN_PICTURE
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device supports picture-in-picture multi-window mode.
  static const FEATURE_PICTURE_IN_PICTURE =
      "android.software.picture_in_picture";

  /// from: static public final java.lang.String FEATURE_PRINTING
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device supports printing.
  static const FEATURE_PRINTING = "android.software.print";

  /// from: static public final java.lang.String FEATURE_RAM_LOW
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device's
  /// ActivityManager\#isLowRamDevice() ActivityManager.isLowRamDevice() method returns
  /// true.
  static const FEATURE_RAM_LOW = "android.hardware.ram.low";

  /// from: static public final java.lang.String FEATURE_RAM_NORMAL
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device's
  /// ActivityManager\#isLowRamDevice() ActivityManager.isLowRamDevice() method returns
  /// false.
  static const FEATURE_RAM_NORMAL = "android.hardware.ram.normal";

  /// from: static public final java.lang.String FEATURE_SCREEN_LANDSCAPE
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports landscape orientation
  /// screens.  For backwards compatibility, you can assume that if neither
  /// this nor \#FEATURE_SCREEN_PORTRAIT is set then the device supports
  /// both portrait and landscape.
  static const FEATURE_SCREEN_LANDSCAPE = "android.hardware.screen.landscape";

  /// from: static public final java.lang.String FEATURE_SCREEN_PORTRAIT
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports portrait orientation
  /// screens.  For backwards compatibility, you can assume that if neither
  /// this nor \#FEATURE_SCREEN_LANDSCAPE is set then the device supports
  /// both portrait and landscape.
  static const FEATURE_SCREEN_PORTRAIT = "android.hardware.screen.portrait";

  /// from: static public final java.lang.String FEATURE_SECURELY_REMOVES_USERS
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device supports secure removal of users. When a user is deleted the data associated
  /// with that user is securely deleted and no longer available.
  static const FEATURE_SECURELY_REMOVES_USERS =
      "android.software.securely_removes_users";

  /// from: static public final java.lang.String FEATURE_SENSOR_ACCELEROMETER
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes an accelerometer.
  static const FEATURE_SENSOR_ACCELEROMETER =
      "android.hardware.sensor.accelerometer";

  /// from: static public final java.lang.String FEATURE_SENSOR_AMBIENT_TEMPERATURE
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes an ambient temperature sensor.
  static const FEATURE_SENSOR_AMBIENT_TEMPERATURE =
      "android.hardware.sensor.ambient_temperature";

  /// from: static public final java.lang.String FEATURE_SENSOR_BAROMETER
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes a barometer (air
  /// pressure sensor.)
  static const FEATURE_SENSOR_BAROMETER = "android.hardware.sensor.barometer";

  /// from: static public final java.lang.String FEATURE_SENSOR_COMPASS
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes a magnetometer (compass).
  static const FEATURE_SENSOR_COMPASS = "android.hardware.sensor.compass";

  /// from: static public final java.lang.String FEATURE_SENSOR_GYROSCOPE
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes a gyroscope.
  static const FEATURE_SENSOR_GYROSCOPE = "android.hardware.sensor.gyroscope";

  /// from: static public final java.lang.String FEATURE_SENSOR_HEART_RATE
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes a heart rate monitor.
  static const FEATURE_SENSOR_HEART_RATE = "android.hardware.sensor.heartrate";

  /// from: static public final java.lang.String FEATURE_SENSOR_HEART_RATE_ECG
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The heart rate sensor on this device is an Electrocardiogram.
  static const FEATURE_SENSOR_HEART_RATE_ECG =
      "android.hardware.sensor.heartrate.ecg";

  /// from: static public final java.lang.String FEATURE_SENSOR_LIGHT
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes a light sensor.
  static const FEATURE_SENSOR_LIGHT = "android.hardware.sensor.light";

  /// from: static public final java.lang.String FEATURE_SENSOR_PROXIMITY
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes a proximity sensor.
  static const FEATURE_SENSOR_PROXIMITY = "android.hardware.sensor.proximity";

  /// from: static public final java.lang.String FEATURE_SENSOR_RELATIVE_HUMIDITY
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes a relative humidity sensor.
  static const FEATURE_SENSOR_RELATIVE_HUMIDITY =
      "android.hardware.sensor.relative_humidity";

  /// from: static public final java.lang.String FEATURE_SENSOR_STEP_COUNTER
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes a hardware step counter.
  static const FEATURE_SENSOR_STEP_COUNTER =
      "android.hardware.sensor.stepcounter";

  /// from: static public final java.lang.String FEATURE_SENSOR_STEP_DETECTOR
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device includes a hardware step detector.
  static const FEATURE_SENSOR_STEP_DETECTOR =
      "android.hardware.sensor.stepdetector";

  /// from: static public final java.lang.String FEATURE_SIP
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The SIP API is enabled on the device.
  static const FEATURE_SIP = "android.software.sip";

  /// from: static public final java.lang.String FEATURE_SIP_VOIP
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports SIP-based VOIP.
  static const FEATURE_SIP_VOIP = "android.software.sip.voip";

  /// from: static public final java.lang.String FEATURE_STRONGBOX_KEYSTORE
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device has a StrongBox hardware-backed Keystore.
  static const FEATURE_STRONGBOX_KEYSTORE =
      "android.hardware.strongbox_keystore";

  /// from: static public final java.lang.String FEATURE_TELEPHONY
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device has a telephony radio with data
  /// communication support.
  static const FEATURE_TELEPHONY = "android.hardware.telephony";

  /// from: static public final java.lang.String FEATURE_TELEPHONY_CDMA
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device has a CDMA telephony stack.
  static const FEATURE_TELEPHONY_CDMA = "android.hardware.telephony.cdma";

  /// from: static public final java.lang.String FEATURE_TELEPHONY_EUICC
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature: The device
  /// supports embedded subscriptions on eUICCs.
  static const FEATURE_TELEPHONY_EUICC = "android.hardware.telephony.euicc";

  /// from: static public final java.lang.String FEATURE_TELEPHONY_GSM
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device has a GSM telephony stack.
  static const FEATURE_TELEPHONY_GSM = "android.hardware.telephony.gsm";

  /// from: static public final java.lang.String FEATURE_TELEPHONY_MBMS
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature: The device
  /// supports cell-broadcast reception using the MBMS APIs.
  static const FEATURE_TELEPHONY_MBMS = "android.hardware.telephony.mbms";

  /// from: static public final java.lang.String FEATURE_TELEVISION
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: This is a device dedicated to showing UI
  /// on a television.  Television here is defined to be a typical living
  /// room television experience: displayed on a big screen, where the user
  /// is sitting far away from it, and the dominant form of input will be
  /// something like a DPAD, not through touch or mouse.
  ///@deprecated use \#FEATURE_LEANBACK instead.
  static const FEATURE_TELEVISION = "android.hardware.type.television";

  /// from: static public final java.lang.String FEATURE_TOUCHSCREEN
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device's display has a touch screen.
  static const FEATURE_TOUCHSCREEN = "android.hardware.touchscreen";

  /// from: static public final java.lang.String FEATURE_TOUCHSCREEN_MULTITOUCH
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device's touch screen supports
  /// multitouch sufficient for basic two-finger gesture detection.
  static const FEATURE_TOUCHSCREEN_MULTITOUCH =
      "android.hardware.touchscreen.multitouch";

  /// from: static public final java.lang.String FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device's touch screen is capable of
  /// tracking two or more fingers fully independently.
  static const FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT =
      "android.hardware.touchscreen.multitouch.distinct";

  /// from: static public final java.lang.String FEATURE_TOUCHSCREEN_MULTITOUCH_JAZZHAND
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device's touch screen is capable of
  /// tracking a full hand of fingers fully independently -- that is, 5 or
  /// more simultaneous independent pointers.
  static const FEATURE_TOUCHSCREEN_MULTITOUCH_JAZZHAND =
      "android.hardware.touchscreen.multitouch.jazzhand";

  /// from: static public final java.lang.String FEATURE_USB_ACCESSORY
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports connecting to USB accessories.
  static const FEATURE_USB_ACCESSORY = "android.hardware.usb.accessory";

  /// from: static public final java.lang.String FEATURE_USB_HOST
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports connecting to USB devices
  /// as the USB host.
  static const FEATURE_USB_HOST = "android.hardware.usb.host";

  /// from: static public final java.lang.String FEATURE_VERIFIED_BOOT
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device supports verified boot.
  static const FEATURE_VERIFIED_BOOT = "android.software.verified_boot";

  /// from: static public final java.lang.String FEATURE_VR_HEADTRACKING
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device implements headtracking suitable for a VR device.
  static const FEATURE_VR_HEADTRACKING = "android.hardware.vr.headtracking";

  /// from: static public final java.lang.String FEATURE_VR_MODE
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device implements an optimized mode for virtual reality (VR) applications that handles
  /// stereoscopic rendering of notifications, and disables most monocular system UI components
  /// while a VR application has user focus.
  /// Devices declaring this feature must include an application implementing a
  /// android.service.vr.VrListenerService that can be targeted by VR applications via
  /// android.app.Activity\#setVrModeEnabled.
  ///@deprecated use \#FEATURE_VR_MODE_HIGH_PERFORMANCE instead.
  static const FEATURE_VR_MODE = "android.software.vr.mode";

  /// from: static public final java.lang.String FEATURE_VR_MODE_HIGH_PERFORMANCE
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device implements an optimized mode for virtual reality (VR) applications that handles
  /// stereoscopic rendering of notifications, disables most monocular system UI components
  /// while a VR application has user focus and meets extra CDD requirements to provide a
  /// high-quality VR experience.
  /// Devices declaring this feature must include an application implementing a
  /// android.service.vr.VrListenerService that can be targeted by VR applications via
  /// android.app.Activity\#setVrModeEnabled.
  /// and must meet CDD requirements to provide a high-quality VR experience.
  static const FEATURE_VR_MODE_HIGH_PERFORMANCE =
      "android.hardware.vr.high_performance";

  /// from: static public final java.lang.String FEATURE_VULKAN_HARDWARE_COMPUTE
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature(String, int): If this feature is supported, the Vulkan native API
  /// will enumerate at least one {@code VkPhysicalDevice}, and the feature version will indicate
  /// what level of optional compute features that device supports beyond the Vulkan 1.0
  /// requirements.
  ///
  /// Compute level 0 indicates:
  /// <ul>
  /// <li>The {@code VK_KHR_variable_pointers} extension and
  ///     {@code VkPhysicalDeviceVariablePointerFeaturesKHR::variablePointers} feature are
  ///      supported.</li>
  /// <li>{@code VkPhysicalDeviceLimits::maxPerStageDescriptorStorageBuffers} is at least 16.</li>
  /// </ul>
  static const FEATURE_VULKAN_HARDWARE_COMPUTE =
      "android.hardware.vulkan.compute";

  /// from: static public final java.lang.String FEATURE_VULKAN_HARDWARE_LEVEL
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature(String, int): If this feature is supported, the Vulkan native API
  /// will enumerate at least one {@code VkPhysicalDevice}, and the feature version will indicate
  /// what level of optional hardware features limits it supports.
  ///
  /// Level 0 includes the base Vulkan requirements as well as:
  /// <ul><li>{@code VkPhysicalDeviceFeatures::textureCompressionETC2}</li></ul>
  ///
  /// Level 1 additionally includes:
  /// <ul>
  /// <li>{@code VkPhysicalDeviceFeatures::fullDrawIndexUint32}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::imageCubeArray}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::independentBlend}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::geometryShader}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::tessellationShader}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::sampleRateShading}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::textureCompressionASTC_LDR}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::fragmentStoresAndAtomics}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::shaderImageGatherExtended}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::shaderUniformBufferArrayDynamicIndexing}</li>
  /// <li>{@code VkPhysicalDeviceFeatures::shaderSampledImageArrayDynamicIndexing}</li>
  /// </ul>
  static const FEATURE_VULKAN_HARDWARE_LEVEL = "android.hardware.vulkan.level";

  /// from: static public final java.lang.String FEATURE_VULKAN_HARDWARE_VERSION
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature(String, int): The version of this feature indicates the highest
  /// {@code VkPhysicalDeviceProperties::apiVersion} supported by the physical devices that support
  /// the hardware level indicated by \#FEATURE_VULKAN_HARDWARE_LEVEL. The feature version
  /// uses the same encoding as Vulkan version numbers:
  /// <ul>
  /// <li>Major version number in bits 31-22</li>
  /// <li>Minor version number in bits 21-12</li>
  /// <li>Patch version number in bits 11-0</li>
  /// </ul>
  /// A version of 1.1.0 or higher also indicates:
  /// <ul>
  /// <li>{@code SYNC_FD} external semaphore and fence handles are supported.</li>
  /// <li>{@code VkPhysicalDeviceSamplerYcbcrConversionFeatures::samplerYcbcrConversion} is
  ///     supported.</li>
  /// </ul>
  static const FEATURE_VULKAN_HARDWARE_VERSION =
      "android.hardware.vulkan.version";

  /// from: static public final java.lang.String FEATURE_WATCH
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: This is a device dedicated to showing UI
  /// on a watch. A watch here is defined to be a device worn on the body, perhaps on
  /// the wrist. The user is very close when interacting with the device.
  static const FEATURE_WATCH = "android.hardware.type.watch";

  /// from: static public final java.lang.String FEATURE_WEBVIEW
  /// Feature for \#getSystemAvailableFeatures and \#hasSystemFeature:
  /// The device has a full implementation of the android.webkit.* APIs. Devices
  /// lacking this feature will not have a functioning WebView implementation.
  static const FEATURE_WEBVIEW = "android.software.webview";

  /// from: static public final java.lang.String FEATURE_WIFI
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports WiFi (802.11) networking.
  static const FEATURE_WIFI = "android.hardware.wifi";

  /// from: static public final java.lang.String FEATURE_WIFI_AWARE
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports Wi-Fi Aware.
  static const FEATURE_WIFI_AWARE = "android.hardware.wifi.aware";

  /// from: static public final java.lang.String FEATURE_WIFI_DIRECT
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports Wi-Fi Direct networking.
  static const FEATURE_WIFI_DIRECT = "android.hardware.wifi.direct";

  /// from: static public final java.lang.String FEATURE_WIFI_PASSPOINT
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports Wi-Fi Passpoint and all
  /// Passpoint related APIs in WifiManager are supported. Refer to
  /// WifiManager\#addOrUpdatePasspointConfiguration for more info.
  static const FEATURE_WIFI_PASSPOINT = "android.hardware.wifi.passpoint";

  /// from: static public final java.lang.String FEATURE_WIFI_RTT
  /// Feature for \#getSystemAvailableFeatures and
  /// \#hasSystemFeature: The device supports Wi-Fi RTT (IEEE 802.11mc).
  static const FEATURE_WIFI_RTT = "android.hardware.wifi.rtt";

  /// from: static public final int GET_ACTIVITIES
  /// PackageInfo flag: return information about
  /// activities in the package in PackageInfo\#activities.
  static const GET_ACTIVITIES = 1;

  /// from: static public final int GET_CONFIGURATIONS
  /// PackageInfo flag: return information about
  /// hardware preferences in
  /// PackageInfo\#configPreferences PackageInfo.configPreferences,
  /// and requested features in PackageInfo\#reqFeatures and
  /// PackageInfo\#featureGroups.
  static const GET_CONFIGURATIONS = 16384;

  /// from: static public final int GET_DISABLED_COMPONENTS
  /// @deprecated replaced with \#MATCH_DISABLED_COMPONENTS
  static const GET_DISABLED_COMPONENTS = 512;

  /// from: static public final int GET_DISABLED_UNTIL_USED_COMPONENTS
  /// @deprecated replaced with \#MATCH_DISABLED_UNTIL_USED_COMPONENTS.
  static const GET_DISABLED_UNTIL_USED_COMPONENTS = 32768;

  /// from: static public final int GET_GIDS
  /// PackageInfo flag: return the
  /// PackageInfo\#gids group ids that are associated with an
  /// application.
  /// This applies for any API returning a PackageInfo class, either
  /// directly or nested inside of another.
  static const GET_GIDS = 256;

  /// from: static public final int GET_INSTRUMENTATION
  /// PackageInfo flag: return information about
  /// instrumentation in the package in
  /// PackageInfo\#instrumentation.
  static const GET_INSTRUMENTATION = 16;

  /// from: static public final int GET_INTENT_FILTERS
  /// PackageInfo flag: return information about the
  /// intent filters supported by the activity.
  static const GET_INTENT_FILTERS = 32;

  /// from: static public final int GET_META_DATA
  /// ComponentInfo flag: return the ComponentInfo\#metaData
  /// data android.os.Bundles that are associated with a component.
  /// This applies for any API returning a ComponentInfo subclass.
  static const GET_META_DATA = 128;

  /// from: static public final int GET_PERMISSIONS
  /// PackageInfo flag: return information about
  /// permissions in the package in
  /// PackageInfo\#permissions.
  static const GET_PERMISSIONS = 4096;

  /// from: static public final int GET_PROVIDERS
  /// PackageInfo flag: return information about
  /// content providers in the package in
  /// PackageInfo\#providers.
  static const GET_PROVIDERS = 8;

  /// from: static public final int GET_RECEIVERS
  /// PackageInfo flag: return information about
  /// intent receivers in the package in
  /// PackageInfo\#receivers.
  static const GET_RECEIVERS = 2;

  /// from: static public final int GET_RESOLVED_FILTER
  /// ResolveInfo flag: return the IntentFilter that
  /// was matched for a particular ResolveInfo in
  /// ResolveInfo\#filter.
  static const GET_RESOLVED_FILTER = 64;

  /// from: static public final int GET_SERVICES
  /// PackageInfo flag: return information about
  /// services in the package in PackageInfo\#services.
  static const GET_SERVICES = 4;

  /// from: static public final int GET_SHARED_LIBRARY_FILES
  /// ApplicationInfo flag: return the
  /// ApplicationInfo\#sharedLibraryFiles paths to the shared libraries
  /// that are associated with an application.
  /// This applies for any API returning an ApplicationInfo class, either
  /// directly or nested inside of another.
  static const GET_SHARED_LIBRARY_FILES = 1024;

  /// from: static public final int GET_SIGNATURES
  /// PackageInfo flag: return information about the
  /// signatures included in the package.
  ///@deprecated use {@code GET_SIGNING_CERTIFICATES} instead
  static const GET_SIGNATURES = 64;

  /// from: static public final int GET_SIGNING_CERTIFICATES
  /// PackageInfo flag: return the signing certificates associated with
  /// this package.  Each entry is a signing certificate that the package
  /// has proven it is authorized to use, usually a past signing certificate from
  /// which it has rotated.
  static const GET_SIGNING_CERTIFICATES = 134217728;

  /// from: static public final int GET_UNINSTALLED_PACKAGES
  /// @deprecated replaced with \#MATCH_UNINSTALLED_PACKAGES
  static const GET_UNINSTALLED_PACKAGES = 8192;

  /// from: static public final int GET_URI_PERMISSION_PATTERNS
  /// ProviderInfo flag: return the
  /// ProviderInfo\#uriPermissionPatterns URI permission patterns
  /// that are associated with a content provider.
  /// This applies for any API returning a ProviderInfo class, either
  /// directly or nested inside of another.
  static const GET_URI_PERMISSION_PATTERNS = 2048;

  /// from: static public final int INSTALL_REASON_DEVICE_RESTORE
  /// Code indicating that this package was installed as part of restoring from another device.
  static const INSTALL_REASON_DEVICE_RESTORE = 2;

  /// from: static public final int INSTALL_REASON_DEVICE_SETUP
  /// Code indicating that this package was installed as part of device setup.
  static const INSTALL_REASON_DEVICE_SETUP = 3;

  /// from: static public final int INSTALL_REASON_POLICY
  /// Code indicating that this package was installed due to enterprise policy.
  static const INSTALL_REASON_POLICY = 1;

  /// from: static public final int INSTALL_REASON_UNKNOWN
  /// Code indicating that the reason for installing this package is unknown.
  static const INSTALL_REASON_UNKNOWN = 0;

  /// from: static public final int INSTALL_REASON_USER
  /// Code indicating that the package installation was initiated by the user.
  static const INSTALL_REASON_USER = 4;

  /// from: static public final int MATCH_ALL
  /// Querying flag: if set and if the platform is doing any filtering of the
  /// results, then the filtering will not happen. This is a synonym for saying
  /// that all results should be returned.
  ///
  /// _This flag should be used with extreme care._
  static const MATCH_ALL = 131072;

  /// from: static public final int MATCH_DEFAULT_ONLY
  /// Resolution and querying flag: if set, only filters that support the
  /// android.content.Intent\#CATEGORY_DEFAULT will be considered for
  /// matching.  This is a synonym for including the CATEGORY_DEFAULT in your
  /// supplied Intent.
  static const MATCH_DEFAULT_ONLY = 65536;

  /// from: static public final int MATCH_DIRECT_BOOT_AWARE
  /// Querying flag: match components which are direct boot _aware_ in
  /// the returned info, regardless of the current user state.
  ///
  /// When neither \#MATCH_DIRECT_BOOT_AWARE nor
  /// \#MATCH_DIRECT_BOOT_UNAWARE are specified, the default behavior is
  /// to match only runnable components based on the user state. For example,
  /// when a user is started but credentials have not been presented yet, the
  /// user is running "locked" and only \#MATCH_DIRECT_BOOT_AWARE
  /// components are returned. Once the user credentials have been presented,
  /// the user is running "unlocked" and both \#MATCH_DIRECT_BOOT_AWARE
  /// and \#MATCH_DIRECT_BOOT_UNAWARE components are returned.
  ///@see UserManager\#isUserUnlocked()
  static const MATCH_DIRECT_BOOT_AWARE = 524288;

  /// from: static public final int MATCH_DIRECT_BOOT_UNAWARE
  /// Querying flag: match components which are direct boot _unaware_ in
  /// the returned info, regardless of the current user state.
  ///
  /// When neither \#MATCH_DIRECT_BOOT_AWARE nor
  /// \#MATCH_DIRECT_BOOT_UNAWARE are specified, the default behavior is
  /// to match only runnable components based on the user state. For example,
  /// when a user is started but credentials have not been presented yet, the
  /// user is running "locked" and only \#MATCH_DIRECT_BOOT_AWARE
  /// components are returned. Once the user credentials have been presented,
  /// the user is running "unlocked" and both \#MATCH_DIRECT_BOOT_AWARE
  /// and \#MATCH_DIRECT_BOOT_UNAWARE components are returned.
  ///@see UserManager\#isUserUnlocked()
  static const MATCH_DIRECT_BOOT_UNAWARE = 262144;

  /// from: static public final int MATCH_DISABLED_COMPONENTS
  /// PackageInfo flag: include disabled components in the returned info.
  static const MATCH_DISABLED_COMPONENTS = 512;

  /// from: static public final int MATCH_DISABLED_UNTIL_USED_COMPONENTS
  /// PackageInfo flag: include disabled components which are in
  /// that state only because of \#COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED
  /// in the returned info.  Note that if you set this flag, applications
  /// that are in this disabled state will be reported as enabled.
  static const MATCH_DISABLED_UNTIL_USED_COMPONENTS = 32768;

  /// from: static public final int MATCH_SYSTEM_ONLY
  /// Querying flag: include only components from applications that are marked
  /// with ApplicationInfo\#FLAG_SYSTEM.
  static const MATCH_SYSTEM_ONLY = 1048576;

  /// from: static public final int MATCH_UNINSTALLED_PACKAGES
  /// Flag parameter to retrieve some information about all applications (even
  /// uninstalled ones) which have data directories. This state could have
  /// resulted if applications have been deleted with flag
  /// {@code DONT_DELETE_DATA} with a possibility of being replaced or
  /// reinstalled in future.
  ///
  /// Note: this flag may cause less information about currently installed
  /// applications to be returned.
  static const MATCH_UNINSTALLED_PACKAGES = 8192;

  /// from: static public final long MAXIMUM_VERIFICATION_TIMEOUT
  /// Can be used as the {@code millisecondsToDelay} argument for
  /// PackageManager\#extendVerificationTimeout. This is the
  /// maximum time {@code PackageManager} waits for the verification
  /// agent to return (in milliseconds).
  static const MAXIMUM_VERIFICATION_TIMEOUT = 3600000;

  /// from: static public final int PERMISSION_DENIED
  /// Permission check result: this is returned by \#checkPermission
  /// if the permission has not been granted to the given package.
  static const PERMISSION_DENIED = -1;

  /// from: static public final int PERMISSION_GRANTED
  /// Permission check result: this is returned by \#checkPermission
  /// if the permission has been granted to the given package.
  static const PERMISSION_GRANTED = 0;

  /// from: static public final int SIGNATURE_FIRST_NOT_SIGNED
  /// Signature check result: this is returned by \#checkSignatures
  /// if the first package is not signed but the second is.
  static const SIGNATURE_FIRST_NOT_SIGNED = -1;

  /// from: static public final int SIGNATURE_MATCH
  /// Signature check result: this is returned by \#checkSignatures
  /// if all signatures on the two packages match.
  static const SIGNATURE_MATCH = 0;

  /// from: static public final int SIGNATURE_NEITHER_SIGNED
  /// Signature check result: this is returned by \#checkSignatures
  /// if neither of the two packages is signed.
  static const SIGNATURE_NEITHER_SIGNED = 1;

  /// from: static public final int SIGNATURE_NO_MATCH
  /// Signature check result: this is returned by \#checkSignatures
  /// if not all signatures on both packages match.
  static const SIGNATURE_NO_MATCH = -3;

  /// from: static public final int SIGNATURE_SECOND_NOT_SIGNED
  /// Signature check result: this is returned by \#checkSignatures
  /// if the second package is not signed but the first is.
  static const SIGNATURE_SECOND_NOT_SIGNED = -2;

  /// from: static public final int SIGNATURE_UNKNOWN_PACKAGE
  /// Signature check result: this is returned by \#checkSignatures
  /// if either of the packages are not valid.
  static const SIGNATURE_UNKNOWN_PACKAGE = -4;

  /// from: static public final int VERIFICATION_ALLOW
  /// Used as the {@code verificationCode} argument for
  /// PackageManager\#verifyPendingInstall to indicate that the calling
  /// package verifier allows the installation to proceed.
  static const VERIFICATION_ALLOW = 1;

  /// from: static public final int VERIFICATION_REJECT
  /// Used as the {@code verificationCode} argument for
  /// PackageManager\#verifyPendingInstall to indicate the calling
  /// package verifier does not vote to allow the installation to proceed.
  static const VERIFICATION_REJECT = -1;

  /// from: static public final int VERSION_CODE_HIGHEST
  /// Constant for specifying the highest installed package version code.
  static const VERSION_CODE_HIGHEST = -1;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_PackageManager_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  PackageManager() : super.fromRef(_ctor());

  static final _getPackageInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getPackageInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.pm.PackageInfo getPackageInfo(java.lang.String packageName, int flags)
  /// Retrieve overall information about an application package that is
  /// installed on the system.
  ///@param packageName The full name (i.e. com.google.apps.contacts) of the
  ///            desired package.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_ACTIVITIES, android.content.pm.PackageManager\#GET_CONFIGURATIONS, android.content.pm.PackageManager\#GET_GIDS, android.content.pm.PackageManager\#GET_INSTRUMENTATION, android.content.pm.PackageManager\#GET_INTENT_FILTERS, android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_PERMISSIONS, android.content.pm.PackageManager\#GET_PROVIDERS, android.content.pm.PackageManager\#GET_RECEIVERS, android.content.pm.PackageManager\#GET_SERVICES, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#GET_SIGNATURES, android.content.pm.PackageManager\#GET_SIGNING_CERTIFICATES, android.content.pm.PackageManager\#GET_URI_PERMISSION_PATTERNS, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_FACTORY_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return A PackageInfo object containing information about the package. If
  ///         flag {@code MATCH_UNINSTALLED_PACKAGES} is set and if the package
  ///         is not found in the list of installed applications, the package
  ///         information is retrieved from the list of uninstalled
  ///         applications (which includes installed applications as well as
  ///         applications with data directory i.e. applications which had been
  ///         deleted with {@code DONT_DELETE_DATA} flag set).
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  PackageInfo getPackageInfo(jni.JlString packageName, int flags) =>
      PackageInfo.fromRef(
          _getPackageInfo(reference, packageName.reference, flags));

  static final _getPackageInfo_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getPackageInfo_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.pm.PackageInfo getPackageInfo(android.content.pm.VersionedPackage versionedPackage, int flags)
  /// Retrieve overall information about an application package that is
  /// installed on the system. This method can be used for retrieving
  /// information about packages for which multiple versions can be installed
  /// at the time. Currently only packages hosting static shared libraries can
  /// have multiple installed versions. The method can also be used to get info
  /// for a package that has a single version installed by passing
  /// \#VERSION_CODE_HIGHEST in the VersionedPackage
  /// constructor.
  ///@param versionedPackage The versioned package for which to query.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_ACTIVITIES, android.content.pm.PackageManager\#GET_CONFIGURATIONS, android.content.pm.PackageManager\#GET_GIDS, android.content.pm.PackageManager\#GET_INSTRUMENTATION, android.content.pm.PackageManager\#GET_INTENT_FILTERS, android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_PERMISSIONS, android.content.pm.PackageManager\#GET_PROVIDERS, android.content.pm.PackageManager\#GET_RECEIVERS, android.content.pm.PackageManager\#GET_SERVICES, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#GET_SIGNATURES, android.content.pm.PackageManager\#GET_SIGNING_CERTIFICATES, android.content.pm.PackageManager\#GET_URI_PERMISSION_PATTERNS, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_FACTORY_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return A PackageInfo object containing information about the package. If
  ///         flag {@code MATCH_UNINSTALLED_PACKAGES} is set and if the package
  ///         is not found in the list of installed applications, the package
  ///         information is retrieved from the list of uninstalled
  ///         applications (which includes installed applications as well as
  ///         applications with data directory i.e. applications which had been
  ///         deleted with {@code DONT_DELETE_DATA} flag set).
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  PackageInfo getPackageInfo_1(VersionedPackage versionedPackage, int flags) =>
      PackageInfo.fromRef(
          _getPackageInfo_1(reference, versionedPackage.reference, flags));

  static final _currentToCanonicalPackageNames = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_currentToCanonicalPackageNames")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String[] currentToCanonicalPackageNames(java.lang.String[] names)
  /// Map from the current package names in use on the device to whatever
  /// the current canonical name of that package is.
  ///@param names Array of current names to be mapped.
  ///@return Returns an array of the same size as the original, containing
  /// the canonical name for each package.
  jni.JlObject currentToCanonicalPackageNames(jni.JlObject names) =>
      jni.JlObject.fromRef(
          _currentToCanonicalPackageNames(reference, names.reference));

  static final _canonicalToCurrentPackageNames = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_canonicalToCurrentPackageNames")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String[] canonicalToCurrentPackageNames(java.lang.String[] names)
  /// Map from a packages canonical name to the current name in use on the device.
  ///@param names Array of new names to be mapped.
  ///@return Returns an array of the same size as the original, containing
  /// the current name for each package.
  jni.JlObject canonicalToCurrentPackageNames(jni.JlObject names) =>
      jni.JlObject.fromRef(
          _canonicalToCurrentPackageNames(reference, names.reference));

  static final _getLaunchIntentForPackage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getLaunchIntentForPackage")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Intent getLaunchIntentForPackage(java.lang.String packageName)
  /// Returns a "good" intent to launch a front-door activity in a package.
  /// This is used, for example, to implement an "open" button when browsing
  /// through packages.  The current implementation looks first for a main
  /// activity in the category Intent\#CATEGORY_INFO, and next for a
  /// main activity in the category Intent\#CATEGORY_LAUNCHER. Returns
  /// <code>null</code> if neither are found.
  ///@param packageName The name of the package to inspect.
  ///
  /// This value must never be {@code null}.
  ///@return A fully-qualified Intent that can be used to launch the
  /// main activity in the package. Returns <code>null</code> if the package
  /// does not contain such an activity, or if _packageName_ is not
  /// recognized.
  content.Intent getLaunchIntentForPackage(jni.JlString packageName) =>
      content.Intent.fromRef(
          _getLaunchIntentForPackage(reference, packageName.reference));

  static final _getLeanbackLaunchIntentForPackage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getLeanbackLaunchIntentForPackage")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Intent getLeanbackLaunchIntentForPackage(java.lang.String packageName)
  /// Return a "good" intent to launch a front-door Leanback activity in a
  /// package, for use for example to implement an "open" button when browsing
  /// through packages. The current implementation will look for a main
  /// activity in the category Intent\#CATEGORY_LEANBACK_LAUNCHER, or
  /// return null if no main leanback activities are found.
  ///@param packageName The name of the package to inspect.
  /// This value must never be {@code null}.
  ///@return Returns either a fully-qualified Intent that can be used to launch
  ///         the main Leanback activity in the package, or null if the package
  ///         does not contain such an activity.
  content.Intent getLeanbackLaunchIntentForPackage(jni.JlString packageName) =>
      content.Intent.fromRef(
          _getLeanbackLaunchIntentForPackage(reference, packageName.reference));

  static final _getPackageGids = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getPackageGids")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int[] getPackageGids(java.lang.String packageName)
  /// Return an array of all of the POSIX secondary group IDs that have been
  /// assigned to the given package.
  ///
  /// Note that the same package may have different GIDs under different
  /// UserHandle on the same device.
  ///@param packageName The full name (i.e. com.google.apps.contacts) of the
  ///            desired package.
  /// This value must never be {@code null}.
  ///@return Returns an int array of the assigned GIDs, or null if there are
  ///         none.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  jni.JlObject getPackageGids(jni.JlString packageName) =>
      jni.JlObject.fromRef(_getPackageGids(reference, packageName.reference));

  static final _getPackageGids_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getPackageGids_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract int[] getPackageGids(java.lang.String packageName, int flags)
  /// Return an array of all of the POSIX secondary group IDs that have been
  /// assigned to the given package.
  ///
  /// Note that the same package may have different GIDs under different
  /// UserHandle on the same device.
  ///@param packageName The full name (i.e. com.google.apps.contacts) of the
  ///            desired package.
  ///@param flags Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_ACTIVITIES, android.content.pm.PackageManager\#GET_CONFIGURATIONS, android.content.pm.PackageManager\#GET_GIDS, android.content.pm.PackageManager\#GET_INSTRUMENTATION, android.content.pm.PackageManager\#GET_INTENT_FILTERS, android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_PERMISSIONS, android.content.pm.PackageManager\#GET_PROVIDERS, android.content.pm.PackageManager\#GET_RECEIVERS, android.content.pm.PackageManager\#GET_SERVICES, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#GET_SIGNATURES, android.content.pm.PackageManager\#GET_SIGNING_CERTIFICATES, android.content.pm.PackageManager\#GET_URI_PERMISSION_PATTERNS, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_FACTORY_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return Returns an int array of the assigned gids, or null if there are
  ///         none.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  jni.JlObject getPackageGids_1(jni.JlString packageName, int flags) =>
      jni.JlObject.fromRef(
          _getPackageGids_1(reference, packageName.reference, flags));

  static final _getPackageUid = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getPackageUid")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract int getPackageUid(java.lang.String packageName, int flags)
  /// Return the UID associated with the given package name.
  ///
  /// Note that the same package will have different UIDs under different
  /// UserHandle on the same device.
  ///@param packageName The full name (i.e. com.google.apps.contacts) of the
  ///            desired package.
  ///@param flags Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_ACTIVITIES, android.content.pm.PackageManager\#GET_CONFIGURATIONS, android.content.pm.PackageManager\#GET_GIDS, android.content.pm.PackageManager\#GET_INSTRUMENTATION, android.content.pm.PackageManager\#GET_INTENT_FILTERS, android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_PERMISSIONS, android.content.pm.PackageManager\#GET_PROVIDERS, android.content.pm.PackageManager\#GET_RECEIVERS, android.content.pm.PackageManager\#GET_SERVICES, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#GET_SIGNATURES, android.content.pm.PackageManager\#GET_SIGNING_CERTIFICATES, android.content.pm.PackageManager\#GET_URI_PERMISSION_PATTERNS, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_FACTORY_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return Returns an integer UID who owns the given package name.
  ///@throws NameNotFoundException if a package with the given name can not be
  ///             found on the system.
  int getPackageUid(jni.JlString packageName, int flags) =>
      _getPackageUid(reference, packageName.reference, flags);

  static final _getPermissionInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getPermissionInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.pm.PermissionInfo getPermissionInfo(java.lang.String name, int flags)
  /// Retrieve all of the information we know about a particular permission.
  ///@param name The fully qualified name (i.e. com.google.permission.LOGIN)
  ///            of the permission you are interested in.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or android.content.pm.PackageManager\#GET_META_DATA
  ///@return Returns a PermissionInfo containing information about the
  ///         permission.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  PermissionInfo getPermissionInfo(jni.JlString name, int flags) =>
      PermissionInfo.fromRef(
          _getPermissionInfo(reference, name.reference, flags));

  static final _queryPermissionsByGroup = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_queryPermissionsByGroup")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.util.List<android.content.pm.PermissionInfo> queryPermissionsByGroup(java.lang.String group, int flags)
  /// Query for all of the permissions associated with a particular group.
  ///@param group The fully qualified name (i.e. com.google.permission.LOGIN)
  ///            of the permission group you are interested in. Use null to
  ///            find all of the permissions not associated with a group.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or android.content.pm.PackageManager\#GET_META_DATA
  ///@return Returns a list of PermissionInfo containing information
  ///         about all of the permissions in the given group.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  jni.JlObject queryPermissionsByGroup(jni.JlString group, int flags) =>
      jni.JlObject.fromRef(
          _queryPermissionsByGroup(reference, group.reference, flags));

  static final _getPermissionGroupInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getPermissionGroupInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.pm.PermissionGroupInfo getPermissionGroupInfo(java.lang.String name, int flags)
  /// Retrieve all of the information we know about a particular group of
  /// permissions.
  ///@param name The fully qualified name (i.e.
  ///            com.google.permission_group.APPS) of the permission you are
  ///            interested in.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or android.content.pm.PackageManager\#GET_META_DATA
  ///@return Returns a PermissionGroupInfo containing information
  ///         about the permission.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  PermissionGroupInfo getPermissionGroupInfo(jni.JlString name, int flags) =>
      PermissionGroupInfo.fromRef(
          _getPermissionGroupInfo(reference, name.reference, flags));

  static final _getAllPermissionGroups = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getAllPermissionGroups")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.util.List<android.content.pm.PermissionGroupInfo> getAllPermissionGroups(int flags)
  /// Retrieve all of the known permission groups in the system.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or android.content.pm.PackageManager\#GET_META_DATA
  ///@return Returns a list of PermissionGroupInfo containing
  ///         information about all of the known permission groups.
  jni.JlObject getAllPermissionGroups(int flags) =>
      jni.JlObject.fromRef(_getAllPermissionGroups(reference, flags));

  static final _getApplicationInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getApplicationInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.pm.ApplicationInfo getApplicationInfo(java.lang.String packageName, int flags)
  /// Retrieve all of the information we know about a particular
  /// package/application.
  ///@param packageName The full name (i.e. com.google.apps.contacts) of an
  ///            application.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return An ApplicationInfo containing information about the
  ///         package. If flag {@code MATCH_UNINSTALLED_PACKAGES} is set and if
  ///         the package is not found in the list of installed applications,
  ///         the application information is retrieved from the list of
  ///         uninstalled applications (which includes installed applications
  ///         as well as applications with data directory i.e. applications
  ///         which had been deleted with {@code DONT_DELETE_DATA} flag set).
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  ApplicationInfo getApplicationInfo(jni.JlString packageName, int flags) =>
      ApplicationInfo.fromRef(
          _getApplicationInfo(reference, packageName.reference, flags));

  static final _getActivityInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getActivityInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.pm.ActivityInfo getActivityInfo(android.content.ComponentName component, int flags)
  /// Retrieve all of the information we know about a particular activity
  /// class.
  ///@param component The full component name (i.e.
  ///            com.google.apps.contacts/com.google.apps.contacts.
  ///            ContactsList) of an Activity class.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return An ActivityInfo containing information about the
  ///         activity.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  ActivityInfo getActivityInfo(content.ComponentName component, int flags) =>
      ActivityInfo.fromRef(
          _getActivityInfo(reference, component.reference, flags));

  static final _getReceiverInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getReceiverInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.pm.ActivityInfo getReceiverInfo(android.content.ComponentName component, int flags)
  /// Retrieve all of the information we know about a particular receiver
  /// class.
  ///@param component The full component name (i.e.
  ///            com.google.apps.calendar/com.google.apps.calendar.
  ///            CalendarAlarm) of a Receiver class.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return An ActivityInfo containing information about the
  ///         receiver.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  ActivityInfo getReceiverInfo(content.ComponentName component, int flags) =>
      ActivityInfo.fromRef(
          _getReceiverInfo(reference, component.reference, flags));

  static final _getServiceInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getServiceInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.pm.ServiceInfo getServiceInfo(android.content.ComponentName component, int flags)
  /// Retrieve all of the information we know about a particular service class.
  ///@param component The full component name (i.e.
  ///            com.google.apps.media/com.google.apps.media.
  ///            BackgroundPlayback) of a Service class.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return A ServiceInfo object containing information about the
  ///         service.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  ServiceInfo getServiceInfo(content.ComponentName component, int flags) =>
      ServiceInfo.fromRef(
          _getServiceInfo(reference, component.reference, flags));

  static final _getProviderInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getProviderInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.pm.ProviderInfo getProviderInfo(android.content.ComponentName component, int flags)
  /// Retrieve all of the information we know about a particular content
  /// provider class.
  ///@param component The full component name (i.e.
  ///            com.google.providers.media/com.google.providers.media.
  ///            MediaProvider) of a ContentProvider class.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return A ProviderInfo object containing information about the
  ///         provider.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  ProviderInfo getProviderInfo(content.ComponentName component, int flags) =>
      ProviderInfo.fromRef(
          _getProviderInfo(reference, component.reference, flags));

  static final _getInstalledPackages = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getInstalledPackages")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.util.List<android.content.pm.PackageInfo> getInstalledPackages(int flags)
  /// Return a List of all packages that are installed for the current user.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_ACTIVITIES, android.content.pm.PackageManager\#GET_CONFIGURATIONS, android.content.pm.PackageManager\#GET_GIDS, android.content.pm.PackageManager\#GET_INSTRUMENTATION, android.content.pm.PackageManager\#GET_INTENT_FILTERS, android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_PERMISSIONS, android.content.pm.PackageManager\#GET_PROVIDERS, android.content.pm.PackageManager\#GET_RECEIVERS, android.content.pm.PackageManager\#GET_SERVICES, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#GET_SIGNATURES, android.content.pm.PackageManager\#GET_SIGNING_CERTIFICATES, android.content.pm.PackageManager\#GET_URI_PERMISSION_PATTERNS, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_FACTORY_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return A List of PackageInfo objects, one for each installed package,
  ///         containing information about the package. In the unlikely case
  ///         there are no installed packages, an empty list is returned. If
  ///         flag {@code MATCH_UNINSTALLED_PACKAGES} is set, the package
  ///         information is retrieved from the list of uninstalled
  ///         applications (which includes installed applications as well as
  ///         applications with data directory i.e. applications which had been
  ///         deleted with {@code DONT_DELETE_DATA} flag set).
  jni.JlObject getInstalledPackages(int flags) =>
      jni.JlObject.fromRef(_getInstalledPackages(reference, flags));

  static final _getPackagesHoldingPermissions = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getPackagesHoldingPermissions")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.util.List<android.content.pm.PackageInfo> getPackagesHoldingPermissions(java.lang.String[] permissions, int flags)
  /// Return a List of all installed packages that are currently holding any of
  /// the given permissions.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_ACTIVITIES, android.content.pm.PackageManager\#GET_CONFIGURATIONS, android.content.pm.PackageManager\#GET_GIDS, android.content.pm.PackageManager\#GET_INSTRUMENTATION, android.content.pm.PackageManager\#GET_INTENT_FILTERS, android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_PERMISSIONS, android.content.pm.PackageManager\#GET_PROVIDERS, android.content.pm.PackageManager\#GET_RECEIVERS, android.content.pm.PackageManager\#GET_SERVICES, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#GET_SIGNATURES, android.content.pm.PackageManager\#GET_SIGNING_CERTIFICATES, android.content.pm.PackageManager\#GET_URI_PERMISSION_PATTERNS, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_FACTORY_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return A List of PackageInfo objects, one for each installed package
  ///         that holds any of the permissions that were provided, containing
  ///         information about the package. If no installed packages hold any
  ///         of the permissions, an empty list is returned. If flag
  ///         {@code MATCH_UNINSTALLED_PACKAGES} is set, the package
  ///         information is retrieved from the list of uninstalled
  ///         applications (which includes installed applications as well as
  ///         applications with data directory i.e. applications which had been
  ///         deleted with {@code DONT_DELETE_DATA} flag set).
  jni.JlObject getPackagesHoldingPermissions(
          jni.JlObject permissions, int flags) =>
      jni.JlObject.fromRef(_getPackagesHoldingPermissions(
          reference, permissions.reference, flags));

  static final _checkPermission = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_checkPermission")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int checkPermission(java.lang.String permName, java.lang.String pkgName)
  /// Check whether a particular package has been granted a particular
  /// permission.
  ///@param permName The name of the permission you are checking for.
  ///@param pkgName The name of the package you are checking against.
  ///@return If the package has the permission, PERMISSION_GRANTED is
  /// returned.  If it does not have the permission, PERMISSION_DENIED
  /// is returned.
  ///
  /// Value is android.content.pm.PackageManager\#PERMISSION_GRANTED, or android.content.pm.PackageManager\#PERMISSION_DENIED
  ///@see \#PERMISSION_GRANTED
  ///@see \#PERMISSION_DENIED
  int checkPermission(jni.JlString permName, jni.JlString pkgName) =>
      _checkPermission(reference, permName.reference, pkgName.reference);

  static final _isPermissionRevokedByPolicy = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_isPermissionRevokedByPolicy")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isPermissionRevokedByPolicy(java.lang.String permName, java.lang.String pkgName)
  /// Checks whether a particular permissions has been revoked for a
  /// package by policy. Typically the device owner or the profile owner
  /// may apply such a policy. The user cannot grant policy revoked
  /// permissions, hence the only way for an app to get such a permission
  /// is by a policy change.
  ///@param permName The name of the permission you are checking for.
  /// This value must never be {@code null}.
  ///@param pkgName The name of the package you are checking against.
  ///
  /// This value must never be {@code null}.
  ///@return Whether the permission is restricted by policy.
  bool isPermissionRevokedByPolicy(
          jni.JlString permName, jni.JlString pkgName) =>
      _isPermissionRevokedByPolicy(
          reference, permName.reference, pkgName.reference) !=
      0;

  static final _addPermission = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_addPermission")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean addPermission(android.content.pm.PermissionInfo info)
  /// Add a new dynamic permission to the system.  For this to work, your
  /// package must have defined a permission tree through the
  /// android.R.styleable\#AndroidManifestPermissionTree &lt;permission-tree&gt; tag in its manifest.  A package can only add
  /// permissions to trees that were defined by either its own package or
  /// another with the same user id; a permission is in a tree if it
  /// matches the name of the permission tree + ".": for example,
  /// "com.foo.bar" is a member of the permission tree "com.foo".
  ///
  /// It is good to make your permission tree name descriptive, because you
  /// are taking possession of that entire set of permission names.  Thus, it
  /// must be under a domain you control, with a suffix that will not match
  /// any normal permissions that may be declared in any applications that
  /// are part of that domain.
  ///
  /// New permissions must be added before
  /// any .apks are installed that use those permissions.  Permissions you
  /// add through this method are remembered across reboots of the device.
  /// If the given permission already exists, the info you supply here
  /// will be used to update it.
  ///@param info Description of the permission to be added.
  ///@return Returns true if a new permission was created, false if an
  /// existing one was updated.
  ///@throws SecurityException if you are not allowed to add the
  /// given permission name.
  ///@see \#removePermission(String)
  bool addPermission(PermissionInfo info) =>
      _addPermission(reference, info.reference) != 0;

  static final _addPermissionAsync = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_addPermissionAsync")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean addPermissionAsync(android.content.pm.PermissionInfo info)
  /// Like \#addPermission(PermissionInfo) but asynchronously
  /// persists the package manager state after returning from the call,
  /// allowing it to return quicker and batch a series of adds at the
  /// expense of no guarantee the added permission will be retained if
  /// the device is rebooted before it is written.
  bool addPermissionAsync(PermissionInfo info) =>
      _addPermissionAsync(reference, info.reference) != 0;

  static final _removePermission = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_removePermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void removePermission(java.lang.String name)
  /// Removes a permission that was previously added with
  /// \#addPermission(PermissionInfo).  The same ownership rules apply
  /// -- you are only allowed to remove permissions that you are allowed
  /// to add.
  ///@param name The name of the permission to remove.
  ///@throws SecurityException if you are not allowed to remove the
  /// given permission name.
  ///@see \#addPermission(PermissionInfo)
  void removePermission(jni.JlString name) =>
      _removePermission(reference, name.reference);

  static final _checkSignatures = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_checkSignatures")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int checkSignatures(java.lang.String pkg1, java.lang.String pkg2)
  /// Compare the signatures of two packages to determine if the same
  /// signature appears in both of them.  If they do contain the same
  /// signature, then they are allowed special privileges when working
  /// with each other: they can share the same user-id, run instrumentation
  /// against each other, etc.
  ///@param pkg1 First package name whose signature will be compared.
  ///@param pkg2 Second package name whose signature will be compared.
  ///@return Returns an integer indicating whether all signatures on the
  /// two packages match. The value is >= 0 (\#SIGNATURE_MATCH) if
  /// all signatures match or < 0 if there is not a match (\#SIGNATURE_NO_MATCH or \#SIGNATURE_UNKNOWN_PACKAGE).
  ///
  /// Value is android.content.pm.PackageManager\#SIGNATURE_MATCH, android.content.pm.PackageManager\#SIGNATURE_NEITHER_SIGNED, android.content.pm.PackageManager\#SIGNATURE_FIRST_NOT_SIGNED, android.content.pm.PackageManager\#SIGNATURE_SECOND_NOT_SIGNED, android.content.pm.PackageManager\#SIGNATURE_NO_MATCH, or android.content.pm.PackageManager\#SIGNATURE_UNKNOWN_PACKAGE
  ///@see \#checkSignatures(int, int)
  int checkSignatures(jni.JlString pkg1, jni.JlString pkg2) =>
      _checkSignatures(reference, pkg1.reference, pkg2.reference);

  static final _checkSignatures_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_content_pm_PackageManager_checkSignatures_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract int checkSignatures(int uid1, int uid2)
  /// Like \#checkSignatures(String, String), but takes UIDs of
  /// the two packages to be checked.  This can be useful, for example,
  /// when doing the check in an IPC, where the UID is the only identity
  /// available.  It is functionally identical to determining the package
  /// associated with the UIDs and checking their signatures.
  ///@param uid1 First UID whose signature will be compared.
  ///@param uid2 Second UID whose signature will be compared.
  ///@return Returns an integer indicating whether all signatures on the
  /// two packages match. The value is >= 0 (\#SIGNATURE_MATCH) if
  /// all signatures match or < 0 if there is not a match (\#SIGNATURE_NO_MATCH or \#SIGNATURE_UNKNOWN_PACKAGE).
  ///
  /// Value is android.content.pm.PackageManager\#SIGNATURE_MATCH, android.content.pm.PackageManager\#SIGNATURE_NEITHER_SIGNED, android.content.pm.PackageManager\#SIGNATURE_FIRST_NOT_SIGNED, android.content.pm.PackageManager\#SIGNATURE_SECOND_NOT_SIGNED, android.content.pm.PackageManager\#SIGNATURE_NO_MATCH, or android.content.pm.PackageManager\#SIGNATURE_UNKNOWN_PACKAGE
  ///@see \#checkSignatures(String, String)
  int checkSignatures_1(int uid1, int uid2) =>
      _checkSignatures_1(reference, uid1, uid2);

  static final _getPackagesForUid = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getPackagesForUid")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.lang.String[] getPackagesForUid(int uid)
  /// Retrieve the names of all packages that are associated with a particular
  /// user id.  In most cases, this will be a single package name, the package
  /// that has been assigned that user id.  Where there are multiple packages
  /// sharing the same user id through the "sharedUserId" mechanism, all
  /// packages with that id will be returned.
  ///@param uid The user id for which you would like to retrieve the
  /// associated packages.
  ///@return Returns an array of one or more packages assigned to the user
  /// id, or null if there are no known packages with the given id.
  jni.JlObject getPackagesForUid(int uid) =>
      jni.JlObject.fromRef(_getPackagesForUid(reference, uid));

  static final _getNameForUid = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getNameForUid")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.lang.String getNameForUid(int uid)
  /// Retrieve the official name associated with a uid. This name is
  /// guaranteed to never change, though it is possible for the underlying
  /// uid to be changed.  That is, if you are storing information about
  /// uids in persistent storage, you should use the string returned
  /// by this function instead of the raw uid.
  ///@param uid The uid for which you would like to retrieve a name.
  ///@return Returns a unique name for the given uid, or null if the
  /// uid is not currently assigned.
  jni.JlString getNameForUid(int uid) =>
      jni.JlString.fromRef(_getNameForUid(reference, uid));

  static final _getInstalledApplications = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getInstalledApplications")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.util.List<android.content.pm.ApplicationInfo> getInstalledApplications(int flags)
  /// Return a List of all application packages that are installed for the
  /// current user. If flag GET_UNINSTALLED_PACKAGES has been set, a list of all
  /// applications including those deleted with {@code DONT_DELETE_DATA}
  /// (partially installed apps with data directory) will be returned.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return A List of ApplicationInfo objects, one for each installed
  ///         application. In the unlikely case there are no installed
  ///         packages, an empty list is returned. If flag
  ///         {@code MATCH_UNINSTALLED_PACKAGES} is set, the application
  ///         information is retrieved from the list of uninstalled
  ///         applications (which includes installed applications as well as
  ///         applications with data directory i.e. applications which had been
  ///         deleted with {@code DONT_DELETE_DATA} flag set).
  jni.JlObject getInstalledApplications(int flags) =>
      jni.JlObject.fromRef(_getInstalledApplications(reference, flags));

  static final _isInstantApp =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PackageManager_isInstantApp")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isInstantApp()
  /// Gets whether this application is an instant app.
  ///@return Whether caller is an instant app.
  ///@see \#isInstantApp(String)
  ///@see \#updateInstantAppCookie(byte[])
  ///@see \#getInstantAppCookie()
  ///@see \#getInstantAppCookieMaxBytes()
  bool isInstantApp() => _isInstantApp(reference) != 0;

  static final _isInstantApp_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_isInstantApp_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isInstantApp(java.lang.String packageName)
  /// Gets whether the given package is an instant app.
  ///@param packageName The package to check
  ///@return Whether the given package is an instant app.
  ///@see \#isInstantApp()
  ///@see \#updateInstantAppCookie(byte[])
  ///@see \#getInstantAppCookie()
  ///@see \#getInstantAppCookieMaxBytes()
  ///@see \#clearInstantAppCookie()
  bool isInstantApp_1(jni.JlString packageName) =>
      _isInstantApp_1(reference, packageName.reference) != 0;

  static final _getInstantAppCookieMaxBytes =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PackageManager_getInstantAppCookieMaxBytes")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getInstantAppCookieMaxBytes()
  /// Gets the maximum size in bytes of the cookie data an instant app
  /// can store on the device.
  ///@return The max cookie size in bytes.
  ///@see \#isInstantApp()
  ///@see \#isInstantApp(String)
  ///@see \#updateInstantAppCookie(byte[])
  ///@see \#getInstantAppCookie()
  ///@see \#clearInstantAppCookie()
  int getInstantAppCookieMaxBytes() => _getInstantAppCookieMaxBytes(reference);

  static final _getInstantAppCookie = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getInstantAppCookie")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract byte[] getInstantAppCookie()
  /// Gets the instant application cookie for this app. Non
  /// instant apps and apps that were instant but were upgraded
  /// to normal apps can still access this API. For instant apps
  /// this cookie is cached for some time after uninstall while for
  /// normal apps the cookie is deleted after the app is uninstalled.
  /// The cookie is always present while the app is installed.
  ///@return The cookie.
  ///
  /// This value will never be {@code null}.
  ///@see \#isInstantApp()
  ///@see \#isInstantApp(String)
  ///@see \#updateInstantAppCookie(byte[])
  ///@see \#getInstantAppCookieMaxBytes()
  ///@see \#clearInstantAppCookie()
  jni.JlObject getInstantAppCookie() =>
      jni.JlObject.fromRef(_getInstantAppCookie(reference));

  static final _clearInstantAppCookie =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PackageManager_clearInstantAppCookie")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void clearInstantAppCookie()
  /// Clears the instant application cookie for the calling app.
  ///@see \#isInstantApp()
  ///@see \#isInstantApp(String)
  ///@see \#getInstantAppCookieMaxBytes()
  ///@see \#getInstantAppCookie()
  ///@see \#clearInstantAppCookie()
  void clearInstantAppCookie() => _clearInstantAppCookie(reference);

  static final _updateInstantAppCookie = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_updateInstantAppCookie")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void updateInstantAppCookie(byte[] cookie)
  /// Updates the instant application cookie for the calling app. Non
  /// instant apps and apps that were instant but were upgraded
  /// to normal apps can still access this API. For instant apps
  /// this cookie is cached for some time after uninstall while for
  /// normal apps the cookie is deleted after the app is uninstalled.
  /// The cookie is always present while the app is installed. The
  /// cookie size is limited by \#getInstantAppCookieMaxBytes().
  /// Passing <code>null</code> or an empty array clears the cookie.
  ///
  ///
  ///@param cookie The cookie data.
  ///
  /// This value may be {@code null}.
  ///@see \#isInstantApp()
  ///@see \#isInstantApp(String)
  ///@see \#getInstantAppCookieMaxBytes()
  ///@see \#getInstantAppCookie()
  ///@see \#clearInstantAppCookie()
  ///@throws IllegalArgumentException if the array exceeds max cookie size.
  void updateInstantAppCookie(jni.JlObject cookie) =>
      _updateInstantAppCookie(reference, cookie.reference);

  static final _getSystemSharedLibraryNames = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getSystemSharedLibraryNames")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String[] getSystemSharedLibraryNames()
  /// Get a list of shared libraries that are available on the
  /// system.
  ///@return An array of shared library names that are
  /// available on the system, or null if none are installed.
  jni.JlObject getSystemSharedLibraryNames() =>
      jni.JlObject.fromRef(_getSystemSharedLibraryNames(reference));

  static final _getSharedLibraries = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getSharedLibraries")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.util.List<android.content.pm.SharedLibraryInfo> getSharedLibraries(int flags)
  /// Get a list of shared libraries on the device.
  ///@param flags To filter the libraries to return.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager.INSTALL_FORWARD_LOCK, android.content.pm.PackageManager.INSTALL_REPLACE_EXISTING, android.content.pm.PackageManager.INSTALL_ALLOW_TEST, android.content.pm.PackageManager.INSTALL_EXTERNAL, android.content.pm.PackageManager.INSTALL_INTERNAL, android.content.pm.PackageManager.INSTALL_FROM_ADB, android.content.pm.PackageManager.INSTALL_ALL_USERS, android.content.pm.PackageManager.INSTALL_ALLOW_DOWNGRADE, android.content.pm.PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS, android.content.pm.PackageManager.INSTALL_FORCE_VOLUME_UUID, android.content.pm.PackageManager.INSTALL_FORCE_PERMISSION_PROMPT, android.content.pm.PackageManager.INSTALL_INSTANT_APP, android.content.pm.PackageManager.INSTALL_DONT_KILL_APP, android.content.pm.PackageManager.INSTALL_FORCE_SDK, android.content.pm.PackageManager.INSTALL_FULL_APP, and android.content.pm.PackageManager.INSTALL_ALLOCATE_AGGRESSIVE
  ///@return The shared library list.
  ///
  /// This value will never be {@code null}.
  ///@see \#MATCH_UNINSTALLED_PACKAGES
  jni.JlObject getSharedLibraries(int flags) =>
      jni.JlObject.fromRef(_getSharedLibraries(reference, flags));

  static final _getChangedPackages = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getChangedPackages")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.pm.ChangedPackages getChangedPackages(int sequenceNumber)
  /// Returns the names of the packages that have been changed
  /// [eg. added, removed or updated] since the given sequence
  /// number.
  /// If no packages have been changed, returns <code>null</code>.
  /// The sequence number starts at <code>0</code> and is
  /// reset every boot.
  ///@param sequenceNumber The first sequence number for which to retrieve package changes.
  /// Value is 0 or greater
  ///@see Settings.Global\#BOOT_COUNT
  ChangedPackages getChangedPackages(int sequenceNumber) =>
      ChangedPackages.fromRef(_getChangedPackages(reference, sequenceNumber));

  static final _getSystemAvailableFeatures = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getSystemAvailableFeatures")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.pm.FeatureInfo[] getSystemAvailableFeatures()
  /// Get a list of features that are available on the
  /// system.
  ///@return An array of FeatureInfo classes describing the features
  /// that are available on the system, or null if there are none(!!).
  jni.JlObject getSystemAvailableFeatures() =>
      jni.JlObject.fromRef(_getSystemAvailableFeatures(reference));

  static final _hasSystemFeature = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_hasSystemFeature")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean hasSystemFeature(java.lang.String name)
  /// Check whether the given feature name is one of the available features as
  /// returned by \#getSystemAvailableFeatures(). This tests for the
  /// presence of _any_ version of the given feature name; use
  /// \#hasSystemFeature(String, int) to check for a minimum version.
  ///@return Returns true if the devices supports the feature, else false.
  bool hasSystemFeature(jni.JlString name) =>
      _hasSystemFeature(reference, name.reference) != 0;

  static final _hasSystemFeature_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_hasSystemFeature_1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract boolean hasSystemFeature(java.lang.String name, int version)
  /// Check whether the given feature name and version is one of the available
  /// features as returned by \#getSystemAvailableFeatures(). Since
  /// features are defined to always be backwards compatible, this returns true
  /// if the available feature version is greater than or equal to the
  /// requested version.
  ///@return Returns true if the devices supports the feature, else false.
  bool hasSystemFeature_1(jni.JlString name, int version) =>
      _hasSystemFeature_1(reference, name.reference, version) != 0;

  static final _resolveActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_resolveActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.pm.ResolveInfo resolveActivity(android.content.Intent intent, int flags)
  /// Determine the best action to perform for a given Intent. This is how
  /// Intent\#resolveActivity finds an activity if a class has not been
  /// explicitly specified.
  ///
  /// _Note:_ if using an implicit Intent (without an explicit
  /// ComponentName specified), be sure to consider whether to set the
  /// \#MATCH_DEFAULT_ONLY only flag. You need to do so to resolve the
  /// activity in the same way that
  /// android.content.Context\#startActivity(Intent) and
  /// android.content.Intent\#resolveActivity(PackageManager) Intent.resolveActivity(PackageManager) do.
  ///
  ///
  ///@param intent An intent containing all of the desired specification
  ///            (action, data, type, category, and/or component).
  ///@param flags Additional option flags to modify the data returned. The
  ///            most important is \#MATCH_DEFAULT_ONLY, to limit the
  ///            resolution to only those activities that support the
  ///            android.content.Intent\#CATEGORY_DEFAULT.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_RESOLVED_FILTER, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return Returns a ResolveInfo object containing the final activity intent
  ///         that was determined to be the best action. Returns null if no
  ///         matching activity was found. If multiple matching activities are
  ///         found and there is no default set, returns a ResolveInfo object
  ///         containing something else, such as the activity resolver.
  ResolveInfo resolveActivity(content.Intent intent, int flags) =>
      ResolveInfo.fromRef(_resolveActivity(reference, intent.reference, flags));

  static final _queryIntentActivities = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_queryIntentActivities")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.util.List<android.content.pm.ResolveInfo> queryIntentActivities(android.content.Intent intent, int flags)
  /// Retrieve all activities that can be performed for the given intent.
  ///@param intent The desired intent as per resolveActivity().
  ///@param flags Additional option flags to modify the data returned. The
  ///            most important is \#MATCH_DEFAULT_ONLY, to limit the
  ///            resolution to only those activities that support the
  ///            android.content.Intent\#CATEGORY_DEFAULT. Or, set
  ///            \#MATCH_ALL to prevent any filtering of the results.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_RESOLVED_FILTER, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return Returns a List of ResolveInfo objects containing one entry for
  ///         each matching activity, ordered from best to worst. In other
  ///         words, the first item is what would be returned by
  ///         \#resolveActivity. If there are no matching activities, an
  ///         empty list is returned.
  jni.JlObject queryIntentActivities(content.Intent intent, int flags) =>
      jni.JlObject.fromRef(
          _queryIntentActivities(reference, intent.reference, flags));

  static final _queryIntentActivityOptions = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32)>>(
          "android_content_pm_PackageManager_queryIntentActivityOptions")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int)>();

  /// from: public abstract java.util.List<android.content.pm.ResolveInfo> queryIntentActivityOptions(android.content.ComponentName caller, android.content.Intent[] specifics, android.content.Intent intent, int flags)
  /// Retrieve a set of activities that should be presented to the user as
  /// similar options. This is like \#queryIntentActivities, except it
  /// also allows you to supply a list of more explicit Intents that you would
  /// like to resolve to particular options, and takes care of returning the
  /// final ResolveInfo list in a reasonable order, with no duplicates, based
  /// on those inputs.
  ///@param caller The class name of the activity that is making the request.
  ///            This activity will never appear in the output list. Can be
  ///            null.
  /// This value may be {@code null}.
  ///@param specifics An array of Intents that should be resolved to the first
  ///            specific results. Can be null.
  /// This value may be {@code null}.
  ///@param intent The desired intent as per resolveActivity().
  ///@param flags Additional option flags to modify the data returned. The
  ///            most important is \#MATCH_DEFAULT_ONLY, to limit the
  ///            resolution to only those activities that support the
  ///            android.content.Intent\#CATEGORY_DEFAULT.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_RESOLVED_FILTER, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return Returns a List of ResolveInfo objects containing one entry for
  ///         each matching activity. The list is ordered first by all of the
  ///         intents resolved in <var>specifics</var> and then any additional
  ///         activities that can handle <var>intent</var> but did not get
  ///         included by one of the <var>specifics</var> intents. If there are
  ///         no matching activities, an empty list is returned.
  jni.JlObject queryIntentActivityOptions(content.ComponentName caller,
          jni.JlObject specifics, content.Intent intent, int flags) =>
      jni.JlObject.fromRef(_queryIntentActivityOptions(reference,
          caller.reference, specifics.reference, intent.reference, flags));

  static final _queryBroadcastReceivers = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_queryBroadcastReceivers")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.util.List<android.content.pm.ResolveInfo> queryBroadcastReceivers(android.content.Intent intent, int flags)
  /// Retrieve all receivers that can handle a broadcast of the given intent.
  ///@param intent The desired intent as per resolveActivity().
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_RESOLVED_FILTER, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return Returns a List of ResolveInfo objects containing one entry for
  ///         each matching receiver, ordered from best to worst. If there are
  ///         no matching receivers, an empty list or null is returned.
  jni.JlObject queryBroadcastReceivers(content.Intent intent, int flags) =>
      jni.JlObject.fromRef(
          _queryBroadcastReceivers(reference, intent.reference, flags));

  static final _resolveService = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_resolveService")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.pm.ResolveInfo resolveService(android.content.Intent intent, int flags)
  /// Determine the best service to handle for a given Intent.
  ///@param intent An intent containing all of the desired specification
  ///            (action, data, type, category, and/or component).
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_RESOLVED_FILTER, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return Returns a ResolveInfo object containing the final service intent
  ///         that was determined to be the best action. Returns null if no
  ///         matching service was found.
  ResolveInfo resolveService(content.Intent intent, int flags) =>
      ResolveInfo.fromRef(_resolveService(reference, intent.reference, flags));

  static final _queryIntentServices = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_queryIntentServices")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.util.List<android.content.pm.ResolveInfo> queryIntentServices(android.content.Intent intent, int flags)
  /// Retrieve all services that can match the given intent.
  ///@param intent The desired intent as per resolveService().
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_RESOLVED_FILTER, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return Returns a List of ResolveInfo objects containing one entry for
  ///         each matching service, ordered from best to worst. In other
  ///         words, the first item is what would be returned by
  ///         \#resolveService. If there are no matching services, an
  ///         empty list or null is returned.
  jni.JlObject queryIntentServices(content.Intent intent, int flags) =>
      jni.JlObject.fromRef(
          _queryIntentServices(reference, intent.reference, flags));

  static final _queryIntentContentProviders = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_queryIntentContentProviders")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.util.List<android.content.pm.ResolveInfo> queryIntentContentProviders(android.content.Intent intent, int flags)
  /// Retrieve all providers that can match the given intent.
  ///@param intent An intent containing all of the desired specification
  ///            (action, data, type, category, and/or component).
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_RESOLVED_FILTER, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return Returns a List of ResolveInfo objects containing one entry for
  ///         each matching provider, ordered from best to worst. If there are
  ///         no matching services, an empty list or null is returned.
  jni.JlObject queryIntentContentProviders(content.Intent intent, int flags) =>
      jni.JlObject.fromRef(
          _queryIntentContentProviders(reference, intent.reference, flags));

  static final _resolveContentProvider = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_resolveContentProvider")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.pm.ProviderInfo resolveContentProvider(java.lang.String name, int flags)
  /// Find a single content provider by its base path name.
  ///@param name The name of the provider to find.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return A ProviderInfo object containing information about the
  ///         provider. If a provider was not found, returns null.
  ProviderInfo resolveContentProvider(jni.JlString name, int flags) =>
      ProviderInfo.fromRef(
          _resolveContentProvider(reference, name.reference, flags));

  static final _queryContentProviders = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_content_pm_PackageManager_queryContentProviders")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract java.util.List<android.content.pm.ProviderInfo> queryContentProviders(java.lang.String processName, int uid, int flags)
  /// Retrieve content provider information.
  ///
  /// _Note: unlike most other methods, an empty result set is indicated
  /// by a null return instead of an empty list._
  ///@param processName If non-null, limits the returned providers to only
  ///            those that are hosted by the given process. If null, all
  ///            content providers are returned.
  ///@param uid If <var>processName</var> is non-null, this is the required
  ///            uid owning the requested content providers.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return A list of ProviderInfo objects containing one entry for
  ///         each provider either matching <var>processName</var> or, if
  ///         <var>processName</var> is null, all known content providers.
  ///         _If there are no matching providers, null is returned._
  jni.JlObject queryContentProviders(
          jni.JlString processName, int uid, int flags) =>
      jni.JlObject.fromRef(
          _queryContentProviders(reference, processName.reference, uid, flags));

  static final _getInstrumentationInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getInstrumentationInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.pm.InstrumentationInfo getInstrumentationInfo(android.content.ComponentName className, int flags)
  /// Retrieve all of the information we know about a particular
  /// instrumentation class.
  ///@param className The full name (i.e.
  ///            com.google.apps.contacts.InstrumentList) of an Instrumentation
  ///            class.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or android.content.pm.PackageManager\#GET_META_DATA
  ///@return An InstrumentationInfo object containing information
  ///         about the instrumentation.
  ///@throws NameNotFoundException if a package with the given name cannot be
  ///             found on the system.
  InstrumentationInfo getInstrumentationInfo(
          content.ComponentName className, int flags) =>
      InstrumentationInfo.fromRef(
          _getInstrumentationInfo(reference, className.reference, flags));

  static final _queryInstrumentation = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_queryInstrumentation")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.util.List<android.content.pm.InstrumentationInfo> queryInstrumentation(java.lang.String targetPackage, int flags)
  /// Retrieve information about available instrumentation code. May be used to
  /// retrieve either all instrumentation code, or only the code targeting a
  /// particular package.
  ///@param targetPackage If null, all instrumentation is returned; only the
  ///            instrumentation targeting this package name is returned.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or android.content.pm.PackageManager\#GET_META_DATA
  ///@return A list of InstrumentationInfo objects containing one
  ///         entry for each matching instrumentation. If there are no
  ///         instrumentation available, returns an empty list.
  jni.JlObject queryInstrumentation(jni.JlString targetPackage, int flags) =>
      jni.JlObject.fromRef(
          _queryInstrumentation(reference, targetPackage.reference, flags));

  static final _getDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getDrawable")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable getDrawable(java.lang.String packageName, int resid, android.content.pm.ApplicationInfo appInfo)
  /// Retrieve an image from a package.  This is a low-level API used by
  /// the various package manager info structures (such as
  /// ComponentInfo to implement retrieval of their associated
  /// icon.
  ///@param packageName The name of the package that this icon is coming from.
  /// Cannot be null.
  ///@param resid The resource identifier of the desired image.  Cannot be 0.
  ///@param appInfo Overall information about <var>packageName</var>.  This
  /// may be null, in which case the application information will be retrieved
  /// for you if needed; if you already have this information around, it can
  /// be much more efficient to supply it here.
  ///@return Returns a Drawable holding the requested image.  Returns null if
  /// an image could not be found for any reason.
  jni.JlObject getDrawable(
          jni.JlString packageName, int resid, ApplicationInfo appInfo) =>
      jni.JlObject.fromRef(_getDrawable(
          reference, packageName.reference, resid, appInfo.reference));

  static final _getActivityIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getActivityIcon")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable getActivityIcon(android.content.ComponentName activityName)
  /// Retrieve the icon associated with an activity.  Given the full name of
  /// an activity, retrieves the information about it and calls
  /// ComponentInfo\#loadIcon ComponentInfo.loadIcon() to return its icon.
  /// If the activity cannot be found, NameNotFoundException is thrown.
  ///@param activityName Name of the activity whose icon is to be retrieved.
  ///@return Returns the image of the icon, or the default activity icon if
  /// it could not be found.  Does not return null.
  ///@throws NameNotFoundException Thrown if the resources for the given
  /// activity could not be loaded.
  ///@see \#getActivityIcon(Intent)
  jni.JlObject getActivityIcon(content.ComponentName activityName) =>
      jni.JlObject.fromRef(_getActivityIcon(reference, activityName.reference));

  static final _getActivityIcon_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getActivityIcon_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable getActivityIcon(android.content.Intent intent)
  /// Retrieve the icon associated with an Intent.  If intent.getClassName() is
  /// set, this simply returns the result of
  /// getActivityIcon(intent.getClassName()).  Otherwise it resolves the intent's
  /// component and returns the icon associated with the resolved component.
  /// If intent.getClassName() cannot be found or the Intent cannot be resolved
  /// to a component, NameNotFoundException is thrown.
  ///@param intent The intent for which you would like to retrieve an icon.
  ///@return Returns the image of the icon, or the default activity icon if
  /// it could not be found.  Does not return null.
  ///@throws NameNotFoundException Thrown if the resources for application
  /// matching the given intent could not be loaded.
  ///@see \#getActivityIcon(ComponentName)
  jni.JlObject getActivityIcon_1(content.Intent intent) =>
      jni.JlObject.fromRef(_getActivityIcon_1(reference, intent.reference));

  static final _getActivityBanner = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getActivityBanner")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable getActivityBanner(android.content.ComponentName activityName)
  /// Retrieve the banner associated with an activity. Given the full name of
  /// an activity, retrieves the information about it and calls
  /// ComponentInfo\#loadIcon ComponentInfo.loadIcon() to return its
  /// banner. If the activity cannot be found, NameNotFoundException is thrown.
  ///@param activityName Name of the activity whose banner is to be retrieved.
  ///@return Returns the image of the banner, or null if the activity has no
  ///         banner specified.
  ///@throws NameNotFoundException Thrown if the resources for the given
  ///             activity could not be loaded.
  ///@see \#getActivityBanner(Intent)
  jni.JlObject getActivityBanner(content.ComponentName activityName) =>
      jni.JlObject.fromRef(
          _getActivityBanner(reference, activityName.reference));

  static final _getActivityBanner_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getActivityBanner_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable getActivityBanner(android.content.Intent intent)
  /// Retrieve the banner associated with an Intent. If intent.getClassName()
  /// is set, this simply returns the result of
  /// getActivityBanner(intent.getClassName()). Otherwise it resolves the
  /// intent's component and returns the banner associated with the resolved
  /// component. If intent.getClassName() cannot be found or the Intent cannot
  /// be resolved to a component, NameNotFoundException is thrown.
  ///@param intent The intent for which you would like to retrieve a banner.
  ///@return Returns the image of the banner, or null if the activity has no
  ///         banner specified.
  ///@throws NameNotFoundException Thrown if the resources for application
  ///             matching the given intent could not be loaded.
  ///@see \#getActivityBanner(ComponentName)
  jni.JlObject getActivityBanner_1(content.Intent intent) =>
      jni.JlObject.fromRef(_getActivityBanner_1(reference, intent.reference));

  static final _getDefaultActivityIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getDefaultActivityIcon")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable getDefaultActivityIcon()
  /// Return the generic icon for an activity that is used when no specific
  /// icon is defined.
  ///@return Drawable Image of the icon.
  jni.JlObject getDefaultActivityIcon() =>
      jni.JlObject.fromRef(_getDefaultActivityIcon(reference));

  static final _getApplicationIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getApplicationIcon")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable getApplicationIcon(android.content.pm.ApplicationInfo info)
  /// Retrieve the icon associated with an application.  If it has not defined
  /// an icon, the default app icon is returned.  Does not return null.
  ///@param info Information about application being queried.
  ///@return Returns the image of the icon, or the default application icon
  /// if it could not be found.
  ///@see \#getApplicationIcon(String)
  jni.JlObject getApplicationIcon(ApplicationInfo info) =>
      jni.JlObject.fromRef(_getApplicationIcon(reference, info.reference));

  static final _getApplicationIcon_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getApplicationIcon_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable getApplicationIcon(java.lang.String packageName)
  /// Retrieve the icon associated with an application.  Given the name of the
  /// application's package, retrieves the information about it and calls
  /// getApplicationIcon() to return its icon. If the application cannot be
  /// found, NameNotFoundException is thrown.
  ///@param packageName Name of the package whose application icon is to be
  ///                    retrieved.
  ///@return Returns the image of the icon, or the default application icon
  /// if it could not be found.  Does not return null.
  ///@throws NameNotFoundException Thrown if the resources for the given
  /// application could not be loaded.
  ///@see \#getApplicationIcon(ApplicationInfo)
  jni.JlObject getApplicationIcon_1(jni.JlString packageName) =>
      jni.JlObject.fromRef(
          _getApplicationIcon_1(reference, packageName.reference));

  static final _getApplicationBanner = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getApplicationBanner")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable getApplicationBanner(android.content.pm.ApplicationInfo info)
  /// Retrieve the banner associated with an application.
  ///@param info Information about application being queried.
  ///@return Returns the image of the banner or null if the application has no
  ///         banner specified.
  ///@see \#getApplicationBanner(String)
  jni.JlObject getApplicationBanner(ApplicationInfo info) =>
      jni.JlObject.fromRef(_getApplicationBanner(reference, info.reference));

  static final _getApplicationBanner_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getApplicationBanner_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable getApplicationBanner(java.lang.String packageName)
  /// Retrieve the banner associated with an application. Given the name of the
  /// application's package, retrieves the information about it and calls
  /// getApplicationIcon() to return its banner. If the application cannot be
  /// found, NameNotFoundException is thrown.
  ///@param packageName Name of the package whose application banner is to be
  ///            retrieved.
  ///@return Returns the image of the banner or null if the application has no
  ///         banner specified.
  ///@throws NameNotFoundException Thrown if the resources for the given
  ///             application could not be loaded.
  ///@see \#getApplicationBanner(ApplicationInfo)
  jni.JlObject getApplicationBanner_1(jni.JlString packageName) =>
      jni.JlObject.fromRef(
          _getApplicationBanner_1(reference, packageName.reference));

  static final _getActivityLogo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getActivityLogo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable getActivityLogo(android.content.ComponentName activityName)
  /// Retrieve the logo associated with an activity. Given the full name of an
  /// activity, retrieves the information about it and calls
  /// ComponentInfo\#loadLogo ComponentInfo.loadLogo() to return its
  /// logo. If the activity cannot be found, NameNotFoundException is thrown.
  ///@param activityName Name of the activity whose logo is to be retrieved.
  ///@return Returns the image of the logo or null if the activity has no logo
  ///         specified.
  ///@throws NameNotFoundException Thrown if the resources for the given
  ///             activity could not be loaded.
  ///@see \#getActivityLogo(Intent)
  jni.JlObject getActivityLogo(content.ComponentName activityName) =>
      jni.JlObject.fromRef(_getActivityLogo(reference, activityName.reference));

  static final _getActivityLogo_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getActivityLogo_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable getActivityLogo(android.content.Intent intent)
  /// Retrieve the logo associated with an Intent.  If intent.getClassName() is
  /// set, this simply returns the result of
  /// getActivityLogo(intent.getClassName()).  Otherwise it resolves the intent's
  /// component and returns the logo associated with the resolved component.
  /// If intent.getClassName() cannot be found or the Intent cannot be resolved
  /// to a component, NameNotFoundException is thrown.
  ///@param intent The intent for which you would like to retrieve a logo.
  ///@return Returns the image of the logo, or null if the activity has no
  /// logo specified.
  ///@throws NameNotFoundException Thrown if the resources for application
  /// matching the given intent could not be loaded.
  ///@see \#getActivityLogo(ComponentName)
  jni.JlObject getActivityLogo_1(content.Intent intent) =>
      jni.JlObject.fromRef(_getActivityLogo_1(reference, intent.reference));

  static final _getApplicationLogo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getApplicationLogo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable getApplicationLogo(android.content.pm.ApplicationInfo info)
  /// Retrieve the logo associated with an application.  If it has not specified
  /// a logo, this method returns null.
  ///@param info Information about application being queried.
  ///@return Returns the image of the logo, or null if no logo is specified
  /// by the application.
  ///@see \#getApplicationLogo(String)
  jni.JlObject getApplicationLogo(ApplicationInfo info) =>
      jni.JlObject.fromRef(_getApplicationLogo(reference, info.reference));

  static final _getApplicationLogo_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getApplicationLogo_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable getApplicationLogo(java.lang.String packageName)
  /// Retrieve the logo associated with an application.  Given the name of the
  /// application's package, retrieves the information about it and calls
  /// getApplicationLogo() to return its logo. If the application cannot be
  /// found, NameNotFoundException is thrown.
  ///@param packageName Name of the package whose application logo is to be
  ///                    retrieved.
  ///@return Returns the image of the logo, or null if no application logo
  /// has been specified.
  ///@throws NameNotFoundException Thrown if the resources for the given
  /// application could not be loaded.
  ///@see \#getApplicationLogo(ApplicationInfo)
  jni.JlObject getApplicationLogo_1(jni.JlString packageName) =>
      jni.JlObject.fromRef(
          _getApplicationLogo_1(reference, packageName.reference));

  static final _getUserBadgedIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getUserBadgedIcon")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable getUserBadgedIcon(android.graphics.drawable.Drawable icon, android.os.UserHandle user)
  /// If the target user is a managed profile, then this returns a badged copy of the given icon
  /// to be able to distinguish it from the original icon. For badging an arbitrary drawable use
  /// \#getUserBadgedDrawableForDensity(
  /// android.graphics.drawable.Drawable, UserHandle, android.graphics.Rect, int).
  ///
  /// If the original drawable is a BitmapDrawable and the backing bitmap is
  /// mutable as per android.graphics.Bitmap\#isMutable(), the badging
  /// is performed in place and the original drawable is returned.
  ///
  ///
  ///@param icon The icon to badge.
  ///@param user The target user.
  ///@return A drawable that combines the original icon and a badge as
  ///         determined by the system.
  jni.JlObject getUserBadgedIcon(jni.JlObject icon, os.UserHandle user) =>
      jni.JlObject.fromRef(
          _getUserBadgedIcon(reference, icon.reference, user.reference));

  static final _getUserBadgedDrawableForDensity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32)>>(
          "android_content_pm_PackageManager_getUserBadgedDrawableForDensity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int)>();

  /// from: public abstract android.graphics.drawable.Drawable getUserBadgedDrawableForDensity(android.graphics.drawable.Drawable drawable, android.os.UserHandle user, android.graphics.Rect badgeLocation, int badgeDensity)
  /// If the target user is a managed profile of the calling user or the caller
  /// is itself a managed profile, then this returns a badged copy of the given
  /// drawable allowing the user to distinguish it from the original drawable.
  /// The caller can specify the location in the bounds of the drawable to be
  /// badged where the badge should be applied as well as the density of the
  /// badge to be used.
  ///
  /// If the original drawable is a BitmapDrawable and the backing bitmap is
  /// mutable as per android.graphics.Bitmap\#isMutable(), the badging
  /// is performed in place and the original drawable is returned.
  ///
  ///
  ///@param drawable The drawable to badge.
  ///@param user The target user.
  ///@param badgeLocation Where in the bounds of the badged drawable to place
  ///         the badge. If it's {@code null}, the badge is applied on top of the entire
  ///         drawable being badged.
  ///@param badgeDensity The optional desired density for the badge as per
  ///         android.util.DisplayMetrics\#densityDpi. If it's not positive,
  ///         the density of the display is used.
  ///@return A drawable that combines the original drawable and a badge as
  ///         determined by the system.
  jni.JlObject getUserBadgedDrawableForDensity(jni.JlObject drawable,
          os.UserHandle user, jni.JlObject badgeLocation, int badgeDensity) =>
      jni.JlObject.fromRef(_getUserBadgedDrawableForDensity(
          reference,
          drawable.reference,
          user.reference,
          badgeLocation.reference,
          badgeDensity));

  static final _getUserBadgedLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getUserBadgedLabel")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.CharSequence getUserBadgedLabel(java.lang.CharSequence label, android.os.UserHandle user)
  /// If the target user is a managed profile of the calling user or the caller
  /// is itself a managed profile, then this returns a copy of the label with
  /// badging for accessibility services like talkback. E.g. passing in "Email"
  /// and it might return "Work Email" for Email in the work profile.
  ///@param label The label to change.
  ///@param user The target user.
  ///@return A label that combines the original label and a badge as
  ///         determined by the system.
  jni.JlObject getUserBadgedLabel(jni.JlObject label, os.UserHandle user) =>
      jni.JlObject.fromRef(
          _getUserBadgedLabel(reference, label.reference, user.reference));

  static final _getText = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getText")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.CharSequence getText(java.lang.String packageName, int resid, android.content.pm.ApplicationInfo appInfo)
  /// Retrieve text from a package.  This is a low-level API used by
  /// the various package manager info structures (such as
  /// ComponentInfo to implement retrieval of their associated
  /// labels and other text.
  ///@param packageName The name of the package that this text is coming from.
  /// Cannot be null.
  ///@param resid The resource identifier of the desired text.  Cannot be 0.
  ///@param appInfo Overall information about <var>packageName</var>.  This
  /// may be null, in which case the application information will be retrieved
  /// for you if needed; if you already have this information around, it can
  /// be much more efficient to supply it here.
  ///@return Returns a CharSequence holding the requested text.  Returns null
  /// if the text could not be found for any reason.
  jni.JlObject getText(
          jni.JlString packageName, int resid, ApplicationInfo appInfo) =>
      jni.JlObject.fromRef(
          _getText(reference, packageName.reference, resid, appInfo.reference));

  static final _getXml = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getXml")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.res.XmlResourceParser getXml(java.lang.String packageName, int resid, android.content.pm.ApplicationInfo appInfo)
  /// Retrieve an XML file from a package.  This is a low-level API used to
  /// retrieve XML meta data.
  ///@param packageName The name of the package that this xml is coming from.
  /// Cannot be null.
  ///@param resid The resource identifier of the desired xml.  Cannot be 0.
  ///@param appInfo Overall information about <var>packageName</var>.  This
  /// may be null, in which case the application information will be retrieved
  /// for you if needed; if you already have this information around, it can
  /// be much more efficient to supply it here.
  ///@return Returns an XmlPullParser allowing you to parse out the XML
  /// data.  Returns null if the xml resource could not be found for any
  /// reason.
  res.XmlResourceParser getXml(
          jni.JlString packageName, int resid, ApplicationInfo appInfo) =>
      res.XmlResourceParser.fromRef(
          _getXml(reference, packageName.reference, resid, appInfo.reference));

  static final _getApplicationLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getApplicationLabel")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.CharSequence getApplicationLabel(android.content.pm.ApplicationInfo info)
  /// Return the label to use for this application.
  ///@return Returns the label associated with this application, or null if
  /// it could not be found for any reason.
  ///@param info The application to get the label of.
  jni.JlObject getApplicationLabel(ApplicationInfo info) =>
      jni.JlObject.fromRef(_getApplicationLabel(reference, info.reference));

  static final _getResourcesForActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getResourcesForActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.res.Resources getResourcesForActivity(android.content.ComponentName activityName)
  /// Retrieve the resources associated with an activity.  Given the full
  /// name of an activity, retrieves the information about it and calls
  /// getResources() to return its application's resources.  If the activity
  /// cannot be found, NameNotFoundException is thrown.
  ///@param activityName Name of the activity whose resources are to be
  ///                     retrieved.
  ///@return Returns the application's Resources.
  ///@throws NameNotFoundException Thrown if the resources for the given
  /// application could not be loaded.
  ///@see \#getResourcesForApplication(ApplicationInfo)
  res.Resources getResourcesForActivity(content.ComponentName activityName) =>
      res.Resources.fromRef(
          _getResourcesForActivity(reference, activityName.reference));

  static final _getResourcesForApplication = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getResourcesForApplication")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.res.Resources getResourcesForApplication(android.content.pm.ApplicationInfo app)
  /// Retrieve the resources for an application.  Throws NameNotFoundException
  /// if the package is no longer installed.
  ///@param app Information about the desired application.
  ///@return Returns the application's Resources.
  ///@throws NameNotFoundException Thrown if the resources for the given
  /// application could not be loaded (most likely because it was uninstalled).
  res.Resources getResourcesForApplication(ApplicationInfo app) =>
      res.Resources.fromRef(
          _getResourcesForApplication(reference, app.reference));

  static final _getResourcesForApplication_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getResourcesForApplication_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.res.Resources getResourcesForApplication(java.lang.String appPackageName)
  /// Retrieve the resources associated with an application.  Given the full
  /// package name of an application, retrieves the information about it and
  /// calls getResources() to return its application's resources.  If the
  /// appPackageName cannot be found, NameNotFoundException is thrown.
  ///@param appPackageName Package name of the application whose resources
  ///                       are to be retrieved.
  ///@return Returns the application's Resources.
  ///@throws NameNotFoundException Thrown if the resources for the given
  /// application could not be loaded.
  ///@see \#getResourcesForApplication(ApplicationInfo)
  res.Resources getResourcesForApplication_1(jni.JlString appPackageName) =>
      res.Resources.fromRef(
          _getResourcesForApplication_1(reference, appPackageName.reference));

  static final _getPackageArchiveInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getPackageArchiveInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.pm.PackageInfo getPackageArchiveInfo(java.lang.String archiveFilePath, int flags)
  /// Retrieve overall information about an application package defined in a
  /// package archive file
  ///@param archiveFilePath The path to the archive file
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_ACTIVITIES, android.content.pm.PackageManager\#GET_CONFIGURATIONS, android.content.pm.PackageManager\#GET_GIDS, android.content.pm.PackageManager\#GET_INSTRUMENTATION, android.content.pm.PackageManager\#GET_INTENT_FILTERS, android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_PERMISSIONS, android.content.pm.PackageManager\#GET_PROVIDERS, android.content.pm.PackageManager\#GET_RECEIVERS, android.content.pm.PackageManager\#GET_SERVICES, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#GET_SIGNATURES, android.content.pm.PackageManager\#GET_SIGNING_CERTIFICATES, android.content.pm.PackageManager\#GET_URI_PERMISSION_PATTERNS, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_FACTORY_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return A PackageInfo object containing information about the package
  ///         archive. If the package could not be parsed, returns null.
  PackageInfo getPackageArchiveInfo(jni.JlString archiveFilePath, int flags) =>
      PackageInfo.fromRef(
          _getPackageArchiveInfo(reference, archiveFilePath.reference, flags));

  static final _verifyPendingInstall = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_content_pm_PackageManager_verifyPendingInstall")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void verifyPendingInstall(int id, int verificationCode)
  /// Allows a package listening to the
  /// Intent\#ACTION_PACKAGE_NEEDS_VERIFICATION package verification
  /// broadcast to respond to the package manager. The response must include
  /// the {@code verificationCode} which is one of
  /// PackageManager\#VERIFICATION_ALLOW or
  /// PackageManager\#VERIFICATION_REJECT.
  ///@param id pending package identifier as passed via the
  ///            PackageManager\#EXTRA_VERIFICATION_ID Intent extra.
  ///@param verificationCode either PackageManager\#VERIFICATION_ALLOW
  ///            or PackageManager\#VERIFICATION_REJECT.
  ///@throws SecurityException if the caller does not have the
  ///            PACKAGE_VERIFICATION_AGENT permission.
  void verifyPendingInstall(int id, int verificationCode) =>
      _verifyPendingInstall(reference, id, verificationCode);

  static final _extendVerificationTimeout = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32, ffi.Int64)>>(
          "android_content_pm_PackageManager_extendVerificationTimeout")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public abstract void extendVerificationTimeout(int id, int verificationCodeAtTimeout, long millisecondsToDelay)
  /// Allows a package listening to the
  /// Intent\#ACTION_PACKAGE_NEEDS_VERIFICATION package verification
  /// broadcast to extend the default timeout for a response and declare what
  /// action to perform after the timeout occurs. The response must include
  /// the {@code verificationCodeAtTimeout} which is one of
  /// PackageManager\#VERIFICATION_ALLOW or
  /// PackageManager\#VERIFICATION_REJECT.
  ///
  /// This method may only be called once per package id. Additional calls
  /// will have no effect.
  ///@param id pending package identifier as passed via the
  ///            PackageManager\#EXTRA_VERIFICATION_ID Intent extra.
  ///@param verificationCodeAtTimeout either
  ///            PackageManager\#VERIFICATION_ALLOW or
  ///            PackageManager\#VERIFICATION_REJECT. If
  ///            {@code verificationCodeAtTimeout} is neither
  ///            PackageManager\#VERIFICATION_ALLOW or
  ///            PackageManager\#VERIFICATION_REJECT, then
  ///            {@code verificationCodeAtTimeout} will default to
  ///            PackageManager\#VERIFICATION_REJECT.
  ///@param millisecondsToDelay the amount of time requested for the timeout.
  ///            Must be positive and less than
  ///            PackageManager\#MAXIMUM_VERIFICATION_TIMEOUT. If
  ///            {@code millisecondsToDelay} is out of bounds,
  ///            {@code millisecondsToDelay} will be set to the closest in
  ///            bounds value; namely, 0 or
  ///            PackageManager\#MAXIMUM_VERIFICATION_TIMEOUT.
  ///@throws SecurityException if the caller does not have the
  ///            PACKAGE_VERIFICATION_AGENT permission.
  void extendVerificationTimeout(
          int id, int verificationCodeAtTimeout, int millisecondsToDelay) =>
      _extendVerificationTimeout(
          reference, id, verificationCodeAtTimeout, millisecondsToDelay);

  static final _setInstallerPackageName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_setInstallerPackageName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setInstallerPackageName(java.lang.String targetPackage, java.lang.String installerPackageName)
  /// Change the installer associated with a given package.  There are limitations
  /// on how the installer package can be changed; in particular:
  /// <ul>
  /// <li> A SecurityException will be thrown if <var>installerPackageName</var>
  /// is not signed with the same certificate as the calling application.
  /// <li> A SecurityException will be thrown if <var>targetPackage</var> already
  /// has an installer package, and that installer package is not signed with
  /// the same certificate as the calling application.
  /// </ul>
  ///@param targetPackage The installed package whose installer will be changed.
  ///@param installerPackageName The package name of the new installer.  May be
  /// null to clear the association.
  void setInstallerPackageName(
          jni.JlString targetPackage, jni.JlString installerPackageName) =>
      _setInstallerPackageName(
          reference, targetPackage.reference, installerPackageName.reference);

  static final _getInstallerPackageName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getInstallerPackageName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getInstallerPackageName(java.lang.String packageName)
  /// Retrieve the package name of the application that installed a package. This identifies
  /// which market the package came from.
  ///@param packageName The name of the package to query
  ///@throws IllegalArgumentException if the given package name is not installed
  jni.JlString getInstallerPackageName(jni.JlString packageName) =>
      jni.JlString.fromRef(
          _getInstallerPackageName(reference, packageName.reference));

  static final _addPackageToPreferred = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_addPackageToPreferred")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void addPackageToPreferred(java.lang.String packageName)
  /// @deprecated This function no longer does anything; it was an old
  /// approach to managing preferred activities, which has been superseded
  /// by (and conflicts with) the modern activity-based preferences.
  void addPackageToPreferred(jni.JlString packageName) =>
      _addPackageToPreferred(reference, packageName.reference);

  static final _removePackageFromPreferred = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_removePackageFromPreferred")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void removePackageFromPreferred(java.lang.String packageName)
  /// @deprecated This function no longer does anything; it was an old
  /// approach to managing preferred activities, which has been superseded
  /// by (and conflicts with) the modern activity-based preferences.
  void removePackageFromPreferred(jni.JlString packageName) =>
      _removePackageFromPreferred(reference, packageName.reference);

  static final _getPreferredPackages = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_getPreferredPackages")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.util.List<android.content.pm.PackageInfo> getPreferredPackages(int flags)
  /// Retrieve the list of all currently configured preferred packages. The
  /// first package on the list is the most preferred, the last is the least
  /// preferred.
  ///@param flags Additional option flags to modify the data returned.
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_ACTIVITIES, android.content.pm.PackageManager\#GET_CONFIGURATIONS, android.content.pm.PackageManager\#GET_GIDS, android.content.pm.PackageManager\#GET_INSTRUMENTATION, android.content.pm.PackageManager\#GET_INTENT_FILTERS, android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_PERMISSIONS, android.content.pm.PackageManager\#GET_PROVIDERS, android.content.pm.PackageManager\#GET_RECEIVERS, android.content.pm.PackageManager\#GET_SERVICES, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#GET_SIGNATURES, android.content.pm.PackageManager\#GET_SIGNING_CERTIFICATES, android.content.pm.PackageManager\#GET_URI_PERMISSION_PATTERNS, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager.MATCH_FACTORY_ONLY, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES, and android.content.pm.PackageManager.MATCH_HIDDEN_UNTIL_INSTALLED_COMPONENTS
  ///@return A List of PackageInfo objects, one for each preferred
  ///         application, in order of preference.
  jni.JlObject getPreferredPackages(int flags) =>
      jni.JlObject.fromRef(_getPreferredPackages(reference, flags));

  static final _addPreferredActivity = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_addPreferredActivity")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void addPreferredActivity(android.content.IntentFilter filter, int match, android.content.ComponentName[] set, android.content.ComponentName activity)
  /// @deprecated This is a protected API that should not have been available
  /// to third party applications.  It is the platform's responsibility for
  /// assigning preferred activities and this cannot be directly modified.
  ///
  /// Add a new preferred activity mapping to the system.  This will be used
  /// to automatically select the given activity component when
  /// Context\#startActivity(Intent) Context.startActivity() finds
  /// multiple matching activities and also matches the given filter.
  ///@param filter The set of intents under which this activity will be
  /// made preferred.
  ///@param match The IntentFilter match category that this preference
  /// applies to.
  ///@param set The set of activities that the user was picking from when
  /// this preference was made.
  ///@param activity The component name of the activity that is to be
  /// preferred.
  void addPreferredActivity(content.IntentFilter filter, int match,
          jni.JlObject set_, content.ComponentName activity) =>
      _addPreferredActivity(reference, filter.reference, match, set_.reference,
          activity.reference);

  static final _clearPackagePreferredActivities = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_clearPackagePreferredActivities")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void clearPackagePreferredActivities(java.lang.String packageName)
  /// Remove all preferred activity mappings, previously added with
  /// \#addPreferredActivity, from the
  /// system whose activities are implemented in the given package name.
  /// An application can only clear its own package(s).
  ///@param packageName The name of the package whose preferred activity
  /// mappings are to be removed.
  void clearPackagePreferredActivities(jni.JlString packageName) =>
      _clearPackagePreferredActivities(reference, packageName.reference);

  static final _getPreferredActivities = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getPreferredActivities")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getPreferredActivities(java.util.List<android.content.IntentFilter> outFilters, java.util.List<android.content.ComponentName> outActivities, java.lang.String packageName)
  /// Retrieve all preferred activities, previously added with
  /// \#addPreferredActivity, that are
  /// currently registered with the system.
  ///@param outFilters A required list in which to place the filters of all of the
  /// preferred activities.
  /// This value must never be {@code null}.
  ///@param outActivities A required list in which to place the component names of
  /// all of the preferred activities.
  /// This value must never be {@code null}.
  ///@param packageName An optional package in which you would like to limit
  /// the list.  If null, all activities will be returned; if non-null, only
  /// those activities in the given package are returned.
  ///@return Returns the total number of registered preferred activities
  /// (the number of distinct IntentFilter records, not the number of unique
  /// activity components) that were found.
  int getPreferredActivities(jni.JlObject outFilters,
          jni.JlObject outActivities, jni.JlString packageName) =>
      _getPreferredActivities(reference, outFilters.reference,
          outActivities.reference, packageName.reference);

  static final _setComponentEnabledSetting = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_content_pm_PackageManager_setComponentEnabledSetting")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void setComponentEnabledSetting(android.content.ComponentName componentName, int newState, int flags)
  /// Set the enabled setting for a package component (activity, receiver, service, provider).
  /// This setting will override any enabled state which may have been set by the component in its
  /// manifest.
  ///@param componentName The component to enable
  ///@param newState The new enabled state for the component.
  /// Value is android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DEFAULT, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_ENABLED, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED_USER, or android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED
  ///@param flags Optional behavior flags.
  ///
  /// Value is either <code>0</code> or android.content.pm.PackageManager\#DONT_KILL_APP
  void setComponentEnabledSetting(
          content.ComponentName componentName, int newState, int flags) =>
      _setComponentEnabledSetting(
          reference, componentName.reference, newState, flags);

  static final _getComponentEnabledSetting = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getComponentEnabledSetting")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getComponentEnabledSetting(android.content.ComponentName componentName)
  /// Return the enabled setting for a package component (activity,
  /// receiver, service, provider).  This returns the last value set by
  /// \#setComponentEnabledSetting(ComponentName, int, int); in most
  /// cases this value will be \#COMPONENT_ENABLED_STATE_DEFAULT since
  /// the value originally specified in the manifest has not been modified.
  ///@param componentName The component to retrieve.
  ///@return Returns the current enabled state for the component.
  ///
  /// Value is android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DEFAULT, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_ENABLED, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED_USER, or android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED
  int getComponentEnabledSetting(content.ComponentName componentName) =>
      _getComponentEnabledSetting(reference, componentName.reference);

  static final _setApplicationEnabledSetting = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_content_pm_PackageManager_setApplicationEnabledSetting")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void setApplicationEnabledSetting(java.lang.String packageName, int newState, int flags)
  /// Set the enabled setting for an application
  /// This setting will override any enabled state which may have been set by the application in
  /// its manifest.  It also overrides the enabled state set in the manifest for any of the
  /// application's components.  It does not override any enabled state set by
  /// \#setComponentEnabledSetting for any of the application's components.
  ///@param packageName The package name of the application to enable
  ///@param newState The new enabled state for the application.
  /// Value is android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DEFAULT, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_ENABLED, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED_USER, or android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED
  ///@param flags Optional behavior flags.
  ///
  /// Value is either <code>0</code> or android.content.pm.PackageManager\#DONT_KILL_APP
  void setApplicationEnabledSetting(
          jni.JlString packageName, int newState, int flags) =>
      _setApplicationEnabledSetting(
          reference, packageName.reference, newState, flags);

  static final _getApplicationEnabledSetting = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getApplicationEnabledSetting")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getApplicationEnabledSetting(java.lang.String packageName)
  /// Return the enabled setting for an application. This returns
  /// the last value set by
  /// \#setApplicationEnabledSetting(String, int, int); in most
  /// cases this value will be \#COMPONENT_ENABLED_STATE_DEFAULT since
  /// the value originally specified in the manifest has not been modified.
  ///@param packageName The package name of the application to retrieve.
  ///@return Returns the current enabled state for the application.
  /// Value is android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DEFAULT, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_ENABLED, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED, android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED_USER, or android.content.pm.PackageManager\#COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED
  ///@throws IllegalArgumentException if the named package does not exist.
  int getApplicationEnabledSetting(jni.JlString packageName) =>
      _getApplicationEnabledSetting(reference, packageName.reference);

  static final _isSafeMode =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PackageManager_isSafeMode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isSafeMode()
  /// Return whether the device has been booted into safe mode.
  bool isSafeMode() => _isSafeMode(reference) != 0;

  static final _isPackageSuspended =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PackageManager_isPackageSuspended")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isPackageSuspended()
  /// Apps can query this to know if they have been suspended. A system app with the permission
  /// {@code android.permission.SUSPEND_APPS} can put any app on the device into a suspended state.
  ///
  /// While in this state, the application's notifications will be hidden, any of its started
  /// activities will be stopped and it will not be able to show toasts or dialogs or ring the
  /// device. When the user tries to launch a suspended app, the system will, instead, show a
  /// dialog to the user informing them that they cannot use this app while it is suspended.
  ///
  /// When an app is put into this state, the broadcast action
  /// Intent\#ACTION_MY_PACKAGE_SUSPENDED will be delivered to any of its broadcast
  /// receivers that included this action in their intent-filters, _including manifest
  /// receivers._ Similarly, a broadcast action Intent\#ACTION_MY_PACKAGE_UNSUSPENDED
  /// is delivered when a previously suspended app is taken out of this state.
  ///
  ///
  ///@return {@code true} if the calling package has been suspended, {@code false} otherwise.
  ///@see \#getSuspendedPackageAppExtras()
  ///@see Intent\#ACTION_MY_PACKAGE_SUSPENDED
  ///@see Intent\#ACTION_MY_PACKAGE_UNSUSPENDED
  bool isPackageSuspended() => _isPackageSuspended(reference) != 0;

  static final _getSuspendedPackageAppExtras = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getSuspendedPackageAppExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getSuspendedPackageAppExtras()
  /// Returns a Bundle of extras that was meant to be sent to the calling app when it was
  /// suspended. An app with the permission {@code android.permission.SUSPEND_APPS} can supply this
  /// to the system at the time of suspending an app.
  ///
  /// This is the same Bundle that is sent along with the broadcast
  /// Intent\#ACTION_MY_PACKAGE_SUSPENDED, whenever the app is suspended. The contents of
  /// this Bundle are a contract between the suspended app and the suspending app.
  ///
  /// Note: These extras are optional, so if no extras were supplied to the system, this method
  /// will return {@code null}, even when the calling app has been suspended.
  ///@return A Bundle containing the extras for the app, or {@code null} if the
  /// package is not currently suspended.
  ///@see \#isPackageSuspended()
  ///@see Intent\#ACTION_MY_PACKAGE_UNSUSPENDED
  ///@see Intent\#ACTION_MY_PACKAGE_SUSPENDED
  ///@see Intent\#EXTRA_SUSPENDED_PACKAGE_EXTRAS
  os.Bundle getSuspendedPackageAppExtras() =>
      os.Bundle.fromRef(_getSuspendedPackageAppExtras(reference));

  static final _setApplicationCategoryHint = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_setApplicationCategoryHint")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setApplicationCategoryHint(java.lang.String packageName, int categoryHint)
  /// Provide a hint of what the ApplicationInfo\#category value should
  /// be for the given package.
  ///
  /// This hint can only be set by the app which installed this package, as
  /// determined by \#getInstallerPackageName(String).
  ///@param packageName the package to change the category hint for.
  /// This value must never be {@code null}.
  ///@param categoryHint the category hint to set.
  ///
  /// Value is android.content.pm.ApplicationInfo\#CATEGORY_UNDEFINED, android.content.pm.ApplicationInfo\#CATEGORY_GAME, android.content.pm.ApplicationInfo\#CATEGORY_AUDIO, android.content.pm.ApplicationInfo\#CATEGORY_VIDEO, android.content.pm.ApplicationInfo\#CATEGORY_IMAGE, android.content.pm.ApplicationInfo\#CATEGORY_SOCIAL, android.content.pm.ApplicationInfo\#CATEGORY_NEWS, android.content.pm.ApplicationInfo\#CATEGORY_MAPS, or android.content.pm.ApplicationInfo\#CATEGORY_PRODUCTIVITY
  void setApplicationCategoryHint(jni.JlString packageName, int categoryHint) =>
      _setApplicationCategoryHint(
          reference, packageName.reference, categoryHint);

  static final _getPackageInstaller = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager_getPackageInstaller")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.pm.PackageInstaller getPackageInstaller()
  /// Return interface that offers the ability to install, upgrade, and remove
  /// applications on the device.
  ///@return This value will never be {@code null}.
  PackageInstaller getPackageInstaller() =>
      PackageInstaller.fromRef(_getPackageInstaller(reference));

  static final _canRequestPackageInstalls =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PackageManager_canRequestPackageInstalls")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean canRequestPackageInstalls()
  /// Checks whether the calling package is allowed to request package installs through package
  /// installer. Apps are encouraged to call this API before launching the package installer via
  /// intent android.content.Intent\#ACTION_INSTALL_PACKAGE. Starting from Android O, the
  /// user can explicitly choose what external sources they trust to install apps on the device.
  /// If this API returns false, the install request will be blocked by the package installer and
  /// a dialog will be shown to the user with an option to launch settings to change their
  /// preference. An application must target Android O or higher and declare permission
  /// android.Manifest.permission\#REQUEST_INSTALL_PACKAGES in order to use this API.
  ///@return true if the calling package is trusted by the user to request install packages on
  /// the device, false otherwise.
  ///@see android.content.Intent\#ACTION_INSTALL_PACKAGE
  ///@see android.provider.Settings\#ACTION_MANAGE_UNKNOWN_APP_SOURCES
  bool canRequestPackageInstalls() =>
      _canRequestPackageInstalls(reference) != 0;

  static final _hasSigningCertificate = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32)>>(
          "android_content_pm_PackageManager_hasSigningCertificate")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean hasSigningCertificate(java.lang.String packageName, byte[] certificate, int type)
  /// Searches the set of signing certificates by which the given package has proven to have been
  /// signed.  This should be used instead of {@code getPackageInfo} with {@code GET_SIGNATURES}
  /// since it takes into account the possibility of signing certificate rotation, except in the
  /// case of packages that are signed by multiple certificates, for which signing certificate
  /// rotation is not supported.  This method is analogous to using {@code getPackageInfo} with
  /// {@code GET_SIGNING_CERTIFICATES} and then searching through the resulting {@code
  /// signingInfo} field to see if the desired certificate is present.
  ///@param packageName package whose signing certificates to check
  ///@param certificate signing certificate for which to search
  ///@param type representation of the {@code certificate}
  /// Value is android.content.pm.PackageManager\#CERT_INPUT_RAW_X509, or android.content.pm.PackageManager\#CERT_INPUT_SHA256
  ///@return true if this package was or is signed by exactly the certificate {@code certificate}
  bool hasSigningCertificate(
          jni.JlString packageName, jni.JlObject certificate, int type) =>
      _hasSigningCertificate(
          reference, packageName.reference, certificate.reference, type) !=
      0;

  static final _hasSigningCertificate_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageManager_hasSigningCertificate_1")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean hasSigningCertificate(int uid, byte[] certificate, int type)
  /// Searches the set of signing certificates by which the package(s) for the given uid has proven
  /// to have been signed.  For multiple packages sharing the same uid, this will return the
  /// signing certificates found in the signing history of the "newest" package, where "newest"
  /// indicates the package with the newest signing certificate in the shared uid group.  This
  /// method should be used instead of {@code getPackageInfo} with {@code GET_SIGNATURES}
  /// since it takes into account the possibility of signing certificate rotation, except in the
  /// case of packages that are signed by multiple certificates, for which signing certificate
  /// rotation is not supported. This method is analogous to using {@code getPackagesForUid}
  /// followed by {@code getPackageInfo} with {@code GET_SIGNING_CERTIFICATES}, selecting the
  /// {@code PackageInfo} of the newest-signed bpackage , and finally searching through the
  /// resulting {@code signingInfo} field to see if the desired certificate is there.
  ///@param uid uid whose signing certificates to check
  ///@param certificate signing certificate for which to search
  ///@param type representation of the {@code certificate}
  /// Value is android.content.pm.PackageManager\#CERT_INPUT_RAW_X509, or android.content.pm.PackageManager\#CERT_INPUT_SHA256
  ///@return true if this package was or is signed by exactly the certificate {@code certificate}
  bool hasSigningCertificate_1(int uid, jni.JlObject certificate, int type) =>
      _hasSigningCertificate_1(reference, uid, certificate.reference, type) !=
      0;
}

/// This exception is thrown when a given package, application, or component
/// name cannot be found.
class PackageManager_NameNotFoundException extends jni.JlObject {
  PackageManager_NameNotFoundException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_PackageManager__NameNotFoundException_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  PackageManager_NameNotFoundException() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageManager__NameNotFoundException_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String name)
  PackageManager_NameNotFoundException.ctor_1(jni.JlString name)
      : super.fromRef(_ctor_1(name.reference));
}

/// Offers the ability to install, upgrade, and remove applications on the
/// device. This includes support for apps packaged either as a single
/// "monolithic" APK, or apps packaged as multiple "split" APKs.
///
/// An app is delivered for installation through a
/// PackageInstaller.Session, which any app can create. Once the session
/// is created, the installer can stream one or more APKs into place until it
/// decides to either commit or destroy the session. Committing may require user
/// intervention to complete the installation.
///
/// Sessions can install brand new apps, upgrade existing apps, or add new splits
/// into an existing app.
///
/// Apps packaged as multiple split APKs always consist of a single "base" APK
/// (with a {@code null} split name) and zero or more "split" APKs (with unique
/// split names). Any subset of these APKs can be installed together, as long as
/// the following constraints are met:
/// <ul>
/// <li>All APKs must have the exact same package name, version code, and signing
/// certificates.
/// <li>All APKs must have unique split names.
/// <li>All installations must contain a single base APK.
/// </ul>
///
/// The ApiDemos project contains examples of using this API:
/// <code>ApiDemos/src/com/example/android/apis/content/InstallApk*.java</code>.
class PackageInstaller extends jni.JlObject {
  PackageInstaller.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_SESSION_COMMITTED
  /// Broadcast Action: Explicit broadcast sent to the last known default launcher when a session
  /// for a new install is committed. For managed profile, this is sent to the default launcher
  /// of the primary profile.
  ///
  /// The associated session is defined in \#EXTRA_SESSION and the user for which this
  /// session was created in Intent\#EXTRA_USER.
  static const ACTION_SESSION_COMMITTED =
      "android.content.pm.action.SESSION_COMMITTED";

  /// from: static public final java.lang.String ACTION_SESSION_DETAILS
  /// Activity Action: Show details about a particular install session. This
  /// may surface actions such as pause, resume, or cancel.
  ///
  /// This should always be scoped to the installer package that owns the
  /// session. Clients should use SessionInfo\#createDetailsIntent() to
  /// build this intent correctly.
  ///
  /// In some cases, a matching Activity may not exist, so ensure you safeguard
  /// against this.
  ///
  /// The session to show details for is defined in \#EXTRA_SESSION_ID.
  static const ACTION_SESSION_DETAILS =
      "android.content.pm.action.SESSION_DETAILS";

  /// from: static public final java.lang.String EXTRA_OTHER_PACKAGE_NAME
  /// Another package name relevant to a status. This is typically the package
  /// responsible for causing an operation failure.
  ///@see Intent\#getStringExtra(String)
  static const EXTRA_OTHER_PACKAGE_NAME =
      "android.content.pm.extra.OTHER_PACKAGE_NAME";

  /// from: static public final java.lang.String EXTRA_PACKAGE_NAME
  /// Package name that an operation is working with.
  ///@see Intent\#getStringExtra(String)
  static const EXTRA_PACKAGE_NAME = "android.content.pm.extra.PACKAGE_NAME";

  /// from: static public final java.lang.String EXTRA_SESSION
  /// SessionInfo that an operation is working with.
  ///@see Intent\#getParcelableExtra(String)
  static const EXTRA_SESSION = "android.content.pm.extra.SESSION";

  /// from: static public final java.lang.String EXTRA_SESSION_ID
  /// An integer session ID that an operation is working with.
  ///@see Intent\#getIntExtra(String, int)
  static const EXTRA_SESSION_ID = "android.content.pm.extra.SESSION_ID";

  /// from: static public final java.lang.String EXTRA_STATUS
  /// Current status of an operation. Will be one of
  /// \#STATUS_PENDING_USER_ACTION, \#STATUS_SUCCESS,
  /// \#STATUS_FAILURE, \#STATUS_FAILURE_ABORTED,
  /// \#STATUS_FAILURE_BLOCKED, \#STATUS_FAILURE_CONFLICT,
  /// \#STATUS_FAILURE_INCOMPATIBLE, \#STATUS_FAILURE_INVALID, or
  /// \#STATUS_FAILURE_STORAGE.
  ///
  /// More information about a status may be available through additional
  /// extras; see the individual status documentation for details.
  ///@see Intent\#getIntExtra(String, int)
  static const EXTRA_STATUS = "android.content.pm.extra.STATUS";

  /// from: static public final java.lang.String EXTRA_STATUS_MESSAGE
  /// Detailed string representation of the status, including raw details that
  /// are useful for debugging.
  ///@see Intent\#getStringExtra(String)
  static const EXTRA_STATUS_MESSAGE = "android.content.pm.extra.STATUS_MESSAGE";

  /// from: static public final java.lang.String EXTRA_STORAGE_PATH
  /// Storage path relevant to a status.
  ///@see Intent\#getStringExtra(String)
  static const EXTRA_STORAGE_PATH = "android.content.pm.extra.STORAGE_PATH";

  /// from: static public final int STATUS_FAILURE
  /// The operation failed in a generic way. The system will always try to
  /// provide a more specific failure reason, but in some rare cases this may
  /// be delivered.
  ///@see \#EXTRA_STATUS_MESSAGE
  static const STATUS_FAILURE = 1;

  /// from: static public final int STATUS_FAILURE_ABORTED
  /// The operation failed because it was actively aborted. For example, the
  /// user actively declined requested permissions, or the session was
  /// abandoned.
  ///@see \#EXTRA_STATUS_MESSAGE
  static const STATUS_FAILURE_ABORTED = 3;

  /// from: static public final int STATUS_FAILURE_BLOCKED
  /// The operation failed because it was blocked. For example, a device policy
  /// may be blocking the operation, a package verifier may have blocked the
  /// operation, or the app may be required for core system operation.
  ///
  /// The result may also contain \#EXTRA_OTHER_PACKAGE_NAME with the
  /// specific package blocking the install.
  ///@see \#EXTRA_STATUS_MESSAGE
  ///@see \#EXTRA_OTHER_PACKAGE_NAME
  static const STATUS_FAILURE_BLOCKED = 2;

  /// from: static public final int STATUS_FAILURE_CONFLICT
  /// The operation failed because it conflicts (or is inconsistent with) with
  /// another package already installed on the device. For example, an existing
  /// permission, incompatible certificates, etc. The user may be able to
  /// uninstall another app to fix the issue.
  ///
  /// The result may also contain \#EXTRA_OTHER_PACKAGE_NAME with the
  /// specific package identified as the cause of the conflict.
  ///@see \#EXTRA_STATUS_MESSAGE
  ///@see \#EXTRA_OTHER_PACKAGE_NAME
  static const STATUS_FAILURE_CONFLICT = 5;

  /// from: static public final int STATUS_FAILURE_INCOMPATIBLE
  /// The operation failed because it is fundamentally incompatible with this
  /// device. For example, the app may require a hardware feature that doesn't
  /// exist, it may be missing native code for the ABIs supported by the
  /// device, or it requires a newer SDK version, etc.
  ///@see \#EXTRA_STATUS_MESSAGE
  static const STATUS_FAILURE_INCOMPATIBLE = 7;

  /// from: static public final int STATUS_FAILURE_INVALID
  /// The operation failed because one or more of the APKs was invalid. For
  /// example, they might be malformed, corrupt, incorrectly signed,
  /// mismatched, etc.
  ///@see \#EXTRA_STATUS_MESSAGE
  static const STATUS_FAILURE_INVALID = 4;

  /// from: static public final int STATUS_FAILURE_STORAGE
  /// The operation failed because of storage issues. For example, the device
  /// may be running low on space, or external media may be unavailable. The
  /// user may be able to help free space or insert different external media.
  ///
  /// The result may also contain \#EXTRA_STORAGE_PATH with the path to
  /// the storage device that caused the failure.
  ///@see \#EXTRA_STATUS_MESSAGE
  ///@see \#EXTRA_STORAGE_PATH
  static const STATUS_FAILURE_STORAGE = 6;

  /// from: static public final int STATUS_PENDING_USER_ACTION
  /// User action is currently required to proceed. You can launch the intent
  /// activity described by Intent\#EXTRA_INTENT to involve the user and
  /// continue.
  ///
  /// You may choose to immediately launch the intent if the user is actively
  /// using your app. Otherwise, you should use a notification to guide the
  /// user back into your app before launching.
  ///@see Intent\#getParcelableExtra(String)
  static const STATUS_PENDING_USER_ACTION = -1;

  /// from: static public final int STATUS_SUCCESS
  /// The operation succeeded.
  static const STATUS_SUCCESS = 0;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_PackageInstaller_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  PackageInstaller() : super.fromRef(_ctor());

  static final _createSession = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller_createSession")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int createSession(android.content.pm.PackageInstaller.SessionParams params)
  /// Create a new session using the given parameters, returning a unique ID
  /// that represents the session. Once created, the session can be opened
  /// multiple times across multiple device boots.
  ///
  /// The system may automatically destroy sessions that have not been
  /// finalized (either committed or abandoned) within a reasonable period of
  /// time, typically on the order of a day.
  ///@throws IOException if parameters were unsatisfiable, such as lack of
  ///             disk space or unavailable media.
  ///@throws SecurityException when installation services are unavailable,
  ///             such as when called from a restricted user.
  ///@throws IllegalArgumentException when SessionParams is invalid.
  ///@param params This value must never be {@code null}.
  ///@return positive, non-zero unique ID that represents the created session.
  ///         This ID remains consistent across device reboots until the
  ///         session is finalized. IDs are not reused during a given boot.
  int createSession(PackageInstaller_SessionParams params) =>
      _createSession(reference, params.reference);

  static final _openSession = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageInstaller_openSession")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.pm.PackageInstaller.Session openSession(int sessionId)
  /// Open an existing session to actively perform work. To succeed, the caller
  /// must be the owner of the install session.
  ///@throws IOException if parameters were unsatisfiable, such as lack of
  ///             disk space or unavailable media.
  ///@throws SecurityException when the caller does not own the session, or
  ///             the session is invalid.
  ///@return This value will never be {@code null}.
  PackageInstaller_Session openSession(int sessionId) =>
      PackageInstaller_Session.fromRef(_openSession(reference, sessionId));

  static final _updateSessionAppIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller_updateSessionAppIcon")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void updateSessionAppIcon(int sessionId, android.graphics.Bitmap appIcon)
  /// Update the icon representing the app being installed in a specific
  /// session. This should be roughly
  /// ActivityManager\#getLauncherLargeIconSize() in both dimensions.
  ///@throws SecurityException when the caller does not own the session, or
  ///             the session is invalid.
  ///@param appIcon This value may be {@code null}.
  void updateSessionAppIcon(int sessionId, jni.JlObject appIcon) =>
      _updateSessionAppIcon(reference, sessionId, appIcon.reference);

  static final _updateSessionAppLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller_updateSessionAppLabel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void updateSessionAppLabel(int sessionId, java.lang.CharSequence appLabel)
  /// Update the label representing the app being installed in a specific
  /// session.
  ///@throws SecurityException when the caller does not own the session, or
  ///             the session is invalid.
  ///@param appLabel This value may be {@code null}.
  void updateSessionAppLabel(int sessionId, jni.JlObject appLabel) =>
      _updateSessionAppLabel(reference, sessionId, appLabel.reference);

  static final _abandonSession = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageInstaller_abandonSession")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void abandonSession(int sessionId)
  /// Completely abandon the given session, destroying all staged data and
  /// rendering it invalid. Abandoned sessions will be reported to
  /// SessionCallback listeners as failures. This is equivalent to
  /// opening the session and calling Session\#abandon().
  ///@throws SecurityException when the caller does not own the session, or
  ///             the session is invalid.
  void abandonSession(int sessionId) => _abandonSession(reference, sessionId);

  static final _getSessionInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageInstaller_getSessionInfo")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.pm.PackageInstaller.SessionInfo getSessionInfo(int sessionId)
  /// Return details for a specific session. No special permissions are
  /// required to retrieve these details.
  ///@return details for the requested session, or {@code null} if the session
  ///         does not exist.
  PackageInstaller_SessionInfo getSessionInfo(int sessionId) =>
      PackageInstaller_SessionInfo.fromRef(
          _getSessionInfo(reference, sessionId));

  static final _getAllSessions = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller_getAllSessions")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.content.pm.PackageInstaller.SessionInfo> getAllSessions()
  /// Return list of all known install sessions, regardless of the installer.
  ///@return This value will never be {@code null}.
  jni.JlObject getAllSessions() =>
      jni.JlObject.fromRef(_getAllSessions(reference));

  static final _getMySessions = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller_getMySessions")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.content.pm.PackageInstaller.SessionInfo> getMySessions()
  /// Return list of all known install sessions owned by the calling app.
  ///@return This value will never be {@code null}.
  jni.JlObject getMySessions() =>
      jni.JlObject.fromRef(_getMySessions(reference));

  static final _uninstall = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller_uninstall")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void uninstall(java.lang.String packageName, android.content.IntentSender statusReceiver)
  /// Uninstall the given package, removing it completely from the device. This
  /// method is available to:
  /// <ul>
  /// <li>the current "installer of record" for the package
  /// <li>the device owner
  /// <li>the affiliated profile owner
  /// </ul>
  ///
  /// Requires android.Manifest.permission\#DELETE_PACKAGES or android.Manifest.permission\#REQUEST_DELETE_PACKAGES
  ///@param packageName The package to uninstall.
  /// This value must never be {@code null}.
  ///@param statusReceiver Where to deliver the result.
  ///
  /// This value must never be {@code null}.
  ///@see android.app.admin.DevicePolicyManager
  void uninstall(
          jni.JlString packageName, content.IntentSender statusReceiver) =>
      _uninstall(reference, packageName.reference, statusReceiver.reference);

  static final _uninstall_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller_uninstall_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void uninstall(android.content.pm.VersionedPackage versionedPackage, android.content.IntentSender statusReceiver)
  /// Uninstall the given package with a specific version code, removing it
  /// completely from the device. If the version code of the package
  /// does not match the one passed in the versioned package argument this
  /// method is a no-op. Use PackageManager\#VERSION_CODE_HIGHEST to
  /// uninstall the latest version of the package.
  ///
  /// This method is available to:
  /// <ul>
  /// <li>the current "installer of record" for the package
  /// <li>the device owner
  /// <li>the affiliated profile owner
  /// </ul>
  ///
  /// Requires android.Manifest.permission\#DELETE_PACKAGES or android.Manifest.permission\#REQUEST_DELETE_PACKAGES
  ///@param versionedPackage The versioned package to uninstall.
  /// This value must never be {@code null}.
  ///@param statusReceiver Where to deliver the result.
  ///
  /// This value must never be {@code null}.
  ///@see android.app.admin.DevicePolicyManager
  void uninstall_1(VersionedPackage versionedPackage,
          content.IntentSender statusReceiver) =>
      _uninstall_1(
          reference, versionedPackage.reference, statusReceiver.reference);

  static final _registerSessionCallback = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller_registerSessionCallback")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerSessionCallback(android.content.pm.PackageInstaller.SessionCallback callback)
  /// Register to watch for session lifecycle events. No special permissions
  /// are required to watch for these events.
  ///@param callback This value must never be {@code null}.
  void registerSessionCallback(PackageInstaller_SessionCallback callback) =>
      _registerSessionCallback(reference, callback.reference);

  static final _registerSessionCallback_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller_registerSessionCallback_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void registerSessionCallback(android.content.pm.PackageInstaller.SessionCallback callback, android.os.Handler handler)
  /// Register to watch for session lifecycle events. No special permissions
  /// are required to watch for these events.
  ///@param handler to dispatch callback events through, otherwise uses
  ///            calling thread.
  ///
  /// This value must never be {@code null}.
  ///@param callback This value must never be {@code null}.
  void registerSessionCallback_1(
          PackageInstaller_SessionCallback callback, os.Handler handler) =>
      _registerSessionCallback_1(
          reference, callback.reference, handler.reference);

  static final _unregisterSessionCallback = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller_unregisterSessionCallback")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterSessionCallback(android.content.pm.PackageInstaller.SessionCallback callback)
  /// Unregister a previously registered callback.
  ///@param callback This value must never be {@code null}.
  void unregisterSessionCallback(PackageInstaller_SessionCallback callback) =>
      _unregisterSessionCallback(reference, callback.reference);
}

/// Parameters for creating a new PackageInstaller.Session.
class PackageInstaller_SessionParams extends jni.JlObject {
  PackageInstaller_SessionParams.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.PackageInstaller.SessionParams> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_PackageInstaller__SessionParams_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int MODE_FULL_INSTALL
  /// Mode for an install session whose staged APKs should fully replace any
  /// existing APKs for the target app.
  static const MODE_FULL_INSTALL = 1;

  /// from: static public final int MODE_INHERIT_EXISTING
  /// Mode for an install session that should inherit any existing APKs for the
  /// target app, unless they have been explicitly overridden (based on split
  /// name) by the session. For example, this can be used to add one or more
  /// split APKs to an existing installation.
  ///
  /// If there are no existing APKs for the target app, this behaves like
  /// \#MODE_FULL_INSTALL.
  static const MODE_INHERIT_EXISTING = 2;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int32)>>(
              "android_content_pm_PackageInstaller__SessionParams_new")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: public void <init>(int mode)
  /// Construct parameters for a new package install session.
  ///@param mode one of \#MODE_FULL_INSTALL or
  ///            \#MODE_INHERIT_EXISTING describing how the session
  ///            should interact with an existing app.
  PackageInstaller_SessionParams(int mode) : super.fromRef(_ctor(mode));

  static final _setInstallLocation = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageInstaller__SessionParams_setInstallLocation")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setInstallLocation(int installLocation)
  /// Provide value of PackageInfo\#installLocation, which may be used
  /// to determine where the app will be staged. Defaults to
  /// PackageInfo\#INSTALL_LOCATION_INTERNAL_ONLY.
  void setInstallLocation(int installLocation) =>
      _setInstallLocation(reference, installLocation);

  static final _setSize = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "android_content_pm_PackageInstaller__SessionParams_setSize")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setSize(long sizeBytes)
  /// Optionally indicate the total size (in bytes) of all APKs that will be
  /// delivered in this session. The system may use this to ensure enough disk
  /// space exists before proceeding, or to estimate container size for
  /// installations living on external storage.
  ///@see PackageInfo\#INSTALL_LOCATION_AUTO
  ///@see PackageInfo\#INSTALL_LOCATION_PREFER_EXTERNAL
  void setSize(int sizeBytes) => _setSize(reference, sizeBytes);

  static final _setAppPackageName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__SessionParams_setAppPackageName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setAppPackageName(java.lang.String appPackageName)
  /// Optionally set the package name of the app being installed. It's strongly
  /// recommended that you provide this value when known, so that observers can
  /// communicate installing apps to users.
  ///
  /// If the APKs staged in the session aren't consistent with this package
  /// name, the install will fail. Regardless of this value, all APKs in the
  /// app must have the same package name.
  ///@param appPackageName This value may be {@code null}.
  void setAppPackageName(jni.JlString appPackageName) =>
      _setAppPackageName(reference, appPackageName.reference);

  static final _setAppIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__SessionParams_setAppIcon")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setAppIcon(android.graphics.Bitmap appIcon)
  /// Optionally set an icon representing the app being installed. This should
  /// be roughly ActivityManager\#getLauncherLargeIconSize() in both
  /// dimensions.
  ///@param appIcon This value may be {@code null}.
  void setAppIcon(jni.JlObject appIcon) =>
      _setAppIcon(reference, appIcon.reference);

  static final _setAppLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__SessionParams_setAppLabel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setAppLabel(java.lang.CharSequence appLabel)
  /// Optionally set a label representing the app being installed.
  ///@param appLabel This value may be {@code null}.
  void setAppLabel(jni.JlObject appLabel) =>
      _setAppLabel(reference, appLabel.reference);

  static final _setOriginatingUri = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__SessionParams_setOriginatingUri")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOriginatingUri(android.net.Uri originatingUri)
  /// Optionally set the URI where this package was downloaded from. This is
  /// informational and may be used as a signal for anti-malware purposes.
  ///@see Intent\#EXTRA_ORIGINATING_URI
  ///@param originatingUri This value may be {@code null}.
  void setOriginatingUri(jni.JlObject originatingUri) =>
      _setOriginatingUri(reference, originatingUri.reference);

  static final _setOriginatingUid = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageInstaller__SessionParams_setOriginatingUid")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setOriginatingUid(int originatingUid)
  /// Sets the UID that initiated the package installation. This is informational
  /// and may be used as a signal for anti-malware purposes.
  ///@see Intent\#EXTRA_ORIGINATING_UID
  void setOriginatingUid(int originatingUid) =>
      _setOriginatingUid(reference, originatingUid);

  static final _setReferrerUri = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__SessionParams_setReferrerUri")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setReferrerUri(android.net.Uri referrerUri)
  /// Optionally set the URI that referred you to install this package. This is
  /// informational and may be used as a signal for anti-malware purposes.
  ///@see Intent\#EXTRA_REFERRER
  ///@param referrerUri This value may be {@code null}.
  void setReferrerUri(jni.JlObject referrerUri) =>
      _setReferrerUri(reference, referrerUri.reference);

  static final _setInstallReason = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageInstaller__SessionParams_setInstallReason")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setInstallReason(int installReason)
  /// Set the reason for installing this package.
  ///@param installReason Value is android.content.pm.PackageManager\#INSTALL_REASON_UNKNOWN, android.content.pm.PackageManager\#INSTALL_REASON_POLICY, android.content.pm.PackageManager\#INSTALL_REASON_DEVICE_RESTORE, android.content.pm.PackageManager\#INSTALL_REASON_DEVICE_SETUP, or android.content.pm.PackageManager\#INSTALL_REASON_USER
  void setInstallReason(int installReason) =>
      _setInstallReason(reference, installReason);

  static final _describeContents = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__SessionParams_describeContents")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageInstaller__SessionParams_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);
}

/// Details for an active install session.
class PackageInstaller_SessionInfo extends jni.JlObject {
  PackageInstaller_SessionInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.PackageInstaller.SessionInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_PackageInstaller__SessionInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_PackageInstaller__SessionInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  /// {@hide }
  PackageInstaller_SessionInfo() : super.fromRef(_ctor());

  static final _getSessionId =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PackageInstaller__SessionInfo_getSessionId")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getSessionId()
  /// Return the ID for this session.
  int getSessionId() => _getSessionId(reference);

  static final _getInstallerPackageName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__SessionInfo_getInstallerPackageName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getInstallerPackageName()
  /// Return the package name of the app that owns this session.
  ///@return This value may be {@code null}.
  jni.JlString getInstallerPackageName() =>
      jni.JlString.fromRef(_getInstallerPackageName(reference));

  static final _getProgress =
      jlookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PackageInstaller__SessionInfo_getProgress")
          .asFunction<double Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getProgress()
  /// Return current overall progress of this session, between 0 and 1.
  ///
  /// Note that this progress may not directly correspond to the value
  /// reported by
  /// PackageInstaller.Session\#setStagingProgress(float), as the
  /// system may carve out a portion of the overall progress to represent
  /// its own internal installation work.
  double getProgress() => _getProgress(reference);

  static final _isActive =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PackageInstaller__SessionInfo_isActive")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isActive()
  /// Return if this session is currently active.
  ///
  /// A session is considered active whenever there is ongoing forward
  /// progress being made, such as the installer holding an open
  /// Session instance while streaming data into place, or the
  /// system optimizing code as the result of
  /// Session\#commit(IntentSender).
  ///
  /// If the installer closes the Session without committing, the
  /// session is considered inactive until the installer opens the session
  /// again.
  bool isActive() => _isActive(reference) != 0;

  static final _isSealed =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PackageInstaller__SessionInfo_isSealed")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isSealed()
  /// Return if this session is sealed.
  ///
  /// Once sealed, no further changes may be made to the session. A session
  /// is sealed the moment Session\#commit(IntentSender) is called.
  bool isSealed() => _isSealed(reference) != 0;

  static final _getInstallReason = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__SessionInfo_getInstallReason")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getInstallReason()
  /// Return the reason for installing this package.
  ///@return The install reason.
  ///
  /// Value is android.content.pm.PackageManager\#INSTALL_REASON_UNKNOWN, android.content.pm.PackageManager\#INSTALL_REASON_POLICY, android.content.pm.PackageManager\#INSTALL_REASON_DEVICE_RESTORE, android.content.pm.PackageManager\#INSTALL_REASON_DEVICE_SETUP, or android.content.pm.PackageManager\#INSTALL_REASON_USER
  int getInstallReason() => _getInstallReason(reference);

  static final _getAppPackageName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__SessionInfo_getAppPackageName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getAppPackageName()
  /// Return the package name this session is working with. May be {@code null}
  /// if unknown.
  jni.JlString getAppPackageName() =>
      jni.JlString.fromRef(_getAppPackageName(reference));

  static final _getAppIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__SessionInfo_getAppIcon")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap getAppIcon()
  /// Return an icon representing the app being installed. May be {@code null}
  /// if unavailable.
  jni.JlObject getAppIcon() => jni.JlObject.fromRef(_getAppIcon(reference));

  static final _getAppLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__SessionInfo_getAppLabel")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getAppLabel()
  /// Return a label representing the app being installed. May be {@code null}
  /// if unavailable.
  jni.JlObject getAppLabel() => jni.JlObject.fromRef(_getAppLabel(reference));

  static final _createDetailsIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__SessionInfo_createDetailsIntent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent createDetailsIntent()
  /// Return an Intent that can be started to view details about this install
  /// session. This may surface actions such as pause, resume, or cancel.
  ///
  /// In some cases, a matching Activity may not exist, so ensure you safeguard
  /// against this.
  ///@see PackageInstaller\#ACTION_SESSION_DETAILS
  ///@return This value may be {@code null}.
  content.Intent createDetailsIntent() =>
      content.Intent.fromRef(_createDetailsIntent(reference));

  static final _getMode =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PackageInstaller__SessionInfo_getMode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getMode()
  /// Get the mode of the session as set in the constructor of the SessionParams.
  ///@return One of SessionParams\#MODE_FULL_INSTALL
  ///         or SessionParams\#MODE_INHERIT_EXISTING
  int getMode() => _getMode(reference);

  static final _getInstallLocation = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__SessionInfo_getInstallLocation")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getInstallLocation()
  /// Get the value set in SessionParams\#setInstallLocation(int).
  int getInstallLocation() => _getInstallLocation(reference);

  static final _getSize =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PackageInstaller__SessionInfo_getSize")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getSize()
  /// Get the value as set in SessionParams\#setSize(long).
  ///
  /// The value is a hint and does not have to match the actual size.
  int getSize() => _getSize(reference);

  static final _getOriginatingUri = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__SessionInfo_getOriginatingUri")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri getOriginatingUri()
  /// Get the value set in SessionParams\#setOriginatingUri(Uri).
  ///@return This value may be {@code null}.
  jni.JlObject getOriginatingUri() =>
      jni.JlObject.fromRef(_getOriginatingUri(reference));

  static final _getOriginatingUid = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__SessionInfo_getOriginatingUid")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getOriginatingUid()
  /// Get the value set in SessionParams\#setOriginatingUid(int).
  int getOriginatingUid() => _getOriginatingUid(reference);

  static final _getReferrerUri = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__SessionInfo_getReferrerUri")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri getReferrerUri()
  /// Get the value set in SessionParams\#setReferrerUri(Uri)
  ///@return This value may be {@code null}.
  jni.JlObject getReferrerUri() =>
      jni.JlObject.fromRef(_getReferrerUri(reference));

  static final _describeContents = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__SessionInfo_describeContents")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageInstaller__SessionInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);
}

/// Events for observing session lifecycle.
///
/// A typical session lifecycle looks like this:
/// <ul>
/// <li>An installer creates a session to indicate pending app delivery. All
/// install details are available at this point.
/// <li>The installer opens the session to deliver APK data. Note that a
/// session may be opened and closed multiple times as network connectivity
/// changes. The installer may deliver periodic progress updates.
/// <li>The installer commits or abandons the session, resulting in the
/// session being finished.
/// </ul>
class PackageInstaller_SessionCallback extends jni.JlObject {
  PackageInstaller_SessionCallback.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_PackageInstaller__SessionCallback_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  PackageInstaller_SessionCallback() : super.fromRef(_ctor());

  static final _onCreated = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageInstaller__SessionCallback_onCreated")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void onCreated(int sessionId)
  /// New session has been created. Details about the session can be
  /// obtained from PackageInstaller\#getSessionInfo(int).
  void onCreated(int sessionId) => _onCreated(reference, sessionId);

  static final _onBadgingChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_PackageInstaller__SessionCallback_onBadgingChanged")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void onBadgingChanged(int sessionId)
  /// Badging details for an existing session has changed. For example, the
  /// app icon or label has been updated.
  void onBadgingChanged(int sessionId) =>
      _onBadgingChanged(reference, sessionId);

  static final _onActiveChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Uint8)>>(
          "android_content_pm_PackageInstaller__SessionCallback_onActiveChanged")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void onActiveChanged(int sessionId, boolean active)
  /// Active state for session has been changed.
  ///
  /// A session is considered active whenever there is ongoing forward
  /// progress being made, such as the installer holding an open
  /// Session instance while streaming data into place, or the
  /// system optimizing code as the result of
  /// Session\#commit(IntentSender).
  ///
  /// If the installer closes the Session without committing, the
  /// session is considered inactive until the installer opens the session
  /// again.
  void onActiveChanged(int sessionId, bool active) =>
      _onActiveChanged(reference, sessionId, active ? 1 : 0);

  static final _onProgressChanged = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Float)>>(
          "android_content_pm_PackageInstaller__SessionCallback_onProgressChanged")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, double)>();

  /// from: public abstract void onProgressChanged(int sessionId, float progress)
  /// Progress for given session has been updated.
  ///
  /// Note that this progress may not directly correspond to the value
  /// reported by
  /// PackageInstaller.Session\#setStagingProgress(float), as the
  /// system may carve out a portion of the overall progress to represent
  /// its own internal installation work.
  void onProgressChanged(int sessionId, double progress) =>
      _onProgressChanged(reference, sessionId, progress);

  static final _onFinished = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Uint8)>>(
          "android_content_pm_PackageInstaller__SessionCallback_onFinished")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void onFinished(int sessionId, boolean success)
  /// Session has completely finished, either with success or failure.
  void onFinished(int sessionId, bool success) =>
      _onFinished(reference, sessionId, success ? 1 : 0);
}

/// An installation that is being actively staged. For an install to succeed,
/// all existing and new packages must have identical package names, version
/// codes, and signing certificates.
///
/// A session may contain any number of split packages. If the application
/// does not yet exist, this session must include a base package.
///
/// If an APK included in this session is already defined by the existing
/// installation (for example, the same split name), the APK in this session
/// will replace the existing APK.
class PackageInstaller_Session extends jni.JlObject {
  PackageInstaller_Session.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_PackageInstaller__Session_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  PackageInstaller_Session() : super.fromRef(_ctor());

  static final _setStagingProgress = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>>(
          "android_content_pm_PackageInstaller__Session_setStagingProgress")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setStagingProgress(float progress)
  /// Set current progress of staging this session. Valid values are
  /// anywhere between 0 and 1.
  ///
  /// Note that this progress may not directly correspond to the value
  /// reported by SessionCallback\#onProgressChanged(int, float), as
  /// the system may carve out a portion of the overall progress to
  /// represent its own internal installation work.
  void setStagingProgress(double progress) =>
      _setStagingProgress(reference, progress);

  static final _openWrite = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int64, ffi.Int64)>>(
          "android_content_pm_PackageInstaller__Session_openWrite")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public java.io.OutputStream openWrite(java.lang.String name, long offsetBytes, long lengthBytes)
  /// Open a stream to write an APK file into the session.
  ///
  /// The returned stream will start writing data at the requested offset
  /// in the underlying file, which can be used to resume a partially
  /// written file. If a valid file length is specified, the system will
  /// preallocate the underlying disk space to optimize placement on disk.
  /// It's strongly recommended to provide a valid file length when known.
  ///
  /// You can write data into the returned stream, optionally call
  /// \#fsync(OutputStream) as needed to ensure bytes have been
  /// persisted to disk, and then close when finished. All streams must be
  /// closed before calling \#commit(IntentSender).
  ///@param name arbitrary, unique name of your choosing to identify the
  ///            APK being written. You can open a file again for
  ///            additional writes (such as after a reboot) by using the
  ///            same name. This name is only meaningful within the context
  ///            of a single install session.
  /// This value must never be {@code null}.
  ///@param offsetBytes offset into the file to begin writing at, or 0 to
  ///            start at the beginning of the file.
  ///@param lengthBytes total size of the file being written, used to
  ///            preallocate the underlying disk space, or -1 if unknown.
  ///            The system may clear various caches as needed to allocate
  ///            this space.
  ///@throws IOException if trouble opening the file for writing, such as
  ///             lack of disk space or unavailable media.
  ///@throws SecurityException if called after the session has been
  ///             sealed or abandoned
  ///@return This value will never be {@code null}.
  jni.JlObject openWrite(jni.JlString name, int offsetBytes, int lengthBytes) =>
      jni.JlObject.fromRef(
          _openWrite(reference, name.reference, offsetBytes, lengthBytes));

  static final _fsync = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__Session_fsync")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void fsync(java.io.OutputStream out)
  /// Ensure that any outstanding data for given stream has been committed
  /// to disk. This is only valid for streams returned from
  /// \#openWrite(String, long, long).
  ///@param out This value must never be {@code null}.
  void fsync(jni.JlObject out) => _fsync(reference, out.reference);

  static final _getNames = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__Session_getNames")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getNames()
  /// Return all APK names contained in this session.
  ///
  /// This returns all names which have been previously written through
  /// \#openWrite(String, long, long) as part of this session.
  ///@throws SecurityException if called after the session has been
  ///             committed or abandoned.
  ///@return This value will never be {@code null}.
  jni.JlObject getNames() => jni.JlObject.fromRef(_getNames(reference));

  static final _openRead = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__Session_openRead")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.InputStream openRead(java.lang.String name)
  /// Open a stream to read an APK file from the session.
  ///
  /// This is only valid for names which have been previously written
  /// through \#openWrite(String, long, long) as part of this
  /// session. For example, this stream may be used to calculate a
  /// MessageDigest of a written APK before committing.
  ///@throws SecurityException if called after the session has been
  ///             committed or abandoned.
  ///@param name This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  jni.JlObject openRead(jni.JlString name) =>
      jni.JlObject.fromRef(_openRead(reference, name.reference));

  static final _removeSplit = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__Session_removeSplit")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void removeSplit(java.lang.String splitName)
  /// Removes a split.
  ///
  /// Split removals occur prior to adding new APKs. If upgrading a feature
  /// split, it is not expected nor desirable to remove the split prior to
  /// upgrading.
  ///
  /// When split removal is bundled with new APKs, the packageName must be
  /// identical.
  ///@param splitName This value must never be {@code null}.
  void removeSplit(jni.JlString splitName) =>
      _removeSplit(reference, splitName.reference);

  static final _commit = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__Session_commit")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void commit(android.content.IntentSender statusReceiver)
  /// Attempt to commit everything staged in this session. This may require
  /// user intervention, and so it may not happen immediately. The final
  /// result of the commit will be reported through the given callback.
  ///
  /// Once this method is called, the session is sealed and no additional
  /// mutations may be performed on the session. If the device reboots
  /// before the session has been finalized, you may commit the session again.
  ///
  /// If the installer is the device owner or the affiliated profile owner, there will be no
  /// user intervention.
  ///@throws SecurityException if streams opened through
  ///             \#openWrite(String, long, long) are still open.
  ///@see android.app.admin.DevicePolicyManager
  ///@param statusReceiver This value must never be {@code null}.
  void commit(content.IntentSender statusReceiver) =>
      _commit(reference, statusReceiver.reference);

  static final _transfer = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInstaller__Session_transfer")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void transfer(java.lang.String packageName)
  /// Transfer the session to a new owner.
  ///
  /// Only sessions that update the installing app can be transferred.
  ///
  /// After the transfer to a package with a different uid all method calls on the session
  /// will cause SecurityExceptions.
  ///
  /// Once this method is called, the session is sealed and no additional mutations beside
  /// committing it may be performed on the session.
  ///@param packageName The package of the new owner. Needs to hold the INSTALL_PACKAGES
  ///                    permission.
  ///
  /// This value must never be {@code null}.
  ///@throws PackageManager.NameNotFoundException if the new owner could not be found.
  ///@throws SecurityException if called after the session has been committed or abandoned.
  ///@throws SecurityException if the session does not update the original installer
  ///@throws SecurityException if streams opened through
  ///                           \#openWrite(String, long, long) are still open.
  void transfer(jni.JlString packageName) =>
      _transfer(reference, packageName.reference);

  static final _close =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PackageInstaller__Session_close")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void close()
  /// Release this session object. You can open the session again if it
  /// hasn't been finalized.
  void close() => _close(reference);

  static final _abandon =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PackageInstaller__Session_abandon")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void abandon()
  /// Completely abandon this session, destroying all staged data and
  /// rendering it invalid. Abandoned sessions will be reported to
  /// SessionCallback listeners as failures. This is equivalent to
  /// opening the session and calling Session\#abandon().
  void abandon() => _abandon(reference);
}

/// Overall information about the contents of a package.  This corresponds
/// to all of the information collected from AndroidManifest.xml.
class PackageInfo extends jni.JlObject {
  PackageInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.PackageInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_PackageInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int INSTALL_LOCATION_AUTO
  /// Constant corresponding to <code>auto</code> in the
  /// android.R.attr\#installLocation attribute.
  static const INSTALL_LOCATION_AUTO = 0;

  /// from: static public final int INSTALL_LOCATION_INTERNAL_ONLY
  /// Constant corresponding to <code>internalOnly</code> in the
  /// android.R.attr\#installLocation attribute.
  static const INSTALL_LOCATION_INTERNAL_ONLY = 1;

  /// from: static public final int INSTALL_LOCATION_PREFER_EXTERNAL
  /// Constant corresponding to <code>preferExternal</code> in the
  /// android.R.attr\#installLocation attribute.
  static const INSTALL_LOCATION_PREFER_EXTERNAL = 2;

  /// from: static public final int REQUESTED_PERMISSION_GRANTED
  /// Flag for \#requestedPermissionsFlags: the requested permission
  /// is currently granted to the application.
  static const REQUESTED_PERMISSION_GRANTED = 2;

  /// from: public android.content.pm.ActivityInfo[] activities
  /// Array of all android.R.styleable\#AndroidManifestActivity &lt;activity&gt; tags included under &lt;application&gt;,
  /// or null if there were none.  This is only filled in if the flag
  /// PackageManager\#GET_ACTIVITIES was set.
  static final _getactivities = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_activities")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get activities =>
      jni.JlObject.fromRef(_getactivities(reference));
  static final _setactivities = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_activities")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set activities(jni.JlObject value) =>
      _setactivities(reference, value.reference);

  /// from: public android.content.pm.ApplicationInfo applicationInfo
  /// Information collected from the &lt;application&gt; tag, or null if
  /// there was none.
  static final _getapplicationInfo = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_applicationInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  ApplicationInfo get applicationInfo =>
      ApplicationInfo.fromRef(_getapplicationInfo(reference));
  static final _setapplicationInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_applicationInfo")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set applicationInfo(ApplicationInfo value) =>
      _setapplicationInfo(reference, value.reference);

  /// from: public int baseRevisionCode
  /// The revision number of the base APK for this package, as specified by the
  /// &lt;manifest&gt; tag's
  /// android.R.styleable\#AndroidManifest_revisionCode revisionCode
  /// attribute.
  static final _getbaseRevisionCode = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_baseRevisionCode")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get baseRevisionCode => _getbaseRevisionCode(reference);
  static final _setbaseRevisionCode = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_PackageInfo_baseRevisionCode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set baseRevisionCode(int value) => _setbaseRevisionCode(reference, value);

  /// from: public android.content.pm.ConfigurationInfo[] configPreferences
  /// Application specified preferred configuration
  /// android.R.styleable\#AndroidManifestUsesConfiguration &lt;uses-configuration&gt; tags included under &lt;manifest&gt;,
  /// or null if there were none. This is only filled in if the flag
  /// PackageManager\#GET_CONFIGURATIONS was set.
  static final _getconfigPreferences = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_configPreferences")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get configPreferences =>
      jni.JlObject.fromRef(_getconfigPreferences(reference));
  static final _setconfigPreferences = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_configPreferences")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set configPreferences(jni.JlObject value) =>
      _setconfigPreferences(reference, value.reference);

  /// from: public android.content.pm.FeatureGroupInfo[] featureGroups
  /// Groups of features that this application has requested.
  /// Each group contains a set of features that are required.
  /// A device must match the features listed in \#reqFeatures and one
  /// or more FeatureGroups in order to have satisfied the feature requirement.
  ///@see FeatureInfo\#FLAG_REQUIRED
  static final _getfeatureGroups = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_featureGroups")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get featureGroups =>
      jni.JlObject.fromRef(_getfeatureGroups(reference));
  static final _setfeatureGroups = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_featureGroups")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set featureGroups(jni.JlObject value) =>
      _setfeatureGroups(reference, value.reference);

  /// from: public long firstInstallTime
  /// The time at which the app was first installed.  Units are as
  /// per System\#currentTimeMillis().
  static final _getfirstInstallTime = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_firstInstallTime")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get firstInstallTime => _getfirstInstallTime(reference);
  static final _setfirstInstallTime = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_content_pm_PackageInfo_firstInstallTime")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set firstInstallTime(int value) => _setfirstInstallTime(reference, value);

  /// from: public int[] gids
  /// All kernel group-IDs that have been assigned to this package.
  /// This is only filled in if the flag PackageManager\#GET_GIDS was set.
  static final _getgids = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_gids")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get gids => jni.JlObject.fromRef(_getgids(reference));
  static final _setgids = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_gids")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set gids(jni.JlObject value) => _setgids(reference, value.reference);

  /// from: public int installLocation
  /// The install location requested by the package. From the
  /// android.R.attr\#installLocation attribute, one of
  /// \#INSTALL_LOCATION_AUTO, \#INSTALL_LOCATION_INTERNAL_ONLY,
  /// \#INSTALL_LOCATION_PREFER_EXTERNAL
  static final _getinstallLocation = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_installLocation")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get installLocation => _getinstallLocation(reference);
  static final _setinstallLocation = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_PackageInfo_installLocation")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set installLocation(int value) => _setinstallLocation(reference, value);

  /// from: public android.content.pm.InstrumentationInfo[] instrumentation
  /// Array of all android.R.styleable\#AndroidManifestInstrumentation &lt;instrumentation&gt; tags included under &lt;manifest&gt;,
  /// or null if there were none.  This is only filled in if the flag
  /// PackageManager\#GET_INSTRUMENTATION was set.
  static final _getinstrumentation = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_instrumentation")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get instrumentation =>
      jni.JlObject.fromRef(_getinstrumentation(reference));
  static final _setinstrumentation = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_instrumentation")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set instrumentation(jni.JlObject value) =>
      _setinstrumentation(reference, value.reference);

  /// from: public long lastUpdateTime
  /// The time at which the app was last updated.  Units are as
  /// per System\#currentTimeMillis().
  static final _getlastUpdateTime = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_lastUpdateTime")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get lastUpdateTime => _getlastUpdateTime(reference);
  static final _setlastUpdateTime = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_content_pm_PackageInfo_lastUpdateTime")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set lastUpdateTime(int value) => _setlastUpdateTime(reference, value);

  /// from: public java.lang.String packageName
  /// The name of this package.  From the &lt;manifest&gt; tag's "name"
  /// attribute.
  static final _getpackageName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_packageName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get packageName =>
      jni.JlString.fromRef(_getpackageName(reference));
  static final _setpackageName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_packageName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set packageName(jni.JlString value) =>
      _setpackageName(reference, value.reference);

  /// from: public android.content.pm.PermissionInfo[] permissions
  /// Array of all android.R.styleable\#AndroidManifestPermission &lt;permission&gt; tags included under &lt;manifest&gt;,
  /// or null if there were none.  This is only filled in if the flag
  /// PackageManager\#GET_PERMISSIONS was set.
  static final _getpermissions = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_permissions")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get permissions =>
      jni.JlObject.fromRef(_getpermissions(reference));
  static final _setpermissions = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_permissions")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set permissions(jni.JlObject value) =>
      _setpermissions(reference, value.reference);

  /// from: public android.content.pm.ProviderInfo[] providers
  /// Array of all android.R.styleable\#AndroidManifestProvider &lt;provider&gt; tags included under &lt;application&gt;,
  /// or null if there were none.  This is only filled in if the flag
  /// PackageManager\#GET_PROVIDERS was set.
  static final _getproviders = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_providers")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get providers => jni.JlObject.fromRef(_getproviders(reference));
  static final _setproviders = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_providers")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set providers(jni.JlObject value) =>
      _setproviders(reference, value.reference);

  /// from: public android.content.pm.ActivityInfo[] receivers
  /// Array of all android.R.styleable\#AndroidManifestReceiver &lt;receiver&gt; tags included under &lt;application&gt;,
  /// or null if there were none.  This is only filled in if the flag
  /// PackageManager\#GET_RECEIVERS was set.
  static final _getreceivers = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_receivers")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get receivers => jni.JlObject.fromRef(_getreceivers(reference));
  static final _setreceivers = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_receivers")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set receivers(jni.JlObject value) =>
      _setreceivers(reference, value.reference);

  /// from: public android.content.pm.FeatureInfo[] reqFeatures
  /// Features that this application has requested.
  ///@see FeatureInfo\#FLAG_REQUIRED
  static final _getreqFeatures = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_reqFeatures")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get reqFeatures =>
      jni.JlObject.fromRef(_getreqFeatures(reference));
  static final _setreqFeatures = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_reqFeatures")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set reqFeatures(jni.JlObject value) =>
      _setreqFeatures(reference, value.reference);

  /// from: public java.lang.String[] requestedPermissions
  /// Array of all android.R.styleable\#AndroidManifestUsesPermission &lt;uses-permission&gt; tags included under &lt;manifest&gt;,
  /// or null if there were none.  This is only filled in if the flag
  /// PackageManager\#GET_PERMISSIONS was set.  This list includes
  /// all permissions requested, even those that were not granted or known
  /// by the system at install time.
  static final _getrequestedPermissions = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_requestedPermissions")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get requestedPermissions =>
      jni.JlObject.fromRef(_getrequestedPermissions(reference));
  static final _setrequestedPermissions = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_requestedPermissions")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set requestedPermissions(jni.JlObject value) =>
      _setrequestedPermissions(reference, value.reference);

  /// from: public int[] requestedPermissionsFlags
  /// Array of flags of all android.R.styleable\#AndroidManifestUsesPermission &lt;uses-permission&gt; tags included under &lt;manifest&gt;,
  /// or null if there were none.  This is only filled in if the flag
  /// PackageManager\#GET_PERMISSIONS was set.  Each value matches
  /// the corresponding entry in \#requestedPermissions, and will have
  /// the flag \#REQUESTED_PERMISSION_GRANTED set as appropriate.
  static final _getrequestedPermissionsFlags = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_requestedPermissionsFlags")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get requestedPermissionsFlags =>
      jni.JlObject.fromRef(_getrequestedPermissionsFlags(reference));
  static final _setrequestedPermissionsFlags = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_requestedPermissionsFlags")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set requestedPermissionsFlags(jni.JlObject value) =>
      _setrequestedPermissionsFlags(reference, value.reference);

  /// from: public android.content.pm.ServiceInfo[] services
  /// Array of all android.R.styleable\#AndroidManifestService &lt;service&gt; tags included under &lt;application&gt;,
  /// or null if there were none.  This is only filled in if the flag
  /// PackageManager\#GET_SERVICES was set.
  static final _getservices = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_services")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get services => jni.JlObject.fromRef(_getservices(reference));
  static final _setservices = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_services")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set services(jni.JlObject value) => _setservices(reference, value.reference);

  /// from: public java.lang.String sharedUserId
  /// The shared user ID name of this package, as specified by the &lt;manifest&gt;
  /// tag's android.R.styleable\#AndroidManifest_sharedUserId sharedUserId
  /// attribute.
  static final _getsharedUserId = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_sharedUserId")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get sharedUserId =>
      jni.JlString.fromRef(_getsharedUserId(reference));
  static final _setsharedUserId = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_sharedUserId")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set sharedUserId(jni.JlString value) =>
      _setsharedUserId(reference, value.reference);

  /// from: public int sharedUserLabel
  /// The shared user ID label of this package, as specified by the &lt;manifest&gt;
  /// tag's android.R.styleable\#AndroidManifest_sharedUserLabel sharedUserLabel
  /// attribute.
  static final _getsharedUserLabel = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_sharedUserLabel")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get sharedUserLabel => _getsharedUserLabel(reference);
  static final _setsharedUserLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_PackageInfo_sharedUserLabel")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set sharedUserLabel(int value) => _setsharedUserLabel(reference, value);

  /// from: public android.content.pm.Signature[] signatures
  /// Array of all signatures read from the package file. This is only filled
  /// in if the flag PackageManager\#GET_SIGNATURES was set. A package
  /// must be singed with at least one certificate which is at position zero.
  /// The package can be signed with additional certificates which appear as
  /// subsequent entries.
  ///
  /// <strong>Note:</strong> Signature ordering is not guaranteed to be
  /// stable which means that a package signed with certificates A and B is
  /// equivalent to being signed with certificates B and A. This means that
  /// in case multiple signatures are reported you cannot assume the one at
  /// the first position to be the same across updates.
  ///
  /// <strong>Deprecated</strong> This has been replaced by the
  /// PackageInfo\#signingInfo field, which takes into
  /// account signing certificate rotation.  For backwards compatibility in
  /// the event of signing certificate rotation, this will return the oldest
  /// reported signing certificate, so that an application will appear to
  /// callers as though no rotation occurred.
  ///@deprecated use {@code signingInfo} instead
  static final _getsignatures = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_signatures")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get signatures =>
      jni.JlObject.fromRef(_getsignatures(reference));
  static final _setsignatures = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_signatures")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set signatures(jni.JlObject value) =>
      _setsignatures(reference, value.reference);

  /// from: public android.content.pm.SigningInfo signingInfo
  /// Signing information read from the package file, potentially
  /// including past signing certificates no longer used after signing
  /// certificate rotation.  This is only filled in if
  /// the flag PackageManager\#GET_SIGNING_CERTIFICATES was set.
  ///
  /// Use this field instead of the deprecated {@code signatures} field.
  /// See SigningInfo for more information on its contents.
  static final _getsigningInfo = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_signingInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  SigningInfo get signingInfo =>
      SigningInfo.fromRef(_getsigningInfo(reference));
  static final _setsigningInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_signingInfo")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set signingInfo(SigningInfo value) =>
      _setsigningInfo(reference, value.reference);

  /// from: public java.lang.String[] splitNames
  /// The names of any installed split APKs for this package.
  static final _getsplitNames = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_splitNames")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get splitNames =>
      jni.JlObject.fromRef(_getsplitNames(reference));
  static final _setsplitNames = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_splitNames")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set splitNames(jni.JlObject value) =>
      _setsplitNames(reference, value.reference);

  /// from: public int[] splitRevisionCodes
  /// The revision number of any split APKs for this package, as specified by
  /// the &lt;manifest&gt; tag's
  /// android.R.styleable\#AndroidManifest_revisionCode revisionCode
  /// attribute. Indexes are a 1:1 mapping against \#splitNames.
  static final _getsplitRevisionCodes = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_splitRevisionCodes")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get splitRevisionCodes =>
      jni.JlObject.fromRef(_getsplitRevisionCodes(reference));
  static final _setsplitRevisionCodes = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_splitRevisionCodes")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set splitRevisionCodes(jni.JlObject value) =>
      _setsplitRevisionCodes(reference, value.reference);

  /// from: public int versionCode
  /// @deprecated Use \#getLongVersionCode() instead, which includes both
  /// this and the additional
  /// android.R.styleable\#AndroidManifest_versionCodeMajor versionCodeMajor attribute.
  /// The version number of this package, as specified by the &lt;manifest&gt;
  /// tag's android.R.styleable\#AndroidManifest_versionCode versionCode
  /// attribute.
  ///@see \#getLongVersionCode()
  static final _getversionCode = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_versionCode")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get versionCode => _getversionCode(reference);
  static final _setversionCode = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_PackageInfo_versionCode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set versionCode(int value) => _setversionCode(reference, value);

  /// from: public java.lang.String versionName
  /// The version name of this package, as specified by the &lt;manifest&gt;
  /// tag's android.R.styleable\#AndroidManifest_versionName versionName
  /// attribute.
  static final _getversionName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageInfo_versionName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get versionName =>
      jni.JlString.fromRef(_getversionName(reference));
  static final _setversionName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageInfo_versionName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set versionName(jni.JlString value) =>
      _setversionName(reference, value.reference);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_PackageInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  PackageInfo() : super.fromRef(_ctor());

  static final _getLongVersionCode =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PackageInfo_getLongVersionCode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getLongVersionCode()
  /// Return android.R.styleable\#AndroidManifest_versionCode versionCode and
  /// android.R.styleable\#AndroidManifest_versionCodeMajor versionCodeMajor combined
  /// together as a single long value.  The
  /// android.R.styleable\#AndroidManifest_versionCodeMajor versionCodeMajor is placed in
  /// the upper 32 bits.
  int getLongVersionCode() => _getLongVersionCode(reference);

  static final _setLongVersionCode = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "android_content_pm_PackageInfo_setLongVersionCode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setLongVersionCode(long longVersionCode)
  /// Set the full version code in this PackageInfo, updating \#versionCode
  /// with the lower bits.
  ///@see \#getLongVersionCode()
  void setLongVersionCode(int longVersionCode) =>
      _setLongVersionCode(reference, longVersionCode);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageInfo_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PackageInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_pm_PackageInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(os.Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags);
}

/// implementation of PackageStats associated with a application package.
///@deprecated this class is an orphan that could never be obtained from a valid
///             public API. If you need package storage statistics use the new
///             StorageStatsManager APIs.
class PackageStats extends jni.JlObject {
  PackageStats.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.PackageStats> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_PackageStats_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: public long cacheSize
  /// Size of cache used by the application. (e.g., /data/data/<app>/cache)
  static final _getcacheSize = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageStats_cacheSize")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get cacheSize => _getcacheSize(reference);
  static final _setcacheSize = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("set_android_content_pm_PackageStats_cacheSize")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set cacheSize(int value) => _setcacheSize(reference, value);

  /// from: public long codeSize
  /// Size of the code (e.g., APK)
  static final _getcodeSize = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageStats_codeSize")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get codeSize => _getcodeSize(reference);
  static final _setcodeSize = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("set_android_content_pm_PackageStats_codeSize")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set codeSize(int value) => _setcodeSize(reference, value);

  /// from: public long dataSize
  /// Size of the internal data size for the application. (e.g.,
  /// /data/data/<app>)
  static final _getdataSize = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageStats_dataSize")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get dataSize => _getdataSize(reference);
  static final _setdataSize = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("set_android_content_pm_PackageStats_dataSize")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set dataSize(int value) => _setdataSize(reference, value);

  /// from: public long externalCacheSize
  /// Size of the external cache used by the application (i.e., on the SD
  /// card). If this is a subdirectory of the data directory, this size will be
  /// subtracted out of the external data size.
  static final _getexternalCacheSize = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageStats_externalCacheSize")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get externalCacheSize => _getexternalCacheSize(reference);
  static final _setexternalCacheSize = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_content_pm_PackageStats_externalCacheSize")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set externalCacheSize(int value) => _setexternalCacheSize(reference, value);

  /// from: public long externalCodeSize
  /// Size of the secure container on external storage holding the
  /// application's code.
  static final _getexternalCodeSize = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageStats_externalCodeSize")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get externalCodeSize => _getexternalCodeSize(reference);
  static final _setexternalCodeSize = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_content_pm_PackageStats_externalCodeSize")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set externalCodeSize(int value) => _setexternalCodeSize(reference, value);

  /// from: public long externalDataSize
  /// Size of the external data used by the application (e.g.,
  /// <sdcard>/Android/data/<app>)
  static final _getexternalDataSize = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageStats_externalDataSize")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get externalDataSize => _getexternalDataSize(reference);
  static final _setexternalDataSize = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_content_pm_PackageStats_externalDataSize")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set externalDataSize(int value) => _setexternalDataSize(reference, value);

  /// from: public long externalMediaSize
  /// Size of the external media size used by the application.
  static final _getexternalMediaSize = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageStats_externalMediaSize")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get externalMediaSize => _getexternalMediaSize(reference);
  static final _setexternalMediaSize = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_content_pm_PackageStats_externalMediaSize")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set externalMediaSize(int value) => _setexternalMediaSize(reference, value);

  /// from: public long externalObbSize
  /// Size of the package's OBBs placed on external media.
  static final _getexternalObbSize = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageStats_externalObbSize")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get externalObbSize => _getexternalObbSize(reference);
  static final _setexternalObbSize = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_content_pm_PackageStats_externalObbSize")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set externalObbSize(int value) => _setexternalObbSize(reference, value);

  /// from: public java.lang.String packageName
  /// Name of the package to which this stats applies.
  static final _getpackageName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_PackageStats_packageName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get packageName =>
      jni.JlString.fromRef(_getpackageName(reference));
  static final _setpackageName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_PackageStats_packageName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set packageName(jni.JlString value) =>
      _setpackageName(reference, value.reference);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageStats_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String pkgName)
  PackageStats(jni.JlString pkgName) : super.fromRef(_ctor(pkgName.reference));

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageStats_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel source)
  PackageStats.ctor_1(os.Parcel source)
      : super.fromRef(_ctor_1(source.reference));

  static final _ctor_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageStats_new_2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.pm.PackageStats pStats)
  PackageStats.ctor_2(PackageStats pStats)
      : super.fromRef(_ctor_2(pStats.reference));

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageStats_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PackageStats_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_pm_PackageStats_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(os.Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags);

  static final _equals_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_PackageStats_equals_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object obj)
  bool equals_1(jni.JlObject obj) => _equals_1(reference, obj.reference) != 0;

  static final _hashCode_1 =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_PackageStats_hashCode_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode_1() => _hashCode_1(reference);
}

/// Packages that have been changed since the last time they
/// were requested.
///@see PackageManager\#getChangedPackages(int)
class ChangedPackages extends jni.JlObject {
  ChangedPackages.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.ChangedPackages> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_ChangedPackages_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ChangedPackages_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int sequenceNumber, java.util.List<java.lang.String> packageNames)
  /// @param packageNames This value must never be {@code null}.
  ChangedPackages(int sequenceNumber, jni.JlObject packageNames)
      : super.fromRef(_ctor(sequenceNumber, packageNames.reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ChangedPackages_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_ChangedPackages_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _getSequenceNumber =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ChangedPackages_getSequenceNumber")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getSequenceNumber()
  /// Returns the last known sequence number for these changes.
  int getSequenceNumber() => _getSequenceNumber(reference);

  static final _getPackageNames = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ChangedPackages_getPackageNames")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<java.lang.String> getPackageNames()
  /// Returns the names of the packages that have changed.
  ///@return This value will never be {@code null}.
  jni.JlObject getPackageNames() =>
      jni.JlObject.fromRef(_getPackageNames(reference));
}

/// Opaque, immutable representation of a signing certificate associated with an
/// application package.
///
/// This class name is slightly misleading, since it's not actually a signature.
class Signature extends jni.JlObject {
  Signature.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.Signature> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_Signature_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_pm_Signature_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(byte[] signature)
  /// Create Signature from an existing raw byte array.
  Signature(jni.JlObject signature) : super.fromRef(_ctor(signature.reference));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_pm_Signature_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String text)
  /// Create Signature from a text representation previously returned by
  /// \#toChars or \#toCharsString(). Signatures are expected to
  /// be a hex-encoded ASCII string.
  ///@param text hex-encoded string representing the signature
  ///@throws IllegalArgumentException when signature is odd-length
  Signature.ctor_1(jni.JlString text) : super.fromRef(_ctor_1(text.reference));

  static final _toChars = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_Signature_toChars")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public char[] toChars()
  /// Encode the Signature as ASCII text.
  jni.JlObject toChars() => jni.JlObject.fromRef(_toChars(reference));

  static final _toChars_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_Signature_toChars_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public char[] toChars(char[] existingArray, int[] outLen)
  /// Encode the Signature as ASCII text in to an existing array.
  ///@param existingArray Existing char array or null.
  ///@param outLen Output parameter for the number of characters written in
  /// to the array.
  ///@return Returns either <var>existingArray</var> if it was large enough
  /// to hold the ASCII representation, or a newly created char[] array if
  /// needed.
  jni.JlObject toChars_1(jni.JlObject existingArray, jni.JlObject outLen) =>
      jni.JlObject.fromRef(
          _toChars_1(reference, existingArray.reference, outLen.reference));

  static final _toCharsString = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_Signature_toCharsString")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toCharsString()
  /// Return the result of \#toChars() as a String.
  jni.JlString toCharsString() =>
      jni.JlString.fromRef(_toCharsString(reference));

  static final _toByteArray = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_Signature_toByteArray")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public byte[] toByteArray()
  /// @return the contents of this signature as a byte array.
  jni.JlObject toByteArray() => jni.JlObject.fromRef(_toByteArray(reference));

  static final _equals_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_Signature_equals_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object obj)
  bool equals_1(jni.JlObject obj) => _equals_1(reference, obj.reference) != 0;

  static final _hashCode_1 =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_Signature_hashCode_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode_1() => _hashCode_1(reference);

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_Signature_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_pm_Signature_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(os.Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags);
}

/// Information you can retrieve about a particular application.  This
/// corresponds to information collected from the AndroidManifest.xml's
/// &lt;application&gt; tag.
class ApplicationInfo extends PackageItemInfo {
  ApplicationInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int CATEGORY_AUDIO
  /// Category for apps which primarily work with audio or music, such as music
  /// players.
  ///@see \#category
  static const CATEGORY_AUDIO = 1;

  /// from: static public final int CATEGORY_GAME
  /// Category for apps which are primarily games.
  ///@see \#category
  static const CATEGORY_GAME = 0;

  /// from: static public final int CATEGORY_IMAGE
  /// Category for apps which primarily work with images or photos, such as
  /// camera or gallery apps.
  ///@see \#category
  static const CATEGORY_IMAGE = 3;

  /// from: static public final int CATEGORY_MAPS
  /// Category for apps which are primarily maps apps, such as navigation apps.
  ///@see \#category
  static const CATEGORY_MAPS = 6;

  /// from: static public final int CATEGORY_NEWS
  /// Category for apps which are primarily news apps, such as newspapers,
  /// magazines, or sports apps.
  ///@see \#category
  static const CATEGORY_NEWS = 5;

  /// from: static public final int CATEGORY_PRODUCTIVITY
  /// Category for apps which are primarily productivity apps, such as cloud
  /// storage or workplace apps.
  ///@see \#category
  static const CATEGORY_PRODUCTIVITY = 7;

  /// from: static public final int CATEGORY_SOCIAL
  /// Category for apps which are primarily social apps, such as messaging,
  /// communication, email, or social network apps.
  ///@see \#category
  static const CATEGORY_SOCIAL = 4;

  /// from: static public final int CATEGORY_UNDEFINED
  /// Value when category is undefined.
  ///@see \#category
  static const CATEGORY_UNDEFINED = -1;

  /// from: static public final int CATEGORY_VIDEO
  /// Category for apps which primarily work with video or movies, such as
  /// streaming video apps.
  ///@see \#category
  static const CATEGORY_VIDEO = 2;

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.ApplicationInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_ApplicationInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int FLAG_ALLOW_BACKUP
  /// Value for \#flags: set to <code>false</code> if the application does not wish
  /// to permit any OS-driven backups of its data; <code>true</code> otherwise.
  ///
  /// Comes from the
  /// android.R.styleable\#AndroidManifestApplication_allowBackup android:allowBackup
  /// attribute of the &lt;application&gt; tag.
  static const FLAG_ALLOW_BACKUP = 32768;

  /// from: static public final int FLAG_ALLOW_CLEAR_USER_DATA
  /// Value for \#flags: default value for the corresponding ActivityInfo flag.
  /// Comes from android.R.styleable\#AndroidManifestApplication_allowClearUserData android:allowClearUserData of the &lt;application&gt; tag.
  static const FLAG_ALLOW_CLEAR_USER_DATA = 64;

  /// from: static public final int FLAG_ALLOW_TASK_REPARENTING
  /// Value for \#flags: default value for the corresponding ActivityInfo flag.
  /// Comes from android.R.styleable\#AndroidManifestApplication_allowTaskReparenting android:allowTaskReparenting of the &lt;application&gt; tag.
  static const FLAG_ALLOW_TASK_REPARENTING = 32;

  /// from: static public final int FLAG_DEBUGGABLE
  /// Value for \#flags: set to true if this application would like to
  /// allow debugging of its
  /// code, even when installed on a non-development system.  Comes
  /// from android.R.styleable\#AndroidManifestApplication_debuggable android:debuggable of the &lt;application&gt; tag.
  static const FLAG_DEBUGGABLE = 2;

  /// from: static public final int FLAG_EXTERNAL_STORAGE
  /// Value for \#flags: Set to true if the application is
  /// currently installed on external/removable/unprotected storage.  Such
  /// applications may not be available if their storage is not currently
  /// mounted.  When the storage it is on is not available, it will look like
  /// the application has been uninstalled (its .apk is no longer available)
  /// but its persistent data is not removed.
  static const FLAG_EXTERNAL_STORAGE = 262144;

  /// from: static public final int FLAG_EXTRACT_NATIVE_LIBS
  /// When set installer extracts native libs from .apk files.
  static const FLAG_EXTRACT_NATIVE_LIBS = 268435456;

  /// from: static public final int FLAG_FACTORY_TEST
  /// Value for \#flags: set to true if this application holds the
  /// android.Manifest.permission\#FACTORY_TEST permission and the
  /// device is running in factory test mode.
  static const FLAG_FACTORY_TEST = 16;

  /// from: static public final int FLAG_FULL_BACKUP_ONLY
  /// Value for \#flags: {@code true} if the application asks that only
  /// full-data streaming backups of its data be performed even though it defines
  /// a android.app.backup.BackupAgent BackupAgent, which normally
  /// indicates that the app will manage its backed-up data via incremental
  /// key/value updates.
  static const FLAG_FULL_BACKUP_ONLY = 67108864;

  /// from: static public final int FLAG_HARDWARE_ACCELERATED
  /// Value for \#flags: {@code true} when the application's rendering
  /// should be hardware accelerated.
  static const FLAG_HARDWARE_ACCELERATED = 536870912;

  /// from: static public final int FLAG_HAS_CODE
  /// Value for \#flags: set to true if this application has code
  /// associated with it.  Comes
  /// from android.R.styleable\#AndroidManifestApplication_hasCode android:hasCode of the &lt;application&gt; tag.
  static const FLAG_HAS_CODE = 4;

  /// from: static public final int FLAG_INSTALLED
  /// Value for \#flags: true if the application is currently
  /// installed for the calling user.
  static const FLAG_INSTALLED = 8388608;

  /// from: static public final int FLAG_IS_DATA_ONLY
  /// Value for \#flags: true if the application only has its
  /// data installed; the application package itself does not currently
  /// exist on the device.
  static const FLAG_IS_DATA_ONLY = 16777216;

  /// from: static public final int FLAG_IS_GAME
  /// Value for \#flags: true if the application was declared to be a
  /// game, or false if it is a non-game application.
  ///@deprecated use \#CATEGORY_GAME instead.
  static const FLAG_IS_GAME = 33554432;

  /// from: static public final int FLAG_KILL_AFTER_RESTORE
  /// Value for \#flags: set to <code>false</code> if the application must be kept
  /// in memory following a full-system restore operation; <code>true</code> otherwise.
  /// Ordinarily, during a full system restore operation each application is shut down
  /// following execution of its agent's onRestore() method.  Setting this attribute to
  /// <code>false</code> prevents this.  Most applications will not need to set this attribute.
  ///
  /// If
  /// android.R.styleable\#AndroidManifestApplication_allowBackup android:allowBackup
  /// is set to <code>false</code> or no
  /// android.R.styleable\#AndroidManifestApplication_backupAgent android:backupAgent
  /// is specified, this flag will be ignored.
  ///
  /// Comes from the
  /// android.R.styleable\#AndroidManifestApplication_killAfterRestore android:killAfterRestore
  /// attribute of the &lt;application&gt; tag.
  static const FLAG_KILL_AFTER_RESTORE = 65536;

  /// from: static public final int FLAG_LARGE_HEAP
  /// Value for \#flags: true when the application has requested a
  /// large heap for its processes.  Corresponds to
  /// android.R.styleable\#AndroidManifestApplication_largeHeap android:largeHeap.
  static const FLAG_LARGE_HEAP = 1048576;

  /// from: static public final int FLAG_MULTIARCH
  /// Value for \#flags: true if code from this application will need to be
  /// loaded into other applications' processes. On devices that support multiple
  /// instruction sets, this implies the code might be loaded into a process that's
  /// using any of the devices supported instruction sets.
  ///
  ///  The system might treat such applications specially, for eg., by
  /// extracting the application's native libraries for all supported instruction
  /// sets or by compiling the application's dex code for all supported instruction
  /// sets.
  static const FLAG_MULTIARCH = -2147483648;

  /// from: static public final int FLAG_PERSISTENT
  /// Value for \#flags: set to true if this application is persistent.
  /// Comes from android.R.styleable\#AndroidManifestApplication_persistent android:persistent of the &lt;application&gt; tag.
  static const FLAG_PERSISTENT = 8;

  /// from: static public final int FLAG_RESIZEABLE_FOR_SCREENS
  /// Value for \#flags: true when the application knows how to adjust
  /// its UI for different screen sizes.  Corresponds to
  /// android.R.styleable\#AndroidManifestSupportsScreens_resizeable android:resizeable.
  static const FLAG_RESIZEABLE_FOR_SCREENS = 4096;

  /// from: static public final int FLAG_RESTORE_ANY_VERSION
  /// Value for \#flags: Set to <code>true</code> if the application's backup
  /// agent claims to be able to handle restore data even "from the future,"
  /// i.e. from versions of the application with a versionCode greater than
  /// the one currently installed on the device.  <i>Use with caution!</i>  By default
  /// this attribute is <code>false</code> and the Backup Manager will ensure that data
  /// from "future" versions of the application are never supplied during a restore operation.
  ///
  /// If
  /// android.R.styleable\#AndroidManifestApplication_allowBackup android:allowBackup
  /// is set to <code>false</code> or no
  /// android.R.styleable\#AndroidManifestApplication_backupAgent android:backupAgent
  /// is specified, this flag will be ignored.
  ///
  /// Comes from the
  /// android.R.styleable\#AndroidManifestApplication_restoreAnyVersion android:restoreAnyVersion
  /// attribute of the &lt;application&gt; tag.
  static const FLAG_RESTORE_ANY_VERSION = 131072;

  /// from: static public final int FLAG_STOPPED
  /// Value for \#flags: true if this application's package is in
  /// the stopped state.
  static const FLAG_STOPPED = 2097152;

  /// from: static public final int FLAG_SUPPORTS_LARGE_SCREENS
  /// Value for \#flags: true when the application's window can be
  /// increased in size for larger screens.  Corresponds to
  /// android.R.styleable\#AndroidManifestSupportsScreens_largeScreens android:largeScreens.
  static const FLAG_SUPPORTS_LARGE_SCREENS = 2048;

  /// from: static public final int FLAG_SUPPORTS_NORMAL_SCREENS
  /// Value for \#flags: true when the application's window can be
  /// displayed on normal screens.  Corresponds to
  /// android.R.styleable\#AndroidManifestSupportsScreens_normalScreens android:normalScreens.
  static const FLAG_SUPPORTS_NORMAL_SCREENS = 1024;

  /// from: static public final int FLAG_SUPPORTS_RTL
  /// Value for \#flags: true  when the application is willing to support
  /// RTL (right to left). All activities will inherit this value.
  ///
  /// Set from the android.R.attr\#supportsRtl attribute in the
  /// activity's manifest.
  ///
  /// Default value is false (no support for RTL).
  static const FLAG_SUPPORTS_RTL = 4194304;

  /// from: static public final int FLAG_SUPPORTS_SCREEN_DENSITIES
  /// Value for \#flags: true when the application knows how to
  /// accomodate different screen densities.  Corresponds to
  /// android.R.styleable\#AndroidManifestSupportsScreens_anyDensity android:anyDensity.
  static const FLAG_SUPPORTS_SCREEN_DENSITIES = 8192;

  /// from: static public final int FLAG_SUPPORTS_SMALL_SCREENS
  /// Value for \#flags: true when the application's window can be
  /// reduced in size for smaller screens.  Corresponds to
  /// android.R.styleable\#AndroidManifestSupportsScreens_smallScreens android:smallScreens.
  static const FLAG_SUPPORTS_SMALL_SCREENS = 512;

  /// from: static public final int FLAG_SUPPORTS_XLARGE_SCREENS
  /// Value for \#flags: true when the application's window can be
  /// increased in size for extra large screens.  Corresponds to
  /// android.R.styleable\#AndroidManifestSupportsScreens_xlargeScreens android:xlargeScreens.
  static const FLAG_SUPPORTS_XLARGE_SCREENS = 524288;

  /// from: static public final int FLAG_SUSPENDED
  /// Value for \#flags: true if this application's package is in
  /// the suspended state.
  static const FLAG_SUSPENDED = 1073741824;

  /// from: static public final int FLAG_SYSTEM
  /// Value for \#flags: if set, this application is installed in the
  /// device's system image.
  static const FLAG_SYSTEM = 1;

  /// from: static public final int FLAG_TEST_ONLY
  /// Value for \#flags: this is set if the application has specified
  /// android.R.styleable\#AndroidManifestApplication_testOnly android:testOnly to be true.
  static const FLAG_TEST_ONLY = 256;

  /// from: static public final int FLAG_UPDATED_SYSTEM_APP
  /// Value for \#flags: this is set if this application has been
  /// installed as an update to a built-in system application.
  static const FLAG_UPDATED_SYSTEM_APP = 128;

  /// from: static public final int FLAG_USES_CLEARTEXT_TRAFFIC
  /// Value for \#flags: {@code true} if the application may use cleartext network traffic
  /// (e.g., HTTP rather than HTTPS; WebSockets rather than WebSockets Secure; XMPP, IMAP, STMP
  /// without STARTTLS or TLS). If {@code false}, the app declares that it does not intend to use
  /// cleartext network traffic, in which case platform components (e.g., HTTP stacks,
  /// {@code DownloadManager}, {@code MediaPlayer}) will refuse app's requests to use cleartext
  /// traffic. Third-party libraries are encouraged to honor this flag as well.
  ///
  /// NOTE: {@code WebView} honors this flag for applications targeting API level 26 and up.
  ///
  /// This flag is ignored on Android N and above if an Android Network Security Config is
  /// present.
  ///
  /// This flag comes from
  /// android.R.styleable\#AndroidManifestApplication_usesCleartextTraffic android:usesCleartextTraffic of the &lt;application&gt; tag.
  static const FLAG_USES_CLEARTEXT_TRAFFIC = 134217728;

  /// from: static public final int FLAG_VM_SAFE_MODE
  /// Value for \#flags: set to true if this application would like to
  /// request the VM to operate under the safe mode. Comes from
  /// android.R.styleable\#AndroidManifestApplication_vmSafeMode android:vmSafeMode of the &lt;application&gt; tag.
  static const FLAG_VM_SAFE_MODE = 16384;

  /// from: public java.lang.String appComponentFactory
  /// The factory of this package, as specified by the &lt;manifest&gt;
  /// tag's android.R.styleable\#AndroidManifestApplication_appComponentFactory
  /// attribute.
  static final _getappComponentFactory = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_appComponentFactory")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get appComponentFactory =>
      jni.JlString.fromRef(_getappComponentFactory(reference));
  static final _setappComponentFactory = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ApplicationInfo_appComponentFactory")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set appComponentFactory(jni.JlString value) =>
      _setappComponentFactory(reference, value.reference);

  /// from: public java.lang.String backupAgentName
  /// Class implementing the Application's backup functionality.  From
  /// the "backupAgent" attribute.  This is an optional attribute and
  /// will be null if the application does not specify it in its manifest.
  ///
  /// If android:allowBackup is set to false, this attribute is ignored.
  static final _getbackupAgentName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_backupAgentName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get backupAgentName =>
      jni.JlString.fromRef(_getbackupAgentName(reference));
  static final _setbackupAgentName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ApplicationInfo_backupAgentName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set backupAgentName(jni.JlString value) =>
      _setbackupAgentName(reference, value.reference);

  /// from: public int category
  /// The category of this app. Categories are used to cluster multiple apps
  /// together into meaningful groups, such as when summarizing battery,
  /// network, or disk usage. Apps should only define this value when they fit
  /// well into one of the specific categories.
  ///
  /// Set from the android.R.attr\#appCategory attribute in the
  /// manifest. If the manifest doesn't define a category, this value may have
  /// been provided by the installer via
  /// PackageManager\#setApplicationCategoryHint(String, int).
  ///
  /// Value is android.content.pm.ApplicationInfo\#CATEGORY_UNDEFINED, android.content.pm.ApplicationInfo\#CATEGORY_GAME, android.content.pm.ApplicationInfo\#CATEGORY_AUDIO, android.content.pm.ApplicationInfo\#CATEGORY_VIDEO, android.content.pm.ApplicationInfo\#CATEGORY_IMAGE, android.content.pm.ApplicationInfo\#CATEGORY_SOCIAL, android.content.pm.ApplicationInfo\#CATEGORY_NEWS, android.content.pm.ApplicationInfo\#CATEGORY_MAPS, or android.content.pm.ApplicationInfo\#CATEGORY_PRODUCTIVITY
  static final _getcategory = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_category")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get category => _getcategory(reference);
  static final _setcategory = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ApplicationInfo_category")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set category(int value) => _setcategory(reference, value);

  /// from: public java.lang.String className
  /// Class implementing the Application object.  From the "class"
  /// attribute.
  static final _getclassName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_className")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get className => jni.JlString.fromRef(_getclassName(reference));
  static final _setclassName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ApplicationInfo_className")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set className(jni.JlString value) =>
      _setclassName(reference, value.reference);

  /// from: public int compatibleWidthLimitDp
  /// The maximum smallest screen width the application is designed for.  If 0,
  /// nothing has been specified.  Comes from
  /// android.R.styleable\#AndroidManifestSupportsScreens_compatibleWidthLimitDp android:compatibleWidthLimitDp attribute of the &lt;supports-screens&gt; tag.
  static final _getcompatibleWidthLimitDp = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_compatibleWidthLimitDp")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get compatibleWidthLimitDp => _getcompatibleWidthLimitDp(reference);
  static final _setcompatibleWidthLimitDp = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ApplicationInfo_compatibleWidthLimitDp")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set compatibleWidthLimitDp(int value) =>
      _setcompatibleWidthLimitDp(reference, value);

  /// from: public java.lang.String dataDir
  /// Full path to the default directory assigned to the package for its
  /// persistent data.
  static final _getdataDir = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_dataDir")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get dataDir => jni.JlString.fromRef(_getdataDir(reference));
  static final _setdataDir = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ApplicationInfo_dataDir")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set dataDir(jni.JlString value) => _setdataDir(reference, value.reference);

  /// from: public int descriptionRes
  /// A style resource identifier (in the package's resources) of the
  /// description of an application.  From the "description" attribute
  /// or, if not set, 0.
  static final _getdescriptionRes = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_descriptionRes")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get descriptionRes => _getdescriptionRes(reference);
  static final _setdescriptionRes = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ApplicationInfo_descriptionRes")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set descriptionRes(int value) => _setdescriptionRes(reference, value);

  /// from: public java.lang.String deviceProtectedDataDir
  /// Full path to the device-protected directory assigned to the package for
  /// its persistent data.
  ///@see Context\#createDeviceProtectedStorageContext()
  static final _getdeviceProtectedDataDir = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_deviceProtectedDataDir")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get deviceProtectedDataDir =>
      jni.JlString.fromRef(_getdeviceProtectedDataDir(reference));
  static final _setdeviceProtectedDataDir = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ApplicationInfo_deviceProtectedDataDir")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set deviceProtectedDataDir(jni.JlString value) =>
      _setdeviceProtectedDataDir(reference, value.reference);

  /// from: public boolean enabled
  /// When false, indicates that all components within this application are
  /// considered disabled, regardless of their individually set enabled status.
  static final _getenabled = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_enabled")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  bool get enabled => _getenabled(reference) != 0;
  static final _setenabled = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("set_android_content_pm_ApplicationInfo_enabled")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set enabled(bool value) => _setenabled(reference, value ? 1 : 0);

  /// from: public int flags
  /// Flags associated with the application.  Any combination of
  /// \#FLAG_SYSTEM, \#FLAG_DEBUGGABLE, \#FLAG_HAS_CODE,
  /// \#FLAG_PERSISTENT, \#FLAG_FACTORY_TEST, and
  /// \#FLAG_ALLOW_TASK_REPARENTING
  /// \#FLAG_ALLOW_CLEAR_USER_DATA, \#FLAG_UPDATED_SYSTEM_APP,
  /// \#FLAG_TEST_ONLY, \#FLAG_SUPPORTS_SMALL_SCREENS,
  /// \#FLAG_SUPPORTS_NORMAL_SCREENS,
  /// \#FLAG_SUPPORTS_LARGE_SCREENS, \#FLAG_SUPPORTS_XLARGE_SCREENS,
  /// \#FLAG_RESIZEABLE_FOR_SCREENS,
  /// \#FLAG_SUPPORTS_SCREEN_DENSITIES, \#FLAG_VM_SAFE_MODE,
  /// \#FLAG_ALLOW_BACKUP, \#FLAG_KILL_AFTER_RESTORE,
  /// \#FLAG_RESTORE_ANY_VERSION, \#FLAG_EXTERNAL_STORAGE,
  /// \#FLAG_LARGE_HEAP, \#FLAG_STOPPED,
  /// \#FLAG_SUPPORTS_RTL, \#FLAG_INSTALLED,
  /// \#FLAG_IS_DATA_ONLY, \#FLAG_IS_GAME,
  /// \#FLAG_FULL_BACKUP_ONLY, \#FLAG_USES_CLEARTEXT_TRAFFIC,
  /// \#FLAG_MULTIARCH.
  static final _getflags = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_flags")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get flags => _getflags(reference);
  static final _setflags = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_ApplicationInfo_flags")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set flags(int value) => _setflags(reference, value);

  /// from: public int largestWidthLimitDp
  /// The maximum smallest screen width the application will work on.  If 0,
  /// nothing has been specified.  Comes from
  /// android.R.styleable\#AndroidManifestSupportsScreens_largestWidthLimitDp android:largestWidthLimitDp attribute of the &lt;supports-screens&gt; tag.
  static final _getlargestWidthLimitDp = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_largestWidthLimitDp")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get largestWidthLimitDp => _getlargestWidthLimitDp(reference);
  static final _setlargestWidthLimitDp = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ApplicationInfo_largestWidthLimitDp")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set largestWidthLimitDp(int value) =>
      _setlargestWidthLimitDp(reference, value);

  /// from: public java.lang.String manageSpaceActivityName
  /// Class implementing the Application's manage space
  /// functionality.  From the "manageSpaceActivity"
  /// attribute. This is an optional attribute and will be null if
  /// applications don't specify it in their manifest
  static final _getmanageSpaceActivityName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_manageSpaceActivityName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get manageSpaceActivityName =>
      jni.JlString.fromRef(_getmanageSpaceActivityName(reference));
  static final _setmanageSpaceActivityName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ApplicationInfo_manageSpaceActivityName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set manageSpaceActivityName(jni.JlString value) =>
      _setmanageSpaceActivityName(reference, value.reference);

  /// from: public int minSdkVersion
  /// The minimum SDK version this application can run on. It will not run
  /// on earlier versions.
  static final _getminSdkVersion = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_minSdkVersion")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get minSdkVersion => _getminSdkVersion(reference);
  static final _setminSdkVersion = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ApplicationInfo_minSdkVersion")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set minSdkVersion(int value) => _setminSdkVersion(reference, value);

  /// from: public java.lang.String nativeLibraryDir
  /// Full path to the directory where native JNI libraries are stored.
  static final _getnativeLibraryDir = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_nativeLibraryDir")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get nativeLibraryDir =>
      jni.JlString.fromRef(_getnativeLibraryDir(reference));
  static final _setnativeLibraryDir = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ApplicationInfo_nativeLibraryDir")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set nativeLibraryDir(jni.JlString value) =>
      _setnativeLibraryDir(reference, value.reference);

  /// from: public java.lang.String permission
  /// Optional name of a permission required to be able to access this
  /// application's components.  From the "permission" attribute.
  static final _getpermission = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_permission")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get permission =>
      jni.JlString.fromRef(_getpermission(reference));
  static final _setpermission = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ApplicationInfo_permission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set permission(jni.JlString value) =>
      _setpermission(reference, value.reference);

  /// from: public java.lang.String processName
  /// The name of the process this application should run in.  From the
  /// "process" attribute or, if not set, the same as
  /// <var>packageName</var>.
  static final _getprocessName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_processName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get processName =>
      jni.JlString.fromRef(_getprocessName(reference));
  static final _setprocessName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ApplicationInfo_processName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set processName(jni.JlString value) =>
      _setprocessName(reference, value.reference);

  /// from: public java.lang.String publicSourceDir
  /// Full path to the publicly available parts of \#sourceDir,
  /// including resources and manifest. This may be different from
  /// \#sourceDir if an application is forward locked.
  static final _getpublicSourceDir = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_publicSourceDir")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get publicSourceDir =>
      jni.JlString.fromRef(_getpublicSourceDir(reference));
  static final _setpublicSourceDir = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ApplicationInfo_publicSourceDir")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set publicSourceDir(jni.JlString value) =>
      _setpublicSourceDir(reference, value.reference);

  /// from: public int requiresSmallestWidthDp
  /// The required smallest screen width the application can run on.  If 0,
  /// nothing has been specified.  Comes from
  /// android.R.styleable\#AndroidManifestSupportsScreens_requiresSmallestWidthDp android:requiresSmallestWidthDp attribute of the &lt;supports-screens&gt; tag.
  static final _getrequiresSmallestWidthDp = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_requiresSmallestWidthDp")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get requiresSmallestWidthDp => _getrequiresSmallestWidthDp(reference);
  static final _setrequiresSmallestWidthDp = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ApplicationInfo_requiresSmallestWidthDp")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set requiresSmallestWidthDp(int value) =>
      _setrequiresSmallestWidthDp(reference, value);

  /// from: public java.lang.String[] sharedLibraryFiles
  /// Paths to all shared libraries this application is linked against.  This
  /// field is only set if the PackageManager\#GET_SHARED_LIBRARY_FILES PackageManager.GET_SHARED_LIBRARY_FILES flag was used when retrieving
  /// the structure.
  static final _getsharedLibraryFiles = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_sharedLibraryFiles")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get sharedLibraryFiles =>
      jni.JlObject.fromRef(_getsharedLibraryFiles(reference));
  static final _setsharedLibraryFiles = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ApplicationInfo_sharedLibraryFiles")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set sharedLibraryFiles(jni.JlObject value) =>
      _setsharedLibraryFiles(reference, value.reference);

  /// from: public java.lang.String sourceDir
  /// Full path to the base APK for this application.
  static final _getsourceDir = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_sourceDir")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get sourceDir => jni.JlString.fromRef(_getsourceDir(reference));
  static final _setsourceDir = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ApplicationInfo_sourceDir")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set sourceDir(jni.JlString value) =>
      _setsourceDir(reference, value.reference);

  /// from: public java.lang.String[] splitNames
  /// The names of all installed split APKs, ordered lexicographically.
  static final _getsplitNames = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_splitNames")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get splitNames =>
      jni.JlObject.fromRef(_getsplitNames(reference));
  static final _setsplitNames = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ApplicationInfo_splitNames")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set splitNames(jni.JlObject value) =>
      _setsplitNames(reference, value.reference);

  /// from: public java.lang.String[] splitPublicSourceDirs
  /// Full path to the publicly available parts of \#splitSourceDirs,
  /// including resources and manifest. This may be different from
  /// \#splitSourceDirs if an application is forward locked.
  ///@see \#splitSourceDirs
  static final _getsplitPublicSourceDirs = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_splitPublicSourceDirs")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get splitPublicSourceDirs =>
      jni.JlObject.fromRef(_getsplitPublicSourceDirs(reference));
  static final _setsplitPublicSourceDirs = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ApplicationInfo_splitPublicSourceDirs")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set splitPublicSourceDirs(jni.JlObject value) =>
      _setsplitPublicSourceDirs(reference, value.reference);

  /// from: public java.lang.String[] splitSourceDirs
  /// Full paths to zero or more split APKs, indexed by the same order as \#splitNames.
  static final _getsplitSourceDirs = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_splitSourceDirs")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get splitSourceDirs =>
      jni.JlObject.fromRef(_getsplitSourceDirs(reference));
  static final _setsplitSourceDirs = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ApplicationInfo_splitSourceDirs")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set splitSourceDirs(jni.JlObject value) =>
      _setsplitSourceDirs(reference, value.reference);

  /// from: public java.util.UUID storageUuid
  /// UUID of the storage volume on which this application is being hosted. For
  /// apps hosted on the default internal storage at
  /// Environment\#getDataDirectory(), the UUID value is
  /// StorageManager\#UUID_DEFAULT.
  static final _getstorageUuid = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_storageUuid")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get storageUuid =>
      jni.JlObject.fromRef(_getstorageUuid(reference));
  static final _setstorageUuid = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ApplicationInfo_storageUuid")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set storageUuid(jni.JlObject value) =>
      _setstorageUuid(reference, value.reference);

  /// from: public int targetSdkVersion
  /// The minimum SDK version this application targets.  It may run on earlier
  /// versions, but it knows how to work with any new behavior added at this
  /// version.  Will be android.os.Build.VERSION_CODES\#CUR_DEVELOPMENT
  /// if this is a development build and the app is targeting that.  You should
  /// compare that this number is >= the SDK version number at which your
  /// behavior was introduced.
  static final _gettargetSdkVersion = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_targetSdkVersion")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get targetSdkVersion => _gettargetSdkVersion(reference);
  static final _settargetSdkVersion = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ApplicationInfo_targetSdkVersion")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set targetSdkVersion(int value) => _settargetSdkVersion(reference, value);

  /// from: public java.lang.String taskAffinity
  /// Default task affinity of all activities in this application. See
  /// ActivityInfo\#taskAffinity for more information.  This comes
  /// from the "taskAffinity" attribute.
  static final _gettaskAffinity = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_taskAffinity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get taskAffinity =>
      jni.JlString.fromRef(_gettaskAffinity(reference));
  static final _settaskAffinity = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_ApplicationInfo_taskAffinity")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set taskAffinity(jni.JlString value) =>
      _settaskAffinity(reference, value.reference);

  /// from: public int theme
  /// A style resource identifier (in the package's resources) of the
  /// default visual theme of the application.  From the "theme" attribute
  /// or, if not set, 0.
  static final _gettheme = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_theme")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get theme => _gettheme(reference);
  static final _settheme = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_ApplicationInfo_theme")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set theme(int value) => _settheme(reference, value);

  /// from: public int uiOptions
  /// The default extra UI options for activities in this application.
  /// Set from the android.R.attr\#uiOptions attribute in the
  /// activity's manifest.
  static final _getuiOptions = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_uiOptions")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get uiOptions => _getuiOptions(reference);
  static final _setuiOptions = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_pm_ApplicationInfo_uiOptions")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set uiOptions(int value) => _setuiOptions(reference, value);

  /// from: public int uid
  /// The kernel user-ID that has been assigned to this application;
  /// currently this is not a unique ID (multiple applications can have
  /// the same uid).
  static final _getuid = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_ApplicationInfo_uid")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get uid => _getuid(reference);
  static final _setuid = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_pm_ApplicationInfo_uid")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set uid(int value) => _setuid(reference, value);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_ApplicationInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ApplicationInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ApplicationInfo_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.pm.ApplicationInfo orig)
  ApplicationInfo.ctor_1(ApplicationInfo orig)
      : super.fromRef(_ctor_1(orig.reference));

  static final _getCategoryTitle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_ApplicationInfo_getCategoryTitle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: static public java.lang.CharSequence getCategoryTitle(android.content.Context context, int category)
  /// Return a concise, localized title for the given
  /// ApplicationInfo\#category value, or {@code null} for unknown
  /// values such as \#CATEGORY_UNDEFINED.
  ///@see \#category
  ///@param category Value is android.content.pm.ApplicationInfo\#CATEGORY_UNDEFINED, android.content.pm.ApplicationInfo\#CATEGORY_GAME, android.content.pm.ApplicationInfo\#CATEGORY_AUDIO, android.content.pm.ApplicationInfo\#CATEGORY_VIDEO, android.content.pm.ApplicationInfo\#CATEGORY_IMAGE, android.content.pm.ApplicationInfo\#CATEGORY_SOCIAL, android.content.pm.ApplicationInfo\#CATEGORY_NEWS, android.content.pm.ApplicationInfo\#CATEGORY_MAPS, or android.content.pm.ApplicationInfo\#CATEGORY_PRODUCTIVITY
  static jni.JlObject getCategoryTitle(content.Context context, int category) =>
      jni.JlObject.fromRef(_getCategoryTitle(context.reference, category));

  static final _dump = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ApplicationInfo_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  void dump(jni.JlObject pw, jni.JlString prefix) =>
      _dump(reference, pw.reference, prefix.reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ApplicationInfo_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ApplicationInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_ApplicationInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(os.Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags);

  static final _loadDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ApplicationInfo_loadDescription")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence loadDescription(android.content.pm.PackageManager pm)
  /// Retrieve the textual description of the application.  This
  /// will call back on the given PackageManager to load the description from
  /// the application.
  ///@param pm A PackageManager from which the label can be loaded; usually
  /// the PackageManager from which you originally retrieved this item.
  ///@return Returns a CharSequence containing the application's description.
  /// If there is no description, null is returned.
  jni.JlObject loadDescription(PackageManager pm) =>
      jni.JlObject.fromRef(_loadDescription(reference, pm.reference));

  static final _isVirtualPreload =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ApplicationInfo_isVirtualPreload")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isVirtualPreload()
  /// Returns whether or not this application was installed as a virtual preload.
  bool isVirtualPreload() => _isVirtualPreload(reference) != 0;
}

class ApplicationInfo_DisplayNameComparator extends jni.JlObject {
  ApplicationInfo_DisplayNameComparator.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ApplicationInfo__DisplayNameComparator_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.pm.PackageManager pm)
  ApplicationInfo_DisplayNameComparator(PackageManager pm)
      : super.fromRef(_ctor(pm.reference));

  static final _compare = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ApplicationInfo__DisplayNameComparator_compare")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final int compare(android.content.pm.ApplicationInfo aa, android.content.pm.ApplicationInfo ab)
  int compare(ApplicationInfo aa, ApplicationInfo ab) =>
      _compare(reference, aa.reference, ab.reference);
}

/// Information you can retrieve about a particular piece of test
/// instrumentation.  This corresponds to information collected
/// from the AndroidManifest.xml's &lt;instrumentation&gt; tag.
class InstrumentationInfo extends PackageItemInfo {
  InstrumentationInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.pm.InstrumentationInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_pm_InstrumentationInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: public java.lang.String dataDir
  /// Full path to a directory assigned to the package for its persistent data.
  static final _getdataDir = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_InstrumentationInfo_dataDir")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get dataDir => jni.JlString.fromRef(_getdataDir(reference));
  static final _setdataDir = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_InstrumentationInfo_dataDir")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set dataDir(jni.JlString value) => _setdataDir(reference, value.reference);

  /// from: public boolean functionalTest
  /// Specifies whether or not to run this instrumentation as a functional test
  static final _getfunctionalTest = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_InstrumentationInfo_functionalTest")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  bool get functionalTest => _getfunctionalTest(reference) != 0;
  static final _setfunctionalTest = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_android_content_pm_InstrumentationInfo_functionalTest")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set functionalTest(bool value) =>
      _setfunctionalTest(reference, value ? 1 : 0);

  /// from: public boolean handleProfiling
  /// Specifies whether or not this instrumentation will handle profiling.
  static final _gethandleProfiling = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_InstrumentationInfo_handleProfiling")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  bool get handleProfiling => _gethandleProfiling(reference) != 0;
  static final _sethandleProfiling = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_android_content_pm_InstrumentationInfo_handleProfiling")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set handleProfiling(bool value) =>
      _sethandleProfiling(reference, value ? 1 : 0);

  /// from: public java.lang.String publicSourceDir
  /// Full path to the publicly available parts of \#sourceDir,
  /// including resources and manifest. This may be different from
  /// \#sourceDir if an application is forward locked.
  static final _getpublicSourceDir = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_InstrumentationInfo_publicSourceDir")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get publicSourceDir =>
      jni.JlString.fromRef(_getpublicSourceDir(reference));
  static final _setpublicSourceDir = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_InstrumentationInfo_publicSourceDir")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set publicSourceDir(jni.JlString value) =>
      _setpublicSourceDir(reference, value.reference);

  /// from: public java.lang.String sourceDir
  /// Full path to the base APK for this application.
  static final _getsourceDir = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_InstrumentationInfo_sourceDir")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get sourceDir => jni.JlString.fromRef(_getsourceDir(reference));
  static final _setsourceDir = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_InstrumentationInfo_sourceDir")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set sourceDir(jni.JlString value) =>
      _setsourceDir(reference, value.reference);

  /// from: public java.lang.String[] splitNames
  /// The names of all installed split APKs, ordered lexicographically.
  static final _getsplitNames = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_InstrumentationInfo_splitNames")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get splitNames =>
      jni.JlObject.fromRef(_getsplitNames(reference));
  static final _setsplitNames = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_InstrumentationInfo_splitNames")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set splitNames(jni.JlObject value) =>
      _setsplitNames(reference, value.reference);

  /// from: public java.lang.String[] splitPublicSourceDirs
  /// Full path to the publicly available parts of \#splitSourceDirs,
  /// including resources and manifest. This may be different from
  /// \#splitSourceDirs if an application is forward locked.
  ///@see \#splitSourceDirs
  static final _getsplitPublicSourceDirs = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_InstrumentationInfo_splitPublicSourceDirs")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get splitPublicSourceDirs =>
      jni.JlObject.fromRef(_getsplitPublicSourceDirs(reference));
  static final _setsplitPublicSourceDirs = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_InstrumentationInfo_splitPublicSourceDirs")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set splitPublicSourceDirs(jni.JlObject value) =>
      _setsplitPublicSourceDirs(reference, value.reference);

  /// from: public java.lang.String[] splitSourceDirs
  /// Full paths to zero or more split APKs, indexed by the same order as \#splitNames.
  static final _getsplitSourceDirs = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_InstrumentationInfo_splitSourceDirs")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get splitSourceDirs =>
      jni.JlObject.fromRef(_getsplitSourceDirs(reference));
  static final _setsplitSourceDirs = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_InstrumentationInfo_splitSourceDirs")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set splitSourceDirs(jni.JlObject value) =>
      _setsplitSourceDirs(reference, value.reference);

  /// from: public java.lang.String targetPackage
  /// The name of the application package being instrumented.  From the
  /// "package" attribute.
  static final _gettargetPackage = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_InstrumentationInfo_targetPackage")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get targetPackage =>
      jni.JlString.fromRef(_gettargetPackage(reference));
  static final _settargetPackage = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_InstrumentationInfo_targetPackage")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set targetPackage(jni.JlString value) =>
      _settargetPackage(reference, value.reference);

  /// from: public java.lang.String targetProcesses
  /// Names of the process(es) this instrumentation will run in.  If not specified, only
  /// runs in the main process of the targetPackage.  Can either be a comma-separated list
  /// of process names or '*' for any process that launches to run targetPackage code.
  static final _gettargetProcesses = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_pm_InstrumentationInfo_targetProcesses")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get targetProcesses =>
      jni.JlString.fromRef(_gettargetProcesses(reference));
  static final _settargetProcesses = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_pm_InstrumentationInfo_targetProcesses")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set targetProcesses(jni.JlString value) =>
      _settargetProcesses(reference, value.reference);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_pm_InstrumentationInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  InstrumentationInfo() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_InstrumentationInfo_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.pm.InstrumentationInfo orig)
  InstrumentationInfo.ctor_1(InstrumentationInfo orig)
      : super.fromRef(_ctor_1(orig.reference));

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_InstrumentationInfo_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_InstrumentationInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_InstrumentationInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(os.Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags);
}

/// The ShortcutManager performs operations on an app's set of _shortcuts_. The
/// ShortcutInfo class contains information about each of the shortcuts themselves.
///
/// An app's shortcuts represent specific tasks and actions that users can perform within your
/// app. When a user selects a shortcut in the currently-active launcher, your app opens an activity
/// other than the app's starting activity, provided that the currently-active launcher supports app
/// shortcuts.
///
///
/// The types of shortcuts that you create for your app depend on the app's key use cases. For
/// example, an email app may publish the "compose new email" shortcut, which allows the app to
/// directly open the compose activity.
///
///
/// <p class="note">__Note:__ Only main activities&mdash;activities that handle the
/// Intent\#ACTION_MAIN action and the Intent\#CATEGORY_LAUNCHER category&mdash;can
/// have shortcuts. If an app has multiple main activities, you need to define the set of shortcuts
/// for _each_ activity.
///
/// This page discusses the implementation details of the <code>ShortcutManager</code> class. For
/// definitions of key terms and guidance on performing operations on shortcuts within your app, see
/// the <a href="/guide/topics/ui/shortcuts.html">App Shortcuts</a> feature guide.
///
/// <h3>Shortcut characteristics</h3>
///
/// This section describes in-depth details about each shortcut type's usage and availability.
///
/// <p class="note">__Important security note:__ All shortcut information is stored in
/// <a href="/training/articles/direct-boot.html">credential encrypted storage</a>, so your app
/// cannot access a user's shortcuts until after they've unlocked the device.
///
/// <h4>Static and dynamic shortcuts</h4>
///
/// Static shortcuts and dynamic shortcuts are shown in a supported launcher when the user
/// performs a specific gesture. On currently-supported launchers, the gesture is a long-press on the
/// app's launcher icon, but the actual gesture may be different on other launcher apps.
///
/// The LauncherApps class provides APIs for launcher apps to access shortcuts.
///
/// <h4>Pinned shortcuts</h4>
///
/// Because pinned shortcuts appear in the launcher itself, they're always visible. A pinned
/// shortcut is removed from the launcher only in the following situations:
/// <ul>
///     <li>The user removes it.
///     <li>The publisher app associated with the shortcut is uninstalled.
///     <li>The user selects __Clear data__ from the publisher app's <i>Storage</i> screen, within
///     the system's __Settings__ app.
/// </ul>
///
/// Because the system performs
/// <a href="/guide/topics/ui/shortcuts.html\#backup-and-restore">backup and restore</a> on pinned
/// shortcuts automatically, these shortcuts' IDs should contain either stable, constant strings or
/// server-side identifiers, rather than identifiers generated locally that might not make sense on
/// other devices.
///
/// <h3>Shortcut display order</h3>
///
/// When the launcher displays an app's shortcuts, they should appear in the following order:
///
/// <ol>
///   <li>__Static shortcuts:__ Shortcuts whose ShortcutInfo\#isDeclaredInManifest() method
///   returns {@code true}.</li>
///   <li>__Dynamic shortcuts:__ Shortcuts whose ShortcutInfo\#isDynamic() method returns
///   {@code true}.</li>
/// </ol>
///
/// Within each shortcut type (static and dynamic), shortcuts are sorted in order of increasing
/// rank according to ShortcutInfo\#getRank().
///
///
/// <h4>Shortcut ranks</h4>
///
/// Shortcut ranks are non-negative, sequential integers that determine the order in which
/// shortcuts appear, assuming that the shortcuts are all in the same category. You can update ranks
/// of existing shortcuts when you call \#updateShortcuts(List),
/// \#addDynamicShortcuts(List), or \#setDynamicShortcuts(List).
///
/// <p class="note">__Note:__ Ranks are auto-adjusted so that they're unique for each type of
/// shortcut (static or dynamic). For example, if there are 3 dynamic shortcuts with ranks 0, 1 and
/// 2, adding another dynamic shortcut with a rank of 1 represents a request to place this shortcut
/// at the second position. In response, the third and fourth shortcuts move closer to the bottom of
/// the shortcut list, with their ranks changing to 2 and 3, respectively.
///
/// <h3>Options for static shortcuts</h3>
///
/// The following list includes descriptions for the different attributes within a static shortcut.
/// You must provide a value for {@code android:shortcutId} and {@code android:shortcutShortLabel};
/// all other values are optional.
///
/// <dl>
///   <dt>{@code android:shortcutId}</dt>
///   <dd>A string literal, which represents the shortcut when a {@code ShortcutManager} object
///   performs operations on it.
///
///   <p class="note">__Note: __You cannot set this attribute's value to a resource string, such
///   as <code>@string/foo</code>.
///
///   </dd>
///
///   <dt>{@code android:enabled}</dt>
///   <dd>Whether the user can interact with the shortcut from a supported launcher.
///
///   The default value is {@code true}. If you set it to {@code false}, you should also set
///   {@code android:shortcutDisabledMessage} to a message that explains why you've disabled the
///   shortcut. If you don't think you need to provide such a message, it's easiest to just remove
///   the shortcut from the XML file entirely, rather than changing the values of the shortcut's
///   {@code android:enabled} and {@code android:shortcutDisabledMessage} attributes.
///   </dd>
///
///   <dt>{@code android:icon}</dt>
///   <dd>The <a href="/topic/performance/graphics/index.html">bitmap</a> or
///   <a href="/guide/practices/ui_guidelines/icon_design_adaptive.html">adaptive icon</a> that the
///   launcher uses when displaying the shortcut to the user. This value can be either the path to an
///   image or the resource file that contains the image. Use adaptive icons whenever possible to
///   improve performance and consistency.
///
///   <p class="note">__Note: __Shortcut icons cannot include
///   <a href="/training/material/drawables.html\#DrawableTint">tints</a>.
///   </dd>
///
///   <dt>{@code android:shortcutShortLabel}</dt>
///   <dd>A concise phrase that describes the shortcut's purpose. For more information, see
///   ShortcutInfo.Builder\#setShortLabel(CharSequence).
///
///   <p class="note">__Note: __This attribute's value must be a resource string, such as
///   <code>@string/shortcut_short_label</code>.
///
///   </dd>
///
///   <dt>{@code android:shortcutLongLabel}</dt>
///   <dd>An extended phrase that describes the shortcut's purpose. If there's enough space, the
///   launcher displays this value instead of {@code android:shortcutShortLabel}. For more
///   information, see ShortcutInfo.Builder\#setLongLabel(CharSequence).
///
///   <p class="note">__Note: __This attribute's value must be a resource string, such as
///   <code>@string/shortcut_long_label</code>.
///
///   </dd>
///
///   <dt>{@code android:shortcutDisabledMessage}</dt>
///   <dd>The message that appears in a supported launcher when the user attempts to launch a
///   disabled shortcut. The message should explain to the user why the shortcut is now disabled.
///   This attribute's value has no effect if {@code android:enabled} is {@code true}.
///
///   <p class="note">__Note: __This attribute's value must be a resource string, such as
///   <code>@string/shortcut_disabled_message</code>.
///
///   </dd>
/// </dl>
///
/// <h3>Inner elements that define static shortcuts</h3>
///
/// The XML file that lists an app's static shortcuts supports the following elements inside each
/// {@code <shortcut>} element. You must include an {@code intent} inner element for each
/// static shortcut that you define.
///
///
/// <dl>
///   <dt>{@code intent}</dt>
///   <dd>The action that the system launches when the user selects the shortcut. This intent must
///   provide a value for the {@code android:action} attribute.
///
///   You can provide multiple intents for a single shortcut. If you do so, the last defined
///   activity is launched, and the other activities are placed in the
///   <a href="/guide/components/tasks-and-back-stack.html">back stack</a>. See
///   <a href="/guide/topics/ui/shortcuts.html\#static">Using Static Shortcuts</a> and the
///   android.app.TaskStackBuilder class reference for details.
///
///   <p class="note">__Note:__ This {@code intent} element cannot include string resources.
///
///   To learn more about how to configure intents, see
///   <a href="{@docRoot}guide/topics/ui/settings.html\#Intents">Using intents</a>.
///
///   </dd>
///
///   <dt>{@code categories}</dt>
///   <dd>Provides a grouping for the types of actions that your app's shortcuts perform, such as
///   creating new chat messages.
///
///   For a list of supported shortcut categories, see the ShortcutInfo class reference
///   for a list of supported shortcut categories.
///   </dd>
/// </dl>
///
/// <h3>Updating shortcuts</h3>
///
/// Each app's launcher icon can contain at most \#getMaxShortcutCountPerActivity() number
/// of static and dynamic shortcuts combined. There is no limit to the number of pinned shortcuts
/// that an app can create, though.
///
/// When a dynamic shortcut is pinned, even when the publisher removes it as a dynamic shortcut,
/// the pinned shortcut is still visible and launchable.  This allows an app to have more than
/// \#getMaxShortcutCountPerActivity() number of shortcuts.
///
/// As an example, suppose \#getMaxShortcutCountPerActivity() is 5:
/// <ol>
///     <li>A chat app publishes 5 dynamic shortcuts for the 5 most recent
///     conversations (c1, c2, ..., c5).
///
///     <li>The user pins all 5 of the shortcuts.
///
///     <li>Later, the user has started 3 additional conversations (c6, c7, and c8), so the publisher
///     app re-publishes its dynamic shortcuts. The new dynamic shortcut list is: c4, c5, ..., c8.
///     The publisher app has to remove c1, c2, and c3 because it can't have more than 5 dynamic
///     shortcuts. However, c1, c2, and c3 are still pinned shortcuts that the user can access and
///     launch.
///     At this point, the user can access a total of 8 shortcuts that link to activities in the
///     publisher app, including the 3 pinned shortcuts, even though an app can have at most 5
///     dynamic shortcuts.
///
///     <li>The app can use \#updateShortcuts(List) to update _any_ of the existing
///     8 shortcuts, when, for example, the chat peers' icons have changed.
///     The \#addDynamicShortcuts(List) and \#setDynamicShortcuts(List) methods
///     can also be used to update existing shortcuts with the same IDs, but they __cannot__ be
///     used for updating non-dynamic, pinned shortcuts because these 2 methods try to convert the
///     given lists of shortcuts to dynamic shortcuts.
/// </ol>
///
/// <h3>Shortcut intents</h3>
///
///
/// Dynamic shortcuts can be published with any set of Intent\#addFlags Intent flags.
/// Typically, Intent\#FLAG_ACTIVITY_CLEAR_TASK is specified, possibly along with other
/// flags; otherwise, if the app is already running, the app is simply brought to
/// the foreground, and the target activity might not appear.
///
/// Static shortcuts __cannot__ have custom intent flags.
/// The first intent of a static shortcut will always have Intent\#FLAG_ACTIVITY_NEW_TASK
/// and Intent\#FLAG_ACTIVITY_CLEAR_TASK set. This means, when the app is already running, all
/// the existing activities in your app are destroyed when a static shortcut is launched.
/// If this behavior is not desirable, you can use a _trampoline activity_, or an invisible
/// activity that starts another activity in Activity\#onCreate, then calls
/// Activity\#finish():
/// <ol>
///     <li>In the <code>AndroidManifest.xml</code> file, the trampoline activity should include the
///     attribute assignment {@code android:taskAffinity=""}.
///     <li>In the shortcuts resource file, the intent within the static shortcut should reference
///     the trampoline activity.
/// </ol>
///
/// <h3>Rate limiting</h3>
///
/// When <a href="/guide/topics/ui/shortcuts.html\#rate-limit">rate limiting</a> is active,
/// \#isRateLimitingActive() returns {@code true}.
///
/// Rate limiting is reset upon certain events, so even background apps can call these APIs until
/// the rate limit is reached again. These events include the following:
/// <ul>
///   <li>An app comes to the foreground.
///   <li>The system locale changes.
///   <li>The user performs the <a href="/guide/topics/ui/notifiers/notifications.html\#direct">inline
///   reply</a> action on a notification.
/// </ul>
///
/// <h3>Handling system locale changes</h3>
///
/// Apps should update dynamic and pinned shortcuts when they receive the
/// Intent\#ACTION_LOCALE_CHANGED broadcast, indicating that the system locale has changed.
/// When the system locale changes, <a href="/guide/topics/ui/shortcuts.html\#rate-limit">rate
/// limiting</a> is reset, so even background apps can add and update dynamic shortcuts until the
/// rate limit is reached again.
///
/// <h3>Retrieving class instances</h3>
/// <!-- Provides a heading for the content filled in by the @SystemService annotation below -->
class ShortcutManager extends jni.JlObject {
  ShortcutManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutManager_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.content.Context context)
  /// @hide
  ShortcutManager(content.Context context)
      : super.fromRef(_ctor(context.reference));

  static final _setDynamicShortcuts = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutManager_setDynamicShortcuts")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean setDynamicShortcuts(java.util.List<android.content.pm.ShortcutInfo> shortcutInfoList)
  /// Publish the list of shortcuts.  All existing dynamic shortcuts from the caller app
  /// will be replaced.  If there are already pinned shortcuts with the same IDs,
  /// the mutable pinned shortcuts are updated.
  ///
  /// This API will be rate-limited.
  ///@param shortcutInfoList This value must never be {@code null}.
  ///@return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
  ///@throws IllegalArgumentException if \#getMaxShortcutCountPerActivity() is exceeded,
  /// or when trying to update immutable shortcuts.
  ///@throws IllegalStateException when the user is locked.
  bool setDynamicShortcuts(jni.JlObject shortcutInfoList) =>
      _setDynamicShortcuts(reference, shortcutInfoList.reference) != 0;

  static final _getDynamicShortcuts = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutManager_getDynamicShortcuts")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.content.pm.ShortcutInfo> getDynamicShortcuts()
  /// Return all dynamic shortcuts from the caller app.
  ///
  /// This API is intended to be used for examining what shortcuts are currently published.
  /// Re-publishing returned ShortcutInfos via APIs such as
  /// \#setDynamicShortcuts(List) may cause loss of information such as icons.
  ///@throws IllegalStateException when the user is locked.
  ///@return This value will never be {@code null}.
  jni.JlObject getDynamicShortcuts() =>
      jni.JlObject.fromRef(_getDynamicShortcuts(reference));

  static final _getManifestShortcuts = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutManager_getManifestShortcuts")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.content.pm.ShortcutInfo> getManifestShortcuts()
  /// Return all static (manifest) shortcuts from the caller app.
  ///
  /// This API is intended to be used for examining what shortcuts are currently published.
  /// Re-publishing returned ShortcutInfos via APIs such as
  /// \#setDynamicShortcuts(List) may cause loss of information such as icons.
  ///@throws IllegalStateException when the user is locked.
  ///@return This value will never be {@code null}.
  jni.JlObject getManifestShortcuts() =>
      jni.JlObject.fromRef(_getManifestShortcuts(reference));

  static final _addDynamicShortcuts = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutManager_addDynamicShortcuts")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean addDynamicShortcuts(java.util.List<android.content.pm.ShortcutInfo> shortcutInfoList)
  /// Publish the list of dynamic shortcuts.  If there are already dynamic or pinned shortcuts with
  /// the same IDs, each mutable shortcut is updated.
  ///
  /// This API will be rate-limited.
  ///@param shortcutInfoList This value must never be {@code null}.
  ///@return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
  ///@throws IllegalArgumentException if \#getMaxShortcutCountPerActivity() is exceeded,
  /// or when trying to update immutable shortcuts.
  ///@throws IllegalStateException when the user is locked.
  bool addDynamicShortcuts(jni.JlObject shortcutInfoList) =>
      _addDynamicShortcuts(reference, shortcutInfoList.reference) != 0;

  static final _removeDynamicShortcuts = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutManager_removeDynamicShortcuts")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void removeDynamicShortcuts(java.util.List<java.lang.String> shortcutIds)
  /// Delete dynamic shortcuts by ID.
  ///@throws IllegalStateException when the user is locked.
  ///@param shortcutIds This value must never be {@code null}.
  void removeDynamicShortcuts(jni.JlObject shortcutIds) =>
      _removeDynamicShortcuts(reference, shortcutIds.reference);

  static final _removeAllDynamicShortcuts =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ShortcutManager_removeAllDynamicShortcuts")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void removeAllDynamicShortcuts()
  /// Delete all dynamic shortcuts from the caller app.
  ///@throws IllegalStateException when the user is locked.
  void removeAllDynamicShortcuts() => _removeAllDynamicShortcuts(reference);

  static final _getPinnedShortcuts = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutManager_getPinnedShortcuts")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.content.pm.ShortcutInfo> getPinnedShortcuts()
  /// Return all pinned shortcuts from the caller app.
  ///
  /// This API is intended to be used for examining what shortcuts are currently published.
  /// Re-publishing returned ShortcutInfos via APIs such as
  /// \#setDynamicShortcuts(List) may cause loss of information such as icons.
  ///@throws IllegalStateException when the user is locked.
  ///@return This value will never be {@code null}.
  jni.JlObject getPinnedShortcuts() =>
      jni.JlObject.fromRef(_getPinnedShortcuts(reference));

  static final _updateShortcuts = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutManager_updateShortcuts")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean updateShortcuts(java.util.List<android.content.pm.ShortcutInfo> shortcutInfoList)
  /// Update all existing shortcuts with the same IDs.  Target shortcuts may be pinned and/or
  /// dynamic, but they must not be immutable.
  ///
  /// This API will be rate-limited.
  ///@param shortcutInfoList This value must never be {@code null}.
  ///@return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
  ///@throws IllegalArgumentException If trying to update immutable shortcuts.
  ///@throws IllegalStateException when the user is locked.
  bool updateShortcuts(jni.JlObject shortcutInfoList) =>
      _updateShortcuts(reference, shortcutInfoList.reference) != 0;

  static final _disableShortcuts = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutManager_disableShortcuts")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void disableShortcuts(java.util.List<java.lang.String> shortcutIds)
  /// Disable pinned shortcuts.  For more details, see the Javadoc for the ShortcutManager
  /// class.
  ///@throws IllegalArgumentException If trying to disable immutable shortcuts.
  ///@throws IllegalStateException when the user is locked.
  ///@param shortcutIds This value must never be {@code null}.
  void disableShortcuts(jni.JlObject shortcutIds) =>
      _disableShortcuts(reference, shortcutIds.reference);

  static final _disableShortcuts_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutManager_disableShortcuts_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void disableShortcuts(java.util.List<java.lang.String> shortcutIds, java.lang.CharSequence disabledMessage)
  /// Disable pinned shortcuts, showing the user a custom error message when they try to select
  /// the disabled shortcuts.
  /// For more details, see the Javadoc for the ShortcutManager class.
  ///@throws IllegalArgumentException If trying to disable immutable shortcuts.
  ///@throws IllegalStateException when the user is locked.
  ///@param shortcutIds This value must never be {@code null}.
  void disableShortcuts_1(
          jni.JlObject shortcutIds, jni.JlObject disabledMessage) =>
      _disableShortcuts_1(
          reference, shortcutIds.reference, disabledMessage.reference);

  static final _enableShortcuts = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutManager_enableShortcuts")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void enableShortcuts(java.util.List<java.lang.String> shortcutIds)
  /// Re-enable pinned shortcuts that were previously disabled.  If the target shortcuts
  /// are already enabled, this method does nothing.
  ///@throws IllegalArgumentException If trying to enable immutable shortcuts.
  ///@throws IllegalStateException when the user is locked.
  ///@param shortcutIds This value must never be {@code null}.
  void enableShortcuts(jni.JlObject shortcutIds) =>
      _enableShortcuts(reference, shortcutIds.reference);

  static final _getMaxShortcutCountPerActivity = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutManager_getMaxShortcutCountPerActivity")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getMaxShortcutCountPerActivity()
  /// Return the maximum number of static and dynamic shortcuts that each launcher icon
  /// can have at a time.
  int getMaxShortcutCountPerActivity() =>
      _getMaxShortcutCountPerActivity(reference);

  static final _isRateLimitingActive =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ShortcutManager_isRateLimitingActive")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isRateLimitingActive()
  /// Return {@code true} when rate-limiting is active for the caller app.
  ///
  /// See the class level javadoc for details.
  ///@throws IllegalStateException when the user is locked.
  bool isRateLimitingActive() => _isRateLimitingActive(reference) != 0;

  static final _getIconMaxWidth =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ShortcutManager_getIconMaxWidth")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getIconMaxWidth()
  /// Return the max width for icons, in pixels.
  ///
  ///  Note that this method returns max width of icon's visible part. Hence, it does not take
  /// into account the inset introduced by AdaptiveIconDrawable. To calculate bitmap image
  /// to function as AdaptiveIconDrawable, multiply
  /// 1 + 2 * AdaptiveIconDrawable\#getExtraInsetFraction() to the returned size.
  int getIconMaxWidth() => _getIconMaxWidth(reference);

  static final _getIconMaxHeight =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_ShortcutManager_getIconMaxHeight")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getIconMaxHeight()
  /// Return the max height for icons, in pixels.
  int getIconMaxHeight() => _getIconMaxHeight(reference);

  static final _reportShortcutUsed = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutManager_reportShortcutUsed")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void reportShortcutUsed(java.lang.String shortcutId)
  /// Apps that publish shortcuts should call this method whenever the user
  /// selects the shortcut containing the given ID or when the user completes
  /// an action in the app that is equivalent to selecting the shortcut.
  /// For more details, see the Javadoc for the ShortcutManager class
  ///
  /// The information is accessible via UsageStatsManager\#queryEvents
  /// Typically, launcher apps use this information to build a prediction model
  /// so that they can promote the shortcuts that are likely to be used at the moment.
  ///@throws IllegalStateException when the user is locked.
  void reportShortcutUsed(jni.JlString shortcutId) =>
      _reportShortcutUsed(reference, shortcutId.reference);

  static final _isRequestPinShortcutSupported = jlookup<
              ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutManager_isRequestPinShortcutSupported")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isRequestPinShortcutSupported()
  /// Return {@code TRUE} if the app is running on a device whose default launcher supports
  /// \#requestPinShortcut(ShortcutInfo, IntentSender).
  ///
  /// The return value may change in subsequent calls if the user changes the default launcher
  /// app.
  ///
  /// __Note:__ See also the support library counterpart
  /// android.support.v4.content.pm.ShortcutManagerCompat\#isRequestPinShortcutSupported(
  /// Context), which supports Android versions lower than VERSION_CODES\#O using the
  /// legacy private intent {@code com.android.launcher.action.INSTALL_SHORTCUT}.
  ///@see \#requestPinShortcut(ShortcutInfo, IntentSender)
  bool isRequestPinShortcutSupported() =>
      _isRequestPinShortcutSupported(reference) != 0;

  static final _requestPinShortcut = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutManager_requestPinShortcut")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean requestPinShortcut(android.content.pm.ShortcutInfo shortcut, android.content.IntentSender resultIntent)
  /// Request to create a pinned shortcut.  The default launcher will receive this request and
  /// ask the user for approval.  If the user approves it, the shortcut will be created, and
  /// {@code resultIntent} will be sent. If a request is denied by the user, however, no response
  /// will be sent to the caller.
  ///
  /// Only apps with a foreground activity or a foreground service can call this method.
  /// Otherwise, it'll throw IllegalStateException.
  ///
  /// It's up to the launcher to decide how to handle previous pending requests when the same
  /// package calls this API multiple times in a row. One possible strategy is to ignore any
  /// previous requests.
  ///
  /// __Note:__ See also the support library counterpart
  /// android.support.v4.content.pm.ShortcutManagerCompat\#requestPinShortcut(
  /// Context, ShortcutInfoCompat, IntentSender),
  /// which supports Android versions lower than VERSION_CODES\#O using the
  /// legacy private intent {@code com.android.launcher.action.INSTALL_SHORTCUT}.
  ///@param shortcut Shortcut to pin.  If an app wants to pin an existing (either static
  ///     or dynamic) shortcut, then it only needs to have an ID. Although other fields don't have
  ///     to be set, the target shortcut must be enabled.
  ///
  ///     If it's a new shortcut, all the mandatory fields, such as a short label, must be
  ///     set.
  /// This value must never be {@code null}.
  ///@param resultIntent If not null, this intent will be sent when the shortcut is pinned.
  ///    Use android.app.PendingIntent\#getIntentSender() to create an IntentSender.
  ///    To avoid background execution limits, use an unexported, manifest-declared receiver.
  ///    For more details, see the overview documentation for the ShortcutManager class.
  ///
  /// This value may be {@code null}.
  ///@return {@code TRUE} if the launcher supports this feature.  Note the API will return without
  ///    waiting for the user to respond, so getting {@code TRUE} from this API does *not* mean
  ///    the shortcut was pinned successfully.  {@code FALSE} if the launcher doesn't support this
  ///    feature.
  ///@see \#isRequestPinShortcutSupported()
  ///@see IntentSender
  ///@see android.app.PendingIntent\#getIntentSender()
  ///@throws IllegalArgumentException if a shortcut with the same ID exists and is disabled.
  ///@throws IllegalStateException The caller doesn't have a foreground activity or a foreground
  /// service, or the device is locked.
  bool requestPinShortcut(
          ShortcutInfo shortcut, content.IntentSender resultIntent) =>
      _requestPinShortcut(
          reference, shortcut.reference, resultIntent.reference) !=
      0;

  static final _createShortcutResultIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_ShortcutManager_createShortcutResultIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent createShortcutResultIntent(android.content.pm.ShortcutInfo shortcut)
  /// Returns an Intent which can be used by the default launcher to pin a shortcut containing the
  /// given ShortcutInfo. This method should be used by an Activity to set a result in
  /// response to Intent\#ACTION_CREATE_SHORTCUT.
  ///@param shortcut New shortcut to pin.  If an app wants to pin an existing (either dynamic
  ///     or manifest) shortcut, then it only needs to have an ID, and other fields don't have to
  ///     be set, in which case, the target shortcut must be enabled.
  ///     If it's a new shortcut, all the mandatory fields, such as a short label, must be
  ///     set.
  /// This value must never be {@code null}.
  ///@return The intent that should be set as the result for the calling activity, or
  ///     <code>null</code> if the current launcher doesn't support shortcuts.
  ///@see Intent\#ACTION_CREATE_SHORTCUT
  ///@throws IllegalArgumentException if a shortcut with the same ID exists and is disabled.
  content.Intent createShortcutResultIntent(ShortcutInfo shortcut) =>
      content.Intent.fromRef(
          _createShortcutResultIntent(reference, shortcut.reference));
}

/// A representation of an activity that can belong to this user or a managed
/// profile associated with this user. It can be used to query the label, icon
/// and badged icon for the activity.
class LauncherActivityInfo extends jni.JlObject {
  LauncherActivityInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherActivityInfo_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.content.Context context)
  LauncherActivityInfo(content.Context context)
      : super.fromRef(_ctor(context.reference));

  static final _getComponentName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherActivityInfo_getComponentName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getComponentName()
  /// Returns the component name of this activity.
  ///@return ComponentName of the activity
  content.ComponentName getComponentName() =>
      content.ComponentName.fromRef(_getComponentName(reference));

  static final _getUser = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherActivityInfo_getUser")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.UserHandle getUser()
  /// Returns the user handle of the user profile that this activity belongs to. In order to
  /// persist the identity of the profile, do not store the UserHandle. Instead retrieve its
  /// serial number from UserManager. You can convert the serial number back to a UserHandle
  /// for later use.
  ///@see UserManager\#getSerialNumberForUser(UserHandle)
  ///@see UserManager\#getUserForSerialNumber(long)
  ///@return The UserHandle of the profile.
  os.UserHandle getUser() => os.UserHandle.fromRef(_getUser(reference));

  static final _getLabel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherActivityInfo_getLabel")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getLabel()
  /// Retrieves the label for the activity.
  ///@return The label for the activity.
  jni.JlObject getLabel() => jni.JlObject.fromRef(_getLabel(reference));

  static final _getIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_LauncherActivityInfo_getIcon")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.drawable.Drawable getIcon(int density)
  /// Returns the icon for this activity, without any badging for the profile.
  ///@param density The preferred density of the icon, zero for default density. Use
  /// density DPI values from DisplayMetrics.
  ///@see \#getBadgedIcon(int)
  ///@see DisplayMetrics
  ///@return The drawable associated with the activity.
  jni.JlObject getIcon(int density) =>
      jni.JlObject.fromRef(_getIcon(reference, density));

  static final _getApplicationInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherActivityInfo_getApplicationInfo")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ApplicationInfo getApplicationInfo()
  /// Returns the application info for the appliction this activity belongs to.
  ///@return
  ApplicationInfo getApplicationInfo() =>
      ApplicationInfo.fromRef(_getApplicationInfo(reference));

  static final _getFirstInstallTime =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_pm_LauncherActivityInfo_getFirstInstallTime")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getFirstInstallTime()
  /// Returns the time at which the package was first installed.
  ///@return The time of installation of the package, in milliseconds.
  int getFirstInstallTime() => _getFirstInstallTime(reference);

  static final _getName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_pm_LauncherActivityInfo_getName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getName()
  /// Returns the name for the acitivty from  android:name in the manifest.
  ///@return the name from android:name for the acitivity.
  jni.JlString getName() => jni.JlString.fromRef(_getName(reference));

  static final _getBadgedIcon = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_pm_LauncherActivityInfo_getBadgedIcon")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.drawable.Drawable getBadgedIcon(int density)
  /// Returns the activity icon with badging appropriate for the profile.
  ///@param density Optional density for the icon, or 0 to use the default density. Use
  /// DisplayMetrics for DPI values.
  ///@see DisplayMetrics
  ///@return A badged icon for the activity.
  jni.JlObject getBadgedIcon(int density) =>
      jni.JlObject.fromRef(_getBadgedIcon(reference, density));
}
