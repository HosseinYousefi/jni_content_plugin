// Autogenerated by jni_gen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_element

import "dart:ffi" as ffi;

import "package:jni/jni.dart" as jni;

import "package:content_plugin/android/os.dart" as os;
import "../../init.dart" show jlookup;

/// Basic information about a Opaque Binary Blob (OBB) that reflects the info
/// from the footer on the OBB file. This information may be manipulated by a
/// developer with the <code>obbtool</code> program in the Android SDK.
class ObbInfo extends jni.JlObject {
  ObbInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.res.ObbInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_res_ObbInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int OBB_OVERLAY
  /// Flag noting that this OBB is an overlay patch for a base OBB.
  static const OBB_OVERLAY = 1;

  /// from: public java.lang.String filename
  /// The canonical filename of the OBB.
  static final _getfilename = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_ObbInfo_filename")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get filename => jni.JlString.fromRef(_getfilename(reference));
  static final _setfilename = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_res_ObbInfo_filename")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set filename(jni.JlString value) => _setfilename(reference, value.reference);

  /// from: public int flags
  /// The flags relating to the OBB.
  static final _getflags = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_ObbInfo_flags")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get flags => _getflags(reference);
  static final _setflags = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_res_ObbInfo_flags")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set flags(int value) => _setflags(reference, value);

  /// from: public java.lang.String packageName
  /// The name of the package to which the OBB file belongs.
  static final _getpackageName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_ObbInfo_packageName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlString get packageName =>
      jni.JlString.fromRef(_getpackageName(reference));
  static final _setpackageName = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_res_ObbInfo_packageName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set packageName(jni.JlString value) =>
      _setpackageName(reference, value.reference);

  /// from: public int version
  /// The version of the package to which the OBB file belongs.
  static final _getversion = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_ObbInfo_version")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get version => _getversion(reference);
  static final _setversion = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_res_ObbInfo_version")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set version(int value) => _setversion(reference, value);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_res_ObbInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  ObbInfo() : super.fromRef(_ctor());

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_ObbInfo_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_ObbInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_ObbInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(os.Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags);
}

/// Lets you map android.view.View state sets to colors.
///
/// android.content.res.ColorStateLists are created from XML resource files defined in the
/// "color" subdirectory directory of an application's resource directory. The XML file contains
/// a single "selector" element with a number of "item" elements inside. For example:
/// <pre>
/// &lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt;
///   &lt;item android:state_focused="true"
///           android:color="@color/sample_focused" /&gt;
///   &lt;item android:state_pressed="true"
///           android:state_enabled="false"
///           android:color="@color/sample_disabled_pressed" /&gt;
///   &lt;item android:state_enabled="false"
///           android:color="@color/sample_disabled_not_pressed" /&gt;
///   &lt;item android:color="@color/sample_default" /&gt;
/// &lt;/selector&gt;
/// </pre>
///
/// This defines a set of state spec / color pairs where each state spec specifies a set of
/// states that a view must either be in or not be in and the color specifies the color associated
/// with that spec.
///
/// <a name="StateSpec"></a>
/// <h3>State specs</h3>
///
/// Each item defines a set of state spec and color pairs, where the state spec is a series of
/// attributes set to either {@code true} or {@code false} to represent inclusion or exclusion. If
/// an attribute is not specified for an item, it may be any value.
///
/// For example, the following item will be matched whenever the focused state is set; any other
/// states may be set or unset:
/// <pre>
/// &lt;item android:state_focused="true"
///         android:color="@color/sample_focused" /&gt;
/// </pre>
///
/// Typically, a color state list will reference framework-defined state attributes such as
/// android.R.attr\#state_focused android:state_focused or
/// android.R.attr\#state_enabled android:state_enabled; however, app-defined attributes may
/// also be used.
///
/// <strong>Note:</strong> The list of state specs will be matched against in the order that they
/// appear in the XML file. For this reason, more-specific items should be placed earlier in the
/// file. An item with no state spec is considered to match any set of states and is generally
/// useful as a final item to be used as a default.
///
/// If an item with no state spec is placed before other items, those items
/// will be ignored.
///
/// <a name="ItemAttributes"></a>
/// <h3>Item attributes</h3>
///
/// Each item must define an android.R.attr\#color android:color attribute, which may be
/// an HTML-style hex color, a reference to a color resource, or -- in API 23 and above -- a theme
/// attribute that resolves to a color.
///
/// Starting with API 23, items may optionally define an android.R.attr\#alpha android:alpha
/// attribute to modify the base color's opacity. This attribute takes a either floating-point value
/// between 0 and 1 or a theme attribute that resolves as such. The item's overall color is
/// calculated by multiplying by the base color's alpha channel by the {@code alpha} value. For
/// example, the following item represents the theme's accent color at 50% opacity:
/// <pre>
/// &lt;item android:state_enabled="false"
///         android:color="?android:attr/colorAccent"
///         android:alpha="0.5" /&gt;
/// </pre>
///
/// <a name="DeveloperGuide"></a>
/// <h3>Developer guide</h3>
///
/// For more information, see the guide to
/// <a href="{@docRoot}guide/topics/resources/color-list-resource.html">Color State
/// List Resource</a>.
///@attr ref android.R.styleable\#ColorStateListItem_alpha
///@attr ref android.R.styleable\#ColorStateListItem_color
class ColorStateList extends jni.JlObject {
  ColorStateList.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.res.ColorStateList> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_res_ColorStateList_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_ColorStateList_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int[][] states, int[] colors)
  /// Creates a ColorStateList that returns the specified mapping from
  /// states to colors.
  ColorStateList(jni.JlObject states, jni.JlObject colors)
      : super.fromRef(_ctor(states.reference, colors.reference));

  static final _valueOf =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int32)>>(
              "android_content_res_ColorStateList_valueOf")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: static public android.content.res.ColorStateList valueOf(int color)
  /// @return A ColorStateList containing a single color.
  ///
  /// This value will never be {@code null}.
  static ColorStateList valueOf(int color) =>
      ColorStateList.fromRef(_valueOf(color));

  static final _createFromXml = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_ColorStateList_createFromXml")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.res.ColorStateList createFromXml(android.content.res.Resources r, org.xmlpull.v1.XmlPullParser parser)
  /// Creates a ColorStateList from an XML document.
  ///@param r Resources against which the ColorStateList should be inflated.
  ///@param parser Parser for the XML document defining the ColorStateList.
  ///@return A new color state list.
  ///
  /// This value will never be {@code null}.
  ///@deprecated Use \#createFromXml(Resources, XmlPullParser parser, Theme)
  static ColorStateList createFromXml(Resources r, jni.JlObject parser) =>
      ColorStateList.fromRef(_createFromXml(r.reference, parser.reference));

  static final _createFromXml_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_ColorStateList_createFromXml_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.res.ColorStateList createFromXml(android.content.res.Resources r, org.xmlpull.v1.XmlPullParser parser, android.content.res.Resources.Theme theme)
  /// Creates a ColorStateList from an XML document using given a set of
  /// Resources and a Theme.
  ///@param r Resources against which the ColorStateList should be inflated.
  /// This value must never be {@code null}.
  ///@param parser Parser for the XML document defining the ColorStateList.
  /// This value must never be {@code null}.
  ///@param theme Optional theme to apply to the color state list, may be
  ///              {@code null}.
  /// This value may be {@code null}.
  ///@return A new color state list.
  static ColorStateList createFromXml_1(
          Resources r, jni.JlObject parser, Resources_Theme theme) =>
      ColorStateList.fromRef(
          _createFromXml_1(r.reference, parser.reference, theme.reference));

  static final _withAlpha = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_ColorStateList_withAlpha")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.res.ColorStateList withAlpha(int alpha)
  /// Creates a new ColorStateList that has the same states and colors as this
  /// one but where each color has the specified alpha value (0-255).
  ///@param alpha The new alpha channel value (0-255).
  ///@return A new color state list.
  ///
  /// This value will never be {@code null}.
  ColorStateList withAlpha(int alpha) =>
      ColorStateList.fromRef(_withAlpha(reference, alpha));

  static final _getChangingConfigurations =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_ColorStateList_getChangingConfigurations")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getChangingConfigurations()
  /// Returns a mask of the configuration parameters for which this color
  /// state list may change, requiring that it be re-created.
  ///@return a mask of the changing configuration parameters, as defined by
  ///         android.content.pm.ActivityInfo
  ///
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  ///@see android.content.pm.ActivityInfo
  int getChangingConfigurations() => _getChangingConfigurations(reference);

  static final _isStateful =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_ColorStateList_isStateful")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isStateful()
  /// Indicates whether this color state list contains at least one state spec
  /// and the first spec is not empty (e.g.&nbsp;match-all).
  ///@return True if this color state list changes color based on state, false
  ///         otherwise.
  ///@see \#getColorForState(int[], int)
  bool isStateful() => _isStateful(reference) != 0;

  static final _isOpaque =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_ColorStateList_isOpaque")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isOpaque()
  /// Indicates whether this color state list is opaque, which means that every
  /// color returned from \#getColorForState(int[], int) has an alpha
  /// value of 255.
  ///@return True if this color state list is opaque.
  bool isOpaque() => _isOpaque(reference) != 0;

  static final _getColorForState = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_ColorStateList_getColorForState")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getColorForState(int[] stateSet, int defaultColor)
  /// Return the color associated with the given set of
  /// android.view.View states.
  ///@param stateSet an array of android.view.View states
  /// This value may be {@code null}.
  ///@param defaultColor the color to return if there's no matching state
  ///                     spec in this ColorStateList that matches the
  ///                     stateSet.
  ///@return the color associated with that set of states in this ColorStateList.
  int getColorForState(jni.JlObject stateSet, int defaultColor) =>
      _getColorForState(reference, stateSet.reference, defaultColor);

  static final _getDefaultColor =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_ColorStateList_getDefaultColor")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getDefaultColor()
  /// Return the default color in this ColorStateList.
  ///@return the default color in this ColorStateList.
  int getDefaultColor() => _getDefaultColor(reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_ColorStateList_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_ColorStateList_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_ColorStateList_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);
}

/// Provides access to an application's raw asset files; see Resources
/// for the way most applications will want to retrieve their resource data.
/// This class presents a lower-level API that allows you to open and read raw
/// files that have been bundled with the application as a simple stream of
/// bytes.
class AssetManager extends jni.JlObject {
  AssetManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int ACCESS_BUFFER
  /// Mode for \#open(String, int): Attempt to load contents into
  /// memory, for fast small reads.
  static const ACCESS_BUFFER = 3;

  /// from: static public final int ACCESS_RANDOM
  /// Mode for \#open(String, int): Read chunks, and seek forward and
  /// backward.
  static const ACCESS_RANDOM = 1;

  /// from: static public final int ACCESS_STREAMING
  /// Mode for \#open(String, int): Read sequentially, with an
  /// occasional forward seek.
  static const ACCESS_STREAMING = 2;

  /// from: static public final int ACCESS_UNKNOWN
  /// Mode for \#open(String, int): no specific information about how
  /// data will be accessed.
  static const ACCESS_UNKNOWN = 0;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_res_AssetManager_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  /// Create a new AssetManager containing only the basic system assets.
  /// Applications will not generally use this method, instead retrieving the
  /// appropriate asset manager with Resources\#getAssets.    Not for
  /// use by applications.
  ///@hide
  AssetManager() : super.fromRef(_ctor());

  static final _close =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_AssetManager_close")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void close()
  /// Close this asset manager.
  void close() => _close(reference);

  static final _open = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetManager_open")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.InputStream open(java.lang.String fileName)
  /// Open an asset using ACCESS_STREAMING mode.  This provides access to
  /// files that have been bundled with an application as assets -- that is,
  /// files placed in to the "assets" directory.
  ///@param fileName The name of the asset to open.  This name can be hierarchical.
  ///
  /// This value must never be {@code null}.
  ///@see \#open(String, int)
  ///@see \#list
  ///@return This value will never be {@code null}.
  jni.JlObject open(jni.JlString fileName) =>
      jni.JlObject.fromRef(_open(reference, fileName.reference));

  static final _open_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_AssetManager_open_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.io.InputStream open(java.lang.String fileName, int accessMode)
  /// Open an asset using an explicit access mode, returning an InputStream to
  /// read its contents.  This provides access to files that have been bundled
  /// with an application as assets -- that is, files placed in to the
  /// "assets" directory.
  ///@param fileName The name of the asset to open.  This name can be hierarchical.
  /// This value must never be {@code null}.
  ///@param accessMode Desired access mode for retrieving the data.
  ///@see \#ACCESS_UNKNOWN
  ///@see \#ACCESS_STREAMING
  ///@see \#ACCESS_RANDOM
  ///@see \#ACCESS_BUFFER
  ///@see \#open(String)
  ///@see \#list
  ///@return This value will never be {@code null}.
  jni.JlObject open_1(jni.JlString fileName, int accessMode) =>
      jni.JlObject.fromRef(_open_1(reference, fileName.reference, accessMode));

  static final _openFd = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetManager_openFd")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.AssetFileDescriptor openFd(java.lang.String fileName)
  /// Open an uncompressed asset by mmapping it and returning an AssetFileDescriptor.
  /// This provides access to files that have been bundled with an application as assets -- that
  /// is, files placed in to the "assets" directory.
  ///
  /// The asset must be uncompressed, or an exception will be thrown.
  ///@param fileName The name of the asset to open.  This name can be hierarchical.
  /// This value must never be {@code null}.
  ///@return An open AssetFileDescriptor.
  ///
  /// This value will never be {@code null}.
  AssetFileDescriptor openFd(jni.JlString fileName) =>
      AssetFileDescriptor.fromRef(_openFd(reference, fileName.reference));

  static final _list = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetManager_list")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] list(java.lang.String path)
  /// Return a String array of all the assets at the given path.
  ///@param path A relative path within the assets, i.e., "docs/home.html".
  ///
  /// This value must never be {@code null}.
  ///@return String[] Array of strings, one for each asset.  These file
  ///         names are relative to 'path'.  You can open the file by
  ///         concatenating 'path' and a name in the returned string (via
  ///         File) and passing that to open().
  ///
  /// This value may be {@code null}.
  ///@see \#open
  jni.JlObject list(jni.JlString path) =>
      jni.JlObject.fromRef(_list(reference, path.reference));

  static final _openNonAssetFd = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetManager_openNonAssetFd")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.AssetFileDescriptor openNonAssetFd(java.lang.String fileName)
  /// Open a non-asset as an asset by mmapping it and returning an AssetFileDescriptor.
  /// This provides direct access to all of the files included in an application
  /// package (not only its assets).  Applications should not normally use this.
  ///
  /// The asset must not be compressed, or an exception will be thrown.
  ///@param fileName Name of the asset to retrieve.
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  AssetFileDescriptor openNonAssetFd(jni.JlString fileName) =>
      AssetFileDescriptor.fromRef(
          _openNonAssetFd(reference, fileName.reference));

  static final _openNonAssetFd_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetManager_openNonAssetFd_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.AssetFileDescriptor openNonAssetFd(int cookie, java.lang.String fileName)
  /// Open a non-asset as an asset by mmapping it and returning an AssetFileDescriptor.
  /// This provides direct access to all of the files included in an application
  /// package (not only its assets).  Applications should not normally use this.
  ///
  /// The asset must not be compressed, or an exception will be thrown.
  ///@param cookie Identifier of the package to be opened.
  ///@param fileName Name of the asset to retrieve.
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  AssetFileDescriptor openNonAssetFd_1(int cookie, jni.JlString fileName) =>
      AssetFileDescriptor.fromRef(
          _openNonAssetFd_1(reference, cookie, fileName.reference));

  static final _openXmlResourceParser = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetManager_openXmlResourceParser")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.XmlResourceParser openXmlResourceParser(java.lang.String fileName)
  /// Retrieve a parser for a compiled XML file.
  ///@param fileName The name of the file to retrieve.
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  XmlResourceParser openXmlResourceParser(jni.JlString fileName) =>
      XmlResourceParser.fromRef(
          _openXmlResourceParser(reference, fileName.reference));

  static final _openXmlResourceParser_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetManager_openXmlResourceParser_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.XmlResourceParser openXmlResourceParser(int cookie, java.lang.String fileName)
  /// Retrieve a parser for a compiled XML file.
  ///@param cookie Identifier of the package to be opened.
  ///@param fileName The name of the file to retrieve.
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  XmlResourceParser openXmlResourceParser_1(
          int cookie, jni.JlString fileName) =>
      XmlResourceParser.fromRef(
          _openXmlResourceParser_1(reference, cookie, fileName.reference));

  static final _finalize =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_AssetManager_finalize")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void finalize()
  void finalize() => _finalize(reference);

  static final _getLocales = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetManager_getLocales")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getLocales()
  /// Get the locales that this asset manager contains data for.
  ///
  /// On SDK 21 (Android 5.0: Lollipop) and above, Locale strings are valid
  /// <a href="https://tools.ietf.org/html/bcp47">BCP-47</a> language tags and can be
  /// parsed using java.util.Locale\#forLanguageTag(String).
  ///
  /// On SDK 20 (Android 4.4W: KitKat for watches) and below, locale strings
  /// are of the form {@code ll_CC} where {@code ll} is a two letter language code,
  /// and {@code CC} is a two letter country code.
  jni.JlObject getLocales() => jni.JlObject.fromRef(_getLocales(reference));
}

class AssetManager_AssetInputStream extends jni.JlObject {
  AssetManager_AssetInputStream.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int64)>>(
              "android_content_res_AssetManager__AssetInputStream_new")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: void <init>(long assetNativePtr)
  AssetManager_AssetInputStream(int assetNativePtr)
      : super.fromRef(_ctor(assetNativePtr));

  static final _read =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_AssetManager__AssetInputStream_read")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int read()
  int read() => _read(reference);

  static final _read_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetManager__AssetInputStream_read_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int read(byte[] b)
  /// @param b This value must never be {@code null}.
  int read_1(jni.JlObject b) => _read_1(reference, b.reference);

  static final _read_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_content_res_AssetManager__AssetInputStream_read_2")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int read(byte[] b, int off, int len)
  /// @param b This value must never be {@code null}.
  int read_2(jni.JlObject b, int off, int len) =>
      _read_2(reference, b.reference, off, len);

  static final _skip = jlookup<
              ffi.NativeFunction<
                  ffi.Int64 Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "android_content_res_AssetManager__AssetInputStream_skip")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public long skip(long n)
  int skip(int n) => _skip(reference, n);

  static final _available =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_AssetManager__AssetInputStream_available")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int available()
  int available() => _available(reference);

  static final _markSupported = jlookup<
              ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetManager__AssetInputStream_markSupported")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean markSupported()
  bool markSupported() => _markSupported(reference) != 0;

  static final _mark = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_AssetManager__AssetInputStream_mark")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void mark(int readlimit)
  void mark(int readlimit) => _mark(reference, readlimit);

  static final _reset =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_AssetManager__AssetInputStream_reset")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void reset()
  void reset() => _reset(reference);

  static final _close =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_AssetManager__AssetInputStream_close")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void close()
  void close() => _close(reference);

  static final _finalize =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_AssetManager__AssetInputStream_finalize")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void finalize()
  void finalize() => _finalize(reference);
}

/// File descriptor of an entry in the AssetManager.  This provides your own
/// opened FileDescriptor that can be used to read the data, as well as the
/// offset and length of that entry's data in the file.
class AssetFileDescriptor extends jni.JlObject {
  AssetFileDescriptor.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.content.res.AssetFileDescriptor> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_res_AssetFileDescriptor_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final long UNKNOWN_LENGTH
  /// Length used with \#AssetFileDescriptor(ParcelFileDescriptor, long, long)
  /// and \#getDeclaredLength when a length has not been declared.  This means
  /// the data extends to the end of the file.
  static const UNKNOWN_LENGTH = -1;

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Int64)>>("android_content_res_AssetFileDescriptor_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void <init>(android.os.ParcelFileDescriptor fd, long startOffset, long length)
  /// Create a new AssetFileDescriptor from the given values.
  ///@param fd The underlying file descriptor.
  ///@param startOffset The location within the file that the asset starts.
  ///            This must be 0 if length is UNKNOWN_LENGTH.
  ///@param length The number of bytes of the asset, or
  ///            \#UNKNOWN_LENGTH if it extends to the end of the file.
  AssetFileDescriptor(os.ParcelFileDescriptor fd, int startOffset, int length)
      : super.fromRef(_ctor(fd.reference, startOffset, length));

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int64, ffi.Int64, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetFileDescriptor_new_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.ParcelFileDescriptor fd, long startOffset, long length, android.os.Bundle extras)
  /// Create a new AssetFileDescriptor from the given values.
  ///@param fd The underlying file descriptor.
  ///@param startOffset The location within the file that the asset starts.
  ///            This must be 0 if length is UNKNOWN_LENGTH.
  ///@param length The number of bytes of the asset, or
  ///            \#UNKNOWN_LENGTH if it extends to the end of the file.
  ///@param extras additional details that can be used to interpret the
  ///            underlying file descriptor. May be null.
  AssetFileDescriptor.ctor_1(
      os.ParcelFileDescriptor fd, int startOffset, int length, os.Bundle extras)
      : super.fromRef(
            _ctor_1(fd.reference, startOffset, length, extras.reference));

  static final _getParcelFileDescriptor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetFileDescriptor_getParcelFileDescriptor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.ParcelFileDescriptor getParcelFileDescriptor()
  /// The AssetFileDescriptor contains its own ParcelFileDescriptor, which
  /// in addition to the normal FileDescriptor object also allows you to close
  /// the descriptor when you are done with it.
  os.ParcelFileDescriptor getParcelFileDescriptor() =>
      os.ParcelFileDescriptor.fromRef(_getParcelFileDescriptor(reference));

  static final _getFileDescriptor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetFileDescriptor_getFileDescriptor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.FileDescriptor getFileDescriptor()
  /// Returns the FileDescriptor that can be used to read the data in the
  /// file.
  jni.JlObject getFileDescriptor() =>
      jni.JlObject.fromRef(_getFileDescriptor(reference));

  static final _getStartOffset =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_AssetFileDescriptor_getStartOffset")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getStartOffset()
  /// Returns the byte offset where this asset entry's data starts.
  int getStartOffset() => _getStartOffset(reference);

  static final _getExtras = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetFileDescriptor_getExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getExtras()
  /// Returns any additional details that can be used to interpret the
  /// underlying file descriptor. May be null.
  os.Bundle getExtras() => os.Bundle.fromRef(_getExtras(reference));

  static final _getLength =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_AssetFileDescriptor_getLength")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getLength()
  /// Returns the total number of bytes of this asset entry's data.  May be
  /// \#UNKNOWN_LENGTH if the asset extends to the end of the file.
  /// If the AssetFileDescriptor was constructed with \#UNKNOWN_LENGTH,
  /// this will use ParcelFileDescriptor\#getStatSize() ParcelFileDescriptor.getStatSize() to find the total size of the file,
  /// returning that number if found or \#UNKNOWN_LENGTH if it could
  /// not be determined.
  ///@see \#getDeclaredLength()
  int getLength() => _getLength(reference);

  static final _getDeclaredLength =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_AssetFileDescriptor_getDeclaredLength")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getDeclaredLength()
  /// Return the actual number of bytes that were declared when the
  /// AssetFileDescriptor was constructed.  Will be
  /// \#UNKNOWN_LENGTH if the length was not declared, meaning data
  /// should be read to the end of the file.
  ///@see \#getDeclaredLength()
  int getDeclaredLength() => _getDeclaredLength(reference);

  static final _close =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_AssetFileDescriptor_close")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void close()
  /// Convenience for calling <code>getParcelFileDescriptor().close()</code>.
  void close() => _close(reference);

  static final _createInputStream = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetFileDescriptor_createInputStream")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.FileInputStream createInputStream()
  /// Create and return a new auto-close input stream for this asset.  This
  /// will either return a full asset AutoCloseInputStream, or
  /// an underlying ParcelFileDescriptor.AutoCloseInputStream ParcelFileDescriptor.AutoCloseInputStream depending on whether the
  /// the object represents a complete file or sub-section of a file.  You
  /// should only call this once for a particular asset.
  jni.JlObject createInputStream() =>
      jni.JlObject.fromRef(_createInputStream(reference));

  static final _createOutputStream = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetFileDescriptor_createOutputStream")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.FileOutputStream createOutputStream()
  /// Create and return a new auto-close output stream for this asset.  This
  /// will either return a full asset AutoCloseOutputStream, or
  /// an underlying ParcelFileDescriptor.AutoCloseOutputStream ParcelFileDescriptor.AutoCloseOutputStream depending on whether the
  /// the object represents a complete file or sub-section of a file.  You
  /// should only call this once for a particular asset.
  jni.JlObject createOutputStream() =>
      jni.JlObject.fromRef(_createOutputStream(reference));

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetFileDescriptor_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_AssetFileDescriptor_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_AssetFileDescriptor_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os.Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags);
}

/// An OutputStream you can create on a ParcelFileDescriptor, which will
/// take care of calling ParcelFileDescriptor\#close ParcelFileDescriptor.close() for you when the stream is closed.
class AssetFileDescriptor_AutoCloseOutputStream
    extends os.ParcelFileDescriptor_AutoCloseOutputStream {
  AssetFileDescriptor_AutoCloseOutputStream.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetFileDescriptor__AutoCloseOutputStream_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.res.AssetFileDescriptor fd)
  AssetFileDescriptor_AutoCloseOutputStream(AssetFileDescriptor fd)
      : super.fromRef(_ctor(fd.reference));

  static final _write = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_content_res_AssetFileDescriptor__AutoCloseOutputStream_write")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void write(byte[] buffer, int offset, int count)
  void write(jni.JlObject buffer, int offset, int count) =>
      _write(reference, buffer.reference, offset, count);

  static final _write_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetFileDescriptor__AutoCloseOutputStream_write_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void write(byte[] buffer)
  void write_1(jni.JlObject buffer) => _write_1(reference, buffer.reference);

  static final _write_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_AssetFileDescriptor__AutoCloseOutputStream_write_2")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void write(int oneByte)
  void write_2(int oneByte) => _write_2(reference, oneByte);
}

/// An InputStream you can create on a ParcelFileDescriptor, which will
/// take care of calling ParcelFileDescriptor\#close ParcelFileDescriptor.close() for you when the stream is closed.
class AssetFileDescriptor_AutoCloseInputStream
    extends os.ParcelFileDescriptor_AutoCloseInputStream {
  AssetFileDescriptor_AutoCloseInputStream.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetFileDescriptor__AutoCloseInputStream_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.res.AssetFileDescriptor fd)
  AssetFileDescriptor_AutoCloseInputStream(AssetFileDescriptor fd)
      : super.fromRef(_ctor(fd.reference));

  static final _available = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetFileDescriptor__AutoCloseInputStream_available")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int available()
  int available() => _available(reference);

  static final _read = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetFileDescriptor__AutoCloseInputStream_read")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int read()
  int read() => _read(reference);

  static final _read_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_content_res_AssetFileDescriptor__AutoCloseInputStream_read_1")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int read(byte[] buffer, int offset, int count)
  int read_1(jni.JlObject buffer, int offset, int count) =>
      _read_1(reference, buffer.reference, offset, count);

  static final _read_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetFileDescriptor__AutoCloseInputStream_read_2")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int read(byte[] buffer)
  int read_2(jni.JlObject buffer) => _read_2(reference, buffer.reference);

  static final _skip = jlookup<
              ffi.NativeFunction<
                  ffi.Int64 Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "android_content_res_AssetFileDescriptor__AutoCloseInputStream_skip")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public long skip(long count)
  int skip(int count) => _skip(reference, count);

  static final _mark = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_AssetFileDescriptor__AutoCloseInputStream_mark")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void mark(int readlimit)
  void mark(int readlimit) => _mark(reference, readlimit);

  static final _markSupported = jlookup<
              ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetFileDescriptor__AutoCloseInputStream_markSupported")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean markSupported()
  bool markSupported() => _markSupported(reference) != 0;

  static final _reset = jlookup<
              ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_AssetFileDescriptor__AutoCloseInputStream_reset")
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: synchronized public void reset()
  void reset() => _reset(reference);
}

/// This class describes all device configuration information that can
/// impact the resources the application retrieves.  This includes both
/// user-specified configuration options (locale list and scaling) as well
/// as device configurations (such as input modes, screen size and screen orientation).
/// You can acquire this object from Resources, using Resources\#getConfiguration. Thus, from an activity, you can get it by chaining the request
/// with android.app.Activity\#getResources:
///
/// <pre>Configuration config = getResources().getConfiguration();</pre>
class Configuration extends jni.JlObject {
  Configuration.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int COLOR_MODE_HDR_MASK
  /// Constant for \#colorMode: bits that encode the dynamic range of the screen.
  static const COLOR_MODE_HDR_MASK = 12;

  /// from: static public final int COLOR_MODE_HDR_NO
  /// Constant for \#colorMode: a \#COLOR_MODE_HDR_MASK value
  /// indicating that the screen is not HDR (low/standard dynamic range).
  /// Corresponds to the <code>-lowdr</code> resource qualifier.
  ///
  static const COLOR_MODE_HDR_NO = 4;

  /// from: static public final int COLOR_MODE_HDR_SHIFT
  /// Constant for \#colorMode: bits shift to get the screen dynamic range.
  static const COLOR_MODE_HDR_SHIFT = 2;

  /// from: static public final int COLOR_MODE_HDR_UNDEFINED
  /// Constant for \#colorMode: a \#COLOR_MODE_HDR_MASK value
  /// indicating that it is unknown whether or not the screen is HDR.
  static const COLOR_MODE_HDR_UNDEFINED = 0;

  /// from: static public final int COLOR_MODE_HDR_YES
  /// Constant for \#colorMode: a \#COLOR_MODE_HDR_MASK value
  /// indicating that the screen is HDR (dynamic range).
  /// Corresponds to the <code>-highdr</code> resource qualifier.
  ///
  static const COLOR_MODE_HDR_YES = 8;

  /// from: static public final int COLOR_MODE_UNDEFINED
  /// Constant for \#colorMode: a value indicating that the color mode is undefined
  static const COLOR_MODE_UNDEFINED = 0;

  /// from: static public final int COLOR_MODE_WIDE_COLOR_GAMUT_MASK
  /// Constant for \#colorMode: bits that encode whether the screen is wide gamut.
  static const COLOR_MODE_WIDE_COLOR_GAMUT_MASK = 3;

  /// from: static public final int COLOR_MODE_WIDE_COLOR_GAMUT_NO
  /// Constant for \#colorMode: a \#COLOR_MODE_WIDE_COLOR_GAMUT_MASK value
  /// indicating that the screen is not wide gamut.
  /// Corresponds to the <code>-nowidecg</code> resource qualifier.
  ///
  static const COLOR_MODE_WIDE_COLOR_GAMUT_NO = 1;

  /// from: static public final int COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED
  /// Constant for \#colorMode: a \#COLOR_MODE_WIDE_COLOR_GAMUT_MASK value
  /// indicating that it is unknown whether or not the screen is wide gamut.
  static const COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED = 0;

  /// from: static public final int COLOR_MODE_WIDE_COLOR_GAMUT_YES
  /// Constant for \#colorMode: a \#COLOR_MODE_WIDE_COLOR_GAMUT_MASK value
  /// indicating that the screen is wide gamut.
  /// Corresponds to the <code>-widecg</code> resource qualifier.
  ///
  static const COLOR_MODE_WIDE_COLOR_GAMUT_YES = 2;

  /// from: static public final android.os.Parcelable.Creator<android.content.res.Configuration> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_res_Configuration_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int DENSITY_DPI_UNDEFINED
  /// Default value for \#densityDpi indicating that no width
  /// has been specified.
  static const DENSITY_DPI_UNDEFINED = 0;

  /// from: static public final int HARDKEYBOARDHIDDEN_NO
  /// Constant for \#hardKeyboardHidden, value corresponding to the
  /// physical keyboard being exposed.
  static const HARDKEYBOARDHIDDEN_NO = 1;

  /// from: static public final int HARDKEYBOARDHIDDEN_UNDEFINED
  /// Constant for \#hardKeyboardHidden: a value indicating that no value has been set.
  static const HARDKEYBOARDHIDDEN_UNDEFINED = 0;

  /// from: static public final int HARDKEYBOARDHIDDEN_YES
  /// Constant for \#hardKeyboardHidden, value corresponding to the
  /// physical keyboard being hidden.
  static const HARDKEYBOARDHIDDEN_YES = 2;

  /// from: static public final int KEYBOARDHIDDEN_NO
  /// Constant for \#keyboardHidden, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#KeyboardAvailQualifier">keysexposed</a>
  /// resource qualifier.
  static const KEYBOARDHIDDEN_NO = 1;

  /// from: static public final int KEYBOARDHIDDEN_UNDEFINED
  /// Constant for \#keyboardHidden: a value indicating that no value has been set.
  static const KEYBOARDHIDDEN_UNDEFINED = 0;

  /// from: static public final int KEYBOARDHIDDEN_YES
  /// Constant for \#keyboardHidden, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#KeyboardAvailQualifier">keyshidden</a>
  /// resource qualifier.
  static const KEYBOARDHIDDEN_YES = 2;

  /// from: static public final int KEYBOARD_12KEY
  /// Constant for \#keyboard, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ImeQualifier">12key</a>
  /// resource qualifier.
  static const KEYBOARD_12KEY = 3;

  /// from: static public final int KEYBOARD_NOKEYS
  /// Constant for \#keyboard, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ImeQualifier">nokeys</a>
  /// resource qualifier.
  static const KEYBOARD_NOKEYS = 1;

  /// from: static public final int KEYBOARD_QWERTY
  /// Constant for \#keyboard, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ImeQualifier">qwerty</a>
  /// resource qualifier.
  static const KEYBOARD_QWERTY = 2;

  /// from: static public final int KEYBOARD_UNDEFINED
  /// Constant for \#keyboard: a value indicating that no value has been set.
  static const KEYBOARD_UNDEFINED = 0;

  /// from: static public final int MNC_ZERO
  /// Constant used to to represent MNC (Mobile Network Code) zero.
  /// 0 cannot be used, since it is used to represent an undefined MNC.
  static const MNC_ZERO = 65535;

  /// from: static public final int NAVIGATIONHIDDEN_NO
  /// Constant for \#navigationHidden, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NavAvailQualifier">navexposed</a>
  /// resource qualifier.
  static const NAVIGATIONHIDDEN_NO = 1;

  /// from: static public final int NAVIGATIONHIDDEN_UNDEFINED
  /// Constant for \#navigationHidden: a value indicating that no value has been set.
  static const NAVIGATIONHIDDEN_UNDEFINED = 0;

  /// from: static public final int NAVIGATIONHIDDEN_YES
  /// Constant for \#navigationHidden, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NavAvailQualifier">navhidden</a>
  /// resource qualifier.
  static const NAVIGATIONHIDDEN_YES = 2;

  /// from: static public final int NAVIGATION_DPAD
  /// Constant for \#navigation, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NavigationQualifier">dpad</a>
  /// resource qualifier.
  static const NAVIGATION_DPAD = 2;

  /// from: static public final int NAVIGATION_NONAV
  /// Constant for \#navigation, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NavigationQualifier">nonav</a>
  /// resource qualifier.
  static const NAVIGATION_NONAV = 1;

  /// from: static public final int NAVIGATION_TRACKBALL
  /// Constant for \#navigation, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NavigationQualifier">trackball</a>
  /// resource qualifier.
  static const NAVIGATION_TRACKBALL = 3;

  /// from: static public final int NAVIGATION_UNDEFINED
  /// Constant for \#navigation: a value indicating that no value has been set.
  static const NAVIGATION_UNDEFINED = 0;

  /// from: static public final int NAVIGATION_WHEEL
  /// Constant for \#navigation, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NavigationQualifier">wheel</a>
  /// resource qualifier.
  static const NAVIGATION_WHEEL = 4;

  /// from: static public final int ORIENTATION_LANDSCAPE
  /// Constant for \#orientation, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#OrientationQualifier">land</a>
  /// resource qualifier.
  static const ORIENTATION_LANDSCAPE = 2;

  /// from: static public final int ORIENTATION_PORTRAIT
  /// Constant for \#orientation, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#OrientationQualifier">port</a>
  /// resource qualifier.
  static const ORIENTATION_PORTRAIT = 1;

  /// from: static public final int ORIENTATION_SQUARE
  /// @deprecated Not currently supported or used.
  static const ORIENTATION_SQUARE = 3;

  /// from: static public final int ORIENTATION_UNDEFINED
  /// Constant for \#orientation: a value indicating that no value has been set.
  static const ORIENTATION_UNDEFINED = 0;

  /// from: static public final int SCREENLAYOUT_LAYOUTDIR_LTR
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_LAYOUTDIR_MASK
  /// value indicating that a layout dir has been set to LTR.
  static const SCREENLAYOUT_LAYOUTDIR_LTR = 64;

  /// from: static public final int SCREENLAYOUT_LAYOUTDIR_MASK
  /// Constant for \#screenLayout: bits that encode the layout direction.
  static const SCREENLAYOUT_LAYOUTDIR_MASK = 192;

  /// from: static public final int SCREENLAYOUT_LAYOUTDIR_RTL
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_LAYOUTDIR_MASK
  /// value indicating that a layout dir has been set to RTL.
  static const SCREENLAYOUT_LAYOUTDIR_RTL = 128;

  /// from: static public final int SCREENLAYOUT_LAYOUTDIR_SHIFT
  /// Constant for \#screenLayout: bits shift to get the layout direction.
  static const SCREENLAYOUT_LAYOUTDIR_SHIFT = 6;

  /// from: static public final int SCREENLAYOUT_LAYOUTDIR_UNDEFINED
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_LAYOUTDIR_MASK
  /// value indicating that no layout dir has been set.
  static const SCREENLAYOUT_LAYOUTDIR_UNDEFINED = 0;

  /// from: static public final int SCREENLAYOUT_LONG_MASK
  /// Constant for \#screenLayout: bits that encode the aspect ratio.
  static const SCREENLAYOUT_LONG_MASK = 48;

  /// from: static public final int SCREENLAYOUT_LONG_NO
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_LONG_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenAspectQualifier">notlong</a>
  /// resource qualifier.
  static const SCREENLAYOUT_LONG_NO = 16;

  /// from: static public final int SCREENLAYOUT_LONG_UNDEFINED
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_LONG_MASK
  /// value indicating that no size has been set.
  static const SCREENLAYOUT_LONG_UNDEFINED = 0;

  /// from: static public final int SCREENLAYOUT_LONG_YES
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_LONG_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenAspectQualifier">long</a>
  /// resource qualifier.
  static const SCREENLAYOUT_LONG_YES = 32;

  /// from: static public final int SCREENLAYOUT_ROUND_MASK
  /// Constant for \#screenLayout: bits that encode roundness of the screen.
  static const SCREENLAYOUT_ROUND_MASK = 768;

  /// from: static public final int SCREENLAYOUT_ROUND_NO
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_ROUND_MASK value indicating
  /// that the screen does not have a rounded shape.
  static const SCREENLAYOUT_ROUND_NO = 256;

  /// from: static public final int SCREENLAYOUT_ROUND_UNDEFINED
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_ROUND_MASK value indicating
  /// that it is unknown whether or not the screen has a round shape.
  static const SCREENLAYOUT_ROUND_UNDEFINED = 0;

  /// from: static public final int SCREENLAYOUT_ROUND_YES
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_ROUND_MASK value indicating
  /// that the screen has a rounded shape. Corners may not be visible to the user;
  /// developers should pay special attention to the android.view.WindowInsets delivered
  /// to views for more information about ensuring content is not obscured.
  ///
  /// Corresponds to the <code>-round</code> resource qualifier.
  ///
  static const SCREENLAYOUT_ROUND_YES = 512;

  /// from: static public final int SCREENLAYOUT_SIZE_LARGE
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_SIZE_MASK
  /// value indicating the screen is at least approximately 480x640 dp units,
  /// corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenSizeQualifier">large</a>
  /// resource qualifier.
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  static const SCREENLAYOUT_SIZE_LARGE = 3;

  /// from: static public final int SCREENLAYOUT_SIZE_MASK
  /// Constant for \#screenLayout: bits that encode the size.
  static const SCREENLAYOUT_SIZE_MASK = 15;

  /// from: static public final int SCREENLAYOUT_SIZE_NORMAL
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_SIZE_MASK
  /// value indicating the screen is at least approximately 320x470 dp units,
  /// corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenSizeQualifier">normal</a>
  /// resource qualifier.
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  static const SCREENLAYOUT_SIZE_NORMAL = 2;

  /// from: static public final int SCREENLAYOUT_SIZE_SMALL
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_SIZE_MASK
  /// value indicating the screen is at least approximately 320x426 dp units,
  /// corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenSizeQualifier">small</a>
  /// resource qualifier.
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  static const SCREENLAYOUT_SIZE_SMALL = 1;

  /// from: static public final int SCREENLAYOUT_SIZE_UNDEFINED
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_SIZE_MASK
  /// value indicating that no size has been set.
  static const SCREENLAYOUT_SIZE_UNDEFINED = 0;

  /// from: static public final int SCREENLAYOUT_SIZE_XLARGE
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_SIZE_MASK
  /// value indicating the screen is at least approximately 720x960 dp units,
  /// corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenSizeQualifier">xlarge</a>
  /// resource qualifier.
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  static const SCREENLAYOUT_SIZE_XLARGE = 4;

  /// from: static public final int SCREENLAYOUT_UNDEFINED
  /// Constant for \#screenLayout: a value indicating that screenLayout is undefined
  static const SCREENLAYOUT_UNDEFINED = 0;

  /// from: static public final int SCREEN_HEIGHT_DP_UNDEFINED
  /// Default value for \#screenHeightDp indicating that no width
  /// has been specified.
  static const SCREEN_HEIGHT_DP_UNDEFINED = 0;

  /// from: static public final int SCREEN_WIDTH_DP_UNDEFINED
  /// Default value for \#screenWidthDp indicating that no width
  /// has been specified.
  static const SCREEN_WIDTH_DP_UNDEFINED = 0;

  /// from: static public final int SMALLEST_SCREEN_WIDTH_DP_UNDEFINED
  /// Default value for \#smallestScreenWidthDp indicating that no width
  /// has been specified.
  static const SMALLEST_SCREEN_WIDTH_DP_UNDEFINED = 0;

  /// from: static public final int TOUCHSCREEN_FINGER
  /// Constant for \#touchscreen, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#TouchscreenQualifier">finger</a>
  /// resource qualifier.
  static const TOUCHSCREEN_FINGER = 3;

  /// from: static public final int TOUCHSCREEN_NOTOUCH
  /// Constant for \#touchscreen, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#TouchscreenQualifier">notouch</a>
  /// resource qualifier.
  static const TOUCHSCREEN_NOTOUCH = 1;

  /// from: static public final int TOUCHSCREEN_STYLUS
  /// @deprecated Not currently supported or used.
  static const TOUCHSCREEN_STYLUS = 2;

  /// from: static public final int TOUCHSCREEN_UNDEFINED
  /// Constant for \#touchscreen: a value indicating that no value has been set.
  static const TOUCHSCREEN_UNDEFINED = 0;

  /// from: static public final int UI_MODE_NIGHT_MASK
  /// Constant for \#uiMode: bits that encode the night mode.
  static const UI_MODE_NIGHT_MASK = 48;

  /// from: static public final int UI_MODE_NIGHT_NO
  /// Constant for \#uiMode: a \#UI_MODE_NIGHT_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NightQualifier">notnight</a>
  /// resource qualifier.
  static const UI_MODE_NIGHT_NO = 16;

  /// from: static public final int UI_MODE_NIGHT_UNDEFINED
  /// Constant for \#uiMode: a \#UI_MODE_NIGHT_MASK
  /// value indicating that no mode type has been set.
  static const UI_MODE_NIGHT_UNDEFINED = 0;

  /// from: static public final int UI_MODE_NIGHT_YES
  /// Constant for \#uiMode: a \#UI_MODE_NIGHT_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NightQualifier">night</a>
  /// resource qualifier.
  static const UI_MODE_NIGHT_YES = 32;

  /// from: static public final int UI_MODE_TYPE_APPLIANCE
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">appliance</a>
  /// resource qualifier.
  static const UI_MODE_TYPE_APPLIANCE = 5;

  /// from: static public final int UI_MODE_TYPE_CAR
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">car</a>
  /// resource qualifier.
  static const UI_MODE_TYPE_CAR = 3;

  /// from: static public final int UI_MODE_TYPE_DESK
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">desk</a>
  /// resource qualifier.
  static const UI_MODE_TYPE_DESK = 2;

  /// from: static public final int UI_MODE_TYPE_MASK
  /// Constant for \#uiMode: bits that encode the mode type.
  static const UI_MODE_TYPE_MASK = 15;

  /// from: static public final int UI_MODE_TYPE_NORMAL
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">no
  /// UI mode</a> resource qualifier specified.
  static const UI_MODE_TYPE_NORMAL = 1;

  /// from: static public final int UI_MODE_TYPE_TELEVISION
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">television</a>
  /// resource qualifier.
  static const UI_MODE_TYPE_TELEVISION = 4;

  /// from: static public final int UI_MODE_TYPE_UNDEFINED
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value indicating that no mode type has been set.
  static const UI_MODE_TYPE_UNDEFINED = 0;

  /// from: static public final int UI_MODE_TYPE_VR_HEADSET
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">vrheadset</a>
  /// resource qualifier.
  static const UI_MODE_TYPE_VR_HEADSET = 7;

  /// from: static public final int UI_MODE_TYPE_WATCH
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">watch</a>
  /// resource qualifier.
  static const UI_MODE_TYPE_WATCH = 6;

  /// from: public int colorMode
  /// Bit mask of color capabilities of the screen. Currently there are two fields:
  /// The \#COLOR_MODE_WIDE_COLOR_GAMUT_MASK bits define the color gamut of
  /// the screen. They may be one of
  /// \#COLOR_MODE_WIDE_COLOR_GAMUT_NO or \#COLOR_MODE_WIDE_COLOR_GAMUT_YES.
  ///
  ///
  /// The \#COLOR_MODE_HDR_MASK defines the dynamic range of the screen. They may be
  /// one of \#COLOR_MODE_HDR_NO or \#COLOR_MODE_HDR_YES.
  ///
  ///
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  ///
  static final _getcolorMode = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_Configuration_colorMode")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get colorMode => _getcolorMode(reference);
  static final _setcolorMode = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_res_Configuration_colorMode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set colorMode(int value) => _setcolorMode(reference, value);

  /// from: public int densityDpi
  /// The target screen density being rendered to,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#DensityQualifier">density</a>
  /// resource qualifier.  Set to
  /// \#DENSITY_DPI_UNDEFINED if no density is specified.
  static final _getdensityDpi = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_Configuration_densityDpi")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get densityDpi => _getdensityDpi(reference);
  static final _setdensityDpi = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_res_Configuration_densityDpi")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set densityDpi(int value) => _setdensityDpi(reference, value);

  /// from: public float fontScale
  /// Current user preference for the scaling factor for fonts, relative
  /// to the base density scaling.
  static final _getfontScale = jlookup<
          ffi.NativeFunction<
              ffi.Float Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_Configuration_fontScale")
      .asFunction<
          double Function(
    ffi.Pointer<ffi.Void>,
  )>();
  double get fontScale => _getfontScale(reference);
  static final _setfontScale = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>>(
          "set_android_content_res_Configuration_fontScale")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, double)>();
  set fontScale(double value) => _setfontScale(reference, value);

  /// from: public int hardKeyboardHidden
  /// A flag indicating whether the hard keyboard has been hidden.  This will
  /// be set on a device with a mechanism to hide the keyboard from the
  /// user, when that mechanism is closed.  One of:
  /// \#HARDKEYBOARDHIDDEN_NO, \#HARDKEYBOARDHIDDEN_YES.
  static final _gethardKeyboardHidden = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_Configuration_hardKeyboardHidden")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get hardKeyboardHidden => _gethardKeyboardHidden(reference);
  static final _sethardKeyboardHidden = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_res_Configuration_hardKeyboardHidden")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set hardKeyboardHidden(int value) => _sethardKeyboardHidden(reference, value);

  /// from: public int keyboard
  /// The kind of keyboard attached to the device.
  /// One of: \#KEYBOARD_NOKEYS, \#KEYBOARD_QWERTY,
  /// \#KEYBOARD_12KEY.
  static final _getkeyboard = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_Configuration_keyboard")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get keyboard => _getkeyboard(reference);
  static final _setkeyboard = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_res_Configuration_keyboard")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set keyboard(int value) => _setkeyboard(reference, value);

  /// from: public int keyboardHidden
  /// A flag indicating whether any keyboard is available.  Unlike
  /// \#hardKeyboardHidden, this also takes into account a soft
  /// keyboard, so if the hard keyboard is hidden but there is soft
  /// keyboard available, it will be set to NO.  Value is one of:
  /// \#KEYBOARDHIDDEN_NO, \#KEYBOARDHIDDEN_YES.
  static final _getkeyboardHidden = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_Configuration_keyboardHidden")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get keyboardHidden => _getkeyboardHidden(reference);
  static final _setkeyboardHidden = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_res_Configuration_keyboardHidden")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set keyboardHidden(int value) => _setkeyboardHidden(reference, value);

  /// from: public java.util.Locale locale
  /// Current user preference for the locale, corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#LocaleQualifier">locale</a>
  /// resource qualifier.
  ///@deprecated Do not set or read this directly. Use \#getLocales() and
  /// \#setLocales(LocaleList). If only the primary locale is needed,
  /// <code>getLocales().get(0)</code> is now the preferred accessor.
  static final _getlocale = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_Configuration_locale")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get locale => jni.JlObject.fromRef(_getlocale(reference));
  static final _setlocale = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_res_Configuration_locale")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set locale(jni.JlObject value) => _setlocale(reference, value.reference);

  /// from: public int mcc
  /// IMSI MCC (Mobile Country Code), corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#MccQualifier">mcc</a>
  /// resource qualifier.  0 if undefined.
  static final _getmcc = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_Configuration_mcc")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get mcc => _getmcc(reference);
  static final _setmcc = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_res_Configuration_mcc")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set mcc(int value) => _setmcc(reference, value);

  /// from: public int mnc
  /// IMSI MNC (Mobile Network Code), corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#MccQualifier">mnc</a>
  /// resource qualifier.  0 if undefined. Note that the actual MNC may be 0; in order to check
  /// for this use the \#MNC_ZERO symbol.
  static final _getmnc = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_Configuration_mnc")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get mnc => _getmnc(reference);
  static final _setmnc = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_res_Configuration_mnc")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set mnc(int value) => _setmnc(reference, value);

  /// from: public int navigation
  /// The kind of navigation method available on the device.
  /// One of: \#NAVIGATION_NONAV, \#NAVIGATION_DPAD,
  /// \#NAVIGATION_TRACKBALL, \#NAVIGATION_WHEEL.
  static final _getnavigation = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_Configuration_navigation")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get navigation => _getnavigation(reference);
  static final _setnavigation = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_res_Configuration_navigation")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set navigation(int value) => _setnavigation(reference, value);

  /// from: public int navigationHidden
  /// A flag indicating whether any 5-way or DPAD navigation available.
  /// This will be set on a device with a mechanism to hide the navigation
  /// controls from the user, when that mechanism is closed.  One of:
  /// \#NAVIGATIONHIDDEN_NO, \#NAVIGATIONHIDDEN_YES.
  static final _getnavigationHidden = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_Configuration_navigationHidden")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get navigationHidden => _getnavigationHidden(reference);
  static final _setnavigationHidden = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_res_Configuration_navigationHidden")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set navigationHidden(int value) => _setnavigationHidden(reference, value);

  /// from: public int orientation
  /// Overall orientation of the screen.  May be one of
  /// \#ORIENTATION_LANDSCAPE, \#ORIENTATION_PORTRAIT.
  static final _getorientation = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_Configuration_orientation")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get orientation => _getorientation(reference);
  static final _setorientation = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_res_Configuration_orientation")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set orientation(int value) => _setorientation(reference, value);

  /// from: public int screenHeightDp
  /// The current height of the available screen space, in dp units,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenHeightQualifier">screen
  /// height</a> resource qualifier.  Set to
  /// \#SCREEN_HEIGHT_DP_UNDEFINED if no height is specified.
  static final _getscreenHeightDp = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_Configuration_screenHeightDp")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get screenHeightDp => _getscreenHeightDp(reference);
  static final _setscreenHeightDp = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_res_Configuration_screenHeightDp")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set screenHeightDp(int value) => _setscreenHeightDp(reference, value);

  /// from: public int screenLayout
  /// Bit mask of overall layout of the screen.  Currently there are four
  /// fields:
  /// The \#SCREENLAYOUT_SIZE_MASK bits define the overall size
  /// of the screen.  They may be one of
  /// \#SCREENLAYOUT_SIZE_SMALL, \#SCREENLAYOUT_SIZE_NORMAL,
  /// \#SCREENLAYOUT_SIZE_LARGE, or \#SCREENLAYOUT_SIZE_XLARGE.
  ///
  ///
  /// The \#SCREENLAYOUT_LONG_MASK defines whether the screen
  /// is wider/taller than normal.  They may be one of
  /// \#SCREENLAYOUT_LONG_NO or \#SCREENLAYOUT_LONG_YES.
  ///
  ///
  /// The \#SCREENLAYOUT_LAYOUTDIR_MASK defines whether the screen layout
  /// is either LTR or RTL.  They may be one of
  /// \#SCREENLAYOUT_LAYOUTDIR_LTR or \#SCREENLAYOUT_LAYOUTDIR_RTL.
  ///
  ///
  /// The \#SCREENLAYOUT_ROUND_MASK defines whether the screen has a rounded
  /// shape. They may be one of \#SCREENLAYOUT_ROUND_NO or \#SCREENLAYOUT_ROUND_YES.
  ///
  ///
  ///
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  ///
  static final _getscreenLayout = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_Configuration_screenLayout")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get screenLayout => _getscreenLayout(reference);
  static final _setscreenLayout = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_res_Configuration_screenLayout")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set screenLayout(int value) => _setscreenLayout(reference, value);

  /// from: public int screenWidthDp
  /// The current width of the available screen space, in dp units,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenWidthQualifier">screen
  /// width</a> resource qualifier.  Set to
  /// \#SCREEN_WIDTH_DP_UNDEFINED if no width is specified.
  static final _getscreenWidthDp = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_Configuration_screenWidthDp")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get screenWidthDp => _getscreenWidthDp(reference);
  static final _setscreenWidthDp = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_res_Configuration_screenWidthDp")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set screenWidthDp(int value) => _setscreenWidthDp(reference, value);

  /// from: public int smallestScreenWidthDp
  /// The smallest screen size an application will see in normal operation,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#SmallestScreenWidthQualifier">smallest
  /// screen width</a> resource qualifier.
  /// This is the smallest value of both screenWidthDp and screenHeightDp
  /// in both portrait and landscape.  Set to
  /// \#SMALLEST_SCREEN_WIDTH_DP_UNDEFINED if no width is specified.
  static final _getsmallestScreenWidthDp = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_Configuration_smallestScreenWidthDp")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get smallestScreenWidthDp => _getsmallestScreenWidthDp(reference);
  static final _setsmallestScreenWidthDp = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_res_Configuration_smallestScreenWidthDp")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set smallestScreenWidthDp(int value) =>
      _setsmallestScreenWidthDp(reference, value);

  /// from: public int touchscreen
  /// The kind of touch screen attached to the device.
  /// One of: \#TOUCHSCREEN_NOTOUCH, \#TOUCHSCREEN_FINGER.
  static final _gettouchscreen = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_Configuration_touchscreen")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get touchscreen => _gettouchscreen(reference);
  static final _settouchscreen = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_content_res_Configuration_touchscreen")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set touchscreen(int value) => _settouchscreen(reference, value);

  /// from: public int uiMode
  /// Bit mask of the ui mode.  Currently there are two fields:
  /// The \#UI_MODE_TYPE_MASK bits define the overall ui mode of the
  /// device. They may be one of \#UI_MODE_TYPE_UNDEFINED,
  /// \#UI_MODE_TYPE_NORMAL, \#UI_MODE_TYPE_DESK,
  /// \#UI_MODE_TYPE_CAR, \#UI_MODE_TYPE_TELEVISION,
  /// \#UI_MODE_TYPE_APPLIANCE, \#UI_MODE_TYPE_WATCH,
  /// or \#UI_MODE_TYPE_VR_HEADSET.
  ///
  /// The \#UI_MODE_NIGHT_MASK defines whether the screen
  /// is in a special mode. They may be one of \#UI_MODE_NIGHT_UNDEFINED,
  /// \#UI_MODE_NIGHT_NO or \#UI_MODE_NIGHT_YES.
  static final _getuiMode = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_res_Configuration_uiMode")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get uiMode => _getuiMode(reference);
  static final _setuiMode = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_content_res_Configuration_uiMode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set uiMode(int value) => _setuiMode(reference, value);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_res_Configuration_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Construct an invalid Configuration. This state is only suitable for constructing a
  /// Configuration delta that will be applied to some valid Configuration object. In order to
  /// create a valid standalone Configuration, you must call \#setToDefaults.
  ///
  ///
  /// Example:
  ///
  /// <pre class="prettyprint">
  ///     Configuration validConfig = new Configuration();
  ///     validConfig.setToDefaults();
  ///
  ///     Configuration deltaOnlyConfig = new Configuration();
  ///     deltaOnlyConfig.orientation = Configuration.ORIENTATION_LANDSCAPE;
  ///
  ///     validConfig.updateFrom(deltaOnlyConfig);
  /// </pre>
  Configuration() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Configuration_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.res.Configuration o)
  /// Makes a deep copy suitable for modification.
  Configuration.ctor_1(Configuration o) : super.fromRef(_ctor_1(o.reference));

  static final _isLayoutSizeAtLeast = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_Configuration_isLayoutSizeAtLeast")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean isLayoutSizeAtLeast(int size)
  /// Check if the Configuration's current \#screenLayout is at
  /// least the given size.
  ///@param size The desired size, either \#SCREENLAYOUT_SIZE_SMALL,
  /// \#SCREENLAYOUT_SIZE_NORMAL, \#SCREENLAYOUT_SIZE_LARGE, or
  /// \#SCREENLAYOUT_SIZE_XLARGE.
  ///@return Returns true if the current screen layout size is at least
  /// the given size.
  bool isLayoutSizeAtLeast(int size) =>
      _isLayoutSizeAtLeast(reference, size) != 0;

  static final _setTo = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Configuration_setTo")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTo(android.content.res.Configuration o)
  /// Sets the fields in this object to those in the given Configuration.
  ///@param o The Configuration object used to set the values of this Configuration's fields.
  void setTo(Configuration o) => _setTo(reference, o.reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Configuration_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _setToDefaults =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_Configuration_setToDefaults")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void setToDefaults()
  /// Set this object to the system defaults.
  void setToDefaults() => _setToDefaults(reference);

  static final _updateFrom = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Configuration_updateFrom")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int updateFrom(android.content.res.Configuration delta)
  /// Copies the fields from delta into this Configuration object, keeping
  /// track of which ones have changed. Any undefined fields in {@code delta}
  /// are ignored and not copied in to the current Configuration.
  ///@param delta This value must never be {@code null}.
  ///@return a bit mask of the changed fields, as per \#diff
  ///
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  int updateFrom(Configuration delta) =>
      _updateFrom(reference, delta.reference);

  static final _diff = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Configuration_diff")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int diff(android.content.res.Configuration delta)
  /// Return a bit mask of the differences between this Configuration
  /// object and the given one.  Does not change the values of either.  Any
  /// undefined fields in <var>delta</var> are ignored.
  ///@return Returns a bit mask indicating which configuration
  /// values has changed, containing any combination of
  /// android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE PackageManager.ActivityInfo.CONFIG_FONT_SCALE,
  /// android.content.pm.ActivityInfo\#CONFIG_MCC PackageManager.ActivityInfo.CONFIG_MCC,
  /// android.content.pm.ActivityInfo\#CONFIG_MNC PackageManager.ActivityInfo.CONFIG_MNC,
  /// android.content.pm.ActivityInfo\#CONFIG_LOCALE PackageManager.ActivityInfo.CONFIG_LOCALE,
  /// android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN PackageManager.ActivityInfo.CONFIG_TOUCHSCREEN,
  /// android.content.pm.ActivityInfo\#CONFIG_KEYBOARD PackageManager.ActivityInfo.CONFIG_KEYBOARD,
  /// android.content.pm.ActivityInfo\#CONFIG_NAVIGATION PackageManager.ActivityInfo.CONFIG_NAVIGATION,
  /// android.content.pm.ActivityInfo\#CONFIG_ORIENTATION PackageManager.ActivityInfo.CONFIG_ORIENTATION,
  /// android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT PackageManager.ActivityInfo.CONFIG_SCREEN_LAYOUT, or
  /// android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE PackageManager.ActivityInfo.CONFIG_SCREEN_SIZE, or
  /// android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE PackageManager.ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE.
  /// android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION PackageManager.ActivityInfo.CONFIG_LAYOUT_DIRECTION.
  int diff(Configuration delta) => _diff(reference, delta.reference);

  static final _needNewResources =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Int32, ffi.Int32)>>(
              "android_content_res_Configuration_needNewResources")
          .asFunction<int Function(int, int)>();

  /// from: static public boolean needNewResources(int configChanges, int interestingChanges)
  /// Determines if a new resource needs to be loaded from the bit set of
  /// configuration changes returned by \#updateFrom(Configuration).
  ///@param configChanges the mask of changes configurations as returned by
  ///                      \#updateFrom(Configuration)
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  ///@param interestingChanges the configuration changes that the resource
  ///                           can handle as given in
  ///                           android.util.TypedValue\#changingConfigurations
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  ///@return {@code true} if the resource needs to be loaded, {@code false}
  ///         otherwise
  static bool needNewResources(int configChanges, int interestingChanges) =>
      _needNewResources(configChanges, interestingChanges) != 0;

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_Configuration_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  /// Parcelable methods
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_Configuration_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _readFromParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Configuration_readFromParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(os.Parcel source) =>
      _readFromParcel(reference, source.reference);

  static final _compareTo = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Configuration_compareTo")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int compareTo(android.content.res.Configuration that)
  int compareTo(Configuration that) => _compareTo(reference, that.reference);

  static final _equals_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Configuration_equals_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(android.content.res.Configuration that)
  bool equals_1(Configuration that) =>
      _equals_1(reference, that.reference) != 0;

  static final _equals_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Configuration_equals_2")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object that)
  bool equals_2(jni.JlObject that) => _equals_2(reference, that.reference) != 0;

  static final _hashCode_1 =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_Configuration_hashCode_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode_1() => _hashCode_1(reference);

  static final _getLocales = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Configuration_getLocales")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.LocaleList getLocales()
  /// Get the locale list. This is the preferred way for getting the locales (instead of using
  /// the direct accessor to \#locale, which would only provide the primary locale).
  ///@return The locale list.
  ///
  /// This value will never be {@code null}.
  os.LocaleList getLocales() => os.LocaleList.fromRef(_getLocales(reference));

  static final _setLocales = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Configuration_setLocales")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setLocales(android.os.LocaleList locales)
  /// Set the locale list. This is the preferred way for setting up the locales (instead of using
  /// the direct accessor or \#setLocale(Locale)). This will also set the layout direction
  /// according to the first locale in the list.
  ///
  /// Note that the layout direction will always come from the first locale in the locale list,
  /// even if the locale is not supported by the resources (the resources may only support
  /// another locale further down the list which has a different direction).
  ///@param locales The locale list. If null, an empty LocaleList will be assigned.
  ///
  /// This value may be {@code null}.
  void setLocales(os.LocaleList locales) =>
      _setLocales(reference, locales.reference);

  static final _setLocale = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Configuration_setLocale")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setLocale(java.util.Locale loc)
  /// Set the locale list to a list of just one locale. This will also set the layout direction
  /// according to the locale.
  ///
  /// Note that after this is run, calling <code>.equals()</code> on the input locale and the
  /// \#locale attribute would return <code>true</code> if they are not null, but there is
  /// no guarantee that they would be the same object.
  ///
  /// See also the note about layout direction in \#setLocales(LocaleList).
  ///@param loc The locale. Can be null.
  ///
  /// This value may be {@code null}.
  void setLocale(jni.JlObject loc) => _setLocale(reference, loc.reference);

  static final _getLayoutDirection =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_Configuration_getLayoutDirection")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLayoutDirection()
  /// Return the layout direction. Will be either View\#LAYOUT_DIRECTION_LTR or
  /// View\#LAYOUT_DIRECTION_RTL.
  ///@return Returns View\#LAYOUT_DIRECTION_RTL if the configuration
  /// is \#SCREENLAYOUT_LAYOUTDIR_RTL, otherwise View\#LAYOUT_DIRECTION_LTR.
  int getLayoutDirection() => _getLayoutDirection(reference);

  static final _setLayoutDirection = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Configuration_setLayoutDirection")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setLayoutDirection(java.util.Locale loc)
  /// Set the layout direction from a Locale.
  ///@param loc The Locale. If null will set the layout direction to
  /// View\#LAYOUT_DIRECTION_LTR. If not null will set it to the layout direction
  /// corresponding to the Locale.
  ///@see View\#LAYOUT_DIRECTION_LTR
  ///@see View\#LAYOUT_DIRECTION_RTL
  void setLayoutDirection(jni.JlObject loc) =>
      _setLayoutDirection(reference, loc.reference);

  static final _isScreenRound =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_Configuration_isScreenRound")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isScreenRound()
  /// Return whether the screen has a round shape. Apps may choose to change styling based
  /// on this property, such as the alignment or layout of text or informational icons.
  ///@return true if the screen is rounded, false otherwise
  bool isScreenRound() => _isScreenRound(reference) != 0;

  static final _isScreenWideColorGamut =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_Configuration_isScreenWideColorGamut")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isScreenWideColorGamut()
  /// Return whether the screen has a wide color gamut and wide color gamut rendering
  /// is supported by this device.
  ///
  /// When true, it implies the screen is colorspace aware but not
  /// necessarily color-managed. The final colors may still be changed by the
  /// screen depending on user settings.
  ///@return true if the screen has a wide color gamut and wide color gamut rendering
  /// is supported, false otherwise
  bool isScreenWideColorGamut() => _isScreenWideColorGamut(reference) != 0;

  static final _isScreenHdr =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_Configuration_isScreenHdr")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isScreenHdr()
  /// Return whether the screen has a high dynamic range.
  ///@return true if the screen has a high dynamic range, false otherwise
  bool isScreenHdr() => _isScreenHdr(reference) != 0;
}

/// Container for an array of values that were retrieved with
/// Resources.Theme\#obtainStyledAttributes(AttributeSet, int[], int, int)
/// or Resources\#obtainAttributes.  Be
/// sure to call \#recycle when done with them.
///
/// The indices used to retrieve values from this structure correspond to
/// the positions of the attributes given to obtainStyledAttributes.
class TypedArray extends jni.JlObject {
  TypedArray.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_res_TypedArray_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.content.res.Resources resources)
  /// @hide
  TypedArray(Resources resources) : super.fromRef(_ctor(resources.reference));

  static final _length =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_TypedArray_length")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int length()
  /// Returns the number of values in this array.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  int length() => _length(reference);

  static final _getIndexCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_TypedArray_getIndexCount")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getIndexCount()
  /// Returns the number of indices in the array that actually have data. Attributes with a value
  /// of @empty are included, as this is an explicit indicator.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  int getIndexCount() => _getIndexCount(reference);

  static final _getIndex = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_TypedArray_getIndex")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getIndex(int at)
  /// Returns an index in the array that has data. Attributes with a value of @empty are included,
  /// as this is an explicit indicator.
  ///@param at The index you would like to returned, ranging from 0 to
  ///           \#getIndexCount().
  ///@return The index at the given offset, which can be used with
  ///         \#getValue and related APIs.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  int getIndex(int at) => _getIndex(reference, at);

  static final _getResources = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_TypedArray_getResources")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.Resources getResources()
  /// Returns the Resources object this array was loaded from.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  Resources getResources() => Resources.fromRef(_getResources(reference));

  static final _getText = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_TypedArray_getText")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.CharSequence getText(int index)
  /// Retrieves the styled string value for the attribute at <var>index</var>.
  ///
  /// If the attribute is not a string, this method will attempt to coerce
  /// it to a string.
  ///@param index Index of attribute to retrieve.
  ///@return CharSequence holding string data. May be styled. Returns
  ///         {@code null} if the attribute is not defined or could not be
  ///         coerced to a string.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  jni.JlObject getText(int index) =>
      jni.JlObject.fromRef(_getText(reference, index));

  static final _getString = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_TypedArray_getString")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getString(int index)
  /// Retrieves the string value for the attribute at <var>index</var>.
  ///
  /// If the attribute is not a string, this method will attempt to coerce
  /// it to a string.
  ///@param index Index of attribute to retrieve.
  ///@return String holding string data. Any styling information is removed.
  ///         Returns {@code null} if the attribute is not defined or could
  ///         not be coerced to a string.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  jni.JlString getString(int index) =>
      jni.JlString.fromRef(_getString(reference, index));

  static final _getNonResourceString = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_TypedArray_getNonResourceString")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getNonResourceString(int index)
  /// Retrieves the string value for the attribute at <var>index</var>, but
  /// only if that string comes from an immediate value in an XML file.  That
  /// is, this does not allow references to string resources, string
  /// attributes, or conversions from other types.  As such, this method
  /// will only return strings for TypedArray objects that come from
  /// attributes in an XML file.
  ///@param index Index of attribute to retrieve.
  ///@return String holding string data. Any styling information is removed.
  ///         Returns {@code null} if the attribute is not defined or is not
  ///         an immediate string value.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  jni.JlString getNonResourceString(int index) =>
      jni.JlString.fromRef(_getNonResourceString(reference, index));

  static final _getBoolean = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Uint8)>>("android_content_res_TypedArray_getBoolean")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public boolean getBoolean(int index, boolean defValue)
  /// Retrieve the boolean value for the attribute at <var>index</var>.
  ///
  /// If the attribute is an integer value, this method will return whether
  /// it is equal to zero. If the attribute is not a boolean or integer value,
  /// this method will attempt to coerce it to an integer using
  /// Integer\#decode(String) and return whether it is equal to zero.
  ///@param index Index of attribute to retrieve.
  ///@param defValue Value to return if the attribute is not defined or
  ///                 cannot be coerced to an integer.
  ///@return Boolean value of the attribute, or defValue if the attribute was
  ///         not defined or could not be coerced to an integer.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  bool getBoolean(int index, bool defValue) =>
      _getBoolean(reference, index, defValue ? 1 : 0) != 0;

  static final _getInt = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_content_res_TypedArray_getInt")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int getInt(int index, int defValue)
  /// Retrieve the integer value for the attribute at <var>index</var>.
  ///
  /// If the attribute is not an integer, this method will attempt to coerce
  /// it to an integer using Integer\#decode(String).
  ///@param index Index of attribute to retrieve.
  ///@param defValue Value to return if the attribute is not defined or
  ///                 cannot be coerced to an integer.
  ///@return Integer value of the attribute, or defValue if the attribute was
  ///         not defined or could not be coerced to an integer.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  int getInt(int index, int defValue) => _getInt(reference, index, defValue);

  static final _getFloat = jlookup<
          ffi.NativeFunction<
              ffi.Float Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Float)>>("android_content_res_TypedArray_getFloat")
      .asFunction<double Function(ffi.Pointer<ffi.Void>, int, double)>();

  /// from: public float getFloat(int index, float defValue)
  /// Retrieve the float value for the attribute at <var>index</var>.
  ///
  /// If the attribute is not a float or an integer, this method will attempt
  /// to coerce it to a float using Float\#parseFloat(String).
  ///@param index Index of attribute to retrieve.
  ///@return Attribute float value, or defValue if the attribute was
  ///         not defined or could not be coerced to a float.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  double getFloat(int index, double defValue) =>
      _getFloat(reference, index, defValue);

  static final _getColor = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_content_res_TypedArray_getColor")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int getColor(int index, int defValue)
  /// Retrieve the color value for the attribute at <var>index</var>.  If
  /// the attribute references a color resource holding a complex
  /// android.content.res.ColorStateList, then the default color from
  /// the set is returned.
  ///
  /// This method will throw an exception if the attribute is defined but is
  /// not an integer color or color state list.
  ///@param index Index of attribute to retrieve.
  ///@param defValue Value to return if the attribute is not defined or
  ///                 not a resource.
  ///@return Attribute color value, or defValue if not defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not an integer color or color state list.
  int getColor(int index, int defValue) =>
      _getColor(reference, index, defValue);

  static final _getColorStateList = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_TypedArray_getColorStateList")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.res.ColorStateList getColorStateList(int index)
  /// Retrieve the ColorStateList for the attribute at <var>index</var>.
  /// The value may be either a single solid color or a reference to
  /// a color or complex android.content.res.ColorStateList
  /// description.
  ///
  /// This method will return {@code null} if the attribute is not defined or
  /// is not an integer color or color state list.
  ///@param index Index of attribute to retrieve.
  ///@return ColorStateList for the attribute, or {@code null} if not
  ///         defined.
  ///@throws RuntimeException if the attribute if the TypedArray has already
  ///         been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not an integer color or color state list.
  ColorStateList getColorStateList(int index) =>
      ColorStateList.fromRef(_getColorStateList(reference, index));

  static final _getInteger = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_content_res_TypedArray_getInteger")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int getInteger(int index, int defValue)
  /// Retrieve the integer value for the attribute at <var>index</var>.
  ///
  /// Unlike \#getInt(int, int), this method will throw an exception if
  /// the attribute is defined but is not an integer.
  ///@param index Index of attribute to retrieve.
  ///@param defValue Value to return if the attribute is not defined or
  ///                 not a resource.
  ///@return Attribute integer value, or defValue if not defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not an integer.
  int getInteger(int index, int defValue) =>
      _getInteger(reference, index, defValue);

  static final _getDimension = jlookup<
          ffi.NativeFunction<
              ffi.Float Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Float)>>("android_content_res_TypedArray_getDimension")
      .asFunction<double Function(ffi.Pointer<ffi.Void>, int, double)>();

  /// from: public float getDimension(int index, float defValue)
  /// Retrieve a dimensional unit attribute at <var>index</var>. Unit
  /// conversions are based on the current DisplayMetrics
  /// associated with the resources this TypedArray object
  /// came from.
  ///
  /// This method will throw an exception if the attribute is defined but is
  /// not a dimension.
  ///@param index Index of attribute to retrieve.
  ///@param defValue Value to return if the attribute is not defined or
  ///                 not a resource.
  ///@return Attribute dimension value multiplied by the appropriate
  ///         metric, or defValue if not defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not an integer.
  ///@see \#getDimensionPixelOffset
  ///@see \#getDimensionPixelSize
  double getDimension(int index, double defValue) =>
      _getDimension(reference, index, defValue);

  static final _getDimensionPixelOffset = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_content_res_TypedArray_getDimensionPixelOffset")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int getDimensionPixelOffset(int index, int defValue)
  /// Retrieve a dimensional unit attribute at <var>index</var> for use
  /// as an offset in raw pixels.  This is the same as
  /// \#getDimension, except the returned value is converted to
  /// integer pixels for you.  An offset conversion involves simply
  /// truncating the base value to an integer.
  ///
  /// This method will throw an exception if the attribute is defined but is
  /// not a dimension.
  ///@param index Index of attribute to retrieve.
  ///@param defValue Value to return if the attribute is not defined or
  ///                 not a resource.
  ///@return Attribute dimension value multiplied by the appropriate
  ///         metric and truncated to integer pixels, or defValue if not defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not an integer.
  ///@see \#getDimension
  ///@see \#getDimensionPixelSize
  int getDimensionPixelOffset(int index, int defValue) =>
      _getDimensionPixelOffset(reference, index, defValue);

  static final _getDimensionPixelSize = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_content_res_TypedArray_getDimensionPixelSize")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int getDimensionPixelSize(int index, int defValue)
  /// Retrieve a dimensional unit attribute at <var>index</var> for use
  /// as a size in raw pixels.  This is the same as
  /// \#getDimension, except the returned value is converted to
  /// integer pixels for use as a size.  A size conversion involves
  /// rounding the base value, and ensuring that a non-zero base value
  /// is at least one pixel in size.
  ///
  /// This method will throw an exception if the attribute is defined but is
  /// not a dimension.
  ///@param index Index of attribute to retrieve.
  ///@param defValue Value to return if the attribute is not defined or
  ///                 not a resource.
  ///@return Attribute dimension value multiplied by the appropriate
  ///         metric and truncated to integer pixels, or defValue if not defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not a dimension.
  ///@see \#getDimension
  ///@see \#getDimensionPixelOffset
  int getDimensionPixelSize(int index, int defValue) =>
      _getDimensionPixelSize(reference, index, defValue);

  static final _getLayoutDimension = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_res_TypedArray_getLayoutDimension")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public int getLayoutDimension(int index, java.lang.String name)
  /// Special version of \#getDimensionPixelSize for retrieving
  /// android.view.ViewGroup's layout_width and layout_height
  /// attributes.  This is only here for performance reasons; applications
  /// should use \#getDimensionPixelSize.
  ///
  /// This method will throw an exception if the attribute is defined but is
  /// not a dimension or integer (enum).
  ///@param index Index of the attribute to retrieve.
  ///@param name Textual name of attribute for error reporting.
  ///@return Attribute dimension value multiplied by the appropriate
  ///         metric and truncated to integer pixels.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not a dimension or integer (enum).
  int getLayoutDimension(int index, jni.JlString name) =>
      _getLayoutDimension(reference, index, name.reference);

  static final _getLayoutDimension_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_content_res_TypedArray_getLayoutDimension_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int getLayoutDimension(int index, int defValue)
  /// Special version of \#getDimensionPixelSize for retrieving
  /// android.view.ViewGroup's layout_width and layout_height
  /// attributes.  This is only here for performance reasons; applications
  /// should use \#getDimensionPixelSize.
  ///@param index Index of the attribute to retrieve.
  ///@param defValue The default value to return if this attribute is not
  ///                 default or contains the wrong type of data.
  ///@return Attribute dimension value multiplied by the appropriate
  ///         metric and truncated to integer pixels.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  int getLayoutDimension_1(int index, int defValue) =>
      _getLayoutDimension_1(reference, index, defValue);

  static final _getFraction = jlookup<
          ffi.NativeFunction<
              ffi.Float Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Float)>>("android_content_res_TypedArray_getFraction")
      .asFunction<
          double Function(ffi.Pointer<ffi.Void>, int, int, int, double)>();

  /// from: public float getFraction(int index, int base, int pbase, float defValue)
  /// Retrieves a fractional unit attribute at <var>index</var>.
  ///@param index Index of attribute to retrieve.
  ///@param base The base value of this fraction.  In other words, a
  ///             standard fraction is multiplied by this value.
  ///@param pbase The parent base value of this fraction.  In other
  ///             words, a parent fraction (nn%p) is multiplied by this
  ///             value.
  ///@param defValue Value to return if the attribute is not defined or
  ///                 not a resource.
  ///@return Attribute fractional value multiplied by the appropriate
  ///         base value, or defValue if not defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not a fraction.
  double getFraction(int index, int base, int pbase, double defValue) =>
      _getFraction(reference, index, base, pbase, defValue);

  static final _getResourceId = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_content_res_TypedArray_getResourceId")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int getResourceId(int index, int defValue)
  /// Retrieves the resource identifier for the attribute at
  /// <var>index</var>.  Note that attribute resource as resolved when
  /// the overall TypedArray object is retrieved.  As a
  /// result, this function will return the resource identifier of the
  /// final resource value that was found, _not_ necessarily the
  /// original resource that was specified by the attribute.
  ///@param index Index of attribute to retrieve.
  ///@param defValue Value to return if the attribute is not defined or
  ///                 not a resource.
  ///@return Attribute resource identifier, or defValue if not defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  int getResourceId(int index, int defValue) =>
      _getResourceId(reference, index, defValue);

  static final _getDrawable = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_TypedArray_getDrawable")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.drawable.Drawable getDrawable(int index)
  /// Retrieve the Drawable for the attribute at <var>index</var>.
  ///
  /// This method will throw an exception if the attribute is defined but is
  /// not a color or drawable resource.
  ///@param index Index of attribute to retrieve.
  ///@return Drawable for the attribute, or {@code null} if not defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not a color or drawable resource.
  jni.JlObject getDrawable(int index) =>
      jni.JlObject.fromRef(_getDrawable(reference, index));

  static final _getFont = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_TypedArray_getFont")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.Typeface getFont(int index)
  /// Retrieve the Typeface for the attribute at <var>index</var>.
  ///
  /// This method will throw an exception if the attribute is defined but is
  /// not a font.
  ///@param index Index of attribute to retrieve.
  ///@return Typeface for the attribute, or {@code null} if not defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not a font resource.
  jni.JlObject getFont(int index) =>
      jni.JlObject.fromRef(_getFont(reference, index));

  static final _getTextArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_TypedArray_getTextArray")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.CharSequence[] getTextArray(int index)
  /// Retrieve the CharSequence[] for the attribute at <var>index</var>.
  /// This gets the resource ID of the selected attribute, and uses
  /// Resources\#getTextArray Resources.getTextArray of the owning
  /// Resources object to retrieve its String[].
  ///
  /// This method will throw an exception if the attribute is defined but is
  /// not a text array resource.
  ///@param index Index of attribute to retrieve.
  ///@return CharSequence[] for the attribute, or {@code null} if not
  ///         defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  jni.JlObject getTextArray(int index) =>
      jni.JlObject.fromRef(_getTextArray(reference, index));

  static final _getValue = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_res_TypedArray_getValue")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getValue(int index, android.util.TypedValue outValue)
  /// Retrieve the raw TypedValue for the attribute at <var>index</var>.
  ///@param index Index of attribute to retrieve.
  ///@param outValue TypedValue object in which to place the attribute's
  ///                 data.
  ///@return {@code true} if the value was retrieved and not @empty, {@code false} otherwise.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  bool getValue(int index, jni.JlObject outValue) =>
      _getValue(reference, index, outValue.reference) != 0;

  static final _getType = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_TypedArray_getType")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getType(int index)
  /// Returns the type of attribute at the specified index.
  ///@param index Index of attribute whose type to retrieve.
  ///@return Attribute type.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  int getType(int index) => _getType(reference, index);

  static final _hasValue = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_TypedArray_hasValue")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean hasValue(int index)
  /// Determines whether there is an attribute at <var>index</var>.
  ///
  /// <strong>Note:</strong> If the attribute was set to {@code @empty} or
  /// {@code @undefined}, this method returns {@code false}.
  ///@param index Index of attribute to retrieve.
  ///@return True if the attribute has a value, false otherwise.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  bool hasValue(int index) => _hasValue(reference, index) != 0;

  static final _hasValueOrEmpty = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_TypedArray_hasValueOrEmpty")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean hasValueOrEmpty(int index)
  /// Determines whether there is an attribute at <var>index</var>, returning
  /// {@code true} if the attribute was explicitly set to {@code @empty} and
  /// {@code false} only if the attribute was undefined.
  ///@param index Index of attribute to retrieve.
  ///@return True if the attribute has a value or is empty, false otherwise.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  bool hasValueOrEmpty(int index) => _hasValueOrEmpty(reference, index) != 0;

  static final _peekValue = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_TypedArray_peekValue")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.util.TypedValue peekValue(int index)
  /// Retrieve the raw TypedValue for the attribute at <var>index</var>
  /// and return a temporary object holding its data.  This object is only
  /// valid until the next call on to TypedArray.
  ///@param index Index of attribute to retrieve.
  ///@return Returns a TypedValue object if the attribute is defined,
  ///         containing its data; otherwise returns null.  (You will not
  ///         receive a TypedValue whose type is TYPE_NULL.)
  ///@throws RuntimeException if the TypedArray has already been recycled.
  jni.JlObject peekValue(int index) =>
      jni.JlObject.fromRef(_peekValue(reference, index));

  static final _getPositionDescription = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_TypedArray_getPositionDescription")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPositionDescription()
  /// Returns a message about the parser state suitable for printing error messages.
  ///@return Human-readable description of current parser state.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  jni.JlString getPositionDescription() =>
      jni.JlString.fromRef(_getPositionDescription(reference));

  static final _recycle =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_TypedArray_recycle")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void recycle()
  /// Recycles the TypedArray, to be re-used by a later caller. After calling
  /// this function you must not ever touch the typed array again.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  void recycle() => _recycle(reference);

  static final _getChangingConfigurations =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_TypedArray_getChangingConfigurations")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getChangingConfigurations()
  /// Return a mask of the configuration parameters for which the values in
  /// this typed array may change.
  ///@return Returns a mask of the changing configuration parameters, as
  ///         defined by android.content.pm.ActivityInfo.
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@see android.content.pm.ActivityInfo
  int getChangingConfigurations() => _getChangingConfigurations(reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_TypedArray_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));
}

/// Class to scan Opaque Binary Blob (OBB) files. Use this to get information
/// about an OBB file for use in a program via ObbInfo.
class ObbScanner extends jni.JlObject {
  ObbScanner.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_res_ObbScanner_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  ObbScanner() : super.fromRef(_ctor());

  static final _getObbInfo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_ObbScanner_getObbInfo")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.res.ObbInfo getObbInfo(java.lang.String filePath)
  /// Scan a file for OBB information.
  ///@param filePath path to the OBB file to be scanned.
  ///@return ObbInfo object information corresponding to the file path
  ///@throws IllegalArgumentException if the OBB file couldn't be found
  ///@throws IOException if the OBB file couldn't be read
  static ObbInfo getObbInfo(jni.JlString filePath) =>
      ObbInfo.fromRef(_getObbInfo(filePath.reference));
}

/// Class for accessing an application's resources.  This sits on top of the
/// asset manager of the application (accessible through \#getAssets) and
/// provides a high-level API for getting typed data from the assets.
///
/// The Android resource system keeps track of all non-code assets associated with an
/// application. You can use this class to access your application's resources. You can generally
/// acquire the android.content.res.Resources instance associated with your application
/// with android.content.Context\#getResources getResources().
///
///
/// The Android SDK tools compile your application's resources into the application binary
/// at build time.  To use a resource, you must install it correctly in the source tree (inside
/// your project's {@code res/} directory) and build your application.  As part of the build
/// process, the SDK tools generate symbols for each resource, which you can use in your application
/// code to access the resources.
///
///
/// Using application resources makes it easy to update various characteristics of your
/// application without modifying code, and&mdash;by providing sets of alternative
/// resources&mdash;enables you to optimize your application for a variety of device configurations
/// (such as for different languages and screen sizes). This is an important aspect of developing
/// Android applications that are compatible on different types of devices.
///
///
/// For more information about using resources, see the documentation about <a href="{@docRoot}guide/topics/resources/index.html">Application Resources</a>.
///
class Resources extends jni.JlObject {
  Resources.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_res_Resources_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.res.AssetManager assets, android.util.DisplayMetrics metrics, android.content.res.Configuration config)
  /// Create a new Resources object on top of an existing set of assets in an
  /// AssetManager.
  ///@deprecated Resources should not be constructed by apps.
  /// See android.content.Context\#createConfigurationContext(Configuration).
  ///@param assets Previously created AssetManager.
  ///@param metrics Current display metrics to consider when
  ///                selecting/computing resource values.
  ///@param config Desired device configuration to consider when
  ///               selecting/computing resource values (optional).
  Resources(AssetManager assets, jni.JlObject metrics, Configuration config)
      : super.fromRef(
            _ctor(assets.reference, metrics.reference, config.reference));

  static final _getSystem =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_res_Resources_getSystem")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.content.res.Resources getSystem()
  /// Return a global shared Resources object that provides access to only
  /// system resources (no application resources), and is not configured for
  /// the current screen (can not use dimension units, does not change based
  /// on orientation, etc).
  static Resources getSystem() => Resources.fromRef(_getSystem());

  static final _getText = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_Resources_getText")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.CharSequence getText(int id)
  /// Return the string value associated with a particular resource ID.  The
  /// returned object will be a String if this is a plain string; it will be
  /// some other type of CharSequence if it is styled.
  /// {@more }
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return CharSequence The string data associated with the resource, plus
  ///         possibly styled text information.
  ///
  /// This value will never be {@code null}.
  jni.JlObject getText(int id) => jni.JlObject.fromRef(_getText(reference, id));

  static final _getFont = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_Resources_getFont")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.Typeface getFont(int id)
  /// Return the Typeface value associated with a particular resource ID.
  /// {@more }
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return Typeface The Typeface data associated with the resource.
  ///
  /// This value will never be {@code null}.
  jni.JlObject getFont(int id) => jni.JlObject.fromRef(_getFont(reference, id));

  static final _getQuantityText = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_content_res_Resources_getQuantityText")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public java.lang.CharSequence getQuantityText(int id, int quantity)
  /// Returns the character sequence necessary for grammatically correct pluralization
  /// of the given resource ID for the given quantity.
  /// Note that the character sequence is selected based solely on grammatical necessity,
  /// and that such rules differ between languages. Do not assume you know which string
  /// will be returned for a given quantity. See
  /// <a href="{@docRoot}guide/topics/resources/string-resource.html\#Plurals">String Resources</a>
  /// for more detail.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@param quantity The number used to get the correct string for the current language's
  ///           plural rules.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return CharSequence The string data associated with the resource, plus
  ///         possibly styled text information.
  ///
  /// This value will never be {@code null}.
  jni.JlObject getQuantityText(int id, int quantity) =>
      jni.JlObject.fromRef(_getQuantityText(reference, id, quantity));

  static final _getString = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_Resources_getString")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getString(int id)
  /// Return the string value associated with a particular resource ID.  It
  /// will be stripped of any styled text information.
  /// {@more }
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return String The string data associated with the resource,
  ///         stripped of styled text information.
  ///
  /// This value will never be {@code null}.
  jni.JlString getString(int id) =>
      jni.JlString.fromRef(_getString(reference, id));

  static final _getString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources_getString_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getString(int id, java.lang.Object[] formatArgs)
  /// Return the string value associated with a particular resource ID,
  /// substituting the format arguments as defined in java.util.Formatter
  /// and java.lang.String\#format. It will be stripped of any styled text
  /// information.
  /// {@more }
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@param formatArgs The format arguments that will be used for substitution.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return String The string data associated with the resource,
  ///         stripped of styled text information.
  ///
  /// This value will never be {@code null}.
  jni.JlString getString_1(int id, jni.JlObject formatArgs) =>
      jni.JlString.fromRef(_getString_1(reference, id, formatArgs.reference));

  static final _getQuantityString = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources_getQuantityString")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getQuantityString(int id, int quantity, java.lang.Object[] formatArgs)
  /// Formats the string necessary for grammatically correct pluralization
  /// of the given resource ID for the given quantity, using the given arguments.
  /// Note that the string is selected based solely on grammatical necessity,
  /// and that such rules differ between languages. Do not assume you know which string
  /// will be returned for a given quantity. See
  /// <a href="{@docRoot}guide/topics/resources/string-resource.html\#Plurals">String Resources</a>
  /// for more detail.
  ///
  /// Substitution of format arguments works as if using
  /// java.util.Formatter and java.lang.String\#format.
  /// The resulting string will be stripped of any styled text information.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@param quantity The number used to get the correct string for the current language's
  ///           plural rules.
  ///@param formatArgs The format arguments that will be used for substitution.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return String The string data associated with the resource,
  /// stripped of styled text information.
  ///
  /// This value will never be {@code null}.
  jni.JlString getQuantityString(
          int id, int quantity, jni.JlObject formatArgs) =>
      jni.JlString.fromRef(
          _getQuantityString(reference, id, quantity, formatArgs.reference));

  static final _getQuantityString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_content_res_Resources_getQuantityString_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public java.lang.String getQuantityString(int id, int quantity)
  /// Returns the string necessary for grammatically correct pluralization
  /// of the given resource ID for the given quantity.
  /// Note that the string is selected based solely on grammatical necessity,
  /// and that such rules differ between languages. Do not assume you know which string
  /// will be returned for a given quantity. See
  /// <a href="{@docRoot}guide/topics/resources/string-resource.html\#Plurals">String Resources</a>
  /// for more detail.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@param quantity The number used to get the correct string for the current language's
  ///           plural rules.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return String The string data associated with the resource,
  /// stripped of styled text information.
  ///
  /// This value will never be {@code null}.
  jni.JlString getQuantityString_1(int id, int quantity) =>
      jni.JlString.fromRef(_getQuantityString_1(reference, id, quantity));

  static final _getText_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources_getText_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getText(int id, java.lang.CharSequence def)
  /// Return the string value associated with a particular resource ID.  The
  /// returned object will be a String if this is a plain string; it will be
  /// some other type of CharSequence if it is styled.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@param def The default CharSequence to return.
  ///@return CharSequence The string data associated with the resource, plus
  ///         possibly styled text information, or def if id is 0 or not found.
  jni.JlObject getText_1(int id, jni.JlObject def) =>
      jni.JlObject.fromRef(_getText_1(reference, id, def.reference));

  static final _getTextArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_Resources_getTextArray")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.CharSequence[] getTextArray(int id)
  /// Return the styled text array associated with a particular resource ID.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return The styled text array associated with the resource.
  ///
  /// This value will never be {@code null}.
  jni.JlObject getTextArray(int id) =>
      jni.JlObject.fromRef(_getTextArray(reference, id));

  static final _getStringArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_Resources_getStringArray")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String[] getStringArray(int id)
  /// Return the string array associated with a particular resource ID.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return The string array associated with the resource.
  ///
  /// This value will never be {@code null}.
  jni.JlObject getStringArray(int id) =>
      jni.JlObject.fromRef(_getStringArray(reference, id));

  static final _getIntArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_Resources_getIntArray")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int[] getIntArray(int id)
  /// Return the int array associated with a particular resource ID.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return The int array associated with the resource.
  ///
  /// This value will never be {@code null}.
  jni.JlObject getIntArray(int id) =>
      jni.JlObject.fromRef(_getIntArray(reference, id));

  static final _obtainTypedArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_Resources_obtainTypedArray")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.res.TypedArray obtainTypedArray(int id)
  /// Return an array of heterogeneous values.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return Returns a TypedArray holding an array of the array values.
  /// Be sure to call TypedArray\#recycle() TypedArray.recycle()
  /// when done with it.
  ///
  /// This value will never be {@code null}.
  TypedArray obtainTypedArray(int id) =>
      TypedArray.fromRef(_obtainTypedArray(reference, id));

  static final _getDimension = jlookup<
          ffi.NativeFunction<
              ffi.Float Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_Resources_getDimension")
      .asFunction<double Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public float getDimension(int id)
  /// Retrieve a dimensional for a particular resource ID.  Unit
  /// conversions are based on the current DisplayMetrics associated
  /// with the resources.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@return Resource dimension value multiplied by the appropriate
  /// metric.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@see \#getDimensionPixelOffset
  ///@see \#getDimensionPixelSize
  double getDimension(int id) => _getDimension(reference, id);

  static final _getDimensionPixelOffset = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_Resources_getDimensionPixelOffset")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getDimensionPixelOffset(int id)
  /// Retrieve a dimensional for a particular resource ID for use
  /// as an offset in raw pixels.  This is the same as
  /// \#getDimension, except the returned value is converted to
  /// integer pixels for you.  An offset conversion involves simply
  /// truncating the base value to an integer.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@return Resource dimension value multiplied by the appropriate
  /// metric and truncated to integer pixels.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@see \#getDimension
  ///@see \#getDimensionPixelSize
  int getDimensionPixelOffset(int id) =>
      _getDimensionPixelOffset(reference, id);

  static final _getDimensionPixelSize = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_Resources_getDimensionPixelSize")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getDimensionPixelSize(int id)
  /// Retrieve a dimensional for a particular resource ID for use
  /// as a size in raw pixels.  This is the same as
  /// \#getDimension, except the returned value is converted to
  /// integer pixels for use as a size.  A size conversion involves
  /// rounding the base value, and ensuring that a non-zero base value
  /// is at least one pixel in size.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@return Resource dimension value multiplied by the appropriate
  /// metric and truncated to integer pixels.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@see \#getDimension
  ///@see \#getDimensionPixelOffset
  int getDimensionPixelSize(int id) => _getDimensionPixelSize(reference, id);

  static final _getFraction = jlookup<
          ffi.NativeFunction<
              ffi.Float Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32,
                  ffi.Int32)>>("android_content_res_Resources_getFraction")
      .asFunction<double Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public float getFraction(int id, int base, int pbase)
  /// Retrieve a fractional unit for a particular resource ID.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@param base The base value of this fraction.  In other words, a
  ///             standard fraction is multiplied by this value.
  ///@param pbase The parent base value of this fraction.  In other
  ///             words, a parent fraction (nn%p) is multiplied by this
  ///             value.
  ///@return Attribute fractional value multiplied by the appropriate
  /// base value.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  double getFraction(int id, int base, int pbase) =>
      _getFraction(reference, id, base, pbase);

  static final _getDrawable = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_Resources_getDrawable")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.drawable.Drawable getDrawable(int id)
  /// Return a drawable object associated with a particular resource ID.
  /// Various types of objects will be returned depending on the underlying
  /// resource -- for example, a solid color, PNG image, scalable image, etc.
  /// The Drawable API hides these implementation details.
  ///
  /// <p class="note"><strong>Note:</strong> Prior to
  /// android.os.Build.VERSION_CODES\#JELLY_BEAN, this function
  /// would not correctly retrieve the final configuration density when
  /// the resource ID passed here is an alias to another Drawable resource.
  /// This means that if the density configuration of the alias resource
  /// is different than the actual resource, the density of the returned
  /// Drawable would be incorrect, resulting in bad scaling. To work
  /// around this, you can instead manually resolve the aliased reference
  /// by using \#getValue(int, TypedValue, boolean) and passing
  /// {@code true} for {@code resolveRefs}. The resulting
  /// TypedValue\#resourceId value may be passed to this method.
  ///
  ///
  /// <p class="note"><strong>Note:</strong> To obtain a themed drawable, use
  /// android.content.Context\#getDrawable(int) Context.getDrawable(int)
  /// or \#getDrawable(int, Theme) passing the desired theme.
  ///
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@return Drawable An object that can be used to draw this resource.
  ///@throws NotFoundException Throws NotFoundException if the given ID does
  ///         not exist.
  ///@see \#getDrawable(int, Theme)
  ///@deprecated Use \#getDrawable(int, Theme) instead.
  jni.JlObject getDrawable(int id) =>
      jni.JlObject.fromRef(_getDrawable(reference, id));

  static final _getDrawable_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources_getDrawable_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable getDrawable(int id, android.content.res.Resources.Theme theme)
  /// Return a drawable object associated with a particular resource ID and
  /// styled for the specified theme. Various types of objects will be
  /// returned depending on the underlying resource -- for example, a solid
  /// color, PNG image, scalable image, etc.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@param theme The theme used to style the drawable attributes, may be {@code null}.
  /// This value may be {@code null}.
  ///@return Drawable An object that can be used to draw this resource.
  ///@throws NotFoundException Throws NotFoundException if the given ID does
  ///         not exist.
  jni.JlObject getDrawable_1(int id, Resources_Theme theme) =>
      jni.JlObject.fromRef(_getDrawable_1(reference, id, theme.reference));

  static final _getDrawableForDensity = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_content_res_Resources_getDrawableForDensity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.graphics.drawable.Drawable getDrawableForDensity(int id, int density)
  /// Return a drawable object associated with a particular resource ID for the
  /// given screen density in DPI. This will set the drawable's density to be
  /// the device's density multiplied by the ratio of actual drawable density
  /// to requested density. This allows the drawable to be scaled up to the
  /// correct size if needed. Various types of objects will be returned
  /// depending on the underlying resource -- for example, a solid color, PNG
  /// image, scalable image, etc. The Drawable API hides these implementation
  /// details.
  ///
  /// <p class="note"><strong>Note:</strong> To obtain a themed drawable, use
  /// android.content.Context\#getDrawable(int) Context.getDrawable(int)
  /// or \#getDrawableForDensity(int, int, Theme) passing the desired
  /// theme.
  ///
  ///@param id The desired resource identifier, as generated by the aapt tool.
  ///            This integer encodes the package, type, and resource entry.
  ///            The value 0 is an invalid identifier.
  ///@param density the desired screen density indicated by the resource as
  ///            found in DisplayMetrics. A value of 0 means to use the
  ///            density returned from \#getConfiguration().
  ///            This is equivalent to calling \#getDrawable(int).
  ///@return Drawable An object that can be used to draw this resource.
  /// This value may be {@code null}.
  ///@throws NotFoundException Throws NotFoundException if the given ID does
  ///             not exist.
  ///@see \#getDrawableForDensity(int, int, Theme)
  ///@deprecated Use \#getDrawableForDensity(int, int, Theme) instead.
  jni.JlObject getDrawableForDensity(int id, int density) =>
      jni.JlObject.fromRef(_getDrawableForDensity(reference, id, density));

  static final _getDrawableForDensity_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources_getDrawableForDensity_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable getDrawableForDensity(int id, int density, android.content.res.Resources.Theme theme)
  /// Return a drawable object associated with a particular resource ID for the
  /// given screen density in DPI and styled for the specified theme.
  ///@param id The desired resource identifier, as generated by the aapt tool.
  ///            This integer encodes the package, type, and resource entry.
  ///            The value 0 is an invalid identifier.
  ///@param density The desired screen density indicated by the resource as
  ///            found in DisplayMetrics. A value of 0 means to use the
  ///            density returned from \#getConfiguration().
  ///            This is equivalent to calling \#getDrawable(int, Theme).
  ///@param theme The theme used to style the drawable attributes, may be {@code null} if the
  ///              drawable cannot be decoded.
  /// This value may be {@code null}.
  ///@return Drawable An object that can be used to draw this resource.
  ///@throws NotFoundException Throws NotFoundException if the given ID does
  ///             not exist.
  jni.JlObject getDrawableForDensity_1(
          int id, int density, Resources_Theme theme) =>
      jni.JlObject.fromRef(
          _getDrawableForDensity_1(reference, id, density, theme.reference));

  static final _getMovie = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_Resources_getMovie")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.Movie getMovie(int id)
  /// Return a movie object associated with the particular resource ID.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  jni.JlObject getMovie(int id) =>
      jni.JlObject.fromRef(_getMovie(reference, id));

  static final _getColor = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_Resources_getColor")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getColor(int id)
  /// Returns a color integer associated with a particular resource ID. If the
  /// resource holds a complex ColorStateList, then the default color
  /// from the set is returned.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does
  ///         not exist.
  ///@return A single color value in the form 0xAARRGGBB.
  ///@deprecated Use \#getColor(int, Theme) instead.
  int getColor(int id) => _getColor(reference, id);

  static final _getColor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources_getColor_1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public int getColor(int id, android.content.res.Resources.Theme theme)
  /// Returns a themed color integer associated with a particular resource ID.
  /// If the resource holds a complex ColorStateList, then the default
  /// color from the set is returned.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@param theme The theme used to style the color attributes, may be
  ///              {@code null}.
  ///
  /// This value may be {@code null}.
  ///@throws NotFoundException Throws NotFoundException if the given ID does
  ///         not exist.
  ///@return A single color value in the form 0xAARRGGBB.
  int getColor_1(int id, Resources_Theme theme) =>
      _getColor_1(reference, id, theme.reference);

  static final _getColorStateList = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_Resources_getColorStateList")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.res.ColorStateList getColorStateList(int id)
  /// Returns a color state list associated with a particular resource ID. The
  /// resource may contain either a single raw color value or a complex
  /// ColorStateList holding multiple possible colors.
  ///@param id The desired resource identifier of a ColorStateList,
  ///           as generated by the aapt tool. This integer encodes the
  ///           package, type, and resource entry. The value 0 is an invalid
  ///           identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does
  ///         not exist.
  ///@return A ColorStateList object containing either a single solid color
  ///         or multiple colors that can be selected based on a state.
  /// This value will never be {@code null}.
  ///@deprecated Use \#getColorStateList(int, Theme) instead.
  ColorStateList getColorStateList(int id) =>
      ColorStateList.fromRef(_getColorStateList(reference, id));

  static final _getColorStateList_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources_getColorStateList_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.ColorStateList getColorStateList(int id, android.content.res.Resources.Theme theme)
  /// Returns a themed color state list associated with a particular resource
  /// ID. The resource may contain either a single raw color value or a
  /// complex ColorStateList holding multiple possible colors.
  ///@param id The desired resource identifier of a ColorStateList,
  ///           as generated by the aapt tool. This integer encodes the
  ///           package, type, and resource entry. The value 0 is an invalid
  ///           identifier.
  ///@param theme The theme used to style the color attributes, may be
  ///              {@code null}.
  ///
  /// This value may be {@code null}.
  ///@throws NotFoundException Throws NotFoundException if the given ID does
  ///         not exist.
  ///@return A themed ColorStateList object containing either a single solid
  ///         color or multiple colors that can be selected based on a state.
  ColorStateList getColorStateList_1(int id, Resources_Theme theme) =>
      ColorStateList.fromRef(
          _getColorStateList_1(reference, id, theme.reference));

  static final _getBoolean = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_Resources_getBoolean")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean getBoolean(int id)
  /// Return a boolean associated with a particular resource ID.  This can be
  /// used with any integral resource value, and will return true if it is
  /// non-zero.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return Returns the boolean value contained in the resource.
  bool getBoolean(int id) => _getBoolean(reference, id) != 0;

  static final _getInteger = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_Resources_getInteger")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getInteger(int id)
  /// Return an integer associated with a particular resource ID.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return Returns the integer value contained in the resource.
  int getInteger(int id) => _getInteger(reference, id);

  static final _getLayout = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_Resources_getLayout")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.res.XmlResourceParser getLayout(int id)
  /// Return an XmlResourceParser through which you can read a view layout
  /// description for the given resource ID.  This parser has limited
  /// functionality -- in particular, you can't change its input, and only
  /// the high-level events are available.
  ///
  /// This function is really a simple wrapper for calling
  /// \#getXml with a layout resource.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return A new parser object through which you can read
  ///         the XML data.
  ///
  /// This value will never be {@code null}.
  ///@see \#getXml
  XmlResourceParser getLayout(int id) =>
      XmlResourceParser.fromRef(_getLayout(reference, id));

  static final _getAnimation = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_Resources_getAnimation")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.res.XmlResourceParser getAnimation(int id)
  /// Return an XmlResourceParser through which you can read an animation
  /// description for the given resource ID.  This parser has limited
  /// functionality -- in particular, you can't change its input, and only
  /// the high-level events are available.
  ///
  /// This function is really a simple wrapper for calling
  /// \#getXml with an animation resource.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return A new parser object through which you can read
  ///         the XML data.
  ///
  /// This value will never be {@code null}.
  ///@see \#getXml
  XmlResourceParser getAnimation(int id) =>
      XmlResourceParser.fromRef(_getAnimation(reference, id));

  static final _getXml = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_Resources_getXml")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.res.XmlResourceParser getXml(int id)
  /// Return an XmlResourceParser through which you can read a generic XML
  /// resource for the given resource ID.
  ///
  /// The XmlPullParser implementation returned here has some limited
  /// functionality.  In particular, you can't change its input, and only
  /// high-level parsing events are available (since the document was
  /// pre-parsed for you at build time, which involved merging text and
  /// stripping comments).
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return A new parser object through which you can read
  ///         the XML data.
  ///
  /// This value will never be {@code null}.
  ///@see android.util.AttributeSet
  XmlResourceParser getXml(int id) =>
      XmlResourceParser.fromRef(_getXml(reference, id));

  static final _openRawResource = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_Resources_openRawResource")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.io.InputStream openRawResource(int id)
  /// Open a data stream for reading a raw resource.  This can only be used
  /// with resources whose value is the name of an asset files -- that is, it can be
  /// used to open drawable, sound, and raw resources; it will fail on string
  /// and color resources.
  ///@param id The resource identifier to open, as generated by the aapt tool.
  ///@return InputStream Access to the resource data.
  ///
  /// This value will never be {@code null}.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  jni.JlObject openRawResource(int id) =>
      jni.JlObject.fromRef(_openRawResource(reference, id));

  static final _openRawResource_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources_openRawResource_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.InputStream openRawResource(int id, android.util.TypedValue value)
  /// Open a data stream for reading a raw resource.  This can only be used
  /// with resources whose value is the name of an asset file -- that is, it can be
  /// used to open drawable, sound, and raw resources; it will fail on string
  /// and color resources.
  ///@param id The resource identifier to open, as generated by the aapt tool.
  ///@param value The TypedValue object to hold the resource information.
  ///@return InputStream Access to the resource data.
  ///
  /// This value will never be {@code null}.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  jni.JlObject openRawResource_1(int id, jni.JlObject value) =>
      jni.JlObject.fromRef(_openRawResource_1(reference, id, value.reference));

  static final _openRawResourceFd = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_Resources_openRawResourceFd")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.res.AssetFileDescriptor openRawResourceFd(int id)
  /// Open a file descriptor for reading a raw resource.  This can only be used
  /// with resources whose value is the name of an asset files -- that is, it can be
  /// used to open drawable, sound, and raw resources; it will fail on string
  /// and color resources.
  ///
  /// This function only works for resources that are stored in the package
  /// as uncompressed data, which typically includes things like mp3 files
  /// and png images.
  ///@param id The resource identifier to open, as generated by the aapt tool.
  ///@return AssetFileDescriptor A new file descriptor you can use to read
  /// the resource.  This includes the file descriptor itself, as well as the
  /// offset and length of data where the resource appears in the file.  A
  /// null is returned if the file exists but is compressed.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  AssetFileDescriptor openRawResourceFd(int id) =>
      AssetFileDescriptor.fromRef(_openRawResourceFd(reference, id));

  static final _getValue = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_content_res_Resources_getValue")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void getValue(int id, android.util.TypedValue outValue, boolean resolveRefs)
  /// Return the raw data associated with a particular resource ID.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@param outValue Object in which to place the resource data.
  ///@param resolveRefs If true, a resource that is a reference to another
  ///                    resource will be followed so that you receive the
  ///                    actual final resource data.  If false, the TypedValue
  ///                    will be filled in with the reference itself.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  void getValue(int id, jni.JlObject outValue, bool resolveRefs) =>
      _getValue(reference, id, outValue.reference, resolveRefs ? 1 : 0);

  static final _getValueForDensity = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_content_res_Resources_getValueForDensity")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void getValueForDensity(int id, int density, android.util.TypedValue outValue, boolean resolveRefs)
  /// Get the raw value associated with a resource with associated density.
  ///@param id resource identifier
  ///@param density density in DPI
  ///@param resolveRefs If true, a resource that is a reference to another
  ///            resource will be followed so that you receive the actual final
  ///            resource data. If false, the TypedValue will be filled in with
  ///            the reference itself.
  ///@throws NotFoundException Throws NotFoundException if the given ID does
  ///             not exist.
  ///@see \#getValue(String, TypedValue, boolean)
  void getValueForDensity(
          int id, int density, jni.JlObject outValue, bool resolveRefs) =>
      _getValueForDensity(
          reference, id, density, outValue.reference, resolveRefs ? 1 : 0);

  static final _getValue_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_content_res_Resources_getValue_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void getValue(java.lang.String name, android.util.TypedValue outValue, boolean resolveRefs)
  /// Return the raw data associated with a particular resource ID.
  /// See getIdentifier() for information on how names are mapped to resource
  /// IDs, and getString(int) for information on how string resources are
  /// retrieved.
  ///
  /// Note: use of this function is discouraged.  It is much more
  /// efficient to retrieve resources by identifier than by name.
  ///@param name The name of the desired resource.  This is passed to
  ///             getIdentifier() with a default type of "string".
  ///@param outValue Object in which to place the resource data.
  ///@param resolveRefs If true, a resource that is a reference to another
  ///                    resource will be followed so that you receive the
  ///                    actual final resource data.  If false, the TypedValue
  ///                    will be filled in with the reference itself.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  void getValue_1(jni.JlString name, jni.JlObject outValue, bool resolveRefs) =>
      _getValue_1(
          reference, name.reference, outValue.reference, resolveRefs ? 1 : 0);

  static final _newTheme = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources_newTheme")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.Resources.Theme newTheme()
  /// Generate a new Theme object for this set of Resources.  It initially
  /// starts out empty.
  ///@return Theme The newly created Theme container.
  Resources_Theme newTheme() => Resources_Theme.fromRef(_newTheme(reference));

  static final _obtainAttributes = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources_obtainAttributes")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.TypedArray obtainAttributes(android.util.AttributeSet set, int[] attrs)
  /// Retrieve a set of basic attribute values from an AttributeSet, not
  /// performing styling of them using a theme and/or style resources.
  ///@param set The current attribute values to retrieve.
  ///@param attrs The specific attributes to be retrieved. These attribute IDs must be sorted in
  ///              ascending order.
  ///@return Returns a TypedArray holding an array of the attribute values.
  /// Be sure to call TypedArray\#recycle() TypedArray.recycle()
  /// when done with it.
  ///@see Theme\#obtainStyledAttributes(AttributeSet, int[], int, int)
  TypedArray obtainAttributes(jni.JlObject set_, jni.JlObject attrs) =>
      TypedArray.fromRef(
          _obtainAttributes(reference, set_.reference, attrs.reference));

  static final _updateConfiguration = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources_updateConfiguration")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void updateConfiguration(android.content.res.Configuration config, android.util.DisplayMetrics metrics)
  /// Store the newly updated configuration.
  ///@deprecated See android.content.Context\#createConfigurationContext(Configuration).
  void updateConfiguration(Configuration config, jni.JlObject metrics) =>
      _updateConfiguration(reference, config.reference, metrics.reference);

  static final _getDisplayMetrics = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources_getDisplayMetrics")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.util.DisplayMetrics getDisplayMetrics()
  /// Return the current display metrics that are in effect for this resource
  /// object.  The returned object should be treated as read-only.
  ///@return The resource's current display metrics.
  jni.JlObject getDisplayMetrics() =>
      jni.JlObject.fromRef(_getDisplayMetrics(reference));

  static final _getConfiguration = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources_getConfiguration")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.Configuration getConfiguration()
  /// Return the current configuration that is in effect for this resource
  /// object.  The returned object should be treated as read-only.
  ///@return The resource's current configuration.
  Configuration getConfiguration() =>
      Configuration.fromRef(_getConfiguration(reference));

  static final _getIdentifier = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources_getIdentifier")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getIdentifier(java.lang.String name, java.lang.String defType, java.lang.String defPackage)
  /// Return a resource identifier for the given resource name.  A fully
  /// qualified resource name is of the form "package:type/entry".  The first
  /// two components (package and type) are optional if defType and
  /// defPackage, respectively, are specified here.
  ///
  /// Note: use of this function is discouraged.  It is much more
  /// efficient to retrieve resources by identifier than by name.
  ///@param name The name of the desired resource.
  ///@param defType Optional default resource type to find, if "type/" is
  ///                not included in the name.  Can be null to require an
  ///                explicit type.
  ///@param defPackage Optional default package to find, if "package:" is
  ///                   not included in the name.  Can be null to require an
  ///                   explicit package.
  ///@return int The associated resource identifier.  Returns 0 if no such
  ///         resource was found.  (0 is not a valid resource ID.)
  int getIdentifier(
          jni.JlString name, jni.JlString defType, jni.JlString defPackage) =>
      _getIdentifier(
          reference, name.reference, defType.reference, defPackage.reference);

  static final _getResourceName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_res_Resources_getResourceName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getResourceName(int resid)
  /// Return the full name for a given resource identifier.  This name is
  /// a single string of the form "package:type/entry".
  ///@param resid The resource identifier whose name is to be retrieved.
  ///@return A string holding the name of the resource.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@see \#getResourcePackageName
  ///@see \#getResourceTypeName
  ///@see \#getResourceEntryName
  jni.JlString getResourceName(int resid) =>
      jni.JlString.fromRef(_getResourceName(reference, resid));

  static final _getResourcePackageName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_Resources_getResourcePackageName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getResourcePackageName(int resid)
  /// Return the package name for a given resource identifier.
  ///@param resid The resource identifier whose package name is to be
  /// retrieved.
  ///@return A string holding the package name of the resource.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@see \#getResourceName
  jni.JlString getResourcePackageName(int resid) =>
      jni.JlString.fromRef(_getResourcePackageName(reference, resid));

  static final _getResourceTypeName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_Resources_getResourceTypeName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getResourceTypeName(int resid)
  /// Return the type name for a given resource identifier.
  ///@param resid The resource identifier whose type name is to be
  /// retrieved.
  ///@return A string holding the type name of the resource.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@see \#getResourceName
  jni.JlString getResourceTypeName(int resid) =>
      jni.JlString.fromRef(_getResourceTypeName(reference, resid));

  static final _getResourceEntryName = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_Resources_getResourceEntryName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getResourceEntryName(int resid)
  /// Return the entry name for a given resource identifier.
  ///@param resid The resource identifier whose entry name is to be
  /// retrieved.
  ///@return A string holding the entry name of the resource.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@see \#getResourceName
  jni.JlString getResourceEntryName(int resid) =>
      jni.JlString.fromRef(_getResourceEntryName(reference, resid));

  static final _parseBundleExtras = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources_parseBundleExtras")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void parseBundleExtras(android.content.res.XmlResourceParser parser, android.os.Bundle outBundle)
  /// Parse a series of android.R.styleable\#Extra &lt;extra&gt; tags from
  /// an XML file.  You call this when you are at the parent tag of the
  /// extra tags, and it will return once all of the child tags have been parsed.
  /// This will call \#parseBundleExtra for each extra tag encountered.
  ///@param parser The parser from which to retrieve the extras.
  ///@param outBundle A Bundle in which to place all parsed extras.
  ///@throws XmlPullParserException
  ///@throws IOException
  void parseBundleExtras(XmlResourceParser parser, os.Bundle outBundle) =>
      _parseBundleExtras(reference, parser.reference, outBundle.reference);

  static final _parseBundleExtra = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources_parseBundleExtra")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void parseBundleExtra(java.lang.String tagName, android.util.AttributeSet attrs, android.os.Bundle outBundle)
  /// Parse a name/value pair out of an XML tag holding that data.  The
  /// AttributeSet must be holding the data defined by
  /// android.R.styleable\#Extra.  The following value types are supported:
  /// <ul>
  /// <li> TypedValue\#TYPE_STRING:
  /// Bundle\#putCharSequence Bundle.putCharSequence()
  /// <li> TypedValue\#TYPE_INT_BOOLEAN:
  /// Bundle\#putCharSequence Bundle.putBoolean()
  /// <li> TypedValue\#TYPE_FIRST_INT-TypedValue\#TYPE_LAST_INT:
  /// Bundle\#putCharSequence Bundle.putBoolean()
  /// <li> TypedValue\#TYPE_FLOAT:
  /// Bundle\#putCharSequence Bundle.putFloat()
  /// </ul>
  ///@param tagName The name of the tag these attributes come from; this is
  /// only used for reporting error messages.
  ///@param attrs The attributes from which to retrieve the name/value pair.
  ///@param outBundle The Bundle in which to place the parsed value.
  ///@throws XmlPullParserException If the attributes are not valid.
  void parseBundleExtra(
          jni.JlString tagName, jni.JlObject attrs, os.Bundle outBundle) =>
      _parseBundleExtra(
          reference, tagName.reference, attrs.reference, outBundle.reference);

  static final _getAssets = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources_getAssets")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.AssetManager getAssets()
  /// Retrieve underlying AssetManager storage for these resources.
  AssetManager getAssets() => AssetManager.fromRef(_getAssets(reference));

  static final _flushLayoutCache =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_Resources_flushLayoutCache")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final void flushLayoutCache()
  /// Call this to remove all cached loaded layout resources from the
  /// Resources object.  Only intended for use with performance testing
  /// tools.
  void flushLayoutCache() => _flushLayoutCache(reference);

  static final _finishPreloading =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_Resources_finishPreloading")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final void finishPreloading()
  /// Called by zygote when it is done preloading resources, to change back
  /// to normal Resources operation.
  void finishPreloading() => _finishPreloading(reference);
}

/// This class holds the current attribute values for a particular theme.
/// In other words, a Theme is a set of values for resource attributes;
/// these are used in conjunction with TypedArray
/// to resolve the final value for an attribute.
///
/// The Theme's attributes come into play in two ways: (1) a styled
/// attribute can explicit reference a value in the theme through the
/// "?themeAttribute" syntax; (2) if no value has been defined for a
/// particular styled attribute, as a last resort we will try to find that
/// attribute's value in the Theme.
///
/// You will normally use the \#obtainStyledAttributes APIs to
/// retrieve XML attributes with style and theme information applied.
class Resources_Theme extends jni.JlObject {
  Resources_Theme.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_res_Resources__Theme_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  Resources_Theme() : super.fromRef(_ctor());

  static final _applyStyle = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Uint8)>>(
          "android_content_res_Resources__Theme_applyStyle")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void applyStyle(int resId, boolean force)
  /// Place new attribute values into the theme.  The style resource
  /// specified by <var>resid</var> will be retrieved from this Theme's
  /// resources, its values placed into the Theme object.
  ///
  /// The semantics of this function depends on the <var>force</var>
  /// argument:  If false, only values that are not already defined in
  /// the theme will be copied from the system resource; otherwise, if
  /// any of the style's attributes are already defined in the theme, the
  /// current values in the theme will be overwritten.
  ///@param resId The resource ID of a style resource from which to
  ///              obtain attribute values.
  ///@param force If true, values in the style resource will always be
  ///              used in the theme; otherwise, they will only be used
  ///              if not already defined in the theme.
  void applyStyle(int resId, bool force) =>
      _applyStyle(reference, resId, force ? 1 : 0);

  static final _setTo = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources__Theme_setTo")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTo(android.content.res.Resources.Theme other)
  /// Set this theme to hold the same contents as the theme
  /// <var>other</var>.  If both of these themes are from the same
  /// Resources object, they will be identical after this function
  /// returns.  If they are from different Resources, only the resources
  /// they have in common will be set in this theme.
  ///@param other The existing Theme to copy from.
  void setTo(Resources_Theme other) => _setTo(reference, other.reference);

  static final _obtainStyledAttributes = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources__Theme_obtainStyledAttributes")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.TypedArray obtainStyledAttributes(int[] attrs)
  /// Return a TypedArray holding the values defined by
  /// <var>Theme</var> which are listed in <var>attrs</var>.
  ///
  /// Be sure to call TypedArray\#recycle() TypedArray.recycle() when you are done
  /// with the array.
  ///@param attrs The desired attributes. These attribute IDs must be sorted in ascending
  ///              order.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return Returns a TypedArray holding an array of the attribute values.
  /// Be sure to call TypedArray\#recycle() TypedArray.recycle()
  /// when done with it.
  ///@see Resources\#obtainAttributes
  ///@see \#obtainStyledAttributes(int, int[])
  ///@see \#obtainStyledAttributes(AttributeSet, int[], int, int)
  TypedArray obtainStyledAttributes(jni.JlObject attrs) =>
      TypedArray.fromRef(_obtainStyledAttributes(reference, attrs.reference));

  static final _obtainStyledAttributes_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources__Theme_obtainStyledAttributes_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.TypedArray obtainStyledAttributes(int resId, int[] attrs)
  /// Return a TypedArray holding the values defined by the style
  /// resource <var>resid</var> which are listed in <var>attrs</var>.
  ///
  /// Be sure to call TypedArray\#recycle() TypedArray.recycle() when you are done
  /// with the array.
  ///@param resId The desired style resource.
  ///@param attrs The desired attributes in the style. These attribute IDs must be sorted in
  ///              ascending order.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return Returns a TypedArray holding an array of the attribute values.
  /// Be sure to call TypedArray\#recycle() TypedArray.recycle()
  /// when done with it.
  ///@see Resources\#obtainAttributes
  ///@see \#obtainStyledAttributes(int[])
  ///@see \#obtainStyledAttributes(AttributeSet, int[], int, int)
  TypedArray obtainStyledAttributes_1(int resId, jni.JlObject attrs) =>
      TypedArray.fromRef(
          _obtainStyledAttributes_1(reference, resId, attrs.reference));

  static final _obtainStyledAttributes_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32)>>(
          "android_content_res_Resources__Theme_obtainStyledAttributes_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.content.res.TypedArray obtainStyledAttributes(android.util.AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes)
  /// Return a TypedArray holding the attribute values in
  /// <var>set</var>
  /// that are listed in <var>attrs</var>.  In addition, if the given
  /// AttributeSet specifies a style class (through the "style" attribute),
  /// that style will be applied on top of the base attributes it defines.
  ///
  /// Be sure to call TypedArray\#recycle() TypedArray.recycle() when you are done
  /// with the array.
  ///
  /// When determining the final value of a particular attribute, there
  /// are four inputs that come into play:
  ///
  ///
  /// <ol>
  ///     <li> Any attribute values in the given AttributeSet.
  ///     <li> The style resource specified in the AttributeSet (named
  ///     "style").
  ///     <li> The default style specified by <var>defStyleAttr</var> and
  ///     <var>defStyleRes</var>
  ///     <li> The base values in this theme.
  /// </ol>
  ///
  /// Each of these inputs is considered in-order, with the first listed
  /// taking precedence over the following ones.  In other words, if in the
  /// AttributeSet you have supplied <code>&lt;Button
  /// textColor="\#ff000000"&gt;</code>, then the button's text will
  /// _always_ be black, regardless of what is specified in any of
  /// the styles.
  ///@param set The base set of attribute values.  May be null.
  ///@param attrs The desired attributes to be retrieved. These attribute IDs must be sorted
  ///              in ascending order.
  ///@param defStyleAttr An attribute in the current theme that contains a
  ///                     reference to a style resource that supplies
  ///                     defaults values for the TypedArray.  Can be
  ///                     0 to not look for defaults.
  ///@param defStyleRes A resource identifier of a style resource that
  ///                    supplies default values for the TypedArray,
  ///                    used only if defStyleAttr is 0 or can not be found
  ///                    in the theme.  Can be 0 to not look for defaults.
  ///@return Returns a TypedArray holding an array of the attribute values.
  /// Be sure to call TypedArray\#recycle() TypedArray.recycle()
  /// when done with it.
  ///@see Resources\#obtainAttributes
  ///@see \#obtainStyledAttributes(int[])
  ///@see \#obtainStyledAttributes(int, int[])
  TypedArray obtainStyledAttributes_2(jni.JlObject set_, jni.JlObject attrs,
          int defStyleAttr, int defStyleRes) =>
      TypedArray.fromRef(_obtainStyledAttributes_2(reference, set_.reference,
          attrs.reference, defStyleAttr, defStyleRes));

  static final _resolveAttribute = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_content_res_Resources__Theme_resolveAttribute")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean resolveAttribute(int resid, android.util.TypedValue outValue, boolean resolveRefs)
  /// Retrieve the value of an attribute in the Theme.  The contents of
  /// <var>outValue</var> are ultimately filled in by
  /// Resources\#getValue.
  ///@param resid The resource identifier of the desired theme
  ///              attribute.
  ///@param outValue Filled in with the ultimate resource value supplied
  ///                 by the attribute.
  ///@param resolveRefs If true, resource references will be walked; if
  ///                    false, <var>outValue</var> may be a
  ///                    TYPE_REFERENCE.  In either case, it will never
  ///                    be a TYPE_ATTRIBUTE.
  ///@return boolean Returns true if the attribute was found and
  ///         <var>outValue</var> is valid, else false.
  bool resolveAttribute(int resid, jni.JlObject outValue, bool resolveRefs) =>
      _resolveAttribute(
          reference, resid, outValue.reference, resolveRefs ? 1 : 0) !=
      0;

  static final _getResources = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources__Theme_getResources")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.Resources getResources()
  /// Returns the resources to which this theme belongs.
  ///@return Resources to which this theme belongs.
  Resources getResources() => Resources.fromRef(_getResources(reference));

  static final _getDrawable = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_Resources__Theme_getDrawable")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.drawable.Drawable getDrawable(int id)
  /// Return a drawable object associated with a particular resource ID
  /// and styled for the Theme.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@return Drawable An object that can be used to draw this resource.
  ///@throws NotFoundException Throws NotFoundException if the given ID
  ///         does not exist.
  jni.JlObject getDrawable(int id) =>
      jni.JlObject.fromRef(_getDrawable(reference, id));

  static final _getChangingConfigurations =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_Resources__Theme_getChangingConfigurations")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getChangingConfigurations()
  /// Returns a bit mask of configuration changes that will impact this
  /// theme (and thus require completely reloading it).
  ///@return a bit mask of configuration changes, as defined by
  ///         ActivityInfo
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  ///@see ActivityInfo
  int getChangingConfigurations() => _getChangingConfigurations(reference);

  static final _dump = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources__Theme_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(int priority, java.lang.String tag, java.lang.String prefix)
  /// Print contents of this theme out to the log.  For debugging only.
  ///@param priority The log priority to use.
  ///@param tag The log tag to use.
  ///@param prefix Text to prefix each line printed.
  void dump(int priority, jni.JlString tag, jni.JlString prefix) =>
      _dump(reference, priority, tag.reference, prefix.reference);
}

/// This exception is thrown by the resource APIs when a requested resource
/// can not be found.
class Resources_NotFoundException extends jni.JlObject {
  Resources_NotFoundException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_res_Resources__NotFoundException_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Resources_NotFoundException() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources__NotFoundException_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String name)
  Resources_NotFoundException.ctor_1(jni.JlString name)
      : super.fromRef(_ctor_1(name.reference));

  static final _ctor_2 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_res_Resources__NotFoundException_new_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String name, java.lang.Exception cause)
  Resources_NotFoundException.ctor_2(jni.JlString name, jni.JlObject cause)
      : super.fromRef(_ctor_2(name.reference, cause.reference));
}

/// The XML parsing interface returned for an XML resource.  This is a standard
/// XmlPullParser interface but also extends AttributeSet and
/// adds an additional \#close() method for the client to indicate when
/// it is done reading the resource.
class XmlResourceParser extends jni.JlObject {
  XmlResourceParser.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _getAttributeNamespace = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_res_XmlResourceParser_getAttributeNamespace")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.lang.String getAttributeNamespace(int index)
  jni.JlString getAttributeNamespace(int index) =>
      jni.JlString.fromRef(_getAttributeNamespace(reference, index));

  static final _close =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_res_XmlResourceParser_close")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void close()
  /// Close this parser. Calls on the interface are no longer valid after this call.
  void close() => _close(reference);
}
