// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_element

import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "../os.dart" as os_;

import "../content.dart" as content_;

import "../content/pm.dart" as pm_;

import "../app.dart" as app_;
import "../../_init.dart" show jniLookup;

/// from: android.app.admin.ConnectEvent
///
/// A class that represents a TCP connect event initiated through the standard network stack.
///
/// It contains information about the originating app as well as the remote TCP endpoint.
///
/// Support both IPv4 and IPv6 connections.
class ConnectEvent extends NetworkEvent {
  ConnectEvent.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR1 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_ConnectEvent__CREATOR1")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.admin.ConnectEvent> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR1 =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR1().object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ConnectEvent__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Parcel in)
  ConnectEvent.ctor1(os_.Parcel in0)
      : super.fromRef(_ctor1(in0.reference).object);

  static final _getInetAddress = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ConnectEvent__getInetAddress")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.net.InetAddress getInetAddress()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getInetAddress() =>
      jni.JniObject.fromRef(_getInetAddress(reference).object);

  static final _getPort = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ConnectEvent__getPort")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getPort()
  int getPort() => _getPort(reference).integer;

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ConnectEvent__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ConnectEvent__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ConnectEvent__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os_.Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags).check();
}

/// from: android.app.admin.DeviceAdminInfo
///
/// This class is used to specify meta information of a device administrator
/// component.
class DeviceAdminInfo extends jni.JniObject {
  DeviceAdminInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_DeviceAdminInfo__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.admin.DeviceAdminInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used to make this class parcelable.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  /// from: static public final int USES_ENCRYPTED_STORAGE
  ///
  /// A type of policy that this device admin can use: require encryption of stored data.
  ///
  /// To control this policy, the device admin must have a "encrypted-storage"
  /// tag in the "uses-policies" section of its meta-data.
  static const USES_ENCRYPTED_STORAGE = 7;

  /// from: static public final int USES_POLICY_DISABLE_CAMERA
  ///
  /// A type of policy that this device admin can use: disables use of all device cameras.
  ///
  /// To control this policy, the device admin must have a "disable-camera"
  /// tag in the "uses-policies" section of its meta-data.
  ///
  /// This policy is deprecated for use by a device admin.  In future releases, it will
  /// only be possible for a device owner or profile owner to disable use of the camera.
  static const USES_POLICY_DISABLE_CAMERA = 8;

  /// from: static public final int USES_POLICY_DISABLE_KEYGUARD_FEATURES
  ///
  /// A type of policy that this device admin can use: disables use of keyguard features.
  ///
  /// To control this policy, the device admin must have a "disable-keyguard-features"
  /// tag in the "uses-policies" section of its meta-data.
  ///
  /// This policy is deprecated for use by a device admin.  In future releases, it will
  /// only be possible for a device owner or profile owner to disable use of keyguard
  /// features.
  static const USES_POLICY_DISABLE_KEYGUARD_FEATURES = 9;

  /// from: static public final int USES_POLICY_EXPIRE_PASSWORD
  ///
  /// A type of policy that this device admin can use: force the user to
  /// change their password after an administrator-defined time limit.
  ///
  /// To control this policy, the device admin must have an "expire-password"
  /// tag in the "uses-policies" section of its meta-data.
  ///
  /// This policy is deprecated for use by a device admin.  In future releases, it will
  /// only be possible for a device owner or profile owner to enforce password expiry.
  static const USES_POLICY_EXPIRE_PASSWORD = 6;

  /// from: static public final int USES_POLICY_FORCE_LOCK
  ///
  /// A type of policy that this device admin can use: able to force the device
  /// to lock viaDevicePolicyManager\#lockNow or limit the
  /// maximum lock timeout for the device via
  /// DevicePolicyManager\#setMaximumTimeToLock.
  ///
  /// To control this policy, the device admin must have a "force-lock"
  /// tag in the "uses-policies" section of its meta-data.
  static const USES_POLICY_FORCE_LOCK = 3;

  /// from: static public final int USES_POLICY_LIMIT_PASSWORD
  ///
  /// A type of policy that this device admin can use: limit the passwords
  /// that the user can select, via DevicePolicyManager\#setPasswordQuality
  /// and DevicePolicyManager\#setPasswordMinimumLength.
  ///
  /// To control this policy, the device admin must have a "limit-password"
  /// tag in the "uses-policies" section of its meta-data.
  ///
  /// This policy is deprecated for use by a device admin.  In future releases, it will
  /// only be possible for a device owner or profile owner to enforce constraints on user
  /// passwords.
  static const USES_POLICY_LIMIT_PASSWORD = 0;

  /// from: static public final int USES_POLICY_RESET_PASSWORD
  ///
  /// A type of policy that this device admin can use: able to reset the
  /// user's password via
  /// DevicePolicyManager\#resetPassword.
  ///
  /// To control this policy, the device admin must have a "reset-password"
  /// tag in the "uses-policies" section of its meta-data.
  static const USES_POLICY_RESET_PASSWORD = 2;

  /// from: static public final int USES_POLICY_WATCH_LOGIN
  ///
  /// A type of policy that this device admin can use: able to watch login
  /// attempts from the user, via DeviceAdminReceiver\#ACTION_PASSWORD_FAILED,
  /// DeviceAdminReceiver\#ACTION_PASSWORD_SUCCEEDED, and
  /// DevicePolicyManager\#getCurrentFailedPasswordAttempts.
  ///
  /// To control this policy, the device admin must have a "watch-login"
  /// tag in the "uses-policies" section of its meta-data.
  static const USES_POLICY_WATCH_LOGIN = 1;

  /// from: static public final int USES_POLICY_WIPE_DATA
  ///
  /// A type of policy that this device admin can use: able to factory
  /// reset the device, erasing all of the user's data, via
  /// DevicePolicyManager\#wipeData.
  ///
  /// To control this policy, the device admin must have a "wipe-data"
  /// tag in the "uses-policies" section of its meta-data.
  static const USES_POLICY_WIPE_DATA = 4;

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminInfo__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context, android.content.pm.ResolveInfo resolveInfo)
  ///
  /// Constructor.
  ///@param context The Context in which we are parsing the device admin.
  ///@param resolveInfo The ResolveInfo returned from the package manager about
  /// this device admin's component.
  DeviceAdminInfo(content_.Context context, pm_.ResolveInfo resolveInfo)
      : super.fromRef(_ctor(context.reference, resolveInfo.reference).object);

  static final _getPackageName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminInfo__getPackageName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPackageName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the .apk package that implements this device admin.
  jni.JniString getPackageName() =>
      jni.JniString.fromRef(_getPackageName(reference).object);

  static final _getReceiverName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminInfo__getReceiverName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getReceiverName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the class name of the receiver component that implements
  /// this device admin.
  jni.JniString getReceiverName() =>
      jni.JniString.fromRef(_getReceiverName(reference).object);

  static final _getActivityInfo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminInfo__getActivityInfo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ActivityInfo getActivityInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the raw information about the receiver implementing this
  /// device admin.  Do not modify the returned object.
  pm_.ActivityInfo getActivityInfo() =>
      pm_.ActivityInfo.fromRef(_getActivityInfo(reference).object);

  static final _getComponent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminInfo__getComponent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getComponent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the component of the receiver that implements this device admin.
  ///@return This value will never be {@code null}.
  content_.ComponentName getComponent() =>
      content_.ComponentName.fromRef(_getComponent(reference).object);

  static final _loadLabel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminInfo__loadLabel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence loadLabel(android.content.pm.PackageManager pm)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Load the user-displayed label for this device admin.
  ///@param pm Supply a PackageManager used to load the device admin's
  /// resources.
  jni.JniObject loadLabel(pm_.PackageManager pm) =>
      jni.JniObject.fromRef(_loadLabel(reference, pm.reference).object);

  static final _loadDescription = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminInfo__loadDescription")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence loadDescription(android.content.pm.PackageManager pm)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Load user-visible description associated with this device admin.
  ///@param pm Supply a PackageManager used to load the device admin's
  /// resources.
  jni.JniObject loadDescription(pm_.PackageManager pm) =>
      jni.JniObject.fromRef(_loadDescription(reference, pm.reference).object);

  static final _loadIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminInfo__loadIcon")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable loadIcon(android.content.pm.PackageManager pm)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Load the user-displayed icon for this device admin.
  ///@param pm Supply a PackageManager used to load the device admin's
  /// resources.
  jni.JniObject loadIcon(pm_.PackageManager pm) =>
      jni.JniObject.fromRef(_loadIcon(reference, pm.reference).object);

  static final _isVisible = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminInfo__isVisible")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isVisible()
  ///
  /// Returns whether this device admin would like to be visible to the
  /// user, even when it is not enabled.
  bool isVisible() => _isVisible(reference).boolean;

  static final _usesPolicy = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DeviceAdminInfo__usesPolicy")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean usesPolicy(int policyIdent)
  ///
  /// Return true if the device admin has requested that it be able to use
  /// the given policy control.  The possible policy identifier inputs are:
  /// \#USES_POLICY_LIMIT_PASSWORD, \#USES_POLICY_WATCH_LOGIN,
  /// \#USES_POLICY_RESET_PASSWORD, \#USES_POLICY_FORCE_LOCK,
  /// \#USES_POLICY_WIPE_DATA,
  /// \#USES_POLICY_EXPIRE_PASSWORD, \#USES_ENCRYPTED_STORAGE,
  /// \#USES_POLICY_DISABLE_CAMERA.
  bool usesPolicy(int policyIdent) =>
      _usesPolicy(reference, policyIdent).boolean;

  static final _getTagForPolicy = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DeviceAdminInfo__getTagForPolicy")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getTagForPolicy(int policyIdent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the XML tag name for the given policy identifier.  Valid identifiers
  /// are as per \#usesPolicy(int).  If the given identifier is not
  /// known, null is returned.
  jni.JniString getTagForPolicy(int policyIdent) =>
      jni.JniString.fromRef(_getTagForPolicy(reference, policyIdent).object);

  static final _supportsTransferOwnership = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminInfo__supportsTransferOwnership")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean supportsTransferOwnership()
  ///
  /// Return true if this administrator can be a target in an ownership transfer.
  bool supportsTransferOwnership() =>
      _supportsTransferOwnership(reference).boolean;

  static final _dump = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminInfo__dump")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  void dump(jni.JniObject pw, jni.JniString prefix) =>
      _dump(reference, pw.reference, prefix.reference).check();

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminInfo__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DeviceAdminInfo__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  ///
  /// Used to package this object into a Parcel.
  ///@param dest The Parcel to be written.
  ///@param flags The flags used for parceling.
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminInfo__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;
}

/// from: android.app.admin.DeviceAdminReceiver
///
/// Base class for implementing a device administration component.  This
/// class provides a convenience for interpreting the raw intent actions
/// that are sent by the system.
///
/// The callback methods, like the base
/// BroadcastReceiver\#onReceive(Context, Intent) BroadcastReceiver.onReceive()
/// method, happen on the main thread of the process.  Thus long running
/// operations must be done on another thread.  Note that because a receiver
/// is done once returning from its receive function, such long-running operations
/// should probably be done in a Service.
///
/// When publishing your DeviceAdmin subclass as a receiver, it must
/// handle \#ACTION_DEVICE_ADMIN_ENABLED and require the
/// android.Manifest.permission\#BIND_DEVICE_ADMIN permission.  A typical
/// manifest entry would look like:
///
///
/// {@sample development/samples/ApiDemos/AndroidManifest.xml device_admin_declaration}
///
/// The meta-data referenced here provides addition information specific
/// to the device administrator, as parsed by the DeviceAdminInfo class.
/// A typical file would be:
///
///
/// {@sample development/samples/ApiDemos/res/xml/device_admin_sample.xml meta_data}
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about device administration, read the
/// <a href="{@docRoot}guide/topics/admin/device-admin.html">Device Administration</a>
/// developer guide.
///
/// </div>
class DeviceAdminReceiver extends content_.BroadcastReceiver {
  DeviceAdminReceiver.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_DEVICE_ADMIN_DISABLED
  ///
  /// Action sent to a device administrator when the user has disabled
  /// it.  Upon return, the application no longer has access to the
  /// protected device policy manager APIs.  You will generally
  /// handle this in DeviceAdminReceiver\#onDisabled(Context, Intent).  Note
  /// that this action will be
  /// sent the receiver regardless of whether it is explicitly listed in
  /// its intent filter.
  static const ACTION_DEVICE_ADMIN_DISABLED =
      "android.app.action.DEVICE_ADMIN_DISABLED";

  /// from: static public final java.lang.String ACTION_DEVICE_ADMIN_DISABLE_REQUESTED
  ///
  /// Action sent to a device administrator when the user has requested to
  /// disable it, but before this has actually been done.  This gives you
  /// a chance to supply a message to the user about the impact of
  /// disabling your admin, by setting the extra field
  /// \#EXTRA_DISABLE_WARNING in the result Intent.  If not set,
  /// no warning will be displayed.  If set, the given text will be shown
  /// to the user before they disable your admin.
  static const ACTION_DEVICE_ADMIN_DISABLE_REQUESTED =
      "android.app.action.DEVICE_ADMIN_DISABLE_REQUESTED";

  /// from: static public final java.lang.String ACTION_DEVICE_ADMIN_ENABLED
  ///
  /// This is the primary action that a device administrator must implement to be
  /// allowed to manage a device.  This will be set to the receiver
  /// when the user enables it for administration.  You will generally
  /// handle this in DeviceAdminReceiver\#onEnabled(Context, Intent).  To be
  /// supported, the receiver must also require the
  /// android.Manifest.permission\#BIND_DEVICE_ADMIN permission so
  /// that other applications can not abuse it.
  static const ACTION_DEVICE_ADMIN_ENABLED =
      "android.app.action.DEVICE_ADMIN_ENABLED";

  /// from: static public final java.lang.String ACTION_LOCK_TASK_ENTERING
  ///
  /// Action sent to a device administrator to notify that the device is entering
  /// lock task mode.  The extra \#EXTRA_LOCK_TASK_PACKAGE
  /// will describe the package using lock task mode.
  ///
  /// The calling device admin must be the device owner or profile
  /// owner to receive this broadcast.
  ///@see DevicePolicyManager\#isLockTaskPermitted(String)
  static const ACTION_LOCK_TASK_ENTERING =
      "android.app.action.LOCK_TASK_ENTERING";

  /// from: static public final java.lang.String ACTION_LOCK_TASK_EXITING
  ///
  /// Action sent to a device administrator to notify that the device is exiting
  /// lock task mode.
  ///
  /// The calling device admin must be the device owner or profile
  /// owner to receive this broadcast.
  ///@see DevicePolicyManager\#isLockTaskPermitted(String)
  static const ACTION_LOCK_TASK_EXITING =
      "android.app.action.LOCK_TASK_EXITING";

  /// from: static public final java.lang.String ACTION_PASSWORD_CHANGED
  ///
  /// Action sent to a device administrator when the user has changed the password of their device
  /// or profile challenge.  You can at this point check the characteristics
  /// of the new password with DevicePolicyManager\#isActivePasswordSufficient() DevicePolicyManager.isActivePasswordSufficient().
  /// You will generally
  /// handle this in DeviceAdminReceiver\#onPasswordChanged(Context, Intent, UserHandle).
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to receive
  /// this broadcast.
  static const ACTION_PASSWORD_CHANGED =
      "android.app.action.ACTION_PASSWORD_CHANGED";

  /// from: static public final java.lang.String ACTION_PASSWORD_EXPIRING
  ///
  /// Action periodically sent to a device administrator when the device or profile challenge
  /// password is expiring.  You will generally
  /// handle this in DeviceAdminReceiver\#onPasswordExpiring(Context, Intent, UserHandle).
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_EXPIRE_PASSWORD to receive
  /// this broadcast.
  static const ACTION_PASSWORD_EXPIRING =
      "android.app.action.ACTION_PASSWORD_EXPIRING";

  /// from: static public final java.lang.String ACTION_PASSWORD_FAILED
  ///
  /// Action sent to a device administrator when the user has entered an incorrect device
  /// or profile challenge password.  You can at this point check the
  /// number of failed password attempts there have been with
  /// DevicePolicyManager\#getCurrentFailedPasswordAttempts DevicePolicyManager.getCurrentFailedPasswordAttempts().  You will generally
  /// handle this in DeviceAdminReceiver\#onPasswordFailed(Context, Intent, UserHandle).
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_WATCH_LOGIN to receive
  /// this broadcast.
  static const ACTION_PASSWORD_FAILED =
      "android.app.action.ACTION_PASSWORD_FAILED";

  /// from: static public final java.lang.String ACTION_PASSWORD_SUCCEEDED
  ///
  /// Action sent to a device administrator when the user has successfully entered their device
  /// or profile challenge password, after failing one or more times.  You will generally
  /// handle this in DeviceAdminReceiver\#onPasswordSucceeded(Context, Intent, UserHandle).
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_WATCH_LOGIN to receive
  /// this broadcast.
  static const ACTION_PASSWORD_SUCCEEDED =
      "android.app.action.ACTION_PASSWORD_SUCCEEDED";

  /// from: static public final java.lang.String ACTION_PROFILE_PROVISIONING_COMPLETE
  ///
  /// Broadcast Action: This broadcast is sent to indicate that provisioning of a managed profile
  /// or managed device has completed successfully.
  ///
  /// The broadcast is limited to the profile that will be managed by the application that
  /// requested provisioning. In the device owner case the profile is the primary user.
  /// The broadcast will also be limited to the DeviceAdminReceiver component
  /// specified in the original intent or NFC bump that started the provisioning process
  /// (see DevicePolicyManager\#ACTION_PROVISION_MANAGED_PROFILE DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE).
  ///
  /// A device admin application which listens to this intent can find out if the device was
  /// provisioned for the device owner or profile owner case by calling respectively
  /// android.app.admin.DevicePolicyManager\#isDeviceOwnerApp and
  /// android.app.admin.DevicePolicyManager\#isProfileOwnerApp. You will generally handle
  /// this in DeviceAdminReceiver\#onProfileProvisioningComplete.
  ///@see DevicePolicyManager\#ACTION_PROVISIONING_SUCCESSFUL
  static const ACTION_PROFILE_PROVISIONING_COMPLETE =
      "android.app.action.PROFILE_PROVISIONING_COMPLETE";

  /// from: static public final int BUGREPORT_FAILURE_FAILED_COMPLETING
  ///
  /// Bugreport completion process failed.
  ///
  /// If this error code is received, the requesting of bugreport can be retried.
  ///@see DevicePolicyManager\#requestBugreport
  static const BUGREPORT_FAILURE_FAILED_COMPLETING = 0;

  /// from: static public final int BUGREPORT_FAILURE_FILE_NO_LONGER_AVAILABLE
  ///
  /// Bugreport has been created, but is no longer available for collection.
  ///
  /// This error likely occurs because the user of the device hasn't consented to share
  /// the bugreport for a long period after its creation.
  ///
  /// If this error code is received, the requesting of bugreport can be retried.
  ///@see DevicePolicyManager\#requestBugreport
  static const BUGREPORT_FAILURE_FILE_NO_LONGER_AVAILABLE = 1;

  /// from: static public final java.lang.String DEVICE_ADMIN_META_DATA
  ///
  /// Name under which a DevicePolicy component publishes information
  /// about itself.  This meta-data must reference an XML resource containing
  /// a device-admin tag.
  static const DEVICE_ADMIN_META_DATA = "android.app.device_admin";

  /// from: static public final java.lang.String EXTRA_DISABLE_WARNING
  ///
  /// A CharSequence that can be shown to the user informing them of the
  /// impact of disabling your admin.
  ///@see \#ACTION_DEVICE_ADMIN_DISABLE_REQUESTED
  static const EXTRA_DISABLE_WARNING = "android.app.extra.DISABLE_WARNING";

  /// from: static public final java.lang.String EXTRA_LOCK_TASK_PACKAGE
  ///
  /// A string containing the name of the package entering lock task mode.
  ///@see \#ACTION_LOCK_TASK_ENTERING
  static const EXTRA_LOCK_TASK_PACKAGE = "android.app.extra.LOCK_TASK_PACKAGE";

  /// from: static public final java.lang.String EXTRA_TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE
  ///
  /// A android.os.Parcelable extra of type android.os.PersistableBundle that
  /// allows a mobile device management application to pass data to the management application
  /// instance after owner transfer.
  ///
  /// If the transfer is successful, the new owner receives the data in
  /// DeviceAdminReceiver\#onTransferOwnershipComplete(Context, PersistableBundle).
  /// The bundle is not changed during the ownership transfer.
  ///@see DevicePolicyManager\#transferOwnership(ComponentName, ComponentName, PersistableBundle)
  static const EXTRA_TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE =
      "android.app.extra.TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE";

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "DeviceAdminReceiver__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  DeviceAdminReceiver() : super.fromRef(_ctor().object);

  static final _getManager = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminReceiver__getManager")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.admin.DevicePolicyManager getManager(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the DevicePolicyManager interface for this administrator to work
  /// with the system.
  DevicePolicyManager getManager(content_.Context context) =>
      DevicePolicyManager.fromRef(
          _getManager(reference, context.reference).object);

  static final _getWho = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminReceiver__getWho")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getWho(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the ComponentName describing who this device administrator is, for
  /// use in DevicePolicyManager APIs that require the administrator to
  /// identify itself.
  content_.ComponentName getWho(content_.Context context) =>
      content_.ComponentName.fromRef(
          _getWho(reference, context.reference).object);

  static final _onEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminReceiver__onEnabled")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onEnabled(android.content.Context context, android.content.Intent intent)
  ///
  /// Called after the administrator is first enabled, as a result of
  /// receiving \#ACTION_DEVICE_ADMIN_ENABLED.  At this point you
  /// can use DevicePolicyManager to set your desired policies.
  ///
  ///  If the admin is activated by a device owner, then the intent
  /// may contain private extras that are relevant to user setup.
  /// {@see DevicePolicyManager\#createAndManageUser(ComponentName, String, ComponentName,
  ///      PersistableBundle, int)}
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  void onEnabled(content_.Context context, content_.Intent intent) =>
      _onEnabled(reference, context.reference, intent.reference).check();

  static final _onDisableRequested = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onDisableRequested")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence onDisableRequested(android.content.Context context, android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called when the user has asked to disable the administrator, as a result of
  /// receiving \#ACTION_DEVICE_ADMIN_DISABLE_REQUESTED, giving you
  /// a chance to present a warning message to them.  The message is returned
  /// as the result; if null is returned (the default implementation), no
  /// message will be displayed.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@return Return the warning message to display to the user before
  /// being disabled; if null is returned, no message is displayed.
  jni.JniObject onDisableRequested(
          content_.Context context, content_.Intent intent) =>
      jni.JniObject.fromRef(
          _onDisableRequested(reference, context.reference, intent.reference)
              .object);

  static final _onDisabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminReceiver__onDisabled")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onDisabled(android.content.Context context, android.content.Intent intent)
  ///
  /// Called prior to the administrator being disabled, as a result of
  /// receiving \#ACTION_DEVICE_ADMIN_DISABLED.  Upon return, you
  /// can no longer use the protected parts of the DevicePolicyManager
  /// API.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  void onDisabled(content_.Context context, content_.Intent intent) =>
      _onDisabled(reference, context.reference, intent.reference).check();

  static final _onPasswordChanged = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onPasswordChanged")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onPasswordChanged(android.content.Context context, android.content.Intent intent)
  ///
  /// Called after the user has changed their device or profile challenge password, as a result of
  /// receiving \#ACTION_PASSWORD_CHANGED.  At this point you
  /// can use DevicePolicyManager\#getPasswordQuality(android.content.ComponentName)
  /// to retrieve the active password characteristics.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@deprecated From android.os.Build.VERSION_CODES\#O, use
  ///             \#onPasswordChanged(Context, Intent, UserHandle) instead.
  void onPasswordChanged(content_.Context context, content_.Intent intent) =>
      _onPasswordChanged(reference, context.reference, intent.reference)
          .check();

  static final _onPasswordChanged1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onPasswordChanged1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPasswordChanged(android.content.Context context, android.content.Intent intent, android.os.UserHandle user)
  ///
  /// Called after the user has changed their device or profile challenge password, as a result of
  /// receiving \#ACTION_PASSWORD_CHANGED.  At this point you
  /// can use DevicePolicyManager\#getPasswordQuality(android.content.ComponentName)
  /// to retrieve the active password characteristics.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param user The user or profile for whom the password changed. To see whether this
  ///        user is the current profile or a parent user, check for equality with
  ///        Process\#myUserHandle.
  void onPasswordChanged1(content_.Context context, content_.Intent intent,
          os_.UserHandle user) =>
      _onPasswordChanged1(
              reference, context.reference, intent.reference, user.reference)
          .check();

  static final _onPasswordFailed = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onPasswordFailed")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onPasswordFailed(android.content.Context context, android.content.Intent intent)
  ///
  /// Called after the user has failed at entering their device or profile challenge password,
  /// as a result of receiving \#ACTION_PASSWORD_FAILED.  At this point you can use
  /// DevicePolicyManager\#getCurrentFailedPasswordAttempts() to retrieve the number of
  /// failed password attempts.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@deprecated From android.os.Build.VERSION_CODES\#O, use
  ///             \#onPasswordFailed(Context, Intent, UserHandle) instead.
  void onPasswordFailed(content_.Context context, content_.Intent intent) =>
      _onPasswordFailed(reference, context.reference, intent.reference).check();

  static final _onPasswordFailed1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onPasswordFailed1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPasswordFailed(android.content.Context context, android.content.Intent intent, android.os.UserHandle user)
  ///
  /// Called after the user has failed at entering their device or profile challenge password,
  /// as a result of receiving \#ACTION_PASSWORD_FAILED.  At this point you can use
  /// DevicePolicyManager\#getCurrentFailedPasswordAttempts() to retrieve the number of
  /// failed password attempts.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param user The user or profile for whom the password check failed. To see whether this
  ///        user is the current profile or a parent user, check for equality with
  ///        Process\#myUserHandle.
  void onPasswordFailed1(content_.Context context, content_.Intent intent,
          os_.UserHandle user) =>
      _onPasswordFailed1(
              reference, context.reference, intent.reference, user.reference)
          .check();

  static final _onPasswordSucceeded = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onPasswordSucceeded")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onPasswordSucceeded(android.content.Context context, android.content.Intent intent)
  ///
  /// Called after the user has succeeded at entering their device or profile challenge password,
  /// as a result of receiving \#ACTION_PASSWORD_SUCCEEDED.  This will
  /// only be received the first time they succeed after having previously
  /// failed.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@deprecated From android.os.Build.VERSION_CODES\#O, use
  ///             \#onPasswordSucceeded(Context, Intent, UserHandle) instead.
  void onPasswordSucceeded(content_.Context context, content_.Intent intent) =>
      _onPasswordSucceeded(reference, context.reference, intent.reference)
          .check();

  static final _onPasswordSucceeded1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onPasswordSucceeded1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPasswordSucceeded(android.content.Context context, android.content.Intent intent, android.os.UserHandle user)
  ///
  /// Called after the user has succeeded at entering their device or profile challenge password,
  /// as a result of receiving \#ACTION_PASSWORD_SUCCEEDED.  This will
  /// only be received the first time they succeed after having previously
  /// failed.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param user The user of profile for whom the password check succeeded.  To see whether this
  ///        user is the current profile or a parent user, check for equality with
  ///        Process\#myUserHandle.
  void onPasswordSucceeded1(content_.Context context, content_.Intent intent,
          os_.UserHandle user) =>
      _onPasswordSucceeded1(
              reference, context.reference, intent.reference, user.reference)
          .check();

  static final _onPasswordExpiring = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onPasswordExpiring")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onPasswordExpiring(android.content.Context context, android.content.Intent intent)
  ///
  /// Called periodically when the device or profile challenge password is about to expire
  /// or has expired.  It will typically be called at these times: on device boot, once per day
  /// before the password expires, and at the time when the password expires.
  ///
  /// If the password is not updated by the user, this method will continue to be called
  /// once per day until the password is changed or the device admin disables password expiration.
  ///
  /// The admin will typically post a notification requesting the user to change their password
  /// in response to this call. The actual password expiration time can be obtained by calling
  /// DevicePolicyManager\#getPasswordExpiration(ComponentName)
  ///
  /// The admin should be sure to take down any notifications it posted in response to this call
  /// when it receives DeviceAdminReceiver\#onPasswordChanged(Context, Intent).
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@deprecated From android.os.Build.VERSION_CODES\#O, use
  ///             \#onPasswordExpiring(Context, Intent, UserHandle) instead.
  void onPasswordExpiring(content_.Context context, content_.Intent intent) =>
      _onPasswordExpiring(reference, context.reference, intent.reference)
          .check();

  static final _onPasswordExpiring1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onPasswordExpiring1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPasswordExpiring(android.content.Context context, android.content.Intent intent, android.os.UserHandle user)
  ///
  /// Called periodically when the device or profile challenge password is about to expire
  /// or has expired.  It will typically be called at these times: on device boot, once per day
  /// before the password expires, and at the time when the password expires.
  ///
  /// If the password is not updated by the user, this method will continue to be called
  /// once per day until the password is changed or the device admin disables password expiration.
  ///
  /// The admin will typically post a notification requesting the user to change their password
  /// in response to this call. The actual password expiration time can be obtained by calling
  /// DevicePolicyManager\#getPasswordExpiration(ComponentName)
  ///
  /// The admin should be sure to take down any notifications it posted in response to this call
  /// when it receives DeviceAdminReceiver\#onPasswordChanged(Context, Intent, UserHandle).
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param user The user or profile for whom the password is expiring. To see whether this
  ///        user is the current profile or a parent user, check for equality with
  ///        Process\#myUserHandle.
  void onPasswordExpiring1(content_.Context context, content_.Intent intent,
          os_.UserHandle user) =>
      _onPasswordExpiring1(
              reference, context.reference, intent.reference, user.reference)
          .check();

  static final _onProfileProvisioningComplete = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onProfileProvisioningComplete")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onProfileProvisioningComplete(android.content.Context context, android.content.Intent intent)
  ///
  /// Called when provisioning of a managed profile or managed device has completed successfully.
  ///
  ///  As a prerequisite for the execution of this callback the DeviceAdminReceiver has
  /// to declare an intent filter for \#ACTION_PROFILE_PROVISIONING_COMPLETE.
  /// Its component must also be specified in the DevicePolicyManager\#EXTRA_DEVICE_ADMIN
  /// of the DevicePolicyManager\#ACTION_PROVISION_MANAGED_PROFILE intent that started the
  /// managed provisioning.
  ///
  /// When provisioning of a managed profile is complete, the managed profile is hidden until
  /// the profile owner calls DevicePolicyManager\#setProfileEnabled(ComponentName admin).
  /// Typically a profile owner will enable the profile when it has finished any additional setup
  /// such as adding an account by using the AccountManager and calling APIs to bring the
  /// profile into the desired state.
  ///
  ///  Note that provisioning completes without waiting for any server interactions, so the
  /// profile owner needs to wait for data to be available if required (e.g. Android device IDs or
  /// other data that is set as a result of server interactions).
  ///
  /// From version android.os.Build.VERSION_CODES\#O, when managed provisioning has
  /// completed, along with this callback the activity intent
  /// DevicePolicyManager\#ACTION_PROVISIONING_SUCCESSFUL will also be sent to the same
  /// application.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  void onProfileProvisioningComplete(
          content_.Context context, content_.Intent intent) =>
      _onProfileProvisioningComplete(
              reference, context.reference, intent.reference)
          .check();

  static final _onReadyForUserInitialization = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onReadyForUserInitialization")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onReadyForUserInitialization(android.content.Context context, android.content.Intent intent)
  ///
  /// Called during provisioning of a managed device to allow the device initializer to perform
  /// user setup steps.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@deprecated Do not use
  void onReadyForUserInitialization(
          content_.Context context, content_.Intent intent) =>
      _onReadyForUserInitialization(
              reference, context.reference, intent.reference)
          .check();

  static final _onLockTaskModeEntering = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onLockTaskModeEntering")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onLockTaskModeEntering(android.content.Context context, android.content.Intent intent, java.lang.String pkg)
  ///
  /// Called when a device is entering lock task mode.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param pkg If entering, the authorized package using lock task mode, otherwise null.
  void onLockTaskModeEntering(content_.Context context, content_.Intent intent,
          jni.JniString pkg) =>
      _onLockTaskModeEntering(
              reference, context.reference, intent.reference, pkg.reference)
          .check();

  static final _onLockTaskModeExiting = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onLockTaskModeExiting")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onLockTaskModeExiting(android.content.Context context, android.content.Intent intent)
  ///
  /// Called when a device is exiting lock task mode.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  void onLockTaskModeExiting(
          content_.Context context, content_.Intent intent) =>
      _onLockTaskModeExiting(reference, context.reference, intent.reference)
          .check();

  static final _onChoosePrivateKeyAlias = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onChoosePrivateKeyAlias")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String onChoosePrivateKeyAlias(android.content.Context context, android.content.Intent intent, int uid, android.net.Uri uri, java.lang.String alias)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Allows this receiver to select the alias for a private key and certificate pair for
  /// authentication. If this method returns null, the default android.app.Activity will be
  /// shown that lets the user pick a private key and certificate pair.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param uid The uid asking for the private key and certificate pair.
  ///@param uri The URI to authenticate, may be null.
  ///@param alias The alias preselected by the client, or null.
  ///@return The private key alias to return and grant access to.
  ///@see KeyChain\#choosePrivateKeyAlias
  jni.JniString onChoosePrivateKeyAlias(
          content_.Context context,
          content_.Intent intent,
          int uid,
          jni.JniObject uri,
          jni.JniString alias) =>
      jni.JniString.fromRef(_onChoosePrivateKeyAlias(
              reference,
              context.reference,
              intent.reference,
              uid,
              uri.reference,
              alias.reference)
          .object);

  static final _onSystemUpdatePending = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("DeviceAdminReceiver__onSystemUpdatePending")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onSystemUpdatePending(android.content.Context context, android.content.Intent intent, long receivedTime)
  ///
  /// Called when the information about a pending system update is available.
  ///
  /// Allows the receiver to be notified when information about a pending system update is
  /// available from the system update service. The same pending system update can trigger multiple
  /// calls to this method, so it is necessary to examine the incoming parameters for details about
  /// the update.
  ///
  /// This callback is only applicable to device owners and profile owners.
  ///
  /// To get further information about a pending system update (for example, whether or not the
  /// update is a security patch), the device owner or profile owner can call
  /// DevicePolicyManager\#getPendingSystemUpdate.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param receivedTime The time as given by System\#currentTimeMillis() indicating when
  ///        the current pending update was first available. -1 if no pending update is available.
  ///@see DevicePolicyManager\#getPendingSystemUpdate
  void onSystemUpdatePending(
          content_.Context context, content_.Intent intent, int receivedTime) =>
      _onSystemUpdatePending(
              reference, context.reference, intent.reference, receivedTime)
          .check();

  static final _onBugreportSharingDeclined = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onBugreportSharingDeclined")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onBugreportSharingDeclined(android.content.Context context, android.content.Intent intent)
  ///
  /// Called when sharing a bugreport has been cancelled by the user of the device.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@see DevicePolicyManager\#requestBugreport
  void onBugreportSharingDeclined(
          content_.Context context, content_.Intent intent) =>
      _onBugreportSharingDeclined(
              reference, context.reference, intent.reference)
          .check();

  static final _onBugreportShared = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onBugreportShared")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onBugreportShared(android.content.Context context, android.content.Intent intent, java.lang.String bugreportHash)
  ///
  /// Called when the bugreport has been shared with the device administrator app.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive. Contains the URI of
  /// the bugreport file (with MIME type "application/vnd.android.bugreport"), that can be accessed
  /// by calling Intent\#getData()
  ///@param bugreportHash SHA-256 hash of the bugreport file.
  ///@see DevicePolicyManager\#requestBugreport
  void onBugreportShared(content_.Context context, content_.Intent intent,
          jni.JniString bugreportHash) =>
      _onBugreportShared(reference, context.reference, intent.reference,
              bugreportHash.reference)
          .check();

  static final _onBugreportFailed = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DeviceAdminReceiver__onBugreportFailed")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onBugreportFailed(android.content.Context context, android.content.Intent intent, int failureCode)
  ///
  /// Called when the bugreport collection flow has failed.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param failureCode int containing failure code. One of
  /// \#BUGREPORT_FAILURE_FAILED_COMPLETING
  /// or \#BUGREPORT_FAILURE_FILE_NO_LONGER_AVAILABLE
  /// Value is android.app.admin.DeviceAdminReceiver\#BUGREPORT_FAILURE_FAILED_COMPLETING, or android.app.admin.DeviceAdminReceiver\#BUGREPORT_FAILURE_FILE_NO_LONGER_AVAILABLE
  ///@see DevicePolicyManager\#requestBugreport
  void onBugreportFailed(
          content_.Context context, content_.Intent intent, int failureCode) =>
      _onBugreportFailed(
              reference, context.reference, intent.reference, failureCode)
          .check();

  static final _onSecurityLogsAvailable = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onSecurityLogsAvailable")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onSecurityLogsAvailable(android.content.Context context, android.content.Intent intent)
  ///
  /// Called when a new batch of security logs can be retrieved.
  ///
  /// If a secondary user or profile is created, this callback won't be received until all users
  /// become affiliated again (even if security logging is enabled).
  /// See DevicePolicyManager\#setAffiliationIds
  ///
  /// This callback will be re-triggered if the logs are not retrieved.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@see DevicePolicyManager\#retrieveSecurityLogs(ComponentName)
  void onSecurityLogsAvailable(
          content_.Context context, content_.Intent intent) =>
      _onSecurityLogsAvailable(reference, context.reference, intent.reference)
          .check();

  static final _onNetworkLogsAvailable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Int32)>>("DeviceAdminReceiver__onNetworkLogsAvailable")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void onNetworkLogsAvailable(android.content.Context context, android.content.Intent intent, long batchToken, int networkLogsCount)
  ///
  /// Called each time a new batch of network logs can be retrieved. This callback method will only
  /// ever be called when network logging is enabled. The logs can only be retrieved while network
  /// logging is enabled.
  ///
  /// If a secondary user or profile is created, this callback won't be received until all users
  /// become affiliated again (even if network logging is enabled). It will also no longer be
  /// possible to retrieve the network logs batch with the most recent {@code batchToken} provided
  /// by this callback. See DevicePolicyManager\#setAffiliationIds.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param batchToken The token representing the current batch of network logs.
  ///@param networkLogsCount The total count of events in the current batch of network logs.
  ///@see DevicePolicyManager\#retrieveNetworkLogs
  void onNetworkLogsAvailable(content_.Context context, content_.Intent intent,
          int batchToken, int networkLogsCount) =>
      _onNetworkLogsAvailable(reference, context.reference, intent.reference,
              batchToken, networkLogsCount)
          .check();

  static final _onUserAdded = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminReceiver__onUserAdded")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onUserAdded(android.content.Context context, android.content.Intent intent, android.os.UserHandle newUser)
  ///
  /// Called when a user or profile is created.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param newUser The UserHandle of the user that has just been added.
  ///
  /// This value must never be {@code null}.
  void onUserAdded(content_.Context context, content_.Intent intent,
          os_.UserHandle newUser) =>
      _onUserAdded(
              reference, context.reference, intent.reference, newUser.reference)
          .check();

  static final _onUserRemoved = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminReceiver__onUserRemoved")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onUserRemoved(android.content.Context context, android.content.Intent intent, android.os.UserHandle removedUser)
  ///
  /// Called when a user or profile is removed.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param removedUser The UserHandle of the user that has just been removed.
  ///
  /// This value must never be {@code null}.
  void onUserRemoved(content_.Context context, content_.Intent intent,
          os_.UserHandle removedUser) =>
      _onUserRemoved(reference, context.reference, intent.reference,
              removedUser.reference)
          .check();

  static final _onUserStarted = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminReceiver__onUserStarted")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onUserStarted(android.content.Context context, android.content.Intent intent, android.os.UserHandle startedUser)
  ///
  /// Called when a user or profile is started.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param startedUser The UserHandle of the user that has just been started.
  ///
  /// This value must never be {@code null}.
  void onUserStarted(content_.Context context, content_.Intent intent,
          os_.UserHandle startedUser) =>
      _onUserStarted(reference, context.reference, intent.reference,
              startedUser.reference)
          .check();

  static final _onUserStopped = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminReceiver__onUserStopped")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onUserStopped(android.content.Context context, android.content.Intent intent, android.os.UserHandle stoppedUser)
  ///
  /// Called when a user or profile is stopped.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param stoppedUser The UserHandle of the user that has just been stopped.
  ///
  /// This value must never be {@code null}.
  void onUserStopped(content_.Context context, content_.Intent intent,
          os_.UserHandle stoppedUser) =>
      _onUserStopped(reference, context.reference, intent.reference,
              stoppedUser.reference)
          .check();

  static final _onUserSwitched = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onUserSwitched")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onUserSwitched(android.content.Context context, android.content.Intent intent, android.os.UserHandle switchedUser)
  ///
  /// Called when a user or profile is switched to.
  ///
  /// This callback is only applicable to device owners.
  ///@param context The running context as per \#onReceive.
  ///@param intent The received intent as per \#onReceive.
  ///@param switchedUser The UserHandle of the user that has just been switched to.
  ///
  /// This value must never be {@code null}.
  void onUserSwitched(content_.Context context, content_.Intent intent,
          os_.UserHandle switchedUser) =>
      _onUserSwitched(reference, context.reference, intent.reference,
              switchedUser.reference)
          .check();

  static final _onTransferOwnershipComplete = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onTransferOwnershipComplete")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onTransferOwnershipComplete(android.content.Context context, android.os.PersistableBundle bundle)
  ///
  /// Called on the newly assigned owner (either device owner or profile owner) when the ownership
  /// transfer has completed successfully.
  ///
  ///  The {@code bundle} parameter allows the original owner to pass data
  /// to the new one.
  ///@param context the running context as per \#onReceive
  /// This value must never be {@code null}.
  ///@param bundle the data to be passed to the new owner
  ///
  /// This value may be {@code null}.
  void onTransferOwnershipComplete(
          content_.Context context, os_.PersistableBundle bundle) =>
      _onTransferOwnershipComplete(
              reference, context.reference, bundle.reference)
          .check();

  static final _onTransferAffiliatedProfileOwnershipComplete = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DeviceAdminReceiver__onTransferAffiliatedProfileOwnershipComplete")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onTransferAffiliatedProfileOwnershipComplete(android.content.Context context, android.os.UserHandle user)
  ///
  /// Called on the device owner when the ownership of one of its affiliated profiles is
  /// transferred.
  ///
  /// This can be used when transferring both device and profile ownership when using
  /// work profile on a fully managed device. The process would look like this:
  /// <ol>
  /// <li>Transfer profile ownership</li>
  /// <li>The device owner gets notified with this callback</li>
  /// <li>Transfer device ownership</li>
  /// <li>Both profile and device ownerships have been transferred</li>
  /// </ol>
  ///@param context the running context as per \#onReceive
  ///@param user the UserHandle of the affiliated user
  ///@see DevicePolicyManager\#transferOwnership(ComponentName, ComponentName, PersistableBundle)
  void onTransferAffiliatedProfileOwnershipComplete(
          content_.Context context, os_.UserHandle user) =>
      _onTransferAffiliatedProfileOwnershipComplete(
              reference, context.reference, user.reference)
          .check();

  static final _onReceive = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminReceiver__onReceive")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onReceive(android.content.Context context, android.content.Intent intent)
  ///
  /// Intercept standard device administrator broadcasts.  Implementations
  /// should not override this method; it is better to implement the
  /// convenience callbacks for each action.
  void onReceive(content_.Context context, content_.Intent intent) =>
      _onReceive(reference, context.reference, intent.reference).check();
}

/// from: android.app.admin.DeviceAdminService
///
/// Base class for a service that device owner/profile owners can optionally have.
///
/// The system searches for it with an intent filter with the
/// DevicePolicyManager\#ACTION_DEVICE_ADMIN_SERVICE action, and tries to keep a bound
/// connection as long as the hosting user is running, so that the device/profile owner is always
/// considered to be in the foreground.  This is useful to receive implicit broadcasts that
/// can no longer be received by manifest receivers by apps targeting Android version
/// android.os.Build.VERSION_CODES\#O.  Device/profile owners can use a runtime-registered
/// broadcast receiver instead, and have a DeviceAdminService so that the process is always
/// running.
///
/// Device/profile owners can use
/// android.content.pm.PackageManager\#setComponentEnabledSetting(ComponentName, int, int)
/// to disable/enable its own service.  For example, when a device/profile owner no longer needs
/// to be in the foreground, it can (and should) disable its service.
///
/// The service must be protected with the permission
/// android.Manifest.permission\#BIND_DEVICE_ADMIN.  Otherwise the system would ignore it.
///
/// When the owner process crashes, the service will be re-bound automatically after a
/// back-off.
///
/// Note the process may still be killed if the system is under heavy memory pressure, in which
/// case the process will be re-started later.
class DeviceAdminService extends app_.Service {
  DeviceAdminService.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor2 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "DeviceAdminService__ctor2")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  DeviceAdminService.ctor2() : super.fromRef(_ctor2().object);

  static final _onBind = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DeviceAdminService__onBind")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  os_.IBinder onBind(content_.Intent intent) =>
      os_.IBinder.fromRef(_onBind(reference, intent.reference).object);
}

/// from: android.app.admin.DevicePolicyManager
///
/// Public interface for managing policies enforced on a device. Most clients of this class must be
/// registered with the system as a <a href="{@docRoot}guide/topics/admin/device-admin.html">device
/// administrator</a>. Additionally, a device administrator may be registered as either a profile or
/// device owner. A given method is accessible to all device administrators unless the documentation
/// for that method specifies that it is restricted to either device or profile owners. Any
/// application calling an api may only pass as an argument a device administrator component it
/// owns. Otherwise, a SecurityException will be thrown.
/// <div class="special reference">
/// <h3>Developer Guides</h3>
///
/// For more information about managing policies for device administration, read the <a href="{@docRoot}guide/topics/admin/device-admin.html">Device Administration</a> developer
/// guide. </div>
///
/// Requires the android.content.pm.PackageManager\#FEATURE_DEVICE_ADMIN PackageManager\#FEATURE_DEVICE_ADMIN feature which can be detected using android.content.pm.PackageManager\#hasSystemFeature(String) PackageManager.hasSystemFeature(String).
class DevicePolicyManager extends jni.JniObject {
  DevicePolicyManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_ADD_DEVICE_ADMIN
  ///
  /// Activity action: ask the user to add a new device administrator to the system.
  /// The desired policy is the ComponentName of the policy in the
  /// \#EXTRA_DEVICE_ADMIN extra field.  This will invoke a UI to
  /// bring the user through adding the device administrator to the system (or
  /// allowing them to reject it).
  ///
  /// You can optionally include the \#EXTRA_ADD_EXPLANATION
  /// field to provide the user with additional explanation (in addition
  /// to your component's description) about what is being added.
  ///
  /// If your administrator is already active, this will ordinarily return immediately (without
  /// user intervention).  However, if your administrator has been updated and is requesting
  /// additional uses-policy flags, the user will be presented with the new list.  New policies
  /// will not be available to the updated administrator until the user has accepted the new list.
  static const ACTION_ADD_DEVICE_ADMIN = "android.app.action.ADD_DEVICE_ADMIN";

  /// from: static public final java.lang.String ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED
  ///
  /// Broadcast Action: Sent after application delegation scopes are changed. The new delegation
  /// scopes will be sent in an {@code ArrayList<String>} extra identified by the
  /// \#EXTRA_DELEGATION_SCOPES key.
  ///
  /// <p class=\u201dnote\u201d> Note: This is a protected intent that can only be sent by the system.
  ///
  static const ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED =
      "android.app.action.APPLICATION_DELEGATION_SCOPES_CHANGED";

  /// from: static public final java.lang.String ACTION_DEVICE_ADMIN_SERVICE
  ///
  /// Service action: Action for a service that device owner and profile owner can optionally
  /// own.  If a device owner or a profile owner has such a service, the system tries to keep
  /// a bound connection to it, in order to keep their process always running.
  /// The service must be protected with the android.Manifest.permission\#BIND_DEVICE_ADMIN
  /// permission.
  static const ACTION_DEVICE_ADMIN_SERVICE =
      "android.app.action.DEVICE_ADMIN_SERVICE";

  /// from: static public final java.lang.String ACTION_DEVICE_OWNER_CHANGED
  ///
  /// Broadcast action: sent when the device owner is set, changed or cleared.
  ///
  /// This broadcast is sent only to the primary user.
  ///@see \#ACTION_PROVISION_MANAGED_DEVICE
  ///@see DevicePolicyManager\#transferOwnership(ComponentName, ComponentName, PersistableBundle)
  static const ACTION_DEVICE_OWNER_CHANGED =
      "android.app.action.DEVICE_OWNER_CHANGED";

  /// from: static public final java.lang.String ACTION_MANAGED_PROFILE_PROVISIONED
  ///
  /// Broadcast Action: This broadcast is sent to indicate that provisioning of a managed profile
  /// has completed successfully.
  ///
  /// The broadcast is limited to the primary profile, to the app specified in the provisioning
  /// intent with action \#ACTION_PROVISION_MANAGED_PROFILE.
  ///
  /// This intent will contain the following extras
  /// <ul>
  /// <li>Intent\#EXTRA_USER, corresponds to the UserHandle of the managed
  /// profile.</li>
  /// <li>\#EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE, corresponds to the account requested to
  /// be migrated at provisioning time, if any.</li>
  /// </ul>
  static const ACTION_MANAGED_PROFILE_PROVISIONED =
      "android.app.action.MANAGED_PROFILE_PROVISIONED";

  /// from: static public final java.lang.String ACTION_PROFILE_OWNER_CHANGED
  ///
  /// Broadcast action: sent when the profile owner is set, changed or cleared.
  ///
  /// This broadcast is sent only to the user managed by the new profile owner.
  ///@see DevicePolicyManager\#transferOwnership(ComponentName, ComponentName, PersistableBundle)
  static const ACTION_PROFILE_OWNER_CHANGED =
      "android.app.action.PROFILE_OWNER_CHANGED";

  /// from: static public final java.lang.String ACTION_PROVISIONING_SUCCESSFUL
  ///
  /// Activity action: This activity action is sent to indicate that provisioning of a managed
  /// profile or managed device has completed successfully. It'll be sent at the same time as
  /// DeviceAdminReceiver\#ACTION_PROFILE_PROVISIONING_COMPLETE broadcast but this will be
  /// delivered faster as it's an activity intent.
  ///
  /// The intent is only sent to the new device or profile owner.
  ///@see \#ACTION_PROVISION_MANAGED_PROFILE
  ///@see \#ACTION_PROVISION_MANAGED_DEVICE
  static const ACTION_PROVISIONING_SUCCESSFUL =
      "android.app.action.PROVISIONING_SUCCESSFUL";

  /// from: static public final java.lang.String ACTION_PROVISION_MANAGED_DEVICE
  ///
  /// Activity action: Starts the provisioning flow which sets up a managed device.
  /// Must be started with android.app.Activity\#startActivityForResult(Intent, int).
  ///
  ///  During device owner provisioning a device admin app is set as the owner of the device.
  /// A device owner has full control over the device. The device owner can not be modified by the
  /// user.
  ///
  ///  A typical use case would be a device that is owned by a company, but used by either an
  /// employee or client.
  ///
  ///  An intent with this action can be sent only on an unprovisioned device.
  /// It is possible to check if provisioning is allowed or not by querying the method
  /// \#isProvisioningAllowed(String).
  ///
  /// The intent contains the following extras:
  /// <ul>
  /// <li>\#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME</li>
  /// <li>\#EXTRA_PROVISIONING_SKIP_ENCRYPTION, optional</li>
  /// <li>\#EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED, optional</li>
  /// <li>\#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE, optional</li>
  /// <li>\#EXTRA_PROVISIONING_LOGO_URI, optional</li>
  /// <li>\#EXTRA_PROVISIONING_MAIN_COLOR, optional</li>
  /// <li>\#EXTRA_PROVISIONING_DISCLAIMERS, optional</li>
  /// </ul>
  ///
  /// When device owner provisioning has completed, an intent of the type
  /// DeviceAdminReceiver\#ACTION_PROFILE_PROVISIONING_COMPLETE is broadcast to the
  /// device owner.
  ///
  /// From version android.os.Build.VERSION_CODES\#O, when device owner provisioning has
  /// completed, along with the above broadcast, activity intent
  /// \#ACTION_PROVISIONING_SUCCESSFUL will also be sent to the device owner.
  ///
  /// If provisioning fails, the device is factory reset.
  ///
  /// A result code of android.app.Activity\#RESULT_OK implies that the synchronous part
  /// of the provisioning flow was successful, although this doesn't guarantee the full flow will
  /// succeed. Conversely a result code of android.app.Activity\#RESULT_CANCELED implies
  /// that the user backed-out of provisioning, or some precondition for provisioning wasn't met.
  static const ACTION_PROVISION_MANAGED_DEVICE =
      "android.app.action.PROVISION_MANAGED_DEVICE";

  /// from: static public final java.lang.String ACTION_PROVISION_MANAGED_PROFILE
  ///
  /// Activity action: Starts the provisioning flow which sets up a managed profile.
  ///
  /// A managed profile allows data separation for example for the usage of a
  /// device as a personal and corporate device. The user which provisioning is started from and
  /// the managed profile share a launcher.
  ///
  /// This intent will typically be sent by a mobile device management application (MDM).
  /// Provisioning adds a managed profile and sets the MDM as the profile owner who has full
  /// control over the profile.
  ///
  /// It is possible to check if provisioning is allowed or not by querying the method
  /// \#isProvisioningAllowed(String).
  ///
  /// In version android.os.Build.VERSION_CODES\#LOLLIPOP, this intent must contain the
  /// extra \#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME.
  /// As of android.os.Build.VERSION_CODES\#M, it should contain the extra
  /// \#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME instead, although specifying only
  /// \#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME is still supported.
  ///
  /// The intent may also contain the following extras:
  /// <ul>
  /// <li>\#EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE, optional </li>
  /// <li>\#EXTRA_PROVISIONING_SKIP_ENCRYPTION, optional, supported from
  /// android.os.Build.VERSION_CODES\#N</li>
  /// <li>\#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE, optional</li>
  /// <li>\#EXTRA_PROVISIONING_LOGO_URI, optional</li>
  /// <li>\#EXTRA_PROVISIONING_MAIN_COLOR, optional</li>
  /// <li>\#EXTRA_PROVISIONING_SKIP_USER_CONSENT, optional</li>
  /// <li>\#EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION, optional</li>
  /// <li>\#EXTRA_PROVISIONING_DISCLAIMERS, optional</li>
  /// </ul>
  ///
  /// When managed provisioning has completed, broadcasts are sent to the application specified
  /// in the provisioning intent. The
  /// DeviceAdminReceiver\#ACTION_PROFILE_PROVISIONING_COMPLETE broadcast is sent in the
  /// managed profile and the \#ACTION_MANAGED_PROFILE_PROVISIONED broadcast is sent in
  /// the primary profile.
  ///
  /// From version android.os.Build.VERSION_CODES\#O, when managed provisioning has
  /// completed, along with the above broadcast, activity intent
  /// \#ACTION_PROVISIONING_SUCCESSFUL will also be sent to the profile owner.
  ///
  /// If provisioning fails, the managedProfile is removed so the device returns to its
  /// previous state.
  ///
  /// If launched with android.app.Activity\#startActivityForResult(Intent, int) a
  /// result code of android.app.Activity\#RESULT_OK implies that the synchronous part of
  /// the provisioning flow was successful, although this doesn't guarantee the full flow will
  /// succeed. Conversely a result code of android.app.Activity\#RESULT_CANCELED implies
  /// that the user backed-out of provisioning, or some precondition for provisioning wasn't met.
  static const ACTION_PROVISION_MANAGED_PROFILE =
      "android.app.action.PROVISION_MANAGED_PROFILE";

  /// from: static public final java.lang.String ACTION_SET_NEW_PARENT_PROFILE_PASSWORD
  ///
  /// Activity action: have the user enter a new password for the parent profile.
  /// If the intent is launched from within a managed profile, this will trigger
  /// entering a new password for the parent of the profile. In all other cases
  /// the behaviour is identical to \#ACTION_SET_NEW_PASSWORD.
  static const ACTION_SET_NEW_PARENT_PROFILE_PASSWORD =
      "android.app.action.SET_NEW_PARENT_PROFILE_PASSWORD";

  /// from: static public final java.lang.String ACTION_SET_NEW_PASSWORD
  ///
  /// Activity action: have the user enter a new password. This activity should
  /// be launched after using \#setPasswordQuality(ComponentName, int),
  /// or \#setPasswordMinimumLength(ComponentName, int) to have the user
  /// enter a new password that meets the current requirements. You can use
  /// \#isActivePasswordSufficient() to determine whether you need to
  /// have the user select a new password in order to meet the current
  /// constraints. Upon being resumed from this activity, you can check the new
  /// password characteristics to see if they are sufficient.
  ///
  /// If the intent is launched from within a managed profile with a profile
  /// owner built against android.os.Build.VERSION_CODES\#M or before,
  /// this will trigger entering a new password for the parent of the profile.
  /// For all other cases it will trigger entering a new password for the user
  /// or profile it is launched from.
  ///@see \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD
  static const ACTION_SET_NEW_PASSWORD = "android.app.action.SET_NEW_PASSWORD";

  /// from: static public final java.lang.String ACTION_START_ENCRYPTION
  ///
  /// Activity action: begin the process of encrypting data on the device.  This activity should
  /// be launched after using \#setStorageEncryption to request encryption be activated.
  /// After resuming from this activity, use \#getStorageEncryption
  /// to check encryption status.  However, on some devices this activity may never return, as
  /// it may trigger a reboot and in some cases a complete data wipe of the device.
  static const ACTION_START_ENCRYPTION = "android.app.action.START_ENCRYPTION";

  /// from: static public final java.lang.String ACTION_SYSTEM_UPDATE_POLICY_CHANGED
  ///
  /// Broadcast action: notify that a new local system update policy has been set by the device
  /// owner. The new policy can be retrieved by \#getSystemUpdatePolicy().
  static const ACTION_SYSTEM_UPDATE_POLICY_CHANGED =
      "android.app.action.SYSTEM_UPDATE_POLICY_CHANGED";

  /// from: static public final java.lang.String DELEGATION_APP_RESTRICTIONS
  ///
  /// Delegation of application restrictions management. This scope grants access to the
  /// \#setApplicationRestrictions and \#getApplicationRestrictions APIs.
  static const DELEGATION_APP_RESTRICTIONS = "delegation-app-restrictions";

  /// from: static public final java.lang.String DELEGATION_BLOCK_UNINSTALL
  ///
  /// Delegation of application uninstall block. This scope grants access to the
  /// \#setUninstallBlocked API.
  static const DELEGATION_BLOCK_UNINSTALL = "delegation-block-uninstall";

  /// from: static public final java.lang.String DELEGATION_CERT_INSTALL
  ///
  /// Delegation of certificate installation and management. This scope grants access to the
  /// \#getInstalledCaCerts, \#hasCaCertInstalled, \#installCaCert,
  /// \#uninstallCaCert, \#uninstallAllUserCaCerts and \#installKeyPair APIs.
  static const DELEGATION_CERT_INSTALL = "delegation-cert-install";

  /// from: static public final java.lang.String DELEGATION_ENABLE_SYSTEM_APP
  ///
  /// Delegation for enabling system apps. This scope grants access to the \#enableSystemApp
  /// API.
  static const DELEGATION_ENABLE_SYSTEM_APP = "delegation-enable-system-app";

  /// from: static public final java.lang.String DELEGATION_INSTALL_EXISTING_PACKAGE
  ///
  /// Delegation for installing existing packages. This scope grants access to the
  /// \#installExistingPackage API.
  static const DELEGATION_INSTALL_EXISTING_PACKAGE =
      "delegation-install-existing-package";

  /// from: static public final java.lang.String DELEGATION_KEEP_UNINSTALLED_PACKAGES
  ///
  /// Delegation of management of uninstalled packages. This scope grants access to the
  /// {@code \#setKeepUninstalledPackages} and {@code \#getKeepUninstalledPackages} APIs.
  static const DELEGATION_KEEP_UNINSTALLED_PACKAGES =
      "delegation-keep-uninstalled-packages";

  /// from: static public final java.lang.String DELEGATION_PACKAGE_ACCESS
  ///
  /// Delegation of package access state. This scope grants access to the
  /// \#isApplicationHidden, \#setApplicationHidden, \#isPackageSuspended, and
  /// \#setPackagesSuspended APIs.
  static const DELEGATION_PACKAGE_ACCESS = "delegation-package-access";

  /// from: static public final java.lang.String DELEGATION_PERMISSION_GRANT
  ///
  /// Delegation of permission policy and permission grant state. This scope grants access to the
  /// \#setPermissionPolicy, \#getPermissionGrantState,
  /// and \#setPermissionGrantState APIs.
  static const DELEGATION_PERMISSION_GRANT = "delegation-permission-grant";

  /// from: static public final int ENCRYPTION_STATUS_ACTIVATING
  ///
  /// Result code for \#getStorageEncryptionStatus:
  /// indicating that encryption is not currently active, but is currently
  /// being activated.  This is only reported by devices that support
  /// encryption of data and only when the storage is currently
  /// undergoing a process of becoming encrypted.  A device that must reboot and/or wipe data
  /// to become encrypted will never return this value.
  static const ENCRYPTION_STATUS_ACTIVATING = 2;

  /// from: static public final int ENCRYPTION_STATUS_ACTIVE
  ///
  /// Result code for \#setStorageEncryption and \#getStorageEncryptionStatus:
  /// indicating that encryption is active.
  ///
  /// Also see \#ENCRYPTION_STATUS_ACTIVE_PER_USER.
  static const ENCRYPTION_STATUS_ACTIVE = 3;

  /// from: static public final int ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY
  ///
  /// Result code for \#getStorageEncryptionStatus:
  /// indicating that encryption is active, but an encryption key has not
  /// been set by the user.
  static const ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY = 4;

  /// from: static public final int ENCRYPTION_STATUS_ACTIVE_PER_USER
  ///
  /// Result code for \#getStorageEncryptionStatus:
  /// indicating that encryption is active and the encryption key is tied to the user or profile.
  ///
  /// This value is only returned to apps targeting API level 24 and above. For apps targeting
  /// earlier API levels, \#ENCRYPTION_STATUS_ACTIVE is returned, even if the
  /// encryption key is specific to the user or profile.
  static const ENCRYPTION_STATUS_ACTIVE_PER_USER = 5;

  /// from: static public final int ENCRYPTION_STATUS_INACTIVE
  ///
  /// Result code for \#setStorageEncryption and \#getStorageEncryptionStatus:
  /// indicating that encryption is supported, but is not currently active.
  static const ENCRYPTION_STATUS_INACTIVE = 1;

  /// from: static public final int ENCRYPTION_STATUS_UNSUPPORTED
  ///
  /// Result code for \#setStorageEncryption and \#getStorageEncryptionStatus:
  /// indicating that encryption is not supported.
  static const ENCRYPTION_STATUS_UNSUPPORTED = 0;

  /// from: static public final java.lang.String EXTRA_ADD_EXPLANATION
  ///
  /// An optional CharSequence providing additional explanation for why the
  /// admin is being added.
  ///@see \#ACTION_ADD_DEVICE_ADMIN
  static const EXTRA_ADD_EXPLANATION = "android.app.extra.ADD_EXPLANATION";

  /// from: static public final java.lang.String EXTRA_DELEGATION_SCOPES
  ///
  /// An {@code ArrayList<String>} corresponding to the delegation scopes given to an app in the
  /// \#ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED broadcast.
  static const EXTRA_DELEGATION_SCOPES = "android.app.extra.DELEGATION_SCOPES";

  /// from: static public final java.lang.String EXTRA_DEVICE_ADMIN
  ///
  /// The ComponentName of the administrator component.
  ///@see \#ACTION_ADD_DEVICE_ADMIN
  static const EXTRA_DEVICE_ADMIN = "android.app.extra.DEVICE_ADMIN";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE
  ///
  /// An android.accounts.Account extra holding the account to migrate during managed
  /// profile provisioning. If the account supplied is present in the primary user, it will be
  /// copied, along with its credentials to the managed profile and removed from the primary user.
  ///
  /// Use with \#ACTION_PROVISION_MANAGED_PROFILE.
  static const EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE =
      "android.app.extra.PROVISIONING_ACCOUNT_TO_MIGRATE";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE
  ///
  /// A android.os.Parcelable extra of type android.os.PersistableBundle that
  /// allows a mobile device management application or NFC programmer application which starts
  /// managed provisioning to pass data to the management application instance after provisioning.
  ///
  /// If used with \#ACTION_PROVISION_MANAGED_PROFILE it can be used by the application that
  /// sends the intent to pass data to itself on the newly created profile.
  /// If used with \#ACTION_PROVISION_MANAGED_DEVICE it allows passing data to the same
  /// instance of the app on the primary user.
  /// Starting from android.os.Build.VERSION_CODES\#M, if used with
  /// \#MIME_TYPE_PROVISIONING_NFC as part of NFC managed device provisioning, the NFC
  /// message should contain a stringified java.util.Properties instance, whose string
  /// properties will be converted into a android.os.PersistableBundle and passed to the
  /// management application after provisioning.
  ///
  ///
  /// In both cases the application receives the data in
  /// DeviceAdminReceiver\#onProfileProvisioningComplete via an intent with the action
  /// DeviceAdminReceiver\#ACTION_PROFILE_PROVISIONING_COMPLETE. The bundle is not changed
  /// during the managed provisioning.
  static const EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE =
      "android.app.extra.PROVISIONING_ADMIN_EXTRAS_BUNDLE";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME
  ///
  /// A ComponentName extra indicating the device admin receiver of the mobile device management
  /// application that will be set as the profile owner or device owner and active admin.
  ///
  /// If an application starts provisioning directly via an intent with action
  /// \#ACTION_PROVISION_MANAGED_PROFILE or
  /// \#ACTION_PROVISION_MANAGED_DEVICE the package name of this
  /// component has to match the package name of the application that started provisioning.
  ///
  /// This component is set as device owner and active admin when device owner provisioning is
  /// started by an intent with action \#ACTION_PROVISION_MANAGED_DEVICE or by an NFC
  /// message containing an NFC record with MIME type
  /// \#MIME_TYPE_PROVISIONING_NFC. For the NFC record, the component name must be
  /// flattened to a string, via ComponentName\#flattenToShortString().
  ///@see DeviceAdminReceiver
  static const EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME =
      "android.app.extra.PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DEVICE_ADMIN_MINIMUM_VERSION_CODE
  ///
  /// An int extra holding a minimum required version code for the device admin package. If the
  /// device admin is already installed on the device, it will only be re-downloaded from
  /// \#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION if the version of the
  /// installed package is less than this version code.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_DEVICE_ADMIN_MINIMUM_VERSION_CODE =
      "android.app.extra.PROVISIONING_DEVICE_ADMIN_MINIMUM_VERSION_CODE";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM
  ///
  /// A String extra holding the URL-safe base64 encoded SHA-256 or SHA-1 hash (see notes below) of
  /// the file at download location specified in
  /// \#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION.
  ///
  /// Either this extra or \#EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM must be
  /// present. The provided checksum must match the checksum of the file at the download
  /// location. If the checksum doesn't match an error will be shown to the user and the user will
  /// be asked to factory reset the device.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  ///
  /// <strong>Note:</strong> for devices running android.os.Build.VERSION_CODES\#LOLLIPOP
  /// and android.os.Build.VERSION_CODES\#LOLLIPOP_MR1 only SHA-1 hash is supported.
  /// Starting from android.os.Build.VERSION_CODES\#M, this parameter accepts SHA-256 in
  /// addition to SHA-1. Support for SHA-1 is likely to be removed in future OS releases.
  static const EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM =
      "android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER
  ///
  /// A String extra holding a http cookie header which should be used in the http request to the
  /// url specified in \#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER =
      "android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION
  ///
  /// A String extra holding a url that specifies the download location of the device admin
  /// package. When not provided it is assumed that the device admin package is already installed.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION =
      "android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME
  ///
  /// A String extra holding the package name of the mobile device management application that
  /// will be set as the profile owner or device owner.
  ///
  /// If an application starts provisioning directly via an intent with action
  /// \#ACTION_PROVISION_MANAGED_PROFILE this package has to match the package name of the
  /// application that started provisioning. The package will be set as profile owner in that case.
  ///
  /// This package is set as device owner when device owner provisioning is started by an NFC
  /// message containing an NFC record with MIME type \#MIME_TYPE_PROVISIONING_NFC.
  ///
  ///  When this extra is set, the application must have exactly one device admin receiver.
  /// This receiver will be set as the profile or device owner and active admin.
  ///@see DeviceAdminReceiver
  ///@deprecated Use \#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME. This extra is still
  /// supported, but only if there is only one device admin receiver in the package that requires
  /// the permission android.Manifest.permission\#BIND_DEVICE_ADMIN.
  static const EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME =
      "android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM
  ///
  /// A String extra holding the URL-safe base64 encoded SHA-256 checksum of any signature of the
  /// android package archive at the download location specified in \#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION.
  ///
  /// The signatures of an android package archive can be obtained using
  /// android.content.pm.PackageManager\#getPackageArchiveInfo with flag
  /// android.content.pm.PackageManager\#GET_SIGNATURES.
  ///
  /// Either this extra or \#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM must be
  /// present. The provided checksum must match the checksum of any signature of the file at
  /// the download location. If the checksum does not match an error will be shown to the user and
  /// the user will be asked to factory reset the device.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM =
      "android.app.extra.PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DISCLAIMERS
  ///
  /// A Bundle[] extra consisting of list of disclaimer headers and disclaimer contents.
  /// Each Bundle must have both \#EXTRA_PROVISIONING_DISCLAIMER_HEADER
  /// as disclaimer header, and \#EXTRA_PROVISIONING_DISCLAIMER_CONTENT as disclaimer
  /// content.
  ///
  ///  The extra typically contains one disclaimer from the company of mobile device
  /// management application (MDM), and one disclaimer from the organization.
  ///
  ///  Call Bundle\#putParcelableArray(String, Parcelable[]) to put the Bundle[]
  ///
  ///  Maximum 3 key-value pairs can be specified. The rest will be ignored.
  ///
  ///  Use in an intent with action \#ACTION_PROVISION_MANAGED_PROFILE or
  /// \#ACTION_PROVISION_MANAGED_DEVICE
  static const EXTRA_PROVISIONING_DISCLAIMERS =
      "android.app.extra.PROVISIONING_DISCLAIMERS";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DISCLAIMER_CONTENT
  ///
  /// A Uri extra pointing to disclaimer content.
  ///
  /// <h5>The following URI schemes are accepted:</h5>
  /// <ul>
  /// <li>content (android.content.ContentResolver\#SCHEME_CONTENT)</li>
  /// <li>android.resource (android.content.ContentResolver\#SCHEME_ANDROID_RESOURCE)</li>
  /// </ul>
  ///
  ///  Styled text is supported in the disclaimer content. The content is parsed by
  /// android.text.Html\#fromHtml(String) and displayed in a
  /// android.widget.TextView.
  ///
  ///  If a <code>content:</code> URI is passed, URI is passed, the intent should have the flag
  /// Intent\#FLAG_GRANT_READ_URI_PERMISSION and the uri should be added to the
  /// android.content.ClipData of the intent too.
  ///
  ///  Use in Bundle \#EXTRA_PROVISIONING_DISCLAIMERS
  ///
  ///  System app, i.e. application with ApplicationInfo\#FLAG_SYSTEM, can also insert a
  /// disclaimer by declaring an application-level meta-data in {@code AndroidManifest.xml}.
  /// Must use it with \#EXTRA_PROVISIONING_DISCLAIMER_HEADER. Here is the example:
  ///
  /// <pre>
  ///  &lt;meta-data
  ///      android:name="android.app.extra.PROVISIONING_DISCLAIMER_CONTENT"
  ///      android:resource="@string/disclaimer_content"
  /// /&gt;</pre>
  static const EXTRA_PROVISIONING_DISCLAIMER_CONTENT =
      "android.app.extra.PROVISIONING_DISCLAIMER_CONTENT";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_DISCLAIMER_HEADER
  ///
  /// A String extra of localized disclaimer header.
  ///
  ///  The extra is typically the company name of mobile device management application (MDM)
  /// or the organization name.
  ///
  ///  Use in Bundle \#EXTRA_PROVISIONING_DISCLAIMERS
  ///
  ///  System app, i.e. application with ApplicationInfo\#FLAG_SYSTEM, can also insert a
  /// disclaimer by declaring an application-level meta-data in {@code AndroidManifest.xml}.
  /// Must use it with \#EXTRA_PROVISIONING_DISCLAIMER_CONTENT. Here is the example:
  ///
  /// <pre>
  ///  &lt;meta-data
  ///      android:name="android.app.extra.PROVISIONING_DISCLAIMER_HEADER"
  ///      android:resource="@string/disclaimer_header"
  /// /&gt;</pre>
  static const EXTRA_PROVISIONING_DISCLAIMER_HEADER =
      "android.app.extra.PROVISIONING_DISCLAIMER_HEADER";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_EMAIL_ADDRESS
  ///
  /// @deprecated From android.os.Build.VERSION_CODES\#O, never used while provisioning the
  /// device.
  static const EXTRA_PROVISIONING_EMAIL_ADDRESS =
      "android.app.extra.PROVISIONING_EMAIL_ADDRESS";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION
  ///
  /// Boolean extra to indicate that the migrated account should be kept. This is used in
  /// conjunction with \#EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE. If it's set to {@code true},
  /// the account will not be removed from the primary user after it is migrated to the newly
  /// created user or profile.
  ///
  ///  Defaults to {@code false}
  ///
  ///  Use with \#ACTION_PROVISION_MANAGED_PROFILE and
  /// \#EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE
  static const EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION =
      "android.app.extra.PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED
  ///
  /// A Boolean extra that can be used by the mobile device management application to skip the
  /// disabling of system apps during provisioning when set to {@code true}.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC or an intent with action
  /// \#ACTION_PROVISION_MANAGED_DEVICE that starts device owner provisioning.
  static const EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED =
      "android.app.extra.PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_LOCALE
  ///
  /// A String extra holding the java.util.Locale that the device will be set to.
  /// Format: xx_yy, where xx is the language code, and yy the country code.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_LOCALE =
      "android.app.extra.PROVISIONING_LOCALE";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_LOCAL_TIME
  ///
  /// A Long extra holding the wall clock time (in milliseconds) to be set on the device's
  /// android.app.AlarmManager.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_LOCAL_TIME =
      "android.app.extra.PROVISIONING_LOCAL_TIME";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_LOGO_URI
  ///
  /// A Uri extra pointing to a logo image. This image will be shown during the
  /// provisioning. If this extra is not passed, a default image will be shown.
  /// <h5>The following URI schemes are accepted:</h5>
  /// <ul>
  /// <li>content (android.content.ContentResolver\#SCHEME_CONTENT)</li>
  /// <li>android.resource (android.content.ContentResolver\#SCHEME_ANDROID_RESOURCE)</li>
  /// </ul>
  ///
  ///  It is the responsibility of the caller to provide an image with a reasonable
  /// pixel density for the device.
  ///
  ///  If a content: URI is passed, the intent should have the flag
  /// Intent\#FLAG_GRANT_READ_URI_PERMISSION and the uri should be added to the
  /// android.content.ClipData of the intent too.
  ///
  /// Use in an intent with action \#ACTION_PROVISION_MANAGED_PROFILE or
  /// \#ACTION_PROVISION_MANAGED_DEVICE
  static const EXTRA_PROVISIONING_LOGO_URI =
      "android.app.extra.PROVISIONING_LOGO_URI";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_MAIN_COLOR
  ///
  /// A integer extra indicating the predominant color to show during the provisioning.
  /// Refer to android.graphics.Color for how the color is represented.
  ///
  /// Use with \#ACTION_PROVISION_MANAGED_PROFILE or
  /// \#ACTION_PROVISION_MANAGED_DEVICE.
  static const EXTRA_PROVISIONING_MAIN_COLOR =
      "android.app.extra.PROVISIONING_MAIN_COLOR";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_SKIP_ENCRYPTION
  ///
  /// A boolean extra indicating whether device encryption can be skipped as part of device owner
  /// or managed profile provisioning.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC or an intent with action
  /// \#ACTION_PROVISION_MANAGED_DEVICE that starts device owner provisioning.
  ///
  /// From android.os.Build.VERSION_CODES\#N onwards, this is also supported for an
  /// intent with action \#ACTION_PROVISION_MANAGED_PROFILE.
  static const EXTRA_PROVISIONING_SKIP_ENCRYPTION =
      "android.app.extra.PROVISIONING_SKIP_ENCRYPTION";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_SKIP_USER_CONSENT
  ///
  /// A boolean extra indicating if the user consent steps from the provisioning flow should be
  /// skipped. If unspecified, defaults to {@code false}.
  ///
  /// It can only be used by an existing device owner trying to create a managed profile via
  /// \#ACTION_PROVISION_MANAGED_PROFILE. Otherwise it is ignored.
  static const EXTRA_PROVISIONING_SKIP_USER_CONSENT =
      "android.app.extra.PROVISIONING_SKIP_USER_CONSENT";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_TIME_ZONE
  ///
  /// A String extra holding the time zone android.app.AlarmManager that the device
  /// will be set to.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_TIME_ZONE =
      "android.app.extra.PROVISIONING_TIME_ZONE";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_WIFI_HIDDEN
  ///
  /// A boolean extra indicating whether the wifi network in \#EXTRA_PROVISIONING_WIFI_SSID
  /// is hidden or not.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_WIFI_HIDDEN =
      "android.app.extra.PROVISIONING_WIFI_HIDDEN";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_WIFI_PAC_URL
  ///
  /// A String extra holding the proxy auto-config (PAC) URL for the wifi network in
  /// \#EXTRA_PROVISIONING_WIFI_SSID.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_WIFI_PAC_URL =
      "android.app.extra.PROVISIONING_WIFI_PAC_URL";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_WIFI_PASSWORD
  ///
  /// A String extra holding the password of the wifi network in
  /// \#EXTRA_PROVISIONING_WIFI_SSID.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_WIFI_PASSWORD =
      "android.app.extra.PROVISIONING_WIFI_PASSWORD";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_WIFI_PROXY_BYPASS
  ///
  /// A String extra holding the proxy bypass for the wifi network in
  /// \#EXTRA_PROVISIONING_WIFI_SSID.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_WIFI_PROXY_BYPASS =
      "android.app.extra.PROVISIONING_WIFI_PROXY_BYPASS";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_WIFI_PROXY_HOST
  ///
  /// A String extra holding the proxy host for the wifi network in
  /// \#EXTRA_PROVISIONING_WIFI_SSID.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_WIFI_PROXY_HOST =
      "android.app.extra.PROVISIONING_WIFI_PROXY_HOST";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_WIFI_PROXY_PORT
  ///
  /// An int extra holding the proxy port for the wifi network in
  /// \#EXTRA_PROVISIONING_WIFI_SSID.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_WIFI_PROXY_PORT =
      "android.app.extra.PROVISIONING_WIFI_PROXY_PORT";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_WIFI_SECURITY_TYPE
  ///
  /// A String extra indicating the security type of the wifi network in
  /// \#EXTRA_PROVISIONING_WIFI_SSID and could be one of {@code NONE}, {@code WPA} or
  /// {@code WEP}.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_WIFI_SECURITY_TYPE =
      "android.app.extra.PROVISIONING_WIFI_SECURITY_TYPE";

  /// from: static public final java.lang.String EXTRA_PROVISIONING_WIFI_SSID
  ///
  /// A String extra holding the ssid of the wifi network that should be used during nfc device
  /// owner provisioning for downloading the mobile device management application.
  ///
  /// Use in an NFC record with \#MIME_TYPE_PROVISIONING_NFC that starts device owner
  /// provisioning via an NFC bump.
  static const EXTRA_PROVISIONING_WIFI_SSID =
      "android.app.extra.PROVISIONING_WIFI_SSID";

  /// from: static public final int FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY
  ///
  /// Flag for \#lockNow(int): also evict the user's credential encryption key from the
  /// keyring. The user's credential will need to be entered again in order to derive the
  /// credential encryption key that will be stored back in the keyring for future use.
  ///
  /// This flag can only be used by a profile owner when locking a managed profile when
  /// \#getStorageEncryptionStatus returns \#ENCRYPTION_STATUS_ACTIVE_PER_USER.
  ///
  /// In order to secure user data, the user will be stopped and restarted so apps should wait
  /// until they are next run to perform further actions.
  static const FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY = 1;

  /// from: static public final int FLAG_MANAGED_CAN_ACCESS_PARENT
  ///
  /// Flag used by \#addCrossProfileIntentFilter to allow activities in
  /// the managed profile to access intents sent from the parent profile.
  /// That is, when an app in the parent profile calls
  /// Activity\#startActivity(Intent), the intent can be resolved by a
  /// matching activity in the managed profile.
  static const FLAG_MANAGED_CAN_ACCESS_PARENT = 2;

  /// from: static public final int FLAG_PARENT_CAN_ACCESS_MANAGED
  ///
  /// Flag used by \#addCrossProfileIntentFilter to allow activities in
  /// the parent profile to access intents sent from the managed profile.
  /// That is, when an app in the managed profile calls
  /// Activity\#startActivity(Intent), the intent can be resolved by a
  /// matching activity in the parent profile.
  static const FLAG_PARENT_CAN_ACCESS_MANAGED = 1;

  /// from: static public final int ID_TYPE_BASE_INFO
  ///
  /// Specifies that the device should attest its manufacturer details. For use with
  /// \#generateKeyPair.
  ///@see \#generateKeyPair
  static const ID_TYPE_BASE_INFO = 1;

  /// from: static public final int ID_TYPE_IMEI
  ///
  /// Specifies that the device should attest its IMEI. For use with \#generateKeyPair.
  ///@see \#generateKeyPair
  static const ID_TYPE_IMEI = 4;

  /// from: static public final int ID_TYPE_MEID
  ///
  /// Specifies that the device should attest its MEID. For use with \#generateKeyPair.
  ///@see \#generateKeyPair
  static const ID_TYPE_MEID = 8;

  /// from: static public final int ID_TYPE_SERIAL
  ///
  /// Specifies that the device should attest its serial number. For use with
  /// \#generateKeyPair.
  ///@see \#generateKeyPair
  static const ID_TYPE_SERIAL = 2;

  /// from: static public final int INSTALLKEY_REQUEST_CREDENTIALS_ACCESS
  ///
  /// Specifies that the calling app should be granted access to the installed credentials
  /// immediately. Otherwise, access to the credentials will be gated by user approval.
  /// For use with \#installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)
  ///@see \#installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)
  static const INSTALLKEY_REQUEST_CREDENTIALS_ACCESS = 1;

  /// from: static public final int INSTALLKEY_SET_USER_SELECTABLE
  ///
  /// Specifies that a user can select the key via the Certificate Selection prompt.
  /// If this flag is not set when calling \#installKeyPair, the key can only be granted
  /// access by implementing android.app.admin.DeviceAdminReceiver\#onChoosePrivateKeyAlias.
  /// For use with \#installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)
  ///@see \#installKeyPair(ComponentName, PrivateKey, Certificate[], String, int)
  static const INSTALLKEY_SET_USER_SELECTABLE = 2;

  /// from: static public final int KEYGUARD_DISABLE_BIOMETRICS
  ///
  /// Disable all biometric authentication on keyguard secure screens (e.g.&nbsp;PIN/Pattern/Password).
  static const KEYGUARD_DISABLE_BIOMETRICS = 416;

  /// from: static public final int KEYGUARD_DISABLE_FACE
  ///
  /// Disable face authentication on keyguard secure screens (e.g.&nbsp;PIN/Pattern/Password).
  static const KEYGUARD_DISABLE_FACE = 128;

  /// from: static public final int KEYGUARD_DISABLE_FEATURES_ALL
  ///
  /// Disable all current and future keyguard customizations.
  static const KEYGUARD_DISABLE_FEATURES_ALL = 2147483647;

  /// from: static public final int KEYGUARD_DISABLE_FEATURES_NONE
  ///
  /// Widgets are enabled in keyguard
  static const KEYGUARD_DISABLE_FEATURES_NONE = 0;

  /// from: static public final int KEYGUARD_DISABLE_FINGERPRINT
  ///
  /// Disable fingerprint authentication on keyguard secure screens (e.g.&nbsp;PIN/Pattern/Password).
  static const KEYGUARD_DISABLE_FINGERPRINT = 32;

  /// from: static public final int KEYGUARD_DISABLE_IRIS
  ///
  /// Disable iris authentication on keyguard secure screens (e.g.&nbsp;PIN/Pattern/Password).
  static const KEYGUARD_DISABLE_IRIS = 256;

  /// from: static public final int KEYGUARD_DISABLE_REMOTE_INPUT
  ///
  /// Disable text entry into notifications on secure keyguard screens (e.g.&nbsp;PIN/Pattern/Password).
  static const KEYGUARD_DISABLE_REMOTE_INPUT = 64;

  /// from: static public final int KEYGUARD_DISABLE_SECURE_CAMERA
  ///
  /// Disable the camera on secure keyguard screens (e.g.&nbsp;PIN/Pattern/Password)
  static const KEYGUARD_DISABLE_SECURE_CAMERA = 2;

  /// from: static public final int KEYGUARD_DISABLE_SECURE_NOTIFICATIONS
  ///
  /// Disable showing all notifications on secure keyguard screens (e.g.&nbsp;PIN/Pattern/Password)
  static const KEYGUARD_DISABLE_SECURE_NOTIFICATIONS = 4;

  /// from: static public final int KEYGUARD_DISABLE_TRUST_AGENTS
  ///
  /// Disable trust agents on secure keyguard screens (e.g.&nbsp;PIN/Pattern/Password).
  /// By setting this flag alone, all trust agents are disabled. If the admin then wants to
  /// whitelist specific features of some trust agent, \#setTrustAgentConfiguration can be
  /// used in conjuction to set trust-agent-specific configurations.
  static const KEYGUARD_DISABLE_TRUST_AGENTS = 16;

  /// from: static public final int KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS
  ///
  /// Only allow redacted notifications on secure keyguard screens (e.g.&nbsp;PIN/Pattern/Password)
  static const KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS = 8;

  /// from: static public final int KEYGUARD_DISABLE_WIDGETS_ALL
  ///
  /// Disable all keyguard widgets. Has no effect starting from
  /// android.os.Build.VERSION_CODES\#LOLLIPOP since keyguard widget is only supported
  /// on Android versions lower than 5.0.
  static const KEYGUARD_DISABLE_WIDGETS_ALL = 1;

  /// from: static public final int LEAVE_ALL_SYSTEM_APPS_ENABLED
  ///
  /// Flag used by \#createAndManageUser to specify that the newly created user should skip
  /// the disabling of system apps during provisioning.
  static const LEAVE_ALL_SYSTEM_APPS_ENABLED = 16;

  /// from: static public final int LOCK_TASK_FEATURE_GLOBAL_ACTIONS
  ///
  /// Enable the global actions dialog during LockTask mode. This is the dialog that shows up when
  /// the user long-presses the power button, for example. Note that the user may not be able to
  /// power off the device if this flag is not set.
  ///
  /// This flag is enabled by default until \#setLockTaskFeatures(ComponentName, int) is
  /// called for the first time.
  ///@see \#setLockTaskFeatures(ComponentName, int)
  static const LOCK_TASK_FEATURE_GLOBAL_ACTIONS = 16;

  /// from: static public final int LOCK_TASK_FEATURE_HOME
  ///
  /// Enable the Home button during LockTask mode. Note that if a custom launcher is used, it has
  /// to be registered as the default launcher with
  /// \#addPersistentPreferredActivity(ComponentName, IntentFilter, ComponentName), and its
  /// package needs to be whitelisted for LockTask with
  /// \#setLockTaskPackages(ComponentName, String[]).
  ///@see \#setLockTaskFeatures(ComponentName, int)
  static const LOCK_TASK_FEATURE_HOME = 4;

  /// from: static public final int LOCK_TASK_FEATURE_KEYGUARD
  ///
  /// Enable the keyguard during LockTask mode. Note that if the keyguard is already disabled with
  /// \#setKeyguardDisabled(ComponentName, boolean), setting this flag will have no effect.
  /// If this flag is not set, the keyguard will not be shown even if the user has a lock screen
  /// credential.
  ///@see \#setLockTaskFeatures(ComponentName, int)
  static const LOCK_TASK_FEATURE_KEYGUARD = 32;

  /// from: static public final int LOCK_TASK_FEATURE_NONE
  ///
  /// Disable all configurable SystemUI features during LockTask mode. This includes,
  /// <ul>
  ///     <li>system info area in the status bar (connectivity icons, clock, etc.)
  ///     <li>notifications (including alerts, icons, and the notification shade)
  ///     <li>Home button
  ///     <li>Recents button and UI
  ///     <li>global actions menu (i.e. power button menu)
  ///     <li>keyguard
  /// </ul>
  ///@see \#setLockTaskFeatures(ComponentName, int)
  static const LOCK_TASK_FEATURE_NONE = 0;

  /// from: static public final int LOCK_TASK_FEATURE_NOTIFICATIONS
  ///
  /// Enable notifications during LockTask mode. This includes notification icons on the status
  /// bar, heads-up notifications, and the expandable notification shade. Note that the Quick
  /// Settings panel remains disabled. This feature flag can only be used in combination with
  /// \#LOCK_TASK_FEATURE_HOME. \#setLockTaskFeatures(ComponentName, int)
  /// throws an IllegalArgumentException if this feature flag is defined without
  /// \#LOCK_TASK_FEATURE_HOME.
  ///@see \#setLockTaskFeatures(ComponentName, int)
  static const LOCK_TASK_FEATURE_NOTIFICATIONS = 2;

  /// from: static public final int LOCK_TASK_FEATURE_OVERVIEW
  ///
  /// Enable the Overview button and the Overview screen during LockTask mode. This feature flag
  /// can only be used in combination with \#LOCK_TASK_FEATURE_HOME, and
  /// \#setLockTaskFeatures(ComponentName, int) will throw an
  /// IllegalArgumentException if this feature flag is defined without
  /// \#LOCK_TASK_FEATURE_HOME.
  ///@see \#setLockTaskFeatures(ComponentName, int)
  static const LOCK_TASK_FEATURE_OVERVIEW = 8;

  /// from: static public final int LOCK_TASK_FEATURE_SYSTEM_INFO
  ///
  /// Enable the system info area in the status bar during LockTask mode. The system info area
  /// usually occupies the right side of the status bar (although this can differ across OEMs). It
  /// includes all system information indicators, such as date and time, connectivity, battery,
  /// vibration mode, etc.
  ///@see \#setLockTaskFeatures(ComponentName, int)
  static const LOCK_TASK_FEATURE_SYSTEM_INFO = 1;

  /// from: static public final int MAKE_USER_EPHEMERAL
  ///
  /// Flag used by \#createAndManageUser to specify that the user should be created
  /// ephemeral. Ephemeral users will be removed after switching to another user or rebooting the
  /// device.
  static const MAKE_USER_EPHEMERAL = 2;

  /// from: static public final java.lang.String MIME_TYPE_PROVISIONING_NFC
  ///
  /// This MIME type is used for starting the device owner provisioning.
  ///
  /// During device owner provisioning a device admin app is set as the owner of the device.
  /// A device owner has full control over the device. The device owner can not be modified by the
  /// user and the only way of resetting the device is if the device owner app calls a factory
  /// reset.
  ///
  ///  A typical use case would be a device that is owned by a company, but used by either an
  /// employee or client.
  ///
  ///  The NFC message must be sent to an unprovisioned device.
  ///
  /// The NFC record must contain a serialized java.util.Properties object which
  /// contains the following properties:
  /// <ul>
  /// <li>\#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME</li>
  /// <li>\#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION, optional</li>
  /// <li>\#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_COOKIE_HEADER, optional</li>
  /// <li>\#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM, optional</li>
  /// <li>\#EXTRA_PROVISIONING_LOCAL_TIME (convert to String), optional</li>
  /// <li>\#EXTRA_PROVISIONING_TIME_ZONE, optional</li>
  /// <li>\#EXTRA_PROVISIONING_LOCALE, optional</li>
  /// <li>\#EXTRA_PROVISIONING_WIFI_SSID, optional</li>
  /// <li>\#EXTRA_PROVISIONING_WIFI_HIDDEN (convert to String), optional</li>
  /// <li>\#EXTRA_PROVISIONING_WIFI_SECURITY_TYPE, optional</li>
  /// <li>\#EXTRA_PROVISIONING_WIFI_PASSWORD, optional</li>
  /// <li>\#EXTRA_PROVISIONING_WIFI_PROXY_HOST, optional</li>
  /// <li>\#EXTRA_PROVISIONING_WIFI_PROXY_PORT (convert to String), optional</li>
  /// <li>\#EXTRA_PROVISIONING_WIFI_PROXY_BYPASS, optional</li>
  /// <li>\#EXTRA_PROVISIONING_WIFI_PAC_URL, optional</li>
  /// <li>\#EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE, optional, supported from
  /// android.os.Build.VERSION_CODES\#M </li></ul>
  ///
  ///
  /// As of android.os.Build.VERSION_CODES\#M, the properties should contain
  /// \#EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME instead of
  /// \#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME, (although specifying only
  /// \#EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME is still supported).
  static const MIME_TYPE_PROVISIONING_NFC =
      "application/com.android.managedprovisioning";

  /// from: static public final int PASSWORD_QUALITY_ALPHABETIC
  ///
  /// Constant for \#setPasswordQuality: the user must have entered a
  /// password containing at least alphabetic (or other symbol) characters.
  /// Note that quality constants are ordered so that higher values are more
  /// restrictive.
  static const PASSWORD_QUALITY_ALPHABETIC = 262144;

  /// from: static public final int PASSWORD_QUALITY_ALPHANUMERIC
  ///
  /// Constant for \#setPasswordQuality: the user must have entered a
  /// password containing at least _both>_ numeric _and_
  /// alphabetic (or other symbol) characters.  Note that quality constants are
  /// ordered so that higher values are more restrictive.
  static const PASSWORD_QUALITY_ALPHANUMERIC = 327680;

  /// from: static public final int PASSWORD_QUALITY_BIOMETRIC_WEAK
  ///
  /// Constant for \#setPasswordQuality: the policy allows for low-security biometric
  /// recognition technology.  This implies technologies that can recognize the identity of
  /// an individual to about a 3 digit PIN (false detection is less than 1 in 1,000).
  /// Note that quality constants are ordered so that higher values are more restrictive.
  static const PASSWORD_QUALITY_BIOMETRIC_WEAK = 32768;

  /// from: static public final int PASSWORD_QUALITY_COMPLEX
  ///
  /// Constant for \#setPasswordQuality: the user must have entered a
  /// password containing at least a letter, a numerical digit and a special
  /// symbol, by default. With this password quality, passwords can be
  /// restricted to contain various sets of characters, like at least an
  /// uppercase letter, etc. These are specified using various methods,
  /// like \#setPasswordMinimumLowerCase(ComponentName, int). Note
  /// that quality constants are ordered so that higher values are more
  /// restrictive.
  static const PASSWORD_QUALITY_COMPLEX = 393216;

  /// from: static public final int PASSWORD_QUALITY_NUMERIC
  ///
  /// Constant for \#setPasswordQuality: the user must have entered a
  /// password containing at least numeric characters.  Note that quality
  /// constants are ordered so that higher values are more restrictive.
  static const PASSWORD_QUALITY_NUMERIC = 131072;

  /// from: static public final int PASSWORD_QUALITY_NUMERIC_COMPLEX
  ///
  /// Constant for \#setPasswordQuality: the user must have entered a
  /// password containing at least numeric characters with no repeating (4444)
  /// or ordered (1234, 4321, 2468) sequences.  Note that quality
  /// constants are ordered so that higher values are more restrictive.
  static const PASSWORD_QUALITY_NUMERIC_COMPLEX = 196608;

  /// from: static public final int PASSWORD_QUALITY_SOMETHING
  ///
  /// Constant for \#setPasswordQuality: the policy requires some kind
  /// of password or pattern, but doesn't care what it is. Note that quality constants
  /// are ordered so that higher values are more restrictive.
  static const PASSWORD_QUALITY_SOMETHING = 65536;

  /// from: static public final int PASSWORD_QUALITY_UNSPECIFIED
  ///
  /// Constant for \#setPasswordQuality: the policy has no requirements
  /// for the password.  Note that quality constants are ordered so that higher
  /// values are more restrictive.
  static const PASSWORD_QUALITY_UNSPECIFIED = 0;

  /// from: static public final int PERMISSION_GRANT_STATE_DEFAULT
  ///
  /// Runtime permission state: The user can manage the permission
  /// through the UI.
  static const PERMISSION_GRANT_STATE_DEFAULT = 0;

  /// from: static public final int PERMISSION_GRANT_STATE_DENIED
  ///
  /// Runtime permission state: The permission is denied to the app
  /// and the user cannot manage the permission through the UI.
  static const PERMISSION_GRANT_STATE_DENIED = 2;

  /// from: static public final int PERMISSION_GRANT_STATE_GRANTED
  ///
  /// Runtime permission state: The permission is granted to the app
  /// and the user cannot manage the permission through the UI.
  static const PERMISSION_GRANT_STATE_GRANTED = 1;

  /// from: static public final int PERMISSION_POLICY_AUTO_DENY
  ///
  /// Permission policy to always deny new permission requests for runtime permissions.
  /// Already granted or denied permissions are not affected by this.
  static const PERMISSION_POLICY_AUTO_DENY = 2;

  /// from: static public final int PERMISSION_POLICY_AUTO_GRANT
  ///
  /// Permission policy to always grant new permission requests for runtime permissions.
  /// Already granted or denied permissions are not affected by this.
  static const PERMISSION_POLICY_AUTO_GRANT = 1;

  /// from: static public final int PERMISSION_POLICY_PROMPT
  ///
  /// Permission policy to prompt user for new permission requests for runtime permissions.
  /// Already granted or denied permissions are not affected by this.
  static const PERMISSION_POLICY_PROMPT = 0;

  /// from: static public final java.lang.String POLICY_DISABLE_CAMERA
  ///
  /// Constant to indicate the feature of disabling the camera. Used as argument to
  /// \#createAdminSupportIntent(String).
  ///@see \#setCameraDisabled(ComponentName, boolean)
  static const POLICY_DISABLE_CAMERA = "policy_disable_camera";

  /// from: static public final java.lang.String POLICY_DISABLE_SCREEN_CAPTURE
  ///
  /// Constant to indicate the feature of disabling screen captures. Used as argument to
  /// \#createAdminSupportIntent(String).
  ///@see \#setScreenCaptureDisabled(ComponentName, boolean)
  static const POLICY_DISABLE_SCREEN_CAPTURE = "policy_disable_screen_capture";

  /// from: static public final int RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT
  ///
  /// Flag for \#resetPasswordWithToken and \#resetPassword: don't ask for user
  /// credentials on device boot.
  /// If the flag is set, the device can be booted without asking for user password.
  /// The absence of this flag does not change the current boot requirements. This flag
  /// can be set by the device owner only. If the app is not the device owner, the flag
  /// is ignored. Once the flag is set, it cannot be reverted back without resetting the
  /// device to factory defaults.
  static const RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT = 2;

  /// from: static public final int RESET_PASSWORD_REQUIRE_ENTRY
  ///
  /// Flag for \#resetPasswordWithToken and \#resetPassword: don't allow other admins
  /// to change the password again until the user has entered it.
  static const RESET_PASSWORD_REQUIRE_ENTRY = 1;

  /// from: static public final int SKIP_SETUP_WIZARD
  ///
  /// Flag used by \#createAndManageUser to skip setup wizard after creating a new user.
  static const SKIP_SETUP_WIZARD = 1;

  /// from: static public final int WIPE_EUICC
  ///
  /// Flag for \#wipeData(int): also erase the device's eUICC data.
  static const WIPE_EUICC = 4;

  /// from: static public final int WIPE_EXTERNAL_STORAGE
  ///
  /// Flag for \#wipeData(int): also erase the device's external
  /// storage (such as SD cards).
  static const WIPE_EXTERNAL_STORAGE = 1;

  /// from: static public final int WIPE_RESET_PROTECTION_DATA
  ///
  /// Flag for \#wipeData(int): also erase the factory reset protection
  /// data.
  ///
  /// This flag may only be set by device owner admins; if it is set by
  /// other admins a SecurityException will be thrown.
  static const WIPE_RESET_PROTECTION_DATA = 2;

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "DevicePolicyManager__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  DevicePolicyManager() : super.fromRef(_ctor().object);

  static final _isAdminActive = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DevicePolicyManager__isAdminActive")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isAdminActive(android.content.ComponentName admin)
  ///
  /// Return true if the given administrator component is currently active (enabled) in the system.
  ///@param admin The administrator component to check for.
  /// This value must never be {@code null}.
  ///@return {@code true} if {@code admin} is currently enabled in the system, {@code false}
  ///         otherwise
  bool isAdminActive(content_.ComponentName admin) =>
      _isAdminActive(reference, admin.reference).boolean;

  static final _getActiveAdmins = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getActiveAdmins")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.content.ComponentName> getActiveAdmins()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a list of all currently active device administrators' component
  /// names.  If there are no administrators {@code null} may be
  /// returned.
  jni.JniObject getActiveAdmins() =>
      jni.JniObject.fromRef(_getActiveAdmins(reference).object);

  static final _removeActiveAdmin = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__removeActiveAdmin")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void removeActiveAdmin(android.content.ComponentName admin)
  ///
  /// Remove a current administration component.  This can only be called
  /// by the application that owns the administration component; if you
  /// try to remove someone else's component, a security exception will be
  /// thrown.
  ///
  /// Note that the operation is not synchronous and the admin might still be active (as
  /// indicated by \#getActiveAdmins()) by the time this method returns.
  ///@param admin The administration compononent to remove.
  /// This value must never be {@code null}.
  ///@throws SecurityException if the caller is not in the owner application of {@code admin}.
  void removeActiveAdmin(content_.ComponentName admin) =>
      _removeActiveAdmin(reference, admin.reference).check();

  static final _hasGrantedPolicy = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__hasGrantedPolicy")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean hasGrantedPolicy(android.content.ComponentName admin, int usesPolicy)
  ///
  /// Returns true if an administrator has been granted a particular device policy. This can be
  /// used to check whether the administrator was activated under an earlier set of policies, but
  /// requires additional policies after an upgrade.
  ///@param admin Which DeviceAdminReceiver this request is associated with. Must be an
  ///            active administrator, or an exception will be thrown.
  /// This value must never be {@code null}.
  ///@param usesPolicy Which uses-policy to check, as defined in DeviceAdminInfo.
  ///@throws SecurityException if {@code admin} is not an active administrator.
  bool hasGrantedPolicy(content_.ComponentName admin, int usesPolicy) =>
      _hasGrantedPolicy(reference, admin.reference, usesPolicy).boolean;

  static final _setPasswordQuality = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__setPasswordQuality")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setPasswordQuality(android.content.ComponentName admin, int quality)
  ///
  /// Called by an application that is administering the device to set the password restrictions it
  /// is imposing. After setting this, the user will not be able to enter a new password that is
  /// not at least as restrictive as what has been set. Note that the current password will remain
  /// until the user has set a new one, so the change does not take place immediately. To prompt
  /// the user for a new password, use \#ACTION_SET_NEW_PASSWORD or
  /// \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after calling this method.
  ///
  /// Quality constants are ordered so that higher values are more restrictive; thus the highest
  /// requested quality constant (between the policy set here, the user's preference, and any other
  /// considerations) is the one that is in effect.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param quality The new desired quality. One of \#PASSWORD_QUALITY_UNSPECIFIED,
  ///            \#PASSWORD_QUALITY_SOMETHING, \#PASSWORD_QUALITY_NUMERIC,
  ///            \#PASSWORD_QUALITY_NUMERIC_COMPLEX, \#PASSWORD_QUALITY_ALPHABETIC,
  ///            \#PASSWORD_QUALITY_ALPHANUMERIC or \#PASSWORD_QUALITY_COMPLEX.
  ///@throws SecurityException if {@code admin} is not an active administrator or if {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  void setPasswordQuality(content_.ComponentName admin, int quality) =>
      _setPasswordQuality(reference, admin.reference, quality).check();

  static final _getPasswordQuality = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getPasswordQuality")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getPasswordQuality(android.content.ComponentName admin)
  ///
  /// Retrieve the current minimum password quality for a particular admin or all admins that set
  /// restrictions on this user and its participating profiles. Restrictions on profiles that have
  /// a separate challenge are not taken into account.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to aggregate
  /// all admins.
  ///
  /// This value may be {@code null}.
  int getPasswordQuality(content_.ComponentName admin) =>
      _getPasswordQuality(reference, admin.reference).integer;

  static final _setPasswordMinimumLength = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__setPasswordMinimumLength")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setPasswordMinimumLength(android.content.ComponentName admin, int length)
  ///
  /// Called by an application that is administering the device to set the minimum allowed password
  /// length. After setting this, the user will not be able to enter a new password that is not at
  /// least as restrictive as what has been set. Note that the current password will remain until
  /// the user has set a new one, so the change does not take place immediately. To prompt the user
  /// for a new password, use \#ACTION_SET_NEW_PASSWORD or
  /// \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after setting this value. This constraint is
  /// only imposed if the administrator has also requested either \#PASSWORD_QUALITY_NUMERIC
  /// , \#PASSWORD_QUALITY_NUMERIC_COMPLEX, \#PASSWORD_QUALITY_ALPHABETIC,
  /// \#PASSWORD_QUALITY_ALPHANUMERIC, or \#PASSWORD_QUALITY_COMPLEX with
  /// \#setPasswordQuality.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param length The new desired minimum password length. A value of 0 means there is no
  ///            restriction.
  ///@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  void setPasswordMinimumLength(content_.ComponentName admin, int length) =>
      _setPasswordMinimumLength(reference, admin.reference, length).check();

  static final _getPasswordMinimumLength = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getPasswordMinimumLength")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getPasswordMinimumLength(android.content.ComponentName admin)
  ///
  /// Retrieve the current minimum password length for a particular admin or all admins that set
  /// restrictions on this user and its participating profiles. Restrictions on profiles that have
  /// a separate challenge are not taken into account.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///
  /// user and its profiles or a particular one.
  ///@param admin The name of the admin component to check, or {@code null} to aggregate
  /// all admins.
  ///
  /// This value may be {@code null}.
  int getPasswordMinimumLength(content_.ComponentName admin) =>
      _getPasswordMinimumLength(reference, admin.reference).integer;

  static final _setPasswordMinimumUpperCase = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "DevicePolicyManager__setPasswordMinimumUpperCase")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setPasswordMinimumUpperCase(android.content.ComponentName admin, int length)
  ///
  /// Called by an application that is administering the device to set the minimum number of upper
  /// case letters required in the password. After setting this, the user will not be able to enter
  /// a new password that is not at least as restrictive as what has been set. Note that the
  /// current password will remain until the user has set a new one, so the change does not take
  /// place immediately. To prompt the user for a new password, use
  /// \#ACTION_SET_NEW_PASSWORD or \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after
  /// setting this value. This constraint is only imposed if the administrator has also requested
  /// \#PASSWORD_QUALITY_COMPLEX with \#setPasswordQuality. The default value is 0.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param length The new desired minimum number of upper case letters required in the password.
  ///            A value of 0 means there is no restriction.
  ///@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  void setPasswordMinimumUpperCase(content_.ComponentName admin, int length) =>
      _setPasswordMinimumUpperCase(reference, admin.reference, length).check();

  static final _getPasswordMinimumUpperCase = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getPasswordMinimumUpperCase")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getPasswordMinimumUpperCase(android.content.ComponentName admin)
  ///
  /// Retrieve the current number of upper case letters required in the password
  /// for a particular admin or all admins that set restrictions on this user and
  /// its participating profiles. Restrictions on profiles that have a separate challenge
  /// are not taken into account.
  /// This is the same value as set by
  /// \#setPasswordMinimumUpperCase(ComponentName, int)
  /// and only applies when the password quality is
  /// \#PASSWORD_QUALITY_COMPLEX.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to
  ///            aggregate all admins.
  /// This value may be {@code null}.
  ///@return The minimum number of upper case letters required in the
  ///         password.
  int getPasswordMinimumUpperCase(content_.ComponentName admin) =>
      _getPasswordMinimumUpperCase(reference, admin.reference).integer;

  static final _setPasswordMinimumLowerCase = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "DevicePolicyManager__setPasswordMinimumLowerCase")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setPasswordMinimumLowerCase(android.content.ComponentName admin, int length)
  ///
  /// Called by an application that is administering the device to set the minimum number of lower
  /// case letters required in the password. After setting this, the user will not be able to enter
  /// a new password that is not at least as restrictive as what has been set. Note that the
  /// current password will remain until the user has set a new one, so the change does not take
  /// place immediately. To prompt the user for a new password, use
  /// \#ACTION_SET_NEW_PASSWORD or \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after
  /// setting this value. This constraint is only imposed if the administrator has also requested
  /// \#PASSWORD_QUALITY_COMPLEX with \#setPasswordQuality. The default value is 0.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param length The new desired minimum number of lower case letters required in the password.
  ///            A value of 0 means there is no restriction.
  ///@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  void setPasswordMinimumLowerCase(content_.ComponentName admin, int length) =>
      _setPasswordMinimumLowerCase(reference, admin.reference, length).check();

  static final _getPasswordMinimumLowerCase = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getPasswordMinimumLowerCase")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getPasswordMinimumLowerCase(android.content.ComponentName admin)
  ///
  /// Retrieve the current number of lower case letters required in the password
  /// for a particular admin or all admins that set restrictions on this user
  /// and its participating profiles. Restrictions on profiles that have
  /// a separate challenge are not taken into account.
  /// This is the same value as set by
  /// \#setPasswordMinimumLowerCase(ComponentName, int)
  /// and only applies when the password quality is
  /// \#PASSWORD_QUALITY_COMPLEX.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to
  ///            aggregate all admins.
  /// This value may be {@code null}.
  ///@return The minimum number of lower case letters required in the
  ///         password.
  int getPasswordMinimumLowerCase(content_.ComponentName admin) =>
      _getPasswordMinimumLowerCase(reference, admin.reference).integer;

  static final _setPasswordMinimumLetters = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__setPasswordMinimumLetters")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setPasswordMinimumLetters(android.content.ComponentName admin, int length)
  ///
  /// Called by an application that is administering the device to set the minimum number of
  /// letters required in the password. After setting this, the user will not be able to enter a
  /// new password that is not at least as restrictive as what has been set. Note that the current
  /// password will remain until the user has set a new one, so the change does not take place
  /// immediately. To prompt the user for a new password, use \#ACTION_SET_NEW_PASSWORD or
  /// \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after setting this value. This constraint is
  /// only imposed if the administrator has also requested \#PASSWORD_QUALITY_COMPLEX with
  /// \#setPasswordQuality. The default value is 1.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param length The new desired minimum number of letters required in the password. A value of
  ///            0 means there is no restriction.
  ///@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  void setPasswordMinimumLetters(content_.ComponentName admin, int length) =>
      _setPasswordMinimumLetters(reference, admin.reference, length).check();

  static final _getPasswordMinimumLetters = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getPasswordMinimumLetters")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getPasswordMinimumLetters(android.content.ComponentName admin)
  ///
  /// Retrieve the current number of letters required in the password
  /// for a particular admin or all admins that set restrictions on this user
  /// and its participating profiles. Restrictions on profiles that have
  /// a separate challenge are not taken into account.
  /// This is the same value as set by
  /// \#setPasswordMinimumLetters(ComponentName, int)
  /// and only applies when the password quality is
  /// \#PASSWORD_QUALITY_COMPLEX.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to
  ///            aggregate all admins.
  /// This value may be {@code null}.
  ///@return The minimum number of letters required in the password.
  int getPasswordMinimumLetters(content_.ComponentName admin) =>
      _getPasswordMinimumLetters(reference, admin.reference).integer;

  static final _setPasswordMinimumNumeric = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__setPasswordMinimumNumeric")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setPasswordMinimumNumeric(android.content.ComponentName admin, int length)
  ///
  /// Called by an application that is administering the device to set the minimum number of
  /// numerical digits required in the password. After setting this, the user will not be able to
  /// enter a new password that is not at least as restrictive as what has been set. Note that the
  /// current password will remain until the user has set a new one, so the change does not take
  /// place immediately. To prompt the user for a new password, use
  /// \#ACTION_SET_NEW_PASSWORD or \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after
  /// setting this value. This constraint is only imposed if the administrator has also requested
  /// \#PASSWORD_QUALITY_COMPLEX with \#setPasswordQuality. The default value is 1.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param length The new desired minimum number of numerical digits required in the password. A
  ///            value of 0 means there is no restriction.
  ///@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  void setPasswordMinimumNumeric(content_.ComponentName admin, int length) =>
      _setPasswordMinimumNumeric(reference, admin.reference, length).check();

  static final _getPasswordMinimumNumeric = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getPasswordMinimumNumeric")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getPasswordMinimumNumeric(android.content.ComponentName admin)
  ///
  /// Retrieve the current number of numerical digits required in the password
  /// for a particular admin or all admins that set restrictions on this user
  /// and its participating profiles. Restrictions on profiles that have
  /// a separate challenge are not taken into account.
  /// This is the same value as set by
  /// \#setPasswordMinimumNumeric(ComponentName, int)
  /// and only applies when the password quality is
  /// \#PASSWORD_QUALITY_COMPLEX.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to
  ///            aggregate all admins.
  /// This value may be {@code null}.
  ///@return The minimum number of numerical digits required in the password.
  int getPasswordMinimumNumeric(content_.ComponentName admin) =>
      _getPasswordMinimumNumeric(reference, admin.reference).integer;

  static final _setPasswordMinimumSymbols = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__setPasswordMinimumSymbols")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setPasswordMinimumSymbols(android.content.ComponentName admin, int length)
  ///
  /// Called by an application that is administering the device to set the minimum number of
  /// symbols required in the password. After setting this, the user will not be able to enter a
  /// new password that is not at least as restrictive as what has been set. Note that the current
  /// password will remain until the user has set a new one, so the change does not take place
  /// immediately. To prompt the user for a new password, use \#ACTION_SET_NEW_PASSWORD or
  /// \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after setting this value. This constraint is
  /// only imposed if the administrator has also requested \#PASSWORD_QUALITY_COMPLEX with
  /// \#setPasswordQuality. The default value is 1.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param length The new desired minimum number of symbols required in the password. A value of
  ///            0 means there is no restriction.
  ///@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  void setPasswordMinimumSymbols(content_.ComponentName admin, int length) =>
      _setPasswordMinimumSymbols(reference, admin.reference, length).check();

  static final _getPasswordMinimumSymbols = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getPasswordMinimumSymbols")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getPasswordMinimumSymbols(android.content.ComponentName admin)
  ///
  /// Retrieve the current number of symbols required in the password
  /// for a particular admin or all admins that set restrictions on this user
  /// and its participating profiles. Restrictions on profiles that have
  /// a separate challenge are not taken into account. This is the same value as
  /// set by \#setPasswordMinimumSymbols(ComponentName, int)
  /// and only applies when the password quality is
  /// \#PASSWORD_QUALITY_COMPLEX.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to
  ///            aggregate all admins.
  /// This value may be {@code null}.
  ///@return The minimum number of symbols required in the password.
  int getPasswordMinimumSymbols(content_.ComponentName admin) =>
      _getPasswordMinimumSymbols(reference, admin.reference).integer;

  static final _setPasswordMinimumNonLetter = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "DevicePolicyManager__setPasswordMinimumNonLetter")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setPasswordMinimumNonLetter(android.content.ComponentName admin, int length)
  ///
  /// Called by an application that is administering the device to set the minimum number of
  /// non-letter characters (numerical digits or symbols) required in the password. After setting
  /// this, the user will not be able to enter a new password that is not at least as restrictive
  /// as what has been set. Note that the current password will remain until the user has set a new
  /// one, so the change does not take place immediately. To prompt the user for a new password,
  /// use \#ACTION_SET_NEW_PASSWORD or \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after
  /// setting this value. This constraint is only imposed if the administrator has also requested
  /// \#PASSWORD_QUALITY_COMPLEX with \#setPasswordQuality. The default value is 0.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param length The new desired minimum number of letters required in the password. A value of
  ///            0 means there is no restriction.
  ///@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  void setPasswordMinimumNonLetter(content_.ComponentName admin, int length) =>
      _setPasswordMinimumNonLetter(reference, admin.reference, length).check();

  static final _getPasswordMinimumNonLetter = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getPasswordMinimumNonLetter")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getPasswordMinimumNonLetter(android.content.ComponentName admin)
  ///
  /// Retrieve the current number of non-letter characters required in the password
  /// for a particular admin or all admins that set restrictions on this user
  /// and its participating profiles. Restrictions on profiles that have
  /// a separate challenge are not taken into account.
  /// This is the same value as set by
  /// \#setPasswordMinimumNonLetter(ComponentName, int)
  /// and only applies when the password quality is
  /// \#PASSWORD_QUALITY_COMPLEX.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to
  ///            aggregate all admins.
  /// This value may be {@code null}.
  ///@return The minimum number of letters required in the password.
  int getPasswordMinimumNonLetter(content_.ComponentName admin) =>
      _getPasswordMinimumNonLetter(reference, admin.reference).integer;

  static final _setPasswordHistoryLength = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__setPasswordHistoryLength")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setPasswordHistoryLength(android.content.ComponentName admin, int length)
  ///
  /// Called by an application that is administering the device to set the length of the password
  /// history. After setting this, the user will not be able to enter a new password that is the
  /// same as any password in the history. Note that the current password will remain until the
  /// user has set a new one, so the change does not take place immediately. To prompt the user for
  /// a new password, use \#ACTION_SET_NEW_PASSWORD or
  /// \#ACTION_SET_NEW_PARENT_PROFILE_PASSWORD after setting this value. This constraint is
  /// only imposed if the administrator has also requested either \#PASSWORD_QUALITY_NUMERIC
  /// , \#PASSWORD_QUALITY_NUMERIC_COMPLEX \#PASSWORD_QUALITY_ALPHABETIC, or
  /// \#PASSWORD_QUALITY_ALPHANUMERIC with \#setPasswordQuality.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param length The new desired length of password history. A value of 0 means there is no
  ///            restriction.
  ///@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  void setPasswordHistoryLength(content_.ComponentName admin, int length) =>
      _setPasswordHistoryLength(reference, admin.reference, length).check();

  static final _setPasswordExpirationTimeout = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "DevicePolicyManager__setPasswordExpirationTimeout")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setPasswordExpirationTimeout(android.content.ComponentName admin, long timeout)
  ///
  /// Called by a device admin to set the password expiration timeout. Calling this method will
  /// restart the countdown for password expiration for the given admin, as will changing the
  /// device password (for all admins).
  ///
  /// The provided timeout is the time delta in ms and will be added to the current time. For
  /// example, to have the password expire 5 days from now, timeout would be 5 * 86400 * 1000 =
  /// 432000000 ms for timeout.
  ///
  /// To disable password expiration, a value of 0 may be used for timeout.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_EXPIRE_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// Note that setting the password will automatically reset the expiration time for all active
  /// admins. Active admins do not need to explicitly call this method in that case.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param timeout The limit (in ms) that a password can remain in effect. A value of 0 means
  ///            there is no restriction (unlimited).
  ///@throws SecurityException if {@code admin} is not an active administrator or {@code admin}
  ///             does not use DeviceAdminInfo\#USES_POLICY_EXPIRE_PASSWORD
  void setPasswordExpirationTimeout(
          content_.ComponentName admin, int timeout) =>
      _setPasswordExpirationTimeout(reference, admin.reference, timeout)
          .check();

  static final _getPasswordExpirationTimeout = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getPasswordExpirationTimeout")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public long getPasswordExpirationTimeout(android.content.ComponentName admin)
  ///
  /// Get the password expiration timeout for the given admin. The expiration timeout is the
  /// recurring expiration timeout provided in the call to
  /// \#setPasswordExpirationTimeout(ComponentName, long) for the given admin or the
  /// aggregate of all participating policy administrators if {@code admin} is null. Admins that
  /// have set restrictions on profiles that have a separate challenge are not taken into account.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to aggregate all admins.
  /// This value may be {@code null}.
  ///@return The timeout for the given admin or the minimum of all timeouts
  int getPasswordExpirationTimeout(content_.ComponentName admin) =>
      _getPasswordExpirationTimeout(reference, admin.reference).long;

  static final _getPasswordExpiration = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getPasswordExpiration")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public long getPasswordExpiration(android.content.ComponentName admin)
  ///
  /// Get the current password expiration time for a particular admin or all admins that set
  /// restrictions on this user and its participating profiles. Restrictions on profiles that have
  /// a separate challenge are not taken into account. If admin is {@code null}, then a composite
  /// of all expiration times is returned - which will be the minimum of all of them.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// the password expiration for the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to aggregate all admins.
  /// This value may be {@code null}.
  ///@return The password expiration time, in milliseconds since epoch.
  int getPasswordExpiration(content_.ComponentName admin) =>
      _getPasswordExpiration(reference, admin.reference).long;

  static final _getPasswordHistoryLength = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getPasswordHistoryLength")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getPasswordHistoryLength(android.content.ComponentName admin)
  ///
  /// Retrieve the current password history length for a particular admin or all admins that
  /// set restrictions on this user and its participating profiles. Restrictions on profiles that
  /// have a separate challenge are not taken into account.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to aggregate
  /// all admins.
  /// This value may be {@code null}.
  ///@return The length of the password history
  int getPasswordHistoryLength(content_.ComponentName admin) =>
      _getPasswordHistoryLength(reference, admin.reference).integer;

  static final _getPasswordMaximumLength = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__getPasswordMaximumLength")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getPasswordMaximumLength(int quality)
  ///
  /// Return the maximum password length that the device supports for a
  /// particular password quality.
  ///@param quality The quality being interrogated.
  ///@return Returns the maximum length that the user can enter.
  int getPasswordMaximumLength(int quality) =>
      _getPasswordMaximumLength(reference, quality).integer;

  static final _isActivePasswordSufficient = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isActivePasswordSufficient")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isActivePasswordSufficient()
  ///
  /// Determine whether the current password the user has set is sufficient to meet the policy
  /// requirements (e.g.&nbsp;quality, minimum length) that have been requested by the admins of this
  /// user and its participating profiles. Restrictions on profiles that have a separate challenge
  /// are not taken into account. The user must be unlocked in order to perform the check.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to determine if the password set on
  /// the parent profile is sufficient.
  ///@return Returns true if the password meets the current requirements, else false.
  ///@throws SecurityException if the calling application does not own an active administrator
  ///             that uses DeviceAdminInfo\#USES_POLICY_LIMIT_PASSWORD
  ///@throws IllegalStateException if the user is not unlocked.
  bool isActivePasswordSufficient() =>
      _isActivePasswordSufficient(reference).boolean;

  static final _isUsingUnifiedPassword = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isUsingUnifiedPassword")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isUsingUnifiedPassword(android.content.ComponentName admin)
  ///
  /// When called by a profile owner of a managed profile returns true if the profile uses unified
  /// challenge with its parent user.
  ///
  /// <strong>Note</strong>: This method is not concerned with password quality and will return
  /// false if the profile has empty password as a separate challenge.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a profile owner of a managed profile.
  ///@see UserManager\#DISALLOW_UNIFIED_PASSWORD
  bool isUsingUnifiedPassword(content_.ComponentName admin) =>
      _isUsingUnifiedPassword(reference, admin.reference).boolean;

  static final _getCurrentFailedPasswordAttempts = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getCurrentFailedPasswordAttempts")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getCurrentFailedPasswordAttempts()
  ///
  /// Retrieve the number of times the user has failed at entering a password since that last
  /// successful password entry.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to retrieve the number of failed
  /// password attemts for the parent user.
  ///
  /// The calling device admin must have requested DeviceAdminInfo\#USES_POLICY_WATCH_LOGIN
  /// to be able to call this method; if it has not, a security exception will be thrown.
  ///@return The number of times user has entered an incorrect password since the last correct
  ///         password entry.
  ///@throws SecurityException if the calling application does not own an active administrator
  ///             that uses DeviceAdminInfo\#USES_POLICY_WATCH_LOGIN
  int getCurrentFailedPasswordAttempts() =>
      _getCurrentFailedPasswordAttempts(reference).integer;

  static final _setMaximumFailedPasswordsForWipe = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "DevicePolicyManager__setMaximumFailedPasswordsForWipe")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setMaximumFailedPasswordsForWipe(android.content.ComponentName admin, int num)
  ///
  /// Setting this to a value greater than zero enables a built-in policy that will perform a
  /// device or profile wipe after too many incorrect device-unlock passwords have been entered.
  /// This built-in policy combines watching for failed passwords and wiping the device, and
  /// requires that you request both DeviceAdminInfo\#USES_POLICY_WATCH_LOGIN and
  /// DeviceAdminInfo\#USES_POLICY_WIPE_DATA}.
  ///
  /// To implement any other policy (e.g. wiping data for a particular application only, erasing or
  /// revoking credentials, or reporting the failure to a server), you should implement
  /// DeviceAdminReceiver\#onPasswordFailed(Context, android.content.Intent) instead. Do not
  /// use this API, because if the maximum count is reached, the device or profile will be wiped
  /// immediately, and your callback will not be invoked.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set a value on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param num The number of failed password attempts at which point the device or profile will
  ///            be wiped.
  ///@throws SecurityException if {@code admin} is not an active administrator or does not use
  ///             both DeviceAdminInfo\#USES_POLICY_WATCH_LOGIN and
  ///             DeviceAdminInfo\#USES_POLICY_WIPE_DATA.
  void setMaximumFailedPasswordsForWipe(
          content_.ComponentName admin, int num) =>
      _setMaximumFailedPasswordsForWipe(reference, admin.reference, num)
          .check();

  static final _getMaximumFailedPasswordsForWipe = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getMaximumFailedPasswordsForWipe")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getMaximumFailedPasswordsForWipe(android.content.ComponentName admin)
  ///
  /// Retrieve the current maximum number of login attempts that are allowed before the device
  /// or profile is wiped, for a particular admin or all admins that set restrictions on this user
  /// and its participating profiles. Restrictions on profiles that have a separate challenge are
  /// not taken into account.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// the value for the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to aggregate
  /// all admins.
  ///
  /// This value may be {@code null}.
  int getMaximumFailedPasswordsForWipe(content_.ComponentName admin) =>
      _getMaximumFailedPasswordsForWipe(reference, admin.reference).integer;

  static final _resetPassword = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__resetPassword")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean resetPassword(java.lang.String password, int flags)
  ///
  /// Force a new password for device unlock (the password needed to access the entire device) or
  /// the work profile challenge on the current user. This takes effect immediately.
  ///
  /// _For device owner and profile owners targeting SDK level
  /// android.os.Build.VERSION_CODES\#O or above, this API is no longer available and will
  /// throw SecurityException. Please use the new API \#resetPasswordWithToken
  /// instead. _
  ///
  /// _Note: This API has been limited as of android.os.Build.VERSION_CODES\#N for
  /// device admins that are not device owner and not profile owner.
  /// The password can now only be changed if there is currently no password set.  Device owner
  /// and profile owner can still do this when user is unlocked and does not have a managed
  /// profile._
  ///
  /// The given password must be sufficient for the current password quality and length constraints
  /// as returned by \#getPasswordQuality(ComponentName) and
  /// \#getPasswordMinimumLength(ComponentName); if it does not meet these constraints, then
  /// it will be rejected and false returned. Note that the password may be a stronger quality
  /// (containing alphanumeric characters when the requested quality is only numeric), in which
  /// case the currently active quality will be increased to match.
  ///
  /// Calling with a null or empty password will clear any existing PIN, pattern or password if the
  /// current password constraints allow it. _Note: This will not work in
  /// android.os.Build.VERSION_CODES\#N and later for managed profiles, or for device admins
  /// that are not device owner or profile owner.  Once set, the password cannot be changed to null
  /// or empty except by these admins._
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_RESET_PASSWORD to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///@param password The new password for the user. Null or empty clears the password.
  ///@param flags May be 0 or combination of \#RESET_PASSWORD_REQUIRE_ENTRY and
  ///            \#RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT.
  ///@return Returns true if the password was applied, or false if it is not acceptable for the
  ///         current constraints or if the user has not been decrypted yet.
  ///@throws SecurityException if the calling application does not own an active administrator
  ///             that uses DeviceAdminInfo\#USES_POLICY_RESET_PASSWORD
  ///@throws IllegalStateException if the calling user is locked or has a managed profile.
  bool resetPassword(jni.JniString password, int flags) =>
      _resetPassword(reference, password.reference, flags).boolean;

  static final _setResetPasswordToken = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setResetPasswordToken")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean setResetPasswordToken(android.content.ComponentName admin, byte[] token)
  ///
  /// Called by a profile or device owner to provision a token which can later be used to reset the
  /// device lockscreen password (if called by device owner), or managed profile challenge (if
  /// called by profile owner), via \#resetPasswordWithToken.
  ///
  /// If the user currently has a lockscreen password, the provisioned token will not be
  /// immediately usable; it only becomes active after the user performs a confirm credential
  /// operation, which can be triggered by KeyguardManager\#createConfirmDeviceCredentialIntent.
  /// If the user has no lockscreen password, the token is activated immediately. In all cases,
  /// the active state of the current token can be checked by \#isResetPasswordTokenActive.
  /// For security reasons, un-activated tokens are only stored in memory and will be lost once
  /// the device reboots. In this case a new token needs to be provisioned again.
  ///
  /// Once provisioned and activated, the token will remain effective even if the user changes
  /// or clears the lockscreen password.
  ///
  /// _This token is highly sensitive and should be treated at the same level as user
  /// credentials. In particular, NEVER store this token on device in plaintext. Do not store
  /// the plaintext token in device-encrypted storage if it will be needed to reset password on
  /// file-based encryption devices before user unlocks. Consider carefully how any password token
  /// will be stored on your server and who will need access to them. Tokens may be the subject of
  /// legal access requests.
  /// _
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  ///@param token a secure token a least 32-byte long, which must be generated by a
  ///        cryptographically strong random number generator.
  ///@return true if the operation is successful, false otherwise.
  ///@throws SecurityException if admin is not a device or profile owner.
  ///@throws IllegalArgumentException if the supplied token is invalid.
  bool setResetPasswordToken(
          content_.ComponentName admin, jni.JniObject token) =>
      _setResetPasswordToken(reference, admin.reference, token.reference)
          .boolean;

  static final _clearResetPasswordToken = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__clearResetPasswordToken")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean clearResetPasswordToken(android.content.ComponentName admin)
  ///
  /// Called by a profile or device owner to revoke the current password reset token.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  ///@return true if the operation is successful, false otherwise.
  ///@throws SecurityException if admin is not a device or profile owner.
  bool clearResetPasswordToken(content_.ComponentName admin) =>
      _clearResetPasswordToken(reference, admin.reference).boolean;

  static final _isResetPasswordTokenActive = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isResetPasswordTokenActive")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isResetPasswordTokenActive(android.content.ComponentName admin)
  ///
  /// Called by a profile or device owner to check if the current reset password token is active.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  ///@return true if the token is active, false otherwise.
  ///@throws SecurityException if admin is not a device or profile owner.
  ///@throws IllegalStateException if no token has been set.
  bool isResetPasswordTokenActive(content_.ComponentName admin) =>
      _isResetPasswordTokenActive(reference, admin.reference).boolean;

  static final _resetPasswordWithToken = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__resetPasswordWithToken")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean resetPasswordWithToken(android.content.ComponentName admin, java.lang.String password, byte[] token, int flags)
  ///
  /// Called by device or profile owner to force set a new device unlock password or a managed
  /// profile challenge on current user. This takes effect immediately.
  ///
  /// Unlike \#resetPassword, this API can change the password even before the user or
  /// device is unlocked or decrypted. The supplied token must have been previously provisioned via
  /// \#setResetPasswordToken, and in active state \#isResetPasswordTokenActive.
  ///
  /// The given password must be sufficient for the current password quality and length constraints
  /// as returned by \#getPasswordQuality(ComponentName) and
  /// \#getPasswordMinimumLength(ComponentName); if it does not meet these constraints, then
  /// it will be rejected and false returned. Note that the password may be a stronger quality, for
  /// example, a password containing alphanumeric characters when the requested quality is only
  /// numeric.
  ///
  /// Calling with a {@code null} or empty password will clear any existing PIN, pattern or
  /// password if the current password constraints allow it.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param password The new password for the user. {@code null} or empty clears the password.
  ///@param token the password reset token previously provisioned by
  ///        \#setResetPasswordToken.
  ///@param flags May be 0 or combination of \#RESET_PASSWORD_REQUIRE_ENTRY and
  ///        \#RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT.
  ///@return Returns true if the password was applied, or false if it is not acceptable for the
  ///         current constraints.
  ///@throws SecurityException if admin is not a device or profile owner.
  ///@throws IllegalStateException if the provided token is not valid.
  bool resetPasswordWithToken(content_.ComponentName admin,
          jni.JniString password, jni.JniObject token, int flags) =>
      _resetPasswordWithToken(reference, admin.reference, password.reference,
              token.reference, flags)
          .boolean;

  static final _setMaximumTimeToLock = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("DevicePolicyManager__setMaximumTimeToLock")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setMaximumTimeToLock(android.content.ComponentName admin, long timeMs)
  ///
  /// Called by an application that is administering the device to set the maximum time for user
  /// activity until the device will lock. This limits the length that the user can set. It takes
  /// effect immediately.
  ///
  /// The calling device admin must have requested DeviceAdminInfo\#USES_POLICY_FORCE_LOCK
  /// to be able to call this method; if it has not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param timeMs The new desired maximum time to lock in milliseconds. A value of 0 means there
  ///            is no restriction.
  ///@throws SecurityException if {@code admin} is not an active administrator or it does not use
  ///             DeviceAdminInfo\#USES_POLICY_FORCE_LOCK
  void setMaximumTimeToLock(content_.ComponentName admin, int timeMs) =>
      _setMaximumTimeToLock(reference, admin.reference, timeMs).check();

  static final _getMaximumTimeToLock = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getMaximumTimeToLock")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public long getMaximumTimeToLock(android.content.ComponentName admin)
  ///
  /// Retrieve the current maximum time to unlock for a particular admin or all admins that set
  /// restrictions on this user and its participating profiles. Restrictions on profiles that have
  /// a separate challenge are not taken into account.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to aggregate
  /// all admins.
  /// This value may be {@code null}.
  ///@return time in milliseconds for the given admin or the minimum value (strictest) of
  /// all admins if admin is null. Returns 0 if there are no restrictions.
  int getMaximumTimeToLock(content_.ComponentName admin) =>
      _getMaximumTimeToLock(reference, admin.reference).long;

  static final _setRequiredStrongAuthTimeout = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "DevicePolicyManager__setRequiredStrongAuthTimeout")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setRequiredStrongAuthTimeout(android.content.ComponentName admin, long timeoutMs)
  ///
  /// Called by a device/profile owner to set the timeout after which unlocking with secondary, non
  /// strong auth (e.g.&nbsp;fingerprint, trust agents) times out, i.e. the user has to use a strong
  /// authentication method like password, pin or pattern.
  ///
  /// This timeout is used internally to reset the timer to require strong auth again after
  /// specified timeout each time it has been successfully used.
  ///
  /// Fingerprint can also be disabled altogether using \#KEYGUARD_DISABLE_FINGERPRINT.
  ///
  /// Trust agents can also be disabled altogether using \#KEYGUARD_DISABLE_TRUST_AGENTS.
  ///
  /// The calling device admin must be a device or profile owner. If it is not,
  /// a SecurityException will be thrown.
  ///
  /// The calling device admin can verify the value it has set by calling
  /// \#getRequiredStrongAuthTimeout(ComponentName) and passing in its instance.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param timeoutMs The new timeout in milliseconds, after which the user will have to unlock
  ///         with strong authentication method. A value of 0 means the admin is not participating
  ///         in controlling the timeout.
  ///         The minimum and maximum timeouts are platform-defined and are typically 1 hour and
  ///         72 hours, respectively. Though discouraged, the admin may choose to require strong
  ///         auth at all times using \#KEYGUARD_DISABLE_FINGERPRINT and/or
  ///         \#KEYGUARD_DISABLE_TRUST_AGENTS.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setRequiredStrongAuthTimeout(
          content_.ComponentName admin, int timeoutMs) =>
      _setRequiredStrongAuthTimeout(reference, admin.reference, timeoutMs)
          .check();

  static final _getRequiredStrongAuthTimeout = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getRequiredStrongAuthTimeout")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public long getRequiredStrongAuthTimeout(android.content.ComponentName admin)
  ///
  /// Determine for how long the user will be able to use secondary, non strong auth for
  /// authentication, since last strong method authentication (password, pin or pattern) was used.
  /// After the returned timeout the user is required to use strong authentication method.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to aggregate
  ///         accross all participating admins.
  /// This value may be {@code null}.
  ///@return The timeout in milliseconds or 0 if not configured for the provided admin.
  int getRequiredStrongAuthTimeout(content_.ComponentName admin) =>
      _getRequiredStrongAuthTimeout(reference, admin.reference).long;

  static final _lockNow = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DevicePolicyManager__lockNow")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void lockNow()
  ///
  /// Make the device lock immediately, as if the lock screen timeout has expired at the point of
  /// this call.
  ///
  /// The calling device admin must have requested DeviceAdminInfo\#USES_POLICY_FORCE_LOCK
  /// to be able to call this method; if it has not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to lock the parent profile.
  ///
  /// Equivalent to calling \#lockNow(int) with no flags.
  ///@throws SecurityException if the calling application does not own an active administrator
  ///             that uses DeviceAdminInfo\#USES_POLICY_FORCE_LOCK
  void lockNow() => _lockNow(reference).check();

  static final _lockNow1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__lockNow1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void lockNow(int flags)
  ///
  /// Make the device lock immediately, as if the lock screen timeout has expired at the point of
  /// this call.
  ///
  /// The calling device admin must have requested DeviceAdminInfo\#USES_POLICY_FORCE_LOCK
  /// to be able to call this method; if it has not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to lock the parent profile.
  ///@param flags May be 0 or \#FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY.
  /// Value is either <code>0</code> or android.app.admin.DevicePolicyManager\#FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY
  ///@throws SecurityException if the calling application does not own an active administrator
  ///             that uses DeviceAdminInfo\#USES_POLICY_FORCE_LOCK or the
  ///             \#FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY flag is passed by an application
  ///             that is not a profile
  ///             owner of a managed profile.
  ///@throws IllegalArgumentException if the \#FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY flag is
  ///             passed when locking the parent profile.
  ///@throws UnsupportedOperationException if the \#FLAG_EVICT_CREDENTIAL_ENCRYPTION_KEY
  ///             flag is passed when \#getStorageEncryptionStatus does not return
  ///             \#ENCRYPTION_STATUS_ACTIVE_PER_USER.
  void lockNow1(int flags) => _lockNow1(reference, flags).check();

  static final _wipeData = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__wipeData")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void wipeData(int flags)
  ///
  /// Ask that all user data be wiped. If called as a secondary user, the user will be removed and
  /// other users will remain unaffected. Calling from the primary user will cause the device to
  /// reboot, erasing all device data - including all the secondary users and their data - while
  /// booting up.
  ///
  /// The calling device admin must have requested DeviceAdminInfo\#USES_POLICY_WIPE_DATA to
  /// be able to call this method; if it has not, a security exception will be thrown.
  ///@param flags Bit mask of additional options: currently supported flags are
  ///            \#WIPE_EXTERNAL_STORAGE and \#WIPE_RESET_PROTECTION_DATA.
  ///@throws SecurityException if the calling application does not own an active administrator
  ///             that uses DeviceAdminInfo\#USES_POLICY_WIPE_DATA
  void wipeData(int flags) => _wipeData(reference, flags).check();

  static final _wipeData1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("DevicePolicyManager__wipeData1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void wipeData(int flags, java.lang.CharSequence reason)
  ///
  /// Ask that all user data be wiped. If called as a secondary user, the user will be removed and
  /// other users will remain unaffected, the provided reason for wiping data can be shown to
  /// user. Calling from the primary user will cause the device to reboot, erasing all device data
  /// - including all the secondary users and their data - while booting up. In this case, we don't
  /// show the reason to the user since the device would be factory reset.
  ///
  /// The calling device admin must have requested DeviceAdminInfo\#USES_POLICY_WIPE_DATA to
  /// be able to call this method; if it has not, a security exception will be thrown.
  ///@param flags Bit mask of additional options: currently supported flags are
  ///            \#WIPE_EXTERNAL_STORAGE and \#WIPE_RESET_PROTECTION_DATA.
  ///@param reason a string that contains the reason for wiping data, which can be
  ///                          presented to the user.
  /// This value must never be {@code null}.
  ///@throws SecurityException if the calling application does not own an active administrator
  ///             that uses DeviceAdminInfo\#USES_POLICY_WIPE_DATA
  ///@throws IllegalArgumentException if the input reason string is null or empty.
  void wipeData1(int flags, jni.JniObject reason) =>
      _wipeData1(reference, flags, reason.reference).check();

  static final _setRecommendedGlobalProxy = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setRecommendedGlobalProxy")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setRecommendedGlobalProxy(android.content.ComponentName admin, android.net.ProxyInfo proxyInfo)
  ///
  /// Set a network-independent global HTTP proxy. This is not normally what you want for typical
  /// HTTP proxies - they are generally network dependent. However if you're doing something
  /// unusual like general internal filtering this may be useful. On a private network where the
  /// proxy is not accessible, you may break HTTP using this.
  ///
  /// This method requires the caller to be the device owner.
  ///
  /// This proxy is only a recommendation and it is possible that some apps will ignore it.
  ///@see ProxyInfo
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param proxyInfo The a ProxyInfo object defining the new global HTTP proxy. A
  ///            {@code null} value will clear the global HTTP proxy.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not the device owner.
  void setRecommendedGlobalProxy(
          content_.ComponentName admin, jni.JniObject proxyInfo) =>
      _setRecommendedGlobalProxy(
              reference, admin.reference, proxyInfo.reference)
          .check();

  static final _setStorageEncryption = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DevicePolicyManager__setStorageEncryption")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public int setStorageEncryption(android.content.ComponentName admin, boolean encrypt)
  ///
  /// Called by an application that is administering the device to request that the storage system
  /// be encrypted. Does nothing if the caller is on a secondary user or a managed profile.
  ///
  /// When multiple device administrators attempt to control device encryption, the most secure,
  /// supported setting will always be used. If any device administrator requests device
  /// encryption, it will be enabled; Conversely, if a device administrator attempts to disable
  /// device encryption while another device administrator has enabled it, the call to disable will
  /// fail (most commonly returning \#ENCRYPTION_STATUS_ACTIVE).
  ///
  /// This policy controls encryption of the secure (application data) storage area. Data written
  /// to other storage areas may or may not be encrypted, and this policy does not require or
  /// control the encryption of any other storage areas. There is one exception: If
  /// android.os.Environment\#isExternalStorageEmulated() is {@code true}, then the
  /// directory returned by android.os.Environment\#getExternalStorageDirectory() must be
  /// written to disk within the encrypted storage area.
  ///
  /// Important Note: On some devices, it is possible to encrypt storage without requiring the user
  /// to create a device PIN or Password. In this case, the storage is encrypted, but the
  /// encryption key may not be fully secured. For maximum security, the administrator should also
  /// require (and check for) a pattern, PIN, or password.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param encrypt true to request encryption, false to release any previous request
  ///@return the new total request status (for all active admins), or DevicePolicyManager\#ENCRYPTION_STATUS_UNSUPPORTED if called for a non-system user.
  ///         Will be one of \#ENCRYPTION_STATUS_UNSUPPORTED, \#ENCRYPTION_STATUS_INACTIVE, or \#ENCRYPTION_STATUS_ACTIVE. This is the value
  ///         of the requests; use \#getStorageEncryptionStatus() to query the actual device
  ///         state.
  ///@throws SecurityException if {@code admin} is not an active administrator or does not use
  ///             DeviceAdminInfo\#USES_ENCRYPTED_STORAGE
  int setStorageEncryption(content_.ComponentName admin, bool encrypt) =>
      _setStorageEncryption(reference, admin.reference, encrypt ? 1 : 0)
          .integer;

  static final _getStorageEncryption = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getStorageEncryption")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getStorageEncryption(android.content.ComponentName admin)
  ///
  /// Called by an application that is administering the device to
  /// determine the requested setting for secure storage.
  ///@param admin Which DeviceAdminReceiver this request is associated with.  If null,
  /// this will return the requested encryption setting as an aggregate of all active
  /// administrators.
  /// This value may be {@code null}.
  ///@return true if the admin(s) are requesting encryption, false if not.
  bool getStorageEncryption(content_.ComponentName admin) =>
      _getStorageEncryption(reference, admin.reference).boolean;

  static final _getStorageEncryptionStatus = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getStorageEncryptionStatus")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getStorageEncryptionStatus()
  ///
  /// Called by an application that is administering the device to
  /// determine the current encryption status of the device.
  ///
  /// Depending on the returned status code, the caller may proceed in different
  /// ways.  If the result is \#ENCRYPTION_STATUS_UNSUPPORTED, the
  /// storage system does not support encryption.  If the
  /// result is \#ENCRYPTION_STATUS_INACTIVE, use \#ACTION_START_ENCRYPTION to begin the process of encrypting or decrypting the
  /// storage.  If the result is \#ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY, the
  /// storage system has enabled encryption but no password is set so further action
  /// may be required.  If the result is \#ENCRYPTION_STATUS_ACTIVATING,
  /// \#ENCRYPTION_STATUS_ACTIVE or \#ENCRYPTION_STATUS_ACTIVE_PER_USER,
  /// no further action is required.
  ///@return current status of encryption. The value will be one of
  /// \#ENCRYPTION_STATUS_UNSUPPORTED, \#ENCRYPTION_STATUS_INACTIVE,
  /// \#ENCRYPTION_STATUS_ACTIVATING, \#ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY,
  /// \#ENCRYPTION_STATUS_ACTIVE, or \#ENCRYPTION_STATUS_ACTIVE_PER_USER.
  int getStorageEncryptionStatus() =>
      _getStorageEncryptionStatus(reference).integer;

  static final _installCaCert = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DevicePolicyManager__installCaCert")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean installCaCert(android.content.ComponentName admin, byte[] certBuffer)
  ///
  /// Installs the given certificate as a user CA.
  ///
  /// The caller must be a profile or device owner on that user, or a delegate package given the
  /// \#DELEGATION_CERT_INSTALL scope via \#setDelegatedScopes; otherwise a
  /// security exception will be thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///              {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@param certBuffer encoded form of the certificate to install.
  ///@return false if the certBuffer cannot be parsed or installation is
  ///         interrupted, true otherwise.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_CERT_INSTALL
  bool installCaCert(content_.ComponentName admin, jni.JniObject certBuffer) =>
      _installCaCert(reference, admin.reference, certBuffer.reference).boolean;

  static final _uninstallCaCert = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__uninstallCaCert")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void uninstallCaCert(android.content.ComponentName admin, byte[] certBuffer)
  ///
  /// Uninstalls the given certificate from trusted user CAs, if present.
  ///
  /// The caller must be a profile or device owner on that user, or a delegate package given the
  /// \#DELEGATION_CERT_INSTALL scope via \#setDelegatedScopes; otherwise a
  /// security exception will be thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///              {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@param certBuffer encoded form of the certificate to remove.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_CERT_INSTALL
  void uninstallCaCert(
          content_.ComponentName admin, jni.JniObject certBuffer) =>
      _uninstallCaCert(reference, admin.reference, certBuffer.reference)
          .check();

  static final _getInstalledCaCerts = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getInstalledCaCerts")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<byte[]> getInstalledCaCerts(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns all CA certificates that are currently trusted, excluding system CA certificates.
  /// If a user has installed any certificates by other means than device policy these will be
  /// included too.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///              {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@return a List of byte[] arrays, each encoding one user CA certificate.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner.
  jni.JniObject getInstalledCaCerts(content_.ComponentName admin) =>
      jni.JniObject.fromRef(
          _getInstalledCaCerts(reference, admin.reference).object);

  static final _uninstallAllUserCaCerts = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__uninstallAllUserCaCerts")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void uninstallAllUserCaCerts(android.content.ComponentName admin)
  ///
  /// Uninstalls all custom trusted CA certificates from the profile. Certificates installed by
  /// means other than device policy will also be removed, except for system CA certificates.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///              {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner.
  void uninstallAllUserCaCerts(content_.ComponentName admin) =>
      _uninstallAllUserCaCerts(reference, admin.reference).check();

  static final _hasCaCertInstalled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__hasCaCertInstalled")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasCaCertInstalled(android.content.ComponentName admin, byte[] certBuffer)
  ///
  /// Returns whether this certificate is installed as a trusted CA.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///              {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@param certBuffer encoded form of the certificate to look up.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner.
  bool hasCaCertInstalled(
          content_.ComponentName admin, jni.JniObject certBuffer) =>
      _hasCaCertInstalled(reference, admin.reference, certBuffer.reference)
          .boolean;

  static final _installKeyPair = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__installKeyPair")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean installKeyPair(android.content.ComponentName admin, java.security.PrivateKey privKey, java.security.cert.Certificate cert, java.lang.String alias)
  ///
  /// Called by a device or profile owner, or delegated certificate installer, to install a
  /// certificate and corresponding private key. All apps within the profile will be able to access
  /// the certificate and use the private key, given direct user approval.
  ///
  /// Access to the installed credentials will not be granted to the caller of this API without
  /// direct user approval. This is for security - should a certificate installer become
  /// compromised, certificates it had already installed will be protected.
  ///
  /// If the installer must have access to the credentials, call
  /// \#installKeyPair(ComponentName, PrivateKey, Certificate[], String, boolean) instead.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@param privKey The private key to install.
  /// This value must never be {@code null}.
  ///@param cert The certificate to install.
  /// This value must never be {@code null}.
  ///@param alias The private key alias under which to install the certificate. If a certificate
  /// with that alias already exists, it will be overwritten.
  /// This value must never be {@code null}.
  ///@return {@code true} if the keys were installed, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_CERT_INSTALL
  bool installKeyPair(content_.ComponentName admin, jni.JniObject privKey,
          jni.JniObject cert, jni.JniString alias) =>
      _installKeyPair(reference, admin.reference, privKey.reference,
              cert.reference, alias.reference)
          .boolean;

  static final _installKeyPair1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DevicePolicyManager__installKeyPair1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int)>();

  /// from: public boolean installKeyPair(android.content.ComponentName admin, java.security.PrivateKey privKey, java.security.cert.Certificate[] certs, java.lang.String alias, boolean requestAccess)
  ///
  /// Called by a device or profile owner, or delegated certificate installer, to install a
  /// certificate chain and corresponding private key for the leaf certificate. All apps within the
  /// profile will be able to access the certificate chain and use the private key, given direct
  /// user approval.
  ///
  /// The caller of this API may grant itself access to the certificate and private key
  /// immediately, without user approval. It is a best practice not to request this unless strictly
  /// necessary since it opens up additional security vulnerabilities.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///        {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@param privKey The private key to install.
  /// This value must never be {@code null}.
  ///@param certs The certificate chain to install. The chain should start with the leaf
  ///        certificate and include the chain of trust in order. This will be returned by
  ///        android.security.KeyChain\#getCertificateChain.
  /// This value must never be {@code null}.
  ///@param alias The private key alias under which to install the certificate. If a certificate
  ///        with that alias already exists, it will be overwritten.
  /// This value must never be {@code null}.
  ///@param requestAccess {@code true} to request that the calling app be granted access to the
  ///        credentials immediately. Otherwise, access to the credentials will be gated by user
  ///        approval.
  ///@return {@code true} if the keys were installed, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner.
  ///@see android.security.KeyChain\#getCertificateChain
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_CERT_INSTALL
  bool installKeyPair1(content_.ComponentName admin, jni.JniObject privKey,
          jni.JniObject certs, jni.JniString alias, bool requestAccess) =>
      _installKeyPair1(reference, admin.reference, privKey.reference,
              certs.reference, alias.reference, requestAccess ? 1 : 0)
          .boolean;

  static final _installKeyPair2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__installKeyPair2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int)>();

  /// from: public boolean installKeyPair(android.content.ComponentName admin, java.security.PrivateKey privKey, java.security.cert.Certificate[] certs, java.lang.String alias, int flags)
  ///
  /// Called by a device or profile owner, or delegated certificate installer, to install a
  /// certificate chain and corresponding private key for the leaf certificate. All apps within the
  /// profile will be able to access the certificate chain and use the private key, given direct
  /// user approval (if the user is allowed to select the private key).
  ///
  /// The caller of this API may grant itself access to the certificate and private key
  /// immediately, without user approval. It is a best practice not to request this unless strictly
  /// necessary since it opens up additional security vulnerabilities.
  ///
  /// Include \#INSTALLKEY_SET_USER_SELECTABLE in the {@code flags} argument to allow
  /// the user to select the key from a dialog.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///        {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@param privKey The private key to install.
  /// This value must never be {@code null}.
  ///@param certs The certificate chain to install. The chain should start with the leaf
  ///        certificate and include the chain of trust in order. This will be returned by
  ///        android.security.KeyChain\#getCertificateChain.
  /// This value must never be {@code null}.
  ///@param alias The private key alias under which to install the certificate. If a certificate
  ///        with that alias already exists, it will be overwritten.
  /// This value must never be {@code null}.
  ///@param flags Flags to request that the calling app be granted access to the credentials
  ///        and set the key to be user-selectable. See \#INSTALLKEY_SET_USER_SELECTABLE and
  ///        \#INSTALLKEY_REQUEST_CREDENTIALS_ACCESS.
  ///@return {@code true} if the keys were installed, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner.
  ///@see android.security.KeyChain\#getCertificateChain
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_CERT_INSTALL
  bool installKeyPair2(content_.ComponentName admin, jni.JniObject privKey,
          jni.JniObject certs, jni.JniString alias, int flags) =>
      _installKeyPair2(reference, admin.reference, privKey.reference,
              certs.reference, alias.reference, flags)
          .boolean;

  static final _removeKeyPair = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DevicePolicyManager__removeKeyPair")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean removeKeyPair(android.content.ComponentName admin, java.lang.String alias)
  ///
  /// Called by a device or profile owner, or delegated certificate installer, to remove a
  /// certificate and private key pair installed under a given alias.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///        {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@param alias The private key alias under which the certificate is installed.
  /// This value must never be {@code null}.
  ///@return {@code true} if the private key alias no longer exists, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_CERT_INSTALL
  bool removeKeyPair(content_.ComponentName admin, jni.JniString alias) =>
      _removeKeyPair(reference, admin.reference, alias.reference).boolean;

  static final _generateKeyPair = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__generateKeyPair")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.security.AttestedKeyPair generateKeyPair(android.content.ComponentName admin, java.lang.String algorithm, android.security.keystore.KeyGenParameterSpec keySpec, int idAttestationFlags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a device or profile owner, or delegated certificate installer, to generate a
  /// new private/public key pair. If the device supports key generation via secure hardware,
  /// this method is useful for creating a key in KeyChain that never left the secure hardware.
  ///
  /// Access to the key is controlled the same way as in \#installKeyPair.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@param algorithm The key generation algorithm, see java.security.KeyPairGenerator.
  /// This value must never be {@code null}.
  ///@param keySpec Specification of the key to generate, see
  /// java.security.KeyPairGenerator.
  /// This value must never be {@code null}.
  ///@param idAttestationFlags A bitmask of all the identifiers that should be included in the
  ///        attestation record ({@code ID_TYPE_BASE_INFO}, {@code ID_TYPE_SERIAL},
  ///        {@code ID_TYPE_IMEI} and {@code ID_TYPE_MEID}), or {@code 0} if no device
  ///        identification is required in the attestation record.
  ///        Device owner, profile owner and their delegated certificate installer can use
  ///        \#ID_TYPE_BASE_INFO to request inclusion of the general device information
  ///        including manufacturer, model, brand, device and product in the attestation record.
  ///        Only device owner and their delegated certificate installer can use
  ///        \#ID_TYPE_SERIAL, \#ID_TYPE_IMEI and \#ID_TYPE_MEID to request
  ///        unique device identifiers to be attested.
  ///
  ///        If any of \#ID_TYPE_SERIAL, \#ID_TYPE_IMEI and \#ID_TYPE_MEID
  ///        is set, it is implicitly assumed that \#ID_TYPE_BASE_INFO is also set.
  ///
  ///        If any flag is specified, then an attestation challenge must be included in the
  ///        {@code keySpec}.
  /// Value is either <code>0</code> or a combination of android.app.admin.DevicePolicyManager\#ID_TYPE_BASE_INFO, android.app.admin.DevicePolicyManager\#ID_TYPE_SERIAL, android.app.admin.DevicePolicyManager\#ID_TYPE_IMEI, and android.app.admin.DevicePolicyManager\#ID_TYPE_MEID
  ///@return A non-null {@code AttestedKeyPair} if the key generation succeeded, null otherwise.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner. If Device ID attestation is requested (using \#ID_TYPE_SERIAL,
  ///         \#ID_TYPE_IMEI or \#ID_TYPE_MEID), the caller must be the Device Owner
  ///         or the Certificate Installer delegate.
  ///@throws IllegalArgumentException if the alias in {@code keySpec} is empty, if the
  ///         algorithm specification in {@code keySpec} is not {@code RSAKeyGenParameterSpec}
  ///         or {@code ECGenParameterSpec}, or if Device ID attestation was requested but the
  ///         {@code keySpec} does not contain an attestation challenge.
  ///@throws UnsupportedOperationException if Device ID attestation was requested but the
  ///         underlying hardware does not support it.
  ///@see KeyGenParameterSpec.Builder\#setAttestationChallenge(byte[])
  jni.JniObject generateKeyPair(
          content_.ComponentName admin,
          jni.JniString algorithm,
          jni.JniObject keySpec,
          int idAttestationFlags) =>
      jni.JniObject.fromRef(_generateKeyPair(reference, admin.reference,
              algorithm.reference, keySpec.reference, idAttestationFlags)
          .object);

  static final _isDeviceIdAttestationSupported = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isDeviceIdAttestationSupported")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isDeviceIdAttestationSupported()
  ///
  /// Returns {@code true} if the device supports attestation of device identifiers in addition
  /// to key attestation.
  ///@return {@code true} if Device ID attestation is supported.
  bool isDeviceIdAttestationSupported() =>
      _isDeviceIdAttestationSupported(reference).boolean;

  static final _setKeyPairCertificate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DevicePolicyManager__setKeyPairCertificate")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean setKeyPairCertificate(android.content.ComponentName admin, java.lang.String alias, java.util.List<java.security.cert.Certificate> certs, boolean isUserSelectable)
  ///
  /// Called by a device or profile owner, or delegated certificate installer, to associate
  /// certificates with a key pair that was generated using \#generateKeyPair, and
  /// set whether the key is available for the user to choose in the certificate selection
  /// prompt.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if calling from a delegated certificate installer.
  /// This value may be {@code null}.
  ///@param alias The private key alias under which to install the certificate. The {@code alias}
  ///        should denote an existing private key. If a certificate with that alias already
  ///        exists, it will be overwritten.
  /// This value must never be {@code null}.
  ///@param certs The certificate chain to install. The chain should start with the leaf
  ///        certificate and include the chain of trust in order. This will be returned by
  ///        android.security.KeyChain\#getCertificateChain.
  /// This value must never be {@code null}.
  ///@param isUserSelectable {@code true} to indicate that a user can select this key via the
  ///        certificate selection prompt, {@code false} to indicate that this key can only be
  ///        granted access by implementing
  ///        android.app.admin.DeviceAdminReceiver\#onChoosePrivateKeyAlias.
  ///@return {@code true} if the provided {@code alias} exists and the certificates has been
  ///        successfully associated with it, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not {@code null} and not a device or profile
  ///         owner, or {@code admin} is null but the calling application is not a delegated
  ///         certificate installer.
  bool setKeyPairCertificate(content_.ComponentName admin, jni.JniString alias,
          jni.JniObject certs, bool isUserSelectable) =>
      _setKeyPairCertificate(reference, admin.reference, alias.reference,
              certs.reference, isUserSelectable ? 1 : 0)
          .boolean;

  static final _setCertInstallerPackage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setCertInstallerPackage")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setCertInstallerPackage(android.content.ComponentName admin, java.lang.String installerPackage)
  ///
  /// Called by a profile owner or device owner to grant access to privileged certificate
  /// manipulation APIs to a third-party certificate installer app. Granted APIs include
  /// \#getInstalledCaCerts, \#hasCaCertInstalled, \#installCaCert,
  /// \#uninstallCaCert, \#uninstallAllUserCaCerts and \#installKeyPair.
  ///
  /// Delegated certificate installer is a per-user state. The delegated access is persistent until
  /// it is later cleared by calling this method with a null value or uninstallling the certificate
  /// installer.
  ///
  /// __Note:__Starting from android.os.Build.VERSION_CODES\#N, if the caller
  /// application's target SDK version is android.os.Build.VERSION_CODES\#N or newer, the
  /// supplied certificate installer package must be installed when calling this API, otherwise an
  /// IllegalArgumentException will be thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param installerPackage The package name of the certificate installer which will be given
  ///            access. If {@code null} is given the current package will be cleared.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or a profile owner.
  ///@deprecated From android.os.Build.VERSION_CODES\#O. Use \#setDelegatedScopes
  /// with the \#DELEGATION_CERT_INSTALL scope instead.
  void setCertInstallerPackage(
          content_.ComponentName admin, jni.JniString installerPackage) =>
      _setCertInstallerPackage(
              reference, admin.reference, installerPackage.reference)
          .check();

  static final _getCertInstallerPackage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getCertInstallerPackage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getCertInstallerPackage(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a profile owner or device owner to retrieve the certificate installer for the user,
  /// or {@code null} if none is set. If there are multiple delegates this function will return one
  /// of them.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return The package name of the current delegated certificate installer, or {@code null} if
  ///         none is set.
  ///@throws SecurityException if {@code admin} is not a device or a profile owner.
  ///@deprecated From android.os.Build.VERSION_CODES\#O. Use \#getDelegatePackages
  /// with the \#DELEGATION_CERT_INSTALL scope instead.
  jni.JniString getCertInstallerPackage(content_.ComponentName admin) =>
      jni.JniString.fromRef(
          _getCertInstallerPackage(reference, admin.reference).object);

  static final _setDelegatedScopes = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setDelegatedScopes")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setDelegatedScopes(android.content.ComponentName admin, java.lang.String delegatePackage, java.util.List<java.lang.String> scopes)
  ///
  /// Called by a profile owner or device owner to grant access to privileged APIs to another app.
  /// Granted APIs are determined by {@code scopes}, which is a list of the {@code DELEGATION_*}
  /// constants.
  ///
  /// A broadcast with the \#ACTION_APPLICATION_DELEGATION_SCOPES_CHANGED action will be
  /// sent to the {@code delegatePackage} with its new scopes in an {@code ArrayList<String>} extra
  /// under the \#EXTRA_DELEGATION_SCOPES key. The broadcast is sent with the
  /// Intent\#FLAG_RECEIVER_REGISTERED_ONLY flag.
  ///
  /// Delegated scopes are a per-user state. The delegated access is persistent until it is later
  /// cleared by calling this method with an empty {@code scopes} list or uninstalling the
  /// {@code delegatePackage}.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param delegatePackage The package name of the app which will be given access.
  /// This value must never be {@code null}.
  ///@param scopes The groups of privileged APIs whose access should be granted to
  ///            {@code delegatedPackage}.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or a profile owner.
  void setDelegatedScopes(content_.ComponentName admin,
          jni.JniString delegatePackage, jni.JniObject scopes) =>
      _setDelegatedScopes(reference, admin.reference, delegatePackage.reference,
              scopes.reference)
          .check();

  static final _getDelegatedScopes = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getDelegatedScopes")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<java.lang.String> getDelegatedScopes(android.content.ComponentName admin, java.lang.String delegatedPackage)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a profile owner or device owner to retrieve a list of the scopes given to a
  /// delegate package. Other apps can use this method to retrieve their own delegated scopes by
  /// passing {@code null} for {@code admin} and their own package name as
  /// {@code delegatedPackage}.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if the caller is {@code delegatedPackage}.
  /// This value may be {@code null}.
  ///@param delegatedPackage The package name of the app whose scopes should be retrieved.
  /// This value must never be {@code null}.
  ///@return A list containing the scopes given to {@code delegatedPackage}.
  ///@throws SecurityException if {@code admin} is not a device or a profile owner.
  jni.JniObject getDelegatedScopes(
          content_.ComponentName admin, jni.JniString delegatedPackage) =>
      jni.JniObject.fromRef(_getDelegatedScopes(
              reference, admin.reference, delegatedPackage.reference)
          .object);

  static final _getDelegatePackages = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getDelegatePackages")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<java.lang.String> getDelegatePackages(android.content.ComponentName admin, java.lang.String delegationScope)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a profile owner or device owner to retrieve a list of delegate packages that were
  /// granted a delegation scope.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param delegationScope The scope whose delegates should be retrieved.
  /// This value must never be {@code null}.
  ///@return A list of package names of the current delegated packages for
  ///       {@code delegationScope}.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or a profile owner.
  jni.JniObject getDelegatePackages(
          content_.ComponentName admin, jni.JniString delegationScope) =>
      jni.JniObject.fromRef(_getDelegatePackages(
              reference, admin.reference, delegationScope.reference)
          .object);

  static final _setAlwaysOnVpnPackage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DevicePolicyManager__setAlwaysOnVpnPackage")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setAlwaysOnVpnPackage(android.content.ComponentName admin, java.lang.String vpnPackage, boolean lockdownEnabled)
  ///
  /// Called by a device or profile owner to configure an always-on VPN connection through a
  /// specific application for the current user. This connection is automatically granted and
  /// persisted after a reboot.
  ///
  /// To support the always-on feature, an app must
  /// <ul>
  ///     <li>declare a android.net.VpnService in its manifest, guarded by
  ///         android.Manifest.permission\#BIND_VPN_SERVICE;</li>
  ///     <li>target android.os.Build.VERSION_CODES\#N API 24 or above; and</li>
  ///     <li><i>not</i> explicitly opt out of the feature through
  ///         android.net.VpnService\#SERVICE_META_DATA_SUPPORTS_ALWAYS_ON.</li>
  /// </ul>
  /// The call will fail if called with the package name of an unsupported VPN app.
  ///@param vpnPackage The package name for an installed VPN app on the device, or {@code null} to
  ///        remove an existing always-on VPN configuration.
  /// This value may be {@code null}.
  ///@param lockdownEnabled {@code true} to disallow networking when the VPN is not connected or
  ///        {@code false} otherwise. This carries the risk that any failure of the VPN provider
  ///        could break networking for all apps. This has no effect when clearing.
  ///@throws SecurityException if {@code admin} is not a device or a profile owner.
  ///@throws NameNotFoundException if {@code vpnPackage} is not installed.
  ///@throws UnsupportedOperationException if {@code vpnPackage} exists but does not support being
  ///         set as always-on, or if always-on VPN is not available.
  ///@param admin This value must never be {@code null}.
  void setAlwaysOnVpnPackage(content_.ComponentName admin,
          jni.JniString vpnPackage, bool lockdownEnabled) =>
      _setAlwaysOnVpnPackage(reference, admin.reference, vpnPackage.reference,
              lockdownEnabled ? 1 : 0)
          .check();

  static final _getAlwaysOnVpnPackage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getAlwaysOnVpnPackage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getAlwaysOnVpnPackage(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a device or profile owner to read the name of the package administering an
  /// always-on VPN connection for the current user. If there is no such package, or the always-on
  /// VPN is provided by the system instead of by an application, {@code null} will be returned.
  ///@param admin This value must never be {@code null}.
  ///@return Package name of VPN controller responsible for always-on VPN, or {@code null} if none
  ///         is set.
  ///@throws SecurityException if {@code admin} is not a device or a profile owner.
  jni.JniString getAlwaysOnVpnPackage(content_.ComponentName admin) =>
      jni.JniString.fromRef(
          _getAlwaysOnVpnPackage(reference, admin.reference).object);

  static final _setCameraDisabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DevicePolicyManager__setCameraDisabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setCameraDisabled(android.content.ComponentName admin, boolean disabled)
  ///
  /// Called by an application that is administering the device to disable all cameras on the
  /// device, for this user. After setting this, no applications running as this user will be able
  /// to access any cameras on the device.
  ///
  /// If the caller is device owner, then the restriction will be applied to all users.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_DISABLE_CAMERA to be able to call this method; if it has
  /// not, a security exception will be thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param disabled Whether or not the camera should be disabled.
  ///@throws SecurityException if {@code admin} is not an active administrator or does not use
  ///             DeviceAdminInfo\#USES_POLICY_DISABLE_CAMERA.
  void setCameraDisabled(content_.ComponentName admin, bool disabled) =>
      _setCameraDisabled(reference, admin.reference, disabled ? 1 : 0).check();

  static final _getCameraDisabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getCameraDisabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getCameraDisabled(android.content.ComponentName admin)
  ///
  /// Determine whether or not the device's cameras have been disabled for this user,
  /// either by the calling admin, if specified, or all admins.
  ///@param admin The name of the admin component to check, or {@code null} to check whether any admins
  /// have disabled the camera
  ///
  /// This value may be {@code null}.
  bool getCameraDisabled(content_.ComponentName admin) =>
      _getCameraDisabled(reference, admin.reference).boolean;

  static final _requestBugreport = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__requestBugreport")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean requestBugreport(android.content.ComponentName admin)
  ///
  /// Called by a device owner to request a bugreport.
  ///
  /// If the device contains secondary users or profiles, they must be affiliated with the device.
  /// Otherwise a SecurityException will be thrown. See \#isAffiliatedUser.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return {@code true} if the bugreport collection started successfully, or {@code false} if it
  ///         wasn't triggered because a previous bugreport operation is still active (either the
  ///         bugreport is still running or waiting for the user to share or decline)
  ///@throws SecurityException if {@code admin} is not a device owner, or there is at least one
  ///         profile or secondary user that is not affiliated with the device.
  ///@see \#isAffiliatedUser
  bool requestBugreport(content_.ComponentName admin) =>
      _requestBugreport(reference, admin.reference).boolean;

  static final _setScreenCaptureDisabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DevicePolicyManager__setScreenCaptureDisabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setScreenCaptureDisabled(android.content.ComponentName admin, boolean disabled)
  ///
  /// Called by a device/profile owner to set whether the screen capture is disabled. Disabling
  /// screen capture also prevents the content from being shown on display devices that do not have
  /// a secure video output. See android.view.Display\#FLAG_SECURE for more details about
  /// secure surfaces and secure displays.
  ///
  /// The calling device admin must be a device or profile owner. If it is not, a security
  /// exception will be thrown.
  ///
  /// From version android.os.Build.VERSION_CODES\#M disabling screen capture also blocks
  /// assist requests for all activities of the relevant user.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param disabled Whether screen capture is disabled or not.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setScreenCaptureDisabled(content_.ComponentName admin, bool disabled) =>
      _setScreenCaptureDisabled(reference, admin.reference, disabled ? 1 : 0)
          .check();

  static final _getScreenCaptureDisabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getScreenCaptureDisabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getScreenCaptureDisabled(android.content.ComponentName admin)
  ///
  /// Determine whether or not screen capture has been disabled by the calling
  /// admin, if specified, or all admins.
  ///@param admin The name of the admin component to check, or {@code null} to check whether any admins
  /// have disabled screen capture.
  ///
  /// This value may be {@code null}.
  bool getScreenCaptureDisabled(content_.ComponentName admin) =>
      _getScreenCaptureDisabled(reference, admin.reference).boolean;

  static final _setAutoTimeRequired = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DevicePolicyManager__setAutoTimeRequired")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setAutoTimeRequired(android.content.ComponentName admin, boolean required)
  ///
  /// Called by a device or profile owner to set whether auto time is required. If auto time is
  /// required, no user will be able set the date and time and network date and time will be used.
  ///
  /// Note: if auto time is required the user can still manually set the time zone.
  ///
  /// The calling device admin must be a device or profile owner. If it is not, a security
  /// exception will be thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param required Whether auto time is set required or not.
  ///@throws SecurityException if {@code admin} is not a device owner.
  void setAutoTimeRequired(content_.ComponentName admin, bool required0) =>
      _setAutoTimeRequired(reference, admin.reference, required0 ? 1 : 0)
          .check();

  static final _getAutoTimeRequired = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getAutoTimeRequired")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getAutoTimeRequired()
  ///
  /// @return true if auto time is required.
  bool getAutoTimeRequired() => _getAutoTimeRequired(reference).boolean;

  static final _setKeyguardDisabledFeatures = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "DevicePolicyManager__setKeyguardDisabledFeatures")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setKeyguardDisabledFeatures(android.content.ComponentName admin, int which)
  ///
  /// Called by an application that is administering the device to disable keyguard customizations,
  /// such as widgets. After setting this, keyguard features will be disabled according to the
  /// provided feature list.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_DISABLE_KEYGUARD_FEATURES to be able to call this method;
  /// if it has not, a security exception will be thrown.
  ///
  /// Calling this from a managed profile before version android.os.Build.VERSION_CODES\#M
  /// will throw a security exception. From version android.os.Build.VERSION_CODES\#M the
  /// profile owner of a managed profile can set:
  /// <ul>
  /// <li>\#KEYGUARD_DISABLE_TRUST_AGENTS, which affects the parent user, but only if there
  /// is no separate challenge set on the managed profile.
  /// <li>\#KEYGUARD_DISABLE_FINGERPRINT, \#KEYGUARD_DISABLE_FACE or
  /// \#KEYGUARD_DISABLE_IRIS which affects the managed profile challenge if
  /// there is one, or the parent user otherwise.
  /// <li>\#KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS which affects notifications generated
  /// by applications in the managed profile.
  /// </ul>
  /// \#KEYGUARD_DISABLE_TRUST_AGENTS, \#KEYGUARD_DISABLE_FINGERPRINT,
  /// \#KEYGUARD_DISABLE_FACE and \#KEYGUARD_DISABLE_IRIS can also be
  /// set on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set restrictions on the parent
  /// profile.
  ///
  /// Requests to disable other features on a managed profile will be ignored.
  ///
  /// The admin can check which features have been disabled by calling
  /// \#getKeyguardDisabledFeatures(ComponentName)
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param which The disabled features flag which can be either
  ///            \#KEYGUARD_DISABLE_FEATURES_NONE (default),
  ///            \#KEYGUARD_DISABLE_FEATURES_ALL, or a combination of
  ///            \#KEYGUARD_DISABLE_WIDGETS_ALL, \#KEYGUARD_DISABLE_SECURE_CAMERA,
  ///            \#KEYGUARD_DISABLE_SECURE_NOTIFICATIONS,
  ///            \#KEYGUARD_DISABLE_TRUST_AGENTS,
  ///            \#KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS,
  ///            \#KEYGUARD_DISABLE_FINGERPRINT,
  ///            \#KEYGUARD_DISABLE_FACE,
  ///            \#KEYGUARD_DISABLE_IRIS.
  ///@throws SecurityException if {@code admin} is not an active administrator or does not user
  ///             DeviceAdminInfo\#USES_POLICY_DISABLE_KEYGUARD_FEATURES
  void setKeyguardDisabledFeatures(content_.ComponentName admin, int which) =>
      _setKeyguardDisabledFeatures(reference, admin.reference, which).check();

  static final _getKeyguardDisabledFeatures = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getKeyguardDisabledFeatures")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getKeyguardDisabledFeatures(android.content.ComponentName admin)
  ///
  /// Determine whether or not features have been disabled in keyguard either by the calling
  /// admin, if specified, or all admins that set restrictions on this user and its participating
  /// profiles. Restrictions on profiles that have a separate challenge are not taken into account.
  ///
  /// This method can be called on the DevicePolicyManager instance
  /// returned by \#getParentProfileInstance(ComponentName) in order to retrieve
  /// restrictions on the parent profile.
  ///@param admin The name of the admin component to check, or {@code null} to check whether any
  /// admins have disabled features in keyguard.
  /// This value may be {@code null}.
  ///@return bitfield of flags. See \#setKeyguardDisabledFeatures(ComponentName, int)
  /// for a list.
  int getKeyguardDisabledFeatures(content_.ComponentName admin) =>
      _getKeyguardDisabledFeatures(reference, admin.reference).integer;

  static final _isDeviceOwnerApp = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isDeviceOwnerApp")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isDeviceOwnerApp(java.lang.String packageName)
  ///
  /// Used to determine if a particular package has been registered as a Device Owner app.
  /// A device owner app is a special device admin that cannot be deactivated by the user, once
  /// activated as a device admin. It also cannot be uninstalled. To check whether a particular
  /// package is currently registered as the device owner app, pass in the package name from
  /// Context\#getPackageName() to this method.<p/>This is useful for device
  /// admin apps that want to check whether they are also registered as the device owner app. The
  /// exact mechanism by which a device admin app is registered as a device owner app is defined by
  /// the setup process.
  ///@param packageName the package name of the app, to compare with the registered device owner
  /// app, if any.
  ///@return whether or not the package is registered as the device owner app.
  bool isDeviceOwnerApp(jni.JniString packageName) =>
      _isDeviceOwnerApp(reference, packageName.reference).boolean;

  static final _clearDeviceOwnerApp = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__clearDeviceOwnerApp")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void clearDeviceOwnerApp(java.lang.String packageName)
  ///
  /// Clears the current device owner. The caller must be the device owner. This function should be
  /// used cautiously as once it is called it cannot be undone. The device owner can only be set as
  /// a part of device setup, before it completes.
  ///
  /// While some policies previously set by the device owner will be cleared by this method, it is
  /// a best-effort process and some other policies will still remain in place after the device
  /// owner is cleared.
  ///@param packageName The package name of the device owner.
  ///@throws SecurityException if the caller is not in {@code packageName} or {@code packageName}
  ///             does not own the current device owner component.
  ///@deprecated This method is expected to be used for testing purposes only. The device owner
  /// will lose control of the device and its data after calling it. In order to protect any
  /// sensitive data that remains on the device, it is advised that the device owner factory resets
  /// the device instead of calling this method. See \#wipeData(int).
  void clearDeviceOwnerApp(jni.JniString packageName) =>
      _clearDeviceOwnerApp(reference, packageName.reference).check();

  static final _clearProfileOwner = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__clearProfileOwner")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void clearProfileOwner(android.content.ComponentName admin)
  ///
  /// Clears the active profile owner. The caller must be the profile owner of this user, otherwise
  /// a SecurityException will be thrown. This method is not available to managed profile owners.
  ///
  /// While some policies previously set by the profile owner will be cleared by this method, it is
  /// a best-effort process and some other policies will still remain in place after the profile
  /// owner is cleared.
  ///@param admin The component to remove as the profile owner.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not an active profile owner, or the method is
  /// being called from a managed profile.
  ///@deprecated This method is expected to be used for testing purposes only. The profile owner
  /// will lose control of the user and its data after calling it. In order to protect any
  /// sensitive data that remains on this user, it is advised that the profile owner deletes it
  /// instead of calling this method. See \#wipeData(int).
  void clearProfileOwner(content_.ComponentName admin) =>
      _clearProfileOwner(reference, admin.reference).check();

  static final _setDeviceOwnerLockScreenInfo = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setDeviceOwnerLockScreenInfo")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setDeviceOwnerLockScreenInfo(android.content.ComponentName admin, java.lang.CharSequence info)
  ///
  /// Sets the device owner information to be shown on the lock screen.
  ///
  /// If the device owner information is {@code null} or empty then the device owner info is
  /// cleared and the user owner info is shown on the lock screen if it is set.
  ///
  /// If the device owner information contains only whitespaces then the message on the lock screen
  /// will be blank and the user will not be allowed to change it.
  ///
  /// If the device owner information needs to be localized, it is the responsibility of the
  /// DeviceAdminReceiver to listen to the Intent\#ACTION_LOCALE_CHANGED broadcast
  /// and set a new version of this string accordingly.
  ///@param admin The name of the admin component to check.
  /// This value must never be {@code null}.
  ///@param info Device owner information which will be displayed instead of the user owner info.
  ///@throws SecurityException if {@code admin} is not a device owner.
  void setDeviceOwnerLockScreenInfo(
          content_.ComponentName admin, jni.JniObject info) =>
      _setDeviceOwnerLockScreenInfo(reference, admin.reference, info.reference)
          .check();

  static final _getDeviceOwnerLockScreenInfo = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getDeviceOwnerLockScreenInfo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getDeviceOwnerLockScreenInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The device owner information. If it is not set returns {@code null}.
  jni.JniObject getDeviceOwnerLockScreenInfo() =>
      jni.JniObject.fromRef(_getDeviceOwnerLockScreenInfo(reference).object);

  static final _setPackagesSuspended = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DevicePolicyManager__setPackagesSuspended")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String[] setPackagesSuspended(android.content.ComponentName admin, java.lang.String[] packageNames, boolean suspended)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by device or profile owners to suspend packages for this user. This function can be
  /// called by a device owner, profile owner, or by a delegate given the
  /// \#DELEGATION_PACKAGE_ACCESS scope via \#setDelegatedScopes.
  ///
  /// A suspended package will not be able to start activities. Its notifications will be hidden,
  /// it will not show up in recents, will not be able to show toasts or dialogs or ring the
  /// device.
  ///
  /// The package must already be installed. If the package is uninstalled while suspended the
  /// package will no longer be suspended. The admin can block this by using
  /// \#setUninstallBlocked.
  ///@param admin The name of the admin component to check, or {@code null} if the caller is a
  ///            package access delegate.
  /// This value must never be {@code null}.
  ///@param packageNames The package names to suspend or unsuspend.
  /// This value must never be {@code null}.
  ///@param suspended If set to {@code true} than the packages will be suspended, if set to
  ///            {@code false} the packages will be unsuspended.
  ///@return an array of package names for which the suspended status is not set as requested in
  ///         this method.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_PACKAGE_ACCESS
  jni.JniObject setPackagesSuspended(content_.ComponentName admin,
          jni.JniObject packageNames, bool suspended) =>
      jni.JniObject.fromRef(_setPackagesSuspended(reference, admin.reference,
              packageNames.reference, suspended ? 1 : 0)
          .object);

  static final _isPackageSuspended = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isPackageSuspended")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isPackageSuspended(android.content.ComponentName admin, java.lang.String packageName)
  ///
  /// Determine if a package is suspended. This function can be called by a device owner, profile
  /// owner, or by a delegate given the \#DELEGATION_PACKAGE_ACCESS scope via
  /// \#setDelegatedScopes.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if the caller is a package access delegate.
  /// This value must never be {@code null}.
  ///@param packageName The name of the package to retrieve the suspended status of.
  ///@return {@code true} if the package is suspended or {@code false} if the package is not
  ///         suspended, could not be found or an error occurred.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@throws NameNotFoundException if the package could not be found.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_PACKAGE_ACCESS
  bool isPackageSuspended(
          content_.ComponentName admin, jni.JniString packageName) =>
      _isPackageSuspended(reference, admin.reference, packageName.reference)
          .boolean;

  static final _setProfileEnabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setProfileEnabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setProfileEnabled(android.content.ComponentName admin)
  ///
  /// Sets the enabled state of the profile. A profile should be enabled only once it is ready to
  /// be used. Only the profile owner can call this.
  ///@see \#isProfileOwnerApp
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  void setProfileEnabled(content_.ComponentName admin) =>
      _setProfileEnabled(reference, admin.reference).check();

  static final _setProfileName = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setProfileName")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setProfileName(android.content.ComponentName admin, java.lang.String profileName)
  ///
  /// Sets the name of the profile. In the device owner case it sets the name of the user which it
  /// is called from. Only a profile owner or device owner can call this. If this is never called
  /// by the profile or device owner, the name will be set to default values.
  ///@see \#isProfileOwnerApp
  ///@see \#isDeviceOwnerApp
  ///@param admin Which DeviceAdminReceiver this request is associate with.
  /// This value must never be {@code null}.
  ///@param profileName The name of the profile.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setProfileName(
          content_.ComponentName admin, jni.JniString profileName) =>
      _setProfileName(reference, admin.reference, profileName.reference)
          .check();

  static final _isProfileOwnerApp = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isProfileOwnerApp")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isProfileOwnerApp(java.lang.String packageName)
  ///
  /// Used to determine if a particular package is registered as the profile owner for the
  /// user. A profile owner is a special device admin that has additional privileges
  /// within the profile.
  ///@param packageName The package name of the app to compare with the registered profile owner.
  ///@return Whether or not the package is registered as the profile owner.
  bool isProfileOwnerApp(jni.JniString packageName) =>
      _isProfileOwnerApp(reference, packageName.reference).boolean;

  static final _addPersistentPreferredActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__addPersistentPreferredActivity")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void addPersistentPreferredActivity(android.content.ComponentName admin, android.content.IntentFilter filter, android.content.ComponentName activity)
  ///
  /// Called by a profile owner or device owner to set a default activity that the system selects
  /// to handle intents that match the given IntentFilter. This activity will remain the
  /// default intent handler even if the set of potential event handlers for the intent filter
  /// changes and if the intent preferences are reset.
  ///
  /// Note that the caller should still declare the activity in the manifest, the API just sets
  /// the activity to be the default one to handle the given intent filter.
  ///
  /// The default disambiguation mechanism takes over if the activity is not installed (anymore).
  /// When the activity is (re)installed, it is automatically reset as default intent handler for
  /// the filter.
  ///
  /// The calling device admin must be a profile owner or device owner. If it is not, a security
  /// exception will be thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param filter The IntentFilter for which a default handler is added.
  ///@param activity The Activity that is added as default intent handler.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void addPersistentPreferredActivity(content_.ComponentName admin,
          content_.IntentFilter filter, content_.ComponentName activity) =>
      _addPersistentPreferredActivity(
              reference, admin.reference, filter.reference, activity.reference)
          .check();

  static final _clearPackagePersistentPreferredActivities = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__clearPackagePersistentPreferredActivities")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void clearPackagePersistentPreferredActivities(android.content.ComponentName admin, java.lang.String packageName)
  ///
  /// Called by a profile owner or device owner to remove all persistent intent handler preferences
  /// associated with the given package that were set by \#addPersistentPreferredActivity.
  ///
  /// The calling device admin must be a profile owner. If it is not, a security exception will be
  /// thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageName The name of the package for which preferences are removed.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void clearPackagePersistentPreferredActivities(
          content_.ComponentName admin, jni.JniString packageName) =>
      _clearPackagePersistentPreferredActivities(
              reference, admin.reference, packageName.reference)
          .check();

  static final _setApplicationRestrictionsManagingPackage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setApplicationRestrictionsManagingPackage")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setApplicationRestrictionsManagingPackage(android.content.ComponentName admin, java.lang.String packageName)
  ///
  /// Called by a profile owner or device owner to grant permission to a package to manage
  /// application restrictions for the calling user via \#setApplicationRestrictions and
  /// \#getApplicationRestrictions.
  ///
  /// This permission is persistent until it is later cleared by calling this method with a
  /// {@code null} value or uninstalling the managing package.
  ///
  /// The supplied application restriction managing package must be installed when calling this
  /// API, otherwise an NameNotFoundException will be thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageName The package name which will be given access to application restrictions
  ///            APIs. If {@code null} is given the current package will be cleared.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@throws NameNotFoundException if {@code packageName} is not found
  ///@deprecated From android.os.Build.VERSION_CODES\#O. Use \#setDelegatedScopes
  /// with the \#DELEGATION_APP_RESTRICTIONS scope instead.
  void setApplicationRestrictionsManagingPackage(
          content_.ComponentName admin, jni.JniString packageName) =>
      _setApplicationRestrictionsManagingPackage(
              reference, admin.reference, packageName.reference)
          .check();

  static final _getApplicationRestrictionsManagingPackage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getApplicationRestrictionsManagingPackage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getApplicationRestrictionsManagingPackage(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a profile owner or device owner to retrieve the application restrictions managing
  /// package for the current user, or {@code null} if none is set. If there are multiple
  /// delegates this function will return one of them.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return The package name allowed to manage application restrictions on the current user, or
  ///         {@code null} if none is set.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@deprecated From android.os.Build.VERSION_CODES\#O. Use \#getDelegatePackages
  /// with the \#DELEGATION_APP_RESTRICTIONS scope instead.
  jni.JniString getApplicationRestrictionsManagingPackage(
          content_.ComponentName admin) =>
      jni.JniString.fromRef(
          _getApplicationRestrictionsManagingPackage(reference, admin.reference)
              .object);

  static final _isCallerApplicationRestrictionsManagingPackage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isCallerApplicationRestrictionsManagingPackage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isCallerApplicationRestrictionsManagingPackage()
  ///
  /// Called by any application to find out whether it has been granted permission via
  /// \#setApplicationRestrictionsManagingPackage to manage application restrictions
  /// for the calling user.
  ///
  /// This is done by comparing the calling Linux uid with the uid of the package specified by
  /// that method.
  ///@deprecated From android.os.Build.VERSION_CODES\#O. Use \#getDelegatedScopes
  /// instead.
  bool isCallerApplicationRestrictionsManagingPackage() =>
      _isCallerApplicationRestrictionsManagingPackage(reference).boolean;

  static final _setApplicationRestrictions = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setApplicationRestrictions")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setApplicationRestrictions(android.content.ComponentName admin, java.lang.String packageName, android.os.Bundle settings)
  ///
  /// Sets the application restrictions for a given target application running in the calling user.
  ///
  /// The caller must be a profile or device owner on that user, or the package allowed to manage
  /// application restrictions via \#setDelegatedScopes with the
  /// \#DELEGATION_APP_RESTRICTIONS scope; otherwise a security exception will be thrown.
  ///
  /// The provided Bundle consists of key-value pairs, where the types of values may be:
  /// <ul>
  /// <li>{@code boolean}
  /// <li>{@code int}
  /// <li>{@code String} or {@code String[]}
  /// <li>From android.os.Build.VERSION_CODES\#M, {@code Bundle} or {@code Bundle[]}
  /// </ul>
  ///
  /// If the restrictions are not available yet, but may be applied in the near future, the caller
  /// can notify the target application of that by adding
  /// UserManager\#KEY_RESTRICTIONS_PENDING to the settings parameter.
  ///
  /// The application restrictions are only made visible to the target application via
  /// UserManager\#getApplicationRestrictions(String), in addition to the profile or device
  /// owner, and the application restrictions managing package via
  /// \#getApplicationRestrictions.
  ///
  /// NOTE: The method performs disk I/O and shouldn't be called on the main thread
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if called by the application restrictions managing package.
  /// This value may be {@code null}.
  ///@param packageName The name of the package to update restricted settings for.
  ///@param settings A Bundle to be parsed by the receiving application, conveying a new
  ///            set of active restrictions.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_APP_RESTRICTIONS
  ///@see UserManager\#KEY_RESTRICTIONS_PENDING
  void setApplicationRestrictions(content_.ComponentName admin,
          jni.JniString packageName, os_.Bundle settings) =>
      _setApplicationRestrictions(reference, admin.reference,
              packageName.reference, settings.reference)
          .check();

  static final _setTrustAgentConfiguration = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setTrustAgentConfiguration")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTrustAgentConfiguration(android.content.ComponentName admin, android.content.ComponentName target, android.os.PersistableBundle configuration)
  ///
  /// Sets a list of configuration features to enable for a trust agent component. This is meant to
  /// be used in conjunction with \#KEYGUARD_DISABLE_TRUST_AGENTS, which disables all trust
  /// agents but those enabled by this function call. If flag
  /// \#KEYGUARD_DISABLE_TRUST_AGENTS is not set, then this call has no effect.
  ///
  /// For any specific trust agent, whether it is disabled or not depends on the aggregated state
  /// of each admin's \#KEYGUARD_DISABLE_TRUST_AGENTS setting and its trust agent
  /// configuration as set by this function call. In particular: if any admin sets
  /// \#KEYGUARD_DISABLE_TRUST_AGENTS and does not additionally set any
  /// trust agent configuration, the trust agent is disabled completely. Otherwise, the trust agent
  /// will receive the list of configurations from all admins who set
  /// \#KEYGUARD_DISABLE_TRUST_AGENTS and aggregate the configurations to determine its
  /// behavior. The exact meaning of aggregation is trust-agent-specific.
  ///
  /// The calling device admin must have requested
  /// DeviceAdminInfo\#USES_POLICY_DISABLE_KEYGUARD_FEATURES to be able to call this method;
  /// if not, a security exception will be thrown.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to set the configuration for
  /// the parent profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param target Component name of the agent to be configured.
  /// This value must never be {@code null}.
  ///@param configuration Trust-agent-specific feature configuration bundle. Please consult
  ///        documentation of the specific trust agent to determine the interpretation of this
  ///        bundle.
  ///@throws SecurityException if {@code admin} is not an active administrator or does not use
  ///             DeviceAdminInfo\#USES_POLICY_DISABLE_KEYGUARD_FEATURES
  void setTrustAgentConfiguration(content_.ComponentName admin,
          content_.ComponentName target, os_.PersistableBundle configuration) =>
      _setTrustAgentConfiguration(reference, admin.reference, target.reference,
              configuration.reference)
          .check();

  static final _getTrustAgentConfiguration = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getTrustAgentConfiguration")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.os.PersistableBundle> getTrustAgentConfiguration(android.content.ComponentName admin, android.content.ComponentName agent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets configuration for the given trust agent based on aggregating all calls to
  /// \#setTrustAgentConfiguration(ComponentName, ComponentName, PersistableBundle) for
  /// all device admins.
  ///
  /// This method can be called on the DevicePolicyManager instance returned by
  /// \#getParentProfileInstance(ComponentName) in order to retrieve the configuration set
  /// on the parent profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with. If null,
  /// this function returns a list of configurations for all admins that declare
  /// \#KEYGUARD_DISABLE_TRUST_AGENTS. If any admin declares
  /// \#KEYGUARD_DISABLE_TRUST_AGENTS but doesn't call
  /// \#setTrustAgentConfiguration(ComponentName, ComponentName, PersistableBundle)
  /// for this {@param agent} or calls it with a null configuration, null is returned.
  /// This value may be {@code null}.
  ///@param agent Which component to get enabled features for.
  /// This value must never be {@code null}.
  ///@return configuration for the given trust agent.
  jni.JniObject getTrustAgentConfiguration(
          content_.ComponentName admin, content_.ComponentName agent) =>
      jni.JniObject.fromRef(_getTrustAgentConfiguration(
              reference, admin.reference, agent.reference)
          .object);

  static final _setCrossProfileCallerIdDisabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "DevicePolicyManager__setCrossProfileCallerIdDisabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setCrossProfileCallerIdDisabled(android.content.ComponentName admin, boolean disabled)
  ///
  /// Called by a profile owner of a managed profile to set whether caller-Id information from the
  /// managed profile will be shown in the parent profile, for incoming calls.
  ///
  /// The calling device admin must be a profile owner. If it is not, a security exception will be
  /// thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param disabled If true caller-Id information in the managed profile is not displayed.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  void setCrossProfileCallerIdDisabled(
          content_.ComponentName admin, bool disabled) =>
      _setCrossProfileCallerIdDisabled(
              reference, admin.reference, disabled ? 1 : 0)
          .check();

  static final _getCrossProfileCallerIdDisabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getCrossProfileCallerIdDisabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getCrossProfileCallerIdDisabled(android.content.ComponentName admin)
  ///
  /// Called by a profile owner of a managed profile to determine whether or not caller-Id
  /// information has been disabled.
  ///
  /// The calling device admin must be a profile owner. If it is not, a security exception will be
  /// thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  bool getCrossProfileCallerIdDisabled(content_.ComponentName admin) =>
      _getCrossProfileCallerIdDisabled(reference, admin.reference).boolean;

  static final _setCrossProfileContactsSearchDisabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "DevicePolicyManager__setCrossProfileContactsSearchDisabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setCrossProfileContactsSearchDisabled(android.content.ComponentName admin, boolean disabled)
  ///
  /// Called by a profile owner of a managed profile to set whether contacts search from the
  /// managed profile will be shown in the parent profile, for incoming calls.
  ///
  /// The calling device admin must be a profile owner. If it is not, a security exception will be
  /// thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param disabled If true contacts search in the managed profile is not displayed.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  void setCrossProfileContactsSearchDisabled(
          content_.ComponentName admin, bool disabled) =>
      _setCrossProfileContactsSearchDisabled(
              reference, admin.reference, disabled ? 1 : 0)
          .check();

  static final _getCrossProfileContactsSearchDisabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getCrossProfileContactsSearchDisabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getCrossProfileContactsSearchDisabled(android.content.ComponentName admin)
  ///
  /// Called by a profile owner of a managed profile to determine whether or not contacts search
  /// has been disabled.
  ///
  /// The calling device admin must be a profile owner. If it is not, a security exception will be
  /// thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  bool getCrossProfileContactsSearchDisabled(content_.ComponentName admin) =>
      _getCrossProfileContactsSearchDisabled(reference, admin.reference)
          .boolean;

  static final _setBluetoothContactSharingDisabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "DevicePolicyManager__setBluetoothContactSharingDisabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setBluetoothContactSharingDisabled(android.content.ComponentName admin, boolean disabled)
  ///
  /// Called by a profile owner of a managed profile to set whether bluetooth devices can access
  /// enterprise contacts.
  ///
  /// The calling device admin must be a profile owner. If it is not, a security exception will be
  /// thrown.
  ///
  /// This API works on managed profile only.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param disabled If true, bluetooth devices cannot access enterprise contacts.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  void setBluetoothContactSharingDisabled(
          content_.ComponentName admin, bool disabled) =>
      _setBluetoothContactSharingDisabled(
              reference, admin.reference, disabled ? 1 : 0)
          .check();

  static final _getBluetoothContactSharingDisabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getBluetoothContactSharingDisabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getBluetoothContactSharingDisabled(android.content.ComponentName admin)
  ///
  /// Called by a profile owner of a managed profile to determine whether or not Bluetooth devices
  /// cannot access enterprise contacts.
  ///
  /// The calling device admin must be a profile owner. If it is not, a security exception will be
  /// thrown.
  ///
  /// This API works on managed profile only.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  bool getBluetoothContactSharingDisabled(content_.ComponentName admin) =>
      _getBluetoothContactSharingDisabled(reference, admin.reference).boolean;

  static final _addCrossProfileIntentFilter = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32)>>(
          "DevicePolicyManager__addCrossProfileIntentFilter")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void addCrossProfileIntentFilter(android.content.ComponentName admin, android.content.IntentFilter filter, int flags)
  ///
  /// Called by the profile owner of a managed profile so that some intents sent in the managed
  /// profile can also be resolved in the parent, or vice versa. Only activity intents are
  /// supported.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param filter The IntentFilter the intent has to match to be also resolved in the
  ///            other profile
  ///@param flags DevicePolicyManager\#FLAG_MANAGED_CAN_ACCESS_PARENT and
  ///            DevicePolicyManager\#FLAG_PARENT_CAN_ACCESS_MANAGED are supported.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void addCrossProfileIntentFilter(content_.ComponentName admin,
          content_.IntentFilter filter, int flags) =>
      _addCrossProfileIntentFilter(
              reference, admin.reference, filter.reference, flags)
          .check();

  static final _clearCrossProfileIntentFilters = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__clearCrossProfileIntentFilters")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void clearCrossProfileIntentFilters(android.content.ComponentName admin)
  ///
  /// Called by a profile owner of a managed profile to remove the cross-profile intent filters
  /// that go from the managed profile to the parent, or from the parent to the managed profile.
  /// Only removes those that have been set by the profile owner.
  ///
  /// _Note_: A list of default cross profile intent filters are set up by the system when
  /// the profile is created, some of them ensure the proper functioning of the profile, while
  /// others enable sharing of data from the parent to the managed profile for user convenience.
  /// These default intent filters are not cleared when this API is called. If the default cross
  /// profile data sharing is not desired, they can be disabled with
  /// UserManager\#DISALLOW_SHARE_INTO_MANAGED_PROFILE.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  void clearCrossProfileIntentFilters(content_.ComponentName admin) =>
      _clearCrossProfileIntentFilters(reference, admin.reference).check();

  static final _setPermittedAccessibilityServices = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setPermittedAccessibilityServices")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean setPermittedAccessibilityServices(android.content.ComponentName admin, java.util.List<java.lang.String> packageNames)
  ///
  /// Called by a profile or device owner to set the permitted
  /// android.accessibilityservice.AccessibilityService. When set by
  /// a device owner or profile owner the restriction applies to all profiles of the user the
  /// device owner or profile owner is an admin for. By default, the user can use any accessibility
  /// service. When zero or more packages have been added, accessibility services that are not in
  /// the list and not part of the system can not be enabled by the user.
  ///
  /// Calling with a null value for the list disables the restriction so that all services can be
  /// used, calling with an empty list only allows the built-in system services. Any non-system
  /// accessibility service that's currently enabled must be included in the list.
  ///
  /// System accessibility services are always available to the user the list can't modify this.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageNames List of accessibility service package names.
  ///@return {@code true} if the operation succeeded, or {@code false} if the list didn't
  ///         contain every enabled non-system accessibility service.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  bool setPermittedAccessibilityServices(
          content_.ComponentName admin, jni.JniObject packageNames) =>
      _setPermittedAccessibilityServices(
              reference, admin.reference, packageNames.reference)
          .boolean;

  static final _getPermittedAccessibilityServices = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getPermittedAccessibilityServices")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<java.lang.String> getPermittedAccessibilityServices(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of permitted accessibility services set by this device or profile owner.
  ///
  /// An empty list means no accessibility services except system services are allowed. Null means
  /// all accessibility services are allowed.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return List of accessiblity service package names.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  jni.JniObject getPermittedAccessibilityServices(
          content_.ComponentName admin) =>
      jni.JniObject.fromRef(
          _getPermittedAccessibilityServices(reference, admin.reference)
              .object);

  static final _setPermittedInputMethods = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setPermittedInputMethods")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean setPermittedInputMethods(android.content.ComponentName admin, java.util.List<java.lang.String> packageNames)
  ///
  /// Called by a profile or device owner to set the permitted input methods services. When set by
  /// a device owner or profile owner the restriction applies to all profiles of the user the
  /// device owner or profile owner is an admin for. By default, the user can use any input method.
  /// When zero or more packages have been added, input method that are not in the list and not
  /// part of the system can not be enabled by the user. This method will fail if it is called for
  /// a admin that is not for the foreground user or a profile of the foreground user. Any
  /// non-system input method service that's currently enabled must be included in the list.
  ///
  /// Calling with a null value for the list disables the restriction so that all input methods can
  /// be used, calling with an empty list disables all but the system's own input methods.
  ///
  /// System input methods are always available to the user this method can't modify this.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageNames List of input method package names.
  ///@return {@code true} if the operation succeeded, or {@code false} if the list didn't
  ///        contain every enabled non-system input method service.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  bool setPermittedInputMethods(
          content_.ComponentName admin, jni.JniObject packageNames) =>
      _setPermittedInputMethods(
              reference, admin.reference, packageNames.reference)
          .boolean;

  static final _getPermittedInputMethods = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getPermittedInputMethods")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<java.lang.String> getPermittedInputMethods(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of permitted input methods set by this device or profile owner.
  ///
  /// An empty list means no input methods except system input methods are allowed. Null means all
  /// input methods are allowed.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return List of input method package names.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  jni.JniObject getPermittedInputMethods(content_.ComponentName admin) =>
      jni.JniObject.fromRef(
          _getPermittedInputMethods(reference, admin.reference).object);

  static final _setPermittedCrossProfileNotificationListeners = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setPermittedCrossProfileNotificationListeners")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean setPermittedCrossProfileNotificationListeners(android.content.ComponentName admin, java.util.List<java.lang.String> packageList)
  ///
  /// Called by a profile owner of a managed profile to set the packages that are allowed to use
  /// a android.service.notification.NotificationListenerService in the primary user to
  /// see notifications from the managed profile. By default all packages are permitted by this
  /// policy. When zero or more packages have been added, notification listeners installed on the
  /// primary user that are not in the list and are not part of the system won't receive events
  /// for managed profile notifications.
  ///
  /// Calling with a {@code null} value for the list disables the restriction so that all
  /// notification listener services be used. Calling with an empty list disables all but the
  /// system's own notification listeners. System notification listener services are always
  /// available to the user.
  ///
  /// If a device or profile owner want to stop notification listeners in their user from seeing
  /// that user's notifications they should prevent that service from running instead (e.g. via
  /// \#setApplicationHidden(ComponentName, String, boolean))
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageList List of package names to whitelist
  /// This value may be {@code null}.
  ///@return true if setting the restriction succeeded. It will fail if called outside a managed
  /// profile
  ///@throws SecurityException if {@code admin} is not a profile owner.
  ///@see android.service.notification.NotificationListenerService
  bool setPermittedCrossProfileNotificationListeners(
          content_.ComponentName admin, jni.JniObject packageList) =>
      _setPermittedCrossProfileNotificationListeners(
              reference, admin.reference, packageList.reference)
          .boolean;

  static final _getPermittedCrossProfileNotificationListeners = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getPermittedCrossProfileNotificationListeners")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<java.lang.String> getPermittedCrossProfileNotificationListeners(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of packages installed on the primary user that allowed to use a
  /// android.service.notification.NotificationListenerService to receive
  /// notifications from this managed profile, as set by the profile owner.
  ///
  /// An empty list means no notification listener services except system ones are allowed.
  /// A {@code null} return value indicates that all notification listeners are allowed.
  ///@param admin This value must never be {@code null}.
  jni.JniObject getPermittedCrossProfileNotificationListeners(
          content_.ComponentName admin) =>
      jni.JniObject.fromRef(_getPermittedCrossProfileNotificationListeners(
              reference, admin.reference)
          .object);

  static final _getKeepUninstalledPackages = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getKeepUninstalledPackages")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<java.lang.String> getKeepUninstalledPackages(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the list of apps to keep around as APKs even if no user has currently installed it. This
  /// function can be called by a device owner or by a delegate given the
  /// \#DELEGATION_KEEP_UNINSTALLED_PACKAGES scope via \#setDelegatedScopes.
  ///
  /// Please note that packages returned in this method are not automatically pre-cached.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if the caller is a keep uninstalled packages delegate.
  /// This value may be {@code null}.
  ///@return List of package names to keep cached.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_KEEP_UNINSTALLED_PACKAGES
  jni.JniObject getKeepUninstalledPackages(content_.ComponentName admin) =>
      jni.JniObject.fromRef(
          _getKeepUninstalledPackages(reference, admin.reference).object);

  static final _setKeepUninstalledPackages = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setKeepUninstalledPackages")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setKeepUninstalledPackages(android.content.ComponentName admin, java.util.List<java.lang.String> packageNames)
  ///
  /// Set a list of apps to keep around as APKs even if no user has currently installed it. This
  /// function can be called by a device owner or by a delegate given the
  /// \#DELEGATION_KEEP_UNINSTALLED_PACKAGES scope via \#setDelegatedScopes.
  ///
  /// Please note that setting this policy does not imply that specified apps will be
  /// automatically pre-cached.
  ///
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if the caller is a keep uninstalled packages delegate.
  /// This value may be {@code null}.
  ///@param packageNames List of package names to keep cached.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_KEEP_UNINSTALLED_PACKAGES
  void setKeepUninstalledPackages(
          content_.ComponentName admin, jni.JniObject packageNames) =>
      _setKeepUninstalledPackages(
              reference, admin.reference, packageNames.reference)
          .check();

  static final _createAndManageUser = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__createAndManageUser")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int)>();

  /// from: public android.os.UserHandle createAndManageUser(android.content.ComponentName admin, java.lang.String name, android.content.ComponentName profileOwner, android.os.PersistableBundle adminExtras, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a device owner to create a user with the specified name and a given component of
  /// the calling package as profile owner. The UserHandle returned by this method should not be
  /// persisted as user handles are recycled as users are removed and created. If you need to
  /// persist an identifier for this user, use UserManager\#getSerialNumberForUser. The new
  /// user will not be started in the background.
  ///
  /// admin is the DeviceAdminReceiver which is the device owner. profileOwner is also a
  /// DeviceAdminReceiver in the same package as admin, and will become the profile owner and will
  /// be registered as an active admin on the new user. The profile owner package will be installed
  /// on the new user.
  ///
  /// If the adminExtras are not null, they will be stored on the device until the user is started
  /// for the first time. Then the extras will be passed to the admin when onEnable is called.
  /// From android.os.Build.VERSION_CODES\#P onwards, if targeting
  /// android.os.Build.VERSION_CODES\#P, throws UserOperationException instead of
  /// returning {@code null} on failure.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param name The user's name.
  /// This value must never be {@code null}.
  ///@param profileOwner Which DeviceAdminReceiver will be profile owner. Has to be in the
  ///            same package as admin, otherwise no user is created and an
  ///            IllegalArgumentException is thrown.
  /// This value must never be {@code null}.
  ///@param adminExtras Extras that will be passed to onEnable of the admin receiver on the new
  ///            user.
  /// This value may be {@code null}.
  ///@param flags \#SKIP_SETUP_WIZARD, \#MAKE_USER_EPHEMERAL and
  ///        \#LEAVE_ALL_SYSTEM_APPS_ENABLED are supported.
  /// Value is either <code>0</code> or a combination of android.app.admin.DevicePolicyManager\#SKIP_SETUP_WIZARD, android.app.admin.DevicePolicyManager\#MAKE_USER_EPHEMERAL, android.app.admin.DevicePolicyManager.MAKE_USER_DEMO, and android.app.admin.DevicePolicyManager\#LEAVE_ALL_SYSTEM_APPS_ENABLED
  ///@see UserHandle
  ///@return the android.os.UserHandle object for the created user, or {@code null} if the
  ///         user could not be created.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@throws UserOperationException if the user could not be created and the calling app is
  /// targeting android.os.Build.VERSION_CODES\#P and running on
  /// android.os.Build.VERSION_CODES\#P.
  os_.UserHandle createAndManageUser(
          content_.ComponentName admin,
          jni.JniString name,
          content_.ComponentName profileOwner,
          os_.PersistableBundle adminExtras,
          int flags) =>
      os_.UserHandle.fromRef(_createAndManageUser(
              reference,
              admin.reference,
              name.reference,
              profileOwner.reference,
              adminExtras.reference,
              flags)
          .object);

  static final _removeUser = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DevicePolicyManager__removeUser")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean removeUser(android.content.ComponentName admin, android.os.UserHandle userHandle)
  ///
  /// Called by a device owner to remove a user/profile and all associated data. The primary user
  /// can not be removed.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param userHandle the user to remove.
  /// This value must never be {@code null}.
  ///@return {@code true} if the user was removed, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not a device owner.
  bool removeUser(content_.ComponentName admin, os_.UserHandle userHandle) =>
      _removeUser(reference, admin.reference, userHandle.reference).boolean;

  static final _switchUser = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DevicePolicyManager__switchUser")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean switchUser(android.content.ComponentName admin, android.os.UserHandle userHandle)
  ///
  /// Called by a device owner to switch the specified secondary user to the foreground.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param userHandle the user to switch to; null will switch to primary.
  /// This value may be {@code null}.
  ///@return {@code true} if the switch was successful, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see Intent\#ACTION_USER_FOREGROUND
  ///@see \#getSecondaryUsers(ComponentName)
  bool switchUser(content_.ComponentName admin, os_.UserHandle userHandle) =>
      _switchUser(reference, admin.reference, userHandle.reference).boolean;

  static final _startUserInBackground = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__startUserInBackground")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int startUserInBackground(android.content.ComponentName admin, android.os.UserHandle userHandle)
  ///
  /// Called by a device owner to start the specified secondary user in background.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param userHandle the user to be started in background.
  /// This value must never be {@code null}.
  ///@return one of the following result codes:
  /// UserManager\#USER_OPERATION_ERROR_UNKNOWN,
  /// UserManager\#USER_OPERATION_SUCCESS,
  /// UserManager\#USER_OPERATION_ERROR_MANAGED_PROFILE,
  /// UserManager\#USER_OPERATION_ERROR_MAX_RUNNING_USERS,
  /// Value is android.os.UserManager\#USER_OPERATION_SUCCESS, android.os.UserManager\#USER_OPERATION_ERROR_UNKNOWN, android.os.UserManager\#USER_OPERATION_ERROR_MANAGED_PROFILE, android.os.UserManager\#USER_OPERATION_ERROR_MAX_RUNNING_USERS, android.os.UserManager\#USER_OPERATION_ERROR_CURRENT_USER, android.os.UserManager\#USER_OPERATION_ERROR_LOW_STORAGE, or android.os.UserManager\#USER_OPERATION_ERROR_MAX_USERS
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#getSecondaryUsers(ComponentName)
  int startUserInBackground(
          content_.ComponentName admin, os_.UserHandle userHandle) =>
      _startUserInBackground(reference, admin.reference, userHandle.reference)
          .integer;

  static final _stopUser = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DevicePolicyManager__stopUser")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int stopUser(android.content.ComponentName admin, android.os.UserHandle userHandle)
  ///
  /// Called by a device owner to stop the specified secondary user.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param userHandle the user to be stopped.
  /// This value must never be {@code null}.
  ///@return one of the following result codes:
  /// UserManager\#USER_OPERATION_ERROR_UNKNOWN,
  /// UserManager\#USER_OPERATION_SUCCESS,
  /// UserManager\#USER_OPERATION_ERROR_MANAGED_PROFILE,
  /// UserManager\#USER_OPERATION_ERROR_CURRENT_USER
  /// Value is android.os.UserManager\#USER_OPERATION_SUCCESS, android.os.UserManager\#USER_OPERATION_ERROR_UNKNOWN, android.os.UserManager\#USER_OPERATION_ERROR_MANAGED_PROFILE, android.os.UserManager\#USER_OPERATION_ERROR_MAX_RUNNING_USERS, android.os.UserManager\#USER_OPERATION_ERROR_CURRENT_USER, android.os.UserManager\#USER_OPERATION_ERROR_LOW_STORAGE, or android.os.UserManager\#USER_OPERATION_ERROR_MAX_USERS
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#getSecondaryUsers(ComponentName)
  int stopUser(content_.ComponentName admin, os_.UserHandle userHandle) =>
      _stopUser(reference, admin.reference, userHandle.reference).integer;

  static final _logoutUser = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DevicePolicyManager__logoutUser")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int logoutUser(android.content.ComponentName admin)
  ///
  /// Called by a profile owner of secondary user that is affiliated with the device to stop the
  /// calling user and switch back to primary.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return one of the following result codes:
  /// UserManager\#USER_OPERATION_ERROR_UNKNOWN,
  /// UserManager\#USER_OPERATION_SUCCESS,
  /// UserManager\#USER_OPERATION_ERROR_MANAGED_PROFILE,
  /// UserManager\#USER_OPERATION_ERROR_CURRENT_USER
  /// Value is android.os.UserManager\#USER_OPERATION_SUCCESS, android.os.UserManager\#USER_OPERATION_ERROR_UNKNOWN, android.os.UserManager\#USER_OPERATION_ERROR_MANAGED_PROFILE, android.os.UserManager\#USER_OPERATION_ERROR_MAX_RUNNING_USERS, android.os.UserManager\#USER_OPERATION_ERROR_CURRENT_USER, android.os.UserManager\#USER_OPERATION_ERROR_LOW_STORAGE, or android.os.UserManager\#USER_OPERATION_ERROR_MAX_USERS
  ///@throws SecurityException if {@code admin} is not a profile owner affiliated with the device.
  ///@see \#getSecondaryUsers(ComponentName)
  int logoutUser(content_.ComponentName admin) =>
      _logoutUser(reference, admin.reference).integer;

  static final _getSecondaryUsers = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getSecondaryUsers")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.os.UserHandle> getSecondaryUsers(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a device owner to list all secondary users on the device. Managed profiles are not
  /// considered as secondary users.
  ///  Used for various user management APIs, including \#switchUser, \#removeUser
  /// and \#stopUser.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return list of other UserHandles on the device.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#removeUser(ComponentName, UserHandle)
  ///@see \#switchUser(ComponentName, UserHandle)
  ///@see \#startUserInBackground(ComponentName, UserHandle)
  ///@see \#stopUser(ComponentName, UserHandle)
  jni.JniObject getSecondaryUsers(content_.ComponentName admin) =>
      jni.JniObject.fromRef(
          _getSecondaryUsers(reference, admin.reference).object);

  static final _isEphemeralUser = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isEphemeralUser")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isEphemeralUser(android.content.ComponentName admin)
  ///
  /// Checks if the profile owner is running in an ephemeral user.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return whether the profile owner is running in an ephemeral user.
  bool isEphemeralUser(content_.ComponentName admin) =>
      _isEphemeralUser(reference, admin.reference).boolean;

  static final _getApplicationRestrictions = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getApplicationRestrictions")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getApplicationRestrictions(android.content.ComponentName admin, java.lang.String packageName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the application restrictions for a given target application running in the calling
  /// user.
  ///
  /// The caller must be a profile or device owner on that user, or the package allowed to manage
  /// application restrictions via \#setDelegatedScopes with the
  /// \#DELEGATION_APP_RESTRICTIONS scope; otherwise a security exception will be thrown.
  ///
  /// NOTE: The method performs disk I/O and shouldn't be called on the main thread
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if called by the application restrictions managing package.
  /// This value may be {@code null}.
  ///@param packageName The name of the package to fetch restricted settings of.
  ///@return Bundle of settings corresponding to what was set last time
  ///         DevicePolicyManager\#setApplicationRestrictions was called, or an empty
  ///         Bundle if no restrictions have been set.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_APP_RESTRICTIONS
  os_.Bundle getApplicationRestrictions(
          content_.ComponentName admin, jni.JniString packageName) =>
      os_.Bundle.fromRef(_getApplicationRestrictions(
              reference, admin.reference, packageName.reference)
          .object);

  static final _addUserRestriction = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__addUserRestriction")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void addUserRestriction(android.content.ComponentName admin, java.lang.String key)
  ///
  /// Called by a profile or device owner to set a user restriction specified by the key.
  ///
  /// The calling device admin must be a profile or device owner; if it is not, a security
  /// exception will be thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param key The key of the restriction. See the constants in android.os.UserManager
  ///            for the list of keys.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void addUserRestriction(content_.ComponentName admin, jni.JniString key) =>
      _addUserRestriction(reference, admin.reference, key.reference).check();

  static final _clearUserRestriction = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__clearUserRestriction")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void clearUserRestriction(android.content.ComponentName admin, java.lang.String key)
  ///
  /// Called by a profile or device owner to clear a user restriction specified by the key.
  ///
  /// The calling device admin must be a profile or device owner; if it is not, a security
  /// exception will be thrown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param key The key of the restriction. See the constants in android.os.UserManager
  ///            for the list of keys.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void clearUserRestriction(content_.ComponentName admin, jni.JniString key) =>
      _clearUserRestriction(reference, admin.reference, key.reference).check();

  static final _getUserRestrictions = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getUserRestrictions")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getUserRestrictions(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a profile or device owner to get user restrictions set with
  /// \#addUserRestriction(ComponentName, String).
  ///
  /// The target user may have more restrictions set by the system or other device owner / profile
  /// owner. To get all the user restrictions currently set, use
  /// UserManager\#getUserRestrictions().
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@return This value will never be {@code null}.
  os_.Bundle getUserRestrictions(content_.ComponentName admin) =>
      os_.Bundle.fromRef(
          _getUserRestrictions(reference, admin.reference).object);

  static final _createAdminSupportIntent = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__createAdminSupportIntent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent createAdminSupportIntent(java.lang.String restriction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by any app to display a support dialog when a feature was disabled by an admin.
  /// This returns an intent that can be used with Context\#startActivity(Intent) to
  /// display the dialog. It will tell the user that the feature indicated by {@code restriction}
  /// was disabled by an admin, and include a link for more information. The default content of
  /// the dialog can be changed by the restricting admin via
  /// \#setShortSupportMessage(ComponentName, CharSequence). If the restriction is not
  /// set (i.e. the feature is available), then the return value will be {@code null}.
  ///@param restriction Indicates for which feature the dialog should be displayed. Can be a
  ///            user restriction from UserManager, e.g.
  ///            UserManager\#DISALLOW_ADJUST_VOLUME, or one of the constants
  ///            \#POLICY_DISABLE_CAMERA, \#POLICY_DISABLE_SCREEN_CAPTURE.
  /// This value must never be {@code null}.
  ///@return Intent An intent to be used to start the dialog-activity if the restriction is
  ///            set by an admin, or null if the restriction does not exist or no admin set it.
  content_.Intent createAdminSupportIntent(jni.JniString restriction) =>
      content_.Intent.fromRef(
          _createAdminSupportIntent(reference, restriction.reference).object);

  static final _setApplicationHidden = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DevicePolicyManager__setApplicationHidden")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean setApplicationHidden(android.content.ComponentName admin, java.lang.String packageName, boolean hidden)
  ///
  /// Hide or unhide packages. When a package is hidden it is unavailable for use, but the data and
  /// actual package file remain. This function can be called by a device owner, profile owner, or
  /// by a delegate given the \#DELEGATION_PACKAGE_ACCESS scope via
  /// \#setDelegatedScopes.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if the caller is a package access delegate.
  /// This value must never be {@code null}.
  ///@param packageName The name of the package to hide or unhide.
  ///@param hidden {@code true} if the package should be hidden, {@code false} if it should be
  ///            unhidden.
  ///@return boolean Whether the hidden setting of the package was successfully updated.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_PACKAGE_ACCESS
  bool setApplicationHidden(content_.ComponentName admin,
          jni.JniString packageName, bool hidden) =>
      _setApplicationHidden(
              reference, admin.reference, packageName.reference, hidden ? 1 : 0)
          .boolean;

  static final _isApplicationHidden = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isApplicationHidden")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isApplicationHidden(android.content.ComponentName admin, java.lang.String packageName)
  ///
  /// Determine if a package is hidden. This function can be called by a device owner, profile
  /// owner, or by a delegate given the \#DELEGATION_PACKAGE_ACCESS scope via
  /// \#setDelegatedScopes.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if the caller is a package access delegate.
  /// This value must never be {@code null}.
  ///@param packageName The name of the package to retrieve the hidden status of.
  ///@return boolean {@code true} if the package is hidden, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_PACKAGE_ACCESS
  bool isApplicationHidden(
          content_.ComponentName admin, jni.JniString packageName) =>
      _isApplicationHidden(reference, admin.reference, packageName.reference)
          .boolean;

  static final _enableSystemApp = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__enableSystemApp")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void enableSystemApp(android.content.ComponentName admin, java.lang.String packageName)
  ///
  /// Re-enable a system app that was disabled by default when the user was initialized. This
  /// function can be called by a device owner, profile owner, or by a delegate given the
  /// \#DELEGATION_ENABLE_SYSTEM_APP scope via \#setDelegatedScopes.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if the caller is an enable system app delegate.
  /// This value must never be {@code null}.
  ///@param packageName The package to be re-enabled in the calling profile.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_PACKAGE_ACCESS
  void enableSystemApp(
          content_.ComponentName admin, jni.JniString packageName) =>
      _enableSystemApp(reference, admin.reference, packageName.reference)
          .check();

  static final _enableSystemApp1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__enableSystemApp1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int enableSystemApp(android.content.ComponentName admin, android.content.Intent intent)
  ///
  /// Re-enable system apps by intent that were disabled by default when the user was initialized.
  /// This function can be called by a device owner, profile owner, or by a delegate given the
  /// \#DELEGATION_ENABLE_SYSTEM_APP scope via \#setDelegatedScopes.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///            {@code null} if the caller is an enable system app delegate.
  /// This value must never be {@code null}.
  ///@param intent An intent matching the app(s) to be installed. All apps that resolve for this
  ///            intent will be re-enabled in the calling profile.
  ///@return int The number of activities that matched the intent and were installed.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_PACKAGE_ACCESS
  int enableSystemApp1(content_.ComponentName admin, content_.Intent intent) =>
      _enableSystemApp1(reference, admin.reference, intent.reference).integer;

  static final _installExistingPackage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__installExistingPackage")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean installExistingPackage(android.content.ComponentName admin, java.lang.String packageName)
  ///
  /// Install an existing package that has been installed in another user, or has been kept after
  /// removal via \#setKeepUninstalledPackages.
  /// This function can be called by a device owner, profile owner or a delegate given
  /// the \#DELEGATION_INSTALL_EXISTING_PACKAGE scope via \#setDelegatedScopes.
  /// When called in a secondary user or managed profile, the user/profile must be affiliated with
  /// the device. See \#isAffiliatedUser.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageName The package to be installed in the calling profile.
  ///@return {@code true} if the app is installed; {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not the device owner, or the profile owner of
  /// an affiliated user or profile.
  ///@see \#setKeepUninstalledPackages
  ///@see \#setDelegatedScopes
  ///@see \#isAffiliatedUser
  ///@see \#DELEGATION_PACKAGE_ACCESS
  bool installExistingPackage(
          content_.ComponentName admin, jni.JniString packageName) =>
      _installExistingPackage(reference, admin.reference, packageName.reference)
          .boolean;

  static final _setAccountManagementDisabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Uint8)>>(
          "DevicePolicyManager__setAccountManagementDisabled")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setAccountManagementDisabled(android.content.ComponentName admin, java.lang.String accountType, boolean disabled)
  ///
  /// Called by a device owner or profile owner to disable account management for a specific type
  /// of account.
  ///
  /// The calling device admin must be a device owner or profile owner. If it is not, a security
  /// exception will be thrown.
  ///
  /// When account management is disabled for an account type, adding or removing an account of
  /// that type will not be possible.
  ///
  /// From android.os.Build.VERSION_CODES\#N the profile or device owner can still use
  /// android.accounts.AccountManager APIs to add or remove accounts when account
  /// management for a specific type is disabled.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param accountType For which account management is disabled or enabled.
  ///@param disabled The boolean indicating that account management will be disabled (true) or
  ///            enabled (false).
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setAccountManagementDisabled(content_.ComponentName admin,
          jni.JniString accountType, bool disabled) =>
      _setAccountManagementDisabled(reference, admin.reference,
              accountType.reference, disabled ? 1 : 0)
          .check();

  static final _getAccountTypesWithManagementDisabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getAccountTypesWithManagementDisabled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getAccountTypesWithManagementDisabled()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the array of accounts for which account management is disabled by the profile owner.
  ///
  ///  Account management can be disabled/enabled by calling
  /// \#setAccountManagementDisabled.
  ///@return a list of account types for which account management has been disabled.
  ///
  /// This value may be {@code null}.
  ///@see \#setAccountManagementDisabled
  jni.JniObject getAccountTypesWithManagementDisabled() =>
      jni.JniObject.fromRef(
          _getAccountTypesWithManagementDisabled(reference).object);

  static final _setLockTaskPackages = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setLockTaskPackages")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setLockTaskPackages(android.content.ComponentName admin, java.lang.String[] packages)
  ///
  /// Sets which packages may enter lock task mode.
  ///
  /// Any packages that share uid with an allowed package will also be allowed to activate lock
  /// task. From android.os.Build.VERSION_CODES\#M removing packages from the lock task
  /// package list results in locked tasks belonging to those packages to be finished.
  ///
  /// This function can only be called by the device owner, a profile owner of an affiliated user
  /// or profile, or the profile owner when no device owner is set. See \#isAffiliatedUser.
  /// Any package set via this method will be cleared if the user becomes unaffiliated.
  ///@param packages The list of packages allowed to enter lock task mode
  /// This value must never be {@code null}.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not the device owner, the profile owner of an
  /// affiliated user or profile, or the profile owner when no device owner is set.
  ///@see \#isAffiliatedUser
  ///@see Activity\#startLockTask()
  ///@see DeviceAdminReceiver\#onLockTaskModeEntering(Context, Intent, String)
  ///@see DeviceAdminReceiver\#onLockTaskModeExiting(Context, Intent)
  ///@see UserManager\#DISALLOW_CREATE_WINDOWS
  void setLockTaskPackages(
          content_.ComponentName admin, jni.JniObject packages) =>
      _setLockTaskPackages(reference, admin.reference, packages.reference)
          .check();

  static final _getLockTaskPackages = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getLockTaskPackages")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getLockTaskPackages(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of packages allowed to start the lock task mode.
  ///@throws SecurityException if {@code admin} is not the device owner, the profile owner of an
  /// affiliated user or profile, or the profile owner when no device owner is set.
  ///@see \#isAffiliatedUser
  ///@see \#setLockTaskPackages
  ///@param admin This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  jni.JniObject getLockTaskPackages(content_.ComponentName admin) =>
      jni.JniObject.fromRef(
          _getLockTaskPackages(reference, admin.reference).object);

  static final _isLockTaskPermitted = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isLockTaskPermitted")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isLockTaskPermitted(java.lang.String pkg)
  ///
  /// This function lets the caller know whether the given component is allowed to start the
  /// lock task mode.
  ///@param pkg The package to check
  bool isLockTaskPermitted(jni.JniString pkg) =>
      _isLockTaskPermitted(reference, pkg.reference).boolean;

  static final _setLockTaskFeatures = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__setLockTaskFeatures")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setLockTaskFeatures(android.content.ComponentName admin, int flags)
  ///
  /// Sets which system features are enabled when the device runs in lock task mode. This method
  /// doesn't affect the features when lock task mode is inactive. Any system features not included
  /// in {@code flags} are implicitly disabled when calling this method. By default, only
  /// \#LOCK_TASK_FEATURE_GLOBAL_ACTIONS is enabled\u2014all the other features are disabled. To
  /// disable the global actions dialog, call this method omitting
  /// \#LOCK_TASK_FEATURE_GLOBAL_ACTIONS.
  ///
  /// This method can only be called by the device owner, a profile owner of an affiliated
  /// user or profile, or the profile owner when no device owner is set. See
  /// \#isAffiliatedUser.
  /// Any features set using this method are cleared if the user becomes unaffiliated.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param flags The system features enabled during lock task mode.
  /// Value is either <code>0</code> or a combination of android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_NONE, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_SYSTEM_INFO, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_NOTIFICATIONS, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_HOME, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_OVERVIEW, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_GLOBAL_ACTIONS, and android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_KEYGUARD
  ///@throws SecurityException if {@code admin} is not the device owner, the profile owner of an
  /// affiliated user or profile, or the profile owner when no device owner is set.
  ///@see \#isAffiliatedUser
  void setLockTaskFeatures(content_.ComponentName admin, int flags) =>
      _setLockTaskFeatures(reference, admin.reference, flags).check();

  static final _getLockTaskFeatures = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getLockTaskFeatures")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getLockTaskFeatures(android.content.ComponentName admin)
  ///
  /// Gets which system features are enabled for LockTask mode.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return bitfield of flags. See \#setLockTaskFeatures(ComponentName, int) for a list.
  /// Value is either <code>0</code> or a combination of android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_NONE, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_SYSTEM_INFO, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_NOTIFICATIONS, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_HOME, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_OVERVIEW, android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_GLOBAL_ACTIONS, and android.app.admin.DevicePolicyManager\#LOCK_TASK_FEATURE_KEYGUARD
  ///@throws SecurityException if {@code admin} is not the device owner, the profile owner of an
  /// affiliated user or profile, or the profile owner when no device owner is set.
  ///@see \#isAffiliatedUser
  ///@see \#setLockTaskFeatures
  int getLockTaskFeatures(content_.ComponentName admin) =>
      _getLockTaskFeatures(reference, admin.reference).integer;

  static final _setGlobalSetting = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setGlobalSetting")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setGlobalSetting(android.content.ComponentName admin, java.lang.String setting, java.lang.String value)
  ///
  /// Called by device owner to update android.provider.Settings.Global settings.
  /// Validation that the value of the setting is in the correct form for the setting type should
  /// be performed by the caller.
  ///
  /// The settings that can be updated with this method are:
  /// <ul>
  /// <li>android.provider.Settings.Global\#ADB_ENABLED</li>
  /// <li>android.provider.Settings.Global\#AUTO_TIME</li>
  /// <li>android.provider.Settings.Global\#AUTO_TIME_ZONE</li>
  /// <li>android.provider.Settings.Global\#DATA_ROAMING</li>
  /// <li>android.provider.Settings.Global\#USB_MASS_STORAGE_ENABLED</li>
  /// <li>android.provider.Settings.Global\#WIFI_SLEEP_POLICY</li>
  /// <li>android.provider.Settings.Global\#STAY_ON_WHILE_PLUGGED_IN This setting is only
  /// available from android.os.Build.VERSION_CODES\#M onwards and can only be set if
  /// \#setMaximumTimeToLock is not used to set a timeout.</li>
  /// <li>android.provider.Settings.Global\#WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN</li> This
  /// setting is only available from android.os.Build.VERSION_CODES\#M onwards.</li>
  /// </ul>
  ///
  /// Changing the following settings has no effect as of android.os.Build.VERSION_CODES\#M:
  /// <ul>
  /// <li>android.provider.Settings.Global\#BLUETOOTH_ON. Use
  /// android.bluetooth.BluetoothAdapter\#enable() and
  /// android.bluetooth.BluetoothAdapter\#disable() instead.</li>
  /// <li>android.provider.Settings.Global\#DEVELOPMENT_SETTINGS_ENABLED</li>
  /// <li>android.provider.Settings.Global\#MODE_RINGER. Use
  /// android.media.AudioManager\#setRingerMode(int) instead.</li>
  /// <li>android.provider.Settings.Global\#NETWORK_PREFERENCE</li>
  /// <li>android.provider.Settings.Global\#WIFI_ON. Use
  /// android.net.wifi.WifiManager\#setWifiEnabled(boolean) instead.</li>
  /// </ul>
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param setting The name of the setting to update.
  ///@param value The value to update the setting to.
  ///@throws SecurityException if {@code admin} is not a device owner.
  void setGlobalSetting(content_.ComponentName admin, jni.JniString setting,
          jni.JniString value) =>
      _setGlobalSetting(
              reference, admin.reference, setting.reference, value.reference)
          .check();

  static final _setSystemSetting = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setSystemSetting")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setSystemSetting(android.content.ComponentName admin, java.lang.String setting, java.lang.String value)
  ///
  /// Called by a device or profile owner to update android.provider.Settings.System
  /// settings. Validation that the value of the setting is in the correct form for the setting
  /// type should be performed by the caller.
  ///
  /// The settings that can be updated by a device owner or profile owner of secondary user with
  /// this method are:
  /// <ul>
  /// <li>android.provider.Settings.System\#SCREEN_BRIGHTNESS</li>
  /// <li>android.provider.Settings.System\#SCREEN_BRIGHTNESS_MODE</li>
  /// <li>android.provider.Settings.System\#SCREEN_OFF_TIMEOUT</li>
  /// </ul>
  ///
  ///@see android.provider.Settings.System\#SCREEN_OFF_TIMEOUT
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param setting The name of the setting to update.
  /// This value must never be {@code null}.
  /// Value is android.provider.Settings.System\#SCREEN_BRIGHTNESS_MODE, android.provider.Settings.System\#SCREEN_BRIGHTNESS, or android.provider.Settings.System\#SCREEN_OFF_TIMEOUT
  ///@param value The value to update the setting to.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setSystemSetting(content_.ComponentName admin, jni.JniString setting,
          jni.JniString value) =>
      _setSystemSetting(
              reference, admin.reference, setting.reference, value.reference)
          .check();

  static final _setTime = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("DevicePolicyManager__setTime")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean setTime(android.content.ComponentName admin, long millis)
  ///
  /// Called by device owner to set the system wall clock time. This only takes effect if called
  /// when android.provider.Settings.Global\#AUTO_TIME is 0, otherwise {@code false} will be
  /// returned.
  ///@param admin Which DeviceAdminReceiver this request is associated with
  /// This value must never be {@code null}.
  ///@param millis time in milliseconds since the Epoch
  ///@return {@code true} if set time succeeded, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not a device owner.
  bool setTime(content_.ComponentName admin, int millis) =>
      _setTime(reference, admin.reference, millis).boolean;

  static final _setTimeZone = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DevicePolicyManager__setTimeZone")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean setTimeZone(android.content.ComponentName admin, java.lang.String timeZone)
  ///
  /// Called by device owner to set the system's persistent default time zone. This only takes
  /// effect if called when android.provider.Settings.Global\#AUTO_TIME_ZONE is 0, otherwise
  /// {@code false} will be returned.
  ///@see android.app.AlarmManager\#setTimeZone(String)
  ///@param admin Which DeviceAdminReceiver this request is associated with
  /// This value must never be {@code null}.
  ///@param timeZone one of the Olson ids from the list returned by
  ///     java.util.TimeZone\#getAvailableIDs
  ///@return {@code true} if set timezone succeeded, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not a device owner.
  bool setTimeZone(content_.ComponentName admin, jni.JniString timeZone) =>
      _setTimeZone(reference, admin.reference, timeZone.reference).boolean;

  static final _setSecureSetting = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setSecureSetting")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setSecureSetting(android.content.ComponentName admin, java.lang.String setting, java.lang.String value)
  ///
  /// Called by profile or device owners to update android.provider.Settings.Secure
  /// settings. Validation that the value of the setting is in the correct form for the setting
  /// type should be performed by the caller.
  ///
  /// The settings that can be updated by a profile or device owner with this method are:
  /// <ul>
  /// <li>android.provider.Settings.Secure\#DEFAULT_INPUT_METHOD</li>
  /// <li>android.provider.Settings.Secure\#SKIP_FIRST_USE_HINTS</li>
  /// </ul>
  ///
  /// A device owner can additionally update the following settings:
  /// <ul>
  /// <li>android.provider.Settings.Secure\#LOCATION_MODE</li>
  /// </ul>
  ///
  /// <strong>Note: Starting from Android O, apps should no longer call this method with the
  /// setting android.provider.Settings.Secure\#INSTALL_NON_MARKET_APPS, which is
  /// deprecated. Instead, device owners or profile owners should use the restriction
  /// UserManager\#DISALLOW_INSTALL_UNKNOWN_SOURCES.
  /// If any app targeting android.os.Build.VERSION_CODES\#O or higher calls this method
  /// with android.provider.Settings.Secure\#INSTALL_NON_MARKET_APPS,
  /// an UnsupportedOperationException is thrown.
  /// </strong>
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param setting The name of the setting to update.
  ///@param value The value to update the setting to.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setSecureSetting(content_.ComponentName admin, jni.JniString setting,
          jni.JniString value) =>
      _setSecureSetting(
              reference, admin.reference, setting.reference, value.reference)
          .check();

  static final _setRestrictionsProvider = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setRestrictionsProvider")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setRestrictionsProvider(android.content.ComponentName admin, android.content.ComponentName provider)
  ///
  /// Designates a specific service component as the provider for making permission requests of a
  /// local or remote administrator of the user.
  /// <p/>
  /// Only a profile owner can designate the restrictions provider.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param provider The component name of the service that implements
  ///            RestrictionsReceiver. If this param is null, it removes the restrictions
  ///            provider previously assigned.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setRestrictionsProvider(
          content_.ComponentName admin, content_.ComponentName provider) =>
      _setRestrictionsProvider(reference, admin.reference, provider.reference)
          .check();

  static final _setMasterVolumeMuted = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DevicePolicyManager__setMasterVolumeMuted")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setMasterVolumeMuted(android.content.ComponentName admin, boolean on)
  ///
  /// Called by profile or device owners to set the master volume mute on or off.
  /// This has no effect when set on a managed profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param on {@code true} to mute master volume, {@code false} to turn mute off.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setMasterVolumeMuted(content_.ComponentName admin, bool on0) =>
      _setMasterVolumeMuted(reference, admin.reference, on0 ? 1 : 0).check();

  static final _isMasterVolumeMuted = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isMasterVolumeMuted")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isMasterVolumeMuted(android.content.ComponentName admin)
  ///
  /// Called by profile or device owners to check whether the master volume mute is on or off.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return {@code true} if master volume is muted, {@code false} if it's not.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  bool isMasterVolumeMuted(content_.ComponentName admin) =>
      _isMasterVolumeMuted(reference, admin.reference).boolean;

  static final _setUninstallBlocked = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DevicePolicyManager__setUninstallBlocked")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setUninstallBlocked(android.content.ComponentName admin, java.lang.String packageName, boolean uninstallBlocked)
  ///
  /// Change whether a user can uninstall a package. This function can be called by a device owner,
  /// profile owner, or by a delegate given the \#DELEGATION_BLOCK_UNINSTALL scope via
  /// \#setDelegatedScopes.
  ///@param admin Which DeviceAdminReceiver this request is associated with, or
  ///             {@code null} if the caller is a block uninstall delegate.
  /// This value may be {@code null}.
  ///@param packageName package to change.
  ///@param uninstallBlocked true if the user shouldn't be able to uninstall the package.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_BLOCK_UNINSTALL
  void setUninstallBlocked(content_.ComponentName admin,
          jni.JniString packageName, bool uninstallBlocked) =>
      _setUninstallBlocked(reference, admin.reference, packageName.reference,
              uninstallBlocked ? 1 : 0)
          .check();

  static final _isUninstallBlocked = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isUninstallBlocked")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isUninstallBlocked(android.content.ComponentName admin, java.lang.String packageName)
  ///
  /// Check whether the user has been blocked by device policy from uninstalling a package.
  /// Requires the caller to be the profile owner if checking a specific admin's policy.
  ///
  /// <strong>Note:</strong> Starting from android.os.Build.VERSION_CODES\#LOLLIPOP_MR1, the
  /// behavior of this API is changed such that passing {@code null} as the {@code admin} parameter
  /// will return if any admin has blocked the uninstallation. Before L MR1, passing {@code null}
  /// will cause a NullPointerException to be raised.
  ///@param admin The name of the admin component whose blocking policy will be checked, or
  ///            {@code null} to check whether any admin has blocked the uninstallation.
  /// This value may be {@code null}.
  ///@param packageName package to check.
  ///@return true if uninstallation is blocked.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  bool isUninstallBlocked(
          content_.ComponentName admin, jni.JniString packageName) =>
      _isUninstallBlocked(reference, admin.reference, packageName.reference)
          .boolean;

  static final _addCrossProfileWidgetProvider = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__addCrossProfileWidgetProvider")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean addCrossProfileWidgetProvider(android.content.ComponentName admin, java.lang.String packageName)
  ///
  /// Called by the profile owner of a managed profile to enable widget providers from a given
  /// package to be available in the parent profile. As a result the user will be able to add
  /// widgets from the white-listed package running under the profile to a widget host which runs
  /// under the parent profile, for example the home screen. Note that a package may have zero or
  /// more provider components, where each component provides a different widget type.
  ///
  /// <strong>Note:</strong> By default no widget provider package is white-listed.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageName The package from which widget providers are white-listed.
  ///@return Whether the package was added.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  ///@see \#removeCrossProfileWidgetProvider(android.content.ComponentName, String)
  ///@see \#getCrossProfileWidgetProviders(android.content.ComponentName)
  bool addCrossProfileWidgetProvider(
          content_.ComponentName admin, jni.JniString packageName) =>
      _addCrossProfileWidgetProvider(
              reference, admin.reference, packageName.reference)
          .boolean;

  static final _removeCrossProfileWidgetProvider = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__removeCrossProfileWidgetProvider")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean removeCrossProfileWidgetProvider(android.content.ComponentName admin, java.lang.String packageName)
  ///
  /// Called by the profile owner of a managed profile to disable widget providers from a given
  /// package to be available in the parent profile. For this method to take effect the package
  /// should have been added via
  /// \#addCrossProfileWidgetProvider( android.content.ComponentName, String).
  ///
  /// <strong>Note:</strong> By default no widget provider package is white-listed.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageName The package from which widget providers are no longer white-listed.
  ///@return Whether the package was removed.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  ///@see \#addCrossProfileWidgetProvider(android.content.ComponentName, String)
  ///@see \#getCrossProfileWidgetProviders(android.content.ComponentName)
  bool removeCrossProfileWidgetProvider(
          content_.ComponentName admin, jni.JniString packageName) =>
      _removeCrossProfileWidgetProvider(
              reference, admin.reference, packageName.reference)
          .boolean;

  static final _getCrossProfileWidgetProviders = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getCrossProfileWidgetProviders")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<java.lang.String> getCrossProfileWidgetProviders(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by the profile owner of a managed profile to query providers from which packages are
  /// available in the parent profile.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return The white-listed package list.
  /// This value will never be {@code null}.
  ///@see \#addCrossProfileWidgetProvider(android.content.ComponentName, String)
  ///@see \#removeCrossProfileWidgetProvider(android.content.ComponentName, String)
  ///@throws SecurityException if {@code admin} is not a profile owner.
  jni.JniObject getCrossProfileWidgetProviders(content_.ComponentName admin) =>
      jni.JniObject.fromRef(
          _getCrossProfileWidgetProviders(reference, admin.reference).object);

  static final _setUserIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DevicePolicyManager__setUserIcon")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setUserIcon(android.content.ComponentName admin, android.graphics.Bitmap icon)
  ///
  /// Called by profile or device owners to set the user's photo.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param icon the bitmap to set as the photo.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setUserIcon(content_.ComponentName admin, jni.JniObject icon) =>
      _setUserIcon(reference, admin.reference, icon.reference).check();

  static final _setSystemUpdatePolicy = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setSystemUpdatePolicy")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setSystemUpdatePolicy(android.content.ComponentName admin, android.app.admin.SystemUpdatePolicy policy)
  ///
  /// Called by device owners to set a local system update policy. When a new policy is set,
  /// \#ACTION_SYSTEM_UPDATE_POLICY_CHANGED is broadcasted.
  ///
  /// If the supplied system update policy has freeze periods set but the freeze periods do not
  /// meet 90-day maximum length or 60-day minimum separation requirement set out in
  /// SystemUpdatePolicy\#setFreezePeriods,
  /// SystemUpdatePolicy.ValidationFailedException will the thrown. Note that the system
  /// keeps a record of freeze periods the device experienced previously, and combines them with
  /// the new freeze periods to be set when checking the maximum freeze length and minimum freeze
  /// separation constraints. As a result, freeze periods that passed validation during
  /// SystemUpdatePolicy\#setFreezePeriods might fail the additional checks here due to
  /// the freeze period history. If this is causing issues during development,
  /// {@code adb shell dpm clear-freeze-period-record} can be used to clear the record.
  ///@param admin Which DeviceAdminReceiver this request is associated with. All
  ///            components in the device owner package can set system update policies and the most
  ///            recent policy takes effect.
  /// This value must never be {@code null}.
  ///@param policy the new policy, or {@code null} to clear the current policy.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@throws IllegalArgumentException if the policy type or maintenance window is not valid.
  ///@throws SystemUpdatePolicy.ValidationFailedException if the policy's freeze period does not
  ///             meet the requirement.
  ///@see SystemUpdatePolicy
  ///@see SystemUpdatePolicy\#setFreezePeriods(List)
  void setSystemUpdatePolicy(
          content_.ComponentName admin, SystemUpdatePolicy policy) =>
      _setSystemUpdatePolicy(reference, admin.reference, policy.reference)
          .check();

  static final _getSystemUpdatePolicy = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getSystemUpdatePolicy")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.admin.SystemUpdatePolicy getSystemUpdatePolicy()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a local system update policy set previously by \#setSystemUpdatePolicy.
  ///@return The current policy object, or {@code null} if no policy is set.
  SystemUpdatePolicy getSystemUpdatePolicy() =>
      SystemUpdatePolicy.fromRef(_getSystemUpdatePolicy(reference).object);

  static final _setKeyguardDisabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DevicePolicyManager__setKeyguardDisabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean setKeyguardDisabled(android.content.ComponentName admin, boolean disabled)
  ///
  /// Called by a device owner or profile owner of secondary users that is affiliated with the
  /// device to disable the keyguard altogether.
  ///
  /// Setting the keyguard to disabled has the same effect as choosing "None" as the screen lock
  /// type. However, this call has no effect if a password, pin or pattern is currently set. If a
  /// password, pin or pattern is set after the keyguard was disabled, the keyguard stops being
  /// disabled.
  ///
  ///
  /// As of android.os.Build.VERSION_CODES\#P, this call also dismisses the
  /// keyguard if it is currently shown.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param disabled {@code true} disables the keyguard, {@code false} reenables it.
  ///@return {@code false} if attempting to disable the keyguard while a lock password was in
  ///         place. {@code true} otherwise.
  ///@throws SecurityException if {@code admin} is not the device owner, or a profile owner of
  /// secondary user that is affiliated with the device.
  ///@see \#isAffiliatedUser
  ///@see \#getSecondaryUsers
  bool setKeyguardDisabled(content_.ComponentName admin, bool disabled) =>
      _setKeyguardDisabled(reference, admin.reference, disabled ? 1 : 0)
          .boolean;

  static final _setStatusBarDisabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DevicePolicyManager__setStatusBarDisabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean setStatusBarDisabled(android.content.ComponentName admin, boolean disabled)
  ///
  /// Called by device owner or profile owner of secondary users  that is affiliated with the
  /// device to disable the status bar. Disabling the status bar blocks notifications, quick
  /// settings and other screen overlays that allow escaping from a single use device.
  ///
  /// <strong>Note:</strong> This method has no effect for LockTask mode. The behavior of the
  /// status bar in LockTask mode can be configured with
  /// \#setLockTaskFeatures(ComponentName, int). Calls to this method when the device is in
  /// LockTask mode will be registered, but will only take effect when the device leaves LockTask
  /// mode.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param disabled {@code true} disables the status bar, {@code false} reenables it.
  ///@return {@code false} if attempting to disable the status bar failed. {@code true} otherwise.
  ///@throws SecurityException if {@code admin} is not the device owner, or a profile owner of
  /// secondary user that is affiliated with the device.
  ///@see \#isAffiliatedUser
  ///@see \#getSecondaryUsers
  bool setStatusBarDisabled(content_.ComponentName admin, bool disabled) =>
      _setStatusBarDisabled(reference, admin.reference, disabled ? 1 : 0)
          .boolean;

  static final _getPendingSystemUpdate = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getPendingSystemUpdate")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.admin.SystemUpdateInfo getPendingSystemUpdate(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by device or profile owners to get information about a pending system update.
  ///@param admin Which profile or device owner this request is associated with.
  /// This value must never be {@code null}.
  ///@return Information about a pending system update or {@code null} if no update pending.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see DeviceAdminReceiver\#onSystemUpdatePending(Context, Intent, long)
  SystemUpdateInfo getPendingSystemUpdate(content_.ComponentName admin) =>
      SystemUpdateInfo.fromRef(
          _getPendingSystemUpdate(reference, admin.reference).object);

  static final _setPermissionPolicy = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__setPermissionPolicy")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setPermissionPolicy(android.content.ComponentName admin, int policy)
  ///
  /// Set the default response for future runtime permission requests by applications. This
  /// function can be called by a device owner, profile owner, or by a delegate given the
  /// \#DELEGATION_PERMISSION_GRANT scope via \#setDelegatedScopes.
  /// The policy can allow for normal operation which prompts the user to grant a permission, or
  /// can allow automatic granting or denying of runtime permission requests by an application.
  /// This also applies to new permissions declared by app updates. When a permission is denied or
  /// granted this way, the effect is equivalent to setting the permission * grant state via
  /// \#setPermissionGrantState.
  /// <p/>
  /// As this policy only acts on runtime permission requests, it only applies to applications
  /// built with a {@code targetSdkVersion} of android.os.Build.VERSION_CODES\#M or later.
  ///@param admin Which profile or device owner this request is associated with.
  /// This value must never be {@code null}.
  ///@param policy One of the policy constants \#PERMISSION_POLICY_PROMPT,
  ///            \#PERMISSION_POLICY_AUTO_GRANT and \#PERMISSION_POLICY_AUTO_DENY.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setPermissionGrantState
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_PERMISSION_GRANT
  void setPermissionPolicy(content_.ComponentName admin, int policy) =>
      _setPermissionPolicy(reference, admin.reference, policy).check();

  static final _getPermissionPolicy = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getPermissionPolicy")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getPermissionPolicy(android.content.ComponentName admin)
  ///
  /// Returns the current runtime permission policy set by the device or profile owner. The
  /// default is \#PERMISSION_POLICY_PROMPT.
  ///@param admin Which profile or device owner this request is associated with.
  ///@return the current policy for future permission requests.
  int getPermissionPolicy(content_.ComponentName admin) =>
      _getPermissionPolicy(reference, admin.reference).integer;

  static final _setPermissionGrantState = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__setPermissionGrantState")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean setPermissionGrantState(android.content.ComponentName admin, java.lang.String packageName, java.lang.String permission, int grantState)
  ///
  /// Sets the grant state of a runtime permission for a specific application. The state can be
  /// \#PERMISSION_GRANT_STATE_DEFAULT default in which a user can manage it through the UI,
  /// \#PERMISSION_GRANT_STATE_DENIED denied, in which the permission is denied and the user
  /// cannot manage it through the UI, and \#PERMISSION_GRANT_STATE_GRANTED granted in which
  /// the permission is granted and the user cannot manage it through the UI. This method can only
  /// be called by a profile owner, device owner, or a delegate given the
  /// \#DELEGATION_PERMISSION_GRANT scope via \#setDelegatedScopes.
  /// <p/>
  /// Note that user cannot manage other permissions in the affected group through the UI
  /// either and their granted state will be kept as the current value. Thus, it's recommended that
  /// you set the grant state of all the permissions in the affected group.
  /// <p/>
  /// Setting the grant state to \#PERMISSION_GRANT_STATE_DEFAULT default does not revoke
  /// the permission. It retains the previous grant, if any.
  /// <p/>
  /// Permissions can be granted or revoked only for applications built with a
  /// {@code targetSdkVersion} of android.os.Build.VERSION_CODES\#M or later.
  ///@param admin Which profile or device owner this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageName The application to grant or revoke a permission to.
  ///@param permission The permission to grant or revoke.
  ///@param grantState The permission grant state which is one of
  ///            \#PERMISSION_GRANT_STATE_DENIED, \#PERMISSION_GRANT_STATE_DEFAULT,
  ///            \#PERMISSION_GRANT_STATE_GRANTED,
  ///@return whether the permission was successfully granted or revoked.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#PERMISSION_GRANT_STATE_DENIED
  ///@see \#PERMISSION_GRANT_STATE_DEFAULT
  ///@see \#PERMISSION_GRANT_STATE_GRANTED
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_PERMISSION_GRANT
  bool setPermissionGrantState(
          content_.ComponentName admin,
          jni.JniString packageName,
          jni.JniString permission,
          int grantState) =>
      _setPermissionGrantState(reference, admin.reference,
              packageName.reference, permission.reference, grantState)
          .boolean;

  static final _getPermissionGrantState = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getPermissionGrantState")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getPermissionGrantState(android.content.ComponentName admin, java.lang.String packageName, java.lang.String permission)
  ///
  /// Returns the current grant state of a runtime permission for a specific application. This
  /// function can be called by a device owner, profile owner, or by a delegate given the
  /// \#DELEGATION_PERMISSION_GRANT scope via \#setDelegatedScopes.
  ///@param admin Which profile or device owner this request is associated with, or {@code null}
  ///            if the caller is a permission grant delegate.
  /// This value may be {@code null}.
  ///@param packageName The application to check the grant state for.
  ///@param permission The permission to check for.
  ///@return the current grant state specified by device policy. If the profile or device owner
  ///         has not set a grant state, the return value is
  ///         \#PERMISSION_GRANT_STATE_DEFAULT. This does not indicate whether or not the
  ///         permission is currently granted for the package.
  ///         <p/>
  ///         If a grant state was set by the profile or device owner, then the return value will
  ///         be one of \#PERMISSION_GRANT_STATE_DENIED or
  ///         \#PERMISSION_GRANT_STATE_GRANTED, which indicates if the permission is
  ///         currently denied or granted.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  ///@see \#setPermissionGrantState(ComponentName, String, String, int)
  ///@see PackageManager\#checkPermission(String, String)
  ///@see \#setDelegatedScopes
  ///@see \#DELEGATION_PERMISSION_GRANT
  int getPermissionGrantState(content_.ComponentName admin,
          jni.JniString packageName, jni.JniString permission) =>
      _getPermissionGrantState(reference, admin.reference,
              packageName.reference, permission.reference)
          .integer;

  static final _isProvisioningAllowed = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isProvisioningAllowed")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isProvisioningAllowed(java.lang.String action)
  ///
  /// Returns whether it is possible for the caller to initiate provisioning of a managed profile
  /// or device, setting itself as the device or profile owner.
  ///@param action One of \#ACTION_PROVISION_MANAGED_DEVICE,
  /// \#ACTION_PROVISION_MANAGED_PROFILE.
  /// This value must never be {@code null}.
  ///@return whether provisioning a managed profile or device is possible.
  ///@throws IllegalArgumentException if the supplied action is not valid.
  bool isProvisioningAllowed(jni.JniString action) =>
      _isProvisioningAllowed(reference, action.reference).boolean;

  static final _isManagedProfile = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isManagedProfile")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isManagedProfile(android.content.ComponentName admin)
  ///
  /// Return if this user is a managed profile of another user. An admin can become the profile
  /// owner of a managed profile with \#ACTION_PROVISION_MANAGED_PROFILE and of a managed
  /// user with \#createAndManageUser
  ///@param admin Which profile owner this request is associated with.
  /// This value must never be {@code null}.
  ///@return if this user is a managed profile of another user.
  bool isManagedProfile(content_.ComponentName admin) =>
      _isManagedProfile(reference, admin.reference).boolean;

  static final _getWifiMacAddress = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getWifiMacAddress")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getWifiMacAddress(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by device owner to get the MAC address of the Wi-Fi device.
  ///@param admin Which device owner this request is associated with.
  /// This value must never be {@code null}.
  ///@return the MAC address of the Wi-Fi device, or null when the information is not available.
  ///         (For example, Wi-Fi hasn't been enabled, or the device doesn't support Wi-Fi.)
  ///
  ///         The address will be in the {@code XX:XX:XX:XX:XX:XX} format.
  ///@throws SecurityException if {@code admin} is not a device owner.
  jni.JniString getWifiMacAddress(content_.ComponentName admin) =>
      jni.JniString.fromRef(
          _getWifiMacAddress(reference, admin.reference).object);

  static final _reboot = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DevicePolicyManager__reboot")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void reboot(android.content.ComponentName admin)
  ///
  /// Called by device owner to reboot the device. If there is an ongoing call on the device,
  /// throws an IllegalStateException.
  ///@param admin Which device owner the request is associated with.
  /// This value must never be {@code null}.
  ///@throws IllegalStateException if device has an ongoing call.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see TelephonyManager\#CALL_STATE_IDLE
  void reboot(content_.ComponentName admin) =>
      _reboot(reference, admin.reference).check();

  static final _setShortSupportMessage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setShortSupportMessage")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setShortSupportMessage(android.content.ComponentName admin, java.lang.CharSequence message)
  ///
  /// Called by a device admin to set the short support message. This will be displayed to the user
  /// in settings screens where funtionality has been disabled by the admin. The message should be
  /// limited to a short statement such as "This setting is disabled by your administrator. Contact
  /// someone@example.com for support." If the message is longer than 200 characters it may be
  /// truncated.
  ///
  /// If the short support message needs to be localized, it is the responsibility of the
  /// DeviceAdminReceiver to listen to the Intent\#ACTION_LOCALE_CHANGED broadcast
  /// and set a new version of this string accordingly.
  ///@see \#setLongSupportMessage
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param message Short message to be displayed to the user in settings or null to clear the
  ///            existing message.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not an active administrator.
  void setShortSupportMessage(
          content_.ComponentName admin, jni.JniObject message) =>
      _setShortSupportMessage(reference, admin.reference, message.reference)
          .check();

  static final _getShortSupportMessage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getShortSupportMessage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getShortSupportMessage(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a device admin to get the short support message.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return The message set by \#setShortSupportMessage(ComponentName, CharSequence) or
  ///         null if no message has been set.
  ///@throws SecurityException if {@code admin} is not an active administrator.
  jni.JniObject getShortSupportMessage(content_.ComponentName admin) =>
      jni.JniObject.fromRef(
          _getShortSupportMessage(reference, admin.reference).object);

  static final _setLongSupportMessage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setLongSupportMessage")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setLongSupportMessage(android.content.ComponentName admin, java.lang.CharSequence message)
  ///
  /// Called by a device admin to set the long support message. This will be displayed to the user
  /// in the device administators settings screen.
  ///
  /// If the long support message needs to be localized, it is the responsibility of the
  /// DeviceAdminReceiver to listen to the Intent\#ACTION_LOCALE_CHANGED broadcast
  /// and set a new version of this string accordingly.
  ///@see \#setShortSupportMessage
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param message Long message to be displayed to the user in settings or null to clear the
  ///            existing message.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not an active administrator.
  void setLongSupportMessage(
          content_.ComponentName admin, jni.JniObject message) =>
      _setLongSupportMessage(reference, admin.reference, message.reference)
          .check();

  static final _getLongSupportMessage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getLongSupportMessage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getLongSupportMessage(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a device admin to get the long support message.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return The message set by \#setLongSupportMessage(ComponentName, CharSequence) or
  ///         null if no message has been set.
  ///@throws SecurityException if {@code admin} is not an active administrator.
  jni.JniObject getLongSupportMessage(content_.ComponentName admin) =>
      jni.JniObject.fromRef(
          _getLongSupportMessage(reference, admin.reference).object);

  static final _getParentProfileInstance = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getParentProfileInstance")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.admin.DevicePolicyManager getParentProfileInstance(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by the profile owner of a managed profile to obtain a DevicePolicyManager
  /// whose calls act on the parent profile.
  ///
  /// The following methods are supported for the parent instance, all other methods will
  /// throw a SecurityException when called on the parent instance:
  /// <ul>
  /// <li>\#getPasswordQuality</li>
  /// <li>\#setPasswordQuality</li>
  /// <li>\#getPasswordMinimumLength</li>
  /// <li>\#setPasswordMinimumLength</li>
  /// <li>\#getPasswordMinimumUpperCase</li>
  /// <li>\#setPasswordMinimumUpperCase</li>
  /// <li>\#getPasswordMinimumLowerCase</li>
  /// <li>\#setPasswordMinimumLowerCase</li>
  /// <li>\#getPasswordMinimumLetters</li>
  /// <li>\#setPasswordMinimumLetters</li>
  /// <li>\#getPasswordMinimumNumeric</li>
  /// <li>\#setPasswordMinimumNumeric</li>
  /// <li>\#getPasswordMinimumSymbols</li>
  /// <li>\#setPasswordMinimumSymbols</li>
  /// <li>\#getPasswordMinimumNonLetter</li>
  /// <li>\#setPasswordMinimumNonLetter</li>
  /// <li>\#getPasswordHistoryLength</li>
  /// <li>\#setPasswordHistoryLength</li>
  /// <li>\#getPasswordExpirationTimeout</li>
  /// <li>\#setPasswordExpirationTimeout</li>
  /// <li>\#getPasswordExpiration</li>
  /// <li>\#getPasswordMaximumLength</li>
  /// <li>\#isActivePasswordSufficient</li>
  /// <li>\#getCurrentFailedPasswordAttempts</li>
  /// <li>\#getMaximumFailedPasswordsForWipe</li>
  /// <li>\#setMaximumFailedPasswordsForWipe</li>
  /// <li>\#getMaximumTimeToLock</li>
  /// <li>\#setMaximumTimeToLock</li>
  /// <li>\#lockNow</li>
  /// <li>\#getKeyguardDisabledFeatures</li>
  /// <li>\#setKeyguardDisabledFeatures</li>
  /// <li>\#getTrustAgentConfiguration</li>
  /// <li>\#setTrustAgentConfiguration</li>
  /// <li>\#getRequiredStrongAuthTimeout</li>
  /// <li>\#setRequiredStrongAuthTimeout</li>
  /// </ul>
  ///@param admin This value must never be {@code null}.
  ///@return a new instance of DevicePolicyManager that acts on the parent profile.
  /// This value will never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  DevicePolicyManager getParentProfileInstance(content_.ComponentName admin) =>
      DevicePolicyManager.fromRef(
          _getParentProfileInstance(reference, admin.reference).object);

  static final _setSecurityLoggingEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DevicePolicyManager__setSecurityLoggingEnabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setSecurityLoggingEnabled(android.content.ComponentName admin, boolean enabled)
  ///
  /// Called by device owner to control the security logging feature.
  ///
  ///  Security logs contain various information intended for security auditing purposes.
  /// See SecurityEvent for details.
  ///
  /// <strong>Note:</strong> The device owner won't be able to retrieve security logs if there
  /// are unaffiliated secondary users or profiles on the device, regardless of whether the
  /// feature is enabled. Logs will be discarded if the internal buffer fills up while waiting for
  /// all users to become affiliated. Therefore it's recommended that affiliation ids are set for
  /// new users as soon as possible after provisioning via \#setAffiliationIds.
  ///@param admin Which device owner this request is associated with.
  /// This value must never be {@code null}.
  ///@param enabled whether security logging should be enabled or not.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#setAffiliationIds
  ///@see \#retrieveSecurityLogs
  void setSecurityLoggingEnabled(content_.ComponentName admin, bool enabled) =>
      _setSecurityLoggingEnabled(reference, admin.reference, enabled ? 1 : 0)
          .check();

  static final _isSecurityLoggingEnabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isSecurityLoggingEnabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isSecurityLoggingEnabled(android.content.ComponentName admin)
  ///
  /// Return whether security logging is enabled or not by the device owner.
  ///
  /// Can only be called by the device owner, otherwise a SecurityException will be
  /// thrown.
  ///@param admin Which device owner this request is associated with.
  /// This value may be {@code null}.
  ///@return {@code true} if security logging is enabled by device owner, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not a device owner.
  bool isSecurityLoggingEnabled(content_.ComponentName admin) =>
      _isSecurityLoggingEnabled(reference, admin.reference).boolean;

  static final _retrieveSecurityLogs = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__retrieveSecurityLogs")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.admin.SecurityLog.SecurityEvent> retrieveSecurityLogs(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by device owner to retrieve all new security logging entries since the last call to
  /// this API after device boots.
  ///
  ///  Access to the logs is rate limited and it will only return new logs after the device
  /// owner has been notified via DeviceAdminReceiver\#onSecurityLogsAvailable.
  ///
  /// If there is any other user or profile on the device, it must be affiliated with the
  /// device. Otherwise a SecurityException will be thrown. See \#isAffiliatedUser.
  ///@param admin Which device owner this request is associated with.
  /// This value must never be {@code null}.
  ///@return the new batch of security logs which is a list of SecurityEvent,
  /// or {@code null} if rate limitation is exceeded or if logging is currently disabled.
  ///@throws SecurityException if {@code admin} is not a device owner, or there is at least one
  /// profile or secondary user that is not affiliated with the device.
  ///@see \#isAffiliatedUser
  ///@see DeviceAdminReceiver\#onSecurityLogsAvailable
  jni.JniObject retrieveSecurityLogs(content_.ComponentName admin) =>
      jni.JniObject.fromRef(
          _retrieveSecurityLogs(reference, admin.reference).object);

  static final _setMeteredDataDisabledPackages = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setMeteredDataDisabledPackages")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<java.lang.String> setMeteredDataDisabledPackages(android.content.ComponentName admin, java.util.List<java.lang.String> packageNames)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a device or profile owner to restrict packages from using metered data.
  ///@param admin which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageNames the list of package names to be restricted.
  /// This value must never be {@code null}.
  ///@return a list of package names which could not be restricted.
  /// This value will never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  jni.JniObject setMeteredDataDisabledPackages(
          content_.ComponentName admin, jni.JniObject packageNames) =>
      jni.JniObject.fromRef(_setMeteredDataDisabledPackages(
              reference, admin.reference, packageNames.reference)
          .object);

  static final _getMeteredDataDisabledPackages = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getMeteredDataDisabledPackages")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<java.lang.String> getMeteredDataDisabledPackages(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a device or profile owner to retrieve the list of packages which are restricted
  /// by the admin from using metered data.
  ///@param admin which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return the list of restricted package names.
  /// This value will never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  jni.JniObject getMeteredDataDisabledPackages(content_.ComponentName admin) =>
      jni.JniObject.fromRef(
          _getMeteredDataDisabledPackages(reference, admin.reference).object);

  static final _retrievePreRebootSecurityLogs = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__retrievePreRebootSecurityLogs")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.admin.SecurityLog.SecurityEvent> retrievePreRebootSecurityLogs(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by device owners to retrieve device logs from before the device's last reboot.
  ///
  /// <strong> This API is not supported on all devices. Calling this API on unsupported devices
  /// will result in {@code null} being returned. The device logs are retrieved from a RAM region
  /// which is not guaranteed to be corruption-free during power cycles, as a result be cautious
  /// about data corruption when parsing. </strong>
  ///
  /// If there is any other user or profile on the device, it must be affiliated with the
  /// device. Otherwise a SecurityException will be thrown. See \#isAffiliatedUser.
  ///@param admin Which device owner this request is associated with.
  /// This value must never be {@code null}.
  ///@return Device logs from before the latest reboot of the system, or {@code null} if this API
  ///         is not supported on the device.
  ///@throws SecurityException if {@code admin} is not a device owner, or there is at least one
  /// profile or secondary user that is not affiliated with the device.
  ///@see \#isAffiliatedUser
  ///@see \#retrieveSecurityLogs
  jni.JniObject retrievePreRebootSecurityLogs(content_.ComponentName admin) =>
      jni.JniObject.fromRef(
          _retrievePreRebootSecurityLogs(reference, admin.reference).object);

  static final _setOrganizationColor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__setOrganizationColor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setOrganizationColor(android.content.ComponentName admin, int color)
  ///
  /// Called by a profile owner of a managed profile to set the color used for customization. This
  /// color is used as background color of the confirm credentials screen for that user. The
  /// default color is teal (\#00796B).
  ///
  /// The confirm credentials screen can be created using
  /// android.app.KeyguardManager\#createConfirmDeviceCredentialIntent.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param color The 24bit (0xRRGGBB) representation of the color to be used.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  void setOrganizationColor(content_.ComponentName admin, int color) =>
      _setOrganizationColor(reference, admin.reference, color).check();

  static final _getOrganizationColor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getOrganizationColor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getOrganizationColor(android.content.ComponentName admin)
  ///
  /// Called by a profile owner of a managed profile to retrieve the color used for customization.
  /// This color is used as background color of the confirm credentials screen for that user.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return The 24bit (0xRRGGBB) representation of the color to be used.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  int getOrganizationColor(content_.ComponentName admin) =>
      _getOrganizationColor(reference, admin.reference).integer;

  static final _setOrganizationName = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setOrganizationName")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setOrganizationName(android.content.ComponentName admin, java.lang.CharSequence title)
  ///
  /// Called by the device owner (since API 26) or profile owner (since API 24) to set the name of
  /// the organization under management.
  ///
  /// If the organization name needs to be localized, it is the responsibility of the DeviceAdminReceiver to listen to the Intent\#ACTION_LOCALE_CHANGED broadcast and set
  /// a new version of this string accordingly.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param title The organization name or {@code null} to clear a previously set name.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device or profile owner.
  void setOrganizationName(content_.ComponentName admin, jni.JniObject title) =>
      _setOrganizationName(reference, admin.reference, title.reference).check();

  static final _getOrganizationName = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getOrganizationName")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getOrganizationName(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a profile owner of a managed profile to retrieve the name of the organization under
  /// management.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@return The organization name or {@code null} if none is set.
  ///@throws SecurityException if {@code admin} is not a profile owner.
  jni.JniObject getOrganizationName(content_.ComponentName admin) =>
      jni.JniObject.fromRef(
          _getOrganizationName(reference, admin.reference).object);

  static final _setAffiliationIds = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setAffiliationIds")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setAffiliationIds(android.content.ComponentName admin, java.util.Set<java.lang.String> ids)
  ///
  /// Indicates the entity that controls the device or profile owner. Two users/profiles are
  /// affiliated if the set of ids set by their device or profile owners intersect.
  ///
  /// A user/profile that is affiliated with the device owner user is considered to be
  /// affiliated with the device.
  ///
  /// <strong>Note:</strong> Features that depend on user affiliation (such as security logging
  /// or \#bindDeviceAdminServiceAsUser) won't be available when a secondary user or profile
  /// is created, until it becomes affiliated. Therefore it is recommended that the appropriate
  /// affiliation ids are set by its profile owner as soon as possible after the user/profile is
  /// created.
  ///@param admin Which profile or device owner this request is associated with.
  /// This value must never be {@code null}.
  ///@param ids A set of opaque non-empty affiliation ids.
  ///
  /// This value must never be {@code null}.
  ///@throws IllegalArgumentException if {@code ids} is null or contains an empty string.
  ///@see \#isAffiliatedUser
  void setAffiliationIds(content_.ComponentName admin, jni.JniObject ids) =>
      _setAffiliationIds(reference, admin.reference, ids.reference).check();

  static final _getAffiliationIds = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getAffiliationIds")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Set<java.lang.String> getAffiliationIds(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the set of affiliation ids previously set via \#setAffiliationIds, or an
  /// empty set if none have been set.
  ///@param admin This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  jni.JniObject getAffiliationIds(content_.ComponentName admin) =>
      jni.JniObject.fromRef(
          _getAffiliationIds(reference, admin.reference).object);

  static final _isAffiliatedUser = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isAffiliatedUser")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isAffiliatedUser()
  ///
  /// Returns whether this user/profile is affiliated with the device.
  ///
  /// By definition, the user that the device owner runs on is always affiliated with the device.
  /// Any other user/profile is considered affiliated with the device if the set specified by its
  /// profile owner via \#setAffiliationIds intersects with the device owner's.
  ///@see \#setAffiliationIds
  bool isAffiliatedUser() => _isAffiliatedUser(reference).boolean;

  static final _setBackupServiceEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DevicePolicyManager__setBackupServiceEnabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setBackupServiceEnabled(android.content.ComponentName admin, boolean enabled)
  ///
  /// Allows the device owner to enable or disable the backup service.
  ///
  ///  Backup service manages all backup and restore mechanisms on the device. Setting this to
  /// false will prevent data from being backed up or restored.
  ///
  ///  Backup service is off by default when device owner is present.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param enabled {@code true} to enable the backup service, {@code false} to disable it.
  ///@throws SecurityException if {@code admin} is not a device owner.
  void setBackupServiceEnabled(content_.ComponentName admin, bool enabled) =>
      _setBackupServiceEnabled(reference, admin.reference, enabled ? 1 : 0)
          .check();

  static final _isBackupServiceEnabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isBackupServiceEnabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isBackupServiceEnabled(android.content.ComponentName admin)
  ///
  /// Return whether the backup service is enabled by the device owner.
  ///
  ///  Backup service manages all backup and restore mechanisms on the device.
  ///@param admin This value must never be {@code null}.
  ///@return {@code true} if backup service is enabled, {@code false} otherwise.
  ///@see \#setBackupServiceEnabled
  bool isBackupServiceEnabled(content_.ComponentName admin) =>
      _isBackupServiceEnabled(reference, admin.reference).boolean;

  static final _setNetworkLoggingEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DevicePolicyManager__setNetworkLoggingEnabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setNetworkLoggingEnabled(android.content.ComponentName admin, boolean enabled)
  ///
  /// Called by a device owner to control the network logging feature.
  ///
  ///  Network logs contain DNS lookup and connect() library call events. The following library
  ///     functions are recorded while network logging is active:
  ///     <ul>
  ///       <li>{@code getaddrinfo()}</li>
  ///       <li>{@code gethostbyname()}</li>
  ///       <li>{@code connect()}</li>
  ///     </ul>
  ///
  ///  Network logging is a low-overhead tool for forensics but it is not guaranteed to use
  ///     full system call logging; event reporting is enabled by default for all processes but not
  ///     strongly enforced.
  ///     Events from applications using alternative implementations of libc, making direct kernel
  ///     calls, or deliberately obfuscating traffic may not be recorded.
  ///
  ///  Some common network events may not be reported. For example:
  ///     <ul>
  ///       <li>Applications may hardcode IP addresses to reduce the number of DNS lookups, or use
  ///           an alternative system for name resolution, and so avoid calling
  ///           {@code getaddrinfo()} or {@code gethostbyname}.</li>
  ///       <li>Applications may use datagram sockets for performance reasons, for example
  ///           for a game client. Calling {@code connect()} is unnecessary for this kind of
  ///           socket, so it will not trigger a network event.</li>
  ///     </ul>
  ///
  ///  It is possible to directly intercept layer 3 traffic leaving the device using an
  ///     always-on VPN service.
  ///     See \#setAlwaysOnVpnPackage(ComponentName, String, boolean)
  ///     and android.net.VpnService for details.
  ///
  /// <strong>Note:</strong> The device owner won't be able to retrieve network logs if there
  /// are unaffiliated secondary users or profiles on the device, regardless of whether the
  /// feature is enabled. Logs will be discarded if the internal buffer fills up while waiting for
  /// all users to become affiliated. Therefore it's recommended that affiliation ids are set for
  /// new users as soon as possible after provisioning via \#setAffiliationIds.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param enabled whether network logging should be enabled or not.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#setAffiliationIds
  ///@see \#retrieveNetworkLogs
  void setNetworkLoggingEnabled(content_.ComponentName admin, bool enabled) =>
      _setNetworkLoggingEnabled(reference, admin.reference, enabled ? 1 : 0)
          .check();

  static final _isNetworkLoggingEnabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isNetworkLoggingEnabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isNetworkLoggingEnabled(android.content.ComponentName admin)
  ///
  /// Return whether network logging is enabled by a device owner.
  ///@param admin Which DeviceAdminReceiver this request is associated with. Can only
  /// be {@code null} if the caller has MANAGE_USERS permission.
  /// This value may be {@code null}.
  ///@return {@code true} if network logging is enabled by device owner, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not a device owner and caller has
  /// no MANAGE_USERS permission
  bool isNetworkLoggingEnabled(content_.ComponentName admin) =>
      _isNetworkLoggingEnabled(reference, admin.reference).boolean;

  static final _retrieveNetworkLogs = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("DevicePolicyManager__retrieveNetworkLogs")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.util.List<android.app.admin.NetworkEvent> retrieveNetworkLogs(android.content.ComponentName admin, long batchToken)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by device owner to retrieve the most recent batch of network logging events.
  /// A device owner has to provide a batchToken provided as part of
  /// DeviceAdminReceiver\#onNetworkLogsAvailable callback. If the token doesn't match the
  /// token of the most recent available batch of logs, {@code null} will be returned.
  ///
  ///  NetworkEvent can be one of DnsEvent or ConnectEvent.
  ///
  ///  The list of network events is sorted chronologically, and contains at most 1200 events.
  ///
  ///  Access to the logs is rate limited and this method will only return a new batch of logs
  /// after the device device owner has been notified via
  /// DeviceAdminReceiver\#onNetworkLogsAvailable.
  ///
  /// If a secondary user or profile is created, calling this method will throw a
  /// SecurityException until all users become affiliated again. It will also no longer be
  /// possible to retrieve the network logs batch with the most recent batchToken provided
  /// by DeviceAdminReceiver\#onNetworkLogsAvailable. See
  /// DevicePolicyManager\#setAffiliationIds.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param batchToken A token of the batch to retrieve
  ///@return A new batch of network logs which is a list of NetworkEvent. Returns
  ///        {@code null} if the batch represented by batchToken is no longer available or if
  ///        logging is disabled.
  ///@throws SecurityException if {@code admin} is not a device owner, or there is at least one
  /// profile or secondary user that is not affiliated with the device.
  ///@see \#setAffiliationIds
  ///@see DeviceAdminReceiver\#onNetworkLogsAvailable
  jni.JniObject retrieveNetworkLogs(
          content_.ComponentName admin, int batchToken) =>
      jni.JniObject.fromRef(
          _retrieveNetworkLogs(reference, admin.reference, batchToken).object);

  static final _bindDeviceAdminServiceAsUser = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__bindDeviceAdminServiceAsUser")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean bindDeviceAdminServiceAsUser(android.content.ComponentName admin, android.content.Intent serviceIntent, android.content.ServiceConnection conn, int flags, android.os.UserHandle targetUser)
  ///
  /// Called by a device owner to bind to a service from a profile owner or vice versa.
  /// See \#getBindDeviceAdminTargetUsers for a definition of which
  /// device/profile owners are allowed to bind to services of another profile/device owner.
  ///
  /// The service must be protected by android.Manifest.permission\#BIND_DEVICE_ADMIN.
  /// Note that the Context used to obtain this
  /// DevicePolicyManager instance via Context\#getSystemService(Class) will be used
  /// to bind to the android.app.Service.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param serviceIntent Identifies the service to connect to.  The Intent must specify either an
  ///        explicit component name or a package name to match an
  ///        IntentFilter published by a service.
  ///@param conn Receives information as the service is started and stopped in main thread. This
  ///        must be a valid ServiceConnection object; it must not be {@code null}.
  /// This value must never be {@code null}.
  ///@param flags Operation options for the binding operation. See
  ///        Context\#bindService(Intent, ServiceConnection, int).
  /// Value is either <code>0</code> or a combination of android.content.Context\#BIND_AUTO_CREATE, android.content.Context\#BIND_DEBUG_UNBIND, android.content.Context\#BIND_NOT_FOREGROUND, android.content.Context\#BIND_ABOVE_CLIENT, android.content.Context\#BIND_ALLOW_OOM_MANAGEMENT, android.content.Context\#BIND_WAIVE_PRIORITY, android.content.Context\#BIND_IMPORTANT, and android.content.Context\#BIND_ADJUST_WITH_ACTIVITY
  ///@param targetUser Which user to bind to. Must be one of the users returned by
  ///        \#getBindDeviceAdminTargetUsers, otherwise a SecurityException will
  ///        be thrown.
  /// This value must never be {@code null}.
  ///@return If you have successfully bound to the service, {@code true} is returned;
  ///         {@code false} is returned if the connection is not made and you will not
  ///         receive the service object.
  ///@see Context\#bindService(Intent, ServiceConnection, int)
  ///@see \#getBindDeviceAdminTargetUsers(ComponentName)
  bool bindDeviceAdminServiceAsUser(
          content_.ComponentName admin,
          content_.Intent serviceIntent,
          content_.ServiceConnection conn,
          int flags,
          os_.UserHandle targetUser) =>
      _bindDeviceAdminServiceAsUser(
              reference,
              admin.reference,
              serviceIntent.reference,
              conn.reference,
              flags,
              targetUser.reference)
          .boolean;

  static final _getBindDeviceAdminTargetUsers = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getBindDeviceAdminTargetUsers")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.os.UserHandle> getBindDeviceAdminTargetUsers(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of target users that the calling device or profile owner can use when
  /// calling \#bindDeviceAdminServiceAsUser.
  ///
  /// A device owner can bind to a service from a profile owner and vice versa, provided that:
  /// <ul>
  /// <li>Both belong to the same package name.
  /// <li>Both users are affiliated. See \#setAffiliationIds.
  /// </ul>
  ///@param admin This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  jni.JniObject getBindDeviceAdminTargetUsers(content_.ComponentName admin) =>
      jni.JniObject.fromRef(
          _getBindDeviceAdminTargetUsers(reference, admin.reference).object);

  static final _clearApplicationUserData = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__clearApplicationUserData")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void clearApplicationUserData(android.content.ComponentName admin, java.lang.String packageName, java.util.concurrent.Executor executor, android.app.admin.DevicePolicyManager.OnClearApplicationUserDataListener listener)
  ///
  /// Called by the device owner or profile owner to clear application user data of a given
  /// package. The behaviour of this is equivalent to the target application calling
  /// android.app.ActivityManager\#clearApplicationUserData().
  ///
  /// <strong>Note:</strong> an application can store data outside of its application data, e.g.
  /// external storage or user dictionary. This data will not be wiped by calling this API.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param packageName The name of the package which will have its user data wiped.
  /// This value must never be {@code null}.
  ///@param executor The executor through which the listener should be invoked.
  /// This value must never be {@code null}.
  /// Callback and listener events are dispatched through this
  ///  *           Executor, providing an easy way to control which thread is
  ///  *           used. To dispatch events through the main thread of your
  ///  *           application, you can use Context\#getMainExecutor(). To
  ///  *           dispatch events through a shared thread pool, you can use
  ///  *           AsyncTask\#THREAD_POOL_EXECUTOR.
  ///@param listener A callback object that will inform the caller when the clearing is done.
  /// This value must never be {@code null}.
  ///@throws SecurityException if the caller is not the device owner/profile owner.
  void clearApplicationUserData(
          content_.ComponentName admin,
          jni.JniString packageName,
          jni.JniObject executor,
          DevicePolicyManager_OnClearApplicationUserDataListener listener) =>
      _clearApplicationUserData(reference, admin.reference,
              packageName.reference, executor.reference, listener.reference)
          .check();

  static final _setLogoutEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DevicePolicyManager__setLogoutEnabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setLogoutEnabled(android.content.ComponentName admin, boolean enabled)
  ///
  /// Called by a device owner to specify whether logout is enabled for all secondary users. The
  /// system may show a logout button that stops the user and switches back to the primary user.
  ///@param admin Which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param enabled whether logout should be enabled or not.
  ///@throws SecurityException if {@code admin} is not a device owner.
  void setLogoutEnabled(content_.ComponentName admin, bool enabled) =>
      _setLogoutEnabled(reference, admin.reference, enabled ? 1 : 0).check();

  static final _isLogoutEnabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isLogoutEnabled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isLogoutEnabled()
  ///
  /// Returns whether logout is enabled by a device owner.
  ///@return {@code true} if logout is enabled by device owner, {@code false} otherwise.
  bool isLogoutEnabled() => _isLogoutEnabled(reference).boolean;

  static final _transferOwnership = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__transferOwnership")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void transferOwnership(android.content.ComponentName admin, android.content.ComponentName target, android.os.PersistableBundle bundle)
  ///
  /// Changes the current administrator to another one. All policies from the current
  /// administrator are migrated to the new administrator. The whole operation is atomic -
  /// the transfer is either complete or not done at all.
  ///
  /// Depending on the current administrator (device owner, profile owner), you have the
  /// following expected behaviour:
  /// <ul>
  ///     <li>A device owner can only be transferred to a new device owner</li>
  ///     <li>A profile owner can only be transferred to a new profile owner</li>
  /// </ul>
  ///
  /// Use the {@code bundle} parameter to pass data to the new administrator. The data
  /// will be received in the
  /// DeviceAdminReceiver\#onTransferOwnershipComplete(Context, PersistableBundle)
  /// callback of the new administrator.
  ///
  /// The transfer has failed if the original administrator is still the corresponding owner
  /// after calling this method.
  ///
  /// The incoming target administrator must have the
  /// <code>&lt;support-transfer-ownership /&gt;</code> tag inside the
  /// <code>&lt;device-admin&gt;&lt;/device-admin&gt;</code> tags in the xml file referenced by
  /// DeviceAdminReceiver\#DEVICE_ADMIN_META_DATA. Otherwise an
  /// IllegalArgumentException will be thrown.
  ///@param admin which DeviceAdminReceiver this request is associated with
  /// This value must never be {@code null}.
  ///@param target which DeviceAdminReceiver we want the new administrator to be
  /// This value must never be {@code null}.
  ///@param bundle data to be sent to the new administrator
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device owner nor a profile owner
  ///@throws IllegalArgumentException if {@code admin} or {@code target} is {@code null}, they
  /// are components in the same package or {@code target} is not an active admin
  void transferOwnership(content_.ComponentName admin,
          content_.ComponentName target, os_.PersistableBundle bundle) =>
      _transferOwnership(
              reference, admin.reference, target.reference, bundle.reference)
          .check();

  static final _setStartUserSessionMessage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setStartUserSessionMessage")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setStartUserSessionMessage(android.content.ComponentName admin, java.lang.CharSequence startUserSessionMessage)
  ///
  /// Called by a device owner to specify the user session start message. This may be displayed
  /// during a user switch.
  ///
  /// The message should be limited to a short statement or it may be truncated.
  ///
  /// If the message needs to be localized, it is the responsibility of the
  /// DeviceAdminReceiver to listen to the Intent\#ACTION_LOCALE_CHANGED broadcast
  /// and set a new version of this message accordingly.
  ///@param admin which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param startUserSessionMessage message for starting user session, or {@code null} to use
  /// system default message.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device owner.
  void setStartUserSessionMessage(content_.ComponentName admin,
          jni.JniObject startUserSessionMessage) =>
      _setStartUserSessionMessage(
              reference, admin.reference, startUserSessionMessage.reference)
          .check();

  static final _setEndUserSessionMessage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__setEndUserSessionMessage")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setEndUserSessionMessage(android.content.ComponentName admin, java.lang.CharSequence endUserSessionMessage)
  ///
  /// Called by a device owner to specify the user session end message. This may be displayed
  /// during a user switch.
  ///
  /// The message should be limited to a short statement or it may be truncated.
  ///
  /// If the message needs to be localized, it is the responsibility of the
  /// DeviceAdminReceiver to listen to the Intent\#ACTION_LOCALE_CHANGED broadcast
  /// and set a new version of this message accordingly.
  ///@param admin which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@param endUserSessionMessage message for ending user session, or {@code null} to use system
  /// default message.
  /// This value may be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device owner.
  void setEndUserSessionMessage(
          content_.ComponentName admin, jni.JniObject endUserSessionMessage) =>
      _setEndUserSessionMessage(
              reference, admin.reference, endUserSessionMessage.reference)
          .check();

  static final _getStartUserSessionMessage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getStartUserSessionMessage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getStartUserSessionMessage(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the user session start message.
  ///@param admin which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device owner.
  jni.JniObject getStartUserSessionMessage(content_.ComponentName admin) =>
      jni.JniObject.fromRef(
          _getStartUserSessionMessage(reference, admin.reference).object);

  static final _getEndUserSessionMessage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getEndUserSessionMessage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getEndUserSessionMessage(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the user session end message.
  ///@param admin which DeviceAdminReceiver this request is associated with.
  /// This value must never be {@code null}.
  ///@throws SecurityException if {@code admin} is not a device owner.
  jni.JniObject getEndUserSessionMessage(content_.ComponentName admin) =>
      jni.JniObject.fromRef(
          _getEndUserSessionMessage(reference, admin.reference).object);

  static final _addOverrideApn = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__addOverrideApn")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int addOverrideApn(android.content.ComponentName admin, android.telephony.data.ApnSetting apnSetting)
  ///
  /// Called by device owner to add an override APN.
  ///
  /// This method may returns {@code -1} if {@code apnSetting} conflicts with an existing
  /// override APN. Update the existing conflicted APN with
  /// \#updateOverrideApn(ComponentName, int, ApnSetting) instead of adding a new entry.
  /// Two override APNs are considered to conflict when all the following APIs return
  /// the same values on both override APNs:
  /// <ul>
  ///   <li>ApnSetting\#getOperatorNumeric()</li>
  ///   <li>ApnSetting\#getApnName()</li>
  ///   <li>ApnSetting\#getProxyAddress()</li>
  ///   <li>ApnSetting\#getProxyPort()</li>
  ///   <li>ApnSetting\#getMmsProxyAddress()</li>
  ///   <li>ApnSetting\#getMmsProxyPort()</li>
  ///   <li>ApnSetting\#getMmsc()</li>
  ///   <li>ApnSetting\#isEnabled()</li>
  ///   <li>ApnSetting\#getMvnoType()</li>
  ///   <li>ApnSetting\#getProtocol()</li>
  ///   <li>ApnSetting\#getRoamingProtocol()</li>
  /// </ul>
  ///@param admin which DeviceAdminReceiver this request is associated with
  /// This value must never be {@code null}.
  ///@param apnSetting the override APN to insert
  /// This value must never be {@code null}.
  ///@return The {@code id} of inserted override APN. Or {@code -1} when failed to insert into
  ///         the database.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#setOverrideApnsEnabled(ComponentName, boolean)
  int addOverrideApn(content_.ComponentName admin, jni.JniObject apnSetting) =>
      _addOverrideApn(reference, admin.reference, apnSetting.reference).integer;

  static final _updateOverrideApn = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__updateOverrideApn")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean updateOverrideApn(android.content.ComponentName admin, int apnId, android.telephony.data.ApnSetting apnSetting)
  ///
  /// Called by device owner to update an override APN.
  ///
  /// This method may returns {@code false} if there is no override APN with the given
  /// {@code apnId}.
  /// This method may also returns {@code false} if {@code apnSetting} conflicts with an
  /// existing override APN. Update the existing conflicted APN instead.
  /// See \#addOverrideApn for the definition of conflict.
  ///@param admin which DeviceAdminReceiver this request is associated with
  /// This value must never be {@code null}.
  ///@param apnId the {@code id} of the override APN to update
  ///@param apnSetting the override APN to update
  /// This value must never be {@code null}.
  ///@return {@code true} if the required override APN is successfully updated,
  ///         {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#setOverrideApnsEnabled(ComponentName, boolean)
  bool updateOverrideApn(
          content_.ComponentName admin, int apnId, jni.JniObject apnSetting) =>
      _updateOverrideApn(
              reference, admin.reference, apnId, apnSetting.reference)
          .boolean;

  static final _removeOverrideApn = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DevicePolicyManager__removeOverrideApn")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean removeOverrideApn(android.content.ComponentName admin, int apnId)
  ///
  /// Called by device owner to remove an override APN.
  ///
  /// This method may returns {@code false} if there is no override APN with the given
  /// {@code apnId}.
  ///@param admin which DeviceAdminReceiver this request is associated with
  /// This value must never be {@code null}.
  ///@param apnId the {@code id} of the override APN to remove
  ///@return {@code true} if the required override APN is successfully removed, {@code false}
  ///         otherwise.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#setOverrideApnsEnabled(ComponentName, boolean)
  bool removeOverrideApn(content_.ComponentName admin, int apnId) =>
      _removeOverrideApn(reference, admin.reference, apnId).boolean;

  static final _getOverrideApns = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getOverrideApns")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.telephony.data.ApnSetting> getOverrideApns(android.content.ComponentName admin)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by device owner to get all override APNs inserted by device owner.
  ///@param admin which DeviceAdminReceiver this request is associated with
  /// This value must never be {@code null}.
  ///@return A list of override APNs inserted by device owner.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#setOverrideApnsEnabled(ComponentName, boolean)
  jni.JniObject getOverrideApns(content_.ComponentName admin) =>
      jni.JniObject.fromRef(
          _getOverrideApns(reference, admin.reference).object);

  static final _setOverrideApnsEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DevicePolicyManager__setOverrideApnsEnabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setOverrideApnsEnabled(android.content.ComponentName admin, boolean enabled)
  ///
  /// Called by device owner to set if override APNs should be enabled.
  ///  Override APNs are separated from other APNs on the device, and can only be inserted or
  /// modified by the device owner. When enabled, only override APNs are in use, any other APNs
  /// are ignored.
  ///@param admin which DeviceAdminReceiver this request is associated with
  /// This value must never be {@code null}.
  ///@param enabled {@code true} if override APNs should be enabled, {@code false} otherwise
  ///@throws SecurityException if {@code admin} is not a device owner.
  void setOverrideApnsEnabled(content_.ComponentName admin, bool enabled) =>
      _setOverrideApnsEnabled(reference, admin.reference, enabled ? 1 : 0)
          .check();

  static final _isOverrideApnEnabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__isOverrideApnEnabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isOverrideApnEnabled(android.content.ComponentName admin)
  ///
  /// Called by device owner to check if override APNs are currently enabled.
  ///@param admin which DeviceAdminReceiver this request is associated with
  /// This value must never be {@code null}.
  ///@return {@code true} if override APNs are currently enabled, {@code false} otherwise.
  ///@throws SecurityException if {@code admin} is not a device owner.
  ///@see \#setOverrideApnsEnabled(ComponentName, boolean)
  bool isOverrideApnEnabled(content_.ComponentName admin) =>
      _isOverrideApnEnabled(reference, admin.reference).boolean;

  static final _getTransferOwnershipBundle = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DevicePolicyManager__getTransferOwnershipBundle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.PersistableBundle getTransferOwnershipBundle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the data passed from the current administrator to the new administrator during an
  /// ownership transfer. This is the same {@code bundle} passed in
  /// \#transferOwnership(ComponentName, ComponentName, PersistableBundle). The bundle is
  /// persisted until the profile owner or device owner is removed.
  ///
  /// This is the same <code>bundle</code> received in the
  /// DeviceAdminReceiver\#onTransferOwnershipComplete(Context, PersistableBundle).
  /// Use this method to retrieve it after the transfer as long as the new administrator is the
  /// active device or profile owner.
  ///
  /// Returns <code>null</code> if no ownership transfer was started for the calling user.
  ///@see \#transferOwnership
  ///@see DeviceAdminReceiver\#onTransferOwnershipComplete(Context, PersistableBundle)
  ///@throws SecurityException if the caller is not a device or profile owner.
  os_.PersistableBundle getTransferOwnershipBundle() =>
      os_.PersistableBundle.fromRef(
          _getTransferOwnershipBundle(reference).object);
}

/// from: android.app.admin.DevicePolicyManager$OnClearApplicationUserDataListener
///
/// Callback used in \#clearApplicationUserData
/// to indicate that the clearing of an application's user data is done.
class DevicePolicyManager_OnClearApplicationUserDataListener
    extends jni.JniObject {
  DevicePolicyManager_OnClearApplicationUserDataListener.fromRef(
      ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onApplicationUserDataCleared = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "DevicePolicyManager_OnClearApplicationUserDataListener__onApplicationUserDataCleared")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void onApplicationUserDataCleared(java.lang.String packageName, boolean succeeded)
  ///
  /// Method invoked when clearing the application user data has completed.
  ///@param packageName The name of the package which had its user data cleared.
  ///@param succeeded Whether the clearing succeeded. Clearing fails for device administrator
  ///                  apps and protected system packages.
  void onApplicationUserDataCleared(
          jni.JniString packageName, bool succeeded) =>
      _onApplicationUserDataCleared(
              reference, packageName.reference, succeeded ? 1 : 0)
          .check();
}

/// from: android.app.admin.DnsEvent
///
/// A class that represents a DNS lookup event initiated through the standard network stack.
///
/// It contains information about the originating app as well as the DNS hostname and resolved
/// IP addresses.
class DnsEvent extends NetworkEvent {
  DnsEvent.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR1 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_DnsEvent__CREATOR1")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.admin.DnsEvent> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR1 =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR1().object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("DnsEvent__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Parcel in)
  DnsEvent.ctor1(os_.Parcel in0) : super.fromRef(_ctor1(in0.reference).object);

  static final _getHostname = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DnsEvent__getHostname")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getHostname()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the hostname that was looked up.
  jni.JniString getHostname() =>
      jni.JniString.fromRef(_getHostname(reference).object);

  static final _getInetAddresses = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DnsEvent__getInetAddresses")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<java.net.InetAddress> getInetAddresses()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns (possibly a subset of) the IP addresses returned.
  jni.JniObject getInetAddresses() =>
      jni.JniObject.fromRef(_getInetAddresses(reference).object);

  static final _getTotalResolvedAddressCount = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DnsEvent__getTotalResolvedAddressCount")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getTotalResolvedAddressCount()
  ///
  /// Returns the number of IP addresses returned from the DNS lookup event. May be different from
  /// the length of the list returned by \#getInetAddresses() if there were too many
  /// addresses to log.
  int getTotalResolvedAddressCount() =>
      _getTotalResolvedAddressCount(reference).integer;

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DnsEvent__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DnsEvent__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("DnsEvent__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os_.Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags).check();
}

/// from: android.app.admin.FreezePeriod
///
/// A class that represents one freeze period which repeats _annually_. A freeze period has
/// two java.time\#MonthDay values that define the start and end dates of the period, both
/// inclusive. If the end date is earlier than the start date, the period is considered wrapped
/// around the year-end. As far as freeze period is concerned, leap year is disregarded and February
/// 29th should be treated as if it were February 28th: so a freeze starting or ending on February
/// 28th is identical to a freeze starting or ending on February 29th. When calulating the length of
/// a freeze or the distance bewteen two freee periods, February 29th is also ignored.
///@see SystemUpdatePolicy\#setFreezePeriods
class FreezePeriod extends jni.JniObject {
  FreezePeriod.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FreezePeriod__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.time.MonthDay start, java.time.MonthDay end)
  ///
  /// Creates a freeze period by its start and end dates. If the end date is earlier than the start
  /// date, the freeze period is considered wrapping year-end.
  FreezePeriod(jni.JniObject start, jni.JniObject end)
      : super.fromRef(_ctor(start.reference, end.reference).object);

  static final _getStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FreezePeriod__getStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.time.MonthDay getStart()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the start date (inclusive) of this freeze period.
  jni.JniObject getStart() =>
      jni.JniObject.fromRef(_getStart(reference).object);

  static final _getEnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FreezePeriod__getEnd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.time.MonthDay getEnd()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the end date (inclusive) of this freeze period.
  jni.JniObject getEnd() => jni.JniObject.fromRef(_getEnd(reference).object);

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FreezePeriod__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);
}

/// from: android.app.admin.NetworkEvent
///
/// An abstract class that represents a network event.
class NetworkEvent extends jni.JniObject {
  NetworkEvent.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_NetworkEvent__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.admin.NetworkEvent> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "NetworkEvent__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  ///
  /// @hide
  NetworkEvent() : super.fromRef(_ctor().object);

  static final _getPackageName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NetworkEvent__getPackageName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPackageName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the package name of the UID that performed the query, as returned by
  /// PackageManager\#getNameForUid.
  jni.JniString getPackageName() =>
      jni.JniString.fromRef(_getPackageName(reference).object);

  static final _getTimestamp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NetworkEvent__getTimestamp")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTimestamp()
  ///
  /// Returns the timestamp of the event being reported in milliseconds, the difference between
  /// the time the event was reported and midnight, January 1, 1970 UTC.
  int getTimestamp() => _getTimestamp(reference).long;

  static final _getId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NetworkEvent__getId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getId()
  ///
  /// Returns the id of the event, where the id monotonically increases for each event. The id
  /// is reset when the device reboots, and when network logging is enabled.
  int getId() => _getId(reference).long;

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NetworkEvent__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("NetworkEvent__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os_.Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags).check();
}

/// from: android.app.admin.SecurityLog
///
/// Definitions for working with security logs.
///
/// Device owner apps can control the logging with
/// DevicePolicyManager\#setSecurityLoggingEnabled. When security logs are enabled, device
/// owner apps receive periodic callbacks from DeviceAdminReceiver\#onSecurityLogsAvailable,
/// at which time new batch of logs can be collected via
/// DevicePolicyManager\#retrieveSecurityLogs. SecurityEvent describes the type and
/// format of security logs being collected.
class SecurityLog extends jni.JniObject {
  SecurityLog.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int LEVEL_ERROR
  ///
  /// Event severity level indicating that the event requires urgent admin action.
  static const LEVEL_ERROR = 3;

  /// from: static public final int LEVEL_INFO
  ///
  /// Event severity level indicating that the event corresponds to normal workflow.
  static const LEVEL_INFO = 1;

  /// from: static public final int LEVEL_WARNING
  ///
  /// Event severity level indicating that the event may require admin attention.
  static const LEVEL_WARNING = 2;

  /// from: static public final int TAG_ADB_SHELL_CMD
  ///
  /// Indicates that a shell command was issued over ADB via {@code adb shell <command>}
  /// The log entry contains a {@code String} payload containing the shell command, accessible
  /// via SecurityEvent\#getData().
  static const TAG_ADB_SHELL_CMD = 210002;

  /// from: static public final int TAG_ADB_SHELL_INTERACTIVE
  ///
  /// Indicates that an ADB interactive shell was opened via "adb shell".
  /// There is no extra payload in the log event.
  static const TAG_ADB_SHELL_INTERACTIVE = 210001;

  /// from: static public final int TAG_APP_PROCESS_START
  ///
  /// Indicates that an app process was started. The log entry contains the following
  /// information about the process encapsulated in an Object array, accessible via
  /// SecurityEvent\#getData():
  /// <li> [0] process name ({@code String})
  /// <li> [1] exact start time in milliseconds according to {@code System.currentTimeMillis()}
  ///      ({@code Long})
  /// <li> [2] app uid ({@code Integer})
  /// <li> [3] app pid ({@code Integer})
  /// <li> [4] seinfo tag ({@code String})
  /// <li> [5] SHA-256 hash of the base APK in hexadecimal ({@code String})
  static const TAG_APP_PROCESS_START = 210005;

  /// from: static public final int TAG_CERT_AUTHORITY_INSTALLED
  ///
  /// Indicates that a new root certificate has been installed into system's trusted credential
  /// storage. The log entry contains the following information about the event, encapsulated in an
  /// Object array and accessible via SecurityEvent\#getData():
  /// <li> [0] result ({@code Integer}, 0 if operation failed, 1 if succeeded)
  /// <li> [1] subject of the certificate ({@code String}).
  static const TAG_CERT_AUTHORITY_INSTALLED = 210029;

  /// from: static public final int TAG_CERT_AUTHORITY_REMOVED
  ///
  /// Indicates that a new root certificate has been removed from system's trusted credential
  /// storage. The log entry contains the following information about the event, encapsulated in an
  /// Object array and accessible via SecurityEvent\#getData():
  /// <li> [0] result ({@code Integer}, 0 if operation failed, 1 if succeeded)
  /// <li> [1] subject of the certificate ({@code String}).
  static const TAG_CERT_AUTHORITY_REMOVED = 210030;

  /// from: static public final int TAG_CERT_VALIDATION_FAILURE
  ///
  /// Indicates a failure to validate X.509v3 certificate. The log entry contains a {@code String}
  /// payload indicating the failure reason, accessible via SecurityEvent\#getData().
  static const TAG_CERT_VALIDATION_FAILURE = 210033;

  /// from: static public final int TAG_CRYPTO_SELF_TEST_COMPLETED
  ///
  /// Indicates that cryptographic functionality self test has completed. The log entry contains an
  /// {@code Integer} payload, indicating the result of the test (0 if the test failed, 1 if
  /// succeeded) and accessible via SecurityEvent\#getData().
  static const TAG_CRYPTO_SELF_TEST_COMPLETED = 210031;

  /// from: static public final int TAG_KEYGUARD_DISABLED_FEATURES_SET
  ///
  /// Indicates that an admin has set disabled keyguard features. The log entry contains the
  /// following information about the event encapsulated in an Object array, accessible via
  /// SecurityEvent\#getData():
  /// <li> [0] admin package name ({@code String})
  /// <li> [1] admin user ID ({@code Integer})
  /// <li> [2] target user ID ({@code Integer})
  /// <li> [3] disabled keyguard feature mask ({@code Integer}).
  ///@see DevicePolicyManager\#setKeyguardDisabledFeatures(ComponentName, int)
  static const TAG_KEYGUARD_DISABLED_FEATURES_SET = 210021;

  /// from: static public final int TAG_KEYGUARD_DISMISSED
  ///
  /// Indicates that keyguard has been dismissed.
  /// There is no extra payload in the log event.
  static const TAG_KEYGUARD_DISMISSED = 210006;

  /// from: static public final int TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT
  ///
  /// Indicates that there has been an authentication attempt to dismiss the keyguard. The log
  /// entry contains the following information about the attempt encapsulated in an Object
  /// array, accessible via SecurityEvent\#getData():
  /// <li> [0] attempt result ({@code Integer}, 1 for successful, 0 for unsuccessful)
  /// <li> [1] strength of authentication method ({@code Integer}, 1 if strong authentication
  ///      method was used, 0 otherwise)
  static const TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT = 210007;

  /// from: static public final int TAG_KEYGUARD_SECURED
  ///
  /// Indicates that the device has been locked, either by the user or by a timeout. There is no
  /// extra payload in the log event.
  static const TAG_KEYGUARD_SECURED = 210008;

  /// from: static public final int TAG_KEY_DESTRUCTION
  ///
  /// Indicates that a cryptographic key was destroyed. The log entry contains the following
  /// information about the event, encapsulated in an Object array and accessible via
  /// SecurityEvent\#getData():
  /// <li> [0] result ({@code Integer}, 0 if operation failed, 1 if succeeded)
  /// <li> [1] alias of the key ({@code String})
  /// <li> [2] requesting process uid ({@code Integer}).
  static const TAG_KEY_DESTRUCTION = 210026;

  /// from: static public final int TAG_KEY_GENERATED
  ///
  /// Indicates that an authentication key was generated. The log entry contains the following
  /// information about the event, encapsulated in an Object array and accessible via
  /// SecurityEvent\#getData():
  /// <li> [0] result ({@code Integer}, 0 if operation failed, 1 if succeeded)
  /// <li> [1] alias of the key ({@code String})
  /// <li> [2] requesting process uid ({@code Integer}).
  static const TAG_KEY_GENERATED = 210024;

  /// from: static public final int TAG_KEY_IMPORT
  ///
  /// Indicates that a cryptographic key was imported. The log entry contains the following
  /// information about the event, encapsulated in an Object array and accessible via
  /// SecurityEvent\#getData():
  /// <li> [0] result ({@code Integer}, 0 if operation failed, 1 if succeeded)
  /// <li> [1] alias of the key ({@code String})
  /// <li> [2] requesting process uid ({@code Integer}).
  static const TAG_KEY_IMPORT = 210025;

  /// from: static public final int TAG_KEY_INTEGRITY_VIOLATION
  ///
  /// Indicates a failed cryptographic key integrity check. The log entry contains the following
  /// information about the event, encapsulated in an Object array and accessible via
  /// SecurityEvent\#getData():
  /// <li> [0] alias of the key ({@code String})
  /// <li> [1] owner application uid ({@code Integer}).
  static const TAG_KEY_INTEGRITY_VIOLATION = 210032;

  /// from: static public final int TAG_LOGGING_STARTED
  ///
  /// Indicates start-up of audit logging. There is no extra payload in the log event.
  static const TAG_LOGGING_STARTED = 210011;

  /// from: static public final int TAG_LOGGING_STOPPED
  ///
  /// Indicates shutdown of audit logging. There is no extra payload in the log event.
  static const TAG_LOGGING_STOPPED = 210012;

  /// from: static public final int TAG_LOG_BUFFER_SIZE_CRITICAL
  ///
  /// Indicates that the audit log buffer has reached 90% of its capacity. There is no extra
  /// payload in the log event.
  static const TAG_LOG_BUFFER_SIZE_CRITICAL = 210015;

  /// from: static public final int TAG_MAX_PASSWORD_ATTEMPTS_SET
  ///
  /// Indicates that an admin has set a maximum number of failed password attempts before wiping
  /// data. The log entry contains the following information about the event encapsulated in an
  /// Object array, accessible via SecurityEvent\#getData():
  /// <li> [0] admin package name ({@code String})
  /// <li> [1] admin user ID ({@code Integer})
  /// <li> [2] target user ID ({@code Integer})
  /// <li> [3] new maximum number of failed password attempts ({@code Integer})
  ///@see DevicePolicyManager\#setMaximumFailedPasswordsForWipe(ComponentName, int)
  static const TAG_MAX_PASSWORD_ATTEMPTS_SET = 210020;

  /// from: static public final int TAG_MAX_SCREEN_LOCK_TIMEOUT_SET
  ///
  /// Indicates that an admin has set a maximum screen lock timeout. The log entry contains the
  /// following information about the event encapsulated in an Object array, accessible
  /// via SecurityEvent\#getData():
  /// <li> [0] admin package name ({@code String})
  /// <li> [1] admin user ID ({@code Integer})
  /// <li> [2] target user ID ({@code Integer})
  /// <li> [3] new screen lock timeout in milliseconds ({@code Long})
  ///@see DevicePolicyManager\#setMaximumTimeToLock(ComponentName, long)
  static const TAG_MAX_SCREEN_LOCK_TIMEOUT_SET = 210019;

  /// from: static public final int TAG_MEDIA_MOUNT
  ///
  /// Indicates that removable media has been mounted on the device. The log entry contains the
  /// following information about the event, encapsulated in an Object array and
  /// accessible via SecurityEvent\#getData():
  /// <li> [0] mount point ({@code String})
  /// <li> [1] volume label ({@code String}).
  static const TAG_MEDIA_MOUNT = 210013;

  /// from: static public final int TAG_MEDIA_UNMOUNT
  ///
  /// Indicates that removable media was unmounted from the device. The log entry contains the
  /// following information about the event, encapsulated in an Object array and
  /// accessible via SecurityEvent\#getData():
  /// <li> [0] mount point ({@code String})
  /// <li> [1] volume label ({@code String}).
  static const TAG_MEDIA_UNMOUNT = 210014;

  /// from: static public final int TAG_OS_SHUTDOWN
  ///
  /// Indicates that the Android OS has shutdown. There is no extra payload in the log event.
  static const TAG_OS_SHUTDOWN = 210010;

  /// from: static public final int TAG_OS_STARTUP
  ///
  /// Indicates that the Android OS has started. The log entry contains the following information
  /// about the startup time software integrity check encapsulated in an Object array,
  /// accessible via SecurityEvent\#getData():
  /// <li> [0] Verified Boot state ({@code String})
  /// <li> [1] dm-verity mode ({@code String}).
  /// Verified Boot state can be one of the following:
  /// <li> {@code green} indicates that there is a full chain of trust extending from the
  /// bootloader to verified partitions including the bootloader, boot partition, and all verified
  /// partitions.
  /// <li> {@code yellow} indicates that the boot partition has been verified using the embedded
  /// certificate and the signature is valid.
  /// <li> {@code orange} indicates that the device may be freely modified. Device integrity is
  /// left to the user to verify out-of-band.
  /// dm-verity mode can be one of the following:
  /// <li> {@code enforcing} indicates that the device will be restarted when corruption is
  /// detected.
  /// <li> {@code eio} indicates that an I/O error will be returned for an attempt to read
  /// corrupted data blocks.
  /// For details see Verified Boot documentation.
  static const TAG_OS_STARTUP = 210009;

  /// from: static public final int TAG_PASSWORD_COMPLEXITY_SET
  ///
  /// Indicates that an admin has set a requirement for password complexity. The log entry contains
  /// the following information about the event, encapsulated in an Object array and
  /// accessible via SecurityEvent\#getData():
  /// <li> [0] admin package name ({@code String})
  /// <li> [1] admin user ID ({@code Integer})
  /// <li> [2] target user ID ({@code Integer})
  /// <li> [3] minimum password length ({@code Integer})
  /// <li> [4] password quality constraint ({@code Integer})
  /// <li> [5] minimum number of letters ({@code Integer})
  /// <li> [6] minimum number of non-letters ({@code Integer})
  /// <li> [7] minimum number of digits ({@code Integer})
  /// <li> [8] minimum number of uppercase letters ({@code Integer})
  /// <li> [9] minimum number of lowercase letters ({@code Integer})
  /// <li> [10] minimum number of symbols ({@code Integer})
  ///@see DevicePolicyManager\#setPasswordMinimumLength(ComponentName, int)
  ///@see DevicePolicyManager\#setPasswordQuality(ComponentName, int)
  ///@see DevicePolicyManager\#setPasswordMinimumLetters(ComponentName, int)
  ///@see DevicePolicyManager\#setPasswordMinimumNonLetter(ComponentName, int)
  ///@see DevicePolicyManager\#setPasswordMinimumLowerCase(ComponentName, int)
  ///@see DevicePolicyManager\#setPasswordMinimumUpperCase(ComponentName, int)
  ///@see DevicePolicyManager\#setPasswordMinimumNumeric(ComponentName, int)
  ///@see DevicePolicyManager\#setPasswordMinimumSymbols(ComponentName, int)
  static const TAG_PASSWORD_COMPLEXITY_SET = 210017;

  /// from: static public final int TAG_PASSWORD_EXPIRATION_SET
  ///
  /// Indicates that an admin has set a password expiration timeout. The log entry contains the
  /// following information about the event, encapsulated in an Object array and accessible
  /// via SecurityEvent\#getData():
  /// <li> [0] admin package name ({@code String})
  /// <li> [1] admin user ID ({@code Integer})
  /// <li> [2] target user ID ({@code Integer})
  /// <li> [3] new password expiration timeout in milliseconds ({@code Long}).
  ///@see DevicePolicyManager\#setPasswordExpirationTimeout(ComponentName, long)
  static const TAG_PASSWORD_EXPIRATION_SET = 210016;

  /// from: static public final int TAG_PASSWORD_HISTORY_LENGTH_SET
  ///
  /// Indicates that an admin has set a password history length. The log entry contains the
  /// following information about the event encapsulated in an Object array, accessible
  /// via SecurityEvent\#getData():
  /// <li> [0] admin package name ({@code String})
  /// <li> [1] admin user ID ({@code Integer})
  /// <li> [2] target user ID ({@code Integer})
  /// <li> [3] new password history length value ({@code Integer})
  ///@see DevicePolicyManager\#setPasswordHistoryLength(ComponentName, int)
  static const TAG_PASSWORD_HISTORY_LENGTH_SET = 210018;

  /// from: static public final int TAG_REMOTE_LOCK
  ///
  /// Indicates that an admin remotely locked the device or profile. The log entry contains the
  /// following information about the event encapsulated in an Object array, accessible via
  /// SecurityEvent\#getData():
  /// <li> [0] admin package name ({@code String}),
  /// <li> [1] admin user ID ({@code Integer}).
  /// <li> [2] target user ID ({@code Integer})
  static const TAG_REMOTE_LOCK = 210022;

  /// from: static public final int TAG_SYNC_RECV_FILE
  ///
  /// Indicates that a file was pulled from the device via the adb daemon, for example via
  /// {@code adb pull}. The log entry contains a {@code String} payload containing the path of the
  /// pulled file on the device, accessible via SecurityEvent\#getData().
  static const TAG_SYNC_RECV_FILE = 210003;

  /// from: static public final int TAG_SYNC_SEND_FILE
  ///
  /// Indicates that a file was pushed to the device via the adb daemon, for example via
  /// {@code adb push}. The log entry contains a {@code String} payload containing the destination
  /// path of the pushed file, accessible via SecurityEvent\#getData().
  static const TAG_SYNC_SEND_FILE = 210004;

  /// from: static public final int TAG_USER_RESTRICTION_ADDED
  ///
  /// Indicates that an admin has set a user restriction. The log entry contains the following
  /// information about the event, encapsulated in an Object array and accessible via
  /// SecurityEvent\#getData():
  /// <li> [0] admin package name ({@code String})
  /// <li> [1] admin user ID ({@code Integer})
  /// <li> [2] user restriction ({@code String})
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  static const TAG_USER_RESTRICTION_ADDED = 210027;

  /// from: static public final int TAG_USER_RESTRICTION_REMOVED
  ///
  /// Indicates that an admin has removed a user restriction. The log entry contains the following
  /// information about the event, encapsulated in an Object array and accessible via
  /// SecurityEvent\#getData():
  /// <li> [0] admin package name ({@code String})
  /// <li> [1] admin user ID ({@code Integer})
  /// <li> [2] user restriction ({@code String})
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  static const TAG_USER_RESTRICTION_REMOVED = 210028;

  /// from: static public final int TAG_WIPE_FAILURE
  ///
  /// Indicates a failure to wipe device or user data. There is no extra payload in the log event.
  static const TAG_WIPE_FAILURE = 210023;

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "SecurityLog__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  SecurityLog() : super.fromRef(_ctor().object);
}

/// from: android.app.admin.SecurityLog$SecurityEvent
///
/// A class representing a security event log entry.
class SecurityLog_SecurityEvent extends jni.JniObject {
  SecurityLog_SecurityEvent.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_SecurityLog_SecurityEvent__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.admin.SecurityLog.SecurityEvent> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SecurityLog_SecurityEvent__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(byte[] data)
  ///
  /// Constructor used by native classes to generate SecurityEvent instances.
  ///@hide
  SecurityLog_SecurityEvent(jni.JniObject data)
      : super.fromRef(_ctor(data.reference).object);

  static final _getTimeNanos = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SecurityLog_SecurityEvent__getTimeNanos")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTimeNanos()
  ///
  /// Returns the timestamp in nano seconds when this event was logged.
  int getTimeNanos() => _getTimeNanos(reference).long;

  static final _getTag = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SecurityLog_SecurityEvent__getTag")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getTag()
  ///
  /// Returns the tag of this log entry, which specifies entry's semantics.
  ///@return Value is android.app.admin.SecurityLog\#TAG_ADB_SHELL_INTERACTIVE, android.app.admin.SecurityLog\#TAG_ADB_SHELL_CMD, android.app.admin.SecurityLog\#TAG_SYNC_RECV_FILE, android.app.admin.SecurityLog\#TAG_SYNC_SEND_FILE, android.app.admin.SecurityLog\#TAG_APP_PROCESS_START, android.app.admin.SecurityLog\#TAG_KEYGUARD_DISMISSED, android.app.admin.SecurityLog\#TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT, android.app.admin.SecurityLog\#TAG_KEYGUARD_SECURED, android.app.admin.SecurityLog\#TAG_OS_STARTUP, android.app.admin.SecurityLog\#TAG_OS_SHUTDOWN, android.app.admin.SecurityLog\#TAG_LOGGING_STARTED, android.app.admin.SecurityLog\#TAG_LOGGING_STOPPED, android.app.admin.SecurityLog\#TAG_MEDIA_MOUNT, android.app.admin.SecurityLog\#TAG_MEDIA_UNMOUNT, android.app.admin.SecurityLog\#TAG_LOG_BUFFER_SIZE_CRITICAL, android.app.admin.SecurityLog\#TAG_PASSWORD_EXPIRATION_SET, android.app.admin.SecurityLog\#TAG_PASSWORD_COMPLEXITY_SET, android.app.admin.SecurityLog\#TAG_PASSWORD_HISTORY_LENGTH_SET, android.app.admin.SecurityLog\#TAG_MAX_SCREEN_LOCK_TIMEOUT_SET, android.app.admin.SecurityLog\#TAG_MAX_PASSWORD_ATTEMPTS_SET, android.app.admin.SecurityLog\#TAG_KEYGUARD_DISABLED_FEATURES_SET, android.app.admin.SecurityLog\#TAG_REMOTE_LOCK, android.app.admin.SecurityLog\#TAG_USER_RESTRICTION_ADDED, android.app.admin.SecurityLog\#TAG_USER_RESTRICTION_REMOVED, android.app.admin.SecurityLog\#TAG_WIPE_FAILURE, android.app.admin.SecurityLog\#TAG_KEY_GENERATED, android.app.admin.SecurityLog\#TAG_KEY_IMPORT, android.app.admin.SecurityLog\#TAG_KEY_DESTRUCTION, android.app.admin.SecurityLog\#TAG_CERT_AUTHORITY_INSTALLED, android.app.admin.SecurityLog\#TAG_CERT_AUTHORITY_REMOVED, android.app.admin.SecurityLog\#TAG_CRYPTO_SELF_TEST_COMPLETED, android.app.admin.SecurityLog\#TAG_KEY_INTEGRITY_VIOLATION, or android.app.admin.SecurityLog\#TAG_CERT_VALIDATION_FAILURE
  int getTag() => _getTag(reference).integer;

  static final _getData = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SecurityLog_SecurityEvent__getData")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object getData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the payload contained in this log entry or {@code null} if there is no payload.
  jni.JniObject getData() => jni.JniObject.fromRef(_getData(reference).object);

  static final _getId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SecurityLog_SecurityEvent__getId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getId()
  ///
  /// Returns the id of the event, where the id monotonically increases for each event. The id
  /// is reset when the device reboots, and when security logging is enabled.
  int getId() => _getId(reference).long;

  static final _getLogLevel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SecurityLog_SecurityEvent__getLogLevel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLogLevel()
  ///
  /// Returns severity level for the event.
  ///@return Value is android.app.admin.SecurityLog\#LEVEL_INFO, android.app.admin.SecurityLog\#LEVEL_WARNING, or android.app.admin.SecurityLog\#LEVEL_ERROR
  int getLogLevel() => _getLogLevel(reference).integer;

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SecurityLog_SecurityEvent__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("SecurityLog_SecurityEvent__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("SecurityLog_SecurityEvent__equals1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object o)
  ///
  /// @hide
  bool equals1(jni.JniObject o) => _equals1(reference, o.reference).boolean;

  static final _hashCode1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SecurityLog_SecurityEvent__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  ///
  /// @hide
  int hashCode1() => _hashCode1(reference).integer;
}

/// from: android.app.admin.SystemUpdateInfo
///
/// A class containing information about a pending system update.
class SystemUpdateInfo extends jni.JniObject {
  SystemUpdateInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_SystemUpdateInfo__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.admin.SystemUpdateInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  /// from: static public final int SECURITY_PATCH_STATE_FALSE
  ///
  /// Represents the system update is not a security patch.
  static const SECURITY_PATCH_STATE_FALSE = 1;

  /// from: static public final int SECURITY_PATCH_STATE_TRUE
  ///
  /// Represents the system update is a security patch.
  static const SECURITY_PATCH_STATE_TRUE = 2;

  /// from: static public final int SECURITY_PATCH_STATE_UNKNOWN
  ///
  /// Represents it is unknown whether the system update is a security patch.
  static const SECURITY_PATCH_STATE_UNKNOWN = 0;

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SystemUpdateInfo__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Parcel in)
  SystemUpdateInfo(os_.Parcel in0) : super.fromRef(_ctor(in0.reference).object);

  static final _getReceivedTime = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SystemUpdateInfo__getReceivedTime")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getReceivedTime()
  ///
  /// Gets time when the update was first available in milliseconds since midnight, January 1,
  /// 1970 UTC.
  ///@return Time in milliseconds as given by System\#currentTimeMillis()
  int getReceivedTime() => _getReceivedTime(reference).long;

  static final _getSecurityPatchState = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SystemUpdateInfo__getSecurityPatchState")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getSecurityPatchState()
  ///
  /// Gets whether the update is a security patch.
  ///@return \#SECURITY_PATCH_STATE_FALSE, \#SECURITY_PATCH_STATE_TRUE, or
  ///         \#SECURITY_PATCH_STATE_UNKNOWN.
  ///
  /// Value is android.app.admin.SystemUpdateInfo\#SECURITY_PATCH_STATE_FALSE, android.app.admin.SystemUpdateInfo\#SECURITY_PATCH_STATE_TRUE, or android.app.admin.SystemUpdateInfo\#SECURITY_PATCH_STATE_UNKNOWN
  int getSecurityPatchState() => _getSecurityPatchState(reference).integer;

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SystemUpdateInfo__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("SystemUpdateInfo__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SystemUpdateInfo__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("SystemUpdateInfo__equals1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => _equals1(reference, o.reference).boolean;

  static final _hashCode1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SystemUpdateInfo__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() => _hashCode1(reference).integer;
}

/// from: android.app.admin.SystemUpdatePolicy
///
/// Determines when over-the-air system updates are installed on a device. Only a device policy
/// controller (DPC) running in device owner mode can set an update policy for the device\u2014by calling
/// the {@code DevicePolicyManager} method
/// DevicePolicyManager\#setSystemUpdatePolicy setSystemUpdatePolicy(). An update
/// policy affects the pending system update (if there is one) and any future updates for the device.
///
/// If a policy is set on a device, the system doesn't notify the user about updates.
///
/// <h3>Example</h3>
///
/// The example below shows how a DPC might set a maintenance window for system updates:
///
/// <pre><code>
/// private final MAINTENANCE_WINDOW_START = 1380; // 11pm
/// private final MAINTENANCE_WINDOW_END = 120; // 2am
///
/// // ...
///
/// // Create the system update policy
/// SystemUpdatePolicy policy = SystemUpdatePolicy.createWindowedInstallPolicy(
///     MAINTENANCE_WINDOW_START, MAINTENANCE_WINDOW_END);
///
/// // Get a DevicePolicyManager instance to set the policy on the device
/// DevicePolicyManager dpm =
///     (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
/// ComponentName adminComponent = getComponentName(context);
/// dpm.setSystemUpdatePolicy(adminComponent, policy);
/// </code></pre>
///
/// <h3>Developer guide</h3>
/// To learn more about managing system updates, read
/// <a href="{@docRoot}/work/dpc/security.html\#control_remote_software_updates">Control remote
/// software updates</a>.
///@see DevicePolicyManager\#setSystemUpdatePolicy
///@see DevicePolicyManager\#getSystemUpdatePolicy
class SystemUpdatePolicy extends jni.JniObject {
  SystemUpdatePolicy.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_SystemUpdatePolicy__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.admin.SystemUpdatePolicy> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  /// from: static public final int TYPE_INSTALL_AUTOMATIC
  ///
  /// Installs system updates (without user interaction) as soon as they become available. Setting
  /// this policy type immediately installs any pending updates that might be postponed or waiting
  /// for a maintenance window.
  static const TYPE_INSTALL_AUTOMATIC = 1;

  /// from: static public final int TYPE_INSTALL_WINDOWED
  ///
  /// Installs system updates (without user interaction) during a daily maintenance window. Set the
  /// start and end of the daily maintenance window, as minutes of the day, when creating a new
  /// {@code TYPE_INSTALL_WINDOWED} policy. See
  /// \#createWindowedInstallPolicy createWindowedInstallPolicy().
  ///
  /// No connectivity, not enough disk space, or a low battery are typical reasons Android might
  /// not install a system update in the daily maintenance window. After 30 days trying to install
  /// an update in the maintenance window (regardless of policy changes in this period), the system
  /// prompts the device user to install the update.
  static const TYPE_INSTALL_WINDOWED = 2;

  /// from: static public final int TYPE_POSTPONE
  ///
  /// Postpones the installation of system updates for 30 days. After the 30-day period has ended,
  /// the system prompts the device user to install the update.
  ///
  /// The system limits each update to one 30-day postponement. The period begins when the
  /// system first postpones the update and setting new {@code TYPE_POSTPONE} policies won\u2019t extend
  /// the period. If, after 30 days the update isn\u2019t installed (through policy changes), the system
  /// prompts the user to install the update.
  ///
  /// <strong>Note</strong>: Device manufacturers or carriers might choose to exempt important
  /// security updates from a postponement policy. Exempted updates notify the device user when
  /// they become available.
  static const TYPE_POSTPONE = 3;

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "SystemUpdatePolicy__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  SystemUpdatePolicy() : super.fromRef(_ctor().object);

  static final _createAutomaticInstallPolicy =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "SystemUpdatePolicy__createAutomaticInstallPolicy")
          .asFunction<jni.JniResult Function()>();

  /// from: static public android.app.admin.SystemUpdatePolicy createAutomaticInstallPolicy()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a policy object and set it to install update automatically as soon as one is
  /// available.
  ///@see \#TYPE_INSTALL_AUTOMATIC
  static SystemUpdatePolicy createAutomaticInstallPolicy() =>
      SystemUpdatePolicy.fromRef(_createAutomaticInstallPolicy().object);

  static final _createWindowedInstallPolicy = jniLookup<
              ffi.NativeFunction<jni.JniResult Function(ffi.Int32, ffi.Int32)>>(
          "SystemUpdatePolicy__createWindowedInstallPolicy")
      .asFunction<jni.JniResult Function(int, int)>();

  /// from: static public android.app.admin.SystemUpdatePolicy createWindowedInstallPolicy(int startTime, int endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a policy object and set it to: new system update will only be installed automatically
  /// when the system clock is inside a daily maintenance window. If the start and end times are
  /// the same, the window is considered to include the <i>whole 24 hours</i>. That is, updates can
  /// install at any time. If start time is later than end time, the window is considered spanning
  /// midnight (i.e. the end time denotes a time on the next day). The maintenance window will last
  /// for 30 days for any given update, after which the window will no longer be effective and
  /// the pending update will be made available for manual installation as if no system update
  /// policy were set on the device. See \#TYPE_INSTALL_WINDOWED for the details of this
  /// policy's behavior.
  ///@param startTime the start of the maintenance window, measured as the number of minutes from
  ///            midnight in the device's local time. Must be in the range of [0, 1440).
  ///@param endTime the end of the maintenance window, measured as the number of minutes from
  ///            midnight in the device's local time. Must be in the range of [0, 1440).
  ///@throws IllegalArgumentException If the {@code startTime} or {@code endTime} isn't in the
  ///            accepted range.
  ///@return The configured policy.
  ///@see \#TYPE_INSTALL_WINDOWED
  static SystemUpdatePolicy createWindowedInstallPolicy(
          int startTime, int endTime) =>
      SystemUpdatePolicy.fromRef(
          _createWindowedInstallPolicy(startTime, endTime).object);

  static final _createPostponeInstallPolicy =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "SystemUpdatePolicy__createPostponeInstallPolicy")
          .asFunction<jni.JniResult Function()>();

  /// from: static public android.app.admin.SystemUpdatePolicy createPostponeInstallPolicy()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a policy object and set it to block installation for a maximum period of 30 days.
  /// To learn more about this policy's behavior, see \#TYPE_POSTPONE.
  ///
  /// __Note: __ security updates (e.g. monthly security patches) will <i>not</i> be affected
  /// by this policy.
  ///@see \#TYPE_POSTPONE
  static SystemUpdatePolicy createPostponeInstallPolicy() =>
      SystemUpdatePolicy.fromRef(_createPostponeInstallPolicy().object);

  static final _getPolicyType = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SystemUpdatePolicy__getPolicyType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getPolicyType()
  ///
  /// Returns the type of system update policy, or -1 if no policy has been set.
  ///@return The policy type or -1 if the type isn't set.
  ///
  /// Value is android.app.admin.SystemUpdatePolicy\#TYPE_INSTALL_AUTOMATIC, android.app.admin.SystemUpdatePolicy\#TYPE_INSTALL_WINDOWED, or android.app.admin.SystemUpdatePolicy\#TYPE_POSTPONE
  int getPolicyType() => _getPolicyType(reference).integer;

  static final _getInstallWindowStart = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SystemUpdatePolicy__getInstallWindowStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getInstallWindowStart()
  ///
  /// Get the start of the maintenance window.
  ///@return the start of the maintenance window measured as the number of minutes from midnight,
  /// or -1 if the policy does not have a maintenance window.
  int getInstallWindowStart() => _getInstallWindowStart(reference).integer;

  static final _getInstallWindowEnd = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SystemUpdatePolicy__getInstallWindowEnd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getInstallWindowEnd()
  ///
  /// Get the end of the maintenance window.
  ///@return the end of the maintenance window measured as the number of minutes from midnight,
  /// or -1 if the policy does not have a maintenance window.
  int getInstallWindowEnd() => _getInstallWindowEnd(reference).integer;

  static final _setFreezePeriods = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "SystemUpdatePolicy__setFreezePeriods")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.admin.SystemUpdatePolicy setFreezePeriods(java.util.List<android.app.admin.FreezePeriod> freezePeriods)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Configure a list of freeze periods on top of the current policy. When the device's clock is
  /// within any of the freeze periods, all incoming system updates including security patches will
  /// be blocked and cannot be installed. When the device is outside the freeze periods, the normal
  /// policy behavior will apply.
  ///
  /// Each individual freeze period is allowed to be at most 90 days long, and adjacent freeze
  /// periods need to be at least 60 days apart. Also, the list of freeze periods should not
  /// contain duplicates or overlap with each other. If any of these conditions is not met, a
  /// ValidationFailedException will be thrown.
  ///
  /// Handling of leap year: we ignore leap years in freeze period calculations, in particular,
  /// <ul>
  /// <li>When a freeze period is defined, February 29th is disregarded so even though a freeze
  /// period can be specified to start or end on February 29th, it will be treated as if the period
  /// started or ended on February 28th.</li>
  /// <li>When applying freeze period behavior to the device, a system clock of February 29th is
  /// treated as if it were February 28th</li>
  /// <li>When calculating the number of days of a freeze period or separation between two freeze
  /// periods, February 29th is also ignored and not counted as one day.</li>
  /// </ul>
  ///@param freezePeriods the list of freeze periods
  ///@throws ValidationFailedException if the supplied freeze periods do not meet the
  ///         requirement set above
  ///@return this instance
  SystemUpdatePolicy setFreezePeriods(jni.JniObject freezePeriods) =>
      SystemUpdatePolicy.fromRef(
          _setFreezePeriods(reference, freezePeriods.reference).object);

  static final _getFreezePeriods = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SystemUpdatePolicy__getFreezePeriods")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.admin.FreezePeriod> getFreezePeriods()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of freeze periods previously set on this system update policy object.
  ///@return the list of freeze periods, or an empty list if none was set.
  jni.JniObject getFreezePeriods() =>
      jni.JniObject.fromRef(_getFreezePeriods(reference).object);

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SystemUpdatePolicy__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SystemUpdatePolicy__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("SystemUpdatePolicy__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();
}

/// from: android.app.admin.SystemUpdatePolicy$ValidationFailedException
///
/// An exception class that represents various validation errors thrown from
/// SystemUpdatePolicy\#setFreezePeriods and
/// DevicePolicyManager\#setSystemUpdatePolicy
class SystemUpdatePolicy_ValidationFailedException extends jni.JniObject {
  SystemUpdatePolicy_ValidationFailedException.fromRef(
      ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_SystemUpdatePolicy_ValidationFailedException__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.admin.SystemUpdatePolicy.ValidationFailedException> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  /// from: static public final int ERROR_COMBINED_FREEZE_PERIOD_TOO_CLOSE
  ///
  /// The device has been in a freeze period and some new freeze period to be set is less
  /// than 60 days from the end of the last freeze period the device went through.
  static const ERROR_COMBINED_FREEZE_PERIOD_TOO_CLOSE = 6;

  /// from: static public final int ERROR_COMBINED_FREEZE_PERIOD_TOO_LONG
  ///
  /// The device has been in a freeze period and when combining with the new freeze period
  /// to be set, it will result in the total freeze period being longer than 90 days.
  static const ERROR_COMBINED_FREEZE_PERIOD_TOO_LONG = 5;

  /// from: static public final int ERROR_DUPLICATE_OR_OVERLAP
  ///
  /// The freeze periods contains duplicates, periods that overlap with each
  /// other or periods whose start and end joins.
  static const ERROR_DUPLICATE_OR_OVERLAP = 2;

  /// from: static public final int ERROR_NEW_FREEZE_PERIOD_TOO_CLOSE
  ///
  /// There exists some freeze period which starts within 60 days of the preceding period's
  /// end time.
  static const ERROR_NEW_FREEZE_PERIOD_TOO_CLOSE = 4;

  /// from: static public final int ERROR_NEW_FREEZE_PERIOD_TOO_LONG
  ///
  /// There exists at least one freeze period whose length exceeds 90 days.
  static const ERROR_NEW_FREEZE_PERIOD_TOO_LONG = 3;

  /// from: static public final int ERROR_UNKNOWN
  ///
  /// Validation failed with unknown error.
  static const ERROR_UNKNOWN = 1;

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "SystemUpdatePolicy_ValidationFailedException__ctor")
      .asFunction<jni.JniResult Function(int, ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(int errorCode, java.lang.String message)
  SystemUpdatePolicy_ValidationFailedException(
      int errorCode, jni.JniString message)
      : super.fromRef(_ctor(errorCode, message.reference).object);

  static final _getErrorCode = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SystemUpdatePolicy_ValidationFailedException__getErrorCode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getErrorCode()
  ///
  /// Returns the type of validation error associated with this exception.
  ///@return Value is android.app.admin.SystemUpdatePolicy.ValidationFailedException.ERROR_NONE, android.app.admin.SystemUpdatePolicy.ValidationFailedException\#ERROR_DUPLICATE_OR_OVERLAP, android.app.admin.SystemUpdatePolicy.ValidationFailedException\#ERROR_NEW_FREEZE_PERIOD_TOO_LONG, android.app.admin.SystemUpdatePolicy.ValidationFailedException\#ERROR_NEW_FREEZE_PERIOD_TOO_CLOSE, android.app.admin.SystemUpdatePolicy.ValidationFailedException\#ERROR_COMBINED_FREEZE_PERIOD_TOO_LONG, android.app.admin.SystemUpdatePolicy.ValidationFailedException\#ERROR_COMBINED_FREEZE_PERIOD_TOO_CLOSE, or android.app.admin.SystemUpdatePolicy.ValidationFailedException\#ERROR_UNKNOWN
  int getErrorCode() => _getErrorCode(reference).integer;

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SystemUpdatePolicy_ValidationFailedException__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "SystemUpdatePolicy_ValidationFailedException__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();
}
