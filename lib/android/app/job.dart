// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_element

import "dart:ffi" as ffi;
import "package:jni/jni.dart" as jni;

import "../../android/os.dart" as os_;

import "../../android/content.dart" as content_;

import "../app.dart" as app_;
import "../../_init.dart" show jniLookup;

/// from: android.app.job.JobInfo
///
/// Container of data passed to the android.app.job.JobScheduler fully encapsulating the
/// parameters required to schedule work against the calling application. These are constructed
/// using the JobInfo.Builder.
/// You must specify at least one sort of constraint on the JobInfo object that you are creating.
/// The goal here is to provide the scheduler with high-level semantics about the work you want to
/// accomplish. Doing otherwise with throw an exception in your app.
class JobInfo extends jni.JniObject {
  JobInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int BACKOFF_POLICY_EXPONENTIAL
  ///
  /// Exponentially back-off a failed job. See
  /// android.app.job.JobInfo.Builder\#setBackoffCriteria(long, int)
  ///
  /// retry_time(current_time, num_failures) =
  ///     current_time + initial_backoff_millis * 2 ^ (num_failures - 1), num_failures >= 1
  static const BACKOFF_POLICY_EXPONENTIAL = 1;

  /// from: static public final int BACKOFF_POLICY_LINEAR
  ///
  /// Linearly back-off a failed job. See
  /// android.app.job.JobInfo.Builder\#setBackoffCriteria(long, int)
  /// retry_time(current_time, num_failures) =
  ///     current_time + initial_backoff_millis * num_failures, num_failures >= 1
  static const BACKOFF_POLICY_LINEAR = 0;

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_job_JobInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.job.JobInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  /// from: static public final long DEFAULT_INITIAL_BACKOFF_MILLIS
  ///
  /// Amount of backoff a job has initially by default, in milliseconds.
  static const DEFAULT_INITIAL_BACKOFF_MILLIS = 30000;

  /// from: static public final long MAX_BACKOFF_DELAY_MILLIS
  ///
  /// Maximum backoff we allow for a job, in milliseconds.
  static const MAX_BACKOFF_DELAY_MILLIS = 18000000;

  /// from: static public final int NETWORK_BYTES_UNKNOWN
  ///
  /// Sentinel value indicating that bytes are unknown.
  static const NETWORK_BYTES_UNKNOWN = -1;

  /// from: static public final int NETWORK_TYPE_ANY
  ///
  /// This job requires network connectivity.
  static const NETWORK_TYPE_ANY = 1;

  /// from: static public final int NETWORK_TYPE_CELLULAR
  ///
  /// This job requires network connectivity that is a cellular network.
  static const NETWORK_TYPE_CELLULAR = 4;

  /// from: static public final int NETWORK_TYPE_METERED
  ///
  /// This job requires metered connectivity such as most cellular data
  /// networks.
  ///@deprecated Cellular networks may be unmetered, or Wi-Fi networks may be
  ///             metered, so this isn't a good way of selecting a specific
  ///             transport. Instead, use \#NETWORK_TYPE_CELLULAR or
  ///             android.net.NetworkRequest.Builder\#addTransportType(int)
  ///             if your job requires a specific network transport.
  static const NETWORK_TYPE_METERED = 4;

  /// from: static public final int NETWORK_TYPE_NONE
  ///
  /// Default.
  static const NETWORK_TYPE_NONE = 0;

  /// from: static public final int NETWORK_TYPE_NOT_ROAMING
  ///
  /// This job requires network connectivity that is not roaming.
  static const NETWORK_TYPE_NOT_ROAMING = 3;

  /// from: static public final int NETWORK_TYPE_UNMETERED
  ///
  /// This job requires network connectivity that is unmetered.
  static const NETWORK_TYPE_UNMETERED = 2;

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_job_JobInfo_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Parcel in)
  JobInfo(os_.Parcel in0) : super.fromRef(_ctor(in0.reference)) {
    jni.Jni.env.checkException();
  }

  static final _getMinPeriodMillis =
      jniLookup<ffi.NativeFunction<ffi.Int64 Function()>>(
              "android_app_job_JobInfo_getMinPeriodMillis")
          .asFunction<int Function()>();

  /// from: static public final long getMinPeriodMillis()
  ///
  /// Query the minimum interval allowed for periodic scheduled jobs.  Attempting
  /// to declare a smaller period that this when scheduling a job will result in a
  /// job that is still periodic, but will run with this effective period.
  ///@return The minimum available interval for scheduling periodic jobs, in milliseconds.
  static int getMinPeriodMillis() {
    final result__ = _getMinPeriodMillis();
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getMinFlexMillis =
      jniLookup<ffi.NativeFunction<ffi.Int64 Function()>>(
              "android_app_job_JobInfo_getMinFlexMillis")
          .asFunction<int Function()>();

  /// from: static public final long getMinFlexMillis()
  ///
  /// Query the minimum flex time allowed for periodic scheduled jobs.  Attempting
  /// to declare a shorter flex time than this when scheduling such a job will
  /// result in this amount as the effective flex time for the job.
  ///@return The minimum available flex time for scheduling periodic jobs, in milliseconds.
  static int getMinFlexMillis() {
    final result__ = _getMinFlexMillis();
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getId =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_getId")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getId()
  ///
  /// Unique job id associated with this application (uid).  This is the same job ID
  /// you supplied in the Builder constructor.
  int getId() {
    final result__ = _getId(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getExtras = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_job_JobInfo_getExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.PersistableBundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @see JobInfo.Builder\#setExtras(PersistableBundle)
  ///@return This value will never be {@code null}.
  os_.PersistableBundle getExtras() {
    final result__ = os_.PersistableBundle.fromRef(_getExtras(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getTransientExtras = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobInfo_getTransientExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getTransientExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @see JobInfo.Builder\#setTransientExtras(Bundle)
  ///@return This value will never be {@code null}.
  os_.Bundle getTransientExtras() {
    final result__ = os_.Bundle.fromRef(_getTransientExtras(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getClipData = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobInfo_getClipData")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ClipData getClipData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @see JobInfo.Builder\#setClipData(ClipData, int)
  ///@return This value may be {@code null}.
  content_.ClipData getClipData() {
    final result__ = content_.ClipData.fromRef(_getClipData(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getClipGrantFlags =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_getClipGrantFlags")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getClipGrantFlags()
  ///
  /// @see JobInfo.Builder\#setClipData(ClipData, int)
  int getClipGrantFlags() {
    final result__ = _getClipGrantFlags(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getService = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_job_JobInfo_getService")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getService()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Name of the service endpoint that will be called back into by the JobScheduler.
  ///@return This value will never be {@code null}.
  content_.ComponentName getService() {
    final result__ = content_.ComponentName.fromRef(_getService(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isRequireCharging =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_isRequireCharging")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isRequireCharging()
  ///
  /// @see JobInfo.Builder\#setRequiresCharging(boolean)
  bool isRequireCharging() {
    final result__ = _isRequireCharging(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isRequireBatteryNotLow =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_isRequireBatteryNotLow")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isRequireBatteryNotLow()
  ///
  /// @see JobInfo.Builder\#setRequiresBatteryNotLow(boolean)
  bool isRequireBatteryNotLow() {
    final result__ = _isRequireBatteryNotLow(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isRequireDeviceIdle =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_isRequireDeviceIdle")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isRequireDeviceIdle()
  ///
  /// @see JobInfo.Builder\#setRequiresDeviceIdle(boolean)
  bool isRequireDeviceIdle() {
    final result__ = _isRequireDeviceIdle(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isRequireStorageNotLow =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_isRequireStorageNotLow")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isRequireStorageNotLow()
  ///
  /// @see JobInfo.Builder\#setRequiresStorageNotLow(boolean)
  bool isRequireStorageNotLow() {
    final result__ = _isRequireStorageNotLow(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getTriggerContentUris = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobInfo_getTriggerContentUris")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.job.JobInfo.TriggerContentUri[] getTriggerContentUris()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Which content: URIs must change for the job to be scheduled.  Returns null
  /// if there are none required.
  ///@see JobInfo.Builder\#addTriggerContentUri(TriggerContentUri)
  jni.JniObject getTriggerContentUris() {
    final result__ = jni.JniObject.fromRef(_getTriggerContentUris(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getTriggerContentUpdateDelay =
      jniLookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_getTriggerContentUpdateDelay")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTriggerContentUpdateDelay()
  ///
  /// When triggering on content URI changes, this is the delay from when a change
  /// is detected until the job is scheduled.
  ///@see JobInfo.Builder\#setTriggerContentUpdateDelay(long)
  int getTriggerContentUpdateDelay() {
    final result__ = _getTriggerContentUpdateDelay(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getTriggerContentMaxDelay =
      jniLookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_getTriggerContentMaxDelay")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTriggerContentMaxDelay()
  ///
  /// When triggering on content URI changes, this is the maximum delay we will
  /// use before scheduling the job.
  ///@see JobInfo.Builder\#setTriggerContentMaxDelay(long)
  int getTriggerContentMaxDelay() {
    final result__ = _getTriggerContentMaxDelay(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getNetworkType =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_getNetworkType")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getNetworkType()
  ///
  /// Return the basic description of the kind of network this job requires.
  ///@deprecated This method attempts to map \#getRequiredNetwork()
  ///             into the set of simple constants, which results in a loss of
  ///             fidelity. Callers should move to using
  ///             \#getRequiredNetwork() directly.
  ///@see Builder\#setRequiredNetworkType(int)
  ///@return Value is android.app.job.JobInfo\#NETWORK_TYPE_NONE, android.app.job.JobInfo\#NETWORK_TYPE_ANY, android.app.job.JobInfo\#NETWORK_TYPE_UNMETERED, android.app.job.JobInfo\#NETWORK_TYPE_NOT_ROAMING, or android.app.job.JobInfo\#NETWORK_TYPE_CELLULAR
  int getNetworkType() {
    final result__ = _getNetworkType(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getRequiredNetwork = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobInfo_getRequiredNetwork")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.NetworkRequest getRequiredNetwork()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the detailed description of the kind of network this job requires,
  /// or {@code null} if no specific kind of network is required.
  ///@see Builder\#setRequiredNetwork(NetworkRequest)
  jni.JniObject getRequiredNetwork() {
    final result__ = jni.JniObject.fromRef(_getRequiredNetwork(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getEstimatedNetworkDownloadBytes =
      jniLookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_getEstimatedNetworkDownloadBytes")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getEstimatedNetworkDownloadBytes()
  ///
  /// Return the estimated size of download traffic that will be performed by
  /// this job, in bytes.
  ///
  /// Value is a non-negative number of bytes.
  ///@return Estimated size of download traffic, or
  ///         \#NETWORK_BYTES_UNKNOWN when unknown.
  /// Value is a non-negative number of bytes.
  ///@see Builder\#setEstimatedNetworkBytes(long, long)
  int getEstimatedNetworkDownloadBytes() {
    final result__ = _getEstimatedNetworkDownloadBytes(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getEstimatedNetworkUploadBytes =
      jniLookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_getEstimatedNetworkUploadBytes")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getEstimatedNetworkUploadBytes()
  ///
  /// Return the estimated size of upload traffic that will be performed by
  /// this job, in bytes.
  ///
  /// Value is a non-negative number of bytes.
  ///@return Estimated size of upload traffic, or
  ///         \#NETWORK_BYTES_UNKNOWN when unknown.
  /// Value is a non-negative number of bytes.
  ///@see Builder\#setEstimatedNetworkBytes(long, long)
  int getEstimatedNetworkUploadBytes() {
    final result__ = _getEstimatedNetworkUploadBytes(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getMinLatencyMillis =
      jniLookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_getMinLatencyMillis")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getMinLatencyMillis()
  ///
  /// Set for a job that does not recur periodically, to specify a delay after which the job
  /// will be eligible for execution. This value is not set if the job recurs periodically.
  ///@see JobInfo.Builder\#setMinimumLatency(long)
  int getMinLatencyMillis() {
    final result__ = _getMinLatencyMillis(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getMaxExecutionDelayMillis =
      jniLookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_getMaxExecutionDelayMillis")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getMaxExecutionDelayMillis()
  ///
  /// @see JobInfo.Builder\#setOverrideDeadline(long)
  int getMaxExecutionDelayMillis() {
    final result__ = _getMaxExecutionDelayMillis(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isPeriodic =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_isPeriodic")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isPeriodic()
  ///
  /// Track whether this job will repeat with a given period.
  ///@see JobInfo.Builder\#setPeriodic(long)
  ///@see JobInfo.Builder\#setPeriodic(long, long)
  bool isPeriodic() {
    final result__ = _isPeriodic(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isPersisted =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_isPersisted")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isPersisted()
  ///
  /// @see JobInfo.Builder\#setPersisted(boolean)
  bool isPersisted() {
    final result__ = _isPersisted(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getIntervalMillis =
      jniLookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_getIntervalMillis")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getIntervalMillis()
  ///
  /// Set to the interval between occurrences of this job. This value is __not__ set if the
  /// job does not recur periodically.
  ///@see JobInfo.Builder\#setPeriodic(long)
  ///@see JobInfo.Builder\#setPeriodic(long, long)
  int getIntervalMillis() {
    final result__ = _getIntervalMillis(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getFlexMillis =
      jniLookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_getFlexMillis")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getFlexMillis()
  ///
  /// Flex time for this job. Only valid if this is a periodic job.  The job can
  /// execute at any time in a window of flex length at the end of the period.
  ///@see JobInfo.Builder\#setPeriodic(long)
  ///@see JobInfo.Builder\#setPeriodic(long, long)
  int getFlexMillis() {
    final result__ = _getFlexMillis(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getInitialBackoffMillis =
      jniLookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_getInitialBackoffMillis")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getInitialBackoffMillis()
  ///
  /// The amount of time the JobScheduler will wait before rescheduling a failed job. This value
  /// will be increased depending on the backoff policy specified at job creation time. Defaults
  /// to 30 seconds, minimum is currently 10 seconds.
  ///@see JobInfo.Builder\#setBackoffCriteria(long, int)
  int getInitialBackoffMillis() {
    final result__ = _getInitialBackoffMillis(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getBackoffPolicy =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_getBackoffPolicy")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getBackoffPolicy()
  ///
  /// Return the backoff policy of this job.
  ///@see JobInfo.Builder\#setBackoffCriteria(long, int)
  ///@return Value is android.app.job.JobInfo\#BACKOFF_POLICY_LINEAR, or android.app.job.JobInfo\#BACKOFF_POLICY_EXPONENTIAL
  int getBackoffPolicy() {
    final result__ = _getBackoffPolicy(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isImportantWhileForeground =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_isImportantWhileForeground")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isImportantWhileForeground()
  ///
  /// @see JobInfo.Builder\#setImportantWhileForeground(boolean)
  bool isImportantWhileForeground() {
    final result__ = _isImportantWhileForeground(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isPrefetch =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_isPrefetch")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isPrefetch()
  ///
  /// @see JobInfo.Builder\#setPrefetch(boolean)
  bool isPrefetch() {
    final result__ = _isPrefetch(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_job_JobInfo_equals1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) {
    final result__ = _equals1(reference, o.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hashCode1 =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_hashCode1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    final result__ = _hashCode1(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_job_JobInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os_.Parcel out, int flags) {
    final result__ = _writeToParcel(reference, out.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_job_JobInfo_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.app.job.JobInfo$TriggerContentUri
///
/// Information about a content URI modification that a job would like to
/// trigger on.
class JobInfo_TriggerContentUri extends jni.JniObject {
  JobInfo_TriggerContentUri.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_job_JobInfo__TriggerContentUri_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.job.JobInfo.TriggerContentUri> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  /// from: static public final int FLAG_NOTIFY_FOR_DESCENDANTS
  ///
  /// Flag for trigger: also trigger if any descendants of the given URI change.
  /// Corresponds to the <var>notifyForDescendants</var> of
  /// android.content.ContentResolver\#registerContentObserver.
  static const FLAG_NOTIFY_FOR_DESCENDANTS = 1;

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_job_JobInfo__TriggerContentUri_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.net.Uri uri, int flags)
  ///
  /// Create a new trigger description.
  ///@param uri The URI to observe.  Must be non-null.
  /// This value must never be {@code null}.
  ///@param flags Flags for the observer.
  ///
  /// Value is either <code>0</code> or android.app.job.JobInfo.TriggerContentUri\#FLAG_NOTIFY_FOR_DESCENDANTS
  JobInfo_TriggerContentUri(jni.JniObject uri, int flags)
      : super.fromRef(_ctor(uri.reference, flags)) {
    jni.Jni.env.checkException();
  }

  static final _getUri = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobInfo__TriggerContentUri_getUri")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri getUri()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Uri this trigger was created for.
  jni.JniObject getUri() {
    final result__ = jni.JniObject.fromRef(_getUri(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getFlags =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo__TriggerContentUri_getFlags")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getFlags()
  ///
  /// Return the flags supplied for the trigger.
  ///@return Value is either <code>0</code> or android.app.job.JobInfo.TriggerContentUri\#FLAG_NOTIFY_FOR_DESCENDANTS
  int getFlags() {
    final result__ = _getFlags(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _equals1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobInfo__TriggerContentUri_equals1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) {
    final result__ = _equals1(reference, o.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hashCode1 =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo__TriggerContentUri_hashCode1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    final result__ = _hashCode1(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobInfo__TriggerContentUri_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_job_JobInfo__TriggerContentUri_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os_.Parcel out, int flags) {
    final result__ = _writeToParcel(reference, out.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.app.job.JobInfo$Builder
///
/// Builder class for constructing JobInfo objects.
class JobInfo_Builder extends jni.JniObject {
  JobInfo_Builder.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobInfo__Builder_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int jobId, android.content.ComponentName jobService)
  ///
  /// Initialize a new Builder to construct a JobInfo.
  ///@param jobId Application-provided id for this job. Subsequent calls to cancel, or
  /// jobs created with the same jobId, will update the pre-existing job with
  /// the same id.  This ID must be unique across all clients of the same uid
  /// (not just the same package).  You will want to make sure this is a stable
  /// id across app updates, so probably not based on a resource ID.
  ///@param jobService The endpoint that you implement that will receive the callback from the
  /// JobScheduler.
  ///
  /// This value must never be {@code null}.
  JobInfo_Builder(int jobId, content_.ComponentName jobService)
      : super.fromRef(_ctor(jobId, jobService.reference)) {
    jni.Jni.env.checkException();
  }

  static final _setExtras = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobInfo__Builder_setExtras")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.job.JobInfo.Builder setExtras(android.os.PersistableBundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set optional extras. This is persisted, so we only allow primitive types.
  ///@param extras Bundle containing extras you want the scheduler to hold on to for you.
  /// This value must never be {@code null}.
  ///@see JobInfo\#getExtras()
  JobInfo_Builder setExtras(os_.PersistableBundle extras) {
    final result__ =
        JobInfo_Builder.fromRef(_setExtras(reference, extras.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setTransientExtras = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobInfo__Builder_setTransientExtras")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.job.JobInfo.Builder setTransientExtras(android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set optional transient extras.
  ///
  /// Because setting this property is not compatible with persisted
  /// jobs, doing so will throw an java.lang.IllegalArgumentException when
  /// android.app.job.JobInfo.Builder\#build() is called.
  ///
  ///@param extras Bundle containing extras you want the scheduler to hold on to for you.
  /// This value must never be {@code null}.
  ///@see JobInfo\#getTransientExtras()
  JobInfo_Builder setTransientExtras(os_.Bundle extras) {
    final result__ = JobInfo_Builder.fromRef(
        _setTransientExtras(reference, extras.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setClipData = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_job_JobInfo__Builder_setClipData")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.job.JobInfo.Builder setClipData(android.content.ClipData clip, int grantFlags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a ClipData associated with this Job.
  ///
  /// The main purpose of providing a ClipData is to allow granting of
  /// URI permissions for data associated with the clip.  The exact kind
  /// of permission grant to perform is specified through <var>grantFlags</var>.
  ///
  /// If the ClipData contains items that are Intents, any
  /// grant flags in those Intents will be ignored.  Only flags provided as an argument
  /// to this method are respected, and will be applied to all Uri or
  /// Intent items in the clip (or sub-items of the clip).
  ///
  /// Because setting this property is not compatible with persisted
  /// jobs, doing so will throw an java.lang.IllegalArgumentException when
  /// android.app.job.JobInfo.Builder\#build() is called.
  ///
  ///@param clip The new clip to set.  May be null to clear the current clip.
  /// This value may be {@code null}.
  ///@param grantFlags The desired permissions to grant for any URIs.  This should be
  /// a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION,
  /// android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION, and
  /// android.content.Intent\#FLAG_GRANT_PREFIX_URI_PERMISSION.
  ///@see JobInfo\#getClipData()
  ///@see JobInfo\#getClipGrantFlags()
  JobInfo_Builder setClipData(content_.ClipData clip, int grantFlags) {
    final result__ = JobInfo_Builder.fromRef(
        _setClipData(reference, clip.reference, grantFlags));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setRequiredNetworkType = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_app_job_JobInfo__Builder_setRequiredNetworkType")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.job.JobInfo.Builder setRequiredNetworkType(int networkType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set basic description of the kind of network your job requires. If
  /// you need more precise control over network capabilities, see
  /// \#setRequiredNetwork(NetworkRequest).
  ///
  /// If your job doesn't need a network connection, you don't need to call
  /// this method, as the default value is \#NETWORK_TYPE_NONE.
  ///
  /// Calling this method defines network as a strict requirement for your
  /// job. If the network requested is not available your job will never
  /// run. See \#setOverrideDeadline(long) to change this behavior.
  /// Calling this method will override any requirements previously defined
  /// by \#setRequiredNetwork(NetworkRequest); you typically only
  /// want to call one of these methods.
  /// <p class="note">
  /// When your job executes in
  /// JobService\#onStartJob(JobParameters), be sure to use the
  /// specific network returned by JobParameters\#getNetwork(),
  /// otherwise you'll use the default network which may not meet this
  /// constraint.
  ///@see \#setRequiredNetwork(NetworkRequest)
  ///@see JobInfo\#getNetworkType()
  ///@see JobParameters\#getNetwork()
  ///@param networkType Value is android.app.job.JobInfo\#NETWORK_TYPE_NONE, android.app.job.JobInfo\#NETWORK_TYPE_ANY, android.app.job.JobInfo\#NETWORK_TYPE_UNMETERED, android.app.job.JobInfo\#NETWORK_TYPE_NOT_ROAMING, or android.app.job.JobInfo\#NETWORK_TYPE_CELLULAR
  JobInfo_Builder setRequiredNetworkType(int networkType) {
    final result__ = JobInfo_Builder.fromRef(
        _setRequiredNetworkType(reference, networkType));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setRequiredNetwork = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobInfo__Builder_setRequiredNetwork")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.job.JobInfo.Builder setRequiredNetwork(android.net.NetworkRequest networkRequest)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set detailed description of the kind of network your job requires.
  ///
  /// If your job doesn't need a network connection, you don't need to call
  /// this method, as the default is {@code null}.
  ///
  /// Calling this method defines network as a strict requirement for your
  /// job. If the network requested is not available your job will never
  /// run. See \#setOverrideDeadline(long) to change this behavior.
  /// Calling this method will override any requirements previously defined
  /// by \#setRequiredNetworkType(int); you typically only want to
  /// call one of these methods.
  /// <p class="note">
  /// When your job executes in
  /// JobService\#onStartJob(JobParameters), be sure to use the
  /// specific network returned by JobParameters\#getNetwork(),
  /// otherwise you'll use the default network which may not meet this
  /// constraint.
  ///@param networkRequest The detailed description of the kind of network
  ///            this job requires, or {@code null} if no specific kind of
  ///            network is required. Defining a NetworkSpecifier
  ///            is only supported for jobs that aren't persisted.
  /// This value may be {@code null}.
  ///@see \#setRequiredNetworkType(int)
  ///@see JobInfo\#getRequiredNetwork()
  ///@see JobParameters\#getNetwork()
  JobInfo_Builder setRequiredNetwork(jni.JniObject networkRequest) {
    final result__ = JobInfo_Builder.fromRef(
        _setRequiredNetwork(reference, networkRequest.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setEstimatedNetworkBytes = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int64, ffi.Int64)>>(
          "android_app_job_JobInfo__Builder_setEstimatedNetworkBytes")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.app.job.JobInfo.Builder setEstimatedNetworkBytes(long downloadBytes, long uploadBytes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the estimated size of network traffic that will be performed by
  /// this job, in bytes.
  ///
  /// Apps are encouraged to provide values that are as accurate as
  /// possible, but when the exact size isn't available, an
  /// order-of-magnitude estimate can be provided instead. Here are some
  /// specific examples:
  /// <ul>
  /// <li>A job that is backing up a photo knows the exact size of that
  /// photo, so it should provide that size as the estimate.
  /// <li>A job that refreshes top news stories wouldn't know an exact
  /// size, but if the size is expected to be consistently around 100KB, it
  /// can provide that order-of-magnitude value as the estimate.
  /// <li>A job that synchronizes email could end up using an extreme range
  /// of data, from under 1KB when nothing has changed, to dozens of MB
  /// when there are new emails with attachments. Jobs that cannot provide
  /// reasonable estimates should use the sentinel value
  /// JobInfo\#NETWORK_BYTES_UNKNOWN.
  /// </ul>
  /// Note that the system may choose to delay jobs with large network
  /// usage estimates when the device has a poor network connection, in
  /// order to save battery.
  ///
  /// The values provided here only reflect the traffic that will be
  /// performed by the base job; if you're using JobWorkItem then
  /// you also need to define the network traffic used by each work item
  /// when constructing them.
  ///@param downloadBytes The estimated size of network traffic that will
  ///            be downloaded by this job, in bytes.
  /// Value is a non-negative number of bytes.
  ///@param uploadBytes The estimated size of network traffic that will be
  ///            uploaded by this job, in bytes.
  /// Value is a non-negative number of bytes.
  ///@see JobInfo\#getEstimatedNetworkDownloadBytes()
  ///@see JobInfo\#getEstimatedNetworkUploadBytes()
  ///@see JobWorkItem\#JobWorkItem(android.content.Intent, long, long)
  JobInfo_Builder setEstimatedNetworkBytes(int downloadBytes, int uploadBytes) {
    final result__ = JobInfo_Builder.fromRef(
        _setEstimatedNetworkBytes(reference, downloadBytes, uploadBytes));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setRequiresCharging = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_job_JobInfo__Builder_setRequiresCharging")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.job.JobInfo.Builder setRequiresCharging(boolean requiresCharging)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify that to run this job, the device must be charging (or be a
  /// non-battery-powered device connected to permanent power, such as Android TV
  /// devices). This defaults to {@code false}.
  ///
  /// <p class="note">For purposes of running jobs, a battery-powered device
  /// "charging" is not quite the same as simply being connected to power.  If the
  /// device is so busy that the battery is draining despite a power connection, jobs
  /// with this constraint will _not_ run.  This can happen during some
  /// common use cases such as video chat, particularly if the device is plugged in
  /// to USB rather than to wall power.
  ///@param requiresCharging Pass {@code true} to require that the device be
  ///     charging in order to run the job.
  ///@see JobInfo\#isRequireCharging()
  JobInfo_Builder setRequiresCharging(bool requiresCharging) {
    final result__ = JobInfo_Builder.fromRef(
        _setRequiresCharging(reference, requiresCharging ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setRequiresBatteryNotLow = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_job_JobInfo__Builder_setRequiresBatteryNotLow")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.job.JobInfo.Builder setRequiresBatteryNotLow(boolean batteryNotLow)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify that to run this job, the device's battery level must not be low.
  /// This defaults to false.  If true, the job will only run when the battery level
  /// is not low, which is generally the point where the user is given a "low battery"
  /// warning.
  ///@param batteryNotLow Whether or not the device's battery level must not be low.
  ///@see JobInfo\#isRequireBatteryNotLow()
  JobInfo_Builder setRequiresBatteryNotLow(bool batteryNotLow) {
    final result__ = JobInfo_Builder.fromRef(
        _setRequiresBatteryNotLow(reference, batteryNotLow ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setRequiresDeviceIdle = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_job_JobInfo__Builder_setRequiresDeviceIdle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.job.JobInfo.Builder setRequiresDeviceIdle(boolean requiresDeviceIdle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// When set {@code true}, ensure that this job will not run if the device is in active use.
  /// The default state is {@code false}: that is, the for the job to be runnable even when
  /// someone is interacting with the device.
  ///
  /// This state is a loose definition provided by the system. In general, it means that
  /// the device is not currently being used interactively, and has not been in use for some
  /// time. As such, it is a good time to perform resource heavy jobs. Bear in mind that
  /// battery usage will still be attributed to your application, and surfaced to the user in
  /// battery stats.
  ///
  ///
  /// <p class="note">Despite the similar naming, this job constraint is _not_
  /// related to the system's "device idle" or "doze" states.  This constraint only
  /// determines whether a job is allowed to run while the device is directly in use.
  ///@param requiresDeviceIdle Pass {@code true} to prevent the job from running
  ///     while the device is being used interactively.
  ///@see JobInfo\#isRequireDeviceIdle()
  JobInfo_Builder setRequiresDeviceIdle(bool requiresDeviceIdle) {
    final result__ = JobInfo_Builder.fromRef(
        _setRequiresDeviceIdle(reference, requiresDeviceIdle ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setRequiresStorageNotLow = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_job_JobInfo__Builder_setRequiresStorageNotLow")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.job.JobInfo.Builder setRequiresStorageNotLow(boolean storageNotLow)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify that to run this job, the device's available storage must not be low.
  /// This defaults to false.  If true, the job will only run when the device is not
  /// in a low storage state, which is generally the point where the user is given a
  /// "low storage" warning.
  ///@param storageNotLow Whether or not the device's available storage must not be low.
  ///@see JobInfo\#isRequireStorageNotLow()
  JobInfo_Builder setRequiresStorageNotLow(bool storageNotLow) {
    final result__ = JobInfo_Builder.fromRef(
        _setRequiresStorageNotLow(reference, storageNotLow ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _addTriggerContentUri = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobInfo__Builder_addTriggerContentUri")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.job.JobInfo.Builder addTriggerContentUri(android.app.job.JobInfo.TriggerContentUri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a new content: URI that will be monitored with a
  /// android.database.ContentObserver, and will cause the job to execute if changed.
  /// If you have any trigger content URIs associated with a job, it will not execute until
  /// there has been a change report for one or more of them.
  ///
  /// Note that trigger URIs can not be used in combination with
  /// \#setPeriodic(long) or \#setPersisted(boolean).  To continually monitor
  /// for content changes, you need to schedule a new JobInfo observing the same URIs
  /// before you finish execution of the JobService handling the most recent changes.
  /// Following this pattern will ensure you do not lost any content changes: while your
  /// job is running, the system will continue monitoring for content changes, and propagate
  /// any it sees over to the next job you schedule.
  ///
  ///
  /// Because setting this property is not compatible with periodic or
  /// persisted jobs, doing so will throw an java.lang.IllegalArgumentException when
  /// android.app.job.JobInfo.Builder\#build() is called.
  ///
  ///
  /// The following example shows how this feature can be used to monitor for changes
  /// in the photos on a device.
  ///
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/content/PhotosContentJob.java
  ///      job}
  ///@param uri The content: URI to monitor.
  /// This value must never be {@code null}.
  ///@see JobInfo\#getTriggerContentUris()
  JobInfo_Builder addTriggerContentUri(JobInfo_TriggerContentUri uri) {
    final result__ = JobInfo_Builder.fromRef(
        _addTriggerContentUri(reference, uri.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setTriggerContentUpdateDelay = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "android_app_job_JobInfo__Builder_setTriggerContentUpdateDelay")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.job.JobInfo.Builder setTriggerContentUpdateDelay(long durationMs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the delay (in milliseconds) from when a content change is detected until
  /// the job is scheduled.  If there are more changes during that time, the delay
  /// will be reset to start at the time of the most recent change.
  ///@param durationMs Delay after most recent content change, in milliseconds.
  ///@see JobInfo\#getTriggerContentUpdateDelay()
  JobInfo_Builder setTriggerContentUpdateDelay(int durationMs) {
    final result__ = JobInfo_Builder.fromRef(
        _setTriggerContentUpdateDelay(reference, durationMs));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setTriggerContentMaxDelay = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "android_app_job_JobInfo__Builder_setTriggerContentMaxDelay")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.job.JobInfo.Builder setTriggerContentMaxDelay(long durationMs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the maximum total delay (in milliseconds) that is allowed from the first
  /// time a content change is detected until the job is scheduled.
  ///@param durationMs Delay after initial content change, in milliseconds.
  ///@see JobInfo\#getTriggerContentMaxDelay()
  JobInfo_Builder setTriggerContentMaxDelay(int durationMs) {
    final result__ = JobInfo_Builder.fromRef(
        _setTriggerContentMaxDelay(reference, durationMs));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setPeriodic = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_app_job_JobInfo__Builder_setPeriodic")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.job.JobInfo.Builder setPeriodic(long intervalMillis)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify that this job should recur with the provided interval, not more than once per
  /// period. You have no control over when within this interval this job will be executed,
  /// only the guarantee that it will be executed at most once within this interval.
  /// Setting this function on the builder with \#setMinimumLatency(long) or
  /// \#setOverrideDeadline(long) will result in an error.
  ///@param intervalMillis Millisecond interval for which this job will repeat.
  ///@see JobInfo\#getIntervalMillis()
  ///@see JobInfo\#getFlexMillis()
  JobInfo_Builder setPeriodic(int intervalMillis) {
    final result__ =
        JobInfo_Builder.fromRef(_setPeriodic(reference, intervalMillis));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setPeriodic1 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Int64)>>("android_app_job_JobInfo__Builder_setPeriodic1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.app.job.JobInfo.Builder setPeriodic(long intervalMillis, long flexMillis)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify that this job should recur with the provided interval and flex. The job can
  /// execute at any time in a window of flex length at the end of the period.
  ///@param intervalMillis Millisecond interval for which this job will repeat. A minimum
  ///                       value of \#getMinPeriodMillis() is enforced.
  ///@param flexMillis Millisecond flex for this job. Flex is clamped to be at least
  ///                   \#getMinFlexMillis() or 5 percent of the period, whichever is
  ///                   higher.
  ///@see JobInfo\#getIntervalMillis()
  ///@see JobInfo\#getFlexMillis()
  JobInfo_Builder setPeriodic1(int intervalMillis, int flexMillis) {
    final result__ = JobInfo_Builder.fromRef(
        _setPeriodic1(reference, intervalMillis, flexMillis));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setMinimumLatency = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "android_app_job_JobInfo__Builder_setMinimumLatency")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.job.JobInfo.Builder setMinimumLatency(long minLatencyMillis)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify that this job should be delayed by the provided amount of time.
  /// Because it doesn't make sense setting this property on a periodic job, doing so will
  /// throw an java.lang.IllegalArgumentException when
  /// android.app.job.JobInfo.Builder\#build() is called.
  ///@param minLatencyMillis Milliseconds before which this job will not be considered for
  ///                         execution.
  ///@see JobInfo\#getMinLatencyMillis()
  JobInfo_Builder setMinimumLatency(int minLatencyMillis) {
    final result__ = JobInfo_Builder.fromRef(
        _setMinimumLatency(reference, minLatencyMillis));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setOverrideDeadline = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "android_app_job_JobInfo__Builder_setOverrideDeadline")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.job.JobInfo.Builder setOverrideDeadline(long maxExecutionDelayMillis)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set deadline which is the maximum scheduling latency. The job will be run by this
  /// deadline even if other requirements are not met. Because it doesn't make sense setting
  /// this property on a periodic job, doing so will throw an
  /// java.lang.IllegalArgumentException when
  /// android.app.job.JobInfo.Builder\#build() is called.
  ///@see JobInfo\#getMaxExecutionDelayMillis()
  JobInfo_Builder setOverrideDeadline(int maxExecutionDelayMillis) {
    final result__ = JobInfo_Builder.fromRef(
        _setOverrideDeadline(reference, maxExecutionDelayMillis));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setBackoffCriteria = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int64, ffi.Int32)>>(
          "android_app_job_JobInfo__Builder_setBackoffCriteria")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.app.job.JobInfo.Builder setBackoffCriteria(long initialBackoffMillis, int backoffPolicy)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set up the back-off/retry policy.
  /// This defaults to some respectable values: {30 seconds, Exponential}. We cap back-off at
  /// 5hrs.
  /// Note that trying to set a backoff criteria for a job with
  /// \#setRequiresDeviceIdle(boolean) will throw an exception when you call build().
  /// This is because back-off typically does not make sense for these types of jobs. See
  /// android.app.job.JobService\#jobFinished(android.app.job.JobParameters, boolean)
  /// for more description of the return value for the case of a job executing while in idle
  /// mode.
  ///@param initialBackoffMillis Millisecond time interval to wait initially when job has
  ///                             failed.
  ///@see JobInfo\#getInitialBackoffMillis()
  ///@see JobInfo\#getBackoffPolicy()
  ///@param backoffPolicy Value is android.app.job.JobInfo\#BACKOFF_POLICY_LINEAR, or android.app.job.JobInfo\#BACKOFF_POLICY_EXPONENTIAL
  JobInfo_Builder setBackoffCriteria(
      int initialBackoffMillis, int backoffPolicy) {
    final result__ = JobInfo_Builder.fromRef(
        _setBackoffCriteria(reference, initialBackoffMillis, backoffPolicy));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setImportantWhileForeground = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_app_job_JobInfo__Builder_setImportantWhileForeground")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.job.JobInfo.Builder setImportantWhileForeground(boolean importantWhileForeground)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Setting this to true indicates that this job is important while the scheduling app
  /// is in the foreground or on the temporary whitelist for background restrictions.
  /// This means that the system will relax doze restrictions on this job during this time.
  ///
  /// Apps should use this flag only for short jobs that are essential for the app to function
  /// properly in the foreground.
  ///
  /// Note that once the scheduling app is no longer whitelisted from background restrictions
  /// and in the background, or the job failed due to unsatisfied constraints,
  /// this job should be expected to behave like other jobs without this flag.
  ///@param importantWhileForeground whether to relax doze restrictions for this job when the
  ///                                 app is in the foreground. False by default.
  ///@see JobInfo\#isImportantWhileForeground()
  JobInfo_Builder setImportantWhileForeground(bool importantWhileForeground) {
    final result__ = JobInfo_Builder.fromRef(_setImportantWhileForeground(
        reference, importantWhileForeground ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setPrefetch = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_job_JobInfo__Builder_setPrefetch")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.job.JobInfo.Builder setPrefetch(boolean prefetch)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Setting this to true indicates that this job is designed to prefetch
  /// content that will make a material improvement to the experience of
  /// the specific user of this device. For example, fetching top headlines
  /// of interest to the current user.
  ///
  /// The system may use this signal to relax the network constraints you
  /// originally requested, such as allowing a
  /// JobInfo\#NETWORK_TYPE_UNMETERED job to run over a metered
  /// network when there is a surplus of metered data available. The system
  /// may also use this signal in combination with end user usage patterns
  /// to ensure data is prefetched before the user launches your app.
  ///@see JobInfo\#isPrefetch()
  JobInfo_Builder setPrefetch(bool prefetch) {
    final result__ =
        JobInfo_Builder.fromRef(_setPrefetch(reference, prefetch ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setPersisted = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_job_JobInfo__Builder_setPersisted")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.job.JobInfo.Builder setPersisted(boolean isPersisted)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether or not to persist this job across device reboots.
  ///
  /// Requires android.Manifest.permission\#RECEIVE_BOOT_COMPLETED
  ///@param isPersisted True to indicate that the job will be written to
  ///            disk and loaded at boot.
  ///@see JobInfo\#isPersisted()
  JobInfo_Builder setPersisted(bool isPersisted) {
    final result__ =
        JobInfo_Builder.fromRef(_setPersisted(reference, isPersisted ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _build = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobInfo__Builder_build")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.job.JobInfo build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The job object to hand to the JobScheduler. This object is immutable.
  JobInfo build() {
    final result__ = JobInfo.fromRef(_build(reference));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.app.job.JobParameters
///
/// Contains the parameters used to configure/identify your job. You do not create this object
/// yourself, instead it is handed in to your application by the System.
class JobParameters extends jni.JniObject {
  JobParameters.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_job_JobParameters_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.job.JobParameters> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_job_JobParameters_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Parcel in)
  JobParameters(os_.Parcel in0) : super.fromRef(_ctor(in0.reference)) {
    jni.Jni.env.checkException();
  }

  static final _getJobId =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobParameters_getJobId")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getJobId()
  ///
  /// @return The unique id of this job, specified at creation time.
  int getJobId() {
    final result__ = _getJobId(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getExtras = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobParameters_getExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.PersistableBundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The extras you passed in when constructing this job with
  /// android.app.job.JobInfo.Builder\#setExtras(android.os.PersistableBundle). This will
  /// never be null. If you did not set any extras this will be an empty bundle.
  os_.PersistableBundle getExtras() {
    final result__ = os_.PersistableBundle.fromRef(_getExtras(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getTransientExtras = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobParameters_getTransientExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getTransientExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The transient extras you passed in when constructing this job with
  /// android.app.job.JobInfo.Builder\#setTransientExtras(android.os.Bundle). This will
  /// never be null. If you did not set any extras this will be an empty bundle.
  os_.Bundle getTransientExtras() {
    final result__ = os_.Bundle.fromRef(_getTransientExtras(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getClipData = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobParameters_getClipData")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ClipData getClipData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The clip you passed in when constructing this job with
  /// android.app.job.JobInfo.Builder\#setClipData(ClipData, int). Will be null
  /// if it was not set.
  content_.ClipData getClipData() {
    final result__ = content_.ClipData.fromRef(_getClipData(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getClipGrantFlags =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobParameters_getClipGrantFlags")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getClipGrantFlags()
  ///
  /// @return The clip grant flags you passed in when constructing this job with
  /// android.app.job.JobInfo.Builder\#setClipData(ClipData, int). Will be 0
  /// if it was not set.
  int getClipGrantFlags() {
    final result__ = _getClipGrantFlags(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isOverrideDeadlineExpired =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobParameters_isOverrideDeadlineExpired")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isOverrideDeadlineExpired()
  ///
  /// For jobs with android.app.job.JobInfo.Builder\#setOverrideDeadline(long) set, this
  /// provides an easy way to tell whether the job is being executed due to the deadline
  /// expiring. Note: If the job is running because its deadline expired, it implies that its
  /// constraints will not be met.
  bool isOverrideDeadlineExpired() {
    final result__ = _isOverrideDeadlineExpired(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getTriggeredContentUris = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobParameters_getTriggeredContentUris")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri[] getTriggeredContentUris()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// For jobs with android.app.job.JobInfo.Builder\#addTriggerContentUri set, this
  /// reports which URIs have triggered the job.  This will be null if either no URIs have
  /// triggered it (it went off due to a deadline or other reason), or the number of changed
  /// URIs is too large to report.  Whether or not the number of URIs is too large, you can
  /// always use \#getTriggeredContentAuthorities() to determine whether the job was
  /// triggered due to any content changes and the authorities they are associated with.
  jni.JniObject getTriggeredContentUris() {
    final result__ = jni.JniObject.fromRef(_getTriggeredContentUris(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getTriggeredContentAuthorities = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobParameters_getTriggeredContentAuthorities")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getTriggeredContentAuthorities()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// For jobs with android.app.job.JobInfo.Builder\#addTriggerContentUri set, this
  /// reports which content authorities have triggered the job.  It will only be null if no
  /// authorities have triggered it -- that is, the job executed for some other reason, such
  /// as a deadline expiring.  If this is non-null, you can use \#getTriggeredContentUris()
  /// to retrieve the details of which URIs changed (as long as that has not exceeded the maximum
  /// number it can reported).
  jni.JniObject getTriggeredContentAuthorities() {
    final result__ =
        jni.JniObject.fromRef(_getTriggeredContentAuthorities(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getNetwork = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobParameters_getNetwork")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Network getNetwork()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the network that should be used to perform any network requests
  /// for this job.
  ///
  /// Devices may have multiple active network connections simultaneously, or
  /// they may not have a default network route at all. To correctly handle all
  /// situations like this, your job should always use the network returned by
  /// this method instead of implicitly using the default network route.
  ///
  /// Note that the system may relax the constraints you originally requested,
  /// such as allowing a JobInfo\#NETWORK_TYPE_UNMETERED job to run over
  /// a metered network when there is a surplus of metered data available.
  ///@return the network that should be used to perform any network requests
  ///         for this job, or {@code null} if this job didn't set any required
  ///         network type.
  ///@see JobInfo.Builder\#setRequiredNetworkType(int)
  jni.JniObject getNetwork() {
    final result__ = jni.JniObject.fromRef(_getNetwork(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _dequeueWork = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobParameters_dequeueWork")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.job.JobWorkItem dequeueWork()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Dequeue the next pending JobWorkItem from these JobParameters associated with their
  /// currently running job.  Calling this method when there is no more work available and all
  /// previously dequeued work has been completed will result in the system taking care of
  /// stopping the job for you --
  /// you should not call JobService\#jobFinished(JobParameters, boolean) yourself
  /// (otherwise you risk losing an upcoming JobWorkItem that is being enqueued at the same time).
  ///
  /// Once you are done with the JobWorkItem returned by this method, you must call
  /// \#completeWork(JobWorkItem) with it to inform the system that you are done
  /// executing the work.  The job will not be finished until all dequeued work has been
  /// completed.  You do not, however, have to complete each returned work item before deqeueing
  /// the next one -- you can use \#dequeueWork() multiple times before completing
  /// previous work if you want to process work in parallel, and you can complete the work
  /// in whatever order you want.
  ///
  ///
  /// If the job runs to the end of its available time period before all work has been
  /// completed, it will stop as normal.  You should return true from
  /// JobService\#onStopJob(JobParameters) in order to have the job rescheduled, and by
  /// doing so any pending as well as remaining uncompleted work will be re-queued
  /// for the next time the job runs.
  ///
  ///
  /// This example shows how to construct a JobService that will serially dequeue and
  /// process work that is available for it:
  ///
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/JobWorkService.java
  ///      service}
  ///@return Returns a new JobWorkItem if there is one pending, otherwise null.
  /// If null is returned, the system will also stop the job if all work has also been completed.
  /// (This means that for correct operation, you must always call dequeueWork() after you have
  /// completed other work, to check either for more work or allow the system to stop the job.)
  JobWorkItem dequeueWork() {
    final result__ = JobWorkItem.fromRef(_dequeueWork(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _completeWork = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobParameters_completeWork")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void completeWork(android.app.job.JobWorkItem work)
  ///
  /// Report the completion of executing a JobWorkItem previously returned by
  /// \#dequeueWork().  This tells the system you are done with the
  /// work associated with that item, so it will not be returned again.  Note that if this
  /// is the last work in the queue, completing it here will _not_ finish the overall
  /// job -- for that to happen, you still need to call \#dequeueWork()
  /// again.
  ///
  /// If you are enqueueing work into a job, you must call this method for each piece
  /// of work you process.  Do _not_ call
  /// JobService\#jobFinished(JobParameters, boolean)
  /// or else you can lose work in your queue.
  ///
  ///@param work The work you have completed processing, as previously returned by
  /// \#dequeueWork()
  ///
  /// This value must never be {@code null}.
  void completeWork(JobWorkItem work) {
    final result__ = _completeWork(reference, work.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobParameters_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_job_JobParameters_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) {
    final result__ = _writeToParcel(reference, dest.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.app.job.JobWorkItem
///
/// A unit of work that can be enqueued for a job using
/// JobScheduler\#enqueue JobScheduler.enqueue.  See
/// JobParameters\#dequeueWork() JobParameters.dequeueWork for more details.
class JobWorkItem extends jni.JniObject {
  JobWorkItem.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_app_job_JobWorkItem_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.job.JobWorkItem> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_app_job_JobWorkItem_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Intent intent)
  ///
  /// Create a new piece of work, which can be submitted to
  /// JobScheduler\#enqueue JobScheduler.enqueue.
  ///@param intent The general Intent describing this work.
  JobWorkItem(content_.Intent intent) : super.fromRef(_ctor(intent.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Int64)>>("android_app_job_JobWorkItem_ctor1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void <init>(android.content.Intent intent, long downloadBytes, long uploadBytes)
  ///
  /// Create a new piece of work, which can be submitted to
  /// JobScheduler\#enqueue JobScheduler.enqueue.
  ///
  /// See JobInfo.Builder\#setEstimatedNetworkBytes(long, long) for
  /// details about how to estimate network traffic.
  ///@param intent The general Intent describing this work.
  ///@param downloadBytes The estimated size of network traffic that will be
  ///            downloaded by this job work item, in bytes.
  /// Value is a non-negative number of bytes.
  ///@param uploadBytes The estimated size of network traffic that will be
  ///            uploaded by this job work item, in bytes.
  ///
  /// Value is a non-negative number of bytes.
  JobWorkItem.ctor1(content_.Intent intent, int downloadBytes, int uploadBytes)
      : super.fromRef(_ctor1(intent.reference, downloadBytes, uploadBytes)) {
    jni.Jni.env.checkException();
  }

  static final _getIntent = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobWorkItem_getIntent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent getIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Intent associated with this work.
  content_.Intent getIntent() {
    final result__ = content_.Intent.fromRef(_getIntent(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getEstimatedNetworkDownloadBytes =
      jniLookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobWorkItem_getEstimatedNetworkDownloadBytes")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getEstimatedNetworkDownloadBytes()
  ///
  /// Return the estimated size of download traffic that will be performed by
  /// this job, in bytes.
  ///
  /// Value is a non-negative number of bytes.
  ///@return Estimated size of download traffic, or
  ///         JobInfo\#NETWORK_BYTES_UNKNOWN when unknown.
  ///
  /// Value is a non-negative number of bytes.
  int getEstimatedNetworkDownloadBytes() {
    final result__ = _getEstimatedNetworkDownloadBytes(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getEstimatedNetworkUploadBytes =
      jniLookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobWorkItem_getEstimatedNetworkUploadBytes")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getEstimatedNetworkUploadBytes()
  ///
  /// Return the estimated size of upload traffic that will be performed by
  /// this job work item, in bytes.
  ///
  /// Value is a non-negative number of bytes.
  ///@return Estimated size of upload traffic, or
  ///         JobInfo\#NETWORK_BYTES_UNKNOWN when unknown.
  ///
  /// Value is a non-negative number of bytes.
  int getEstimatedNetworkUploadBytes() {
    final result__ = _getEstimatedNetworkUploadBytes(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDeliveryCount =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobWorkItem_getDeliveryCount")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getDeliveryCount()
  ///
  /// Return the count of the number of times this work item has been delivered
  /// to the job.  The value will be > 1 if it has been redelivered because the job
  /// was stopped or crashed while it had previously been delivered but before the
  /// job had called JobParameters\#completeWork JobParameters.completeWork for it.
  int getDeliveryCount() {
    final result__ = _getDeliveryCount(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobWorkItem_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobWorkItem_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_job_JobWorkItem_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os_.Parcel out, int flags) {
    final result__ = _writeToParcel(reference, out.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.app.job.JobScheduler
///
/// This is an API for scheduling various types of jobs against the framework that will be executed
/// in your application's own process.
///
/// See android.app.job.JobInfo for more description of the types of jobs that can be run
/// and how to construct them. You will construct these JobInfo objects and pass them to the
/// JobScheduler with \#schedule(JobInfo). When the criteria declared are met, the
/// system will execute this job on your application's android.app.job.JobService.
/// You identify the service component that implements the logic for your job when you
/// construct the JobInfo using
/// android.app.job.JobInfo.Builder\#JobInfo.Builder(int,android.content.ComponentName).
///
///
///
/// The framework will be intelligent about when it executes jobs, and attempt to batch
/// and defer them as much as possible. Typically if you don't specify a deadline on a job, it
/// can be run at any moment depending on the current state of the JobScheduler's internal queue.
///
/// While a job is running, the system holds a wakelock on behalf of your app.  For this reason,
/// you do not need to take any action to guarantee that the device stays awake for the
/// duration of the job.
///
///
/// You do not
/// instantiate this class directly; instead, retrieve it through
/// android.content.Context\#getSystemService Context.getSystemService(Context.JOB_SCHEDULER_SERVICE).
class JobScheduler extends jni.JniObject {
  JobScheduler.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int RESULT_FAILURE
  ///
  /// Returned from \#schedule(JobInfo) when an invalid parameter was supplied. This can occur
  /// if the run-time for your job is too short, or perhaps the system can't resolve the
  /// requisite JobService in your package.
  static const RESULT_FAILURE = 0;

  /// from: static public final int RESULT_SUCCESS
  ///
  /// Returned from \#schedule(JobInfo) if this job has been successfully scheduled.
  static const RESULT_SUCCESS = 1;

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_job_JobScheduler_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  JobScheduler() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _schedule = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobScheduler_schedule")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int schedule(android.app.job.JobInfo job)
  ///
  /// Schedule a job to be executed.  Will replace any currently scheduled job with the same
  /// ID with the new information in the JobInfo.  If a job with the given ID is currently
  /// running, it will be stopped.
  ///@param job The job you wish scheduled. See
  /// android.app.job.JobInfo.Builder JobInfo.Builder for more detail on the sorts of jobs
  /// you can schedule.
  /// This value must never be {@code null}.
  ///@return the result of the schedule request.
  ///
  /// Value is android.app.job.JobScheduler\#RESULT_FAILURE, or android.app.job.JobScheduler\#RESULT_SUCCESS
  int schedule(JobInfo job) {
    final result__ = _schedule(reference, job.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _enqueue = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobScheduler_enqueue")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int enqueue(android.app.job.JobInfo job, android.app.job.JobWorkItem work)
  ///
  /// Similar to \#schedule, but allows you to enqueue work for a new _or existing_
  /// job.  If a job with the same ID is already scheduled, it will be replaced with the
  /// new JobInfo, but any previously enqueued work will remain and be dispatched the
  /// next time it runs.  If a job with the same ID is already running, the new work will be
  /// enqueued for it.
  ///
  /// The work you enqueue is later retrieved through
  /// JobParameters\#dequeueWork() JobParameters.dequeueWork.  Be sure to see there
  /// about how to process work; the act of enqueueing work changes how you should handle the
  /// overall lifecycle of an executing job.
  ///
  ///
  /// It is strongly encouraged that you use the same JobInfo for all work you
  /// enqueue.  This will allow the system to optimally schedule work along with any pending
  /// and/or currently running work.  If the JobInfo changes from the last time the job was
  /// enqueued, the system will need to update the associated JobInfo, which can cause a disruption
  /// in execution.  In particular, this can result in any currently running job that is processing
  /// previous work to be stopped and restarted with the new JobInfo.
  ///
  ///
  /// It is recommended that you avoid using
  /// JobInfo.Builder\#setExtras(PersistableBundle) or
  /// JobInfo.Builder\#setTransientExtras(Bundle) with a JobInfo you are using to
  /// enqueue work.  The system will try to compare these extras with the previous JobInfo,
  /// but there are situations where it may get this wrong and count the JobInfo as changing.
  /// (That said, you should be relatively safe with a simple set of consistent data in these
  /// fields.)  You should never use JobInfo.Builder\#setClipData(ClipData, int) with
  /// work you are enqueue, since currently this will always be treated as a different JobInfo,
  /// even if the ClipData contents are exactly the same.
  ///
  ///@param job The job you wish to enqueue work for. See
  /// android.app.job.JobInfo.Builder JobInfo.Builder for more detail on the sorts of jobs
  /// you can schedule.
  /// This value must never be {@code null}.
  ///@param work New work to enqueue.  This will be available later when the job starts running.
  /// This value must never be {@code null}.
  ///@return the result of the enqueue request.
  ///
  /// Value is android.app.job.JobScheduler\#RESULT_FAILURE, or android.app.job.JobScheduler\#RESULT_SUCCESS
  int enqueue(JobInfo job, JobWorkItem work) {
    final result__ = _enqueue(reference, job.reference, work.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _cancel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_job_JobScheduler_cancel")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void cancel(int jobId)
  ///
  /// Cancel the specified job.  If the job is currently executing, it is stopped
  /// immediately and the return value from its JobService\#onStopJob(JobParameters)
  /// method is ignored.
  ///@param jobId unique identifier for the job to be canceled, as supplied to
  ///     JobInfo.Builder\#JobInfo.Builder(int, android.content.ComponentName)
  ///     JobInfo.Builder(int, android.content.ComponentName).
  void cancel(int jobId) {
    final result__ = _cancel(reference, jobId);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _cancelAll =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_app_job_JobScheduler_cancelAll")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void cancelAll()
  ///
  /// Cancel _all_ jobs that have been scheduled by the calling application.
  void cancelAll() {
    final result__ = _cancelAll(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getAllPendingJobs = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobScheduler_getAllPendingJobs")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.util.List<android.app.job.JobInfo> getAllPendingJobs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all jobs that have been scheduled by the calling application.
  ///@return a list of all of the app's scheduled jobs.  This includes jobs that are
  ///     currently started as well as those that are still waiting to run.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getAllPendingJobs() {
    final result__ = jni.JniObject.fromRef(_getAllPendingJobs(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPendingJob = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_app_job_JobScheduler_getPendingJob")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.job.JobInfo getPendingJob(int jobId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Look up the description of a scheduled job.
  ///@return The JobInfo description of the given scheduled job, or {@code null}
  ///     if the supplied job ID does not correspond to any job.
  JobInfo getPendingJob(int jobId) {
    final result__ = JobInfo.fromRef(_getPendingJob(reference, jobId));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.app.job.JobService
///
/// Entry point for the callback from the android.app.job.JobScheduler.
///
/// This is the base class that handles asynchronous requests that were previously scheduled. You
/// are responsible for overriding JobService\#onStartJob(JobParameters), which is where
/// you will implement your job logic.
///
/// This service executes each incoming job on a android.os.Handler running on your
/// application's main thread. This means that you __must__ offload your execution logic to
/// another thread/handler/android.os.AsyncTask of your choosing. Not doing so will result
/// in blocking any future callbacks from the JobManager - specifically
/// \#onStopJob(android.app.job.JobParameters), which is meant to inform you that the
/// scheduling requirements are no longer being met.
///
class JobService extends app_.Service {
  JobService.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String PERMISSION_BIND
  ///
  /// Job services must be protected with this permission:
  ///
  /// <pre class="prettyprint">
  ///     &\#60;service android:name="MyJobService"
  ///              android:permission="android.permission.BIND_JOB_SERVICE" &\#62;
  ///         ...
  ///     &\#60;/service&\#62;
  /// </pre>
  ///
  /// If a job service is declared in the manifest but not protected with this
  /// permission, that service will be ignored by the system.
  static const PERMISSION_BIND = "android.permission.BIND_JOB_SERVICE";

  static final _ctor2 =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_app_job_JobService_ctor2")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  JobService.ctor2() : super.fromRef(_ctor2()) {
    jni.Jni.env.checkException();
  }

  static final _onBind = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_app_job_JobService_onBind")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  os_.IBinder onBind(content_.Intent intent) {
    final result__ = os_.IBinder.fromRef(_onBind(reference, intent.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _jobFinished = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_job_JobService_jobFinished")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void jobFinished(android.app.job.JobParameters params, boolean wantsReschedule)
  ///
  /// Call this to inform the JobScheduler that the job has finished its work.  When the
  /// system receives this message, it releases the wakelock being held for the job.
  ///
  /// You can request that the job be scheduled again by passing {@code true} as
  /// the <code>wantsReschedule</code> parameter. This will apply back-off policy
  /// for the job; this policy can be adjusted through the
  /// android.app.job.JobInfo.Builder\#setBackoffCriteria(long, int) method
  /// when the job is originally scheduled.  The job's initial
  /// requirements are preserved when jobs are rescheduled, regardless of backed-off
  /// policy.
  /// <p class="note">
  /// A job running while the device is dozing will not be rescheduled with the normal back-off
  /// policy.  Instead, the job will be re-added to the queue and executed again during
  /// a future idle maintenance window.
  ///
  ///
  ///@param params The parameters identifying this job, as supplied to
  ///               the job in the \#onStartJob(JobParameters) callback.
  ///@param wantsReschedule {@code true} if this job should be rescheduled according
  ///     to the back-off criteria specified when it was first scheduled; {@code false}
  ///     otherwise.
  void jobFinished(JobParameters params, bool wantsReschedule) {
    final result__ =
        _jobFinished(reference, params.reference, wantsReschedule ? 1 : 0);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onStartJob = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobService_onStartJob")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean onStartJob(android.app.job.JobParameters params)
  ///
  /// Called to indicate that the job has begun executing.  Override this method with the
  /// logic for your job.  Like all other component lifecycle callbacks, this method executes
  /// on your application's main thread.
  ///
  /// Return {@code true} from this method if your job needs to continue running.  If you
  /// do this, the job remains active until you call
  /// \#jobFinished(JobParameters, boolean) to tell the system that it has completed
  /// its work, or until the job's required constraints are no longer satisfied.  For
  /// example, if the job was scheduled using
  /// JobInfo.Builder\#setRequiresCharging(boolean) setRequiresCharging(true),
  /// it will be immediately halted by the system if the user unplugs the device from power,
  /// the job's \#onStopJob(JobParameters) callback will be invoked, and the app
  /// will be expected to shut down all ongoing work connected with that job.
  ///
  /// The system holds a wakelock on behalf of your app as long as your job is executing.
  /// This wakelock is acquired before this method is invoked, and is not released until either
  /// you call \#jobFinished(JobParameters, boolean), or after the system invokes
  /// \#onStopJob(JobParameters) to notify your job that it is being shut down
  /// prematurely.
  ///
  /// Returning {@code false} from this method means your job is already finished.  The
  /// system's wakelock for the job will be released, and \#onStopJob(JobParameters)
  /// will not be invoked.
  ///@param params Parameters specifying info about this job, including the optional
  ///     extras configured with {@link JobInfo.Builder\#setExtras(android.os.PersistableBundle).
  ///     This object serves to identify this specific running job instance when calling
  ///     \#jobFinished(JobParameters, boolean).
  ///@return {@code true} if your service will continue running, using a separate thread
  ///     when appropriate.  {@code false} means that this job has completed its work.
  bool onStartJob(JobParameters params) {
    final result__ = _onStartJob(reference, params.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onStopJob = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobService_onStopJob")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean onStopJob(android.app.job.JobParameters params)
  ///
  /// This method is called if the system has determined that you must stop execution of your job
  /// even before you've had a chance to call \#jobFinished(JobParameters, boolean).
  ///
  /// This will happen if the requirements specified at schedule time are no longer met. For
  /// example you may have requested WiFi with
  /// android.app.job.JobInfo.Builder\#setRequiredNetworkType(int), yet while your
  /// job was executing the user toggled WiFi. Another example is if you had specified
  /// android.app.job.JobInfo.Builder\#setRequiresDeviceIdle(boolean), and the phone left its
  /// idle maintenance window. You are solely responsible for the behavior of your application
  /// upon receipt of this message; your app will likely start to misbehave if you ignore it.
  ///
  /// Once this method returns, the system releases the wakelock that it is holding on
  /// behalf of the job.
  ///
  ///@param params The parameters identifying this job, as supplied to
  ///               the job in the \#onStartJob(JobParameters) callback.
  ///@return {@code true} to indicate to the JobManager whether you'd like to reschedule
  /// this job based on the retry criteria provided at job creation-time; or {@code false}
  /// to end the job entirely.  Regardless of the value returned, your job must stop executing.
  bool onStopJob(JobParameters params) {
    final result__ = _onStopJob(reference, params.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.app.job.JobServiceEngine
///
/// Helper for implementing a android.app.Service that interacts with
/// JobScheduler.  This is not intended for use by regular applications, but
/// allows frameworks built on top of the platform to create their own
/// android.app.Service that interact with JobScheduler as well as
/// add in additional functionality.  If you just want to execute jobs normally, you
/// should instead be looking at JobService.
class JobServiceEngine extends jni.JniObject {
  JobServiceEngine.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobServiceEngine_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Service service)
  ///
  /// Create a new engine, ready for use.
  ///@param service The Service that is creating this engine and in which it will run.
  JobServiceEngine(app_.Service service)
      : super.fromRef(_ctor(service.reference)) {
    jni.Jni.env.checkException();
  }

  static final _getBinder = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobServiceEngine_getBinder")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.IBinder getBinder()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the engine's IPC interface that should be returned by
  /// Service\#onBind(Intent).
  os_.IBinder getBinder() {
    final result__ = os_.IBinder.fromRef(_getBinder(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onStartJob = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobServiceEngine_onStartJob")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean onStartJob(android.app.job.JobParameters params)
  ///
  /// Engine's report that a job has started.  See
  /// JobService\#onStartJob(JobParameters) JobService.onStartJob for more information.
  bool onStartJob(JobParameters params) {
    final result__ = _onStartJob(reference, params.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onStopJob = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_app_job_JobServiceEngine_onStopJob")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean onStopJob(android.app.job.JobParameters params)
  ///
  /// Engine's report that a job has stopped.  See
  /// JobService\#onStopJob(JobParameters) JobService.onStopJob for more information.
  bool onStopJob(JobParameters params) {
    final result__ = _onStopJob(reference, params.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _jobFinished = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_app_job_JobServiceEngine_jobFinished")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void jobFinished(android.app.job.JobParameters params, boolean needsReschedule)
  ///
  /// Call in to engine to report that a job has finished executing.  See
  /// JobService\#jobFinished(JobParameters, boolean)  JobService.jobFinished} for more
  /// information.
  void jobFinished(JobParameters params, bool needsReschedule) {
    final result__ =
        _jobFinished(reference, params.reference, needsReschedule ? 1 : 0);
    jni.Jni.env.checkException();
    return result__;
  }
}
