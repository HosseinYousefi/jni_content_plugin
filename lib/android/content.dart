// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_element

import "dart:ffi" as ffi;
import "package:jni/jni.dart" as jni;

import "../android/os.dart" as os_;

import "content/res.dart" as res_;

import "content/pm.dart" as pm_;
import "../_init.dart" show jniLookup;

/// from: android.content.ComponentCallbacks2
///
/// Extended ComponentCallbacks interface with a new callback for
/// finer-grained memory management. This interface is available in all application components
/// (android.app.Activity, android.app.Service,
/// ContentProvider, and android.app.Application).
///
/// You should implement \#onTrimMemory to incrementally release memory based on current
/// system constraints. Using this callback to release your resources helps provide a more
/// responsive system overall, but also directly benefits the user experience for
/// your app by allowing the system to keep your process alive longer. That is,
/// if you _don't_ trim your resources based on memory levels defined by this callback,
/// the system is more likely to kill your process while it is cached in the least-recently used
/// (LRU) list, thus requiring your app to restart and restore all state when the user returns to it.
///
/// The values provided by \#onTrimMemory do not represent a single linear progression of
/// memory limits, but provide you different types of clues about memory availability:
///
/// <ul>
/// <li>When your app is running:
///  <ol>
///  <li>\#TRIM_MEMORY_RUNNING_MODERATE <br>The device is beginning to run low on memory.
/// Your app is running and not killable.
///  <li>\#TRIM_MEMORY_RUNNING_LOW <br>The device is running much lower on memory.
/// Your app is running and not killable, but please release unused resources to improve system
/// performance (which directly impacts your app's performance).
///  <li>\#TRIM_MEMORY_RUNNING_CRITICAL <br>The device is running extremely low on memory.
/// Your app is not yet considered a killable process, but the system will begin killing
/// background processes if apps do not release resources, so you should release non-critical
/// resources now to prevent performance degradation.
///  </ol>
/// </li>
/// <li>When your app's visibility changes:
///  <ol>
///  <li>\#TRIM_MEMORY_UI_HIDDEN <br>Your app's UI is no longer visible, so this is a good
/// time to release large resources that are used only by your UI.
///  </ol>
/// </li>
/// <li>When your app's process resides in the background LRU list:
///  <ol>
///  <li>\#TRIM_MEMORY_BACKGROUND <br>The system is running low on memory and your process is
/// near the beginning of the LRU list. Although your app process is not at a high risk of being
/// killed, the system may already be killing processes in the LRU list, so you should release
/// resources that are easy to recover so your process will remain in the list and resume
/// quickly when the user returns to your app.
///  <li>\#TRIM_MEMORY_MODERATE <br>The system is running low on memory and your process is
/// near the middle of the LRU list. If the system becomes further constrained for memory, there's a
/// chance your process will be killed.
///  <li>\#TRIM_MEMORY_COMPLETE <br>The system is running low on memory and your process is
/// one of the first to be killed if the system does not recover memory now. You should release
/// absolutely everything that's not critical to resuming your app state.
///   To support API levels lower than 14, you can use the \#onLowMemory method as a
/// fallback that's roughly equivalent to the ComponentCallbacks2\#TRIM_MEMORY_COMPLETE level.
///  </li>
///  </ol>
/// <p class="note"><strong>Note:</strong> When the system begins
/// killing processes in the LRU list, although it primarily works bottom-up, it does give some
/// consideration to which processes are consuming more memory and will thus provide more gains in
/// memory if killed. So the less memory you consume while in the LRU list overall, the better
/// your chances are to remain in the list and be able to quickly resume.
///
/// </li>
/// </ul>
/// More information about the different stages of a process lifecycle (such as what it means
/// to be placed in the background LRU list) is provided in the <a href="{@docRoot}guide/components/processes-and-threads.html\#Lifecycle">Processes and Threads</a>
/// document.
class ComponentCallbacks2 extends jni.JniObject {
  ComponentCallbacks2.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int TRIM_MEMORY_BACKGROUND
  ///
  /// Level for \#onTrimMemory(int): the process has gone on to the
  /// LRU list.  This is a good opportunity to clean up resources that can
  /// efficiently and quickly be re-built if the user returns to the app.
  static const TRIM_MEMORY_BACKGROUND = 40;

  /// from: static public final int TRIM_MEMORY_COMPLETE
  ///
  /// Level for \#onTrimMemory(int): the process is nearing the end
  /// of the background LRU list, and if more memory isn't found soon it will
  /// be killed.
  static const TRIM_MEMORY_COMPLETE = 80;

  /// from: static public final int TRIM_MEMORY_MODERATE
  ///
  /// Level for \#onTrimMemory(int): the process is around the middle
  /// of the background LRU list; freeing memory can help the system keep
  /// other processes running later in the list for better overall performance.
  static const TRIM_MEMORY_MODERATE = 60;

  /// from: static public final int TRIM_MEMORY_RUNNING_CRITICAL
  ///
  /// Level for \#onTrimMemory(int): the process is not an expendable
  /// background process, but the device is running extremely low on memory
  /// and is about to not be able to keep any background processes running.
  /// Your running process should free up as many non-critical resources as it
  /// can to allow that memory to be used elsewhere.  The next thing that
  /// will happen after this is \#onLowMemory() called to report that
  /// nothing at all can be kept in the background, a situation that can start
  /// to notably impact the user.
  static const TRIM_MEMORY_RUNNING_CRITICAL = 15;

  /// from: static public final int TRIM_MEMORY_RUNNING_LOW
  ///
  /// Level for \#onTrimMemory(int): the process is not an expendable
  /// background process, but the device is running low on memory.
  /// Your running process should free up unneeded resources to allow that
  /// memory to be used elsewhere.
  static const TRIM_MEMORY_RUNNING_LOW = 10;

  /// from: static public final int TRIM_MEMORY_RUNNING_MODERATE
  ///
  /// Level for \#onTrimMemory(int): the process is not an expendable
  /// background process, but the device is running moderately low on memory.
  /// Your running process may want to release some unneeded resources for
  /// use elsewhere.
  static const TRIM_MEMORY_RUNNING_MODERATE = 5;

  /// from: static public final int TRIM_MEMORY_UI_HIDDEN
  ///
  /// Level for \#onTrimMemory(int): the process had been showing
  /// a user interface, and is no longer doing so.  Large allocations with
  /// the UI should be released at this point to allow memory to be better
  /// managed.
  static const TRIM_MEMORY_UI_HIDDEN = 20;

  static final _onTrimMemory = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_ComponentCallbacks2_onTrimMemory")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void onTrimMemory(int level)
  ///
  /// Called when the operating system has determined that it is a good
  /// time for a process to trim unneeded memory from its process.  This will
  /// happen for example when it goes in the background and there is not enough
  /// memory to keep as many background processes running as desired.  You
  /// should never compare to exact values of the level, since new intermediate
  /// values may be added -- you will typically want to compare if the value
  /// is greater or equal to a level you are interested in.
  ///
  /// To retrieve the processes current trim level at any point, you can
  /// use android.app.ActivityManager\#getMyMemoryState ActivityManager.getMyMemoryState(RunningAppProcessInfo).
  ///@param level The context of the trim, giving a hint of the amount of
  /// trimming the application may like to perform.
  ///
  /// Value is android.content.ComponentCallbacks2\#TRIM_MEMORY_COMPLETE, android.content.ComponentCallbacks2\#TRIM_MEMORY_MODERATE, android.content.ComponentCallbacks2\#TRIM_MEMORY_BACKGROUND, android.content.ComponentCallbacks2\#TRIM_MEMORY_UI_HIDDEN, android.content.ComponentCallbacks2\#TRIM_MEMORY_RUNNING_CRITICAL, android.content.ComponentCallbacks2\#TRIM_MEMORY_RUNNING_LOW, or android.content.ComponentCallbacks2\#TRIM_MEMORY_RUNNING_MODERATE
  void onTrimMemory(int level) {
    final result__ = _onTrimMemory(reference, level);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.ClipDescription
///
/// Meta-data describing the contents of a ClipData.  Provides enough
/// information to know if you can handle the ClipData, but not the data
/// itself.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using the clipboard framework, read the
/// <a href="{@docRoot}guide/topics/clipboard/copy-paste.html">Copy and Paste</a>
/// developer guide.
///
/// </div>
class ClipDescription extends jni.JniObject {
  ClipDescription.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_ClipDescription_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.ClipDescription> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  /// from: static public final java.lang.String MIMETYPE_TEXT_HTML
  ///
  /// The MIME type for a clip holding HTML text.
  static const MIMETYPE_TEXT_HTML = "text/html";

  /// from: static public final java.lang.String MIMETYPE_TEXT_INTENT
  ///
  /// The MIME type for a clip holding an Intent.
  static const MIMETYPE_TEXT_INTENT = "text/vnd.android.intent";

  /// from: static public final java.lang.String MIMETYPE_TEXT_PLAIN
  ///
  /// The MIME type for a clip holding plain text.
  static const MIMETYPE_TEXT_PLAIN = "text/plain";

  /// from: static public final java.lang.String MIMETYPE_TEXT_URILIST
  ///
  /// The MIME type for a clip holding one or more URIs.  This should be
  /// used for URIs that are meaningful to a user (such as an http: URI).
  /// It should _not_ be used for a content: URI that references some
  /// other piece of data; in that case the MIME type should be the type
  /// of the referenced data.
  static const MIMETYPE_TEXT_URILIST = "text/uri-list";

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipDescription_ctor")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.CharSequence label, java.lang.String[] mimeTypes)
  ///
  /// Create a new clip.
  ///@param label Label to show to the user describing this clip.
  ///@param mimeTypes An array of MIME types this data is available as.
  ClipDescription(jni.JniObject label, jni.JniObject mimeTypes)
      : super.fromRef(_ctor(label.reference, mimeTypes.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipDescription_ctor1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.ClipDescription o)
  ///
  /// Create a copy of a ClipDescription.
  ClipDescription.ctor1(ClipDescription o)
      : super.fromRef(_ctor1(o.reference)) {
    jni.Jni.env.checkException();
  }

  static final _compareMimeTypes = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipDescription_compareMimeTypes")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean compareMimeTypes(java.lang.String concreteType, java.lang.String desiredType)
  ///
  /// Helper to compare two MIME types, where one may be a pattern.
  ///@param concreteType A fully-specified MIME type.
  ///@param desiredType A desired MIME type that may be a pattern such as *&\#47;*.
  ///@return Returns true if the two MIME types match.
  static bool compareMimeTypes(
      jni.JniString concreteType, jni.JniString desiredType) {
    final result__ =
        _compareMimeTypes(concreteType.reference, desiredType.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getTimestamp =
      jniLookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ClipDescription_getTimestamp")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTimestamp()
  ///
  /// Return the timestamp at which the associated ClipData is copied to global clipboard
  /// in the System\#currentTimeMillis() time base.
  ///@return timestamp at which the associated ClipData is copied to global clipboard
  ///         or {@code 0} if it is not copied to clipboard.
  int getTimestamp() {
    final result__ = _getTimestamp(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getLabel = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipDescription_getLabel")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getLabel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the label for this clip.
  jni.JniObject getLabel() {
    final result__ = jni.JniObject.fromRef(_getLabel(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hasMimeType = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipDescription_hasMimeType")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasMimeType(java.lang.String mimeType)
  ///
  /// Check whether the clip description contains the given MIME type.
  ///@param mimeType The desired MIME type.  May be a pattern.
  ///@return Returns true if one of the MIME types in the clip description
  /// matches the desired MIME type, else false.
  bool hasMimeType(jni.JniString mimeType) {
    final result__ = _hasMimeType(reference, mimeType.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _filterMimeTypes = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipDescription_filterMimeTypes")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] filterMimeTypes(java.lang.String mimeType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Filter the clip description MIME types by the given MIME type.  Returns
  /// all MIME types in the clip that match the given MIME type.
  ///@param mimeType The desired MIME type.  May be a pattern.
  ///@return Returns an array of all matching MIME types.  If there are no
  /// matching MIME types, null is returned.
  jni.JniObject filterMimeTypes(jni.JniString mimeType) {
    final result__ =
        jni.JniObject.fromRef(_filterMimeTypes(reference, mimeType.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getMimeTypeCount =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ClipDescription_getMimeTypeCount")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getMimeTypeCount()
  ///
  /// Return the number of MIME types the clip is available in.
  int getMimeTypeCount() {
    final result__ = _getMimeTypeCount(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getMimeType = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_ClipDescription_getMimeType")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getMimeType(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return one of the possible clip MIME types.
  jni.JniString getMimeType(int index) {
    final result__ = jni.JniString.fromRef(_getMimeType(reference, index));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getExtras = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipDescription_getExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.PersistableBundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the clip description.
  ///@return the bundle containing extended data previously set with
  /// \#setExtras(PersistableBundle), or null if no extras have been set.
  ///@see \#setExtras(PersistableBundle)
  os_.PersistableBundle getExtras() {
    final result__ = os_.PersistableBundle.fromRef(_getExtras(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setExtras = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipDescription_setExtras")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExtras(android.os.PersistableBundle extras)
  ///
  /// Add extended data to the clip description.
  ///@see \#getExtras()
  void setExtras(os_.PersistableBundle extras) {
    final result__ = _setExtras(reference, extras.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipDescription_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ClipDescription_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_ClipDescription_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) {
    final result__ = _writeToParcel(reference, dest.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.ClipboardManager
///
/// Interface to the clipboard service, for placing and retrieving text in
/// the global clipboard.
///
///
/// The ClipboardManager API itself is very simple: it consists of methods
/// to atomically get and set the current primary clipboard data.  That data
/// is expressed as a ClipData object, which defines the protocol
/// for data exchange between applications.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using the clipboard framework, read the
/// <a href="{@docRoot}guide/topics/clipboard/copy-paste.html">Copy and Paste</a>
/// developer guide.
///
/// </div>
class ClipboardManager extends jni.JniObject {
  ClipboardManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_ClipboardManager_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  ClipboardManager() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _setPrimaryClip = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipboardManager_setPrimaryClip")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setPrimaryClip(android.content.ClipData clip)
  ///
  /// Sets the current primary clip on the clipboard.  This is the clip that
  /// is involved in normal cut and paste operations.
  ///@param clip The clipped data item to set.
  /// This value must never be {@code null}.
  ///@see \#getPrimaryClip()
  ///@see \#clearPrimaryClip()
  void setPrimaryClip(ClipData clip) {
    final result__ = _setPrimaryClip(reference, clip.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _clearPrimaryClip =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ClipboardManager_clearPrimaryClip")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void clearPrimaryClip()
  ///
  /// Clears any current primary clip on the clipboard.
  ///@see \#setPrimaryClip(ClipData)
  void clearPrimaryClip() {
    final result__ = _clearPrimaryClip(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPrimaryClip = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipboardManager_getPrimaryClip")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ClipData getPrimaryClip()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current primary clip on the clipboard.
  ///@see \#setPrimaryClip(ClipData)
  ///@return This value may be {@code null}.
  ClipData getPrimaryClip() {
    final result__ = ClipData.fromRef(_getPrimaryClip(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPrimaryClipDescription = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipboardManager_getPrimaryClipDescription")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ClipDescription getPrimaryClipDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a description of the current primary clip on the clipboard
  /// but not a copy of its data.
  ///@see \#setPrimaryClip(ClipData)
  ///@return This value may be {@code null}.
  ClipDescription getPrimaryClipDescription() {
    final result__ =
        ClipDescription.fromRef(_getPrimaryClipDescription(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hasPrimaryClip =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ClipboardManager_hasPrimaryClip")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasPrimaryClip()
  ///
  /// Returns true if there is currently a primary clip on the clipboard.
  bool hasPrimaryClip() {
    final result__ = _hasPrimaryClip(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _addPrimaryClipChangedListener = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipboardManager_addPrimaryClipChangedListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void addPrimaryClipChangedListener(android.content.ClipboardManager.OnPrimaryClipChangedListener what)
  void addPrimaryClipChangedListener(
      ClipboardManager_OnPrimaryClipChangedListener what) {
    final result__ = _addPrimaryClipChangedListener(reference, what.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _removePrimaryClipChangedListener = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipboardManager_removePrimaryClipChangedListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void removePrimaryClipChangedListener(android.content.ClipboardManager.OnPrimaryClipChangedListener what)
  void removePrimaryClipChangedListener(
      ClipboardManager_OnPrimaryClipChangedListener what) {
    final result__ =
        _removePrimaryClipChangedListener(reference, what.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getText = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipboardManager_getText")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Use \#getPrimaryClip() instead.  This retrieves
  /// the primary clip and tries to coerce it to a string.
  jni.JniObject getText() {
    final result__ = jni.JniObject.fromRef(_getText(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setText = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipboardManager_setText")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setText(java.lang.CharSequence text)
  ///
  /// @deprecated Use \#setPrimaryClip(ClipData) instead.  This
  /// creates a ClippedItem holding the given text and sets it as the
  /// primary clip.  It has no label or icon.
  void setText(jni.JniObject text) {
    final result__ = _setText(reference, text.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hasText =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ClipboardManager_hasText")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasText()
  ///
  /// @deprecated Use \#hasPrimaryClip() instead.
  bool hasText() {
    final result__ = _hasText(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.ClipboardManager$OnPrimaryClipChangedListener
///
/// Defines a listener callback that is invoked when the primary clip on the clipboard changes.
/// Objects that want to register a listener call
/// android.content.ClipboardManager\#addPrimaryClipChangedListener(OnPrimaryClipChangedListener) addPrimaryClipChangedListener() with an
/// object that implements OnPrimaryClipChangedListener.
class ClipboardManager_OnPrimaryClipChangedListener extends jni.JniObject {
  ClipboardManager_OnPrimaryClipChangedListener.fromRef(
      ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onPrimaryClipChanged = jniLookup<
              ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipboardManager__OnPrimaryClipChangedListener_onPrimaryClipChanged")
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onPrimaryClipChanged()
  ///
  /// Callback that is invoked by android.content.ClipboardManager when the primary
  /// clip changes.
  void onPrimaryClipChanged() {
    final result__ = _onPrimaryClipChanged(reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.ActivityNotFoundException
///
/// This exception is thrown when a call to Context\#startActivity or
/// one of its variants fails because an Activity can not be found to execute
/// the given Intent.
class ActivityNotFoundException extends jni.JniObject {
  ActivityNotFoundException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_ActivityNotFoundException_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ActivityNotFoundException() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ActivityNotFoundException_ctor1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String name)
  ActivityNotFoundException.ctor1(jni.JniString name)
      : super.fromRef(_ctor1(name.reference)) {
    jni.Jni.env.checkException();
  }
}

/// from: android.content.ContentResolver
///
/// This class provides applications access to the content model.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using a ContentResolver with content providers, read the
/// <a href="{@docRoot}guide/topics/providers/content-providers.html">Content Providers</a>
/// developer guide.
///
class ContentResolver extends jni.JniObject {
  ContentResolver.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ANY_CURSOR_ITEM_TYPE
  ///
  /// This is the Android platform's generic MIME type to match any MIME
  /// type of the form "\#CURSOR_ITEM_BASE_TYPE/{@code SUB_TYPE}".
  /// {@code SUB_TYPE} is the sub-type of the application-dependent
  /// content, e.g., "audio", "video", "playlist".
  static const ANY_CURSOR_ITEM_TYPE = "vnd.android.cursor.item/*";

  /// from: static public final java.lang.String CURSOR_DIR_BASE_TYPE
  ///
  /// This is the Android platform's base MIME type for a content: URI
  /// containing a Cursor of zero or more items.  Applications should use this
  /// as the base type along with their own sub-type of their content: URIs
  /// that represent a directory of items.  For example, hypothetical IMAP email
  /// client may have a URI
  /// <code>content://com.company.provider.imap/inbox</code> for all of the
  /// messages in its inbox, whose MIME type would be reported as
  /// <code>CURSOR_DIR_BASE_TYPE + "/vnd.company.imap-msg"</code>
  ///
  /// Note how the base MIME type varies between this and
  /// \#CURSOR_ITEM_BASE_TYPE depending on whether there is
  /// one single item or multiple items in the data set, while the sub-type
  /// remains the same because in either case the data structure contained
  /// in the cursor is the same.
  static const CURSOR_DIR_BASE_TYPE = "vnd.android.cursor.dir";

  /// from: static public final java.lang.String CURSOR_ITEM_BASE_TYPE
  ///
  /// This is the Android platform's base MIME type for a content: URI
  /// containing a Cursor of a single item.  Applications should use this
  /// as the base type along with their own sub-type of their content: URIs
  /// that represent a particular item.  For example, hypothetical IMAP email
  /// client may have a URI
  /// <code>content://com.company.provider.imap/inbox/1</code> for a particular
  /// message in the inbox, whose MIME type would be reported as
  /// <code>CURSOR_ITEM_BASE_TYPE + "/vnd.company.imap-msg"</code>
  ///
  /// Compare with \#CURSOR_DIR_BASE_TYPE.
  static const CURSOR_ITEM_BASE_TYPE = "vnd.android.cursor.item";

  /// from: static public final java.lang.String EXTRA_HONORED_ARGS
  ///
  /// Allows provider to report back to client which query keys are honored in a Cursor.
  ///
  /// Key identifying a {@code String[]} containing all QUERY_ARG_SORT* arguments
  /// honored by the provider. Include this in Cursor extras Bundle
  /// when any QUERY_ARG_SORT* value was honored during the preparation of the
  /// results Cursor.
  ///
  /// If present, ALL honored arguments are enumerated in this extra\u2019s payload.
  ///@see \#QUERY_ARG_SORT_COLUMNS
  ///@see \#QUERY_ARG_SORT_DIRECTION
  ///@see \#QUERY_ARG_SORT_COLLATION
  static const EXTRA_HONORED_ARGS = "android.content.extra.HONORED_ARGS";

  /// from: static public final java.lang.String EXTRA_REFRESH_SUPPORTED
  ///
  /// An extra boolean describing whether a particular provider supports refresh
  /// or not. If a provider supports refresh, it should include this key in its
  /// returned Cursor as part of its query call.
  static const EXTRA_REFRESH_SUPPORTED =
      "android.content.extra.REFRESH_SUPPORTED";

  /// from: static public final java.lang.String EXTRA_SIZE
  ///
  /// An extra Point describing the optimal size for a requested image
  /// resource, in pixels. If a provider has multiple sizes of the image, it
  /// should return the image closest to this size.
  ///@see \#openTypedAssetFileDescriptor(Uri, String, Bundle)
  ///@see \#openTypedAssetFileDescriptor(Uri, String, Bundle,
  ///      CancellationSignal)
  static const EXTRA_SIZE = "android.content.extra.SIZE";

  /// from: static public final java.lang.String EXTRA_TOTAL_COUNT
  ///
  /// Added to Cursor extras Bundle to indicate total row count of
  /// recordset when paging is supported. Providers must include this when
  /// implementing paging support.
  ///
  /// A provider may return -1 that row count of the recordset is unknown.
  ///
  /// Providers having returned -1 in a previous query are recommended to
  /// send content change notification once (if) full recordset size becomes
  /// known.
  static const EXTRA_TOTAL_COUNT = "android.content.extra.TOTAL_COUNT";

  /// from: static public final int NOTIFY_SKIP_NOTIFY_FOR_DESCENDANTS
  ///
  /// Flag for \#notifyChange(Uri, ContentObserver, int): if set, this notification
  /// will be skipped if it is being delivered to the root URI of a ContentObserver that is
  /// using "notify for descendants."  The purpose of this is to allow the provide to send
  /// a general notification of "something under X" changed that observers of that specific
  /// URI can receive, while also sending a specific URI under X.  It would use this flag
  /// when sending the former, so that observers of "X and descendants" only see the latter.
  static const NOTIFY_SKIP_NOTIFY_FOR_DESCENDANTS = 2;

  /// from: static public final int NOTIFY_SYNC_TO_NETWORK
  ///
  /// Flag for \#notifyChange(Uri, ContentObserver, int): attempt to sync the change
  /// to the network.
  static const NOTIFY_SYNC_TO_NETWORK = 1;

  /// from: static public final java.lang.String QUERY_ARG_LIMIT
  ///
  /// Specifies the max number of rows to include in a Cursor.
  static const QUERY_ARG_LIMIT = "android:query-arg-limit";

  /// from: static public final java.lang.String QUERY_ARG_OFFSET
  ///
  /// Specifies the offset row index within a Cursor.
  static const QUERY_ARG_OFFSET = "android:query-arg-offset";

  /// from: static public final java.lang.String QUERY_ARG_SORT_COLLATION
  ///
  /// Allows client to specify a hint to the provider declaring which collation
  /// to use when sorting text values.
  ///
  /// Providers may support custom collators. When specifying a custom collator
  /// the value is determined by the Provider.
  ///
  /// <li>ContentProvider implementations: When preparing data in
  /// ContentProvider\#query(Uri, String[], Bundle, CancellationSignal), if sort collation
  /// is reflected in the returned Cursor, it is  strongly recommended that
  /// \#QUERY_ARG_SORT_COLLATION then be included in the array of honored arguments
  /// reflected in Cursor extras Bundle under \#EXTRA_HONORED_ARGS.
  ///
  /// <li>When querying a provider, where no QUERY_ARG_SQL* otherwise exists in the
  /// arguments Bundle, the Content framework will attempt to synthesize
  /// a QUERY_ARG_SQL* argument using the corresponding QUERY_ARG_SORT* values.
  ///@see java.text.Collator\#PRIMARY
  ///@see java.text.Collator\#SECONDARY
  ///@see java.text.Collator\#TERTIARY
  ///@see java.text.Collator\#IDENTICAL
  static const QUERY_ARG_SORT_COLLATION = "android:query-arg-sort-collation";

  /// from: static public final java.lang.String QUERY_ARG_SORT_COLUMNS
  ///
  /// Specifies the list of columns against which to sort results. When first column values
  /// are identical, records are then sorted based on second column values, and so on.
  ///
  /// Columns present in this list must also be included in the projection
  /// supplied to ContentResolver\#query(Uri, String[], Bundle, CancellationSignal).
  ///
  /// Apps targeting android.os.Build.VERSION_CODES\#O or higher:
  ///
  /// <li>ContentProvider implementations: When preparing data in
  /// ContentProvider\#query(Uri, String[], Bundle, CancellationSignal), if sort columns
  /// is reflected in the returned Cursor, it is  strongly recommended that
  /// \#QUERY_ARG_SORT_COLUMNS then be included in the array of honored arguments
  /// reflected in Cursor extras Bundle under \#EXTRA_HONORED_ARGS.
  ///
  /// <li>When querying a provider, where no QUERY_ARG_SQL* otherwise exists in the
  /// arguments Bundle, the Content framework will attempt to synthesize
  /// an QUERY_ARG_SQL* argument using the corresponding QUERY_ARG_SORT* values.
  static const QUERY_ARG_SORT_COLUMNS = "android:query-arg-sort-columns";

  /// from: static public final java.lang.String QUERY_ARG_SORT_DIRECTION
  ///
  /// Specifies desired sort order. When unspecified a provider may provide a default
  /// sort direction, or choose to return unsorted results.
  ///
  /// Apps targeting android.os.Build.VERSION_CODES\#O or higher:
  ///
  /// <li>ContentProvider implementations: When preparing data in
  /// ContentProvider\#query(Uri, String[], Bundle, CancellationSignal), if sort direction
  /// is reflected in the returned Cursor, it is  strongly recommended that
  /// \#QUERY_ARG_SORT_DIRECTION then be included in the array of honored arguments
  /// reflected in Cursor extras Bundle under \#EXTRA_HONORED_ARGS.
  ///
  /// <li>When querying a provider, where no QUERY_ARG_SQL* otherwise exists in the
  /// arguments Bundle, the Content framework will attempt to synthesize
  /// a QUERY_ARG_SQL* argument using the corresponding QUERY_ARG_SORT* values.
  ///@see \#QUERY_SORT_DIRECTION_ASCENDING
  ///@see \#QUERY_SORT_DIRECTION_DESCENDING
  static const QUERY_ARG_SORT_DIRECTION = "android:query-arg-sort-direction";

  /// from: static public final java.lang.String QUERY_ARG_SQL_SELECTION
  ///
  /// Key for an SQL style selection string that may be present in the query Bundle argument
  /// passed to ContentProvider\#query(Uri, String[], Bundle, CancellationSignal)
  /// when called by a legacy client.
  ///
  /// Clients should never include user supplied values directly in the selection string,
  /// as this presents an avenue for SQL injection attacks. In lieu of this, a client
  /// should use standard placeholder notation to represent values in a selection string,
  /// then supply a corresponding value in {@value \#QUERY_ARG_SQL_SELECTION_ARGS}.
  ///
  /// __Apps targeting android.os.Build.VERSION_CODES\#O or higher are strongly
  /// encourage to use structured query arguments in lieu of opaque SQL query clauses.__
  ///@see \#QUERY_ARG_SORT_COLUMNS
  ///@see \#QUERY_ARG_SORT_DIRECTION
  ///@see \#QUERY_ARG_SORT_COLLATION
  static const QUERY_ARG_SQL_SELECTION = "android:query-arg-sql-selection";

  /// from: static public final java.lang.String QUERY_ARG_SQL_SELECTION_ARGS
  ///
  /// Key for SQL selection string arguments list.
  ///
  /// Clients should never include user supplied values directly in the selection string,
  /// as this presents an avenue for SQL injection attacks. In lieu of this, a client
  /// should use standard placeholder notation to represent values in a selection string,
  /// then supply a corresponding value in {@value \#QUERY_ARG_SQL_SELECTION_ARGS}.
  ///
  /// __Apps targeting android.os.Build.VERSION_CODES\#O or higher are strongly
  /// encourage to use structured query arguments in lieu of opaque SQL query clauses.__
  ///@see \#QUERY_ARG_SORT_COLUMNS
  ///@see \#QUERY_ARG_SORT_DIRECTION
  ///@see \#QUERY_ARG_SORT_COLLATION
  static const QUERY_ARG_SQL_SELECTION_ARGS =
      "android:query-arg-sql-selection-args";

  /// from: static public final java.lang.String QUERY_ARG_SQL_SORT_ORDER
  ///
  /// Key for an SQL style sort string that may be present in the query Bundle argument
  /// passed to ContentProvider\#query(Uri, String[], Bundle, CancellationSignal)
  /// when called by a legacy client.
  ///
  /// __Apps targeting android.os.Build.VERSION_CODES\#O or higher are strongly
  /// encourage to use structured query arguments in lieu of opaque SQL query clauses.__
  ///@see \#QUERY_ARG_SORT_COLUMNS
  ///@see \#QUERY_ARG_SORT_DIRECTION
  ///@see \#QUERY_ARG_SORT_COLLATION
  static const QUERY_ARG_SQL_SORT_ORDER = "android:query-arg-sql-sort-order";

  /// from: static public final int QUERY_SORT_DIRECTION_ASCENDING
  static const QUERY_SORT_DIRECTION_ASCENDING = 0;

  /// from: static public final int QUERY_SORT_DIRECTION_DESCENDING
  static const QUERY_SORT_DIRECTION_DESCENDING = 1;

  /// from: static public final java.lang.String SCHEME_ANDROID_RESOURCE
  static const SCHEME_ANDROID_RESOURCE = "android.resource";

  /// from: static public final java.lang.String SCHEME_CONTENT
  static const SCHEME_CONTENT = "content";

  /// from: static public final java.lang.String SCHEME_FILE
  static const SCHEME_FILE = "file";

  /// from: static public final java.lang.String SYNC_EXTRAS_ACCOUNT
  ///
  /// @deprecated instead use
  /// \#requestSync(android.accounts.Account, String, android.os.Bundle)
  static const SYNC_EXTRAS_ACCOUNT = "account";

  /// from: static public final java.lang.String SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS
  ///
  /// Indicates that the sync adapter should not proceed with the delete operations,
  /// if it determines that there are too many.
  /// See SyncResult\#tooManyDeletions
  static const SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS = "discard_deletions";

  /// from: static public final java.lang.String SYNC_EXTRAS_DO_NOT_RETRY
  ///
  /// If this extra is set to true then the request will not be retried if it fails.
  static const SYNC_EXTRAS_DO_NOT_RETRY = "do_not_retry";

  /// from: static public final java.lang.String SYNC_EXTRAS_EXPEDITED
  ///
  /// If this extra is set to true, the sync request will be scheduled
  /// at the front of the sync request queue and without any delay
  static const SYNC_EXTRAS_EXPEDITED = "expedited";

  /// from: static public final java.lang.String SYNC_EXTRAS_FORCE
  ///
  /// @deprecated instead use
  /// \#SYNC_EXTRAS_MANUAL
  static const SYNC_EXTRAS_FORCE = "force";

  /// from: static public final java.lang.String SYNC_EXTRAS_IGNORE_BACKOFF
  ///
  /// If this extra is set to true then any backoffs for the initial attempt (e.g.&nbsp;due to retries)
  /// are ignored by the sync scheduler. If this request fails and gets rescheduled then the
  /// retries will still honor the backoff.
  static const SYNC_EXTRAS_IGNORE_BACKOFF = "ignore_backoff";

  /// from: static public final java.lang.String SYNC_EXTRAS_IGNORE_SETTINGS
  ///
  /// If this extra is set to true then the sync settings (like getSyncAutomatically())
  /// are ignored by the sync scheduler.
  static const SYNC_EXTRAS_IGNORE_SETTINGS = "ignore_settings";

  /// from: static public final java.lang.String SYNC_EXTRAS_INITIALIZE
  ///
  /// Set by the SyncManager to request that the SyncAdapter initialize itself for
  /// the given account/authority pair. One required initialization step is to
  /// ensure that \#setIsSyncable(android.accounts.Account, String, int) has been
  /// called with a >= 0 value. When this flag is set the SyncAdapter does not need to
  /// do a full sync, though it is allowed to do so.
  static const SYNC_EXTRAS_INITIALIZE = "initialize";

  /// from: static public final java.lang.String SYNC_EXTRAS_MANUAL
  ///
  /// Setting this extra is the equivalent of setting both \#SYNC_EXTRAS_IGNORE_SETTINGS
  /// and \#SYNC_EXTRAS_IGNORE_BACKOFF
  static const SYNC_EXTRAS_MANUAL = "force";

  /// from: static public final java.lang.String SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS
  ///
  /// Indicates that the sync adapter should proceed with the delete operations,
  /// even if it determines that there are too many.
  /// See SyncResult\#tooManyDeletions
  static const SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS = "deletions_override";

  /// from: static public final java.lang.String SYNC_EXTRAS_REQUIRE_CHARGING
  ///
  /// If this extra is set to true, the sync request will be scheduled
  /// only when the device is plugged in. This is equivalent to calling
  /// setRequiresCharging(true) on SyncRequest.
  static const SYNC_EXTRAS_REQUIRE_CHARGING = "require_charging";

  /// from: static public final java.lang.String SYNC_EXTRAS_UPLOAD
  ///
  /// Indicates that this sync is intended to only upload local changes to the server.
  /// For example, this will be set to true if the sync is initiated by a call to
  /// ContentResolver\#notifyChange(android.net.Uri, android.database.ContentObserver, boolean)
  static const SYNC_EXTRAS_UPLOAD = "upload";

  /// from: static public final int SYNC_OBSERVER_TYPE_ACTIVE
  static const SYNC_OBSERVER_TYPE_ACTIVE = 4;

  /// from: static public final int SYNC_OBSERVER_TYPE_PENDING
  static const SYNC_OBSERVER_TYPE_PENDING = 2;

  /// from: static public final int SYNC_OBSERVER_TYPE_SETTINGS
  static const SYNC_OBSERVER_TYPE_SETTINGS = 1;

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  ContentResolver(Context context) : super.fromRef(_ctor(context.reference)) {
    jni.Jni.env.checkException();
  }

  static final _getType = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_getType")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String getType(android.net.Uri url)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the MIME type of the given content URL.
  ///@param url A Uri identifying content (either a list or specific type),
  /// using the content:// scheme.
  /// This value must never be {@code null}.
  ///@return A MIME type for the content, or null if the URL is invalid or the type is unknown
  jni.JniString getType(jni.JniObject url) {
    final result__ = jni.JniString.fromRef(_getType(reference, url.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getStreamTypes = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_getStreamTypes")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getStreamTypes(android.net.Uri url, java.lang.String mimeTypeFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query for the possible MIME types for the representations the given
  /// content URL can be returned when opened as as stream with
  /// \#openTypedAssetFileDescriptor.  Note that the types here are
  /// not necessarily a superset of the type returned by \#getType --
  /// many content providers cannot return a raw stream for the structured
  /// data that they contain.
  ///@param url A Uri identifying content (either a list or specific type),
  /// using the content:// scheme.
  /// This value must never be {@code null}.
  ///@param mimeTypeFilter The desired MIME type.  This may be a pattern,
  /// such as *&\#47;*, to query for all available MIME types that match the
  /// pattern.
  /// This value must never be {@code null}.
  ///@return Returns an array of MIME type strings for all available
  /// data streams that match the given mimeTypeFilter.  If there are none,
  /// null is returned.
  jni.JniObject getStreamTypes(
      jni.JniObject url, jni.JniString mimeTypeFilter) {
    final result__ = jni.JniObject.fromRef(
        _getStreamTypes(reference, url.reference, mimeTypeFilter.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _query = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_query")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query the given URI, returning a Cursor over the result set.
  ///
  /// For best performance, the caller should follow these guidelines:
  /// <ul>
  /// <li>Provide an explicit projection, to prevent
  /// reading data from storage that aren't going to be used.</li>
  /// <li>Use question mark parameter markers such as 'phone=?' instead of
  /// explicit values in the {@code selection} parameter, so that queries
  /// that differ only by those values will be recognized as the same
  /// for caching purposes.</li>
  /// </ul>
  ///
  ///
  ///@param uri The URI, using the content:// scheme, for the content to
  ///         retrieve.
  /// This value must never be {@code null}.
  ///@param projection A list of which columns to return. Passing null will
  ///         return all columns, which is inefficient.
  /// This value may be {@code null}.
  ///@param selection A filter declaring which rows to return, formatted as an
  ///         SQL WHERE clause (excluding the WHERE itself). Passing null will
  ///         return all rows for the given URI.
  /// This value may be {@code null}.
  ///@param selectionArgs You may include ?s in selection, which will be
  ///         replaced by the values from selectionArgs, in the order that they
  ///         appear in the selection. The values will be bound as Strings.
  /// This value may be {@code null}.
  ///@param sortOrder How to order the rows, formatted as an SQL ORDER BY
  ///         clause (excluding the ORDER BY itself). Passing null will use the
  ///         default sort order, which may be unordered.
  /// This value may be {@code null}.
  ///@return A Cursor object, which is positioned before the first entry, or null
  ///@see Cursor
  jni.JniObject query(
      jni.JniObject uri,
      jni.JniObject projection,
      jni.JniString selection,
      jni.JniObject selectionArgs,
      jni.JniString sortOrder) {
    final result__ = jni.JniObject.fromRef(_query(
        reference,
        uri.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        sortOrder.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _query1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_query1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query the given URI, returning a Cursor over the result set
  /// with optional support for cancellation.
  ///
  /// For best performance, the caller should follow these guidelines:
  /// <ul>
  /// <li>Provide an explicit projection, to prevent
  /// reading data from storage that aren't going to be used.</li>
  /// <li>Use question mark parameter markers such as 'phone=?' instead of
  /// explicit values in the {@code selection} parameter, so that queries
  /// that differ only by those values will be recognized as the same
  /// for caching purposes.</li>
  /// </ul>
  ///
  ///
  ///@param uri The URI, using the content:// scheme, for the content to
  ///         retrieve.
  /// This value must never be {@code null}.
  ///@param projection A list of which columns to return. Passing null will
  ///         return all columns, which is inefficient.
  /// This value may be {@code null}.
  ///@param selection A filter declaring which rows to return, formatted as an
  ///         SQL WHERE clause (excluding the WHERE itself). Passing null will
  ///         return all rows for the given URI.
  /// This value may be {@code null}.
  ///@param selectionArgs You may include ?s in selection, which will be
  ///         replaced by the values from selectionArgs, in the order that they
  ///         appear in the selection. The values will be bound as Strings.
  /// This value may be {@code null}.
  ///@param sortOrder How to order the rows, formatted as an SQL ORDER BY
  ///         clause (excluding the ORDER BY itself). Passing null will use the
  ///         default sort order, which may be unordered.
  /// This value may be {@code null}.
  ///@param cancellationSignal A signal to cancel the operation in progress, or null if none.
  /// If the operation is canceled, then OperationCanceledException will be thrown
  /// when the query is executed.
  /// This value may be {@code null}.
  ///@return A Cursor object, which is positioned before the first entry, or null
  ///@see Cursor
  jni.JniObject query1(
      jni.JniObject uri,
      jni.JniObject projection,
      jni.JniString selection,
      jni.JniObject selectionArgs,
      jni.JniString sortOrder,
      os_.CancellationSignal cancellationSignal) {
    final result__ = jni.JniObject.fromRef(_query1(
        reference,
        uri.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        sortOrder.reference,
        cancellationSignal.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _query2 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_query2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, android.os.Bundle queryArgs, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query the given URI, returning a Cursor over the result set
  /// with support for cancellation.
  ///
  /// For best performance, the caller should follow these guidelines:
  ///
  /// <li>Provide an explicit projection, to prevent reading data from storage
  /// that aren't going to be used.
  ///
  /// Provider must identify which QUERY_ARG_SORT* arguments were honored during
  /// the preparation of the result set by including the respective argument keys
  /// in the Cursor extras Bundle. See \#EXTRA_HONORED_ARGS
  /// for details.
  ///@see \#QUERY_ARG_SORT_COLUMNS, \#QUERY_ARG_SORT_DIRECTION, \#QUERY_ARG_SORT_COLLATION.
  ///@param uri The URI, using the content:// scheme, for the content to
  ///         retrieve.
  /// This value must never be {@code null}.
  ///@param projection A list of which columns to return. Passing null will
  ///         return all columns, which is inefficient.
  /// This value may be {@code null}.
  ///@param queryArgs A Bundle containing any arguments to the query.
  /// This value may be {@code null}.
  ///@param cancellationSignal A signal to cancel the operation in progress, or null if none.
  /// If the operation is canceled, then OperationCanceledException will be thrown
  /// when the query is executed.
  /// This value may be {@code null}.
  ///@return A Cursor object, which is positioned before the first entry, or null
  ///@see Cursor
  jni.JniObject query2(jni.JniObject uri, jni.JniObject projection,
      os_.Bundle queryArgs, os_.CancellationSignal cancellationSignal) {
    final result__ = jni.JniObject.fromRef(_query2(
        reference,
        uri.reference,
        projection.reference,
        queryArgs.reference,
        cancellationSignal.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _canonicalize = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_canonicalize")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.net.Uri canonicalize(android.net.Uri url)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Transform the given <var>url</var> to a canonical representation of
  /// its referenced resource, which can be used across devices, persisted,
  /// backed up and restored, etc.  The returned Uri is still a fully capable
  /// Uri for use with its content provider, allowing you to do all of the
  /// same content provider operations as with the original Uri --
  /// \#query, \#openInputStream(android.net.Uri), etc.  The
  /// only difference in behavior between the original and new Uris is that
  /// the content provider may need to do some additional work at each call
  /// using it to resolve it to the correct resource, especially if the
  /// canonical Uri has been moved to a different environment.
  ///
  /// If you are moving a canonical Uri between environments, you should
  /// perform another call to \#canonicalize with that original Uri to
  /// re-canonicalize it for the current environment.  Alternatively, you may
  /// want to use \#uncanonicalize to transform it to a non-canonical
  /// Uri that works only in the current environment but potentially more
  /// efficiently than the canonical representation.
  ///
  ///@param url The Uri that is to be transformed to a canonical
  /// representation.  Like all resolver calls, the input can be either
  /// a non-canonical or canonical Uri.
  ///
  /// This value must never be {@code null}.
  ///@return Returns the official canonical representation of <var>url</var>,
  /// or null if the content provider does not support a canonical representation
  /// of the given Uri.  Many providers may not support canonicalization of some
  /// or all of their Uris.
  ///@see \#uncanonicalize
  jni.JniObject canonicalize(jni.JniObject url) {
    final result__ =
        jni.JniObject.fromRef(_canonicalize(reference, url.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _uncanonicalize = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_uncanonicalize")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.net.Uri uncanonicalize(android.net.Uri url)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Given a canonical Uri previously generated by \#canonicalize, convert
  /// it to its local non-canonical form.  This can be useful in some cases where
  /// you know that you will only be using the Uri in the current environment and
  /// want to avoid any possible overhead when using it with the content
  /// provider or want to verify that the referenced data exists at all in the
  /// new environment.
  ///@param url The canonical Uri that is to be convered back to its
  /// non-canonical form.
  ///
  /// This value must never be {@code null}.
  ///@return Returns the non-canonical representation of <var>url</var>.  This will
  /// return null if data identified by the canonical Uri can not be found in
  /// the current environment; callers must always check for null and deal with
  /// that by appropriately falling back to an alternative.
  ///@see \#canonicalize
  jni.JniObject uncanonicalize(jni.JniObject url) {
    final result__ =
        jni.JniObject.fromRef(_uncanonicalize(reference, url.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _refresh = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_refresh")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean refresh(android.net.Uri url, android.os.Bundle args, android.os.CancellationSignal cancellationSignal)
  ///
  /// This allows clients to request an explicit refresh of content identified by {@code uri}.
  ///
  /// Client code should only invoke this method when there is a strong indication (such as a user
  /// initiated pull to refresh gesture) that the content is stale.
  ///
  ///@param url The Uri identifying the data to refresh.
  /// This value must never be {@code null}.
  ///@param args Additional options from the client. The definitions of these are specific to the
  ///            content provider being called.
  /// This value may be {@code null}.
  ///@param cancellationSignal A signal to cancel the operation in progress, or {@code null} if
  ///            none. For example, if you called refresh on a particular uri, you should call
  ///            CancellationSignal\#throwIfCanceled() to check whether the client has
  ///            canceled the refresh request.
  /// This value may be {@code null}.
  ///@return true if the provider actually tried refreshing.
  bool refresh(jni.JniObject url, os_.Bundle args,
      os_.CancellationSignal cancellationSignal) {
    final result__ = _refresh(reference, url.reference, args.reference,
            cancellationSignal.reference) !=
        0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openInputStream = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_openInputStream")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final java.io.InputStream openInputStream(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a stream on to the content associated with a content URI.  If there
  /// is no data associated with the URI, FileNotFoundException is thrown.
  ///
  /// <h5>Accepts the following URI schemes:</h5>
  /// <ul>
  /// <li>content (\#SCHEME_CONTENT)</li>
  /// <li>android.resource (\#SCHEME_ANDROID_RESOURCE)</li>
  /// <li>file (\#SCHEME_FILE)</li>
  /// </ul>
  ///
  /// See \#openAssetFileDescriptor(Uri, String) for more information
  /// on these schemes.
  ///@param uri The desired URI.
  /// This value must never be {@code null}.
  ///@return InputStream
  /// This value may be {@code null}.
  ///@throws FileNotFoundException if the provided URI could not be opened.
  ///@see \#openAssetFileDescriptor(Uri, String)
  jni.JniObject openInputStream(jni.JniObject uri) {
    final result__ =
        jni.JniObject.fromRef(_openInputStream(reference, uri.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openOutputStream = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_openOutputStream")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final java.io.OutputStream openOutputStream(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Synonym for \#openOutputStream(Uri, String) openOutputStream(uri, "w").
  ///@throws FileNotFoundException if the provided URI could not be opened.
  ///@param uri This value must never be {@code null}.
  ///@return This value may be {@code null}.
  jni.JniObject openOutputStream(jni.JniObject uri) {
    final result__ =
        jni.JniObject.fromRef(_openOutputStream(reference, uri.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openOutputStream1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_openOutputStream1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final java.io.OutputStream openOutputStream(android.net.Uri uri, java.lang.String mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a stream on to the content associated with a content URI.  If there
  /// is no data associated with the URI, FileNotFoundException is thrown.
  ///
  /// <h5>Accepts the following URI schemes:</h5>
  /// <ul>
  /// <li>content (\#SCHEME_CONTENT)</li>
  /// <li>file (\#SCHEME_FILE)</li>
  /// </ul>
  ///
  /// See \#openAssetFileDescriptor(Uri, String) for more information
  /// on these schemes.
  ///@param uri The desired URI.
  /// This value must never be {@code null}.
  ///@param mode May be "w", "wa", "rw", or "rwt".
  /// This value must never be {@code null}.
  ///@return OutputStream
  /// This value may be {@code null}.
  ///@throws FileNotFoundException if the provided URI could not be opened.
  ///@see \#openAssetFileDescriptor(Uri, String)
  jni.JniObject openOutputStream1(jni.JniObject uri, jni.JniString mode) {
    final result__ = jni.JniObject.fromRef(
        _openOutputStream1(reference, uri.reference, mode.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openFileDescriptor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_openFileDescriptor")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.ParcelFileDescriptor openFileDescriptor(android.net.Uri uri, java.lang.String mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a raw file descriptor to access data under a URI.  This
  /// is like \#openAssetFileDescriptor(Uri, String), but uses the
  /// underlying ContentProvider\#openFile
  /// ContentProvider.openFile()} method, so will _not_ work with
  /// providers that return sub-sections of files.  If at all possible,
  /// you should use \#openAssetFileDescriptor(Uri, String).  You
  /// will receive a FileNotFoundException exception if the provider returns a
  /// sub-section of a file.
  ///
  /// <h5>Accepts the following URI schemes:</h5>
  /// <ul>
  /// <li>content (\#SCHEME_CONTENT)</li>
  /// <li>file (\#SCHEME_FILE)</li>
  /// </ul>
  ///
  /// See \#openAssetFileDescriptor(Uri, String) for more information
  /// on these schemes.
  ///
  /// If opening with the exclusive "r" or "w" modes, the returned
  /// ParcelFileDescriptor could be a pipe or socket pair to enable streaming
  /// of data. Opening with the "rw" mode implies a file on disk that supports
  /// seeking. If possible, always use an exclusive mode to give the underlying
  /// ContentProvider the most flexibility.
  ///
  /// If you are writing a file, and need to communicate an error to the
  /// provider, use ParcelFileDescriptor\#closeWithError(String).
  ///@param uri The desired URI to open.
  /// This value must never be {@code null}.
  ///@param mode The file mode to use, as per ContentProvider\#openFile ContentProvider.openFile.
  /// This value must never be {@code null}.
  ///@return Returns a new ParcelFileDescriptor pointing to the file.  You
  /// own this descriptor and are responsible for closing it when done.
  /// This value may be {@code null}.
  ///@throws FileNotFoundException Throws FileNotFoundException if no
  /// file exists under the URI or the mode is invalid.
  ///@see \#openAssetFileDescriptor(Uri, String)
  os_.ParcelFileDescriptor openFileDescriptor(
      jni.JniObject uri, jni.JniString mode) {
    final result__ = os_.ParcelFileDescriptor.fromRef(
        _openFileDescriptor(reference, uri.reference, mode.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openFileDescriptor1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_openFileDescriptor1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.ParcelFileDescriptor openFileDescriptor(android.net.Uri uri, java.lang.String mode, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a raw file descriptor to access data under a URI.  This
  /// is like \#openAssetFileDescriptor(Uri, String), but uses the
  /// underlying ContentProvider\#openFile
  /// ContentProvider.openFile()} method, so will _not_ work with
  /// providers that return sub-sections of files.  If at all possible,
  /// you should use \#openAssetFileDescriptor(Uri, String).  You
  /// will receive a FileNotFoundException exception if the provider returns a
  /// sub-section of a file.
  ///
  /// <h5>Accepts the following URI schemes:</h5>
  /// <ul>
  /// <li>content (\#SCHEME_CONTENT)</li>
  /// <li>file (\#SCHEME_FILE)</li>
  /// </ul>
  ///
  /// See \#openAssetFileDescriptor(Uri, String) for more information
  /// on these schemes.
  ///
  /// If opening with the exclusive "r" or "w" modes, the returned
  /// ParcelFileDescriptor could be a pipe or socket pair to enable streaming
  /// of data. Opening with the "rw" mode implies a file on disk that supports
  /// seeking. If possible, always use an exclusive mode to give the underlying
  /// ContentProvider the most flexibility.
  ///
  /// If you are writing a file, and need to communicate an error to the
  /// provider, use ParcelFileDescriptor\#closeWithError(String).
  ///@param uri The desired URI to open.
  /// This value must never be {@code null}.
  ///@param mode The file mode to use, as per ContentProvider\#openFile ContentProvider.openFile.
  /// This value must never be {@code null}.
  ///@param cancellationSignal A signal to cancel the operation in progress,
  ///         or null if none. If the operation is canceled, then
  ///         OperationCanceledException will be thrown.
  /// This value may be {@code null}.
  ///@return Returns a new ParcelFileDescriptor pointing to the file.  You
  /// own this descriptor and are responsible for closing it when done.
  ///@throws FileNotFoundException Throws FileNotFoundException if no
  /// file exists under the URI or the mode is invalid.
  ///@see \#openAssetFileDescriptor(Uri, String)
  os_.ParcelFileDescriptor openFileDescriptor1(jni.JniObject uri,
      jni.JniString mode, os_.CancellationSignal cancellationSignal) {
    final result__ = os_.ParcelFileDescriptor.fromRef(_openFileDescriptor1(
        reference,
        uri.reference,
        mode.reference,
        cancellationSignal.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openAssetFileDescriptor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_openAssetFileDescriptor")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.AssetFileDescriptor openAssetFileDescriptor(android.net.Uri uri, java.lang.String mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a raw file descriptor to access data under a URI.  This
  /// interacts with the underlying ContentProvider\#openAssetFile
  /// method of the provider associated with the given URI, to retrieve any file stored there.
  ///
  /// <h5>Accepts the following URI schemes:</h5>
  /// <ul>
  /// <li>content (\#SCHEME_CONTENT)</li>
  /// <li>android.resource (\#SCHEME_ANDROID_RESOURCE)</li>
  /// <li>file (\#SCHEME_FILE)</li>
  /// </ul>
  /// <h5>The android.resource (\#SCHEME_ANDROID_RESOURCE) Scheme</h5>
  ///
  /// A Uri object can be used to reference a resource in an APK file.  The
  /// Uri should be one of the following formats:
  /// <ul>
  /// <li><code>android.resource://package_name/id_number</code><br/>
  /// <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
  /// For example <code>com.example.myapp</code><br/>
  /// <code>id_number</code> is the int form of the ID.<br/>
  /// The easiest way to construct this form is
  /// <pre>Uri uri = Uri.parse("android.resource://com.example.myapp/" + R.raw.my_resource");</pre>
  /// </li>
  /// <li><code>android.resource://package_name/type/name</code><br/>
  /// <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
  /// For example <code>com.example.myapp</code><br/>
  /// <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
  /// or <code>drawable</code>.
  /// <code>name</code> is the string form of the resource name.  That is, whatever the file
  /// name was in your res directory, without the type extension.
  /// The easiest way to construct this form is
  /// <pre>Uri uri = Uri.parse("android.resource://com.example.myapp/raw/my_resource");</pre>
  /// </li>
  /// </ul>
  ///
  /// Note that if this function is called for read-only input (mode is "r")
  /// on a content: URI, it will instead call \#openTypedAssetFileDescriptor
  /// for you with a MIME type of "*&\#47;*".  This allows such callers to benefit
  /// from any built-in data conversion that a provider implements.
  ///@param uri The desired URI to open.
  /// This value must never be {@code null}.
  ///@param mode The file mode to use, as per ContentProvider\#openAssetFile ContentProvider.openAssetFile.
  /// This value must never be {@code null}.
  ///@return Returns a new ParcelFileDescriptor pointing to the file.  You
  /// own this descriptor and are responsible for closing it when done.
  /// This value may be {@code null}.
  ///@throws FileNotFoundException Throws FileNotFoundException of no
  /// file exists under the URI or the mode is invalid.
  res_.AssetFileDescriptor openAssetFileDescriptor(
      jni.JniObject uri, jni.JniString mode) {
    final result__ = res_.AssetFileDescriptor.fromRef(
        _openAssetFileDescriptor(reference, uri.reference, mode.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openAssetFileDescriptor1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_openAssetFileDescriptor1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.AssetFileDescriptor openAssetFileDescriptor(android.net.Uri uri, java.lang.String mode, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a raw file descriptor to access data under a URI.  This
  /// interacts with the underlying ContentProvider\#openAssetFile
  /// method of the provider associated with the given URI, to retrieve any file stored there.
  ///
  /// <h5>Accepts the following URI schemes:</h5>
  /// <ul>
  /// <li>content (\#SCHEME_CONTENT)</li>
  /// <li>android.resource (\#SCHEME_ANDROID_RESOURCE)</li>
  /// <li>file (\#SCHEME_FILE)</li>
  /// </ul>
  /// <h5>The android.resource (\#SCHEME_ANDROID_RESOURCE) Scheme</h5>
  ///
  /// A Uri object can be used to reference a resource in an APK file.  The
  /// Uri should be one of the following formats:
  /// <ul>
  /// <li><code>android.resource://package_name/id_number</code><br/>
  /// <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
  /// For example <code>com.example.myapp</code><br/>
  /// <code>id_number</code> is the int form of the ID.<br/>
  /// The easiest way to construct this form is
  /// <pre>Uri uri = Uri.parse("android.resource://com.example.myapp/" + R.raw.my_resource");</pre>
  /// </li>
  /// <li><code>android.resource://package_name/type/name</code><br/>
  /// <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
  /// For example <code>com.example.myapp</code><br/>
  /// <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
  /// or <code>drawable</code>.
  /// <code>name</code> is the string form of the resource name.  That is, whatever the file
  /// name was in your res directory, without the type extension.
  /// The easiest way to construct this form is
  /// <pre>Uri uri = Uri.parse("android.resource://com.example.myapp/raw/my_resource");</pre>
  /// </li>
  /// </ul>
  ///
  /// Note that if this function is called for read-only input (mode is "r")
  /// on a content: URI, it will instead call \#openTypedAssetFileDescriptor
  /// for you with a MIME type of "*&\#47;*".  This allows such callers to benefit
  /// from any built-in data conversion that a provider implements.
  ///@param uri The desired URI to open.
  /// This value must never be {@code null}.
  ///@param mode The file mode to use, as per ContentProvider\#openAssetFile ContentProvider.openAssetFile.
  /// This value must never be {@code null}.
  ///@param cancellationSignal A signal to cancel the operation in progress, or null if
  ///            none. If the operation is canceled, then
  ///            OperationCanceledException will be thrown.
  /// This value may be {@code null}.
  ///@return Returns a new ParcelFileDescriptor pointing to the file.  You
  /// own this descriptor and are responsible for closing it when done.
  ///@throws FileNotFoundException Throws FileNotFoundException of no
  /// file exists under the URI or the mode is invalid.
  res_.AssetFileDescriptor openAssetFileDescriptor1(jni.JniObject uri,
      jni.JniString mode, os_.CancellationSignal cancellationSignal) {
    final result__ = res_.AssetFileDescriptor.fromRef(_openAssetFileDescriptor1(
        reference,
        uri.reference,
        mode.reference,
        cancellationSignal.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openTypedAssetFileDescriptor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_openTypedAssetFileDescriptor")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.AssetFileDescriptor openTypedAssetFileDescriptor(android.net.Uri uri, java.lang.String mimeType, android.os.Bundle opts)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a raw file descriptor to access (potentially type transformed)
  /// data from a "content:" URI.  This interacts with the underlying
  /// ContentProvider\#openTypedAssetFile method of the provider
  /// associated with the given URI, to retrieve retrieve any appropriate
  /// data stream for the data stored there.
  ///
  /// Unlike \#openAssetFileDescriptor, this function only works
  /// with "content:" URIs, because content providers are the only facility
  /// with an associated MIME type to ensure that the returned data stream
  /// is of the desired type.
  ///
  /// All text/* streams are encoded in UTF-8.
  ///@param uri The desired URI to open.
  /// This value must never be {@code null}.
  ///@param mimeType The desired MIME type of the returned data.  This can
  /// be a pattern such as *&\#47;*, which will allow the content provider to
  /// select a type, though there is no way for you to determine what type
  /// it is returning.
  /// This value must never be {@code null}.
  ///@param opts Additional provider-dependent options.
  /// This value may be {@code null}.
  ///@return Returns a new ParcelFileDescriptor from which you can read the
  /// data stream from the provider.  Note that this may be a pipe, meaning
  /// you can't seek in it.  The only seek you should do is if the
  /// AssetFileDescriptor contains an offset, to move to that offset before
  /// reading.  You own this descriptor and are responsible for closing it when done.
  /// This value may be {@code null}.
  ///@throws FileNotFoundException Throws FileNotFoundException of no
  /// data of the desired type exists under the URI.
  res_.AssetFileDescriptor openTypedAssetFileDescriptor(
      jni.JniObject uri, jni.JniString mimeType, os_.Bundle opts) {
    final result__ = res_.AssetFileDescriptor.fromRef(
        _openTypedAssetFileDescriptor(
            reference, uri.reference, mimeType.reference, opts.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openTypedAssetFileDescriptor1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_openTypedAssetFileDescriptor1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.AssetFileDescriptor openTypedAssetFileDescriptor(android.net.Uri uri, java.lang.String mimeType, android.os.Bundle opts, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a raw file descriptor to access (potentially type transformed)
  /// data from a "content:" URI.  This interacts with the underlying
  /// ContentProvider\#openTypedAssetFile method of the provider
  /// associated with the given URI, to retrieve retrieve any appropriate
  /// data stream for the data stored there.
  ///
  /// Unlike \#openAssetFileDescriptor, this function only works
  /// with "content:" URIs, because content providers are the only facility
  /// with an associated MIME type to ensure that the returned data stream
  /// is of the desired type.
  ///
  /// All text/* streams are encoded in UTF-8.
  ///@param uri The desired URI to open.
  /// This value must never be {@code null}.
  ///@param mimeType The desired MIME type of the returned data.  This can
  /// be a pattern such as *&\#47;*, which will allow the content provider to
  /// select a type, though there is no way for you to determine what type
  /// it is returning.
  /// This value must never be {@code null}.
  ///@param opts Additional provider-dependent options.
  /// This value may be {@code null}.
  ///@param cancellationSignal A signal to cancel the operation in progress,
  ///         or null if none. If the operation is canceled, then
  ///         OperationCanceledException will be thrown.
  /// This value may be {@code null}.
  ///@return Returns a new ParcelFileDescriptor from which you can read the
  /// data stream from the provider.  Note that this may be a pipe, meaning
  /// you can't seek in it.  The only seek you should do is if the
  /// AssetFileDescriptor contains an offset, to move to that offset before
  /// reading.  You own this descriptor and are responsible for closing it when done.
  ///@throws FileNotFoundException Throws FileNotFoundException of no
  /// data of the desired type exists under the URI.
  res_.AssetFileDescriptor openTypedAssetFileDescriptor1(
      jni.JniObject uri,
      jni.JniString mimeType,
      os_.Bundle opts,
      os_.CancellationSignal cancellationSignal) {
    final result__ = res_.AssetFileDescriptor.fromRef(
        _openTypedAssetFileDescriptor1(reference, uri.reference,
            mimeType.reference, opts.reference, cancellationSignal.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _insert = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_insert")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.net.Uri insert(android.net.Uri url, android.content.ContentValues values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Inserts a row into a table at the given URL.
  ///
  /// If the content provider supports transactions the insertion will be atomic.
  ///@param url The URL of the table to insert into.
  /// This value must never be {@code null}.
  ///@param values The initial values for the newly inserted row. The key is the column name for
  ///               the field. Passing an empty ContentValues will create an empty row.
  /// This value may be {@code null}.
  ///@return the URL of the newly created row.
  ///
  /// This value may be {@code null}.
  jni.JniObject insert(jni.JniObject url, ContentValues values) {
    final result__ = jni.JniObject.fromRef(
        _insert(reference, url.reference, values.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _applyBatch = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_applyBatch")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ContentProviderResult[] applyBatch(java.lang.String authority, java.util.ArrayList<android.content.ContentProviderOperation> operations)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Applies each of the ContentProviderOperation objects and returns an array
  /// of their results. Passes through OperationApplicationException, which may be thrown
  /// by the call to ContentProviderOperation\#apply.
  /// If all the applications succeed then a ContentProviderResult array with the
  /// same number of elements as the operations will be returned. It is implementation-specific
  /// how many, if any, operations will have been successfully applied if a call to
  /// apply results in a OperationApplicationException.
  ///@param authority the authority of the ContentProvider to which this batch should be applied
  /// This value must never be {@code null}.
  ///@param operations the operations to apply
  /// This value must never be {@code null}.
  ///@return the results of the applications
  /// This value will never be {@code null}.
  ///@throws OperationApplicationException thrown if an application fails.
  /// See ContentProviderOperation\#apply for more information.
  ///@throws RemoteException thrown if a RemoteException is encountered while attempting
  ///   to communicate with a remote provider.
  jni.JniObject applyBatch(jni.JniString authority, jni.JniObject operations) {
    final result__ = jni.JniObject.fromRef(
        _applyBatch(reference, authority.reference, operations.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _bulkInsert = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_bulkInsert")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final int bulkInsert(android.net.Uri url, android.content.ContentValues[] values)
  ///
  /// Inserts multiple rows into a table at the given URL.
  ///
  /// This function make no guarantees about the atomicity of the insertions.
  ///@param url The URL of the table to insert into.
  /// This value must never be {@code null}.
  ///@param values The initial values for the newly inserted rows. The key is the column name for
  ///               the field. Passing null will create an empty row.
  /// This value must never be {@code null}.
  ///@return the number of newly created rows.
  int bulkInsert(jni.JniObject url, jni.JniObject values) {
    final result__ = _bulkInsert(reference, url.reference, values.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _delete1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_delete1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final int delete(android.net.Uri url, java.lang.String where, java.lang.String[] selectionArgs)
  ///
  /// Deletes row(s) specified by a content URI.
  ///
  /// If the content provider supports transactions, the deletion will be atomic.
  ///@param url The URL of the row to delete.
  /// This value must never be {@code null}.
  ///@param where A filter to apply to rows before deleting, formatted as an SQL WHERE clause
  ///            (excluding the WHERE itself).
  /// This value may be {@code null}.
  ///@param selectionArgs This value may be {@code null}.
  ///@return The number of rows deleted.
  int delete1(
      jni.JniObject url, jni.JniString where, jni.JniObject selectionArgs) {
    final result__ = _delete1(
        reference, url.reference, where.reference, selectionArgs.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _update = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_update")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final int update(android.net.Uri uri, android.content.ContentValues values, java.lang.String where, java.lang.String[] selectionArgs)
  ///
  /// Update row(s) in a content URI.
  ///
  /// If the content provider supports transactions the update will be atomic.
  ///@param uri The URI to modify.
  /// This value must never be {@code null}.
  ///@param values The new field values. The key is the column name for the field.
  ///            A null value will remove an existing field value.
  /// This value may be {@code null}.
  ///@param where A filter to apply to rows before updating, formatted as an SQL WHERE clause
  ///           (excluding the WHERE itself).
  /// This value may be {@code null}.
  ///@param selectionArgs This value may be {@code null}.
  ///@return the number of rows updated.
  ///@throws NullPointerException if uri or values are null
  int update(jni.JniObject uri, ContentValues values, jni.JniString where,
      jni.JniObject selectionArgs) {
    final result__ = _update(reference, uri.reference, values.reference,
        where.reference, selectionArgs.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _call = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_call")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.Bundle call(android.net.Uri uri, java.lang.String method, java.lang.String arg, android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Call a provider-defined method.  This can be used to implement
  /// read or write interfaces which are cheaper than using a Cursor and/or
  /// do not fit into the traditional table model.
  ///@param method provider-defined method name to call.  Opaque to
  ///   framework, but must be non-null.
  /// This value must never be {@code null}.
  ///@param arg provider-defined String argument.  May be null.
  /// This value may be {@code null}.
  ///@param extras provider-defined Bundle argument.  May be null.
  /// This value may be {@code null}.
  ///@param uri This value must never be {@code null}.
  ///@return a result Bundle, possibly null.  Will be null if the ContentProvider
  ///   does not implement call.
  ///@throws NullPointerException if uri or method is null
  ///@throws IllegalArgumentException if uri is not known
  os_.Bundle call(jni.JniObject uri, jni.JniString method, jni.JniString arg,
      os_.Bundle extras) {
    final result__ = os_.Bundle.fromRef(_call(reference, uri.reference,
        method.reference, arg.reference, extras.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _acquireContentProviderClient = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_acquireContentProviderClient")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.ContentProviderClient acquireContentProviderClient(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a ContentProviderClient that is associated with the ContentProvider
  /// that services the content at uri, starting the provider if necessary. Returns
  /// null if there is no provider associated wih the uri. The caller must indicate that they are
  /// done with the provider by calling ContentProviderClient\#release which will allow
  /// the system to release the provider it it determines that there is no other reason for
  /// keeping it active.
  ///@param uri specifies which provider should be acquired
  /// This value must never be {@code null}.
  ///@return a ContentProviderClient that is associated with the ContentProvider
  /// that services the content at uri or null if there isn't one.
  ContentProviderClient acquireContentProviderClient(jni.JniObject uri) {
    final result__ = ContentProviderClient.fromRef(
        _acquireContentProviderClient(reference, uri.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _acquireContentProviderClient1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_acquireContentProviderClient1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.ContentProviderClient acquireContentProviderClient(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a ContentProviderClient that is associated with the ContentProvider
  /// with the authority of name, starting the provider if necessary. Returns
  /// null if there is no provider associated wih the uri. The caller must indicate that they are
  /// done with the provider by calling ContentProviderClient\#release which will allow
  /// the system to release the provider it it determines that there is no other reason for
  /// keeping it active.
  ///@param name specifies which provider should be acquired
  /// This value must never be {@code null}.
  ///@return a ContentProviderClient that is associated with the ContentProvider
  /// with the authority of name or null if there isn't one.
  ContentProviderClient acquireContentProviderClient1(jni.JniString name) {
    final result__ = ContentProviderClient.fromRef(
        _acquireContentProviderClient1(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _acquireUnstableContentProviderClient = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_acquireUnstableContentProviderClient")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.ContentProviderClient acquireUnstableContentProviderClient(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#acquireContentProviderClient(Uri), but for use when you do
  /// not trust the stability of the target content provider.  This turns off
  /// the mechanism in the platform clean up processes that are dependent on
  /// a content provider if that content provider's process goes away.  Normally
  /// you can safely assume that once you have acquired a provider, you can freely
  /// use it as needed and it won't disappear, even if your process is in the
  /// background.  If using this method, you need to take care to deal with any
  /// failures when communicating with the provider, and be sure to close it
  /// so that it can be re-opened later.  In particular, catching a
  /// android.os.DeadObjectException from the calls there will let you
  /// know that the content provider has gone away; at that point the current
  /// ContentProviderClient object is invalid, and you should release it.  You
  /// can acquire a new one if you would like to try to restart the provider
  /// and perform new operations on it.
  ///@param uri This value must never be {@code null}.
  ///@return This value may be {@code null}.
  ContentProviderClient acquireUnstableContentProviderClient(
      jni.JniObject uri) {
    final result__ = ContentProviderClient.fromRef(
        _acquireUnstableContentProviderClient(reference, uri.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _acquireUnstableContentProviderClient1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_acquireUnstableContentProviderClient1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.ContentProviderClient acquireUnstableContentProviderClient(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#acquireContentProviderClient(String), but for use when you do
  /// not trust the stability of the target content provider.  This turns off
  /// the mechanism in the platform clean up processes that are dependent on
  /// a content provider if that content provider's process goes away.  Normally
  /// you can safely assume that once you have acquired a provider, you can freely
  /// use it as needed and it won't disappear, even if your process is in the
  /// background.  If using this method, you need to take care to deal with any
  /// failures when communicating with the provider, and be sure to close it
  /// so that it can be re-opened later.  In particular, catching a
  /// android.os.DeadObjectException from the calls there will let you
  /// know that the content provider has gone away; at that point the current
  /// ContentProviderClient object is invalid, and you should release it.  You
  /// can acquire a new one if you would like to try to restart the provider
  /// and perform new operations on it.
  ///@param name This value must never be {@code null}.
  ///@return This value may be {@code null}.
  ContentProviderClient acquireUnstableContentProviderClient1(
      jni.JniString name) {
    final result__ = ContentProviderClient.fromRef(
        _acquireUnstableContentProviderClient1(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _registerContentObserver = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Uint8,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_registerContentObserver")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void registerContentObserver(android.net.Uri uri, boolean notifyForDescendants, android.database.ContentObserver observer)
  ///
  /// Register an observer class that gets callbacks when data identified by a
  /// given content URI changes.
  ///
  /// Starting in android.os.Build.VERSION_CODES\#O, all content
  /// notifications must be backed by a valid ContentProvider.
  ///@param uri The URI to watch for changes. This can be a specific row URI,
  ///            or a base URI for a whole class of content.
  /// This value must never be {@code null}.
  ///@param notifyForDescendants When false, the observer will be notified
  ///            whenever a change occurs to the exact URI specified by
  ///            <code>uri</code> or to one of the URI's ancestors in the path
  ///            hierarchy. When true, the observer will also be notified
  ///            whenever a change occurs to the URI's descendants in the path
  ///            hierarchy.
  ///@param observer The object that receives callbacks when changes occur.
  /// This value must never be {@code null}.
  ///@see \#unregisterContentObserver
  void registerContentObserver(
      jni.JniObject uri, bool notifyForDescendants, jni.JniObject observer) {
    final result__ = _registerContentObserver(reference, uri.reference,
        notifyForDescendants ? 1 : 0, observer.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _unregisterContentObserver = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_unregisterContentObserver")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void unregisterContentObserver(android.database.ContentObserver observer)
  ///
  /// Unregisters a change observer.
  ///@param observer The previously registered observer that is no longer needed.
  /// This value must never be {@code null}.
  ///@see \#registerContentObserver
  void unregisterContentObserver(jni.JniObject observer) {
    final result__ = _unregisterContentObserver(reference, observer.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _notifyChange = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_notifyChange")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void notifyChange(android.net.Uri uri, android.database.ContentObserver observer)
  ///
  /// Notify registered observers that a row was updated and attempt to sync
  /// changes to the network.
  ///
  /// To observe events sent through this call, use
  /// \#registerContentObserver(Uri, boolean, ContentObserver).
  ///
  /// Starting in android.os.Build.VERSION_CODES\#O, all content
  /// notifications must be backed by a valid ContentProvider.
  ///@param uri The uri of the content that was changed.
  /// This value must never be {@code null}.
  ///@param observer The observer that originated the change, may be
  ///            <code>null</null>. The observer that originated the change
  ///            will only receive the notification if it has requested to
  ///            receive self-change notifications by implementing
  ///            ContentObserver\#deliverSelfNotifications() to return
  ///            true.
  ///
  /// This value may be {@code null}.
  void notifyChange(jni.JniObject uri, jni.JniObject observer) {
    final result__ =
        _notifyChange(reference, uri.reference, observer.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _notifyChange1 = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_content_ContentResolver_notifyChange1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void notifyChange(android.net.Uri uri, android.database.ContentObserver observer, boolean syncToNetwork)
  ///
  /// Notify registered observers that a row was updated.
  ///
  /// To observe events sent through this call, use
  /// \#registerContentObserver(Uri, boolean, ContentObserver).
  ///
  /// If syncToNetwork is true, this will attempt to schedule a local sync
  /// using the sync adapter that's registered for the authority of the
  /// provided uri. No account will be passed to the sync adapter, so all
  /// matching accounts will be synchronized.
  ///
  /// Starting in android.os.Build.VERSION_CODES\#O, all content
  /// notifications must be backed by a valid ContentProvider.
  ///@param uri The uri of the content that was changed.
  /// This value must never be {@code null}.
  ///@param observer The observer that originated the change, may be
  ///            <code>null</null>. The observer that originated the change
  ///            will only receive the notification if it has requested to
  ///            receive self-change notifications by implementing
  ///            ContentObserver\#deliverSelfNotifications() to return
  ///            true.
  /// This value may be {@code null}.
  ///@param syncToNetwork If true, same as \#NOTIFY_SYNC_TO_NETWORK.
  ///@see \#requestSync(android.accounts.Account, String, android.os.Bundle)
  void notifyChange1(
      jni.JniObject uri, jni.JniObject observer, bool syncToNetwork) {
    final result__ = _notifyChange1(
        reference, uri.reference, observer.reference, syncToNetwork ? 1 : 0);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _notifyChange2 = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_ContentResolver_notifyChange2")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void notifyChange(android.net.Uri uri, android.database.ContentObserver observer, int flags)
  ///
  /// Notify registered observers that a row was updated.
  ///
  /// To observe events sent through this call, use
  /// \#registerContentObserver(Uri, boolean, ContentObserver).
  ///
  /// If syncToNetwork is true, this will attempt to schedule a local sync
  /// using the sync adapter that's registered for the authority of the
  /// provided uri. No account will be passed to the sync adapter, so all
  /// matching accounts will be synchronized.
  ///
  /// Starting in android.os.Build.VERSION_CODES\#O, all content
  /// notifications must be backed by a valid ContentProvider.
  ///@param uri The uri of the content that was changed.
  /// This value must never be {@code null}.
  ///@param observer The observer that originated the change, may be
  ///            <code>null</null>. The observer that originated the change
  ///            will only receive the notification if it has requested to
  ///            receive self-change notifications by implementing
  ///            ContentObserver\#deliverSelfNotifications() to return
  ///            true.
  /// This value may be {@code null}.
  ///@param flags Additional flags: \#NOTIFY_SYNC_TO_NETWORK.
  /// Value is either <code>0</code> or a combination of android.content.ContentResolver\#NOTIFY_SYNC_TO_NETWORK, and android.content.ContentResolver\#NOTIFY_SKIP_NOTIFY_FOR_DESCENDANTS
  ///@see \#requestSync(android.accounts.Account, String, android.os.Bundle)
  void notifyChange2(jni.JniObject uri, jni.JniObject observer, int flags) {
    final result__ =
        _notifyChange2(reference, uri.reference, observer.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _takePersistableUriPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_ContentResolver_takePersistableUriPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void takePersistableUriPermission(android.net.Uri uri, int modeFlags)
  ///
  /// Take a persistable URI permission grant that has been offered. Once
  /// taken, the permission grant will be remembered across device reboots.
  /// Only URI permissions granted with
  /// Intent\#FLAG_GRANT_PERSISTABLE_URI_PERMISSION can be persisted. If
  /// the grant has already been persisted, taking it again will touch
  /// UriPermission\#getPersistedTime().
  ///@see \#getPersistedUriPermissions()
  ///@param uri This value must never be {@code null}.
  ///@param modeFlags Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  void takePersistableUriPermission(jni.JniObject uri, int modeFlags) {
    final result__ =
        _takePersistableUriPermission(reference, uri.reference, modeFlags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _releasePersistableUriPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_ContentResolver_releasePersistableUriPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void releasePersistableUriPermission(android.net.Uri uri, int modeFlags)
  ///
  /// Relinquish a persisted URI permission grant. The URI must have been
  /// previously made persistent with
  /// \#takePersistableUriPermission(Uri, int). Any non-persistent
  /// grants to the calling package will remain intact.
  ///@see \#getPersistedUriPermissions()
  ///@param uri This value must never be {@code null}.
  ///@param modeFlags Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  void releasePersistableUriPermission(jni.JniObject uri, int modeFlags) {
    final result__ =
        _releasePersistableUriPermission(reference, uri.reference, modeFlags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPersistedUriPermissions = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_getPersistedUriPermissions")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.content.UriPermission> getPersistedUriPermissions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return list of all URI permission grants that have been persisted by the
  /// calling app. That is, the returned permissions have been granted
  /// _to_ the calling app. Only persistable grants taken with
  /// \#takePersistableUriPermission(Uri, int) are returned.
  /// Note: Some of the returned URIs may not be usable until after the user is unlocked.
  ///@see \#takePersistableUriPermission(Uri, int)
  ///@see \#releasePersistableUriPermission(Uri, int)
  ///@return This value will never be {@code null}.
  jni.JniObject getPersistedUriPermissions() {
    final result__ =
        jni.JniObject.fromRef(_getPersistedUriPermissions(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getOutgoingPersistedUriPermissions = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_getOutgoingPersistedUriPermissions")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.content.UriPermission> getOutgoingPersistedUriPermissions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return list of all persisted URI permission grants that are hosted by the
  /// calling app. That is, the returned permissions have been granted
  /// _from_ the calling app. Only grants taken with
  /// \#takePersistableUriPermission(Uri, int) are returned.
  /// Note: Some of the returned URIs may not be usable until after the user is unlocked.
  ///@return This value will never be {@code null}.
  jni.JniObject getOutgoingPersistedUriPermissions() {
    final result__ =
        jni.JniObject.fromRef(_getOutgoingPersistedUriPermissions(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startSync = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_startSync")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startSync(android.net.Uri uri, android.os.Bundle extras)
  ///
  /// Start an asynchronous sync operation. If you want to monitor the progress
  /// of the sync you may register a SyncObserver. Only values of the following
  /// types may be used in the extras bundle:
  /// <ul>
  /// <li>Integer</li>
  /// <li>Long</li>
  /// <li>Boolean</li>
  /// <li>Float</li>
  /// <li>Double</li>
  /// <li>String</li>
  /// <li>Account</li>
  /// <li>null</li>
  /// </ul>
  ///@param uri the uri of the provider to sync or null to sync all providers.
  ///@param extras any extras to pass to the SyncAdapter.
  ///@deprecated instead use
  /// \#requestSync(android.accounts.Account, String, android.os.Bundle)
  void startSync(jni.JniObject uri, os_.Bundle extras) {
    final result__ = _startSync(reference, uri.reference, extras.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _requestSync = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_requestSync")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void requestSync(android.accounts.Account account, java.lang.String authority, android.os.Bundle extras)
  ///
  /// Start an asynchronous sync operation. If you want to monitor the progress
  /// of the sync you may register a SyncObserver. Only values of the following
  /// types may be used in the extras bundle:
  /// <ul>
  /// <li>Integer</li>
  /// <li>Long</li>
  /// <li>Boolean</li>
  /// <li>Float</li>
  /// <li>Double</li>
  /// <li>String</li>
  /// <li>Account</li>
  /// <li>null</li>
  /// </ul>
  ///@param account which account should be synced
  ///@param authority which authority should be synced
  ///@param extras any extras to pass to the SyncAdapter.
  static void requestSync(
      jni.JniObject account, jni.JniString authority, os_.Bundle extras) {
    final result__ =
        _requestSync(account.reference, authority.reference, extras.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _requestSync1 =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentResolver_requestSync1")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void requestSync(android.content.SyncRequest request)
  ///
  /// Register a sync with the SyncManager. These requests are built using the
  /// SyncRequest.Builder.
  static void requestSync1(SyncRequest request) {
    final result__ = _requestSync1(request.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _validateSyncExtrasBundle =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentResolver_validateSyncExtrasBundle")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void validateSyncExtrasBundle(android.os.Bundle extras)
  ///
  /// Check that only values of the following types are in the Bundle:
  /// <ul>
  /// <li>Integer</li>
  /// <li>Long</li>
  /// <li>Boolean</li>
  /// <li>Float</li>
  /// <li>Double</li>
  /// <li>String</li>
  /// <li>Account</li>
  /// <li>null</li>
  /// </ul>
  ///@param extras the Bundle to check
  static void validateSyncExtrasBundle(os_.Bundle extras) {
    final result__ = _validateSyncExtrasBundle(extras.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _cancelSync = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_cancelSync")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void cancelSync(android.net.Uri uri)
  ///
  /// Cancel any active or pending syncs that match the Uri. If the uri is null then
  /// all syncs will be canceled.
  ///@param uri the uri of the provider to sync or null to sync all providers.
  ///@deprecated instead use \#cancelSync(android.accounts.Account, String)
  void cancelSync(jni.JniObject uri) {
    final result__ = _cancelSync(reference, uri.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _cancelSync1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_cancelSync1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void cancelSync(android.accounts.Account account, java.lang.String authority)
  ///
  /// Cancel any active or pending syncs that match account and authority. The account and
  /// authority can each independently be set to null, which means that syncs with any account
  /// or authority, respectively, will match.
  ///@param account filters the syncs that match by this account
  ///@param authority filters the syncs that match by this authority
  static void cancelSync1(jni.JniObject account, jni.JniString authority) {
    final result__ = _cancelSync1(account.reference, authority.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSyncAdapterTypes =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_ContentResolver_getSyncAdapterTypes")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.content.SyncAdapterType[] getSyncAdapterTypes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get information about the SyncAdapters that are known to the system.
  ///@return an array of SyncAdapters that have registered with the system
  static jni.JniObject getSyncAdapterTypes() {
    final result__ = jni.JniObject.fromRef(_getSyncAdapterTypes());
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSyncAutomatically = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_getSyncAutomatically")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean getSyncAutomatically(android.accounts.Account account, java.lang.String authority)
  ///
  /// Check if the provider should be synced when a network tickle is received
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#READ_SYNC_SETTINGS.
  ///@param account the account whose setting we are querying
  ///@param authority the provider whose setting we are querying
  ///@return true if the provider should be synced when a network tickle is received
  static bool getSyncAutomatically(
      jni.JniObject account, jni.JniString authority) {
    final result__ =
        _getSyncAutomatically(account.reference, authority.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setSyncAutomatically = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_content_ContentResolver_setSyncAutomatically")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public void setSyncAutomatically(android.accounts.Account account, java.lang.String authority, boolean sync)
  ///
  /// Set whether or not the provider is synced when it receives a network tickle.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#WRITE_SYNC_SETTINGS.
  ///@param account the account whose setting we are querying
  ///@param authority the provider whose behavior is being controlled
  ///@param sync true if the provider should be synced when tickles are received for it
  static void setSyncAutomatically(
      jni.JniObject account, jni.JniString authority, bool sync0) {
    final result__ = _setSyncAutomatically(
        account.reference, authority.reference, sync0 ? 1 : 0);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _addPeriodicSync = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int64)>>(
          "android_content_ContentResolver_addPeriodicSync")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public void addPeriodicSync(android.accounts.Account account, java.lang.String authority, android.os.Bundle extras, long pollFrequency)
  ///
  /// Specifies that a sync should be requested with the specified the account, authority,
  /// and extras at the given frequency. If there is already another periodic sync scheduled
  /// with the account, authority and extras then a new periodic sync won't be added, instead
  /// the frequency of the previous one will be updated.
  ///
  /// These periodic syncs honor the "syncAutomatically" and "masterSyncAutomatically" settings.
  /// Although these sync are scheduled at the specified frequency, it may take longer for it to
  /// actually be started if other syncs are ahead of it in the sync operation queue. This means
  /// that the actual start time may drift.
  ///
  /// Periodic syncs are not allowed to have any of \#SYNC_EXTRAS_DO_NOT_RETRY,
  /// \#SYNC_EXTRAS_IGNORE_BACKOFF, \#SYNC_EXTRAS_IGNORE_SETTINGS,
  /// \#SYNC_EXTRAS_INITIALIZE, \#SYNC_EXTRAS_FORCE,
  /// \#SYNC_EXTRAS_EXPEDITED, \#SYNC_EXTRAS_MANUAL set to true.
  /// If any are supplied then an IllegalArgumentException will be thrown.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#WRITE_SYNC_SETTINGS.
  /// The bundle for a periodic sync can be queried by applications with the correct
  /// permissions using
  /// ContentResolver\#getPeriodicSyncs(Account account, String provider), so no
  /// sensitive data should be transferred here.
  ///@param account the account to specify in the sync
  ///@param authority the provider to specify in the sync request
  ///@param extras extra parameters to go along with the sync request
  ///@param pollFrequency how frequently the sync should be performed, in seconds.
  /// On Android API level 24 and above, a minmam interval of 15 minutes is enforced.
  /// On previous versions, the minimum interval is 1 hour.
  ///@throws IllegalArgumentException if an illegal extra was set or if any of the parameters
  /// are null.
  static void addPeriodicSync(jni.JniObject account, jni.JniString authority,
      os_.Bundle extras, int pollFrequency) {
    final result__ = _addPeriodicSync(account.reference, authority.reference,
        extras.reference, pollFrequency);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _removePeriodicSync = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_removePeriodicSync")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void removePeriodicSync(android.accounts.Account account, java.lang.String authority, android.os.Bundle extras)
  ///
  /// Remove a periodic sync. Has no affect if account, authority and extras don't match
  /// an existing periodic sync.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#WRITE_SYNC_SETTINGS.
  ///@param account the account of the periodic sync to remove
  ///@param authority the provider of the periodic sync to remove
  ///@param extras the extras of the periodic sync to remove
  static void removePeriodicSync(
      jni.JniObject account, jni.JniString authority, os_.Bundle extras) {
    final result__ = _removePeriodicSync(
        account.reference, authority.reference, extras.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _cancelSync2 =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentResolver_cancelSync2")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void cancelSync(android.content.SyncRequest request)
  ///
  /// Remove the specified sync. This will cancel any pending or active syncs. If the request is
  /// for a periodic sync, this call will remove any future occurrences.
  ///
  ///     If a periodic sync is specified, the caller must hold the permission
  ///     android.Manifest.permission\#WRITE_SYNC_SETTINGS.
  ///
  ///
  /// It is possible to cancel a sync using a SyncRequest object that is not the same object
  /// with which you requested the sync. Do so by building a SyncRequest with the same
  /// adapter, frequency, __and__ extras bundle.
  ///@param request SyncRequest object containing information about sync to cancel.
  static void cancelSync2(SyncRequest request) {
    final result__ = _cancelSync2(request.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPeriodicSyncs = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_getPeriodicSyncs")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.List<android.content.PeriodicSync> getPeriodicSyncs(android.accounts.Account account, java.lang.String authority)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the list of information about the periodic syncs for the given account and authority.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#READ_SYNC_SETTINGS.
  ///@param account the account whose periodic syncs we are querying
  ///@param authority the provider whose periodic syncs we are querying
  ///@return a list of PeriodicSync objects. This list may be empty but will never be null.
  static jni.JniObject getPeriodicSyncs(
      jni.JniObject account, jni.JniString authority) {
    final result__ = jni.JniObject.fromRef(
        _getPeriodicSyncs(account.reference, authority.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getIsSyncable = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_getIsSyncable")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public int getIsSyncable(android.accounts.Account account, java.lang.String authority)
  ///
  /// Check if this account/provider is syncable.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#READ_SYNC_SETTINGS.
  ///@return >0 if it is syncable, 0 if not, and <0 if the state isn't known yet.
  static int getIsSyncable(jni.JniObject account, jni.JniString authority) {
    final result__ = _getIsSyncable(account.reference, authority.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setIsSyncable = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_ContentResolver_setIsSyncable")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public void setIsSyncable(android.accounts.Account account, java.lang.String authority, int syncable)
  ///
  /// Set whether this account/provider is syncable.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#WRITE_SYNC_SETTINGS.
  ///@param syncable >0 denotes syncable, 0 means not syncable, <0 means unknown
  static void setIsSyncable(
      jni.JniObject account, jni.JniString authority, int syncable) {
    final result__ =
        _setIsSyncable(account.reference, authority.reference, syncable);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getMasterSyncAutomatically =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function()>>(
              "android_content_ContentResolver_getMasterSyncAutomatically")
          .asFunction<int Function()>();

  /// from: static public boolean getMasterSyncAutomatically()
  ///
  /// Gets the master auto-sync setting that applies to all the providers and accounts.
  /// If this is false then the per-provider auto-sync setting is ignored.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#READ_SYNC_SETTINGS.
  ///@return the master auto-sync setting that applies to all the providers and accounts
  static bool getMasterSyncAutomatically() {
    final result__ = _getMasterSyncAutomatically() != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setMasterSyncAutomatically =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Uint8)>>(
              "android_content_ContentResolver_setMasterSyncAutomatically")
          .asFunction<void Function(int)>();

  /// from: static public void setMasterSyncAutomatically(boolean sync)
  ///
  /// Sets the master auto-sync setting that applies to all the providers and accounts.
  /// If this is false then the per-provider auto-sync setting is ignored.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#WRITE_SYNC_SETTINGS.
  ///@param sync the master auto-sync setting that applies to all the providers and accounts
  static void setMasterSyncAutomatically(bool sync0) {
    final result__ = _setMasterSyncAutomatically(sync0 ? 1 : 0);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isSyncActive = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_isSyncActive")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean isSyncActive(android.accounts.Account account, java.lang.String authority)
  ///
  /// Returns true if there is currently a sync operation for the given account or authority
  /// actively being processed.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#READ_SYNC_STATS.
  ///@param account the account whose setting we are querying
  ///@param authority the provider whose behavior is being queried
  ///@return true if a sync is active for the given account or authority.
  static bool isSyncActive(jni.JniObject account, jni.JniString authority) {
    final result__ = _isSyncActive(account.reference, authority.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getCurrentSync =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_ContentResolver_getCurrentSync")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.content.SyncInfo getCurrentSync()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If a sync is active returns the information about it, otherwise returns null.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#READ_SYNC_STATS.
  ///
  ///@return the SyncInfo for the currently active sync or null if one is not active.
  ///@deprecated Since multiple concurrent syncs are now supported you should use
  /// \#getCurrentSyncs() to get the accurate list of current syncs.
  /// This method returns the first item from the list of current syncs
  /// or null if there are none.
  static SyncInfo getCurrentSync() {
    final result__ = SyncInfo.fromRef(_getCurrentSync());
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getCurrentSyncs =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_ContentResolver_getCurrentSyncs")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public java.util.List<android.content.SyncInfo> getCurrentSyncs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list with information about all the active syncs. This list will be empty
  /// if there are no active syncs.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#READ_SYNC_STATS.
  ///
  ///@return a List of SyncInfo objects for the currently active syncs.
  static jni.JniObject getCurrentSyncs() {
    final result__ = jni.JniObject.fromRef(_getCurrentSyncs());
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isSyncPending = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_isSyncPending")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean isSyncPending(android.accounts.Account account, java.lang.String authority)
  ///
  /// Return true if the pending status is true of any matching authorities.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#READ_SYNC_STATS.
  ///@param account the account whose setting we are querying
  ///@param authority the provider whose behavior is being queried
  ///@return true if there is a pending sync with the matching account and authority
  static bool isSyncPending(jni.JniObject account, jni.JniString authority) {
    final result__ =
        _isSyncPending(account.reference, authority.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _addStatusChangeListener = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentResolver_addStatusChangeListener")
      .asFunction<ffi.Pointer<ffi.Void> Function(int, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.Object addStatusChangeListener(int mask, android.content.SyncStatusObserver callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Request notifications when the different aspects of the SyncManager change. The
  /// different items that can be requested are:
  /// <ul>
  /// <li> \#SYNC_OBSERVER_TYPE_PENDING
  /// <li> \#SYNC_OBSERVER_TYPE_ACTIVE
  /// <li> \#SYNC_OBSERVER_TYPE_SETTINGS
  /// </ul>
  /// The caller can set one or more of the status types in the mask for any
  /// given listener registration.
  ///@param mask the status change types that will cause the callback to be invoked
  ///@param callback observer to be invoked when the status changes
  ///@return a handle that can be used to remove the listener at a later time
  static jni.JniObject addStatusChangeListener(
      int mask, SyncStatusObserver callback) {
    final result__ = jni.JniObject.fromRef(
        _addStatusChangeListener(mask, callback.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _removeStatusChangeListener =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentResolver_removeStatusChangeListener")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void removeStatusChangeListener(java.lang.Object handle)
  ///
  /// Remove a previously registered status change listener.
  ///@param handle the handle that was returned by \#addStatusChangeListener
  static void removeStatusChangeListener(jni.JniObject handle) {
    final result__ = _removeStatusChangeListener(handle.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.DialogInterface
///
/// Interface that defines a dialog-type class that can be shown, dismissed, or
/// canceled, and may have buttons that can be clicked.
class DialogInterface extends jni.JniObject {
  DialogInterface.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int BUTTON1
  ///
  /// @deprecated Use \#BUTTON_POSITIVE
  static const BUTTON1 = -1;

  /// from: static public final int BUTTON2
  ///
  /// @deprecated Use \#BUTTON_NEGATIVE
  static const BUTTON2 = -2;

  /// from: static public final int BUTTON3
  ///
  /// @deprecated Use \#BUTTON_NEUTRAL
  static const BUTTON3 = -3;

  /// from: static public final int BUTTON_NEGATIVE
  ///
  /// The identifier for the negative button.
  static const BUTTON_NEGATIVE = -2;

  /// from: static public final int BUTTON_NEUTRAL
  ///
  /// The identifier for the neutral button.
  static const BUTTON_NEUTRAL = -3;

  /// from: static public final int BUTTON_POSITIVE
  ///
  /// The identifier for the positive button.
  static const BUTTON_POSITIVE = -1;

  static final _cancel =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_DialogInterface_cancel")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void cancel()
  ///
  /// Cancels the dialog, invoking the OnCancelListener.
  ///
  /// The OnDismissListener may also be called if cancellation
  /// dismisses the dialog.
  void cancel() {
    final result__ = _cancel(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _dismiss =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_DialogInterface_dismiss")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void dismiss()
  ///
  /// Dismisses the dialog, invoking the OnDismissListener.
  void dismiss() {
    final result__ = _dismiss(reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.DialogInterface$OnShowListener
///
/// Interface used to allow the creator of a dialog to run some code when the
/// dialog is shown.
class DialogInterface_OnShowListener extends jni.JniObject {
  DialogInterface_OnShowListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onShow = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_DialogInterface__OnShowListener_onShow")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onShow(android.content.DialogInterface dialog)
  ///
  /// This method will be invoked when the dialog is shown.
  ///@param dialog the dialog that was shown will be passed into the
  ///               method
  void onShow(DialogInterface dialog) {
    final result__ = _onShow(reference, dialog.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.DialogInterface$OnMultiChoiceClickListener
///
/// Interface used to allow the creator of a dialog to run some code when an
/// item in a multi-choice dialog is clicked.
class DialogInterface_OnMultiChoiceClickListener extends jni.JniObject {
  DialogInterface_OnMultiChoiceClickListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onClick = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Uint8)>>(
          "android_content_DialogInterface__OnMultiChoiceClickListener_onClick")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void onClick(android.content.DialogInterface dialog, int which, boolean isChecked)
  ///
  /// This method will be invoked when an item in the dialog is clicked.
  ///@param dialog the dialog where the selection was made
  ///@param which the position of the item in the list that was clicked
  ///@param isChecked {@code true} if the click checked the item, else
  ///                  {@code false}
  void onClick(DialogInterface dialog, int which, bool isChecked) {
    final result__ =
        _onClick(reference, dialog.reference, which, isChecked ? 1 : 0);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.DialogInterface$OnKeyListener
///
/// Interface definition for a callback to be invoked when a key event is
/// dispatched to this dialog. The callback will be invoked before the key
/// event is given to the dialog.
class DialogInterface_OnKeyListener extends jni.JniObject {
  DialogInterface_OnKeyListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onKey = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_DialogInterface__OnKeyListener_onKey")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean onKey(android.content.DialogInterface dialog, int keyCode, android.view.KeyEvent event)
  ///
  /// Called when a key is dispatched to a dialog. This allows listeners to
  /// get a chance to respond before the dialog.
  ///@param dialog the dialog the key has been dispatched to
  ///@param keyCode the code for the physical key that was pressed
  ///@param event the KeyEvent object containing full information about
  ///              the event
  ///@return {@code true} if the listener has consumed the event,
  ///         {@code false} otherwise
  bool onKey(DialogInterface dialog, int keyCode, jni.JniObject event) {
    final result__ =
        _onKey(reference, dialog.reference, keyCode, event.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.DialogInterface$OnDismissListener
///
/// Interface used to allow the creator of a dialog to run some code when the
/// dialog is dismissed.
class DialogInterface_OnDismissListener extends jni.JniObject {
  DialogInterface_OnDismissListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onDismiss = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_DialogInterface__OnDismissListener_onDismiss")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onDismiss(android.content.DialogInterface dialog)
  ///
  /// This method will be invoked when the dialog is dismissed.
  ///@param dialog the dialog that was dismissed will be passed into the
  ///               method
  void onDismiss(DialogInterface dialog) {
    final result__ = _onDismiss(reference, dialog.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.DialogInterface$OnClickListener
///
/// Interface used to allow the creator of a dialog to run some code when an
/// item on the dialog is clicked.
class DialogInterface_OnClickListener extends jni.JniObject {
  DialogInterface_OnClickListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onClick = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_DialogInterface__OnClickListener_onClick")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void onClick(android.content.DialogInterface dialog, int which)
  ///
  /// This method will be invoked when a button in the dialog is clicked.
  ///@param dialog the dialog that received the click
  ///@param which the button that was clicked (ex.
  ///              DialogInterface\#BUTTON_POSITIVE) or the position
  ///              of the item clicked
  void onClick(DialogInterface dialog, int which) {
    final result__ = _onClick(reference, dialog.reference, which);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.DialogInterface$OnCancelListener
///
/// Interface used to allow the creator of a dialog to run some code when the
/// dialog is canceled.
///
/// This will only be called when the dialog is canceled, if the creator
/// needs to know when it is dismissed in general, use
/// DialogInterface.OnDismissListener.
class DialogInterface_OnCancelListener extends jni.JniObject {
  DialogInterface_OnCancelListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onCancel = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_DialogInterface__OnCancelListener_onCancel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onCancel(android.content.DialogInterface dialog)
  ///
  /// This method will be invoked when the dialog is canceled.
  ///@param dialog the dialog that was canceled will be passed into the
  ///               method
  void onCancel(DialogInterface dialog) {
    final result__ = _onCancel(reference, dialog.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.RestrictionsManager
///
/// Provides a mechanism for apps to query restrictions imposed by an entity that
/// manages the user. Apps can also send permission requests to a local or remote
/// device administrator to override default app-specific restrictions or any other
/// operation that needs explicit authorization from the administrator.
///
/// Apps can expose a set of restrictions via an XML file specified in the manifest.
///
/// If the user has an active Restrictions Provider, dynamic requests can be made in
/// addition to the statically imposed restrictions. Dynamic requests are app-specific
/// and can be expressed via a predefined set of request types.
///
/// The RestrictionsManager forwards the dynamic requests to the active
/// Restrictions Provider. The Restrictions Provider can respond back to requests by calling
/// \#notifyPermissionResponse(String, PersistableBundle), when
/// a response is received from the administrator of the device or user.
/// The response is relayed back to the application via a protected broadcast,
/// \#ACTION_PERMISSION_RESPONSE_RECEIVED.
///
/// Static restrictions are specified by an XML file referenced by a meta-data attribute
/// in the manifest. This enables applications as well as any web administration consoles
/// to be able to read the list of available restrictions from the apk.
///
/// The syntax of the XML format is as follows:
/// <pre>
/// &lt;?xml version="1.0" encoding="utf-8"?&gt;
/// &lt;restrictions xmlns:android="http://schemas.android.com/apk/res/android" &gt;
///     &lt;restriction
///         android:key="string"
///         android:title="string resource"
///         android:restrictionType=["bool" | "string" | "integer"
///                                         | "choice" | "multi-select" | "hidden"
///                                         | "bundle" | "bundle_array"]
///         android:description="string resource"
///         android:entries="string-array resource"
///         android:entryValues="string-array resource"
///         android:defaultValue="reference" &gt;
///             &lt;restriction ... /&gt;
///             ...
///     &lt;/restriction&gt;
///     &lt;restriction ... /&gt;
///     ...
/// &lt;/restrictions&gt;
/// </pre>
///
/// The attributes for each restriction depend on the restriction type.
///
/// <ul>
/// <li><code>key</code>, <code>title</code> and <code>restrictionType</code> are mandatory.</li>
/// <li><code>entries</code> and <code>entryValues</code> are required if <code>restrictionType
/// </code> is <code>choice</code> or <code>multi-select</code>.</li>
/// <li><code>defaultValue</code> is optional and its type depends on the
/// <code>restrictionType</code></li>
/// <li><code>hidden</code> type must have a <code>defaultValue</code> and will
/// not be shown to the administrator. It can be used to pass along data that cannot be modified,
/// such as a version code.</li>
/// <li><code>description</code> is meant to describe the restriction in more detail to the
/// administrator controlling the values, if the title is not sufficient.</li>
/// </ul>
///
/// Only restrictions of type {@code bundle} and {@code bundle_array} can have one or multiple nested
/// restriction elements.
///
/// In your manifest's <code>application</code> section, add the meta-data tag to point to
/// the restrictions XML file as shown below:
/// <pre>
/// &lt;application ... &gt;
///     &lt;meta-data android:name="android.content.APP_RESTRICTIONS"
///                   android:resource="@xml/app_restrictions" /&gt;
///     ...
/// &lt;/application&gt;
/// </pre>
///@see RestrictionEntry
///@see RestrictionsReceiver
///@see DevicePolicyManager\#setRestrictionsProvider(ComponentName, ComponentName)
///@see DevicePolicyManager\#setApplicationRestrictions(ComponentName, String, Bundle)
class RestrictionsManager extends jni.JniObject {
  RestrictionsManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_PERMISSION_RESPONSE_RECEIVED
  ///
  /// Broadcast intent delivered when a response is received for a permission request. The
  /// application should not interrupt the user by coming to the foreground if it isn't
  /// currently in the foreground. It can either post a notification informing
  /// the user of the response or wait until the next time the user launches the app.
  ///
  /// For instance, if the user requested permission to make an in-app purchase,
  /// the app can post a notification that the request had been approved or denied.
  ///
  /// The broadcast Intent carries the following extra:
  /// \#EXTRA_RESPONSE_BUNDLE.
  static const ACTION_PERMISSION_RESPONSE_RECEIVED =
      "android.content.action.PERMISSION_RESPONSE_RECEIVED";

  /// from: static public final java.lang.String ACTION_REQUEST_LOCAL_APPROVAL
  ///
  /// Activity intent that is optionally implemented by the Restrictions Provider package
  /// to challenge for an administrator PIN or password locally on the device. Apps will
  /// call this intent using Activity\#startActivityForResult. On a successful
  /// response, Activity\#onActivityResult will return a resultCode of
  /// Activity\#RESULT_OK.
  ///
  /// The intent must contain \#EXTRA_REQUEST_BUNDLE as an extra and the bundle must
  /// contain at least \#REQUEST_KEY_MESSAGE for the activity to display.
  ///
  ///@see \#createLocalApprovalIntent()
  static const ACTION_REQUEST_LOCAL_APPROVAL =
      "android.content.action.REQUEST_LOCAL_APPROVAL";

  /// from: static public final java.lang.String ACTION_REQUEST_PERMISSION
  ///
  /// Broadcast intent sent to the Restrictions Provider to handle a permission request from
  /// an app. It will have the following extras: \#EXTRA_PACKAGE_NAME,
  /// \#EXTRA_REQUEST_TYPE, \#EXTRA_REQUEST_ID and \#EXTRA_REQUEST_BUNDLE.
  /// The Restrictions Provider will handle the request and respond back to the
  /// RestrictionsManager, when a response is available, by calling
  /// \#notifyPermissionResponse.
  ///
  /// The BroadcastReceiver must require the android.Manifest.permission\#BIND_DEVICE_ADMIN
  /// permission to ensure that only the system can send the broadcast.
  static const ACTION_REQUEST_PERMISSION =
      "android.content.action.REQUEST_PERMISSION";

  /// from: static public final java.lang.String EXTRA_PACKAGE_NAME
  ///
  /// The package name of the application making the request.
  ///
  /// Type: String
  static const EXTRA_PACKAGE_NAME = "android.content.extra.PACKAGE_NAME";

  /// from: static public final java.lang.String EXTRA_REQUEST_BUNDLE
  ///
  /// The request bundle passed in the \#ACTION_REQUEST_PERMISSION broadcast.
  ///
  /// Type: PersistableBundle
  static const EXTRA_REQUEST_BUNDLE = "android.content.extra.REQUEST_BUNDLE";

  /// from: static public final java.lang.String EXTRA_REQUEST_ID
  ///
  /// The request ID passed in the \#ACTION_REQUEST_PERMISSION broadcast.
  ///
  /// Type: String
  static const EXTRA_REQUEST_ID = "android.content.extra.REQUEST_ID";

  /// from: static public final java.lang.String EXTRA_REQUEST_TYPE
  ///
  /// The request type passed in the \#ACTION_REQUEST_PERMISSION broadcast.
  ///
  /// Type: String
  static const EXTRA_REQUEST_TYPE = "android.content.extra.REQUEST_TYPE";

  /// from: static public final java.lang.String EXTRA_RESPONSE_BUNDLE
  ///
  /// Contains a response from the administrator for specific request.
  /// The bundle contains the following information, at least:
  /// <ul>
  /// <li>\#REQUEST_KEY_ID: The request ID.</li>
  /// <li>\#RESPONSE_KEY_RESULT: The response result.</li>
  /// </ul>
  ///
  /// Type: PersistableBundle
  static const EXTRA_RESPONSE_BUNDLE = "android.content.extra.RESPONSE_BUNDLE";

  /// from: static public final java.lang.String META_DATA_APP_RESTRICTIONS
  ///
  /// Name of the meta-data entry in the manifest that points to the XML file containing the
  /// application's available restrictions.
  ///@see \#getManifestRestrictions(String)
  static const META_DATA_APP_RESTRICTIONS = "android.content.APP_RESTRICTIONS";

  /// from: static public final java.lang.String REQUEST_KEY_APPROVE_LABEL
  ///
  /// Key for request approval button label contained in the request bundle.
  ///
  /// Optional, may be shown as a label on the positive button in a dialog or
  /// notification presented to the administrator who approves the request.
  ///
  /// Type: String
  static const REQUEST_KEY_APPROVE_LABEL = "android.request.approve_label";

  /// from: static public final java.lang.String REQUEST_KEY_DATA
  ///
  /// Key for request data contained in the request bundle.
  ///
  /// Optional, typically used to identify the specific data that is being referred to,
  /// such as the unique identifier for a movie or book. This is not used for display
  /// purposes and is more like a cookie. This value is returned in the
  /// \#EXTRA_RESPONSE_BUNDLE.
  ///
  /// Type: String
  static const REQUEST_KEY_DATA = "android.request.data";

  /// from: static public final java.lang.String REQUEST_KEY_DENY_LABEL
  ///
  /// Key for request rejection button label contained in the request bundle.
  ///
  /// Optional, may be shown as a label on the negative button in a dialog or
  /// notification presented to the administrator who approves the request.
  ///
  /// Type: String
  static const REQUEST_KEY_DENY_LABEL = "android.request.deny_label";

  /// from: static public final java.lang.String REQUEST_KEY_ICON
  ///
  /// Key for request icon contained in the request bundle.
  ///
  /// Optional, shown alongside the request message presented to the administrator
  /// who approves the request. The content must be a compressed image such as a
  /// PNG or JPEG, as a byte array.
  ///
  /// Type: byte[]
  static const REQUEST_KEY_ICON = "android.request.icon";

  /// from: static public final java.lang.String REQUEST_KEY_ID
  ///
  /// Key for request ID contained in the request bundle.
  ///
  /// App-generated request ID to identify the specific request when receiving
  /// a response. This value is returned in the \#EXTRA_RESPONSE_BUNDLE.
  ///
  /// Type: String
  static const REQUEST_KEY_ID = "android.request.id";

  /// from: static public final java.lang.String REQUEST_KEY_MESSAGE
  ///
  /// Key for request message contained in the request bundle.
  ///
  /// Required, shown as the actual message in a notification or dialog presented
  /// to the administrator who approves the request.
  ///
  /// Type: String
  static const REQUEST_KEY_MESSAGE = "android.request.mesg";

  /// from: static public final java.lang.String REQUEST_KEY_NEW_REQUEST
  ///
  /// Key for issuing a new request, contained in the request bundle. If this is set to true,
  /// the Restrictions Provider must make a new request. If it is false or not specified, then
  /// the Restrictions Provider can return a cached response that has the same requestId, if
  /// available. If there's no cached response, it will issue a new one to the administrator.
  ///
  /// Type: boolean
  static const REQUEST_KEY_NEW_REQUEST = "android.request.new_request";

  /// from: static public final java.lang.String REQUEST_KEY_TITLE
  ///
  /// Key for request title contained in the request bundle.
  ///
  /// Optional, typically used as the title of any notification or dialog presented
  /// to the administrator who approves the request.
  ///
  /// Type: String
  static const REQUEST_KEY_TITLE = "android.request.title";

  /// from: static public final java.lang.String REQUEST_TYPE_APPROVAL
  ///
  /// Request type for a simple question, with a possible title and icon.
  ///
  /// Required keys are: \#REQUEST_KEY_MESSAGE
  ///
  /// Optional keys are
  /// \#REQUEST_KEY_DATA, \#REQUEST_KEY_ICON, \#REQUEST_KEY_TITLE,
  /// \#REQUEST_KEY_APPROVE_LABEL and \#REQUEST_KEY_DENY_LABEL.
  static const REQUEST_TYPE_APPROVAL = "android.request.type.approval";

  /// from: static public final java.lang.String RESPONSE_KEY_ERROR_CODE
  ///
  /// Key for the optional error code in the response bundle sent to the application.
  ///
  /// Type: int
  ///
  /// Possible values: \#RESULT_ERROR_BAD_REQUEST, \#RESULT_ERROR_NETWORK or
  /// \#RESULT_ERROR_INTERNAL.
  static const RESPONSE_KEY_ERROR_CODE = "android.response.errorcode";

  /// from: static public final java.lang.String RESPONSE_KEY_MESSAGE
  ///
  /// Key for the optional message in the response bundle sent to the application.
  ///
  /// Type: String
  static const RESPONSE_KEY_MESSAGE = "android.response.msg";

  /// from: static public final java.lang.String RESPONSE_KEY_RESPONSE_TIMESTAMP
  ///
  /// Key for the optional timestamp of when the administrator responded to the permission
  /// request. It is an represented in milliseconds since January 1, 1970 00:00:00.0 UTC.
  ///
  /// Type: long
  static const RESPONSE_KEY_RESPONSE_TIMESTAMP = "android.response.timestamp";

  /// from: static public final java.lang.String RESPONSE_KEY_RESULT
  ///
  /// Key for the response result in the response bundle sent to the application, for a permission
  /// request. It indicates the status of the request. In some cases an additional message might
  /// be available in \#RESPONSE_KEY_MESSAGE, to be displayed to the user.
  ///
  /// Type: int
  ///
  /// Possible values: \#RESULT_APPROVED, \#RESULT_DENIED,
  /// \#RESULT_NO_RESPONSE, \#RESULT_UNKNOWN_REQUEST or
  /// \#RESULT_ERROR.
  static const RESPONSE_KEY_RESULT = "android.response.result";

  /// from: static public final int RESULT_APPROVED
  ///
  /// Response result value indicating that the request was approved.
  static const RESULT_APPROVED = 1;

  /// from: static public final int RESULT_DENIED
  ///
  /// Response result value indicating that the request was denied.
  static const RESULT_DENIED = 2;

  /// from: static public final int RESULT_ERROR
  ///
  /// Response result value indicating an error condition. Additional error code might be available
  /// in the response bundle, for the key \#RESPONSE_KEY_ERROR_CODE. There might also be
  /// an associated error message in the response bundle, for the key
  /// \#RESPONSE_KEY_MESSAGE.
  static const RESULT_ERROR = 5;

  /// from: static public final int RESULT_ERROR_BAD_REQUEST
  ///
  /// Error code indicating that there was a problem with the request.
  ///
  /// Stored in \#RESPONSE_KEY_ERROR_CODE field in the response bundle.
  static const RESULT_ERROR_BAD_REQUEST = 1;

  /// from: static public final int RESULT_ERROR_INTERNAL
  ///
  /// Error code indicating that there was an internal error.
  ///
  /// Stored in \#RESPONSE_KEY_ERROR_CODE field in the response bundle.
  static const RESULT_ERROR_INTERNAL = 3;

  /// from: static public final int RESULT_ERROR_NETWORK
  ///
  /// Error code indicating that there was a problem with the network.
  ///
  /// Stored in \#RESPONSE_KEY_ERROR_CODE field in the response bundle.
  static const RESULT_ERROR_NETWORK = 2;

  /// from: static public final int RESULT_NO_RESPONSE
  ///
  /// Response result value indicating that the request has not received a response yet.
  static const RESULT_NO_RESPONSE = 3;

  /// from: static public final int RESULT_UNKNOWN_REQUEST
  ///
  /// Response result value indicating that the request is unknown, when it's not a new
  /// request.
  static const RESULT_UNKNOWN_REQUEST = 4;

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_RestrictionsManager_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  RestrictionsManager() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _getApplicationRestrictions = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionsManager_getApplicationRestrictions")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getApplicationRestrictions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns any available set of application-specific restrictions applicable
  /// to this application.
  ///@return the application restrictions as a Bundle. Returns null if there
  /// are no restrictions.
  os_.Bundle getApplicationRestrictions() {
    final result__ = os_.Bundle.fromRef(_getApplicationRestrictions(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hasRestrictionsProvider =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_RestrictionsManager_hasRestrictionsProvider")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasRestrictionsProvider()
  ///
  /// Called by an application to check if there is an active Restrictions Provider. If
  /// there isn't, \#requestPermission(String, String, PersistableBundle) is not available.
  ///@return whether there is an active Restrictions Provider.
  bool hasRestrictionsProvider() {
    final result__ = _hasRestrictionsProvider(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _requestPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionsManager_requestPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void requestPermission(java.lang.String requestType, java.lang.String requestId, android.os.PersistableBundle request)
  ///
  /// Called by an application to request permission for an operation. The contents of the
  /// request are passed in a Bundle that contains several pieces of data depending on the
  /// chosen request type.
  ///@param requestType The type of request. The type could be one of the
  /// predefined types specified here or a custom type that the specific
  /// Restrictions Provider might understand. For custom types, the type name should be
  /// namespaced to avoid collisions with predefined types and types specified by
  /// other Restrictions Providers.
  ///@param requestId A unique id generated by the app that contains sufficient information
  /// to identify the parameters of the request when it receives the id in the response.
  ///@param request A PersistableBundle containing the data corresponding to the specified request
  /// type. The keys for the data in the bundle depend on the request type.
  ///@throws IllegalArgumentException if any of the required parameters are missing.
  void requestPermission(jni.JniString requestType, jni.JniString requestId,
      os_.PersistableBundle request) {
    final result__ = _requestPermission(reference, requestType.reference,
        requestId.reference, request.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _createLocalApprovalIntent = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionsManager_createLocalApprovalIntent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent createLocalApprovalIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Intent createLocalApprovalIntent() {
    final result__ = Intent.fromRef(_createLocalApprovalIntent(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _notifyPermissionResponse = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionsManager_notifyPermissionResponse")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void notifyPermissionResponse(java.lang.String packageName, android.os.PersistableBundle response)
  ///
  /// Called by the Restrictions Provider to deliver a response to an application.
  ///@param packageName the application to deliver the response to. Cannot be null.
  ///@param response the bundle containing the response status, request ID and other information.
  ///                 Cannot be null.
  ///@throws IllegalArgumentException if any of the required parameters are missing.
  void notifyPermissionResponse(
      jni.JniString packageName, os_.PersistableBundle response) {
    final result__ = _notifyPermissionResponse(
        reference, packageName.reference, response.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getManifestRestrictions = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionsManager_getManifestRestrictions")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.content.RestrictionEntry> getManifestRestrictions(java.lang.String packageName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parse and return the list of restrictions defined in the manifest for the specified
  /// package, if any.
  ///@param packageName The application for which to fetch the restrictions list.
  ///@return The list of RestrictionEntry objects created from the XML file specified
  /// in the manifest, or null if none was specified.
  jni.JniObject getManifestRestrictions(jni.JniString packageName) {
    final result__ = jni.JniObject.fromRef(
        _getManifestRestrictions(reference, packageName.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _convertRestrictionsToBundle = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionsManager_convertRestrictionsToBundle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.Bundle convertRestrictionsToBundle(java.util.List<android.content.RestrictionEntry> entries)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Converts a list of restrictions to the corresponding bundle, using the following mapping:
  /// <table>
  ///     <tr><th>RestrictionEntry</th><th>Bundle</th></tr>
  ///     <tr><td>RestrictionEntry\#TYPE_BOOLEAN</td><td>Bundle\#putBoolean</td></tr>
  ///     <tr><td>RestrictionEntry\#TYPE_CHOICE,
  ///     RestrictionEntry\#TYPE_MULTI_SELECT</td>
  ///     <td>Bundle\#putStringArray</td></tr>
  ///     <tr><td>RestrictionEntry\#TYPE_INTEGER</td><td>Bundle\#putInt</td></tr>
  ///     <tr><td>RestrictionEntry\#TYPE_STRING</td><td>Bundle\#putString</td></tr>
  ///     <tr><td>RestrictionEntry\#TYPE_BUNDLE</td><td>Bundle\#putBundle</td></tr>
  ///     <tr><td>RestrictionEntry\#TYPE_BUNDLE_ARRAY</td>
  ///     <td>Bundle\#putParcelableArray</td></tr>
  /// </table>
  ///@param entries list of restrictions
  static os_.Bundle convertRestrictionsToBundle(jni.JniObject entries) {
    final result__ =
        os_.Bundle.fromRef(_convertRestrictionsToBundle(entries.reference));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.ContentProviderResult
///
/// Contains the result of the application of a ContentProviderOperation. It is guaranteed
/// to have exactly one of \#uri or \#count set.
class ContentProviderResult extends jni.JniObject {
  ContentProviderResult.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_ContentProviderResult_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.ContentProviderResult> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  static final _get_count = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_ContentProviderResult_count")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public final java.lang.Integer count
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get count => jni.JniObject.fromRef(_get_count(reference));

  static final _get_uri = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_ContentProviderResult_uri")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public final android.net.Uri uri
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get uri => jni.JniObject.fromRef(_get_uri(reference));

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderResult_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.net.Uri uri)
  ContentProviderResult(jni.JniObject uri)
      : super.fromRef(_ctor(uri.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor1 =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int32)>>(
              "android_content_ContentProviderResult_ctor1")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: public void <init>(int count)
  ContentProviderResult.ctor1(int count) : super.fromRef(_ctor1(count)) {
    jni.Jni.env.checkException();
  }

  static final _ctor2 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderResult_ctor2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel source)
  ContentProviderResult.ctor2(os_.Parcel source)
      : super.fromRef(_ctor2(source.reference)) {
    jni.Jni.env.checkException();
  }

  static final _writeToParcel = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_ContentProviderResult_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) {
    final result__ = _writeToParcel(reference, dest.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentProviderResult_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderResult_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.ComponentCallbacks
///
/// The set of callback APIs that are common to all application components
/// (android.app.Activity, android.app.Service,
/// ContentProvider, and android.app.Application).
///
/// <p class="note"><strong>Note:</strong> You should also implement the ComponentCallbacks2 interface, which provides the ComponentCallbacks2\#onTrimMemory callback to help your app manage its memory usage more
/// effectively.
///
class ComponentCallbacks extends jni.JniObject {
  ComponentCallbacks.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _onConfigurationChanged = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentCallbacks_onConfigurationChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onConfigurationChanged(android.content.res.Configuration newConfig)
  ///
  /// Called by the system when the device configuration changes while your
  /// component is running.  Note that, unlike activities, other components
  /// are never restarted when a configuration changes: they must always deal
  /// with the results of the change, such as by re-retrieving resources.
  ///
  /// At the time that this function has been called, your Resources
  /// object will have been updated to return resource values matching the
  /// new configuration.
  ///
  /// For more information, read <a href="{@docRoot}guide/topics/resources/runtime-changes.html">Handling Runtime Changes</a>.
  ///@param newConfig The new device configuration.
  void onConfigurationChanged(res_.Configuration newConfig) {
    final result__ = _onConfigurationChanged(reference, newConfig.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onLowMemory =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ComponentCallbacks_onLowMemory")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onLowMemory()
  ///
  /// This is called when the overall system is running low on memory, and
  /// actively running processes should trim their memory usage.  While
  /// the exact point at which this will be called is not defined, generally
  /// it will happen when all background process have been killed.
  /// That is, before reaching the point of killing processes hosting
  /// service and foreground UI that we would like to avoid killing.
  ///
  /// You should implement this method to release
  /// any caches or other unnecessary resources you may be holding on to.
  /// The system will perform a garbage collection for you after returning from this method.
  /// Preferably, you should implement ComponentCallbacks2\#onTrimMemory from
  /// ComponentCallbacks2 to incrementally unload your resources based on various
  /// levels of memory demands.  That API is available for API level 14 and higher, so you should
  /// only use this \#onLowMemory method as a fallback for older versions, which can be
  /// treated the same as ComponentCallbacks2\#onTrimMemory with the ComponentCallbacks2\#TRIM_MEMORY_COMPLETE level.
  ///
  void onLowMemory() {
    final result__ = _onLowMemory(reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.Context
///
/// Interface to global information about an application environment.  This is
/// an abstract class whose implementation is provided by
/// the Android system.  It
/// allows access to application-specific resources and classes, as well as
/// up-calls for application-level operations such as launching activities,
/// broadcasting and receiving intents, etc.
class Context extends jni.JniObject {
  Context.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACCESSIBILITY_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.view.accessibility.AccessibilityManager for giving the user
  /// feedback for UI events through the registered event listeners.
  ///@see \#getSystemService(String)
  ///@see android.view.accessibility.AccessibilityManager
  static const ACCESSIBILITY_SERVICE = "accessibility";

  /// from: static public final java.lang.String ACCOUNT_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.accounts.AccountManager for receiving intents at a
  /// time of your choosing.
  ///@see \#getSystemService(String)
  ///@see android.accounts.AccountManager
  static const ACCOUNT_SERVICE = "account";

  /// from: static public final java.lang.String ACTIVITY_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.app.ActivityManager for interacting with the global
  /// system state.
  ///@see \#getSystemService(String)
  ///@see android.app.ActivityManager
  static const ACTIVITY_SERVICE = "activity";

  /// from: static public final java.lang.String ALARM_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.app.AlarmManager for receiving intents at a
  /// time of your choosing.
  ///@see \#getSystemService(String)
  ///@see android.app.AlarmManager
  static const ALARM_SERVICE = "alarm";

  /// from: static public final java.lang.String APPWIDGET_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.appwidget.AppWidgetManager for accessing AppWidgets.
  ///@see \#getSystemService(String)
  static const APPWIDGET_SERVICE = "appwidget";

  /// from: static public final java.lang.String APP_OPS_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.app.AppOpsManager for tracking application operations
  /// on the device.
  ///@see \#getSystemService(String)
  ///@see android.app.AppOpsManager
  static const APP_OPS_SERVICE = "appops";

  /// from: static public final java.lang.String AUDIO_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.media.AudioManager for handling management of volume,
  /// ringer modes and audio routing.
  ///@see \#getSystemService(String)
  ///@see android.media.AudioManager
  static const AUDIO_SERVICE = "audio";

  /// from: static public final java.lang.String BATTERY_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.os.BatteryManager for managing battery state.
  ///@see \#getSystemService(String)
  static const BATTERY_SERVICE = "batterymanager";

  /// from: static public final int BIND_ABOVE_CLIENT
  ///
  /// Flag for \#bindService: indicates that the client application
  /// binding to this service considers the service to be more important than
  /// the app itself.  When set, the platform will try to have the out of
  /// memory killer kill the app before it kills the service it is bound to, though
  /// this is not guaranteed to be the case.
  static const BIND_ABOVE_CLIENT = 8;

  /// from: static public final int BIND_ADJUST_WITH_ACTIVITY
  ///
  /// Flag for \#bindService: If binding from an activity, allow the
  /// target service's process importance to be raised based on whether the
  /// activity is visible to the user, regardless whether another flag is
  /// used to reduce the amount that the client process's overall importance
  /// is used to impact it.
  static const BIND_ADJUST_WITH_ACTIVITY = 128;

  /// from: static public final int BIND_ALLOW_OOM_MANAGEMENT
  ///
  /// Flag for \#bindService: allow the process hosting the bound
  /// service to go through its normal memory management.  It will be
  /// treated more like a running service, allowing the system to
  /// (temporarily) expunge the process if low on memory or for some other
  /// whim it may have, and being more aggressive about making it a candidate
  /// to be killed (and restarted) if running for a long time.
  static const BIND_ALLOW_OOM_MANAGEMENT = 16;

  /// from: static public final int BIND_AUTO_CREATE
  ///
  /// Flag for \#bindService: automatically create the service as long
  /// as the binding exists.  Note that while this will create the service,
  /// its android.app.Service\#onStartCommand
  /// method will still only be called due to an
  /// explicit call to \#startService.  Even without that, though,
  /// this still provides you with access to the service object while the
  /// service is created.
  ///
  /// Note that prior to android.os.Build.VERSION_CODES\#ICE_CREAM_SANDWICH,
  /// not supplying this flag would also impact how important the system
  /// consider's the target service's process to be.  When set, the only way
  /// for it to be raised was by binding from a service in which case it will
  /// only be important when that activity is in the foreground.  Now to
  /// achieve this behavior you must explicitly supply the new flag
  /// \#BIND_ADJUST_WITH_ACTIVITY.  For compatibility, old applications
  /// that don't specify \#BIND_AUTO_CREATE will automatically have
  /// the flags \#BIND_WAIVE_PRIORITY and
  /// \#BIND_ADJUST_WITH_ACTIVITY set for them in order to achieve
  /// the same result.
  static const BIND_AUTO_CREATE = 1;

  /// from: static public final int BIND_DEBUG_UNBIND
  ///
  /// Flag for \#bindService: include debugging help for mismatched
  /// calls to unbind.  When this flag is set, the callstack of the following
  /// \#unbindService call is retained, to be printed if a later
  /// incorrect unbind call is made.  Note that doing this requires retaining
  /// information about the binding that was made for the lifetime of the app,
  /// resulting in a leak -- this should only be used for debugging.
  static const BIND_DEBUG_UNBIND = 2;

  /// from: static public final int BIND_EXTERNAL_SERVICE
  ///
  /// Flag for \#bindService: The service being bound is an
  /// android.R.attr\#isolatedProcess isolated,
  /// android.R.attr\#externalService external service.  This binds the service into the
  /// calling application's package, rather than the package in which the service is declared.
  ///
  /// When using this flag, the code for the service being bound will execute under the calling
  /// application's package name and user ID.  Because the service must be an isolated process,
  /// it will not have direct access to the application's data, though.
  ///
  /// The purpose of this flag is to allow applications to provide services that are attributed
  /// to the app using the service, rather than the application providing the service.
  ///
  ///
  static const BIND_EXTERNAL_SERVICE = -2147483648;

  /// from: static public final int BIND_IMPORTANT
  ///
  /// Flag for \#bindService: this service is very important to
  /// the client, so should be brought to the foreground process level
  /// when the client is.  Normally a process can only be raised to the
  /// visibility level by a client, even if that client is in the foreground.
  static const BIND_IMPORTANT = 64;

  /// from: static public final int BIND_NOT_FOREGROUND
  ///
  /// Flag for \#bindService: don't allow this binding to raise
  /// the target service's process to the foreground scheduling priority.
  /// It will still be raised to at least the same memory priority
  /// as the client (so that its process will not be killable in any
  /// situation where the client is not killable), but for CPU scheduling
  /// purposes it may be left in the background.  This only has an impact
  /// in the situation where the binding client is a foreground process
  /// and the target service is in a background process.
  static const BIND_NOT_FOREGROUND = 4;

  /// from: static public final int BIND_WAIVE_PRIORITY
  ///
  /// Flag for \#bindService: don't impact the scheduling or
  /// memory management priority of the target service's hosting process.
  /// Allows the service's process to be managed on the background LRU list
  /// just like a regular application process in the background.
  static const BIND_WAIVE_PRIORITY = 32;

  /// from: static public final java.lang.String BLUETOOTH_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.bluetooth.BluetoothManager for using Bluetooth.
  ///@see \#getSystemService(String)
  static const BLUETOOTH_SERVICE = "bluetooth";

  /// from: static public final java.lang.String CAMERA_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.hardware.camera2.CameraManager for interacting with
  /// camera devices.
  ///@see \#getSystemService(String)
  ///@see android.hardware.camera2.CameraManager
  static const CAMERA_SERVICE = "camera";

  /// from: static public final java.lang.String CAPTIONING_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.view.accessibility.CaptioningManager for obtaining
  /// captioning properties and listening for changes in captioning
  /// preferences.
  ///@see \#getSystemService(String)
  ///@see android.view.accessibility.CaptioningManager
  static const CAPTIONING_SERVICE = "captioning";

  /// from: static public final java.lang.String CARRIER_CONFIG_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.telephony.CarrierConfigManager for reading carrier configuration values.
  ///@see \#getSystemService(String)
  ///@see android.telephony.CarrierConfigManager
  static const CARRIER_CONFIG_SERVICE = "carrier_config";

  /// from: static public final java.lang.String CLIPBOARD_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.content.ClipboardManager for accessing and modifying
  /// the contents of the global clipboard.
  ///@see \#getSystemService(String)
  ///@see android.content.ClipboardManager
  static const CLIPBOARD_SERVICE = "clipboard";

  /// from: static public final java.lang.String COMPANION_DEVICE_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.companion.CompanionDeviceManager for managing companion devices
  ///@see \#getSystemService(String)
  ///@see android.companion.CompanionDeviceManager
  static const COMPANION_DEVICE_SERVICE = "companiondevice";

  /// from: static public final java.lang.String CONNECTIVITY_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.net.ConnectivityManager for handling management of
  /// network connections.
  ///@see \#getSystemService(String)
  ///@see android.net.ConnectivityManager
  static const CONNECTIVITY_SERVICE = "connectivity";

  /// from: static public final java.lang.String CONSUMER_IR_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.hardware.ConsumerIrManager for transmitting infrared
  /// signals from the device.
  ///@see \#getSystemService(String)
  ///@see android.hardware.ConsumerIrManager
  static const CONSUMER_IR_SERVICE = "consumer_ir";

  /// from: static public final int CONTEXT_IGNORE_SECURITY
  ///
  /// Flag for use with \#createPackageContext: ignore any security
  /// restrictions on the Context being requested, allowing it to always
  /// be loaded.  For use with \#CONTEXT_INCLUDE_CODE to allow code
  /// to be loaded into a process even when it isn't safe to do so.  Use
  /// with extreme care!
  static const CONTEXT_IGNORE_SECURITY = 2;

  /// from: static public final int CONTEXT_INCLUDE_CODE
  ///
  /// Flag for use with \#createPackageContext: include the application
  /// code with the context.  This means loading code into the caller's
  /// process, so that \#getClassLoader() can be used to instantiate
  /// the application's classes.  Setting this flags imposes security
  /// restrictions on what application context you can access; if the
  /// requested application can not be safely loaded into your process,
  /// java.lang.SecurityException will be thrown.  If this flag is not set,
  /// there will be no restrictions on the packages that can be loaded,
  /// but \#getClassLoader will always return the default system
  /// class loader.
  static const CONTEXT_INCLUDE_CODE = 1;

  /// from: static public final int CONTEXT_RESTRICTED
  ///
  /// Flag for use with \#createPackageContext: a restricted context may
  /// disable specific features. For instance, a View associated with a restricted
  /// context would ignore particular XML attributes.
  static const CONTEXT_RESTRICTED = 4;

  /// from: static public final java.lang.String CROSS_PROFILE_APPS_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.content.pm.CrossProfileApps for cross profile operations.
  ///@see \#getSystemService(String)
  static const CROSS_PROFILE_APPS_SERVICE = "crossprofileapps";

  /// from: static public final java.lang.String DEVICE_POLICY_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.app.admin.DevicePolicyManager for working with global
  /// device policy management.
  ///@see \#getSystemService(String)
  static const DEVICE_POLICY_SERVICE = "device_policy";

  /// from: static public final java.lang.String DISPLAY_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.hardware.display.DisplayManager for interacting with display devices.
  ///@see \#getSystemService(String)
  ///@see android.hardware.display.DisplayManager
  static const DISPLAY_SERVICE = "display";

  /// from: static public final java.lang.String DOWNLOAD_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.app.DownloadManager for requesting HTTP downloads.
  ///@see \#getSystemService(String)
  static const DOWNLOAD_SERVICE = "download";

  /// from: static public final java.lang.String DROPBOX_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.os.DropBoxManager instance for recording
  /// diagnostic logs.
  ///@see \#getSystemService(String)
  static const DROPBOX_SERVICE = "dropbox";

  /// from: static public final java.lang.String EUICC_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.telephony.euicc.EuiccManager to manage the device eUICC (embedded SIM).
  ///@see \#getSystemService(String)
  ///@see android.telephony.euicc.EuiccManager
  static const EUICC_SERVICE = "euicc";

  /// from: static public final java.lang.String FINGERPRINT_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.hardware.fingerprint.FingerprintManager for handling management
  /// of fingerprints.
  ///@see \#getSystemService(String)
  ///@see android.hardware.fingerprint.FingerprintManager
  static const FINGERPRINT_SERVICE = "fingerprint";

  /// from: static public final java.lang.String HARDWARE_PROPERTIES_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.os.HardwarePropertiesManager for accessing the hardware properties service.
  ///@see \#getSystemService(String)
  static const HARDWARE_PROPERTIES_SERVICE = "hardware_properties";

  /// from: static public final java.lang.String INPUT_METHOD_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.view.inputmethod.InputMethodManager for accessing input
  /// methods.
  ///@see \#getSystemService(String)
  static const INPUT_METHOD_SERVICE = "input_method";

  /// from: static public final java.lang.String INPUT_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.hardware.input.InputManager for interacting with input devices.
  ///@see \#getSystemService(String)
  ///@see android.hardware.input.InputManager
  static const INPUT_SERVICE = "input";

  /// from: static public final java.lang.String IPSEC_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.net.IpSecManager for encrypting Sockets or Networks with
  /// IPSec.
  ///@see \#getSystemService(String)
  static const IPSEC_SERVICE = "ipsec";

  /// from: static public final java.lang.String JOB_SCHEDULER_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.app.job.JobScheduler instance for managing occasional
  /// background tasks.
  ///@see \#getSystemService(String)
  ///@see android.app.job.JobScheduler
  static const JOB_SCHEDULER_SERVICE = "jobscheduler";

  /// from: static public final java.lang.String KEYGUARD_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.app.NotificationManager for controlling keyguard.
  ///@see \#getSystemService(String)
  ///@see android.app.KeyguardManager
  static const KEYGUARD_SERVICE = "keyguard";

  /// from: static public final java.lang.String LAUNCHER_APPS_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.content.pm.LauncherApps for querying and monitoring launchable apps across
  /// profiles of a user.
  ///@see \#getSystemService(String)
  ///@see android.content.pm.LauncherApps
  static const LAUNCHER_APPS_SERVICE = "launcherapps";

  /// from: static public final java.lang.String LAYOUT_INFLATER_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.view.LayoutInflater for inflating layout resources in this
  /// context.
  ///@see \#getSystemService(String)
  ///@see android.view.LayoutInflater
  static const LAYOUT_INFLATER_SERVICE = "layout_inflater";

  /// from: static public final java.lang.String LOCATION_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.location.LocationManager for controlling location
  /// updates.
  ///@see \#getSystemService(String)
  ///@see android.location.LocationManager
  static const LOCATION_SERVICE = "location";

  /// from: static public final java.lang.String MEDIA_PROJECTION_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.media.projection.MediaProjectionManager instance for managing
  /// media projection sessions.
  ///@see \#getSystemService(String)
  ///@see android.media.projection.MediaProjectionManager
  static const MEDIA_PROJECTION_SERVICE = "media_projection";

  /// from: static public final java.lang.String MEDIA_ROUTER_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.media.MediaRouter for controlling and managing
  /// routing of media.
  ///@see \#getSystemService(String)
  ///@see android.media.MediaRouter
  static const MEDIA_ROUTER_SERVICE = "media_router";

  /// from: static public final java.lang.String MEDIA_SESSION_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.media.session.MediaSessionManager for managing media Sessions.
  ///@see \#getSystemService(String)
  ///@see android.media.session.MediaSessionManager
  static const MEDIA_SESSION_SERVICE = "media_session";

  /// from: static public final java.lang.String MIDI_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.media.midi.MidiManager for accessing the MIDI service.
  ///@see \#getSystemService(String)
  static const MIDI_SERVICE = "midi";

  /// from: static public final int MODE_APPEND
  ///
  /// File creation mode: for use with \#openFileOutput, if the file
  /// already exists then write data to the end of the existing file
  /// instead of erasing it.
  ///@see \#openFileOutput
  static const MODE_APPEND = 32768;

  /// from: static public final int MODE_ENABLE_WRITE_AHEAD_LOGGING
  ///
  /// Database open flag: when set, the database is opened with write-ahead
  /// logging enabled by default.
  ///@see \#openOrCreateDatabase(String, int, CursorFactory)
  ///@see \#openOrCreateDatabase(String, int, CursorFactory, DatabaseErrorHandler)
  ///@see SQLiteDatabase\#enableWriteAheadLogging
  static const MODE_ENABLE_WRITE_AHEAD_LOGGING = 8;

  /// from: static public final int MODE_MULTI_PROCESS
  ///
  /// SharedPreference loading flag: when set, the file on disk will
  /// be checked for modification even if the shared preferences
  /// instance is already loaded in this process.  This behavior is
  /// sometimes desired in cases where the application has multiple
  /// processes, all writing to the same SharedPreferences file.
  /// Generally there are better forms of communication between
  /// processes, though.
  ///
  /// This was the legacy (but undocumented) behavior in and
  /// before Gingerbread (Android 2.3) and this flag is implied when
  /// targetting such releases.  For applications targetting SDK
  /// versions _greater than_ Android 2.3, this flag must be
  /// explicitly set if desired.
  ///@see \#getSharedPreferences
  ///@deprecated MODE_MULTI_PROCESS does not work reliably in
  /// some versions of Android, and furthermore does not provide any
  /// mechanism for reconciling concurrent modifications across
  /// processes.  Applications should not attempt to use it.  Instead,
  /// they should use an explicit cross-process data management
  /// approach such as android.content.ContentProvider ContentProvider.
  static const MODE_MULTI_PROCESS = 4;

  /// from: static public final int MODE_NO_LOCALIZED_COLLATORS
  ///
  /// Database open flag: when set, the database is opened without support for
  /// localized collators.
  ///@see \#openOrCreateDatabase(String, int, CursorFactory)
  ///@see \#openOrCreateDatabase(String, int, CursorFactory, DatabaseErrorHandler)
  ///@see SQLiteDatabase\#NO_LOCALIZED_COLLATORS
  static const MODE_NO_LOCALIZED_COLLATORS = 16;

  /// from: static public final int MODE_PRIVATE
  ///
  /// File creation mode: the default mode, where the created file can only
  /// be accessed by the calling application (or all applications sharing the
  /// same user ID).
  static const MODE_PRIVATE = 0;

  /// from: static public final int MODE_WORLD_READABLE
  ///
  /// File creation mode: allow all other applications to have read access to
  /// the created file.
  ///
  /// Starting from android.os.Build.VERSION_CODES\#N, attempting to use this
  /// mode throws a SecurityException.
  ///@deprecated Creating world-readable files is very dangerous, and likely
  ///             to cause security holes in applications. It is strongly
  ///             discouraged; instead, applications should use more formal
  ///             mechanism for interactions such as ContentProvider,
  ///             BroadcastReceiver, and android.app.Service.
  ///             There are no guarantees that this access mode will remain on
  ///             a file, such as when it goes through a backup and restore.
  ///@see android.support.v4.content.FileProvider
  ///@see Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  static const MODE_WORLD_READABLE = 1;

  /// from: static public final int MODE_WORLD_WRITEABLE
  ///
  /// File creation mode: allow all other applications to have write access to
  /// the created file.
  ///
  /// Starting from android.os.Build.VERSION_CODES\#N, attempting to use this
  /// mode will throw a SecurityException.
  ///@deprecated Creating world-writable files is very dangerous, and likely
  ///             to cause security holes in applications. It is strongly
  ///             discouraged; instead, applications should use more formal
  ///             mechanism for interactions such as ContentProvider,
  ///             BroadcastReceiver, and android.app.Service.
  ///             There are no guarantees that this access mode will remain on
  ///             a file, such as when it goes through a backup and restore.
  ///@see android.support.v4.content.FileProvider
  ///@see Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  static const MODE_WORLD_WRITEABLE = 2;

  /// from: static public final java.lang.String NETWORK_STATS_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.app.usage.NetworkStatsManager for querying network usage stats.
  ///@see \#getSystemService(String)
  ///@see android.app.usage.NetworkStatsManager
  static const NETWORK_STATS_SERVICE = "netstats";

  /// from: static public final java.lang.String NFC_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.nfc.NfcManager for using NFC.
  ///@see \#getSystemService(String)
  static const NFC_SERVICE = "nfc";

  /// from: static public final java.lang.String NOTIFICATION_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.app.NotificationManager for informing the user of
  /// background events.
  ///@see \#getSystemService(String)
  ///@see android.app.NotificationManager
  static const NOTIFICATION_SERVICE = "notification";

  /// from: static public final java.lang.String NSD_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.net.nsd.NsdManager for handling management of network service
  /// discovery
  ///@see \#getSystemService(String)
  ///@see android.net.nsd.NsdManager
  static const NSD_SERVICE = "servicediscovery";

  /// from: static public final java.lang.String POWER_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.os.PowerManager for controlling power management,
  /// including "wake locks," which let you keep the device on while
  /// you're running long tasks.
  static const POWER_SERVICE = "power";

  /// from: static public final java.lang.String PRINT_SERVICE
  ///
  /// android.print.PrintManager for printing and managing
  /// printers and print tasks.
  ///@see \#getSystemService(String)
  ///@see android.print.PrintManager
  static const PRINT_SERVICE = "print";

  /// from: static public final int RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///
  /// Flag for \#registerReceiver: The receiver can receive broadcasts from Instant Apps.
  static const RECEIVER_VISIBLE_TO_INSTANT_APPS = 1;

  /// from: static public final java.lang.String RESTRICTIONS_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.content.RestrictionsManager for retrieving application restrictions
  /// and requesting permissions for restricted operations.
  ///@see \#getSystemService(String)
  ///@see android.content.RestrictionsManager
  static const RESTRICTIONS_SERVICE = "restrictions";

  /// from: static public final java.lang.String SEARCH_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.app.SearchManager for handling searches.
  ///
  ///
  /// Configuration\#UI_MODE_TYPE_WATCH does not support
  /// android.app.SearchManager.
  ///@see \#getSystemService
  ///@see android.app.SearchManager
  static const SEARCH_SERVICE = "search";

  /// from: static public final java.lang.String SENSOR_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.hardware.SensorManager for accessing sensors.
  ///@see \#getSystemService(String)
  ///@see android.hardware.SensorManager
  static const SENSOR_SERVICE = "sensor";

  /// from: static public final java.lang.String SHORTCUT_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.content.pm.ShortcutManager for accessing the launcher shortcut service.
  ///@see \#getSystemService(String)
  ///@see android.content.pm.ShortcutManager
  static const SHORTCUT_SERVICE = "shortcut";

  /// from: static public final java.lang.String STORAGE_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.os.storage.StorageManager for accessing system storage
  /// functions.
  ///@see \#getSystemService(String)
  ///@see android.os.storage.StorageManager
  static const STORAGE_SERVICE = "storage";

  /// from: static public final java.lang.String STORAGE_STATS_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.app.usage.StorageStatsManager for accessing system storage
  /// statistics.
  ///@see \#getSystemService(String)
  ///@see android.app.usage.StorageStatsManager
  static const STORAGE_STATS_SERVICE = "storagestats";

  /// from: static public final java.lang.String SYSTEM_HEALTH_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.os.health.SystemHealthManager for accessing system health (battery, power,
  /// memory, etc) metrics.
  ///@see \#getSystemService(String)
  static const SYSTEM_HEALTH_SERVICE = "systemhealth";

  /// from: static public final java.lang.String TELECOM_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.telecom.TelecomManager to manage telecom-related features
  /// of the device.
  ///@see \#getSystemService(String)
  ///@see android.telecom.TelecomManager
  static const TELECOM_SERVICE = "telecom";

  /// from: static public final java.lang.String TELEPHONY_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.telephony.TelephonyManager for handling management the
  /// telephony features of the device.
  ///@see \#getSystemService(String)
  ///@see android.telephony.TelephonyManager
  static const TELEPHONY_SERVICE = "phone";

  /// from: static public final java.lang.String TELEPHONY_SUBSCRIPTION_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.telephony.SubscriptionManager for handling management the
  /// telephony subscriptions of the device.
  ///@see \#getSystemService(String)
  ///@see android.telephony.SubscriptionManager
  static const TELEPHONY_SUBSCRIPTION_SERVICE =
      "telephony_subscription_service";

  /// from: static public final java.lang.String TEXT_CLASSIFICATION_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// TextClassificationManager for text classification services.
  ///@see \#getSystemService(String)
  ///@see TextClassificationManager
  static const TEXT_CLASSIFICATION_SERVICE = "textclassification";

  /// from: static public final java.lang.String TEXT_SERVICES_MANAGER_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.view.textservice.TextServicesManager for accessing
  /// text services.
  ///@see \#getSystemService(String)
  static const TEXT_SERVICES_MANAGER_SERVICE = "textservices";

  /// from: static public final java.lang.String TV_INPUT_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.media.tv.TvInputManager for interacting with TV inputs
  /// on the device.
  ///@see \#getSystemService(String)
  ///@see android.media.tv.TvInputManager
  static const TV_INPUT_SERVICE = "tv_input";

  /// from: static public final java.lang.String UI_MODE_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.app.UiModeManager for controlling UI modes.
  ///@see \#getSystemService(String)
  static const UI_MODE_SERVICE = "uimode";

  /// from: static public final java.lang.String USAGE_STATS_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.app.usage.UsageStatsManager for querying device usage stats.
  ///@see \#getSystemService(String)
  ///@see android.app.usage.UsageStatsManager
  static const USAGE_STATS_SERVICE = "usagestats";

  /// from: static public final java.lang.String USB_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.hardware.usb.UsbManager for access to USB devices (as a USB host)
  /// and for controlling this device's behavior as a USB device.
  ///@see \#getSystemService(String)
  ///@see android.hardware.usb.UsbManager
  static const USB_SERVICE = "usb";

  /// from: static public final java.lang.String USER_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.os.UserManager for managing users on devices that support multiple users.
  ///@see \#getSystemService(String)
  ///@see android.os.UserManager
  static const USER_SERVICE = "user";

  /// from: static public final java.lang.String VIBRATOR_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.os.Vibrator for interacting with the vibration hardware.
  ///@see \#getSystemService(String)
  ///@see android.os.Vibrator
  static const VIBRATOR_SERVICE = "vibrator";

  /// from: static public final java.lang.String WALLPAPER_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// com.android.server.WallpaperService for accessing wallpapers.
  ///@see \#getSystemService(String)
  static const WALLPAPER_SERVICE = "wallpaper";

  /// from: static public final java.lang.String WIFI_AWARE_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.net.wifi.aware.WifiAwareManager for handling management of
  /// Wi-Fi Aware.
  ///@see \#getSystemService(String)
  ///@see android.net.wifi.aware.WifiAwareManager
  static const WIFI_AWARE_SERVICE = "wifiaware";

  /// from: static public final java.lang.String WIFI_P2P_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.net.wifi.p2p.WifiP2pManager for handling management of
  /// Wi-Fi peer-to-peer connections.
  ///@see \#getSystemService(String)
  ///@see android.net.wifi.p2p.WifiP2pManager
  static const WIFI_P2P_SERVICE = "wifip2p";

  /// from: static public final java.lang.String WIFI_RTT_RANGING_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.net.wifi.rtt.WifiRttManager for ranging devices with wifi
  ///
  /// Note: this is a replacement for WIFI_RTT_SERVICE above. It will
  /// be renamed once final implementation in place.
  ///@see \#getSystemService(String)
  ///@see android.net.wifi.rtt.WifiRttManager
  static const WIFI_RTT_RANGING_SERVICE = "wifirtt";

  /// from: static public final java.lang.String WIFI_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a android.net.wifi.WifiManager for handling management of
  /// Wi-Fi access.
  ///@see \#getSystemService(String)
  ///@see android.net.wifi.WifiManager
  static const WIFI_SERVICE = "wifi";

  /// from: static public final java.lang.String WINDOW_SERVICE
  ///
  /// Use with \#getSystemService(String) to retrieve a
  /// android.view.WindowManager for accessing the system's window
  /// manager.
  ///@see \#getSystemService(String)
  ///@see android.view.WindowManager
  static const WINDOW_SERVICE = "window";

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_Context_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Context() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _getAssets = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Context_getAssets")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.res.AssetManager getAssets()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an AssetManager instance for the application's package.
  ///
  /// <strong>Note:</strong> Implementations of this method should return
  /// an AssetManager instance that is consistent with the Resources instance
  /// returned by \#getResources(). For example, they should share the
  /// same Configuration object.
  ///@return an AssetManager instance for the application's package
  ///@see \#getResources()
  res_.AssetManager getAssets() {
    final result__ = res_.AssetManager.fromRef(_getAssets(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getResources = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getResources")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.res.Resources getResources()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Resources instance for the application's package.
  ///
  /// <strong>Note:</strong> Implementations of this method should return
  /// a Resources instance that is consistent with the AssetManager instance
  /// returned by \#getAssets(). For example, they should share the
  /// same Configuration object.
  ///@return a Resources instance for the application's package
  ///@see \#getAssets()
  res_.Resources getResources() {
    final result__ = res_.Resources.fromRef(_getResources(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPackageManager = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getPackageManager")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.pm.PackageManager getPackageManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return PackageManager instance to find global package information.
  pm_.PackageManager getPackageManager() {
    final result__ = pm_.PackageManager.fromRef(_getPackageManager(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getContentResolver = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getContentResolver")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.ContentResolver getContentResolver()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a ContentResolver instance for your application's package.
  ContentResolver getContentResolver() {
    final result__ = ContentResolver.fromRef(_getContentResolver(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getMainLooper = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getMainLooper")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.os.Looper getMainLooper()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Looper for the main thread of the current process.  This is
  /// the thread used to dispatch calls to application components (activities,
  /// services, etc).
  ///
  /// By definition, this method returns the same result as would be obtained
  /// by calling Looper\#getMainLooper() Looper.getMainLooper().
  ///
  ///
  ///@return The main looper.
  os_.Looper getMainLooper() {
    final result__ = os_.Looper.fromRef(_getMainLooper(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getMainExecutor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getMainExecutor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.concurrent.Executor getMainExecutor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an Executor that will run enqueued tasks on the main
  /// thread associated with this context. This is the thread used to dispatch
  /// calls to application components (activities, services, etc).
  jni.JniObject getMainExecutor() {
    final result__ = jni.JniObject.fromRef(_getMainExecutor(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getApplicationContext = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getApplicationContext")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Context getApplicationContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the context of the single, global Application object of the
  /// current process.  This generally should only be used if you need a
  /// Context whose lifecycle is separate from the current context, that is
  /// tied to the lifetime of the process rather than the current component.
  ///
  /// Consider for example how this interacts with
  /// \#registerReceiver(BroadcastReceiver, IntentFilter):
  /// <ul>
  /// <li> If used from an Activity context, the receiver is being registered
  /// within that activity.  This means that you are expected to unregister
  /// before the activity is done being destroyed; in fact if you do not do
  /// so, the framework will clean up your leaked registration as it removes
  /// the activity and log an error.  Thus, if you use the Activity context
  /// to register a receiver that is static (global to the process, not
  /// associated with an Activity instance) then that registration will be
  /// removed on you at whatever point the activity you used is destroyed.
  /// <li> If used from the Context returned here, the receiver is being
  /// registered with the global state associated with your application.  Thus
  /// it will never be unregistered for you.  This is necessary if the receiver
  /// is associated with static data, not a particular component.  However
  /// using the ApplicationContext elsewhere can easily lead to serious leaks
  /// if you forget to unregister, unbind, etc.
  /// </ul>
  Context getApplicationContext() {
    final result__ = Context.fromRef(_getApplicationContext(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _registerComponentCallbacks = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_registerComponentCallbacks")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerComponentCallbacks(android.content.ComponentCallbacks callback)
  ///
  /// Add a new ComponentCallbacks to the base application of the
  /// Context, which will be called at the same times as the ComponentCallbacks
  /// methods of activities and other components are called.  Note that you
  /// _must_ be sure to use \#unregisterComponentCallbacks when
  /// appropriate in the future; this will not be removed for you.
  ///@param callback The interface to call.  This can be either a
  /// ComponentCallbacks or ComponentCallbacks2 interface.
  void registerComponentCallbacks(ComponentCallbacks callback) {
    final result__ = _registerComponentCallbacks(reference, callback.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _unregisterComponentCallbacks = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_unregisterComponentCallbacks")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterComponentCallbacks(android.content.ComponentCallbacks callback)
  ///
  /// Remove a ComponentCallbacks object that was previously registered
  /// with \#registerComponentCallbacks(ComponentCallbacks).
  void unregisterComponentCallbacks(ComponentCallbacks callback) {
    final result__ =
        _unregisterComponentCallbacks(reference, callback.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getText = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Context_getText")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final java.lang.CharSequence getText(int resId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a localized, styled CharSequence from the application's package's
  /// default string table.
  ///@param resId Resource id for the CharSequence text
  ///@return This value will never be {@code null}.
  jni.JniObject getText(int resId) {
    final result__ = jni.JniObject.fromRef(_getText(reference, resId));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getString = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Context_getString")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final java.lang.String getString(int resId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a localized string from the application's package's
  /// default string table.
  ///@param resId Resource id for the string
  ///@return The string data associated with the resource, stripped of styled
  ///         text information.
  ///
  /// This value will never be {@code null}.
  jni.JniString getString(int resId) {
    final result__ = jni.JniString.fromRef(_getString(reference, resId));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getString1 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_content_Context_getString1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String getString(int resId, java.lang.Object[] formatArgs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a localized formatted string from the application's package's
  /// default string table, substituting the format arguments as defined in
  /// java.util.Formatter and java.lang.String\#format.
  ///@param resId Resource id for the format string
  ///@param formatArgs The format arguments that will be used for
  ///                   substitution.
  ///@return The string data associated with the resource, formatted and
  ///         stripped of styled text information.
  ///
  /// This value will never be {@code null}.
  jni.JniString getString1(int resId, jni.JniObject formatArgs) {
    final result__ = jni.JniString.fromRef(
        _getString1(reference, resId, formatArgs.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getColor = jniLookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Context_getColor")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final int getColor(int id)
  ///
  /// Returns a color associated with a particular resource ID and styled for
  /// the current theme.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@return A single color value in the form 0xAARRGGBB.
  ///@throws android.content.res.Resources.NotFoundException if the given ID
  ///         does not exist.
  int getColor(int id) {
    final result__ = _getColor(reference, id);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDrawable = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Context_getDrawable")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final android.graphics.drawable.Drawable getDrawable(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a drawable object associated with a particular resource ID and
  /// styled for the current theme.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@return An object that can be used to draw this resource.
  /// This value may be {@code null}.
  ///@throws android.content.res.Resources.NotFoundException if the given ID
  ///         does not exist.
  jni.JniObject getDrawable(int id) {
    final result__ = jni.JniObject.fromRef(_getDrawable(reference, id));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getColorStateList = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Context_getColorStateList")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final android.content.res.ColorStateList getColorStateList(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a color state list associated with a particular resource ID and
  /// styled for the current theme.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@return A color state list.
  /// This value will never be {@code null}.
  ///@throws android.content.res.Resources.NotFoundException if the given ID
  ///         does not exist.
  res_.ColorStateList getColorStateList(int id) {
    final result__ =
        res_.ColorStateList.fromRef(_getColorStateList(reference, id));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setTheme = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Context_setTheme")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setTheme(int resid)
  ///
  /// Set the base theme for this context.  Note that this should be called
  /// before any views are instantiated in the Context (for example before
  /// calling android.app.Activity\#setContentView or
  /// android.view.LayoutInflater\#inflate).
  ///@param resid The style resource describing the theme.
  void setTheme(int resid) {
    final result__ = _setTheme(reference, resid);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getTheme = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Context_getTheme")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.res.Resources.Theme getTheme()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Theme object associated with this Context.
  res_.Resources_Theme getTheme() {
    final result__ = res_.Resources_Theme.fromRef(_getTheme(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _obtainStyledAttributes = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_obtainStyledAttributes")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.TypedArray obtainStyledAttributes(int[] attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve styled attribute information in this Context's theme.  See
  /// android.content.res.Resources.Theme\#obtainStyledAttributes(int[])
  /// for more information.
  ///@see android.content.res.Resources.Theme\#obtainStyledAttributes(int[])
  res_.TypedArray obtainStyledAttributes(jni.JniObject attrs) {
    final result__ = res_.TypedArray.fromRef(
        _obtainStyledAttributes(reference, attrs.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _obtainStyledAttributes1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_obtainStyledAttributes1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.TypedArray obtainStyledAttributes(int resid, int[] attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve styled attribute information in this Context's theme.  See
  /// android.content.res.Resources.Theme\#obtainStyledAttributes(int, int[])
  /// for more information.
  ///@see android.content.res.Resources.Theme\#obtainStyledAttributes(int, int[])
  res_.TypedArray obtainStyledAttributes1(int resid, jni.JniObject attrs) {
    final result__ = res_.TypedArray.fromRef(
        _obtainStyledAttributes1(reference, resid, attrs.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _obtainStyledAttributes2 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_obtainStyledAttributes2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.TypedArray obtainStyledAttributes(android.util.AttributeSet set, int[] attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve styled attribute information in this Context's theme.  See
  /// android.content.res.Resources.Theme\#obtainStyledAttributes(AttributeSet, int[], int, int)
  /// for more information.
  ///@see android.content.res.Resources.Theme\#obtainStyledAttributes(AttributeSet, int[], int, int)
  res_.TypedArray obtainStyledAttributes2(
      jni.JniObject set0, jni.JniObject attrs) {
    final result__ = res_.TypedArray.fromRef(
        _obtainStyledAttributes2(reference, set0.reference, attrs.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _obtainStyledAttributes3 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32)>>(
          "android_content_Context_obtainStyledAttributes3")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final android.content.res.TypedArray obtainStyledAttributes(android.util.AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve styled attribute information in this Context's theme.  See
  /// android.content.res.Resources.Theme\#obtainStyledAttributes(AttributeSet, int[], int, int)
  /// for more information.
  ///@see android.content.res.Resources.Theme\#obtainStyledAttributes(AttributeSet, int[], int, int)
  res_.TypedArray obtainStyledAttributes3(jni.JniObject set0,
      jni.JniObject attrs, int defStyleAttr, int defStyleRes) {
    final result__ = res_.TypedArray.fromRef(_obtainStyledAttributes3(
        reference, set0.reference, attrs.reference, defStyleAttr, defStyleRes));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getClassLoader = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getClassLoader")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.ClassLoader getClassLoader()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a class loader you can use to retrieve classes in this package.
  jni.JniObject getClassLoader() {
    final result__ = jni.JniObject.fromRef(_getClassLoader(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPackageName = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getPackageName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getPackageName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the name of this application's package.
  jni.JniString getPackageName() {
    final result__ = jni.JniString.fromRef(_getPackageName(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getApplicationInfo = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getApplicationInfo")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.pm.ApplicationInfo getApplicationInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the full application info for this context's package.
  pm_.ApplicationInfo getApplicationInfo() {
    final result__ =
        pm_.ApplicationInfo.fromRef(_getApplicationInfo(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPackageResourcePath = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getPackageResourcePath")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getPackageResourcePath()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the full path to this context's primary Android package.
  /// The Android package is a ZIP file which contains the application's
  /// primary resources.
  ///
  /// Note: this is not generally useful for applications, since they should
  /// not be directly accessing the file system.
  ///@return String Path to the resources.
  jni.JniString getPackageResourcePath() {
    final result__ = jni.JniString.fromRef(_getPackageResourcePath(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPackageCodePath = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getPackageCodePath")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getPackageCodePath()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the full path to this context's primary Android package.
  /// The Android package is a ZIP file which contains application's
  /// primary code and assets.
  ///
  /// Note: this is not generally useful for applications, since they should
  /// not be directly accessing the file system.
  ///@return String Path to the code and assets.
  jni.JniString getPackageCodePath() {
    final result__ = jni.JniString.fromRef(_getPackageCodePath(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSharedPreferences = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Context_getSharedPreferences")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.SharedPreferences getSharedPreferences(java.lang.String name, int mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve and hold the contents of the preferences file 'name', returning
  /// a SharedPreferences through which you can retrieve and modify its
  /// values.  Only one instance of the SharedPreferences object is returned
  /// to any callers for the same name, meaning they will see each other's
  /// edits as soon as they are made.
  ///
  /// This method is thead-safe.
  ///@param name Desired preferences file. If a preferences file by this name
  /// does not exist, it will be created when you retrieve an
  /// editor (SharedPreferences.edit()) and then commit changes (Editor.commit()).
  ///@param mode Operating mode.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Context\#MODE_PRIVATE, android.content.Context\#MODE_WORLD_READABLE, android.content.Context\#MODE_WORLD_WRITEABLE, and android.content.Context\#MODE_MULTI_PROCESS
  ///@return The single SharedPreferences instance that can be used
  ///         to retrieve and modify the preference values.
  ///@see \#MODE_PRIVATE
  SharedPreferences getSharedPreferences(jni.JniString name, int mode) {
    final result__ = SharedPreferences.fromRef(
        _getSharedPreferences(reference, name.reference, mode));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _moveSharedPreferencesFrom = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_moveSharedPreferencesFrom")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean moveSharedPreferencesFrom(android.content.Context sourceContext, java.lang.String name)
  ///
  /// Move an existing shared preferences file from the given source storage
  /// context to this context. This is typically used to migrate data between
  /// storage locations after an upgrade, such as moving to device protected
  /// storage.
  ///@param sourceContext The source context which contains the existing
  ///            shared preferences to move.
  ///@param name The name of the shared preferences file.
  ///@return {@code true} if the move was successful or if the shared
  ///         preferences didn't exist in the source context, otherwise
  ///         {@code false}.
  ///@see \#createDeviceProtectedStorageContext()
  bool moveSharedPreferencesFrom(Context sourceContext, jni.JniString name) {
    final result__ = _moveSharedPreferencesFrom(
            reference, sourceContext.reference, name.reference) !=
        0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _deleteSharedPreferences = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_deleteSharedPreferences")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean deleteSharedPreferences(java.lang.String name)
  ///
  /// Delete an existing shared preferences file.
  ///@param name The name (unique in the application package) of the shared
  ///            preferences file.
  ///@return {@code true} if the shared preferences file was successfully
  ///         deleted; else {@code false}.
  ///@see \#getSharedPreferences(String, int)
  bool deleteSharedPreferences(jni.JniString name) {
    final result__ = _deleteSharedPreferences(reference, name.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openFileInput = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_openFileInput")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.FileInputStream openFileInput(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a private file associated with this Context's application package
  /// for reading.
  ///@param name The name of the file to open; can not contain path
  ///             separators.
  ///@return The resulting FileInputStream.
  ///@see \#openFileOutput
  ///@see \#fileList
  ///@see \#deleteFile
  ///@see java.io.FileInputStream\#FileInputStream(String)
  jni.JniObject openFileInput(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_openFileInput(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openFileOutput = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Context_openFileOutput")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.io.FileOutputStream openFileOutput(java.lang.String name, int mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a private file associated with this Context's application package
  /// for writing. Creates the file if it doesn't already exist.
  ///
  /// No additional permissions are required for the calling app to read or
  /// write the returned file.
  ///@param name The name of the file to open; can not contain path
  ///            separators.
  ///@param mode Operating mode.
  /// Value is either <code>0</code> or a combination of android.content.Context\#MODE_PRIVATE, android.content.Context\#MODE_WORLD_READABLE, android.content.Context\#MODE_WORLD_WRITEABLE, and android.content.Context\#MODE_APPEND
  ///@return The resulting FileOutputStream.
  ///@see \#MODE_APPEND
  ///@see \#MODE_PRIVATE
  ///@see \#openFileInput
  ///@see \#fileList
  ///@see \#deleteFile
  ///@see java.io.FileOutputStream\#FileOutputStream(String)
  jni.JniObject openFileOutput(jni.JniString name, int mode) {
    final result__ =
        jni.JniObject.fromRef(_openFileOutput(reference, name.reference, mode));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _deleteFile = jniLookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Context_deleteFile")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean deleteFile(java.lang.String name)
  ///
  /// Delete the given private file associated with this Context's
  /// application package.
  ///@param name The name of the file to delete; can not contain path
  ///             separators.
  ///@return {@code true} if the file was successfully deleted; else
  ///         {@code false}.
  ///@see \#openFileInput
  ///@see \#openFileOutput
  ///@see \#fileList
  ///@see java.io.File\#delete()
  bool deleteFile(jni.JniString name) {
    final result__ = _deleteFile(reference, name.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getFileStreamPath = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getFileStreamPath")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.File getFileStreamPath(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the absolute path on the filesystem where a file created with
  /// \#openFileOutput is stored.
  ///
  /// The returned path may change over time if the calling app is moved to an
  /// adopted storage device, so only relative paths should be persisted.
  ///@param name The name of the file for which you would like to get
  ///          its path.
  ///@return An absolute path to the given file.
  ///@see \#openFileOutput
  ///@see \#getFilesDir
  ///@see \#getDir
  jni.JniObject getFileStreamPath(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_getFileStreamPath(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDataDir = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Context_getDataDir")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.File getDataDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the absolute path to the directory on the filesystem where all
  /// private files belonging to this app are stored. Apps should not use this
  /// path directly; they should instead use \#getFilesDir(),
  /// \#getCacheDir(), \#getDir(String, int), or other storage
  /// APIs on this class.
  ///
  /// The returned path may change over time if the calling app is moved to an
  /// adopted storage device, so only relative paths should be persisted.
  ///
  /// No additional permissions are required for the calling app to read or
  /// write files under the returned path.
  ///@see ApplicationInfo\#dataDir
  jni.JniObject getDataDir() {
    final result__ = jni.JniObject.fromRef(_getDataDir(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getFilesDir = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getFilesDir")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.File getFilesDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the absolute path to the directory on the filesystem where files
  /// created with \#openFileOutput are stored.
  ///
  /// The returned path may change over time if the calling app is moved to an
  /// adopted storage device, so only relative paths should be persisted.
  ///
  /// No additional permissions are required for the calling app to read or
  /// write files under the returned path.
  ///@return The path of the directory holding application files.
  ///@see \#openFileOutput
  ///@see \#getFileStreamPath
  ///@see \#getDir
  jni.JniObject getFilesDir() {
    final result__ = jni.JniObject.fromRef(_getFilesDir(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getNoBackupFilesDir = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getNoBackupFilesDir")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.File getNoBackupFilesDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the absolute path to the directory on the filesystem similar to
  /// \#getFilesDir(). The difference is that files placed under this
  /// directory will be excluded from automatic backup to remote storage. See
  /// android.app.backup.BackupAgent BackupAgent for a full discussion
  /// of the automatic backup mechanism in Android.
  ///
  /// The returned path may change over time if the calling app is moved to an
  /// adopted storage device, so only relative paths should be persisted.
  ///
  /// No additional permissions are required for the calling app to read or
  /// write files under the returned path.
  ///@return The path of the directory holding application files that will not
  ///         be automatically backed up to remote storage.
  ///@see \#openFileOutput
  ///@see \#getFileStreamPath
  ///@see \#getDir
  ///@see android.app.backup.BackupAgent
  jni.JniObject getNoBackupFilesDir() {
    final result__ = jni.JniObject.fromRef(_getNoBackupFilesDir(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getExternalFilesDir = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getExternalFilesDir")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.File getExternalFilesDir(java.lang.String type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the absolute path to the directory on the primary shared/external
  /// storage device where the application can place persistent files it owns.
  /// These files are internal to the applications, and not typically visible
  /// to the user as media.
  ///
  /// This is like \#getFilesDir() in that these files will be deleted
  /// when the application is uninstalled, however there are some important
  /// differences:
  /// <ul>
  /// <li>Shared storage may not always be available, since removable media can
  /// be ejected by the user. Media state can be checked using
  /// Environment\#getExternalStorageState(File).
  /// <li>There is no security enforced with these files. For example, any
  /// application holding
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE can write to
  /// these files.
  /// </ul>
  ///
  /// If a shared storage device is emulated (as determined by
  /// Environment\#isExternalStorageEmulated(File)), it's contents are
  /// backed by a private user data partition, which means there is little
  /// benefit to storing data here instead of the private directories returned
  /// by \#getFilesDir(), etc.
  ///
  /// Starting in android.os.Build.VERSION_CODES\#KITKAT, no permissions
  /// are required to read or write to the returned path; it's always
  /// accessible to the calling app. This only applies to paths generated for
  /// package name of the calling application. To access paths belonging to
  /// other packages,
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE and/or
  /// android.Manifest.permission\#READ_EXTERNAL_STORAGE are required.
  ///
  /// On devices with multiple users (as described by UserManager),
  /// each user has their own isolated shared storage. Applications only have
  /// access to the shared storage for the user they're running as.
  ///
  /// The returned path may change over time if different shared storage media
  /// is inserted, so only relative paths should be persisted.
  ///
  /// Here is an example of typical code to manipulate a file in an
  /// application's shared storage:
  ///
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
  /// private_file}
  ///
  /// If you supply a non-null <var>type</var> to this function, the returned
  /// file will be a path to a sub-directory of the given type. Though these
  /// files are not automatically scanned by the media scanner, you can
  /// explicitly add them to the media database with
  /// android.media.MediaScannerConnection\#scanFile(Context, String[], String[], android.media.MediaScannerConnection.OnScanCompletedListener) MediaScannerConnection.scanFile. Note that this is not the same as
  /// android.os.Environment\#getExternalStoragePublicDirectory Environment.getExternalStoragePublicDirectory(), which provides
  /// directories of media shared by all applications. The directories returned
  /// here are owned by the application, and their contents will be removed
  /// when the application is uninstalled. Unlike
  /// android.os.Environment\#getExternalStoragePublicDirectory Environment.getExternalStoragePublicDirectory(), the directory returned
  /// here will be automatically created for you.
  ///
  /// Here is an example of typical code to manipulate a picture in an
  /// application's shared storage and add it to the media database:
  ///
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
  /// private_picture}
  ///@param type The type of files directory to return. May be {@code null}
  ///            for the root of the files directory or one of the following
  ///            constants for a subdirectory:
  ///            android.os.Environment\#DIRECTORY_MUSIC,
  ///            android.os.Environment\#DIRECTORY_PODCASTS,
  ///            android.os.Environment\#DIRECTORY_RINGTONES,
  ///            android.os.Environment\#DIRECTORY_ALARMS,
  ///            android.os.Environment\#DIRECTORY_NOTIFICATIONS,
  ///            android.os.Environment\#DIRECTORY_PICTURES, or
  ///            android.os.Environment\#DIRECTORY_MOVIES.
  /// This value may be {@code null}.
  ///@return the absolute path to application-specific directory. May return
  ///         {@code null} if shared storage is not currently available.
  ///@see \#getFilesDir
  ///@see \#getExternalFilesDirs(String)
  ///@see Environment\#getExternalStorageState(File)
  ///@see Environment\#isExternalStorageEmulated(File)
  ///@see Environment\#isExternalStorageRemovable(File)
  jni.JniObject getExternalFilesDir(jni.JniString type) {
    final result__ =
        jni.JniObject.fromRef(_getExternalFilesDir(reference, type.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getExternalFilesDirs = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getExternalFilesDirs")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.File[] getExternalFilesDirs(java.lang.String type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns absolute paths to application-specific directories on all
  /// shared/external storage devices where the application can place
  /// persistent files it owns. These files are internal to the application,
  /// and not typically visible to the user as media.
  ///
  /// This is like \#getFilesDir() in that these files will be deleted
  /// when the application is uninstalled, however there are some important
  /// differences:
  /// <ul>
  /// <li>Shared storage may not always be available, since removable media can
  /// be ejected by the user. Media state can be checked using
  /// Environment\#getExternalStorageState(File).
  /// <li>There is no security enforced with these files. For example, any
  /// application holding
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE can write to
  /// these files.
  /// </ul>
  ///
  /// If a shared storage device is emulated (as determined by
  /// Environment\#isExternalStorageEmulated(File)), it's contents are
  /// backed by a private user data partition, which means there is little
  /// benefit to storing data here instead of the private directories returned
  /// by \#getFilesDir(), etc.
  ///
  /// Shared storage devices returned here are considered a stable part of the
  /// device, including physical media slots under a protective cover. The
  /// returned paths do not include transient devices, such as USB flash drives
  /// connected to handheld devices.
  ///
  /// An application may store data on any or all of the returned devices. For
  /// example, an app may choose to store large files on the device with the
  /// most available space, as measured by StatFs.
  ///
  /// No additional permissions are required for the calling app to read or
  /// write files under the returned path. Write access outside of these paths
  /// on secondary external storage devices is not available.
  ///
  /// The returned path may change over time if different shared storage media
  /// is inserted, so only relative paths should be persisted.
  ///@param type The type of files directory to return. May be {@code null}
  ///            for the root of the files directory or one of the following
  ///            constants for a subdirectory:
  ///            android.os.Environment\#DIRECTORY_MUSIC,
  ///            android.os.Environment\#DIRECTORY_PODCASTS,
  ///            android.os.Environment\#DIRECTORY_RINGTONES,
  ///            android.os.Environment\#DIRECTORY_ALARMS,
  ///            android.os.Environment\#DIRECTORY_NOTIFICATIONS,
  ///            android.os.Environment\#DIRECTORY_PICTURES, or
  ///            android.os.Environment\#DIRECTORY_MOVIES.
  ///@return the absolute paths to application-specific directories. Some
  ///         individual paths may be {@code null} if that shared storage is
  ///         not currently available. The first path returned is the same as
  ///         \#getExternalFilesDir(String).
  ///@see \#getExternalFilesDir(String)
  ///@see Environment\#getExternalStorageState(File)
  ///@see Environment\#isExternalStorageEmulated(File)
  ///@see Environment\#isExternalStorageRemovable(File)
  jni.JniObject getExternalFilesDirs(jni.JniString type) {
    final result__ =
        jni.JniObject.fromRef(_getExternalFilesDirs(reference, type.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getObbDir = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Context_getObbDir")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.File getObbDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the primary shared/external storage directory where this
  /// application's OBB files (if there are any) can be found. Note if the
  /// application does not have any OBB files, this directory may not exist.
  ///
  /// This is like \#getFilesDir() in that these files will be deleted
  /// when the application is uninstalled, however there are some important
  /// differences:
  /// <ul>
  /// <li>Shared storage may not always be available, since removable media can
  /// be ejected by the user. Media state can be checked using
  /// Environment\#getExternalStorageState(File).
  /// <li>There is no security enforced with these files. For example, any
  /// application holding
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE can write to
  /// these files.
  /// </ul>
  ///
  /// Starting in android.os.Build.VERSION_CODES\#KITKAT, no permissions
  /// are required to read or write to the path that this method returns.
  /// However, starting from android.os.Build.VERSION_CODES\#M,
  /// to read the OBB expansion files, you must declare the
  /// android.Manifest.permission\#READ_EXTERNAL_STORAGE permission in the app manifest and ask for
  /// permission at runtime as follows:
  ///
  ///
  ///
  /// {@code <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"
  /// android:maxSdkVersion="23" />}
  ///
  ///
  ///
  /// Starting from android.os.Build.VERSION_CODES\#N,
  /// android.Manifest.permission\#READ_EXTERNAL_STORAGE
  /// permission is not required, so don\u2019t ask for this
  /// permission at runtime. To handle both cases, your app must first try to read the OBB file,
  /// and if it fails, you must request
  /// android.Manifest.permission\#READ_EXTERNAL_STORAGE permission at runtime.
  ///
  ///
  ///
  ///
  /// The following code snippet shows how to do this:
  ///
  ///
  ///
  /// <pre>
  /// File obb = new File(obb_filename);
  /// boolean open_failed = false;
  ///
  /// try {
  ///     BufferedReader br = new BufferedReader(new FileReader(obb));
  ///     open_failed = false;
  ///     ReadObbFile(br);
  /// } catch (IOException e) {
  ///     open_failed = true;
  /// }
  ///
  /// if (open_failed) {
  ///     // request READ_EXTERNAL_STORAGE permission before reading OBB file
  ///     ReadObbFileWithPermission();
  /// }
  /// </pre>
  ///
  /// On devices with multiple users (as described by UserManager),
  /// multiple users may share the same OBB storage location. Applications
  /// should ensure that multiple instances running under different users don't
  /// interfere with each other.
  ///@return the absolute path to application-specific directory. May return
  ///         {@code null} if shared storage is not currently available.
  ///@see \#getObbDirs()
  ///@see Environment\#getExternalStorageState(File)
  ///@see Environment\#isExternalStorageEmulated(File)
  ///@see Environment\#isExternalStorageRemovable(File)
  jni.JniObject getObbDir() {
    final result__ = jni.JniObject.fromRef(_getObbDir(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getObbDirs = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Context_getObbDirs")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.File[] getObbDirs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns absolute paths to application-specific directories on all
  /// shared/external storage devices where the application's OBB files (if
  /// there are any) can be found. Note if the application does not have any
  /// OBB files, these directories may not exist.
  ///
  /// This is like \#getFilesDir() in that these files will be deleted
  /// when the application is uninstalled, however there are some important
  /// differences:
  /// <ul>
  /// <li>Shared storage may not always be available, since removable media can
  /// be ejected by the user. Media state can be checked using
  /// Environment\#getExternalStorageState(File).
  /// <li>There is no security enforced with these files. For example, any
  /// application holding
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE can write to
  /// these files.
  /// </ul>
  ///
  /// Shared storage devices returned here are considered a stable part of the
  /// device, including physical media slots under a protective cover. The
  /// returned paths do not include transient devices, such as USB flash drives
  /// connected to handheld devices.
  ///
  /// An application may store data on any or all of the returned devices. For
  /// example, an app may choose to store large files on the device with the
  /// most available space, as measured by StatFs.
  ///
  /// No additional permissions are required for the calling app to read or
  /// write files under the returned path. Write access outside of these paths
  /// on secondary external storage devices is not available.
  ///@return the absolute paths to application-specific directories. Some
  ///         individual paths may be {@code null} if that shared storage is
  ///         not currently available. The first path returned is the same as
  ///         \#getObbDir()
  ///@see \#getObbDir()
  ///@see Environment\#getExternalStorageState(File)
  ///@see Environment\#isExternalStorageEmulated(File)
  ///@see Environment\#isExternalStorageRemovable(File)
  jni.JniObject getObbDirs() {
    final result__ = jni.JniObject.fromRef(_getObbDirs(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getCacheDir = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getCacheDir")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.File getCacheDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the absolute path to the application specific cache directory on
  /// the filesystem.
  ///
  /// The system will automatically delete files in this directory as disk
  /// space is needed elsewhere on the device. The system will always delete
  /// older files first, as reported by File\#lastModified(). If
  /// desired, you can exert more control over how files are deleted using
  /// StorageManager\#setCacheBehaviorGroup(File, boolean) and
  /// StorageManager\#setCacheBehaviorTombstone(File, boolean).
  ///
  /// Apps are strongly encouraged to keep their usage of cache space below the
  /// quota returned by
  /// StorageManager\#getCacheQuotaBytes(java.util.UUID). If your app
  /// goes above this quota, your cached files will be some of the first to be
  /// deleted when additional disk space is needed. Conversely, if your app
  /// stays under this quota, your cached files will be some of the last to be
  /// deleted when additional disk space is needed.
  ///
  /// Note that your cache quota will change over time depending on how
  /// frequently the user interacts with your app, and depending on how much
  /// system-wide disk space is used.
  ///
  /// The returned path may change over time if the calling app is moved to an
  /// adopted storage device, so only relative paths should be persisted.
  ///
  /// Apps require no extra permissions to read or write to the returned path,
  /// since this path lives in their private storage.
  ///@return The path of the directory holding application cache files.
  ///@see \#openFileOutput
  ///@see \#getFileStreamPath
  ///@see \#getDir
  ///@see \#getExternalCacheDir
  jni.JniObject getCacheDir() {
    final result__ = jni.JniObject.fromRef(_getCacheDir(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getCodeCacheDir = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getCodeCacheDir")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.File getCodeCacheDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the absolute path to the application specific cache directory on
  /// the filesystem designed for storing cached code.
  ///
  /// The system will delete any files stored in this location both when your
  /// specific application is upgraded, and when the entire platform is
  /// upgraded.
  ///
  /// This location is optimal for storing compiled or optimized code generated
  /// by your application at runtime.
  ///
  /// The returned path may change over time if the calling app is moved to an
  /// adopted storage device, so only relative paths should be persisted.
  ///
  /// Apps require no extra permissions to read or write to the returned path,
  /// since this path lives in their private storage.
  ///@return The path of the directory holding application code cache files.
  jni.JniObject getCodeCacheDir() {
    final result__ = jni.JniObject.fromRef(_getCodeCacheDir(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getExternalCacheDir = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getExternalCacheDir")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.File getExternalCacheDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns absolute path to application-specific directory on the primary
  /// shared/external storage device where the application can place cache
  /// files it owns. These files are internal to the application, and not
  /// typically visible to the user as media.
  ///
  /// This is like \#getCacheDir() in that these files will be deleted
  /// when the application is uninstalled, however there are some important
  /// differences:
  /// <ul>
  /// <li>The platform does not always monitor the space available in shared
  /// storage, and thus may not automatically delete these files. Apps should
  /// always manage the maximum space used in this location. Currently the only
  /// time files here will be deleted by the platform is when running on
  /// android.os.Build.VERSION_CODES\#JELLY_BEAN_MR1 or later and
  /// Environment\#isExternalStorageEmulated(File) returns true.
  /// <li>Shared storage may not always be available, since removable media can
  /// be ejected by the user. Media state can be checked using
  /// Environment\#getExternalStorageState(File).
  /// <li>There is no security enforced with these files. For example, any
  /// application holding
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE can write to
  /// these files.
  /// </ul>
  ///
  /// If a shared storage device is emulated (as determined by
  /// Environment\#isExternalStorageEmulated(File)), its contents are
  /// backed by a private user data partition, which means there is little
  /// benefit to storing data here instead of the private directory returned by
  /// \#getCacheDir().
  ///
  /// Starting in android.os.Build.VERSION_CODES\#KITKAT, no permissions
  /// are required to read or write to the returned path; it's always
  /// accessible to the calling app. This only applies to paths generated for
  /// package name of the calling application. To access paths belonging to
  /// other packages,
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE and/or
  /// android.Manifest.permission\#READ_EXTERNAL_STORAGE are required.
  ///
  /// On devices with multiple users (as described by UserManager),
  /// each user has their own isolated shared storage. Applications only have
  /// access to the shared storage for the user they're running as.
  ///
  /// The returned path may change over time if different shared storage media
  /// is inserted, so only relative paths should be persisted.
  ///@return the absolute path to application-specific directory. May return
  ///         {@code null} if shared storage is not currently available.
  ///@see \#getCacheDir
  ///@see \#getExternalCacheDirs()
  ///@see Environment\#getExternalStorageState(File)
  ///@see Environment\#isExternalStorageEmulated(File)
  ///@see Environment\#isExternalStorageRemovable(File)
  jni.JniObject getExternalCacheDir() {
    final result__ = jni.JniObject.fromRef(_getExternalCacheDir(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getExternalCacheDirs = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getExternalCacheDirs")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.File[] getExternalCacheDirs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns absolute paths to application-specific directories on all
  /// shared/external storage devices where the application can place cache
  /// files it owns. These files are internal to the application, and not
  /// typically visible to the user as media.
  ///
  /// This is like \#getCacheDir() in that these files will be deleted
  /// when the application is uninstalled, however there are some important
  /// differences:
  /// <ul>
  /// <li>The platform does not always monitor the space available in shared
  /// storage, and thus may not automatically delete these files. Apps should
  /// always manage the maximum space used in this location. Currently the only
  /// time files here will be deleted by the platform is when running on
  /// android.os.Build.VERSION_CODES\#JELLY_BEAN_MR1 or later and
  /// Environment\#isExternalStorageEmulated(File) returns true.
  /// <li>Shared storage may not always be available, since removable media can
  /// be ejected by the user. Media state can be checked using
  /// Environment\#getExternalStorageState(File).
  /// <li>There is no security enforced with these files. For example, any
  /// application holding
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE can write to
  /// these files.
  /// </ul>
  ///
  /// If a shared storage device is emulated (as determined by
  /// Environment\#isExternalStorageEmulated(File)), it's contents are
  /// backed by a private user data partition, which means there is little
  /// benefit to storing data here instead of the private directory returned by
  /// \#getCacheDir().
  ///
  /// Shared storage devices returned here are considered a stable part of the
  /// device, including physical media slots under a protective cover. The
  /// returned paths do not include transient devices, such as USB flash drives
  /// connected to handheld devices.
  ///
  /// An application may store data on any or all of the returned devices. For
  /// example, an app may choose to store large files on the device with the
  /// most available space, as measured by StatFs.
  ///
  /// No additional permissions are required for the calling app to read or
  /// write files under the returned path. Write access outside of these paths
  /// on secondary external storage devices is not available.
  ///
  /// The returned paths may change over time if different shared storage media
  /// is inserted, so only relative paths should be persisted.
  ///@return the absolute paths to application-specific directories. Some
  ///         individual paths may be {@code null} if that shared storage is
  ///         not currently available. The first path returned is the same as
  ///         \#getExternalCacheDir().
  ///@see \#getExternalCacheDir()
  ///@see Environment\#getExternalStorageState(File)
  ///@see Environment\#isExternalStorageEmulated(File)
  ///@see Environment\#isExternalStorageRemovable(File)
  jni.JniObject getExternalCacheDirs() {
    final result__ = jni.JniObject.fromRef(_getExternalCacheDirs(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getExternalMediaDirs = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getExternalMediaDirs")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.File[] getExternalMediaDirs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns absolute paths to application-specific directories on all
  /// shared/external storage devices where the application can place media
  /// files. These files are scanned and made available to other apps through
  /// MediaStore.
  ///
  /// This is like \#getExternalFilesDirs in that these files will be
  /// deleted when the application is uninstalled, however there are some
  /// important differences:
  /// <ul>
  /// <li>Shared storage may not always be available, since removable media can
  /// be ejected by the user. Media state can be checked using
  /// Environment\#getExternalStorageState(File).
  /// <li>There is no security enforced with these files. For example, any
  /// application holding
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE can write to
  /// these files.
  /// </ul>
  ///
  /// Shared storage devices returned here are considered a stable part of the
  /// device, including physical media slots under a protective cover. The
  /// returned paths do not include transient devices, such as USB flash drives
  /// connected to handheld devices.
  ///
  /// An application may store data on any or all of the returned devices. For
  /// example, an app may choose to store large files on the device with the
  /// most available space, as measured by StatFs.
  ///
  /// No additional permissions are required for the calling app to read or
  /// write files under the returned path. Write access outside of these paths
  /// on secondary external storage devices is not available.
  ///
  /// The returned paths may change over time if different shared storage media
  /// is inserted, so only relative paths should be persisted.
  ///@return the absolute paths to application-specific directories. Some
  ///         individual paths may be {@code null} if that shared storage is
  ///         not currently available.
  ///@see Environment\#getExternalStorageState(File)
  ///@see Environment\#isExternalStorageEmulated(File)
  ///@see Environment\#isExternalStorageRemovable(File)
  jni.JniObject getExternalMediaDirs() {
    final result__ = jni.JniObject.fromRef(_getExternalMediaDirs(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _fileList = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Context_fileList")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String[] fileList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an array of strings naming the private files associated with
  /// this Context's application package.
  ///@return Array of strings naming the private files.
  ///@see \#openFileInput
  ///@see \#openFileOutput
  ///@see \#deleteFile
  jni.JniObject fileList() {
    final result__ = jni.JniObject.fromRef(_fileList(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDir = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Context_getDir")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.io.File getDir(java.lang.String name, int mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve, creating if needed, a new directory in which the application
  /// can place its own custom data files.  You can use the returned File
  /// object to create and access files in this directory.  Note that files
  /// created through a File object will only be accessible by your own
  /// application; you can only set the mode of the entire directory, not
  /// of individual files.
  ///
  /// The returned path may change over time if the calling app is moved to an
  /// adopted storage device, so only relative paths should be persisted.
  ///
  /// Apps require no extra permissions to read or write to the returned path,
  /// since this path lives in their private storage.
  ///@param name Name of the directory to retrieve.  This is a directory
  /// that is created as part of your application data.
  ///@param mode Operating mode.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Context\#MODE_PRIVATE, android.content.Context\#MODE_WORLD_READABLE, android.content.Context\#MODE_WORLD_WRITEABLE, and android.content.Context\#MODE_APPEND
  ///@return A File object for the requested directory.  The directory
  /// will have been created if it does not already exist.
  ///@see \#openFileOutput(String, int)
  jni.JniObject getDir(jni.JniString name, int mode) {
    final result__ =
        jni.JniObject.fromRef(_getDir(reference, name.reference, mode));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openOrCreateDatabase = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_openOrCreateDatabase")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.database.sqlite.SQLiteDatabase openOrCreateDatabase(java.lang.String name, int mode, android.database.sqlite.SQLiteDatabase.CursorFactory factory)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a new private SQLiteDatabase associated with this Context's
  /// application package. Create the database file if it doesn't exist.
  ///@param name The name (unique in the application package) of the database.
  ///@param mode Operating mode.
  /// Value is either <code>0</code> or a combination of android.content.Context\#MODE_PRIVATE, android.content.Context\#MODE_WORLD_READABLE, android.content.Context\#MODE_WORLD_WRITEABLE, android.content.Context\#MODE_ENABLE_WRITE_AHEAD_LOGGING, and android.content.Context\#MODE_NO_LOCALIZED_COLLATORS
  ///@param factory An optional factory class that is called to instantiate a
  ///            cursor when query is called.
  ///@return The contents of a newly created database with the given name.
  ///@throws android.database.sqlite.SQLiteException if the database file
  ///             could not be opened.
  ///@see \#MODE_PRIVATE
  ///@see \#MODE_ENABLE_WRITE_AHEAD_LOGGING
  ///@see \#MODE_NO_LOCALIZED_COLLATORS
  ///@see \#deleteDatabase
  jni.JniObject openOrCreateDatabase(
      jni.JniString name, int mode, jni.JniObject factory0) {
    final result__ = jni.JniObject.fromRef(_openOrCreateDatabase(
        reference, name.reference, mode, factory0.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openOrCreateDatabase1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_openOrCreateDatabase1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.database.sqlite.SQLiteDatabase openOrCreateDatabase(java.lang.String name, int mode, android.database.sqlite.SQLiteDatabase.CursorFactory factory, android.database.DatabaseErrorHandler errorHandler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a new private SQLiteDatabase associated with this Context's
  /// application package. Creates the database file if it doesn't exist.
  ///
  /// Accepts input param: a concrete instance of DatabaseErrorHandler
  /// to be used to handle corruption when sqlite reports database corruption.
  ///
  ///
  ///@param name The name (unique in the application package) of the database.
  ///@param mode Operating mode.
  /// Value is either <code>0</code> or a combination of android.content.Context\#MODE_PRIVATE, android.content.Context\#MODE_WORLD_READABLE, android.content.Context\#MODE_WORLD_WRITEABLE, android.content.Context\#MODE_ENABLE_WRITE_AHEAD_LOGGING, and android.content.Context\#MODE_NO_LOCALIZED_COLLATORS
  ///@param factory An optional factory class that is called to instantiate a
  ///            cursor when query is called.
  ///@param errorHandler the DatabaseErrorHandler to be used when
  ///            sqlite reports database corruption. if null,
  ///            android.database.DefaultDatabaseErrorHandler is
  ///            assumed.
  /// This value may be {@code null}.
  ///@return The contents of a newly created database with the given name.
  ///@throws android.database.sqlite.SQLiteException if the database file
  ///             could not be opened.
  ///@see \#MODE_PRIVATE
  ///@see \#MODE_ENABLE_WRITE_AHEAD_LOGGING
  ///@see \#MODE_NO_LOCALIZED_COLLATORS
  ///@see \#deleteDatabase
  jni.JniObject openOrCreateDatabase1(jni.JniString name, int mode,
      jni.JniObject factory0, jni.JniObject errorHandler) {
    final result__ = jni.JniObject.fromRef(_openOrCreateDatabase1(reference,
        name.reference, mode, factory0.reference, errorHandler.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _moveDatabaseFrom = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_moveDatabaseFrom")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean moveDatabaseFrom(android.content.Context sourceContext, java.lang.String name)
  ///
  /// Move an existing database file from the given source storage context to
  /// this context. This is typically used to migrate data between storage
  /// locations after an upgrade, such as migrating to device protected
  /// storage.
  ///
  /// The database must be closed before being moved.
  ///@param sourceContext The source context which contains the existing
  ///            database to move.
  ///@param name The name of the database file.
  ///@return {@code true} if the move was successful or if the database didn't
  ///         exist in the source context, otherwise {@code false}.
  ///@see \#createDeviceProtectedStorageContext()
  bool moveDatabaseFrom(Context sourceContext, jni.JniString name) {
    final result__ =
        _moveDatabaseFrom(reference, sourceContext.reference, name.reference) !=
            0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _deleteDatabase = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_deleteDatabase")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean deleteDatabase(java.lang.String name)
  ///
  /// Delete an existing private SQLiteDatabase associated with this Context's
  /// application package.
  ///@param name The name (unique in the application package) of the
  ///             database.
  ///@return {@code true} if the database was successfully deleted; else {@code false}.
  ///@see \#openOrCreateDatabase
  bool deleteDatabase(jni.JniString name) {
    final result__ = _deleteDatabase(reference, name.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDatabasePath = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getDatabasePath")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.io.File getDatabasePath(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the absolute path on the filesystem where a database created with
  /// \#openOrCreateDatabase is stored.
  ///
  /// The returned path may change over time if the calling app is moved to an
  /// adopted storage device, so only relative paths should be persisted.
  ///@param name The name of the database for which you would like to get
  ///          its path.
  ///@return An absolute path to the given database.
  ///@see \#openOrCreateDatabase
  jni.JniObject getDatabasePath(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_getDatabasePath(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _databaseList = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_databaseList")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String[] databaseList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an array of strings naming the private databases associated with
  /// this Context's application package.
  ///@return Array of strings naming the private databases.
  ///@see \#openOrCreateDatabase
  ///@see \#deleteDatabase
  jni.JniObject databaseList() {
    final result__ = jni.JniObject.fromRef(_databaseList(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getWallpaper = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getWallpaper")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable getWallpaper()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Use android.app.WallpaperManager\#getDrawable WallpaperManager.get() instead.
  jni.JniObject getWallpaper() {
    final result__ = jni.JniObject.fromRef(_getWallpaper(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _peekWallpaper = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_peekWallpaper")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable peekWallpaper()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Use android.app.WallpaperManager\#peekDrawable WallpaperManager.peek() instead.
  jni.JniObject peekWallpaper() {
    final result__ = jni.JniObject.fromRef(_peekWallpaper(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getWallpaperDesiredMinimumWidth =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Context_getWallpaperDesiredMinimumWidth")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getWallpaperDesiredMinimumWidth()
  ///
  /// @deprecated Use android.app.WallpaperManager\#getDesiredMinimumWidth() WallpaperManager.getDesiredMinimumWidth() instead.
  int getWallpaperDesiredMinimumWidth() {
    final result__ = _getWallpaperDesiredMinimumWidth(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getWallpaperDesiredMinimumHeight =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Context_getWallpaperDesiredMinimumHeight")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getWallpaperDesiredMinimumHeight()
  ///
  /// @deprecated Use android.app.WallpaperManager\#getDesiredMinimumHeight() WallpaperManager.getDesiredMinimumHeight() instead.
  int getWallpaperDesiredMinimumHeight() {
    final result__ = _getWallpaperDesiredMinimumHeight(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setWallpaper = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_setWallpaper")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setWallpaper(android.graphics.Bitmap bitmap)
  ///
  /// @deprecated Use android.app.WallpaperManager\#setBitmap(Bitmap) WallpaperManager.set() instead.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  void setWallpaper(jni.JniObject bitmap) {
    final result__ = _setWallpaper(reference, bitmap.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setWallpaper1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_setWallpaper1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setWallpaper(java.io.InputStream data)
  ///
  /// @deprecated Use android.app.WallpaperManager\#setStream(InputStream) WallpaperManager.set() instead.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  void setWallpaper1(jni.JniObject data) {
    final result__ = _setWallpaper1(reference, data.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _clearWallpaper =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Context_clearWallpaper")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void clearWallpaper()
  ///
  /// @deprecated Use android.app.WallpaperManager\#clear WallpaperManager.clear() instead.
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  void clearWallpaper() {
    final result__ = _clearWallpaper(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startActivity = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_startActivity")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void startActivity(android.content.Intent intent)
  ///
  /// Same as \#startActivity(Intent, Bundle) with no options
  /// specified.
  ///@param intent The description of the activity to start.
  ///@throws ActivityNotFoundException &nbsp;
  ///`
  ///@see \#startActivity(Intent, Bundle)
  ///@see PackageManager\#resolveActivity
  void startActivity(Intent intent) {
    final result__ = _startActivity(reference, intent.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startActivity1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_startActivity1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void startActivity(android.content.Intent intent, android.os.Bundle options)
  ///
  /// Launch a new activity.  You will not receive any information about when
  /// the activity exits.
  ///
  /// Note that if this method is being called from outside of an
  /// android.app.Activity Context, then the Intent must include
  /// the Intent\#FLAG_ACTIVITY_NEW_TASK launch flag.  This is because,
  /// without being started from an existing Activity, there is no existing
  /// task in which to place the new activity and thus it needs to be placed
  /// in its own separate task.
  ///
  /// This method throws ActivityNotFoundException
  /// if there was no Activity found to run the given Intent.
  ///@param intent The description of the activity to start.
  ///@param options Additional options for how the Activity should be started.
  /// May be null if there are no options.  See android.app.ActivityOptions
  /// for how to build the Bundle supplied here; there are no supported definitions
  /// for building it manually.
  ///
  /// This value may be {@code null}.
  ///@throws ActivityNotFoundException &nbsp;
  ///@see \#startActivity(Intent)
  ///@see PackageManager\#resolveActivity
  void startActivity1(Intent intent, os_.Bundle options) {
    final result__ =
        _startActivity1(reference, intent.reference, options.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startActivities = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_startActivities")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void startActivities(android.content.Intent[] intents)
  ///
  /// Same as \#startActivities(Intent[], Bundle) with no options
  /// specified.
  ///@param intents An array of Intents to be started.
  ///@throws ActivityNotFoundException &nbsp;
  ///@see \#startActivities(Intent[], Bundle)
  ///@see PackageManager\#resolveActivity
  void startActivities(jni.JniObject intents) {
    final result__ = _startActivities(reference, intents.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startActivities1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_startActivities1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void startActivities(android.content.Intent[] intents, android.os.Bundle options)
  ///
  /// Launch multiple new activities.  This is generally the same as calling
  /// \#startActivity(Intent) for the first Intent in the array,
  /// that activity during its creation calling \#startActivity(Intent)
  /// for the second entry, etc.  Note that unlike that approach, generally
  /// none of the activities except the last in the array will be created
  /// at this point, but rather will be created when the user first visits
  /// them (due to pressing back from the activity on top).
  ///
  /// This method throws ActivityNotFoundException
  /// if there was no Activity found for _any_ given Intent.  In this
  /// case the state of the activity stack is undefined (some Intents in the
  /// list may be on it, some not), so you probably want to avoid such situations.
  ///@param intents An array of Intents to be started.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///@throws ActivityNotFoundException &nbsp;
  ///@see \#startActivities(Intent[])
  ///@see PackageManager\#resolveActivity
  void startActivities1(jni.JniObject intents, os_.Bundle options) {
    final result__ =
        _startActivities1(reference, intents.reference, options.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startIntentSender = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("android_content_Context_startIntentSender")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public abstract void startIntentSender(android.content.IntentSender intent, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)
  ///
  /// Same as \#startIntentSender(IntentSender, Intent, int, int, int, Bundle)
  /// with no options specified.
  ///@param intent The IntentSender to launch.
  ///@param fillInIntent If non-null, this will be provided as the
  /// intent parameter to IntentSender\#sendIntent.
  /// This value may be {@code null}.
  ///@param flagsMask Intent flags in the original IntentSender that you
  /// would like to change.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_FROM_BACKGROUND, android.content.Intent\#FLAG_DEBUG_LOG_RESOLUTION, android.content.Intent\#FLAG_EXCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_INCLUDE_STOPPED_PACKAGES, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, android.content.Intent\#FLAG_ACTIVITY_MATCH_EXTERNAL, android.content.Intent\#FLAG_ACTIVITY_NO_HISTORY, android.content.Intent\#FLAG_ACTIVITY_SINGLE_TOP, android.content.Intent\#FLAG_ACTIVITY_NEW_TASK, android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TOP, android.content.Intent\#FLAG_ACTIVITY_FORWARD_RESULT, android.content.Intent\#FLAG_ACTIVITY_PREVIOUS_IS_TOP, android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS, android.content.Intent\#FLAG_ACTIVITY_BROUGHT_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED, android.content.Intent\#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NO_USER_ACTION, android.content.Intent\#FLAG_ACTIVITY_REORDER_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_NO_ANIMATION, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TASK, android.content.Intent\#FLAG_ACTIVITY_TASK_ON_HOME, android.content.Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS, android.content.Intent\#FLAG_ACTIVITY_LAUNCH_ADJACENT, android.content.Intent\#FLAG_RECEIVER_REGISTERED_ONLY, android.content.Intent\#FLAG_RECEIVER_REPLACE_PENDING, android.content.Intent\#FLAG_RECEIVER_FOREGROUND, android.content.Intent\#FLAG_RECEIVER_NO_ABORT, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, and android.content.Intent\#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@param flagsValues Desired values for any bits set in
  /// <var>flagsMask</var>
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_FROM_BACKGROUND, android.content.Intent\#FLAG_DEBUG_LOG_RESOLUTION, android.content.Intent\#FLAG_EXCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_INCLUDE_STOPPED_PACKAGES, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, android.content.Intent\#FLAG_ACTIVITY_MATCH_EXTERNAL, android.content.Intent\#FLAG_ACTIVITY_NO_HISTORY, android.content.Intent\#FLAG_ACTIVITY_SINGLE_TOP, android.content.Intent\#FLAG_ACTIVITY_NEW_TASK, android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TOP, android.content.Intent\#FLAG_ACTIVITY_FORWARD_RESULT, android.content.Intent\#FLAG_ACTIVITY_PREVIOUS_IS_TOP, android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS, android.content.Intent\#FLAG_ACTIVITY_BROUGHT_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED, android.content.Intent\#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NO_USER_ACTION, android.content.Intent\#FLAG_ACTIVITY_REORDER_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_NO_ANIMATION, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TASK, android.content.Intent\#FLAG_ACTIVITY_TASK_ON_HOME, android.content.Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS, android.content.Intent\#FLAG_ACTIVITY_LAUNCH_ADJACENT, android.content.Intent\#FLAG_RECEIVER_REGISTERED_ONLY, android.content.Intent\#FLAG_RECEIVER_REPLACE_PENDING, android.content.Intent\#FLAG_RECEIVER_FOREGROUND, android.content.Intent\#FLAG_RECEIVER_NO_ABORT, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, and android.content.Intent\#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@param extraFlags Always set to 0.
  ///@see \#startActivity(Intent)
  ///@see \#startIntentSender(IntentSender, Intent, int, int, int, Bundle)
  void startIntentSender(IntentSender intent, Intent fillInIntent,
      int flagsMask, int flagsValues, int extraFlags) {
    final result__ = _startIntentSender(reference, intent.reference,
        fillInIntent.reference, flagsMask, flagsValues, extraFlags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startIntentSender1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_startIntentSender1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void startIntentSender(android.content.IntentSender intent, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, android.os.Bundle options)
  ///
  /// Like \#startActivity(Intent, Bundle), but taking a IntentSender
  /// to start.  If the IntentSender is for an activity, that activity will be started
  /// as if you had called the regular \#startActivity(Intent)
  /// here; otherwise, its associated action will be executed (such as
  /// sending a broadcast) as if you had called
  /// IntentSender\#sendIntent IntentSender.sendIntent on it.
  ///@param intent The IntentSender to launch.
  ///@param fillInIntent If non-null, this will be provided as the
  /// intent parameter to IntentSender\#sendIntent.
  /// This value may be {@code null}.
  ///@param flagsMask Intent flags in the original IntentSender that you
  /// would like to change.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_FROM_BACKGROUND, android.content.Intent\#FLAG_DEBUG_LOG_RESOLUTION, android.content.Intent\#FLAG_EXCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_INCLUDE_STOPPED_PACKAGES, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, android.content.Intent\#FLAG_ACTIVITY_MATCH_EXTERNAL, android.content.Intent\#FLAG_ACTIVITY_NO_HISTORY, android.content.Intent\#FLAG_ACTIVITY_SINGLE_TOP, android.content.Intent\#FLAG_ACTIVITY_NEW_TASK, android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TOP, android.content.Intent\#FLAG_ACTIVITY_FORWARD_RESULT, android.content.Intent\#FLAG_ACTIVITY_PREVIOUS_IS_TOP, android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS, android.content.Intent\#FLAG_ACTIVITY_BROUGHT_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED, android.content.Intent\#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NO_USER_ACTION, android.content.Intent\#FLAG_ACTIVITY_REORDER_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_NO_ANIMATION, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TASK, android.content.Intent\#FLAG_ACTIVITY_TASK_ON_HOME, android.content.Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS, android.content.Intent\#FLAG_ACTIVITY_LAUNCH_ADJACENT, android.content.Intent\#FLAG_RECEIVER_REGISTERED_ONLY, android.content.Intent\#FLAG_RECEIVER_REPLACE_PENDING, android.content.Intent\#FLAG_RECEIVER_FOREGROUND, android.content.Intent\#FLAG_RECEIVER_NO_ABORT, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, and android.content.Intent\#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@param flagsValues Desired values for any bits set in
  /// <var>flagsMask</var>
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_FROM_BACKGROUND, android.content.Intent\#FLAG_DEBUG_LOG_RESOLUTION, android.content.Intent\#FLAG_EXCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_INCLUDE_STOPPED_PACKAGES, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, android.content.Intent\#FLAG_ACTIVITY_MATCH_EXTERNAL, android.content.Intent\#FLAG_ACTIVITY_NO_HISTORY, android.content.Intent\#FLAG_ACTIVITY_SINGLE_TOP, android.content.Intent\#FLAG_ACTIVITY_NEW_TASK, android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TOP, android.content.Intent\#FLAG_ACTIVITY_FORWARD_RESULT, android.content.Intent\#FLAG_ACTIVITY_PREVIOUS_IS_TOP, android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS, android.content.Intent\#FLAG_ACTIVITY_BROUGHT_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED, android.content.Intent\#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NO_USER_ACTION, android.content.Intent\#FLAG_ACTIVITY_REORDER_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_NO_ANIMATION, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TASK, android.content.Intent\#FLAG_ACTIVITY_TASK_ON_HOME, android.content.Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS, android.content.Intent\#FLAG_ACTIVITY_LAUNCH_ADJACENT, android.content.Intent\#FLAG_RECEIVER_REGISTERED_ONLY, android.content.Intent\#FLAG_RECEIVER_REPLACE_PENDING, android.content.Intent\#FLAG_RECEIVER_FOREGROUND, android.content.Intent\#FLAG_RECEIVER_NO_ABORT, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, and android.content.Intent\#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@param extraFlags Always set to 0.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.  If options
  /// have also been supplied by the IntentSender, options given here will
  /// override any that conflict with those given by the IntentSender.
  ///
  /// This value may be {@code null}.
  ///@see \#startActivity(Intent, Bundle)
  ///@see \#startIntentSender(IntentSender, Intent, int, int, int)
  void startIntentSender1(IntentSender intent, Intent fillInIntent,
      int flagsMask, int flagsValues, int extraFlags, os_.Bundle options) {
    final result__ = _startIntentSender1(
        reference,
        intent.reference,
        fillInIntent.reference,
        flagsMask,
        flagsValues,
        extraFlags,
        options.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendBroadcast = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_sendBroadcast")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendBroadcast(android.content.Intent intent)
  ///
  /// Broadcast the given intent to all interested BroadcastReceivers.  This
  /// call is asynchronous; it returns immediately, and you will continue
  /// executing while the receivers are run.  No results are propagated from
  /// receivers and receivers can not abort the broadcast. If you want
  /// to allow receivers to propagate results or abort the broadcast, you must
  /// send an ordered broadcast using
  /// \#sendOrderedBroadcast(Intent, String).
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///@param intent The Intent to broadcast; all receivers matching this
  ///               Intent will receive the broadcast.
  ///@see android.content.BroadcastReceiver
  ///@see \#registerReceiver
  ///@see \#sendBroadcast(Intent, String)
  ///@see \#sendOrderedBroadcast(Intent, String)
  ///@see \#sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
  void sendBroadcast(Intent intent) {
    final result__ = _sendBroadcast(reference, intent.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendBroadcast1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_sendBroadcast1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendBroadcast(android.content.Intent intent, java.lang.String receiverPermission)
  ///
  /// Broadcast the given intent to all interested BroadcastReceivers, allowing
  /// an optional required permission to be enforced.  This
  /// call is asynchronous; it returns immediately, and you will continue
  /// executing while the receivers are run.  No results are propagated from
  /// receivers and receivers can not abort the broadcast. If you want
  /// to allow receivers to propagate results or abort the broadcast, you must
  /// send an ordered broadcast using
  /// \#sendOrderedBroadcast(Intent, String).
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///@param intent The Intent to broadcast; all receivers matching this
  ///               Intent will receive the broadcast.
  ///@param receiverPermission (optional) String naming a permission that
  ///               a receiver must hold in order to receive your broadcast.
  ///               If null, no permission is required.
  ///
  /// This value may be {@code null}.
  ///@see android.content.BroadcastReceiver
  ///@see \#registerReceiver
  ///@see \#sendBroadcast(Intent)
  ///@see \#sendOrderedBroadcast(Intent, String)
  ///@see \#sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
  void sendBroadcast1(Intent intent, jni.JniString receiverPermission) {
    final result__ = _sendBroadcast1(
        reference, intent.reference, receiverPermission.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendOrderedBroadcast = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_sendOrderedBroadcast")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendOrderedBroadcast(android.content.Intent intent, java.lang.String receiverPermission)
  ///
  /// Broadcast the given intent to all interested BroadcastReceivers, delivering
  /// them one at a time to allow more preferred receivers to consume the
  /// broadcast before it is delivered to less preferred receivers.  This
  /// call is asynchronous; it returns immediately, and you will continue
  /// executing while the receivers are run.
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///@param intent The Intent to broadcast; all receivers matching this
  ///               Intent will receive the broadcast.
  ///@param receiverPermission (optional) String naming a permissions that
  ///               a receiver must hold in order to receive your broadcast.
  ///               If null, no permission is required.
  ///
  /// This value may be {@code null}.
  ///@see android.content.BroadcastReceiver
  ///@see \#registerReceiver
  ///@see \#sendBroadcast(Intent)
  ///@see \#sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
  void sendOrderedBroadcast(Intent intent, jni.JniString receiverPermission) {
    final result__ = _sendOrderedBroadcast(
        reference, intent.reference, receiverPermission.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendOrderedBroadcast1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_sendOrderedBroadcast1")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendOrderedBroadcast(android.content.Intent intent, java.lang.String receiverPermission, android.content.BroadcastReceiver resultReceiver, android.os.Handler scheduler, int initialCode, java.lang.String initialData, android.os.Bundle initialExtras)
  ///
  /// Version of \#sendBroadcast(Intent) that allows you to
  /// receive data back from the broadcast.  This is accomplished by
  /// supplying your own BroadcastReceiver when calling, which will be
  /// treated as a final receiver at the end of the broadcast -- its
  /// BroadcastReceiver\#onReceive method will be called with
  /// the result values collected from the other receivers.  The broadcast will
  /// be serialized in the same way as calling
  /// \#sendOrderedBroadcast(Intent, String).
  ///
  /// Like \#sendBroadcast(Intent), this method is
  /// asynchronous; it will return before
  /// resultReceiver.onReceive() is called.
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///@param intent The Intent to broadcast; all receivers matching this
  ///               Intent will receive the broadcast.
  /// This value must never be {@code null}.
  ///@param receiverPermission String naming a permissions that
  ///               a receiver must hold in order to receive your broadcast.
  ///               If null, no permission is required.
  /// This value may be {@code null}.
  ///@param resultReceiver Your own BroadcastReceiver to treat as the final
  ///                       receiver of the broadcast.
  /// This value may be {@code null}.
  ///@param scheduler A custom Handler with which to schedule the
  ///                  resultReceiver callback; if null it will be
  ///                  scheduled in the Context's main thread.
  /// This value may be {@code null}.
  ///@param initialCode An initial value for the result code.  Often
  ///                    Activity.RESULT_OK.
  ///@param initialData An initial value for the result data.  Often
  ///                    null.
  /// This value may be {@code null}.
  ///@param initialExtras An initial value for the result extras.  Often
  ///                      null.
  ///
  /// This value may be {@code null}.
  ///@see \#sendBroadcast(Intent)
  ///@see \#sendBroadcast(Intent, String)
  ///@see \#sendOrderedBroadcast(Intent, String)
  ///@see android.content.BroadcastReceiver
  ///@see \#registerReceiver
  ///@see android.app.Activity\#RESULT_OK
  void sendOrderedBroadcast1(
      Intent intent,
      jni.JniString receiverPermission,
      BroadcastReceiver resultReceiver,
      os_.Handler scheduler,
      int initialCode,
      jni.JniString initialData,
      os_.Bundle initialExtras) {
    final result__ = _sendOrderedBroadcast1(
        reference,
        intent.reference,
        receiverPermission.reference,
        resultReceiver.reference,
        scheduler.reference,
        initialCode,
        initialData.reference,
        initialExtras.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendBroadcastAsUser = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_sendBroadcastAsUser")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendBroadcastAsUser(android.content.Intent intent, android.os.UserHandle user)
  ///
  /// Version of \#sendBroadcast(Intent) that allows you to specify the
  /// user the broadcast will be sent to.  This is not available to applications
  /// that are not pre-installed on the system image.
  /// Requires android.Manifest.permission\#INTERACT_ACROSS_USERS
  ///@param intent The intent to broadcast
  ///@param user UserHandle to send the intent to.
  ///@see \#sendBroadcast(Intent)
  void sendBroadcastAsUser(Intent intent, os_.UserHandle user) {
    final result__ =
        _sendBroadcastAsUser(reference, intent.reference, user.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendBroadcastAsUser1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_sendBroadcastAsUser1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendBroadcastAsUser(android.content.Intent intent, android.os.UserHandle user, java.lang.String receiverPermission)
  ///
  /// Version of \#sendBroadcast(Intent, String) that allows you to specify the
  /// user the broadcast will be sent to.  This is not available to applications
  /// that are not pre-installed on the system image.
  ///
  /// Requires android.Manifest.permission\#INTERACT_ACROSS_USERS
  ///@param intent The Intent to broadcast; all receivers matching this
  ///               Intent will receive the broadcast.
  ///@param user UserHandle to send the intent to.
  ///@param receiverPermission (optional) String naming a permission that
  ///               a receiver must hold in order to receive your broadcast.
  ///               If null, no permission is required.
  ///
  /// This value may be {@code null}.
  ///@see \#sendBroadcast(Intent, String)
  void sendBroadcastAsUser1(
      Intent intent, os_.UserHandle user, jni.JniString receiverPermission) {
    final result__ = _sendBroadcastAsUser1(reference, intent.reference,
        user.reference, receiverPermission.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendOrderedBroadcastAsUser = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_sendOrderedBroadcastAsUser")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendOrderedBroadcastAsUser(android.content.Intent intent, android.os.UserHandle user, java.lang.String receiverPermission, android.content.BroadcastReceiver resultReceiver, android.os.Handler scheduler, int initialCode, java.lang.String initialData, android.os.Bundle initialExtras)
  ///
  /// Version of
  /// \#sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
  /// that allows you to specify the
  /// user the broadcast will be sent to.  This is not available to applications
  /// that are not pre-installed on the system image.
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///
  /// Requires android.Manifest.permission\#INTERACT_ACROSS_USERS
  ///@param intent The Intent to broadcast; all receivers matching this
  ///               Intent will receive the broadcast.
  ///@param user UserHandle to send the intent to.
  ///@param receiverPermission String naming a permissions that
  ///               a receiver must hold in order to receive your broadcast.
  ///               If null, no permission is required.
  /// This value may be {@code null}.
  ///@param resultReceiver Your own BroadcastReceiver to treat as the final
  ///                       receiver of the broadcast.
  ///@param scheduler A custom Handler with which to schedule the
  ///                  resultReceiver callback; if null it will be
  ///                  scheduled in the Context's main thread.
  /// This value may be {@code null}.
  ///@param initialCode An initial value for the result code.  Often
  ///                    Activity.RESULT_OK.
  ///@param initialData An initial value for the result data.  Often
  ///                    null.
  /// This value may be {@code null}.
  ///@param initialExtras An initial value for the result extras.  Often
  ///                      null.
  ///
  /// This value may be {@code null}.
  ///@see \#sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)
  void sendOrderedBroadcastAsUser(
      Intent intent,
      os_.UserHandle user,
      jni.JniString receiverPermission,
      BroadcastReceiver resultReceiver,
      os_.Handler scheduler,
      int initialCode,
      jni.JniString initialData,
      os_.Bundle initialExtras) {
    final result__ = _sendOrderedBroadcastAsUser(
        reference,
        intent.reference,
        user.reference,
        receiverPermission.reference,
        resultReceiver.reference,
        scheduler.reference,
        initialCode,
        initialData.reference,
        initialExtras.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendStickyBroadcast = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_sendStickyBroadcast")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendStickyBroadcast(android.content.Intent intent)
  ///
  /// Perform a \#sendBroadcast(Intent) that is "sticky," meaning the
  /// Intent you are sending stays around after the broadcast is complete,
  /// so that others can quickly retrieve that data through the return
  /// value of \#registerReceiver(BroadcastReceiver, IntentFilter).  In
  /// all other ways, this behaves the same as
  /// \#sendBroadcast(Intent).
  ///
  /// Requires android.Manifest.permission\#BROADCAST_STICKY
  ///@deprecated Sticky broadcasts should not be used.  They provide no security (anyone
  /// can access them), no protection (anyone can modify them), and many other problems.
  /// The recommended pattern is to use a non-sticky broadcast to report that _something_
  /// has changed, with another mechanism for apps to retrieve the current value whenever
  /// desired.
  ///@param intent The Intent to broadcast; all receivers matching this
  /// Intent will receive the broadcast, and the Intent will be held to
  /// be re-broadcast to future receivers.
  ///@see \#sendBroadcast(Intent)
  ///@see \#sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)
  void sendStickyBroadcast(Intent intent) {
    final result__ = _sendStickyBroadcast(reference, intent.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendStickyOrderedBroadcast = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_sendStickyOrderedBroadcast")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendStickyOrderedBroadcast(android.content.Intent intent, android.content.BroadcastReceiver resultReceiver, android.os.Handler scheduler, int initialCode, java.lang.String initialData, android.os.Bundle initialExtras)
  ///
  /// Version of \#sendStickyBroadcast that allows you to
  /// receive data back from the broadcast.  This is accomplished by
  /// supplying your own BroadcastReceiver when calling, which will be
  /// treated as a final receiver at the end of the broadcast -- its
  /// BroadcastReceiver\#onReceive method will be called with
  /// the result values collected from the other receivers.  The broadcast will
  /// be serialized in the same way as calling
  /// \#sendOrderedBroadcast(Intent, String).
  ///
  /// Like \#sendBroadcast(Intent), this method is
  /// asynchronous; it will return before
  /// resultReceiver.onReceive() is called.  Note that the sticky data
  /// stored is only the data you initially supply to the broadcast, not
  /// the result of any changes made by the receivers.
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///
  /// Requires android.Manifest.permission\#BROADCAST_STICKY
  ///@deprecated Sticky broadcasts should not be used.  They provide no security (anyone
  /// can access them), no protection (anyone can modify them), and many other problems.
  /// The recommended pattern is to use a non-sticky broadcast to report that _something_
  /// has changed, with another mechanism for apps to retrieve the current value whenever
  /// desired.
  ///@param intent The Intent to broadcast; all receivers matching this
  ///               Intent will receive the broadcast.
  ///@param resultReceiver Your own BroadcastReceiver to treat as the final
  ///                       receiver of the broadcast.
  ///@param scheduler A custom Handler with which to schedule the
  ///                  resultReceiver callback; if null it will be
  ///                  scheduled in the Context's main thread.
  /// This value may be {@code null}.
  ///@param initialCode An initial value for the result code.  Often
  ///                    Activity.RESULT_OK.
  ///@param initialData An initial value for the result data.  Often
  ///                    null.
  /// This value may be {@code null}.
  ///@param initialExtras An initial value for the result extras.  Often
  ///                      null.
  ///
  /// This value may be {@code null}.
  ///@see \#sendBroadcast(Intent)
  ///@see \#sendBroadcast(Intent, String)
  ///@see \#sendOrderedBroadcast(Intent, String)
  ///@see \#sendStickyBroadcast(Intent)
  ///@see android.content.BroadcastReceiver
  ///@see \#registerReceiver
  ///@see android.app.Activity\#RESULT_OK
  void sendStickyOrderedBroadcast(
      Intent intent,
      BroadcastReceiver resultReceiver,
      os_.Handler scheduler,
      int initialCode,
      jni.JniString initialData,
      os_.Bundle initialExtras) {
    final result__ = _sendStickyOrderedBroadcast(
        reference,
        intent.reference,
        resultReceiver.reference,
        scheduler.reference,
        initialCode,
        initialData.reference,
        initialExtras.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _removeStickyBroadcast = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_removeStickyBroadcast")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void removeStickyBroadcast(android.content.Intent intent)
  ///
  /// Remove the data previously sent with \#sendStickyBroadcast,
  /// so that it is as if the sticky broadcast had never happened.
  ///
  /// Requires android.Manifest.permission\#BROADCAST_STICKY
  ///@deprecated Sticky broadcasts should not be used.  They provide no security (anyone
  /// can access them), no protection (anyone can modify them), and many other problems.
  /// The recommended pattern is to use a non-sticky broadcast to report that _something_
  /// has changed, with another mechanism for apps to retrieve the current value whenever
  /// desired.
  ///@param intent The Intent that was previously broadcast.
  ///@see \#sendStickyBroadcast
  void removeStickyBroadcast(Intent intent) {
    final result__ = _removeStickyBroadcast(reference, intent.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendStickyBroadcastAsUser = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_sendStickyBroadcastAsUser")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendStickyBroadcastAsUser(android.content.Intent intent, android.os.UserHandle user)
  ///
  /// Version of \#sendStickyBroadcast(Intent) that allows you to specify the
  /// user the broadcast will be sent to.  This is not available to applications
  /// that are not pre-installed on the system image.
  ///
  /// Requires android.Manifest.permission\#INTERACT_ACROSS_USERS and android.Manifest.permission\#BROADCAST_STICKY
  ///@deprecated Sticky broadcasts should not be used.  They provide no security (anyone
  /// can access them), no protection (anyone can modify them), and many other problems.
  /// The recommended pattern is to use a non-sticky broadcast to report that _something_
  /// has changed, with another mechanism for apps to retrieve the current value whenever
  /// desired.
  ///@param intent The Intent to broadcast; all receivers matching this
  /// Intent will receive the broadcast, and the Intent will be held to
  /// be re-broadcast to future receivers.
  ///@param user UserHandle to send the intent to.
  ///@see \#sendBroadcast(Intent)
  void sendStickyBroadcastAsUser(Intent intent, os_.UserHandle user) {
    final result__ =
        _sendStickyBroadcastAsUser(reference, intent.reference, user.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendStickyOrderedBroadcastAsUser = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_sendStickyOrderedBroadcastAsUser")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void sendStickyOrderedBroadcastAsUser(android.content.Intent intent, android.os.UserHandle user, android.content.BroadcastReceiver resultReceiver, android.os.Handler scheduler, int initialCode, java.lang.String initialData, android.os.Bundle initialExtras)
  ///
  /// Version of
  /// \#sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)
  /// that allows you to specify the
  /// user the broadcast will be sent to.  This is not available to applications
  /// that are not pre-installed on the system image.
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///
  /// Requires android.Manifest.permission\#INTERACT_ACROSS_USERS and android.Manifest.permission\#BROADCAST_STICKY
  ///@deprecated Sticky broadcasts should not be used.  They provide no security (anyone
  /// can access them), no protection (anyone can modify them), and many other problems.
  /// The recommended pattern is to use a non-sticky broadcast to report that _something_
  /// has changed, with another mechanism for apps to retrieve the current value whenever
  /// desired.
  ///@param intent The Intent to broadcast; all receivers matching this
  ///               Intent will receive the broadcast.
  ///@param user UserHandle to send the intent to.
  ///@param resultReceiver Your own BroadcastReceiver to treat as the final
  ///                       receiver of the broadcast.
  ///@param scheduler A custom Handler with which to schedule the
  ///                  resultReceiver callback; if null it will be
  ///                  scheduled in the Context's main thread.
  /// This value may be {@code null}.
  ///@param initialCode An initial value for the result code.  Often
  ///                    Activity.RESULT_OK.
  ///@param initialData An initial value for the result data.  Often
  ///                    null.
  /// This value may be {@code null}.
  ///@param initialExtras An initial value for the result extras.  Often
  ///                      null.
  ///
  /// This value may be {@code null}.
  ///@see \#sendStickyOrderedBroadcast(Intent, BroadcastReceiver, Handler, int, String, Bundle)
  void sendStickyOrderedBroadcastAsUser(
      Intent intent,
      os_.UserHandle user,
      BroadcastReceiver resultReceiver,
      os_.Handler scheduler,
      int initialCode,
      jni.JniString initialData,
      os_.Bundle initialExtras) {
    final result__ = _sendStickyOrderedBroadcastAsUser(
        reference,
        intent.reference,
        user.reference,
        resultReceiver.reference,
        scheduler.reference,
        initialCode,
        initialData.reference,
        initialExtras.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _removeStickyBroadcastAsUser = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_removeStickyBroadcastAsUser")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void removeStickyBroadcastAsUser(android.content.Intent intent, android.os.UserHandle user)
  ///
  /// Version of \#removeStickyBroadcast(Intent) that allows you to specify the
  /// user the broadcast will be sent to.  This is not available to applications
  /// that are not pre-installed on the system image.
  ///
  /// You must hold the android.Manifest.permission\#BROADCAST_STICKY
  /// permission in order to use this API.  If you do not hold that
  /// permission, SecurityException will be thrown.
  ///
  /// Requires android.Manifest.permission\#INTERACT_ACROSS_USERS and android.Manifest.permission\#BROADCAST_STICKY
  ///@deprecated Sticky broadcasts should not be used.  They provide no security (anyone
  /// can access them), no protection (anyone can modify them), and many other problems.
  /// The recommended pattern is to use a non-sticky broadcast to report that _something_
  /// has changed, with another mechanism for apps to retrieve the current value whenever
  /// desired.
  ///@param intent The Intent that was previously broadcast.
  ///@param user UserHandle to remove the sticky broadcast from.
  ///@see \#sendStickyBroadcastAsUser
  void removeStickyBroadcastAsUser(Intent intent, os_.UserHandle user) {
    final result__ = _removeStickyBroadcastAsUser(
        reference, intent.reference, user.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _registerReceiver = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_registerReceiver")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver receiver, android.content.IntentFilter filter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Register a BroadcastReceiver to be run in the main activity thread.  The
  /// <var>receiver</var> will be called with any broadcast Intent that
  /// matches <var>filter</var>, in the main application thread.
  ///
  /// The system may broadcast Intents that are "sticky" -- these stay
  /// around after the broadcast has finished, to be sent to any later
  /// registrations. If your IntentFilter matches one of these sticky
  /// Intents, that Intent will be returned by this function
  /// <strong>and</strong> sent to your <var>receiver</var> as if it had just
  /// been broadcast.
  ///
  /// There may be multiple sticky Intents that match <var>filter</var>,
  /// in which case each of these will be sent to <var>receiver</var>.  In
  /// this case, only one of these can be returned directly by the function;
  /// which of these that is returned is arbitrarily decided by the system.
  ///
  /// If you know the Intent your are registering for is sticky, you can
  /// supply null for your <var>receiver</var>.  In this case, no receiver is
  /// registered -- the function simply returns the sticky Intent that
  /// matches <var>filter</var>.  In the case of multiple matches, the same
  /// rules as described above apply.
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///
  /// As of android.os.Build.VERSION_CODES\#ICE_CREAM_SANDWICH, receivers
  /// registered with this method will correctly respect the
  /// Intent\#setPackage(String) specified for an Intent being broadcast.
  /// Prior to that, it would be ignored and delivered to all matching registered
  /// receivers.  Be careful if using this for security.
  ///
  ///
  /// <p class="note">Note: this method _cannot be called from a
  /// BroadcastReceiver component;_ that is, from a BroadcastReceiver
  /// that is declared in an application's manifest.  It is okay, however, to call
  /// this method from another BroadcastReceiver that has itself been registered
  /// at run time with \#registerReceiver, since the lifetime of such a
  /// registered BroadcastReceiver is tied to the object that registered it.
  ///
  ///@param receiver The BroadcastReceiver to handle the broadcast.
  /// This value may be {@code null}.
  ///@param filter Selects the Intent broadcasts to be received.
  ///@return The first sticky intent found that matches <var>filter</var>,
  ///         or null if there are none.
  ///@see \#registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)
  ///@see \#sendBroadcast
  ///@see \#unregisterReceiver
  Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) {
    final result__ = Intent.fromRef(
        _registerReceiver(reference, receiver.reference, filter.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _registerReceiver1 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Context_registerReceiver1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver receiver, android.content.IntentFilter filter, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Register to receive intent broadcasts, with the receiver optionally being
  /// exposed to Instant Apps. See
  /// \#registerReceiver(BroadcastReceiver, IntentFilter) for more
  /// information. By default Instant Apps cannot interact with receivers in other
  /// applications, this allows you to expose a receiver that Instant Apps can
  /// interact with.
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///
  /// As of android.os.Build.VERSION_CODES\#ICE_CREAM_SANDWICH, receivers
  /// registered with this method will correctly respect the
  /// Intent\#setPackage(String) specified for an Intent being broadcast.
  /// Prior to that, it would be ignored and delivered to all matching registered
  /// receivers.  Be careful if using this for security.
  ///
  ///@param receiver The BroadcastReceiver to handle the broadcast.
  /// This value may be {@code null}.
  ///@param filter Selects the Intent broadcasts to be received.
  ///@param flags Additional options for the receiver. May be 0 or
  ///      \#RECEIVER_VISIBLE_TO_INSTANT_APPS.
  ///
  /// Value is either <code>0</code> or android.content.Context\#RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@return The first sticky intent found that matches <var>filter</var>,
  ///         or null if there are none.
  ///@see \#registerReceiver(BroadcastReceiver, IntentFilter)
  ///@see \#sendBroadcast
  ///@see \#unregisterReceiver
  Intent registerReceiver1(
      BroadcastReceiver receiver, IntentFilter filter, int flags) {
    final result__ = Intent.fromRef(_registerReceiver1(
        reference, receiver.reference, filter.reference, flags));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _registerReceiver2 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_registerReceiver2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver receiver, android.content.IntentFilter filter, java.lang.String broadcastPermission, android.os.Handler scheduler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Register to receive intent broadcasts, to run in the context of
  /// <var>scheduler</var>.  See
  /// \#registerReceiver(BroadcastReceiver, IntentFilter) for more
  /// information.  This allows you to enforce permissions on who can
  /// broadcast intents to your receiver, or have the receiver run in
  /// a different thread than the main application thread.
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///
  /// As of android.os.Build.VERSION_CODES\#ICE_CREAM_SANDWICH, receivers
  /// registered with this method will correctly respect the
  /// Intent\#setPackage(String) specified for an Intent being broadcast.
  /// Prior to that, it would be ignored and delivered to all matching registered
  /// receivers.  Be careful if using this for security.
  ///
  ///@param receiver The BroadcastReceiver to handle the broadcast.
  ///@param filter Selects the Intent broadcasts to be received.
  ///@param broadcastPermission String naming a permissions that a
  ///      broadcaster must hold in order to send an Intent to you.  If null,
  ///      no permission is required.
  /// This value may be {@code null}.
  ///@param scheduler Handler identifying the thread that will receive
  ///      the Intent.  If null, the main thread of the process will be used.
  ///
  /// This value may be {@code null}.
  ///@return The first sticky intent found that matches <var>filter</var>,
  ///         or null if there are none.
  ///@see \#registerReceiver(BroadcastReceiver, IntentFilter)
  ///@see \#sendBroadcast
  ///@see \#unregisterReceiver
  Intent registerReceiver2(BroadcastReceiver receiver, IntentFilter filter,
      jni.JniString broadcastPermission, os_.Handler scheduler) {
    final result__ = Intent.fromRef(_registerReceiver2(
        reference,
        receiver.reference,
        filter.reference,
        broadcastPermission.reference,
        scheduler.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _registerReceiver3 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Context_registerReceiver3")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int)>();

  /// from: public abstract android.content.Intent registerReceiver(android.content.BroadcastReceiver receiver, android.content.IntentFilter filter, java.lang.String broadcastPermission, android.os.Handler scheduler, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Register to receive intent broadcasts, to run in the context of
  /// <var>scheduler</var>. See
  /// \#registerReceiver(BroadcastReceiver, IntentFilter, int) and
  /// \#registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)
  /// for more information.
  ///
  /// See BroadcastReceiver for more information on Intent broadcasts.
  ///
  /// As of android.os.Build.VERSION_CODES\#ICE_CREAM_SANDWICH, receivers
  /// registered with this method will correctly respect the
  /// Intent\#setPackage(String) specified for an Intent being broadcast.
  /// Prior to that, it would be ignored and delivered to all matching registered
  /// receivers.  Be careful if using this for security.
  ///
  ///@param receiver The BroadcastReceiver to handle the broadcast.
  ///@param filter Selects the Intent broadcasts to be received.
  ///@param broadcastPermission String naming a permissions that a
  ///      broadcaster must hold in order to send an Intent to you.  If null,
  ///      no permission is required.
  /// This value may be {@code null}.
  ///@param scheduler Handler identifying the thread that will receive
  ///      the Intent.  If null, the main thread of the process will be used.
  /// This value may be {@code null}.
  ///@param flags Additional options for the receiver. May be 0 or
  ///      \#RECEIVER_VISIBLE_TO_INSTANT_APPS.
  ///
  /// Value is either <code>0</code> or android.content.Context\#RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@return The first sticky intent found that matches <var>filter</var>,
  ///         or null if there are none.
  ///@see \#registerReceiver(BroadcastReceiver, IntentFilter, int)
  ///@see \#registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)
  ///@see \#sendBroadcast
  ///@see \#unregisterReceiver
  Intent registerReceiver3(BroadcastReceiver receiver, IntentFilter filter,
      jni.JniString broadcastPermission, os_.Handler scheduler, int flags) {
    final result__ = Intent.fromRef(_registerReceiver3(
        reference,
        receiver.reference,
        filter.reference,
        broadcastPermission.reference,
        scheduler.reference,
        flags));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _unregisterReceiver = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_unregisterReceiver")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void unregisterReceiver(android.content.BroadcastReceiver receiver)
  ///
  /// Unregister a previously registered BroadcastReceiver.  _All_
  /// filters that have been registered for this BroadcastReceiver will be
  /// removed.
  ///@param receiver The BroadcastReceiver to unregister.
  ///@see \#registerReceiver
  void unregisterReceiver(BroadcastReceiver receiver) {
    final result__ = _unregisterReceiver(reference, receiver.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startService = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_startService")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.ComponentName startService(android.content.Intent service)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Request that a given application service be started.  The Intent
  /// should either contain the complete class name of a specific service
  /// implementation to start, or a specific package name to target.  If the
  /// Intent is less specified, it logs a warning about this.  In this case any of the
  /// multiple matching services may be used.  If this service
  /// is not already running, it will be instantiated and started (creating a
  /// process for it if needed); if it is running then it remains running.
  ///
  /// Every call to this method will result in a corresponding call to
  /// the target service's android.app.Service\#onStartCommand method,
  /// with the <var>intent</var> given here.  This provides a convenient way
  /// to submit jobs to a service without having to bind and call on to its
  /// interface.
  ///
  /// Using startService() overrides the default service lifetime that is
  /// managed by \#bindService: it requires the service to remain
  /// running until \#stopService is called, regardless of whether
  /// any clients are connected to it.  Note that calls to startService()
  /// do not nest: no matter how many times you call startService(),
  /// a single call to \#stopService will stop it.
  ///
  /// The system attempts to keep running services around as much as
  /// possible.  The only time they should be stopped is if the current
  /// foreground application is using so many resources that the service needs
  /// to be killed.  If any errors happen in the service's process, it will
  /// automatically be restarted.
  ///
  /// This function will throw SecurityException if you do not
  /// have permission to start the given service.
  ///
  /// <p class="note"><strong>Note:</strong> Each call to startService()
  /// results in significant work done by the system to manage service
  /// lifecycle surrounding the processing of the intent, which can take
  /// multiple milliseconds of CPU time. Due to this cost, startService()
  /// should not be used for frequent intent delivery to a service, and only
  /// for scheduling significant work. Use \#bindService bound services
  /// for high frequency calls.
  ///
  ///
  ///@param service Identifies the service to be started.  The Intent must be
  ///      fully explicit (supplying a component name).  Additional values
  ///      may be included in the Intent extras to supply arguments along with
  ///      this specific start call.
  ///@return If the service is being started or is already running, the
  /// ComponentName of the actual service that was started is
  /// returned; else if the service does not exist null is returned.
  ///@throws SecurityException If the caller does not have permission to access the service
  /// or the service can not be found.
  ///@throws IllegalStateException If the application is in a state where the service
  /// can not be started (such as not in the foreground in a state when services are allowed).
  ///@see \#stopService
  ///@see \#bindService
  ComponentName startService(Intent service) {
    final result__ =
        ComponentName.fromRef(_startService(reference, service.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startForegroundService = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_startForegroundService")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.ComponentName startForegroundService(android.content.Intent service)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Similar to \#startService(Intent), but with an implicit promise that the
  /// Service will call android.app.Service\#startForeground(int, android.app.Notification) startForeground(int, android.app.Notification) once it begins running.  The service is given
  /// an amount of time comparable to the ANR interval to do this, otherwise the system
  /// will automatically stop the service and declare the app ANR.
  ///
  /// Unlike the ordinary \#startService(Intent), this method can be used
  /// at any time, regardless of whether the app hosting the service is in a foreground
  /// state.
  ///@param service Identifies the service to be started.  The Intent must be
  ///      fully explicit (supplying a component name).  Additional values
  ///      may be included in the Intent extras to supply arguments along with
  ///      this specific start call.
  ///@return If the service is being started or is already running, the
  /// ComponentName of the actual service that was started is
  /// returned; else if the service does not exist null is returned.
  ///@throws SecurityException If the caller does not have permission to access the service
  /// or the service can not be found.
  ///@see \#stopService
  ///@see android.app.Service\#startForeground(int, android.app.Notification)
  ComponentName startForegroundService(Intent service) {
    final result__ = ComponentName.fromRef(
        _startForegroundService(reference, service.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _stopService = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_stopService")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean stopService(android.content.Intent service)
  ///
  /// Request that a given application service be stopped.  If the service is
  /// not running, nothing happens.  Otherwise it is stopped.  Note that calls
  /// to startService() are not counted -- this stops the service no matter
  /// how many times it was started.
  ///
  /// Note that if a stopped service still has ServiceConnection
  /// objects bound to it with the \#BIND_AUTO_CREATE set, it will
  /// not be destroyed until all of these bindings are removed.  See
  /// the android.app.Service documentation for more details on a
  /// service's lifecycle.
  ///
  /// This function will throw SecurityException if you do not
  /// have permission to stop the given service.
  ///@param service Description of the service to be stopped.  The Intent must be either
  ///      fully explicit (supplying a component name) or specify a specific package
  ///      name it is targetted to.
  ///@return If there is a service matching the given Intent that is already
  /// running, then it is stopped and {@code true} is returned; else {@code false} is returned.
  ///@throws SecurityException If the caller does not have permission to access the service
  /// or the service can not be found.
  ///@throws IllegalStateException If the application is in a state where the service
  /// can not be started (such as not in the foreground in a state when services are allowed).
  ///@see \#startService
  bool stopService(Intent service) {
    final result__ = _stopService(reference, service.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _bindService = jniLookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Context_bindService")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract boolean bindService(android.content.Intent service, android.content.ServiceConnection conn, int flags)
  ///
  /// Connect to an application service, creating it if needed.  This defines
  /// a dependency between your application and the service.  The given
  /// <var>conn</var> will receive the service object when it is created and be
  /// told if it dies and restarts.  The service will be considered required
  /// by the system only for as long as the calling context exists.  For
  /// example, if this Context is an Activity that is stopped, the service will
  /// not be required to continue running until the Activity is resumed.
  ///
  /// If the service does not support binding, it may return {@code null} from
  /// its android.app.Service\#onBind(Intent) onBind() method.  If it does, then
  /// the ServiceConnection's
  /// ServiceConnection\#onNullBinding(ComponentName) onNullBinding() method
  /// will be invoked instead of
  /// ServiceConnection\#onServiceConnected(ComponentName, IBinder) onServiceConnected().
  ///
  /// This method will throw SecurityException if the calling app does not
  /// have permission to bind to the given service.
  ///
  /// <p class="note">Note: this method _cannot be called from a
  /// BroadcastReceiver component_.  A pattern you can use to
  /// communicate from a BroadcastReceiver to a Service is to call
  /// \#startService with the arguments containing the command to be
  /// sent, with the service calling its
  /// android.app.Service\#stopSelf(int) method when done executing
  /// that command.  See the API demo App/Service/Service Start Arguments
  /// Controller for an illustration of this.  It is okay, however, to use
  /// this method from a BroadcastReceiver that has been registered with
  /// \#registerReceiver, since the lifetime of this BroadcastReceiver
  /// is tied to another object (the one that registered it).
  ///
  ///@param service Identifies the service to connect to.  The Intent must
  ///      specify an explicit component name.
  ///@param conn Receives information as the service is started and stopped.
  ///      This must be a valid ServiceConnection object; it must not be null.
  /// This value must never be {@code null}.
  ///@param flags Operation options for the binding.  May be 0,
  ///          \#BIND_AUTO_CREATE, \#BIND_DEBUG_UNBIND,
  ///          \#BIND_NOT_FOREGROUND, \#BIND_ABOVE_CLIENT,
  ///          \#BIND_ALLOW_OOM_MANAGEMENT, or
  ///          \#BIND_WAIVE_PRIORITY.
  /// Value is either <code>0</code> or a combination of android.content.Context\#BIND_AUTO_CREATE, android.content.Context\#BIND_DEBUG_UNBIND, android.content.Context\#BIND_NOT_FOREGROUND, android.content.Context\#BIND_ABOVE_CLIENT, android.content.Context\#BIND_ALLOW_OOM_MANAGEMENT, android.content.Context\#BIND_WAIVE_PRIORITY, android.content.Context\#BIND_IMPORTANT, and android.content.Context\#BIND_ADJUST_WITH_ACTIVITY
  ///@return {@code true} if the system is in the process of bringing up a
  ///         service that your client has permission to bind to; {@code false}
  ///         if the system couldn't find the service or if your client doesn't
  ///         have permission to bind to it. If this value is {@code true}, you
  ///         should later call \#unbindService to release the
  ///         connection.
  ///@throws SecurityException If the caller does not have permission to access the service
  /// or the service can not be found.
  ///@see \#unbindService
  ///@see \#startService
  ///@see \#BIND_AUTO_CREATE
  ///@see \#BIND_DEBUG_UNBIND
  ///@see \#BIND_NOT_FOREGROUND
  bool bindService(Intent service, ServiceConnection conn, int flags) {
    final result__ =
        _bindService(reference, service.reference, conn.reference, flags) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _unbindService = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_unbindService")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void unbindService(android.content.ServiceConnection conn)
  ///
  /// Disconnect from an application service.  You will no longer receive
  /// calls as the service is restarted, and the service is now allowed to
  /// stop at any time.
  ///@param conn The connection interface previously supplied to
  ///             bindService().  This parameter must not be null.
  ///
  /// This value must never be {@code null}.
  ///@see \#bindService
  void unbindService(ServiceConnection conn) {
    final result__ = _unbindService(reference, conn.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startInstrumentation = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_startInstrumentation")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean startInstrumentation(android.content.ComponentName className, java.lang.String profileFile, android.os.Bundle arguments)
  ///
  /// Start executing an android.app.Instrumentation class.  The given
  /// Instrumentation component will be run by killing its target application
  /// (if currently running), starting the target process, instantiating the
  /// instrumentation component, and then letting it drive the application.
  ///
  /// This function is not synchronous -- it returns as soon as the
  /// instrumentation has started and while it is running.
  ///
  /// Instrumentation is normally only allowed to run against a package
  /// that is either unsigned or signed with a signature that the
  /// the instrumentation package is also signed with (ensuring the target
  /// trusts the instrumentation).
  ///@param className Name of the Instrumentation component to be run.
  /// This value must never be {@code null}.
  ///@param profileFile Optional path to write profiling data as the
  /// instrumentation runs, or null for no profiling.
  /// This value may be {@code null}.
  ///@param arguments Additional optional arguments to pass to the
  /// instrumentation, or null.
  ///
  /// This value may be {@code null}.
  ///@return {@code true} if the instrumentation was successfully started,
  /// else {@code false} if it could not be found.
  bool startInstrumentation(ComponentName className, jni.JniString profileFile,
      os_.Bundle arguments) {
    final result__ = _startInstrumentation(reference, className.reference,
            profileFile.reference, arguments.reference) !=
        0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSystemService = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getSystemService")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.Object getSystemService(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the handle to a system-level service by name. The class of the
  /// returned object varies by the requested name. Currently available names
  /// are:
  ///
  /// <dl>
  ///  <dt> \#WINDOW_SERVICE ("window")
  ///  <dd> The top-level window manager in which you can place custom
  ///  windows.  The returned object is a android.view.WindowManager.
  ///  <dt> \#LAYOUT_INFLATER_SERVICE ("layout_inflater")
  ///  <dd> A android.view.LayoutInflater for inflating layout resources
  ///  in this context.
  ///  <dt> \#ACTIVITY_SERVICE ("activity")
  ///  <dd> A android.app.ActivityManager for interacting with the
  ///  global activity state of the system.
  ///  <dt> \#POWER_SERVICE ("power")
  ///  <dd> A android.os.PowerManager for controlling power
  ///  management.
  ///  <dt> \#ALARM_SERVICE ("alarm")
  ///  <dd> A android.app.AlarmManager for receiving intents at the
  ///  time of your choosing.
  ///  <dt> \#NOTIFICATION_SERVICE ("notification")
  ///  <dd> A android.app.NotificationManager for informing the user
  ///   of background events.
  ///  <dt> \#KEYGUARD_SERVICE ("keyguard")
  ///  <dd> A android.app.KeyguardManager for controlling keyguard.
  ///  <dt> \#LOCATION_SERVICE ("location")
  ///  <dd> A android.location.LocationManager for controlling location
  ///   (e.g., GPS) updates.
  ///  <dt> \#SEARCH_SERVICE ("search")
  ///  <dd> A android.app.SearchManager for handling search.
  ///  <dt> \#VIBRATOR_SERVICE ("vibrator")
  ///  <dd> A android.os.Vibrator for interacting with the vibrator
  ///  hardware.
  ///  <dt> \#CONNECTIVITY_SERVICE ("connection")
  ///  <dd> A android.net.ConnectivityManager ConnectivityManager for
  ///  handling management of network connections.
  ///  <dt> \#IPSEC_SERVICE ("ipsec")
  ///  <dd> A android.net.IpSecManager IpSecManager for managing IPSec on
  ///  sockets and networks.
  ///  <dt> \#WIFI_SERVICE ("wifi")
  ///  <dd> A android.net.wifi.WifiManager WifiManager for management of Wi-Fi
  ///  connectivity.  On releases before NYC, it should only be obtained from an application
  ///  context, and not from any other derived context to avoid memory leaks within the calling
  ///  process.
  ///  <dt> \#WIFI_AWARE_SERVICE ("wifiaware")
  ///  <dd> A android.net.wifi.aware.WifiAwareManager WifiAwareManager for management of
  /// Wi-Fi Aware discovery and connectivity.
  ///  <dt> \#WIFI_P2P_SERVICE ("wifip2p")
  ///  <dd> A android.net.wifi.p2p.WifiP2pManager WifiP2pManager for management of
  /// Wi-Fi Direct connectivity.
  /// <dt> \#INPUT_METHOD_SERVICE ("input_method")
  /// <dd> An android.view.inputmethod.InputMethodManager InputMethodManager
  /// for management of input methods.
  /// <dt> \#UI_MODE_SERVICE ("uimode")
  /// <dd> An android.app.UiModeManager for controlling UI modes.
  /// <dt> \#DOWNLOAD_SERVICE ("download")
  /// <dd> A android.app.DownloadManager for requesting HTTP downloads
  /// <dt> \#BATTERY_SERVICE ("batterymanager")
  /// <dd> A android.os.BatteryManager for managing battery state
  /// <dt> \#JOB_SCHEDULER_SERVICE ("taskmanager")
  /// <dd>  A android.app.job.JobScheduler for managing scheduled tasks
  /// <dt> \#NETWORK_STATS_SERVICE ("netstats")
  /// <dd> A android.app.usage.NetworkStatsManager NetworkStatsManager for querying network
  /// usage statistics.
  /// <dt> \#HARDWARE_PROPERTIES_SERVICE ("hardware_properties")
  /// <dd> A android.os.HardwarePropertiesManager for accessing hardware properties.
  /// </dl>
  ///
  /// Note:  System services obtained via this API may be closely associated with
  /// the Context in which they are obtained from.  In general, do not share the
  /// service objects between various different contexts (Activities, Applications,
  /// Services, Providers, etc.)
  ///
  /// Note: Instant apps, for which PackageManager\#isInstantApp() returns true,
  /// don't have access to the following system services: \#DEVICE_POLICY_SERVICE,
  /// \#FINGERPRINT_SERVICE, \#SHORTCUT_SERVICE, \#USB_SERVICE,
  /// \#WALLPAPER_SERVICE, \#WIFI_P2P_SERVICE, \#WIFI_SERVICE,
  /// \#WIFI_AWARE_SERVICE. For these services this method will return <code>null</code>.
  /// Generally, if you are running as an instant app you should always check whether the result
  /// of this method is null.
  ///@param name The name of the desired service.
  ///
  /// Value is android.content.Context\#POWER_SERVICE, android.content.Context\#WINDOW_SERVICE, android.content.Context\#LAYOUT_INFLATER_SERVICE, android.content.Context\#ACCOUNT_SERVICE, android.content.Context\#ACTIVITY_SERVICE, android.content.Context\#ALARM_SERVICE, android.content.Context\#NOTIFICATION_SERVICE, android.content.Context\#ACCESSIBILITY_SERVICE, android.content.Context\#CAPTIONING_SERVICE, android.content.Context\#KEYGUARD_SERVICE, android.content.Context\#LOCATION_SERVICE, android.content.Context\#SEARCH_SERVICE, android.content.Context\#SENSOR_SERVICE, android.content.Context\#STORAGE_SERVICE, android.content.Context\#STORAGE_STATS_SERVICE, android.content.Context\#WALLPAPER_SERVICE, android.content.Context.TIME_ZONE_RULES_MANAGER_SERVICE, android.content.Context\#VIBRATOR_SERVICE, android.content.Context\#CONNECTIVITY_SERVICE, android.content.Context\#IPSEC_SERVICE, android.content.Context\#NETWORK_STATS_SERVICE, android.content.Context\#WIFI_SERVICE, android.content.Context\#WIFI_AWARE_SERVICE, android.content.Context\#WIFI_P2P_SERVICE, android.content.Context.WIFI_SCANNING_SERVICE, android.content.Context\#WIFI_RTT_RANGING_SERVICE, android.content.Context\#NSD_SERVICE, android.content.Context\#AUDIO_SERVICE, android.content.Context\#FINGERPRINT_SERVICE, android.content.Context\#MEDIA_ROUTER_SERVICE, android.content.Context\#TELEPHONY_SERVICE, android.content.Context\#TELEPHONY_SUBSCRIPTION_SERVICE, android.content.Context\#CARRIER_CONFIG_SERVICE, android.content.Context\#TELECOM_SERVICE, android.content.Context\#CLIPBOARD_SERVICE, android.content.Context\#INPUT_METHOD_SERVICE, android.content.Context\#TEXT_SERVICES_MANAGER_SERVICE, android.content.Context\#TEXT_CLASSIFICATION_SERVICE, android.content.Context\#APPWIDGET_SERVICE, android.content.Context\#DROPBOX_SERVICE, android.content.Context\#DEVICE_POLICY_SERVICE, android.content.Context\#UI_MODE_SERVICE, android.content.Context\#DOWNLOAD_SERVICE, android.content.Context\#NFC_SERVICE, android.content.Context\#BLUETOOTH_SERVICE, android.content.Context\#USB_SERVICE, android.content.Context\#LAUNCHER_APPS_SERVICE, android.content.Context\#INPUT_SERVICE, android.content.Context\#DISPLAY_SERVICE, android.content.Context\#USER_SERVICE, android.content.Context\#RESTRICTIONS_SERVICE, android.content.Context\#APP_OPS_SERVICE, android.content.Context\#CAMERA_SERVICE, android.content.Context\#PRINT_SERVICE, android.content.Context\#CONSUMER_IR_SERVICE, android.content.Context\#TV_INPUT_SERVICE, android.content.Context\#USAGE_STATS_SERVICE, android.content.Context\#MEDIA_SESSION_SERVICE, android.content.Context\#BATTERY_SERVICE, android.content.Context\#JOB_SCHEDULER_SERVICE, android.content.Context\#MEDIA_PROJECTION_SERVICE, android.content.Context\#MIDI_SERVICE, android.content.Context.RADIO_SERVICE, android.content.Context\#HARDWARE_PROPERTIES_SERVICE, android.content.Context\#SHORTCUT_SERVICE, android.content.Context\#SYSTEM_HEALTH_SERVICE, android.content.Context\#COMPANION_DEVICE_SERVICE, or android.content.Context\#CROSS_PROFILE_APPS_SERVICE
  /// This value must never be {@code null}.
  ///@return The service or null if the name does not exist.
  ///@see \#WINDOW_SERVICE
  ///@see android.view.WindowManager
  ///@see \#LAYOUT_INFLATER_SERVICE
  ///@see android.view.LayoutInflater
  ///@see \#ACTIVITY_SERVICE
  ///@see android.app.ActivityManager
  ///@see \#POWER_SERVICE
  ///@see android.os.PowerManager
  ///@see \#ALARM_SERVICE
  ///@see android.app.AlarmManager
  ///@see \#NOTIFICATION_SERVICE
  ///@see android.app.NotificationManager
  ///@see \#KEYGUARD_SERVICE
  ///@see android.app.KeyguardManager
  ///@see \#LOCATION_SERVICE
  ///@see android.location.LocationManager
  ///@see \#SEARCH_SERVICE
  ///@see android.app.SearchManager
  ///@see \#SENSOR_SERVICE
  ///@see android.hardware.SensorManager
  ///@see \#STORAGE_SERVICE
  ///@see android.os.storage.StorageManager
  ///@see \#VIBRATOR_SERVICE
  ///@see android.os.Vibrator
  ///@see \#CONNECTIVITY_SERVICE
  ///@see android.net.ConnectivityManager
  ///@see \#WIFI_SERVICE
  ///@see android.net.wifi.WifiManager
  ///@see \#AUDIO_SERVICE
  ///@see android.media.AudioManager
  ///@see \#MEDIA_ROUTER_SERVICE
  ///@see android.media.MediaRouter
  ///@see \#TELEPHONY_SERVICE
  ///@see android.telephony.TelephonyManager
  ///@see \#TELEPHONY_SUBSCRIPTION_SERVICE
  ///@see android.telephony.SubscriptionManager
  ///@see \#CARRIER_CONFIG_SERVICE
  ///@see android.telephony.CarrierConfigManager
  ///@see \#INPUT_METHOD_SERVICE
  ///@see android.view.inputmethod.InputMethodManager
  ///@see \#UI_MODE_SERVICE
  ///@see android.app.UiModeManager
  ///@see \#DOWNLOAD_SERVICE
  ///@see android.app.DownloadManager
  ///@see \#BATTERY_SERVICE
  ///@see android.os.BatteryManager
  ///@see \#JOB_SCHEDULER_SERVICE
  ///@see android.app.job.JobScheduler
  ///@see \#NETWORK_STATS_SERVICE
  ///@see android.app.usage.NetworkStatsManager
  ///@see android.os.HardwarePropertiesManager
  ///@see \#HARDWARE_PROPERTIES_SERVICE
  jni.JniObject getSystemService(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_getSystemService(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSystemServiceName = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_getSystemServiceName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getSystemServiceName(java.lang.Class<?> serviceClass)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the name of the system-level service that is represented by the specified class.
  ///@param serviceClass The class of the desired service.
  /// This value must never be {@code null}.
  ///@return The service name or null if the class is not a supported system service.
  jni.JniString getSystemServiceName(jni.JniObject serviceClass) {
    final result__ = jni.JniString.fromRef(
        _getSystemServiceName(reference, serviceClass.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _checkPermission = jniLookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32)>>("android_content_Context_checkPermission")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract int checkPermission(java.lang.String permission, int pid, int uid)
  ///
  /// Determine whether the given permission is allowed for a particular
  /// process and user ID running in the system.
  ///@param permission The name of the permission being checked.
  /// This value must never be {@code null}.
  ///@param pid The process ID being checked against.  Must be > 0.
  ///@param uid The user ID being checked against.  A uid of 0 is the root
  /// user, which will pass every permission check.
  ///@return PackageManager\#PERMISSION_GRANTED if the given
  /// pid/uid is allowed that permission, or
  /// PackageManager\#PERMISSION_DENIED if it is not.
  ///
  /// Value is android.content.pm.PackageManager\#PERMISSION_GRANTED, or android.content.pm.PackageManager\#PERMISSION_DENIED
  ///@see PackageManager\#checkPermission(String, String)
  ///@see \#checkCallingPermission
  int checkPermission(jni.JniString permission, int pid, int uid) {
    final result__ =
        _checkPermission(reference, permission.reference, pid, uid);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _checkCallingPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_checkCallingPermission")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int checkCallingPermission(java.lang.String permission)
  ///
  /// Determine whether the calling process of an IPC you are handling has been
  /// granted a particular permission.  This is basically the same as calling
  /// \#checkPermission(String, int, int) with the pid and uid returned
  /// by android.os.Binder\#getCallingPid and
  /// android.os.Binder\#getCallingUid.  One important difference
  /// is that if you are not currently processing an IPC, this function
  /// will always fail.  This is done to protect against accidentally
  /// leaking permissions; you can use \#checkCallingOrSelfPermission
  /// to avoid this protection.
  ///@param permission The name of the permission being checked.
  ///
  /// This value must never be {@code null}.
  ///@return PackageManager\#PERMISSION_GRANTED if the calling
  /// pid/uid is allowed that permission, or
  /// PackageManager\#PERMISSION_DENIED if it is not.
  ///
  /// Value is android.content.pm.PackageManager\#PERMISSION_GRANTED, or android.content.pm.PackageManager\#PERMISSION_DENIED
  ///@see PackageManager\#checkPermission(String, String)
  ///@see \#checkPermission
  ///@see \#checkCallingOrSelfPermission
  int checkCallingPermission(jni.JniString permission) {
    final result__ = _checkCallingPermission(reference, permission.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _checkCallingOrSelfPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_checkCallingOrSelfPermission")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int checkCallingOrSelfPermission(java.lang.String permission)
  ///
  /// Determine whether the calling process of an IPC _or you_ have been
  /// granted a particular permission.  This is the same as
  /// \#checkCallingPermission, except it grants your own permissions
  /// if you are not currently processing an IPC.  Use with care!
  ///@param permission The name of the permission being checked.
  ///
  /// This value must never be {@code null}.
  ///@return PackageManager\#PERMISSION_GRANTED if the calling
  /// pid/uid is allowed that permission, or
  /// PackageManager\#PERMISSION_DENIED if it is not.
  ///
  /// Value is android.content.pm.PackageManager\#PERMISSION_GRANTED, or android.content.pm.PackageManager\#PERMISSION_DENIED
  ///@see PackageManager\#checkPermission(String, String)
  ///@see \#checkPermission
  ///@see \#checkCallingPermission
  int checkCallingOrSelfPermission(jni.JniString permission) {
    final result__ =
        _checkCallingOrSelfPermission(reference, permission.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _checkSelfPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_checkSelfPermission")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int checkSelfPermission(java.lang.String permission)
  ///
  /// Determine whether _you_ have been granted a particular permission.
  ///@param permission The name of the permission being checked.
  ///
  /// This value must never be {@code null}.
  ///@return PackageManager\#PERMISSION_GRANTED if you have the
  /// permission, or PackageManager\#PERMISSION_DENIED if not.
  ///
  /// Value is android.content.pm.PackageManager\#PERMISSION_GRANTED, or android.content.pm.PackageManager\#PERMISSION_DENIED
  ///@see PackageManager\#checkPermission(String, String)
  ///@see \#checkCallingPermission(String)
  int checkSelfPermission(jni.JniString permission) {
    final result__ = _checkSelfPermission(reference, permission.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _enforcePermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_enforcePermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void enforcePermission(java.lang.String permission, int pid, int uid, java.lang.String message)
  ///
  /// If the given permission is not allowed for a particular process
  /// and user ID running in the system, throw a SecurityException.
  ///@param permission The name of the permission being checked.
  /// This value must never be {@code null}.
  ///@param pid The process ID being checked against.  Must be &gt; 0.
  ///@param uid The user ID being checked against.  A uid of 0 is the root
  /// user, which will pass every permission check.
  ///@param message A message to include in the exception if it is thrown.
  ///
  /// This value may be {@code null}.
  ///@see \#checkPermission(String, int, int)
  void enforcePermission(
      jni.JniString permission, int pid, int uid, jni.JniString message) {
    final result__ = _enforcePermission(
        reference, permission.reference, pid, uid, message.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _enforceCallingPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_enforceCallingPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void enforceCallingPermission(java.lang.String permission, java.lang.String message)
  ///
  /// If the calling process of an IPC you are handling has not been
  /// granted a particular permission, throw a SecurityException.  This is basically the same as calling
  /// \#enforcePermission(String, int, int, String) with the
  /// pid and uid returned by android.os.Binder\#getCallingPid
  /// and android.os.Binder\#getCallingUid.  One important
  /// difference is that if you are not currently processing an IPC,
  /// this function will always throw the SecurityException.  This is
  /// done to protect against accidentally leaking permissions; you
  /// can use \#enforceCallingOrSelfPermission to avoid this
  /// protection.
  ///@param permission The name of the permission being checked.
  /// This value must never be {@code null}.
  ///@param message A message to include in the exception if it is thrown.
  ///
  /// This value may be {@code null}.
  ///@see \#checkCallingPermission(String)
  void enforceCallingPermission(
      jni.JniString permission, jni.JniString message) {
    final result__ = _enforceCallingPermission(
        reference, permission.reference, message.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _enforceCallingOrSelfPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_enforceCallingOrSelfPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void enforceCallingOrSelfPermission(java.lang.String permission, java.lang.String message)
  ///
  /// If neither you nor the calling process of an IPC you are
  /// handling has been granted a particular permission, throw a
  /// SecurityException.  This is the same as \#enforceCallingPermission, except it grants your own
  /// permissions if you are not currently processing an IPC.  Use
  /// with care!
  ///@param permission The name of the permission being checked.
  /// This value must never be {@code null}.
  ///@param message A message to include in the exception if it is thrown.
  ///
  /// This value may be {@code null}.
  ///@see \#checkCallingOrSelfPermission(String)
  void enforceCallingOrSelfPermission(
      jni.JniString permission, jni.JniString message) {
    final result__ = _enforceCallingOrSelfPermission(
        reference, permission.reference, message.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _grantUriPermission = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Context_grantUriPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void grantUriPermission(java.lang.String toPackage, android.net.Uri uri, int modeFlags)
  ///
  /// Grant permission to access a specific Uri to another package, regardless
  /// of whether that package has general permission to access the Uri's
  /// content provider.  This can be used to grant specific, temporary
  /// permissions, typically in response to user interaction (such as the
  /// user opening an attachment that you would like someone else to
  /// display).
  ///
  /// Normally you should use Intent\#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION or
  /// Intent\#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION with the Intent being used to
  /// start an activity instead of this function directly.  If you use this
  /// function directly, you should be sure to call
  /// \#revokeUriPermission when the target should no longer be allowed
  /// to access it.
  ///
  /// To succeed, the content provider owning the Uri must have set the
  /// android.R.styleable\#AndroidManifestProvider_grantUriPermissions grantUriPermissions attribute in its manifest or included the
  /// android.R.styleable\#AndroidManifestGrantUriPermission &lt;grant-uri-permissions&gt; tag.
  ///@param toPackage The package you would like to allow to access the Uri.
  ///@param uri The Uri you would like to grant access to.
  ///@param modeFlags The desired access modes.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_PERSISTABLE_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_PREFIX_URI_PERMISSION
  ///@see \#revokeUriPermission
  void grantUriPermission(
      jni.JniString toPackage, jni.JniObject uri, int modeFlags) {
    final result__ = _grantUriPermission(
        reference, toPackage.reference, uri.reference, modeFlags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _revokeUriPermission = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Context_revokeUriPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void revokeUriPermission(android.net.Uri uri, int modeFlags)
  ///
  /// Remove all permissions to access a particular content provider Uri
  /// that were previously added with \#grantUriPermission or _any other_ mechanism.
  /// The given Uri will match all previously granted Uris that are the same or a
  /// sub-path of the given Uri.  That is, revoking "content://foo/target" will
  /// revoke both "content://foo/target" and "content://foo/target/sub", but not
  /// "content://foo".  It will not remove any prefix grants that exist at a
  /// higher level.
  ///
  /// Prior to android.os.Build.VERSION_CODES\#LOLLIPOP, if you did not have
  /// regular permission access to a Uri, but had received access to it through
  /// a specific Uri permission grant, you could not revoke that grant with this
  /// function and a SecurityException would be thrown.  As of
  /// android.os.Build.VERSION_CODES\#LOLLIPOP, this function will not throw a security
  /// exception, but will remove whatever permission grants to the Uri had been given to the app
  /// (or none).
  ///
  ///
  /// Unlike \#revokeUriPermission(String, Uri, int), this method impacts all permission
  /// grants matching the given Uri, for any package they had been granted to, through any
  /// mechanism this had happened (such as indirectly through the clipboard, activity launch,
  /// service start, etc).  That means this can be potentially dangerous to use, as it can
  /// revoke grants that another app could be strongly expecting to stick around.
  ///
  ///@param uri The Uri you would like to revoke access to.
  ///@param modeFlags The access modes to revoke.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@see \#grantUriPermission
  void revokeUriPermission(jni.JniObject uri, int modeFlags) {
    final result__ = _revokeUriPermission(reference, uri.reference, modeFlags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _revokeUriPermission1 = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Context_revokeUriPermission1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void revokeUriPermission(java.lang.String toPackage, android.net.Uri uri, int modeFlags)
  ///
  /// Remove permissions to access a particular content provider Uri
  /// that were previously added with \#grantUriPermission for a specific target
  /// package.  The given Uri will match all previously granted Uris that are the same or a
  /// sub-path of the given Uri.  That is, revoking "content://foo/target" will
  /// revoke both "content://foo/target" and "content://foo/target/sub", but not
  /// "content://foo".  It will not remove any prefix grants that exist at a
  /// higher level.
  ///
  /// Unlike \#revokeUriPermission(Uri, int), this method will _only_
  /// revoke permissions that had been explicitly granted through \#grantUriPermission
  /// and only for the package specified.  Any matching grants that have happened through
  /// other mechanisms (clipboard, activity launching, service starting, etc) will not be
  /// removed.
  ///
  ///@param toPackage The package you had previously granted access to.
  ///@param uri The Uri you would like to revoke access to.
  ///@param modeFlags The access modes to revoke.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@see \#grantUriPermission
  void revokeUriPermission1(
      jni.JniString toPackage, jni.JniObject uri, int modeFlags) {
    final result__ = _revokeUriPermission1(
        reference, toPackage.reference, uri.reference, modeFlags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _checkUriPermission = jniLookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("android_content_Context_checkUriPermission")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public abstract int checkUriPermission(android.net.Uri uri, int pid, int uid, int modeFlags)
  ///
  /// Determine whether a particular process and user ID has been granted
  /// permission to access a specific URI.  This only checks for permissions
  /// that have been explicitly granted -- if the given process/uid has
  /// more general access to the URI's content provider then this check will
  /// always fail.
  ///@param uri The uri that is being checked.
  ///@param pid The process ID being checked against.  Must be &gt; 0.
  ///@param uid The user ID being checked against.  A uid of 0 is the root
  /// user, which will pass every permission check.
  ///@param modeFlags The access modes to check.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@return PackageManager\#PERMISSION_GRANTED if the given
  /// pid/uid is allowed to access that uri, or
  /// PackageManager\#PERMISSION_DENIED if it is not.
  ///
  /// Value is android.content.pm.PackageManager\#PERMISSION_GRANTED, or android.content.pm.PackageManager\#PERMISSION_DENIED
  ///@see \#checkCallingUriPermission
  int checkUriPermission(jni.JniObject uri, int pid, int uid, int modeFlags) {
    final result__ =
        _checkUriPermission(reference, uri.reference, pid, uid, modeFlags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _checkCallingUriPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_Context_checkCallingUriPermission")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract int checkCallingUriPermission(android.net.Uri uri, int modeFlags)
  ///
  /// Determine whether the calling process and user ID has been
  /// granted permission to access a specific URI.  This is basically
  /// the same as calling \#checkUriPermission(Uri, int, int,
  /// int) with the pid and uid returned by android.os.Binder\#getCallingPid and android.os.Binder\#getCallingUid.  One important difference is
  /// that if you are not currently processing an IPC, this function
  /// will always fail.
  ///@param uri The uri that is being checked.
  ///@param modeFlags The access modes to check.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@return PackageManager\#PERMISSION_GRANTED if the caller
  /// is allowed to access that uri, or
  /// PackageManager\#PERMISSION_DENIED if it is not.
  ///
  /// Value is android.content.pm.PackageManager\#PERMISSION_GRANTED, or android.content.pm.PackageManager\#PERMISSION_DENIED
  ///@see \#checkUriPermission(Uri, int, int, int)
  int checkCallingUriPermission(jni.JniObject uri, int modeFlags) {
    final result__ =
        _checkCallingUriPermission(reference, uri.reference, modeFlags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _checkCallingOrSelfUriPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_Context_checkCallingOrSelfUriPermission")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract int checkCallingOrSelfUriPermission(android.net.Uri uri, int modeFlags)
  ///
  /// Determine whether the calling process of an IPC _or you_ has been granted
  /// permission to access a specific URI.  This is the same as
  /// \#checkCallingUriPermission, except it grants your own permissions
  /// if you are not currently processing an IPC.  Use with care!
  ///@param uri The uri that is being checked.
  ///@param modeFlags The access modes to check.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@return PackageManager\#PERMISSION_GRANTED if the caller
  /// is allowed to access that uri, or
  /// PackageManager\#PERMISSION_DENIED if it is not.
  ///
  /// Value is android.content.pm.PackageManager\#PERMISSION_GRANTED, or android.content.pm.PackageManager\#PERMISSION_DENIED
  ///@see \#checkCallingUriPermission
  int checkCallingOrSelfUriPermission(jni.JniObject uri, int modeFlags) {
    final result__ =
        _checkCallingOrSelfUriPermission(reference, uri.reference, modeFlags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _checkUriPermission1 = jniLookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("android_content_Context_checkUriPermission1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public abstract int checkUriPermission(android.net.Uri uri, java.lang.String readPermission, java.lang.String writePermission, int pid, int uid, int modeFlags)
  ///
  /// Check both a Uri and normal permission.  This allows you to perform
  /// both \#checkPermission and \#checkUriPermission in one
  /// call.
  ///@param uri The Uri whose permission is to be checked, or null to not
  /// do this check.
  /// This value may be {@code null}.
  ///@param readPermission The permission that provides overall read access,
  /// or null to not do this check.
  /// This value may be {@code null}.
  ///@param writePermission The permission that provides overall write
  /// access, or null to not do this check.
  /// This value may be {@code null}.
  ///@param pid The process ID being checked against.  Must be &gt; 0.
  ///@param uid The user ID being checked against.  A uid of 0 is the root
  /// user, which will pass every permission check.
  ///@param modeFlags The access modes to check.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@return PackageManager\#PERMISSION_GRANTED if the caller
  /// is allowed to access that uri or holds one of the given permissions, or
  /// PackageManager\#PERMISSION_DENIED if it is not.
  ///
  /// Value is android.content.pm.PackageManager\#PERMISSION_GRANTED, or android.content.pm.PackageManager\#PERMISSION_DENIED
  int checkUriPermission1(jni.JniObject uri, jni.JniString readPermission,
      jni.JniString writePermission, int pid, int uid, int modeFlags) {
    final result__ = _checkUriPermission1(
        reference,
        uri.reference,
        readPermission.reference,
        writePermission.reference,
        pid,
        uid,
        modeFlags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _enforceUriPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_enforceUriPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void enforceUriPermission(android.net.Uri uri, int pid, int uid, int modeFlags, java.lang.String message)
  ///
  /// If a particular process and user ID has not been granted
  /// permission to access a specific URI, throw SecurityException.  This only checks for permissions that have
  /// been explicitly granted -- if the given process/uid has more
  /// general access to the URI's content provider then this check
  /// will always fail.
  ///@param uri The uri that is being checked.
  ///@param pid The process ID being checked against.  Must be &gt; 0.
  ///@param uid The user ID being checked against.  A uid of 0 is the root
  /// user, which will pass every permission check.
  ///@param modeFlags The access modes to enforce.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@param message A message to include in the exception if it is thrown.
  ///@see \#checkUriPermission(Uri, int, int, int)
  void enforceUriPermission(jni.JniObject uri, int pid, int uid, int modeFlags,
      jni.JniString message) {
    final result__ = _enforceUriPermission(
        reference, uri.reference, pid, uid, modeFlags, message.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _enforceCallingUriPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_enforceCallingUriPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void enforceCallingUriPermission(android.net.Uri uri, int modeFlags, java.lang.String message)
  ///
  /// If the calling process and user ID has not been granted
  /// permission to access a specific URI, throw SecurityException.  This is basically the same as calling
  /// \#enforceUriPermission(Uri, int, int, int, String) with
  /// the pid and uid returned by android.os.Binder\#getCallingPid and android.os.Binder\#getCallingUid.  One important difference is
  /// that if you are not currently processing an IPC, this function
  /// will always throw a SecurityException.
  ///@param uri The uri that is being checked.
  ///@param modeFlags The access modes to enforce.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@param message A message to include in the exception if it is thrown.
  ///@see \#checkCallingUriPermission(Uri, int)
  void enforceCallingUriPermission(
      jni.JniObject uri, int modeFlags, jni.JniString message) {
    final result__ = _enforceCallingUriPermission(
        reference, uri.reference, modeFlags, message.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _enforceCallingOrSelfUriPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_enforceCallingOrSelfUriPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void enforceCallingOrSelfUriPermission(android.net.Uri uri, int modeFlags, java.lang.String message)
  ///
  /// If the calling process of an IPC _or you_ has not been
  /// granted permission to access a specific URI, throw SecurityException.  This is the same as \#enforceCallingUriPermission, except it grants your own
  /// permissions if you are not currently processing an IPC.  Use
  /// with care!
  ///@param uri The uri that is being checked.
  ///@param modeFlags The access modes to enforce.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@param message A message to include in the exception if it is thrown.
  ///@see \#checkCallingOrSelfUriPermission(Uri, int)
  void enforceCallingOrSelfUriPermission(
      jni.JniObject uri, int modeFlags, jni.JniString message) {
    final result__ = _enforceCallingOrSelfUriPermission(
        reference, uri.reference, modeFlags, message.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _enforceUriPermission1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_enforceUriPermission1")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void enforceUriPermission(android.net.Uri uri, java.lang.String readPermission, java.lang.String writePermission, int pid, int uid, int modeFlags, java.lang.String message)
  ///
  /// Enforce both a Uri and normal permission.  This allows you to perform
  /// both \#enforcePermission and \#enforceUriPermission in one
  /// call.
  ///@param uri The Uri whose permission is to be checked, or null to not
  /// do this check.
  /// This value may be {@code null}.
  ///@param readPermission The permission that provides overall read access,
  /// or null to not do this check.
  /// This value may be {@code null}.
  ///@param writePermission The permission that provides overall write
  /// access, or null to not do this check.
  /// This value may be {@code null}.
  ///@param pid The process ID being checked against.  Must be &gt; 0.
  ///@param uid The user ID being checked against.  A uid of 0 is the root
  /// user, which will pass every permission check.
  ///@param modeFlags The access modes to enforce.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, and android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  ///@param message A message to include in the exception if it is thrown.
  ///
  /// This value may be {@code null}.
  ///@see \#checkUriPermission(Uri, String, String, int, int, int)
  void enforceUriPermission1(
      jni.JniObject uri,
      jni.JniString readPermission,
      jni.JniString writePermission,
      int pid,
      int uid,
      int modeFlags,
      jni.JniString message) {
    final result__ = _enforceUriPermission1(
        reference,
        uri.reference,
        readPermission.reference,
        writePermission.reference,
        pid,
        uid,
        modeFlags,
        message.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _createPackageContext = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Context_createPackageContext")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.Context createPackageContext(java.lang.String packageName, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new Context object for the given application name.  This
  /// Context is the same as what the named application gets when it is
  /// launched, containing the same resources and class loader.  Each call to
  /// this method returns a new instance of a Context object; Context objects
  /// are not shared, however they share common state (Resources, ClassLoader,
  /// etc) so the Context instance itself is fairly lightweight.
  ///
  /// Throws android.content.pm.PackageManager.NameNotFoundException if there is no
  /// application with the given package name.
  ///
  /// Throws java.lang.SecurityException if the Context requested
  /// can not be loaded into the caller's process for security reasons (see
  /// \#CONTEXT_INCLUDE_CODE for more information}.
  ///@param packageName Name of the application's package.
  ///@param flags Option flags.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Context\#CONTEXT_INCLUDE_CODE, android.content.Context\#CONTEXT_IGNORE_SECURITY, android.content.Context\#CONTEXT_RESTRICTED, android.content.Context.CONTEXT_DEVICE_PROTECTED_STORAGE, android.content.Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE, and android.content.Context.CONTEXT_REGISTER_PACKAGE
  ///@return A Context for the application.
  ///@throws SecurityException &nbsp;
  ///@throws PackageManager.NameNotFoundException if there is no application with
  /// the given package name.
  Context createPackageContext(jni.JniString packageName, int flags) {
    final result__ = Context.fromRef(
        _createPackageContext(reference, packageName.reference, flags));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _createContextForSplit = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_createContextForSplit")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Context createContextForSplit(java.lang.String splitName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new Context object for the given split name. The new Context has a ClassLoader and
  /// Resources object that can access the split's and all of its dependencies' code/resources.
  /// Each call to this method returns a new instance of a Context object;
  /// Context objects are not shared, however common state (ClassLoader, other Resources for
  /// the same split) may be so the Context itself can be fairly lightweight.
  ///@param splitName The name of the split to include, as declared in the split's
  ///                  <code>AndroidManifest.xml</code>.
  ///@return A Context with the given split's code and/or resources loaded.
  Context createContextForSplit(jni.JniString splitName) {
    final result__ =
        Context.fromRef(_createContextForSplit(reference, splitName.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _createConfigurationContext = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_createConfigurationContext")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Context createConfigurationContext(android.content.res.Configuration overrideConfiguration)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new Context object for the current Context but whose resources
  /// are adjusted to match the given Configuration.  Each call to this method
  /// returns a new instance of a Context object; Context objects are not
  /// shared, however common state (ClassLoader, other Resources for the
  /// same configuration) may be so the Context itself can be fairly lightweight.
  ///@param overrideConfiguration A Configuration specifying what
  /// values to modify in the base Configuration of the original Context's
  /// resources.  If the base configuration changes (such as due to an
  /// orientation change), the resources of this context will also change except
  /// for those that have been explicitly overridden with a value here.
  ///
  /// This value must never be {@code null}.
  ///@return A Context with the given configuration override.
  Context createConfigurationContext(res_.Configuration overrideConfiguration) {
    final result__ = Context.fromRef(_createConfigurationContext(
        reference, overrideConfiguration.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _createDisplayContext = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_createDisplayContext")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Context createDisplayContext(android.view.Display display)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new Context object for the current Context but whose resources
  /// are adjusted to match the metrics of the given Display.  Each call to this method
  /// returns a new instance of a Context object; Context objects are not
  /// shared, however common state (ClassLoader, other Resources for the
  /// same configuration) may be so the Context itself can be fairly lightweight.
  ///
  /// The returned display Context provides a WindowManager
  /// (see \#getSystemService(String)) that is configured to show windows
  /// on the given display.  The WindowManager's WindowManager\#getDefaultDisplay
  /// method can be used to retrieve the Display from the returned Context.
  ///@param display A Display object specifying the display
  /// for whose metrics the Context's resources should be tailored and upon which
  /// new windows should be shown.
  ///
  /// This value must never be {@code null}.
  ///@return A Context for the display.
  Context createDisplayContext(jni.JniObject display) {
    final result__ =
        Context.fromRef(_createDisplayContext(reference, display.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _createDeviceProtectedStorageContext = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Context_createDeviceProtectedStorageContext")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Context createDeviceProtectedStorageContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new Context object for the current Context but whose storage
  /// APIs are backed by device-protected storage.
  ///
  /// On devices with direct boot, data stored in this location is encrypted
  /// with a key tied to the physical device, and it can be accessed
  /// immediately after the device has booted successfully, both
  /// _before and after_ the user has authenticated with their
  /// credentials (such as a lock pattern or PIN).
  ///
  /// Because device-protected data is available without user authentication,
  /// you should carefully limit the data you store using this Context. For
  /// example, storing sensitive authentication tokens or passwords in the
  /// device-protected area is strongly discouraged.
  ///
  /// If the underlying device does not have the ability to store
  /// device-protected and credential-protected data using different keys, then
  /// both storage areas will become available at the same time. They remain as
  /// two distinct storage locations on disk, and only the window of
  /// availability changes.
  ///
  /// Each call to this method returns a new instance of a Context object;
  /// Context objects are not shared, however common state (ClassLoader, other
  /// Resources for the same configuration) may be so the Context itself can be
  /// fairly lightweight.
  ///@see \#isDeviceProtectedStorage()
  Context createDeviceProtectedStorageContext() {
    final result__ =
        Context.fromRef(_createDeviceProtectedStorageContext(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isRestricted =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Context_isRestricted")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isRestricted()
  ///
  /// Indicates whether this Context is restricted.
  ///@return {@code true} if this Context is restricted, {@code false} otherwise.
  ///@see \#CONTEXT_RESTRICTED
  bool isRestricted() {
    final result__ = _isRestricted(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isDeviceProtectedStorage =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Context_isDeviceProtectedStorage")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isDeviceProtectedStorage()
  ///
  /// Indicates if the storage APIs of this Context are backed by
  /// device-protected storage.
  ///@see \#createDeviceProtectedStorageContext()
  bool isDeviceProtectedStorage() {
    final result__ = _isDeviceProtectedStorage(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.ContentUris
///
/// Utility methods useful for working with android.net.Uri objects
/// that use the &quot;content&quot; (content://) scheme.
///
///
///   Content URIs have the syntax
///
///
///
///   <code>content://_authority_/_path_/_id_</code>
///
///
///<dl>
///   <dt>
///       <code>content:</code>
///   </dt>
///   <dd>
///       The scheme portion of the URI. This is always set to android.content.ContentResolver\#SCHEME_CONTENT ContentResolver.SCHEME_CONTENT (value
///       <code>content://</code>).
///   </dd>
///   <dt>
///       _authority_
///   </dt>
///   <dd>
///       A string that identifies the entire content provider. All the content URIs for the provider
///       start with this string. To guarantee a unique authority, providers should consider
///       using an authority that is the same as the provider class' package identifier.
///   </dd>
///   <dt>
///       _path_
///   </dt>
///   <dd>
///       Zero or more segments, separated by a forward slash (<code>/</code>), that identify
///       some subset of the provider's data. Most providers use the path part to identify
///       individual tables. Individual segments in the path are often called
///       &quot;directories&quot; although they do not refer to file directories. The right-most
///       segment in a path is often called a &quot;twig&quot;
///   </dd>
///   <dt>
///       _id_
///   </dt>
///   <dd>
///       A unique numeric identifier for a single row in the subset of data identified by the
///       preceding path part. Most providers recognize content URIs that contain an id part
///       and give them special handling. A table that contains a column named <code>_ID</code>
///       often expects the id part to be a particular value for that column.
///   </dd>
///</dl>
class ContentUris extends jni.JniObject {
  ContentUris.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_ContentUris_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ContentUris() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _parseId =
      jniLookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentUris_parseId")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public long parseId(android.net.Uri contentUri)
  ///
  /// Converts the last path segment to a long.
  ///
  /// This supports a common convention for content URIs where an ID is
  /// stored in the last segment.
  ///@throws UnsupportedOperationException if this isn't a hierarchical URI
  ///@throws NumberFormatException if the last segment isn't a number
  ///@return the long conversion of the last segment or -1 if the path is
  ///  empty
  static int parseId(jni.JniObject contentUri) {
    final result__ = _parseId(contentUri.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _appendId = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_content_ContentUris_appendId")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.net.Uri.Builder appendId(android.net.Uri.Builder builder, long id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Appends the given ID to the end of the path.
  ///@param builder to append the ID to
  ///@param id to append
  ///@return the given builder
  static jni.JniObject appendId(jni.JniObject builder, int id) {
    final result__ = jni.JniObject.fromRef(_appendId(builder.reference, id));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _withAppendedId = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_content_ContentUris_withAppendedId")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.net.Uri withAppendedId(android.net.Uri contentUri, long id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Appends the given ID to the end of the path.
  ///@param contentUri to start with
  ///@param id to append
  ///@return a new URI with the given ID appended to the end of the path
  static jni.JniObject withAppendedId(jni.JniObject contentUri, int id) {
    final result__ =
        jni.JniObject.fromRef(_withAppendedId(contentUri.reference, id));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.SyncStats
///
/// Used to record various statistics about the result of a sync operation. The SyncManager
/// gets access to these via a SyncResult and uses some of them to determine the
/// disposition of the sync. See SyncResult for further dicussion on how the
/// SyncManager uses these values.
class SyncStats extends jni.JniObject {
  SyncStats.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_SyncStats_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.SyncStats> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  static final _get_numAuthExceptions = jniLookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncStats_numAuthExceptions")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public long numAuthExceptions
  ///
  /// The SyncAdapter was unable to authenticate the android.accounts.Account
  /// that was specified in the request. The user needs to take some action to resolve
  /// before a future request can expect to succeed. This is considered a hard error.
  int get numAuthExceptions => _get_numAuthExceptions(reference);
  static final _set_numAuthExceptions = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_content_SyncStats_numAuthExceptions")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public long numAuthExceptions
  ///
  /// The SyncAdapter was unable to authenticate the android.accounts.Account
  /// that was specified in the request. The user needs to take some action to resolve
  /// before a future request can expect to succeed. This is considered a hard error.
  set numAuthExceptions(int value) => _set_numAuthExceptions(reference, value);

  static final _get_numConflictDetectedExceptions = jniLookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncStats_numConflictDetectedExceptions")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public long numConflictDetectedExceptions
  ///
  /// The SyncAdapter detected that there was an unrecoverable version conflict when it
  /// attempted to update or delete a version of a resource on the server. This is expected
  /// to clear itself automatically once the new state is retrieved from the server,
  /// though it may remain until the user intervenes manually, perhaps by clearing the
  /// local storage and starting over frmo scratch. This is considered a hard error.
  int get numConflictDetectedExceptions =>
      _get_numConflictDetectedExceptions(reference);
  static final _set_numConflictDetectedExceptions = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_content_SyncStats_numConflictDetectedExceptions")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public long numConflictDetectedExceptions
  ///
  /// The SyncAdapter detected that there was an unrecoverable version conflict when it
  /// attempted to update or delete a version of a resource on the server. This is expected
  /// to clear itself automatically once the new state is retrieved from the server,
  /// though it may remain until the user intervenes manually, perhaps by clearing the
  /// local storage and starting over frmo scratch. This is considered a hard error.
  set numConflictDetectedExceptions(int value) =>
      _set_numConflictDetectedExceptions(reference, value);

  static final _get_numDeletes = jniLookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncStats_numDeletes")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public long numDeletes
  ///
  /// Counter for tracking how many deletes were performed by the sync operation, as defined
  /// by the SyncAdapter.
  int get numDeletes => _get_numDeletes(reference);
  static final _set_numDeletes = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("set_android_content_SyncStats_numDeletes")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public long numDeletes
  ///
  /// Counter for tracking how many deletes were performed by the sync operation, as defined
  /// by the SyncAdapter.
  set numDeletes(int value) => _set_numDeletes(reference, value);

  static final _get_numEntries = jniLookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncStats_numEntries")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public long numEntries
  ///
  /// Counter for tracking how many entries were affected by the sync operation, as defined
  /// by the SyncAdapter.
  int get numEntries => _get_numEntries(reference);
  static final _set_numEntries = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("set_android_content_SyncStats_numEntries")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public long numEntries
  ///
  /// Counter for tracking how many entries were affected by the sync operation, as defined
  /// by the SyncAdapter.
  set numEntries(int value) => _set_numEntries(reference, value);

  static final _get_numInserts = jniLookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncStats_numInserts")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public long numInserts
  ///
  /// Counter for tracking how many inserts were performed by the sync operation, as defined
  /// by the SyncAdapter.
  int get numInserts => _get_numInserts(reference);
  static final _set_numInserts = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("set_android_content_SyncStats_numInserts")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public long numInserts
  ///
  /// Counter for tracking how many inserts were performed by the sync operation, as defined
  /// by the SyncAdapter.
  set numInserts(int value) => _set_numInserts(reference, value);

  static final _get_numIoExceptions = jniLookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncStats_numIoExceptions")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public long numIoExceptions
  ///
  /// The SyncAdapter had a problem, most likely with the network connectivity or a timeout
  /// while waiting for a network response. The request may succeed if it is tried again
  /// later. This is considered a soft error.
  int get numIoExceptions => _get_numIoExceptions(reference);
  static final _set_numIoExceptions = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("set_android_content_SyncStats_numIoExceptions")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public long numIoExceptions
  ///
  /// The SyncAdapter had a problem, most likely with the network connectivity or a timeout
  /// while waiting for a network response. The request may succeed if it is tried again
  /// later. This is considered a soft error.
  set numIoExceptions(int value) => _set_numIoExceptions(reference, value);

  static final _get_numParseExceptions = jniLookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncStats_numParseExceptions")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public long numParseExceptions
  ///
  /// The SyncAdapter had a problem with the data it received from the server or the storage
  /// later. This problem will likely repeat if the request is tried again. The problem
  /// will need to be cleared up by either the server or the storage layer (likely with help
  /// from the user). If the SyncAdapter cleans up the data itself then it typically won't
  /// increment this value although it may still do so in order to record that it had to
  /// perform some cleanup. E.g., if the SyncAdapter received a bad entry from the server
  /// when processing a feed of entries, it may choose to drop the entry and thus make
  /// progress and still increment this value just so the SyncAdapter can record that an
  /// error occurred. This is considered a hard error.
  int get numParseExceptions => _get_numParseExceptions(reference);
  static final _set_numParseExceptions = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_content_SyncStats_numParseExceptions")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public long numParseExceptions
  ///
  /// The SyncAdapter had a problem with the data it received from the server or the storage
  /// later. This problem will likely repeat if the request is tried again. The problem
  /// will need to be cleared up by either the server or the storage layer (likely with help
  /// from the user). If the SyncAdapter cleans up the data itself then it typically won't
  /// increment this value although it may still do so in order to record that it had to
  /// perform some cleanup. E.g., if the SyncAdapter received a bad entry from the server
  /// when processing a feed of entries, it may choose to drop the entry and thus make
  /// progress and still increment this value just so the SyncAdapter can record that an
  /// error occurred. This is considered a hard error.
  set numParseExceptions(int value) =>
      _set_numParseExceptions(reference, value);

  static final _get_numSkippedEntries = jniLookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncStats_numSkippedEntries")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public long numSkippedEntries
  ///
  /// Counter for tracking how many entries, either from the server or the local store, were
  /// ignored during the sync operation. This could happen if the SyncAdapter detected some
  /// unparsable data but decided to skip it and move on rather than failing immediately.
  int get numSkippedEntries => _get_numSkippedEntries(reference);
  static final _set_numSkippedEntries = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "set_android_content_SyncStats_numSkippedEntries")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public long numSkippedEntries
  ///
  /// Counter for tracking how many entries, either from the server or the local store, were
  /// ignored during the sync operation. This could happen if the SyncAdapter detected some
  /// unparsable data but decided to skip it and move on rather than failing immediately.
  set numSkippedEntries(int value) => _set_numSkippedEntries(reference, value);

  static final _get_numUpdates = jniLookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncStats_numUpdates")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public long numUpdates
  ///
  /// Counter for tracking how many updates were performed by the sync operation, as defined
  /// by the SyncAdapter.
  int get numUpdates => _get_numUpdates(reference);
  static final _set_numUpdates = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("set_android_content_SyncStats_numUpdates")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public long numUpdates
  ///
  /// Counter for tracking how many updates were performed by the sync operation, as defined
  /// by the SyncAdapter.
  set numUpdates(int value) => _set_numUpdates(reference, value);

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_SyncStats_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  SyncStats() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_SyncStats_ctor1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel in)
  SyncStats.ctor1(os_.Parcel in0) : super.fromRef(_ctor1(in0.reference)) {
    jni.Jni.env.checkException();
  }

  static final _toString1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_SyncStats_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _clear =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SyncStats_clear")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void clear()
  ///
  /// Reset all the counters to 0.
  void clear() {
    final result__ = _clear(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SyncStats_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_SyncStats_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) {
    final result__ = _writeToParcel(reference, dest.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.ServiceConnection
///
/// Interface for monitoring the state of an application service.  See
/// android.app.Service and
/// Context\#bindService Context.bindService() for more information.
/// Like many callbacks from the system, the methods on this class are called
/// from the main thread of your process.
class ServiceConnection extends jni.JniObject {
  ServiceConnection.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _onServiceConnected = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ServiceConnection_onServiceConnected")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onServiceConnected(android.content.ComponentName name, android.os.IBinder service)
  ///
  /// Called when a connection to the Service has been established, with
  /// the android.os.IBinder of the communication channel to the
  /// Service.
  ///
  /// <p class="note">__Note:__ If the system has started to bind your
  /// client app to a service, it's possible that your app will never receive
  /// this callback. Your app won't receive a callback if there's an issue with
  /// the service, such as the service crashing while being created.
  ///@param name The concrete component name of the service that has
  /// been connected.
  ///@param service The IBinder of the Service's communication channel,
  /// which you can now make calls on.
  void onServiceConnected(ComponentName name, os_.IBinder service) {
    final result__ =
        _onServiceConnected(reference, name.reference, service.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onServiceDisconnected = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ServiceConnection_onServiceDisconnected")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onServiceDisconnected(android.content.ComponentName name)
  ///
  /// Called when a connection to the Service has been lost.  This typically
  /// happens when the process hosting the service has crashed or been killed.
  /// This does _not_ remove the ServiceConnection itself -- this
  /// binding to the service will remain active, and you will receive a call
  /// to \#onServiceConnected when the Service is next running.
  ///@param name The concrete component name of the service whose
  /// connection has been lost.
  void onServiceDisconnected(ComponentName name) {
    final result__ = _onServiceDisconnected(reference, name.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onBindingDied = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ServiceConnection_onBindingDied")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: default public void onBindingDied(android.content.ComponentName name)
  ///
  /// Called when the binding to this connection is dead.  This means the
  /// interface will never receive another connection.  The application will
  /// need to unbind and rebind the connection to activate it again.  This may
  /// happen, for example, if the application hosting the service it is bound to
  /// has been updated.
  ///@param name The concrete component name of the service whose
  /// connection is dead.
  void onBindingDied(ComponentName name) {
    final result__ = _onBindingDied(reference, name.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onNullBinding = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ServiceConnection_onNullBinding")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: default public void onNullBinding(android.content.ComponentName name)
  ///
  /// Called when the service being bound has returned {@code null} from its
  /// android.app.Service\#onBind(Intent) onBind() method.  This indicates
  /// that the attempting service binding represented by this ServiceConnection
  /// will never become usable.
  ///
  /// <p class="note">The app which requested the binding must still call
  /// Context\#unbindService(ServiceConnection) to release the tracking
  /// resources associated with this ServiceConnection even if this callback was
  /// invoked following Context\#bindService Context.bindService() bindService().
  ///@param name The concrete component name of the service whose binding
  ///     has been rejected by the Service implementation.
  void onNullBinding(ComponentName name) {
    final result__ = _onNullBinding(reference, name.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.MutableContextWrapper
///
/// Special version of ContextWrapper that allows the base context to
/// be modified after it is initially set.
class MutableContextWrapper extends ContextWrapper {
  MutableContextWrapper.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_MutableContextWrapper_ctor1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context base)
  MutableContextWrapper.ctor1(Context base)
      : super.fromRef(_ctor1(base.reference)) {
    jni.Jni.env.checkException();
  }

  static final _setBaseContext = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_MutableContextWrapper_setBaseContext")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setBaseContext(android.content.Context base)
  ///
  /// Change the base context for this ContextWrapper. All calls will then be
  /// delegated to the base context.  Unlike ContextWrapper, the base context
  /// can be changed even after one is already set.
  ///@param base The new base context for this wrapper.
  void setBaseContext(Context base) {
    final result__ = _setBaseContext(reference, base.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.IntentFilter
///
/// Structured description of Intent values to be matched.  An IntentFilter can
/// match against actions, categories, and data (either via its type, scheme,
/// and/or path) in an Intent.  It also includes a "priority" value which is
/// used to order multiple matching filters.
///
/// IntentFilter objects are often created in XML as part of a package's
/// android.R.styleable\#AndroidManifest AndroidManifest.xml file,
/// using android.R.styleable\#AndroidManifestIntentFilter intent-filter
/// tags.
///
/// There are three Intent characteristics you can filter on: the
/// _action_, _data_, and _categories_.  For each of these
/// characteristics you can provide
/// multiple possible matching values (via \#addAction,
/// \#addDataType, \#addDataScheme, \#addDataSchemeSpecificPart,
/// \#addDataAuthority, \#addDataPath, and \#addCategory, respectively).
/// For actions, the field
/// will not be tested if no values have been given (treating it as a wildcard);
/// if no data characteristics are specified, however, then the filter will
/// only match intents that contain no data.
///
/// The data characteristic is
/// itself divided into three attributes: type, scheme, authority, and path.
/// Any that are
/// specified must match the contents of the Intent.  If you specify a scheme
/// but no type, only Intent that does not have a type (such as mailto:) will
/// match; a content: URI will never match because they always have a MIME type
/// that is supplied by their content provider.  Specifying a type with no scheme
/// has somewhat special meaning: it will match either an Intent with no URI
/// field, or an Intent with a content: or file: URI.  If you specify neither,
/// then only an Intent with no data or type will match.  To specify an authority,
/// you must also specify one or more schemes that it is associated with.
/// To specify a path, you also must specify both one or more authorities and
/// one or more schemes it is associated with.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For information about how to create and resolve intents, read the
/// <a href="{@docRoot}guide/topics/intents/intents-filters.html">Intents and Intent Filters</a>
/// developer guide.
///
/// </div>
///
/// <h3>Filter Rules</h3>
/// A match is based on the following rules.  Note that
/// for an IntentFilter to match an Intent, three conditions must hold:
/// the <strong>action</strong> and <strong>category</strong> must match, and
/// the data (both the <strong>data type</strong> and
/// <strong>data scheme+authority+path</strong> if specified) must match
/// (see \#match(ContentResolver, Intent, boolean, String) for more details
/// on how the data fields match).
///
/// <strong>Action</strong> matches if any of the given values match the
/// Intent action; if the filter specifies no actions, then it will only match
/// Intents that do not contain an action.
///
/// <strong>Data Type</strong> matches if any of the given values match the
/// Intent type.  The Intent
/// type is determined by calling Intent\#resolveType.  A wildcard can be
/// used for the MIME sub-type, in both the Intent and IntentFilter, so that the
/// type "audio/*" will match "audio/mpeg", "audio/aiff", "audio/*", etc.
/// _Note that MIME type matching here is __case sensitive__, unlike
/// formal RFC MIME types!_  You should thus always use lower case letters
/// for your MIME types.
///
/// <strong>Data Scheme</strong> matches if any of the given values match the
/// Intent data's scheme.
/// The Intent scheme is determined by calling Intent\#getData
/// and android.net.Uri\#getScheme on that URI.
/// _Note that scheme matching here is __case sensitive__, unlike
/// formal RFC schemes!_  You should thus always use lower case letters
/// for your schemes.
///
/// <strong>Data Scheme Specific Part</strong> matches if any of the given values match
/// the Intent's data scheme specific part _and_ one of the data schemes in the filter
/// has matched the Intent, _or_ no scheme specific parts were supplied in the filter.
/// The Intent scheme specific part is determined by calling
/// Intent\#getData and android.net.Uri\#getSchemeSpecificPart on that URI.
/// _Note that scheme specific part matching is __case sensitive__._
///
/// <strong>Data Authority</strong> matches if any of the given values match
/// the Intent's data authority _and_ one of the data schemes in the filter
/// has matched the Intent, _or_ no authories were supplied in the filter.
/// The Intent authority is determined by calling
/// Intent\#getData and android.net.Uri\#getAuthority on that URI.
/// _Note that authority matching here is __case sensitive__, unlike
/// formal RFC host names!_  You should thus always use lower case letters
/// for your authority.
///
/// <strong>Data Path</strong> matches if any of the given values match the
/// Intent's data path _and_ both a scheme and authority in the filter
/// has matched against the Intent, _or_ no paths were supplied in the
/// filter.  The Intent authority is determined by calling
/// Intent\#getData and android.net.Uri\#getPath on that URI.
///
/// <strong>Categories</strong> match if _all_ of the categories in
/// the Intent match categories given in the filter.  Extra categories in the
/// filter that are not in the Intent will not cause the match to fail.  Note
/// that unlike the action, an IntentFilter with no categories
/// will only match an Intent that does not have any categories.
class IntentFilter extends jni.JniObject {
  IntentFilter.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_IntentFilter_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.IntentFilter> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  /// from: static public final int MATCH_ADJUSTMENT_MASK
  ///
  /// The part of a match constant that applies a quality adjustment to the
  /// basic category of match.  The value \#MATCH_ADJUSTMENT_NORMAL
  /// is no adjustment; higher numbers than that improve the quality, while
  /// lower numbers reduce it.
  static const MATCH_ADJUSTMENT_MASK = 65535;

  /// from: static public final int MATCH_ADJUSTMENT_NORMAL
  ///
  /// Quality adjustment applied to the category of match that signifies
  /// the default, base value; higher numbers improve the quality while
  /// lower numbers reduce it.
  static const MATCH_ADJUSTMENT_NORMAL = 32768;

  /// from: static public final int MATCH_CATEGORY_EMPTY
  ///
  /// The filter matched an intent that had no data specified.
  static const MATCH_CATEGORY_EMPTY = 1048576;

  /// from: static public final int MATCH_CATEGORY_HOST
  ///
  /// The filter matched an intent with the same data URI scheme and
  /// authority host.
  static const MATCH_CATEGORY_HOST = 3145728;

  /// from: static public final int MATCH_CATEGORY_MASK
  ///
  /// The part of a match constant that describes the category of match
  /// that occurred.  May be either \#MATCH_CATEGORY_EMPTY,
  /// \#MATCH_CATEGORY_SCHEME, \#MATCH_CATEGORY_SCHEME_SPECIFIC_PART,
  /// \#MATCH_CATEGORY_HOST, \#MATCH_CATEGORY_PORT,
  /// \#MATCH_CATEGORY_PATH, or \#MATCH_CATEGORY_TYPE.  Higher
  /// values indicate a better match.
  static const MATCH_CATEGORY_MASK = 268369920;

  /// from: static public final int MATCH_CATEGORY_PATH
  ///
  /// The filter matched an intent with the same data URI scheme,
  /// authority, and path.
  static const MATCH_CATEGORY_PATH = 5242880;

  /// from: static public final int MATCH_CATEGORY_PORT
  ///
  /// The filter matched an intent with the same data URI scheme and
  /// authority host and port.
  static const MATCH_CATEGORY_PORT = 4194304;

  /// from: static public final int MATCH_CATEGORY_SCHEME
  ///
  /// The filter matched an intent with the same data URI scheme.
  static const MATCH_CATEGORY_SCHEME = 2097152;

  /// from: static public final int MATCH_CATEGORY_SCHEME_SPECIFIC_PART
  ///
  /// The filter matched an intent with the same data URI scheme and
  /// scheme specific part.
  static const MATCH_CATEGORY_SCHEME_SPECIFIC_PART = 5767168;

  /// from: static public final int MATCH_CATEGORY_TYPE
  ///
  /// The filter matched an intent with the same data MIME type.
  static const MATCH_CATEGORY_TYPE = 6291456;

  /// from: static public final int NO_MATCH_ACTION
  ///
  /// The filter didn't match due to different actions.
  static const NO_MATCH_ACTION = -3;

  /// from: static public final int NO_MATCH_CATEGORY
  ///
  /// The filter didn't match because it required one or more categories
  /// that were not in the Intent.
  static const NO_MATCH_CATEGORY = -4;

  /// from: static public final int NO_MATCH_DATA
  ///
  /// The filter didn't match due to different data URIs.
  static const NO_MATCH_DATA = -2;

  /// from: static public final int NO_MATCH_TYPE
  ///
  /// The filter didn't match due to different MIME types.
  static const NO_MATCH_TYPE = -1;

  /// from: static public final int SYSTEM_HIGH_PRIORITY
  ///
  /// The filter \#setPriority value at which system high-priority
  /// receivers are placed; that is, receivers that should execute before
  /// application code. Applications should never use filters with this or
  /// higher priorities.
  ///@see \#setPriority
  static const SYSTEM_HIGH_PRIORITY = 1000;

  /// from: static public final int SYSTEM_LOW_PRIORITY
  ///
  /// The filter \#setPriority value at which system low-priority
  /// receivers are placed; that is, receivers that should execute after
  /// application code. Applications should never use filters with this or
  /// lower priorities.
  ///@see \#setPriority
  static const SYSTEM_LOW_PRIORITY = -1000;

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_IntentFilter_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ///
  /// New empty IntentFilter.
  IntentFilter() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_IntentFilter_ctor1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String action)
  ///
  /// New IntentFilter that matches a single action with no data.  If
  /// no data characteristics are subsequently specified, then the
  /// filter will only match intents that contain no data.
  ///@param action The action to match, such as Intent.ACTION_MAIN.
  IntentFilter.ctor1(jni.JniString action)
      : super.fromRef(_ctor1(action.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor2 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_IntentFilter_ctor2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String action, java.lang.String dataType)
  ///
  /// New IntentFilter that matches a single action and data type.
  ///
  /// _Note: MIME type matching in the Android framework is
  /// case-sensitive, unlike formal RFC MIME types.  As a result,
  /// you should always write your MIME types with lower case letters,
  /// and any MIME types you receive from outside of Android should be
  /// converted to lower case before supplying them here._
  ///
  ///
  /// Throws MalformedMimeTypeException if the given MIME type is
  /// not syntactically correct.
  ///@param action The action to match, such as Intent.ACTION_VIEW.
  ///@param dataType The type to match, such as "vnd.android.cursor.dir/person".
  IntentFilter.ctor2(jni.JniString action, jni.JniString dataType)
      : super.fromRef(_ctor2(action.reference, dataType.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor3 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_IntentFilter_ctor3")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.IntentFilter o)
  ///
  /// New IntentFilter containing a copy of an existing filter.
  ///@param o The original filter to copy.
  IntentFilter.ctor3(IntentFilter o) : super.fromRef(_ctor3(o.reference)) {
    jni.Jni.env.checkException();
  }

  static final _create = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_create")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.IntentFilter create(java.lang.String action, java.lang.String dataType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new IntentFilter instance with a specified action and MIME
  /// type, where you know the MIME type is correctly formatted.  This catches
  /// the MalformedMimeTypeException exception that the constructor
  /// can call and turns it into a runtime exception.
  ///@param action The action to match, such as Intent.ACTION_VIEW.
  ///@param dataType The type to match, such as "vnd.android.cursor.dir/person".
  ///@return A new IntentFilter for the given action and type.
  ///@see \#IntentFilter(String, String)
  static IntentFilter create(jni.JniString action, jni.JniString dataType) {
    final result__ =
        IntentFilter.fromRef(_create(action.reference, dataType.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setPriority = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_IntentFilter_setPriority")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setPriority(int priority)
  ///
  /// Modify priority of this filter.  This only affects receiver filters.
  /// The priority of activity filters are set in XML and cannot be changed
  /// programatically. The default priority is 0. Positive values will be
  /// before the default, lower values will be after it. Applications should
  /// use a value that is larger than \#SYSTEM_LOW_PRIORITY and
  /// smaller than \#SYSTEM_HIGH_PRIORITY .
  ///@param priority The new priority value.
  ///@see \#getPriority
  ///@see \#SYSTEM_LOW_PRIORITY
  ///@see \#SYSTEM_HIGH_PRIORITY
  void setPriority(int priority) {
    final result__ = _setPriority(reference, priority);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPriority =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_IntentFilter_getPriority")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getPriority()
  ///
  /// Return the priority of this filter.
  ///@return The priority of the filter.
  ///@see \#setPriority
  int getPriority() {
    final result__ = _getPriority(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _addAction = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_addAction")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void addAction(java.lang.String action)
  ///
  /// Add a new Intent action to match against.  If any actions are included
  /// in the filter, then an Intent's action must be one of those values for
  /// it to match.  If no actions are included, the Intent action is ignored.
  ///@param action Name of the action to match, such as Intent.ACTION_VIEW.
  void addAction(jni.JniString action) {
    final result__ = _addAction(reference, action.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _countActions =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_IntentFilter_countActions")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int countActions()
  ///
  /// Return the number of actions in the filter.
  int countActions() {
    final result__ = _countActions(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getAction = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_IntentFilter_getAction")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final java.lang.String getAction(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an action in the filter.
  jni.JniString getAction(int index) {
    final result__ = jni.JniString.fromRef(_getAction(reference, index));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hasAction = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_hasAction")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean hasAction(java.lang.String action)
  ///
  /// Is the given action included in the filter?  Note that if the filter
  /// does not include any actions, false will _always_ be returned.
  ///@param action The action to look for.
  ///@return True if the action is explicitly mentioned in the filter.
  bool hasAction(jni.JniString action) {
    final result__ = _hasAction(reference, action.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _matchAction = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_matchAction")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean matchAction(java.lang.String action)
  ///
  /// Match this filter against an Intent's action.  If the filter does not
  /// specify any actions, the match will always fail.
  ///@param action The desired action to look for.
  ///@return True if the action is listed in the filter.
  bool matchAction(jni.JniString action) {
    final result__ = _matchAction(reference, action.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _actionsIterator = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_actionsIterator")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.Iterator<java.lang.String> actionsIterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an iterator over the filter's actions.  If there are no actions,
  /// returns null.
  jni.JniObject actionsIterator() {
    final result__ = jni.JniObject.fromRef(_actionsIterator(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _addDataType = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_addDataType")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void addDataType(java.lang.String type)
  ///
  /// Add a new Intent data type to match against.  If any types are
  /// included in the filter, then an Intent's data must be _either_
  /// one of these types _or_ a matching scheme.  If no data types
  /// are included, then an Intent will only match if it specifies no data.
  ///
  /// _Note: MIME type matching in the Android framework is
  /// case-sensitive, unlike formal RFC MIME types.  As a result,
  /// you should always write your MIME types with lower case letters,
  /// and any MIME types you receive from outside of Android should be
  /// converted to lower case before supplying them here._
  ///
  ///
  /// Throws MalformedMimeTypeException if the given MIME type is
  /// not syntactically correct.
  ///@param type Name of the data type to match, such as "vnd.android.cursor.dir/person".
  ///@see \#matchData
  void addDataType(jni.JniString type) {
    final result__ = _addDataType(reference, type.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hasDataType = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_hasDataType")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean hasDataType(java.lang.String type)
  ///
  /// Is the given data type included in the filter?  Note that if the filter
  /// does not include any type, false will _always_ be returned.
  ///@param type The data type to look for.
  ///@return True if the type is explicitly mentioned in the filter.
  bool hasDataType(jni.JniString type) {
    final result__ = _hasDataType(reference, type.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _countDataTypes =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_IntentFilter_countDataTypes")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int countDataTypes()
  ///
  /// Return the number of data types in the filter.
  int countDataTypes() {
    final result__ = _countDataTypes(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDataType = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_IntentFilter_getDataType")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final java.lang.String getDataType(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a data type in the filter.
  jni.JniString getDataType(int index) {
    final result__ = jni.JniString.fromRef(_getDataType(reference, index));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _typesIterator = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_typesIterator")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.Iterator<java.lang.String> typesIterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an iterator over the filter's data types.
  jni.JniObject typesIterator() {
    final result__ = jni.JniObject.fromRef(_typesIterator(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _addDataScheme = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_addDataScheme")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void addDataScheme(java.lang.String scheme)
  ///
  /// Add a new Intent data scheme to match against.  If any schemes are
  /// included in the filter, then an Intent's data must be _either_
  /// one of these schemes _or_ a matching data type.  If no schemes
  /// are included, then an Intent will match only if it includes no data.
  ///
  /// _Note: scheme matching in the Android framework is
  /// case-sensitive, unlike formal RFC schemes.  As a result,
  /// you should always write your schemes with lower case letters,
  /// and any schemes you receive from outside of Android should be
  /// converted to lower case before supplying them here._
  ///
  ///@param scheme Name of the scheme to match, such as "http".
  ///@see \#matchData
  void addDataScheme(jni.JniString scheme) {
    final result__ = _addDataScheme(reference, scheme.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _countDataSchemes =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_IntentFilter_countDataSchemes")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int countDataSchemes()
  ///
  /// Return the number of data schemes in the filter.
  int countDataSchemes() {
    final result__ = _countDataSchemes(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDataScheme = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_IntentFilter_getDataScheme")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final java.lang.String getDataScheme(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a data scheme in the filter.
  jni.JniString getDataScheme(int index) {
    final result__ = jni.JniString.fromRef(_getDataScheme(reference, index));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hasDataScheme = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_hasDataScheme")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean hasDataScheme(java.lang.String scheme)
  ///
  /// Is the given data scheme included in the filter?  Note that if the
  /// filter does not include any scheme, false will _always_ be
  /// returned.
  ///@param scheme The data scheme to look for.
  ///@return True if the scheme is explicitly mentioned in the filter.
  bool hasDataScheme(jni.JniString scheme) {
    final result__ = _hasDataScheme(reference, scheme.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _schemesIterator = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_schemesIterator")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.Iterator<java.lang.String> schemesIterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an iterator over the filter's data schemes.
  jni.JniObject schemesIterator() {
    final result__ = jni.JniObject.fromRef(_schemesIterator(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _addDataSchemeSpecificPart = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_IntentFilter_addDataSchemeSpecificPart")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void addDataSchemeSpecificPart(java.lang.String ssp, int type)
  ///
  /// Add a new Intent data "scheme specific part" to match against.  The filter must
  /// include one or more schemes (via \#addDataScheme) for the
  /// scheme specific part to be considered.  If any scheme specific parts are
  /// included in the filter, then an Intent's data must match one of
  /// them.  If no scheme specific parts are included, then only the scheme must match.
  ///
  /// The "scheme specific part" that this matches against is the string returned
  /// by android.net.Uri\#getSchemeSpecificPart() Uri.getSchemeSpecificPart.
  /// For Uris that contain a path, this kind of matching is not generally of interest,
  /// since \#addDataAuthority(String, String) and
  /// \#addDataPath(String, int) can provide a better mechanism for matching
  /// them.  However, for Uris that do not contain a path, the authority and path
  /// are empty, so this is the only way to match against the non-scheme part.
  ///
  ///@param ssp Either a raw string that must exactly match the scheme specific part
  /// path, or a simple pattern, depending on <var>type</var>.
  ///@param type Determines how <var>ssp</var> will be compared to
  /// determine a match: either PatternMatcher\#PATTERN_LITERAL,
  /// PatternMatcher\#PATTERN_PREFIX, or
  /// PatternMatcher\#PATTERN_SIMPLE_GLOB.
  ///@see \#matchData
  ///@see \#addDataScheme
  void addDataSchemeSpecificPart(jni.JniString ssp, int type) {
    final result__ = _addDataSchemeSpecificPart(reference, ssp.reference, type);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _countDataSchemeSpecificParts =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_IntentFilter_countDataSchemeSpecificParts")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int countDataSchemeSpecificParts()
  ///
  /// Return the number of data scheme specific parts in the filter.
  int countDataSchemeSpecificParts() {
    final result__ = _countDataSchemeSpecificParts(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDataSchemeSpecificPart = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_IntentFilter_getDataSchemeSpecificPart")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final android.os.PatternMatcher getDataSchemeSpecificPart(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a data scheme specific part in the filter.
  os_.PatternMatcher getDataSchemeSpecificPart(int index) {
    final result__ = os_.PatternMatcher.fromRef(
        _getDataSchemeSpecificPart(reference, index));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hasDataSchemeSpecificPart = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_hasDataSchemeSpecificPart")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean hasDataSchemeSpecificPart(java.lang.String data)
  ///
  /// Is the given data scheme specific part included in the filter?  Note that if the
  /// filter does not include any scheme specific parts, false will _always_ be
  /// returned.
  ///@param data The scheme specific part that is being looked for.
  ///@return Returns true if the data string matches a scheme specific part listed in the
  ///         filter.
  bool hasDataSchemeSpecificPart(jni.JniString data) {
    final result__ = _hasDataSchemeSpecificPart(reference, data.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _schemeSpecificPartsIterator = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_schemeSpecificPartsIterator")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.Iterator<android.os.PatternMatcher> schemeSpecificPartsIterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an iterator over the filter's data scheme specific parts.
  jni.JniObject schemeSpecificPartsIterator() {
    final result__ =
        jni.JniObject.fromRef(_schemeSpecificPartsIterator(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _addDataAuthority = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_addDataAuthority")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void addDataAuthority(java.lang.String host, java.lang.String port)
  ///
  /// Add a new Intent data authority to match against.  The filter must
  /// include one or more schemes (via \#addDataScheme) for the
  /// authority to be considered.  If any authorities are
  /// included in the filter, then an Intent's data must match one of
  /// them.  If no authorities are included, then only the scheme must match.
  ///
  /// _Note: host name in the Android framework is
  /// case-sensitive, unlike formal RFC host names.  As a result,
  /// you should always write your host names with lower case letters,
  /// and any host names you receive from outside of Android should be
  /// converted to lower case before supplying them here._
  ///
  ///@param host The host part of the authority to match.  May start with a
  ///             single '*' to wildcard the front of the host name.
  ///@param port Optional port part of the authority to match.  If null, any
  ///             port is allowed.
  ///@see \#matchData
  ///@see \#addDataScheme
  void addDataAuthority(jni.JniString host, jni.JniString port) {
    final result__ =
        _addDataAuthority(reference, host.reference, port.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _countDataAuthorities =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_IntentFilter_countDataAuthorities")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int countDataAuthorities()
  ///
  /// Return the number of data authorities in the filter.
  int countDataAuthorities() {
    final result__ = _countDataAuthorities(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDataAuthority = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_IntentFilter_getDataAuthority")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final android.content.IntentFilter.AuthorityEntry getDataAuthority(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a data authority in the filter.
  IntentFilter_AuthorityEntry getDataAuthority(int index) {
    final result__ = IntentFilter_AuthorityEntry.fromRef(
        _getDataAuthority(reference, index));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hasDataAuthority = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_hasDataAuthority")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean hasDataAuthority(android.net.Uri data)
  ///
  /// Is the given data authority included in the filter?  Note that if the
  /// filter does not include any authorities, false will _always_ be
  /// returned.
  ///@param data The data whose authority is being looked for.
  ///@return Returns true if the data string matches an authority listed in the
  ///         filter.
  bool hasDataAuthority(jni.JniObject data) {
    final result__ = _hasDataAuthority(reference, data.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _authoritiesIterator = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_authoritiesIterator")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.Iterator<android.content.IntentFilter.AuthorityEntry> authoritiesIterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an iterator over the filter's data authorities.
  jni.JniObject authoritiesIterator() {
    final result__ = jni.JniObject.fromRef(_authoritiesIterator(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _addDataPath = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_IntentFilter_addDataPath")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void addDataPath(java.lang.String path, int type)
  ///
  /// Add a new Intent data path to match against.  The filter must
  /// include one or more schemes (via \#addDataScheme) _and_
  /// one or more authorities (via \#addDataAuthority) for the
  /// path to be considered.  If any paths are
  /// included in the filter, then an Intent's data must match one of
  /// them.  If no paths are included, then only the scheme/authority must
  /// match.
  ///
  /// The path given here can either be a literal that must directly
  /// match or match against a prefix, or it can be a simple globbing pattern.
  /// If the latter, you can use '*' anywhere in the pattern to match zero
  /// or more instances of the previous character, '.' as a wildcard to match
  /// any character, and '\' to escape the next character.
  ///@param path Either a raw string that must exactly match the file
  /// path, or a simple pattern, depending on <var>type</var>.
  ///@param type Determines how <var>path</var> will be compared to
  /// determine a match: either PatternMatcher\#PATTERN_LITERAL,
  /// PatternMatcher\#PATTERN_PREFIX, or
  /// PatternMatcher\#PATTERN_SIMPLE_GLOB.
  ///@see \#matchData
  ///@see \#addDataScheme
  ///@see \#addDataAuthority
  void addDataPath(jni.JniString path, int type) {
    final result__ = _addDataPath(reference, path.reference, type);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _countDataPaths =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_IntentFilter_countDataPaths")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int countDataPaths()
  ///
  /// Return the number of data paths in the filter.
  int countDataPaths() {
    final result__ = _countDataPaths(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDataPath = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_IntentFilter_getDataPath")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final android.os.PatternMatcher getDataPath(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a data path in the filter.
  os_.PatternMatcher getDataPath(int index) {
    final result__ = os_.PatternMatcher.fromRef(_getDataPath(reference, index));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hasDataPath = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_hasDataPath")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean hasDataPath(java.lang.String data)
  ///
  /// Is the given data path included in the filter?  Note that if the
  /// filter does not include any paths, false will _always_ be
  /// returned.
  ///@param data The data path to look for.  This is without the scheme
  ///             prefix.
  ///@return True if the data string matches a path listed in the
  ///         filter.
  bool hasDataPath(jni.JniString data) {
    final result__ = _hasDataPath(reference, data.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _pathsIterator = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_pathsIterator")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.Iterator<android.os.PatternMatcher> pathsIterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an iterator over the filter's data paths.
  jni.JniObject pathsIterator() {
    final result__ = jni.JniObject.fromRef(_pathsIterator(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _matchDataAuthority = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_matchDataAuthority")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final int matchDataAuthority(android.net.Uri data)
  ///
  /// Match this intent filter against the given Intent data.  This ignores
  /// the data scheme -- unlike \#matchData, the authority will match
  /// regardless of whether there is a matching scheme.
  ///@param data The data whose authority is being looked for.
  ///@return Returns either \#MATCH_CATEGORY_HOST,
  /// \#MATCH_CATEGORY_PORT, \#NO_MATCH_DATA.
  int matchDataAuthority(jni.JniObject data) {
    final result__ = _matchDataAuthority(reference, data.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _matchData = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_matchData")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final int matchData(java.lang.String type, java.lang.String scheme, android.net.Uri data)
  ///
  /// Match this filter against an Intent's data (type, scheme and path). If
  /// the filter does not specify any types and does not specify any
  /// schemes/paths, the match will only succeed if the intent does not
  /// also specify a type or data.  If the filter does not specify any schemes,
  /// it will implicitly match intents with no scheme, or the schemes "content:"
  /// or "file:" (basically performing a MIME-type only match).  If the filter
  /// does not specify any MIME types, the Intent also must not specify a MIME
  /// type.
  ///
  /// Be aware that to match against an authority, you must also specify a base
  /// scheme the authority is in.  To match against a data path, both a scheme
  /// and authority must be specified.  If the filter does not specify any
  /// types or schemes that it matches against, it is considered to be empty
  /// (any authority or data path given is ignored, as if it were empty as
  /// well).
  ///
  /// _Note: MIME type, Uri scheme, and host name matching in the
  /// Android framework is case-sensitive, unlike the formal RFC definitions.
  /// As a result, you should always write these elements with lower case letters,
  /// and normalize any MIME types or Uris you receive from
  /// outside of Android to ensure these elements are lower case before
  /// supplying them here._
  ///
  ///@param type The desired data type to look for, as returned by
  ///             Intent.resolveType().
  ///@param scheme The desired data scheme to look for, as returned by
  ///               Intent.getScheme().
  ///@param data The full data string to match against, as supplied in
  ///             Intent.data.
  ///@return Returns either a valid match constant (a combination of
  /// \#MATCH_CATEGORY_MASK and \#MATCH_ADJUSTMENT_MASK),
  /// or one of the error codes \#NO_MATCH_TYPE if the type didn't match
  /// or \#NO_MATCH_DATA if the scheme/path didn't match.
  ///@see \#match
  int matchData(jni.JniString type, jni.JniString scheme, jni.JniObject data) {
    final result__ =
        _matchData(reference, type.reference, scheme.reference, data.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _addCategory = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_addCategory")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void addCategory(java.lang.String category)
  ///
  /// Add a new Intent category to match against.  The semantics of
  /// categories is the opposite of actions -- an Intent includes the
  /// categories that it requires, all of which must be included in the
  /// filter in order to match.  In other words, adding a category to the
  /// filter has no impact on matching unless that category is specified in
  /// the intent.
  ///@param category Name of category to match, such as Intent.CATEGORY_EMBED.
  void addCategory(jni.JniString category) {
    final result__ = _addCategory(reference, category.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _countCategories =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_IntentFilter_countCategories")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int countCategories()
  ///
  /// Return the number of categories in the filter.
  int countCategories() {
    final result__ = _countCategories(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getCategory = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_IntentFilter_getCategory")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final java.lang.String getCategory(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a category in the filter.
  jni.JniString getCategory(int index) {
    final result__ = jni.JniString.fromRef(_getCategory(reference, index));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hasCategory = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_hasCategory")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean hasCategory(java.lang.String category)
  ///
  /// Is the given category included in the filter?
  ///@param category The category that the filter supports.
  ///@return True if the category is explicitly mentioned in the filter.
  bool hasCategory(jni.JniString category) {
    final result__ = _hasCategory(reference, category.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _categoriesIterator = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_categoriesIterator")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.Iterator<java.lang.String> categoriesIterator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an iterator over the filter's categories.
  ///@return Iterator if this filter has categories or {@code null} if none.
  jni.JniObject categoriesIterator() {
    final result__ = jni.JniObject.fromRef(_categoriesIterator(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _matchCategories = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_matchCategories")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String matchCategories(java.util.Set<java.lang.String> categories)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Match this filter against an Intent's categories.  Each category in
  /// the Intent must be specified by the filter; if any are not in the
  /// filter, the match fails.
  ///@param categories The categories included in the intent, as returned by
  ///                   Intent.getCategories().
  ///@return If all categories match (success), null; else the name of the
  ///         first category that didn't match.
  jni.JniString matchCategories(jni.JniObject categories) {
    final result__ = jni.JniString.fromRef(
        _matchCategories(reference, categories.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _match = jniLookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Pointer<ffi.Void>)>>("android_content_IntentFilter_match")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final int match(android.content.ContentResolver resolver, android.content.Intent intent, boolean resolve, java.lang.String logTag)
  ///
  /// Test whether this filter matches the given <var>intent</var>.
  ///@param intent The Intent to compare against.
  ///@param resolve If true, the intent's type will be resolved by calling
  ///                Intent.resolveType(); otherwise a simple match against
  ///                Intent.type will be performed.
  ///@param logTag Tag to use in debugging messages.
  ///@return Returns either a valid match constant (a combination of
  /// \#MATCH_CATEGORY_MASK and \#MATCH_ADJUSTMENT_MASK),
  /// or one of the error codes \#NO_MATCH_TYPE if the type didn't match,
  /// \#NO_MATCH_DATA if the scheme/path didn't match,
  /// \#NO_MATCH_ACTION if the action didn't match, or
  /// \#NO_MATCH_CATEGORY if one or more categories didn't match.
  ///@see \#match(String, String, String, android.net.Uri , Set, String)
  int match(ContentResolver resolver, Intent intent, bool resolve,
      jni.JniString logTag) {
    final result__ = _match(reference, resolver.reference, intent.reference,
        resolve ? 1 : 0, logTag.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _match1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_match1")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final int match(java.lang.String action, java.lang.String type, java.lang.String scheme, android.net.Uri data, java.util.Set<java.lang.String> categories, java.lang.String logTag)
  ///
  /// Test whether this filter matches the given intent data.  A match is
  /// only successful if the actions and categories in the Intent match
  /// against the filter, as described in IntentFilter; in that case,
  /// the match result returned will be as per \#matchData.
  ///@param action The intent action to match against (Intent.getAction).
  ///@param type The intent type to match against (Intent.resolveType()).
  ///@param scheme The data scheme to match against (Intent.getScheme()).
  ///@param data The data URI to match against (Intent.getData()).
  ///@param categories The categories to match against
  ///                   (Intent.getCategories()).
  ///@param logTag Tag to use in debugging messages.
  ///@return Returns either a valid match constant (a combination of
  /// \#MATCH_CATEGORY_MASK and \#MATCH_ADJUSTMENT_MASK),
  /// or one of the error codes \#NO_MATCH_TYPE if the type didn't match,
  /// \#NO_MATCH_DATA if the scheme/path didn't match,
  /// \#NO_MATCH_ACTION if the action didn't match, or
  /// \#NO_MATCH_CATEGORY if one or more categories didn't match.
  ///@see \#matchData
  ///@see Intent\#getAction
  ///@see Intent\#resolveType
  ///@see Intent\#getScheme
  ///@see Intent\#getData
  ///@see Intent\#getCategories
  int match1(jni.JniString action, jni.JniString type, jni.JniString scheme,
      jni.JniObject data, jni.JniObject categories, jni.JniString logTag) {
    final result__ = _match1(
        reference,
        action.reference,
        type.reference,
        scheme.reference,
        data.reference,
        categories.reference,
        logTag.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToXml = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_writeToXml")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeToXml(org.xmlpull.v1.XmlSerializer serializer)
  ///
  /// Write the contents of the IntentFilter as an XML stream.
  void writeToXml(jni.JniObject serializer) {
    final result__ = _writeToXml(reference, serializer.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _readFromXml = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter_readFromXml")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromXml(org.xmlpull.v1.XmlPullParser parser)
  void readFromXml(jni.JniObject parser) {
    final result__ = _readFromXml(reference, parser.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _dump = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_IntentFilter_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer du, java.lang.String prefix)
  void dump(jni.JniObject du, jni.JniString prefix) {
    final result__ = _dump(reference, du.reference, prefix.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_IntentFilter_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_IntentFilter_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) {
    final result__ = _writeToParcel(reference, dest.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.IntentFilter$MalformedMimeTypeException
///
/// This exception is thrown when a given MIME type does not have a valid
/// syntax.
class IntentFilter_MalformedMimeTypeException extends jni.JniObject {
  IntentFilter_MalformedMimeTypeException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_IntentFilter__MalformedMimeTypeException_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  IntentFilter_MalformedMimeTypeException() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter__MalformedMimeTypeException_ctor1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String name)
  IntentFilter_MalformedMimeTypeException.ctor1(jni.JniString name)
      : super.fromRef(_ctor1(name.reference)) {
    jni.Jni.env.checkException();
  }
}

/// from: android.content.IntentFilter$AuthorityEntry
///
/// This is an entry for a single authority in the Iterator returned by
/// \#authoritiesIterator().
class IntentFilter_AuthorityEntry extends jni.JniObject {
  IntentFilter_AuthorityEntry.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter__AuthorityEntry_ctor")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String host, java.lang.String port)
  IntentFilter_AuthorityEntry(jni.JniString host, jni.JniString port)
      : super.fromRef(_ctor(host.reference, port.reference)) {
    jni.Jni.env.checkException();
  }

  static final _getHost = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter__AuthorityEntry_getHost")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getHost()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getHost() {
    final result__ = jni.JniString.fromRef(_getHost(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPort =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_IntentFilter__AuthorityEntry_getPort")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getPort()
  int getPort() {
    final result__ = _getPort(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _equals1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter__AuthorityEntry_equals1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object obj)
  bool equals1(jni.JniObject obj) {
    final result__ = _equals1(reference, obj.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _match = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentFilter__AuthorityEntry_match")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int match(android.net.Uri data)
  ///
  /// Determine whether this AuthorityEntry matches the given data Uri.
  /// _Note that this comparison is case-sensitive, unlike formal
  /// RFC host names.  You thus should always normalize to lower-case._
  ///@param data The Uri to match.
  ///@return Returns either IntentFilter\#NO_MATCH_DATA,
  /// IntentFilter\#MATCH_CATEGORY_PORT, or
  /// IntentFilter\#MATCH_CATEGORY_HOST.
  int match(jni.JniObject data) {
    final result__ = _match(reference, data.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.SyncRequest
///
/// Convenience class to construct sync requests. See android.content.SyncRequest.Builder
/// for an explanation of the various functions. The resulting object is passed through to the
/// framework via android.content.ContentResolver\#requestSync(SyncRequest).
class SyncRequest extends jni.JniObject {
  SyncRequest.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_SyncRequest_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.SyncRequest> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_SyncRequest_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Parcel in)
  SyncRequest(os_.Parcel in0) : super.fromRef(_ctor(in0.reference)) {
    jni.Jni.env.checkException();
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SyncRequest_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_SyncRequest_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  void writeToParcel(os_.Parcel parcel, int flags) {
    final result__ = _writeToParcel(reference, parcel.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.SyncRequest$Builder
///
/// Builder class for a SyncRequest. As you build your SyncRequest this class will also
/// perform validation.
class SyncRequest_Builder extends jni.JniObject {
  SyncRequest_Builder.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_SyncRequest__Builder_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  SyncRequest_Builder() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _syncOnce = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_SyncRequest__Builder_syncOnce")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.SyncRequest.Builder syncOnce()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Request that a sync occur immediately.
  ///
  /// Example
  /// <pre>
  ///     SyncRequest.Builder builder = (new SyncRequest.Builder()).syncOnce();
  /// </pre>
  SyncRequest_Builder syncOnce() {
    final result__ = SyncRequest_Builder.fromRef(_syncOnce(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _syncPeriodic = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int64, ffi.Int64)>>(
          "android_content_SyncRequest__Builder_syncPeriodic")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.content.SyncRequest.Builder syncPeriodic(long pollFrequency, long beforeSeconds)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Build a periodic sync. Either this or syncOnce() __must__ be called for this builder.
  /// Syncs are identified by target android.provider and by the
  /// contents of the extras bundle.
  /// You cannot reuse the same builder for one-time syncs after having specified a periodic
  /// sync (by calling this function). If you do, an <code>IllegalArgumentException</code>
  /// will be thrown.
  /// The bundle for a periodic sync can be queried by applications with the correct
  /// permissions using
  /// ContentResolver\#getPeriodicSyncs(Account account, String provider), so no
  /// sensitive data should be transferred here.
  ///
  /// Example usage.
  ///
  /// <pre>
  ///     Request a periodic sync every 5 hours with 20 minutes of flex.
  ///     SyncRequest.Builder builder =
  ///         (new SyncRequest.Builder()).syncPeriodic(5 * HOUR_IN_SECS, 20 * MIN_IN_SECS);
  ///
  ///     Schedule a periodic sync every hour at any point in time during that hour.
  ///     SyncRequest.Builder builder =
  ///         (new SyncRequest.Builder()).syncPeriodic(1 * HOUR_IN_SECS, 1 * HOUR_IN_SECS);
  /// </pre>
  ///
  /// N.B.: Periodic syncs are not allowed to have any of
  /// ContentResolver\#SYNC_EXTRAS_DO_NOT_RETRY,
  /// ContentResolver\#SYNC_EXTRAS_IGNORE_BACKOFF,
  /// ContentResolver\#SYNC_EXTRAS_IGNORE_SETTINGS,
  /// ContentResolver\#SYNC_EXTRAS_INITIALIZE,
  /// ContentResolver\#SYNC_EXTRAS_FORCE,
  /// ContentResolver\#SYNC_EXTRAS_EXPEDITED,
  /// ContentResolver\#SYNC_EXTRAS_MANUAL
  /// set to true. If any are supplied then an <code>IllegalArgumentException</code> will
  /// be thrown.
  ///@param pollFrequency the amount of time in seconds that you wish
  ///            to elapse between periodic syncs. A minimum period of 1 hour is enforced.
  ///@param beforeSeconds the amount of flex time in seconds before
  ///            {@code pollFrequency} that you permit for the sync to take
  ///            place. Must be less than {@code pollFrequency} and greater than
  ///            MAX(5% of {@code pollFrequency}, 5 minutes)
  SyncRequest_Builder syncPeriodic(int pollFrequency, int beforeSeconds) {
    final result__ = SyncRequest_Builder.fromRef(
        _syncPeriodic(reference, pollFrequency, beforeSeconds));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setDisallowMetered = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_content_SyncRequest__Builder_setDisallowMetered")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.SyncRequest.Builder setDisallowMetered(boolean disallow)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Will throw an <code>IllegalArgumentException</code> if called and
  /// \#setIgnoreSettings(boolean ignoreSettings) has already been called.
  ///@param disallow true to allow this transfer on metered networks. Default false.
  SyncRequest_Builder setDisallowMetered(bool disallow) {
    final result__ = SyncRequest_Builder.fromRef(
        _setDisallowMetered(reference, disallow ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setRequiresCharging = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_content_SyncRequest__Builder_setRequiresCharging")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.SyncRequest.Builder setRequiresCharging(boolean requiresCharging)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify whether the sync requires the phone to be plugged in.
  ///@param requiresCharging true if sync requires the phone to be plugged in. Default false.
  SyncRequest_Builder setRequiresCharging(bool requiresCharging) {
    final result__ = SyncRequest_Builder.fromRef(
        _setRequiresCharging(reference, requiresCharging ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setSyncAdapter = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_SyncRequest__Builder_setSyncAdapter")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.SyncRequest.Builder setSyncAdapter(android.accounts.Account account, java.lang.String authority)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify an authority and account for this transfer.
  ///@param authority A String identifying the content provider to be synced.
  ///@param account Account to sync. Can be null unless this is a periodic
  ///            sync, for which verification by the ContentResolver will
  ///            fail. If a sync is performed without an account, the
  SyncRequest_Builder setSyncAdapter(
      jni.JniObject account, jni.JniString authority) {
    final result__ = SyncRequest_Builder.fromRef(
        _setSyncAdapter(reference, account.reference, authority.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setExtras = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_SyncRequest__Builder_setExtras")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.SyncRequest.Builder setExtras(android.os.Bundle bundle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Developer-provided extras handed back when sync actually occurs. This bundle is copied
  /// into the SyncRequest returned by \#build().
  ///
  /// Example:
  /// <pre>
  ///   String[] syncItems = {"dog", "cat", "frog", "child"};
  ///   SyncRequest.Builder builder =
  ///     new SyncRequest.Builder()
  ///       .setSyncAdapter(dummyAccount, dummyProvider)
  ///       .syncOnce();
  ///
  ///   for (String syncData : syncItems) {
  ///     Bundle extras = new Bundle();
  ///     extras.setString("data", syncData);
  ///     builder.setExtras(extras);
  ///     ContentResolver.sync(builder.build()); // Each sync() request creates a unique sync.
  ///   }
  /// </pre>
  /// Only values of the following types may be used in the extras bundle:
  /// <ul>
  /// <li>Integer</li>
  /// <li>Long</li>
  /// <li>Boolean</li>
  /// <li>Float</li>
  /// <li>Double</li>
  /// <li>String</li>
  /// <li>Account</li>
  /// <li>null</li>
  /// </ul>
  /// If any data is present in the bundle not of this type, build() will
  /// throw a runtime exception.
  ///@param bundle extras bundle to set.
  SyncRequest_Builder setExtras(os_.Bundle bundle) {
    final result__ =
        SyncRequest_Builder.fromRef(_setExtras(reference, bundle.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setNoRetry = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_content_SyncRequest__Builder_setNoRetry")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.SyncRequest.Builder setNoRetry(boolean noRetry)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience function for setting ContentResolver\#SYNC_EXTRAS_DO_NOT_RETRY.
  ///
  /// A one-off sync operation that fails will be retried with exponential back-off unless
  /// this is set to false. Not valid for periodic sync and will throw an
  /// <code>IllegalArgumentException</code> in build().
  ///@param noRetry true to not retry a failed sync. Default false.
  SyncRequest_Builder setNoRetry(bool noRetry) {
    final result__ =
        SyncRequest_Builder.fromRef(_setNoRetry(reference, noRetry ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setIgnoreSettings = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_content_SyncRequest__Builder_setIgnoreSettings")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.SyncRequest.Builder setIgnoreSettings(boolean ignoreSettings)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience function for setting ContentResolver\#SYNC_EXTRAS_IGNORE_SETTINGS.
  ///
  /// Not valid for periodic sync and will throw an <code>IllegalArgumentException</code> in
  /// \#build().
  /// Throws <code>IllegalArgumentException</code> if called and
  /// \#setDisallowMetered(boolean) has been set.
  ///@param ignoreSettings true to ignore the sync automatically settings. Default false.
  SyncRequest_Builder setIgnoreSettings(bool ignoreSettings) {
    final result__ = SyncRequest_Builder.fromRef(
        _setIgnoreSettings(reference, ignoreSettings ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setIgnoreBackoff = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_content_SyncRequest__Builder_setIgnoreBackoff")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.SyncRequest.Builder setIgnoreBackoff(boolean ignoreBackoff)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience function for setting ContentResolver\#SYNC_EXTRAS_IGNORE_BACKOFF.
  ///
  /// Ignoring back-off will force the sync scheduling process to ignore any back-off that was
  /// the result of a failed sync, as well as to invalidate any SyncResult\#delayUntil
  /// value that may have been set by the adapter. Successive failures will not honor this
  /// flag. Not valid for periodic sync and will throw an <code>IllegalArgumentException</code>
  /// in \#build().
  ///@param ignoreBackoff ignore back off settings. Default false.
  SyncRequest_Builder setIgnoreBackoff(bool ignoreBackoff) {
    final result__ = SyncRequest_Builder.fromRef(
        _setIgnoreBackoff(reference, ignoreBackoff ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setManual = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_content_SyncRequest__Builder_setManual")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.SyncRequest.Builder setManual(boolean isManual)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience function for setting ContentResolver\#SYNC_EXTRAS_MANUAL.
  ///
  /// Not valid for periodic sync and will throw an <code>IllegalArgumentException</code> in
  /// \#build().
  ///@param isManual User-initiated sync or not. Default false.
  SyncRequest_Builder setManual(bool isManual) {
    final result__ =
        SyncRequest_Builder.fromRef(_setManual(reference, isManual ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setExpedited = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_content_SyncRequest__Builder_setExpedited")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.SyncRequest.Builder setExpedited(boolean expedited)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// An expedited sync runs immediately and can preempt other non-expedited running syncs.
  ///
  /// Not valid for periodic sync and will throw an <code>IllegalArgumentException</code> in
  /// \#build().
  ///@param expedited whether to run expedited. Default false.
  SyncRequest_Builder setExpedited(bool expedited) {
    final result__ = SyncRequest_Builder.fromRef(
        _setExpedited(reference, expedited ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _build = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_SyncRequest__Builder_build")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.SyncRequest build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Performs validation over the request and throws the runtime exception
  /// <code>IllegalArgumentException</code> if this validation fails.
  ///@return a SyncRequest with the information contained within this
  ///         builder.
  SyncRequest build() {
    final result__ = SyncRequest.fromRef(_build(reference));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.SharedPreferences
///
/// Interface for accessing and modifying preference data returned by Context\#getSharedPreferences.  For any particular set of preferences,
/// there is a single instance of this class that all clients share.
/// Modifications to the preferences must go through an Editor object
/// to ensure the preference values remain in a consistent state and control
/// when they are committed to storage.  Objects that are returned from the
/// various <code>get</code> methods must be treated as immutable by the application.
///
/// Note: This class provides strong consistency guarantees. It is using expensive operations
/// which might slow down an app. Frequently changing properties or properties where loss can be
/// tolerated should use other mechanisms. For more details read the comments on
/// Editor\#commit() and Editor\#apply().
///
/// _Note: This class does not support use across multiple processes._
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using SharedPreferences, read the
/// <a href="{@docRoot}guide/topics/data/data-storage.html\#pref">Data Storage</a>
/// developer guide.
///</div>
///@see Context\#getSharedPreferences
class SharedPreferences extends jni.JniObject {
  SharedPreferences.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _getAll = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_SharedPreferences_getAll")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.util.Map<java.lang.String,?> getAll()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve all values from the preferences.
  ///
  /// Note that you _must not_ modify the collection returned
  /// by this method, or alter any of its contents.  The consistency of your
  /// stored data is not guaranteed if you do.
  ///@return Returns a map containing a list of pairs key/value representing
  /// the preferences.
  ///@throws NullPointerException
  jni.JniObject getAll() {
    final result__ = jni.JniObject.fromRef(_getAll(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getString = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_SharedPreferences_getString")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getString(java.lang.String key, java.lang.String defValue)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a String value from the preferences.
  ///@param key The name of the preference to retrieve.
  ///@param defValue Value to return if this preference does not exist.
  ///
  /// This value may be {@code null}.
  ///@return Returns the preference value if it exists, or defValue.  Throws
  /// ClassCastException if there is a preference with this name that is not
  /// a String.
  ///
  /// This value may be {@code null}.
  ///@throws ClassCastException
  jni.JniString getString(jni.JniString key, jni.JniString defValue) {
    final result__ = jni.JniString.fromRef(
        _getString(reference, key.reference, defValue.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getStringSet = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_SharedPreferences_getStringSet")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.util.Set<java.lang.String> getStringSet(java.lang.String key, java.util.Set<java.lang.String> defValues)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a set of String values from the preferences.
  ///
  /// Note that you _must not_ modify the set instance returned
  /// by this call.  The consistency of the stored data is not guaranteed
  /// if you do, nor is your ability to modify the instance at all.
  ///@param key The name of the preference to retrieve.
  ///@param defValues Values to return if this preference does not exist.
  ///
  /// This value may be {@code null}.
  ///@return Returns the preference values if they exist, or defValues.
  /// Throws ClassCastException if there is a preference with this name
  /// that is not a Set.
  ///
  /// This value may be {@code null}.
  ///@throws ClassCastException
  jni.JniObject getStringSet(jni.JniString key, jni.JniObject defValues) {
    final result__ = jni.JniObject.fromRef(
        _getStringSet(reference, key.reference, defValues.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getInt = jniLookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_SharedPreferences_getInt")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract int getInt(java.lang.String key, int defValue)
  ///
  /// Retrieve an int value from the preferences.
  ///@param key The name of the preference to retrieve.
  ///@param defValue Value to return if this preference does not exist.
  ///@return Returns the preference value if it exists, or defValue.  Throws
  /// ClassCastException if there is a preference with this name that is not
  /// an int.
  ///@throws ClassCastException
  int getInt(jni.JniString key, int defValue) {
    final result__ = _getInt(reference, key.reference, defValue);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getLong = jniLookup<
          ffi.NativeFunction<
              ffi.Int64 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_content_SharedPreferences_getLong")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract long getLong(java.lang.String key, long defValue)
  ///
  /// Retrieve a long value from the preferences.
  ///@param key The name of the preference to retrieve.
  ///@param defValue Value to return if this preference does not exist.
  ///@return Returns the preference value if it exists, or defValue.  Throws
  /// ClassCastException if there is a preference with this name that is not
  /// a long.
  ///@throws ClassCastException
  int getLong(jni.JniString key, int defValue) {
    final result__ = _getLong(reference, key.reference, defValue);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getFloat = jniLookup<
          ffi.NativeFunction<
              ffi.Float Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("android_content_SharedPreferences_getFloat")
      .asFunction<
          double Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, double)>();

  /// from: public abstract float getFloat(java.lang.String key, float defValue)
  ///
  /// Retrieve a float value from the preferences.
  ///@param key The name of the preference to retrieve.
  ///@param defValue Value to return if this preference does not exist.
  ///@return Returns the preference value if it exists, or defValue.  Throws
  /// ClassCastException if there is a preference with this name that is not
  /// a float.
  ///@throws ClassCastException
  double getFloat(jni.JniString key, double defValue) {
    final result__ = _getFloat(reference, key.reference, defValue);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getBoolean = jniLookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_content_SharedPreferences_getBoolean")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract boolean getBoolean(java.lang.String key, boolean defValue)
  ///
  /// Retrieve a boolean value from the preferences.
  ///@param key The name of the preference to retrieve.
  ///@param defValue Value to return if this preference does not exist.
  ///@return Returns the preference value if it exists, or defValue.  Throws
  /// ClassCastException if there is a preference with this name that is not
  /// a boolean.
  ///@throws ClassCastException
  bool getBoolean(jni.JniString key, bool defValue) {
    final result__ =
        _getBoolean(reference, key.reference, defValue ? 1 : 0) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _contains = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_SharedPreferences_contains")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean contains(java.lang.String key)
  ///
  /// Checks whether the preferences contains a preference.
  ///@param key The name of the preference to check.
  ///@return Returns true if the preference exists in the preferences,
  ///         otherwise false.
  bool contains(jni.JniString key) {
    final result__ = _contains(reference, key.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _edit = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_SharedPreferences_edit")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.SharedPreferences.Editor edit()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new Editor for these preferences, through which you can make
  /// modifications to the data in the preferences and atomically commit those
  /// changes back to the SharedPreferences object.
  ///
  /// Note that you _must_ call Editor\#commit to have any
  /// changes you perform in the Editor actually show up in the
  /// SharedPreferences.
  ///@return Returns a new instance of the Editor interface, allowing
  /// you to modify the values in this SharedPreferences object.
  SharedPreferences_Editor edit() {
    final result__ = SharedPreferences_Editor.fromRef(_edit(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _registerOnSharedPreferenceChangeListener = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_SharedPreferences_registerOnSharedPreferenceChangeListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void registerOnSharedPreferenceChangeListener(android.content.SharedPreferences.OnSharedPreferenceChangeListener listener)
  ///
  /// Registers a callback to be invoked when a change happens to a preference.
  ///
  /// <p class="caution"><strong>Caution:</strong> The preference manager does
  /// not currently store a strong reference to the listener. You must store a
  /// strong reference to the listener, or it will be susceptible to garbage
  /// collection. We recommend you keep a reference to the listener in the
  /// instance data of an object that will exist as long as you need the
  /// listener.
  ///
  ///@param listener The callback that will run.
  ///@see \#unregisterOnSharedPreferenceChangeListener
  void registerOnSharedPreferenceChangeListener(
      SharedPreferences_OnSharedPreferenceChangeListener listener) {
    final result__ = _registerOnSharedPreferenceChangeListener(
        reference, listener.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _unregisterOnSharedPreferenceChangeListener = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_SharedPreferences_unregisterOnSharedPreferenceChangeListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void unregisterOnSharedPreferenceChangeListener(android.content.SharedPreferences.OnSharedPreferenceChangeListener listener)
  ///
  /// Unregisters a previous callback.
  ///@param listener The callback that should be unregistered.
  ///@see \#registerOnSharedPreferenceChangeListener
  void unregisterOnSharedPreferenceChangeListener(
      SharedPreferences_OnSharedPreferenceChangeListener listener) {
    final result__ = _unregisterOnSharedPreferenceChangeListener(
        reference, listener.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.SharedPreferences$OnSharedPreferenceChangeListener
///
/// Interface definition for a callback to be invoked when a shared
/// preference is changed.
class SharedPreferences_OnSharedPreferenceChangeListener extends jni.JniObject {
  SharedPreferences_OnSharedPreferenceChangeListener.fromRef(
      ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onSharedPreferenceChanged = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_SharedPreferences__OnSharedPreferenceChangeListener_onSharedPreferenceChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onSharedPreferenceChanged(android.content.SharedPreferences sharedPreferences, java.lang.String key)
  ///
  /// Called when a shared preference is changed, added, or removed. This
  /// may be called even if a preference is set to its existing value.
  ///
  /// This callback will be run on your main thread.
  ///@param sharedPreferences The SharedPreferences that received
  ///            the change.
  ///@param key The key of the preference that was changed, added, or
  ///            removed.
  void onSharedPreferenceChanged(
      SharedPreferences sharedPreferences, jni.JniString key) {
    final result__ = _onSharedPreferenceChanged(
        reference, sharedPreferences.reference, key.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.SharedPreferences$Editor
///
/// Interface used for modifying values in a SharedPreferences
/// object.  All changes you make in an editor are batched, and not copied
/// back to the original SharedPreferences until you call \#commit
/// or \#apply
class SharedPreferences_Editor extends jni.JniObject {
  SharedPreferences_Editor.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _putString = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_SharedPreferences__Editor_putString")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.SharedPreferences.Editor putString(java.lang.String key, java.lang.String value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a String value in the preferences editor, to be written back once
  /// \#commit or \#apply are called.
  ///@param key The name of the preference to modify.
  ///@param value The new value for the preference.  Passing {@code null}
  ///    for this argument is equivalent to calling \#remove(String) with
  ///    this key.
  ///
  /// This value may be {@code null}.
  ///@return Returns a reference to the same Editor object, so you can
  /// chain put calls together.
  SharedPreferences_Editor putString(jni.JniString key, jni.JniString value) {
    final result__ = SharedPreferences_Editor.fromRef(
        _putString(reference, key.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putStringSet = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_SharedPreferences__Editor_putStringSet")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.SharedPreferences.Editor putStringSet(java.lang.String key, java.util.Set<java.lang.String> values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a set of String values in the preferences editor, to be written
  /// back once \#commit or \#apply is called.
  ///@param key The name of the preference to modify.
  ///@param values The set of new values for the preference.  Passing {@code null}
  ///    for this argument is equivalent to calling \#remove(String) with
  ///    this key.
  /// This value may be {@code null}.
  ///@return Returns a reference to the same Editor object, so you can
  /// chain put calls together.
  SharedPreferences_Editor putStringSet(
      jni.JniString key, jni.JniObject values) {
    final result__ = SharedPreferences_Editor.fromRef(
        _putStringSet(reference, key.reference, values.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putInt = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_SharedPreferences__Editor_putInt")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.SharedPreferences.Editor putInt(java.lang.String key, int value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set an int value in the preferences editor, to be written back once
  /// \#commit or \#apply are called.
  ///@param key The name of the preference to modify.
  ///@param value The new value for the preference.
  ///@return Returns a reference to the same Editor object, so you can
  /// chain put calls together.
  SharedPreferences_Editor putInt(jni.JniString key, int value) {
    final result__ = SharedPreferences_Editor.fromRef(
        _putInt(reference, key.reference, value));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putLong = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "android_content_SharedPreferences__Editor_putLong")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.SharedPreferences.Editor putLong(java.lang.String key, long value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a long value in the preferences editor, to be written back once
  /// \#commit or \#apply are called.
  ///@param key The name of the preference to modify.
  ///@param value The new value for the preference.
  ///@return Returns a reference to the same Editor object, so you can
  /// chain put calls together.
  SharedPreferences_Editor putLong(jni.JniString key, int value) {
    final result__ = SharedPreferences_Editor.fromRef(
        _putLong(reference, key.reference, value));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putFloat = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Float)>>(
          "android_content_SharedPreferences__Editor_putFloat")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, double)>();

  /// from: public abstract android.content.SharedPreferences.Editor putFloat(java.lang.String key, float value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a float value in the preferences editor, to be written back once
  /// \#commit or \#apply are called.
  ///@param key The name of the preference to modify.
  ///@param value The new value for the preference.
  ///@return Returns a reference to the same Editor object, so you can
  /// chain put calls together.
  SharedPreferences_Editor putFloat(jni.JniString key, double value) {
    final result__ = SharedPreferences_Editor.fromRef(
        _putFloat(reference, key.reference, value));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putBoolean = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_content_SharedPreferences__Editor_putBoolean")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.SharedPreferences.Editor putBoolean(java.lang.String key, boolean value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a boolean value in the preferences editor, to be written back
  /// once \#commit or \#apply are called.
  ///@param key The name of the preference to modify.
  ///@param value The new value for the preference.
  ///@return Returns a reference to the same Editor object, so you can
  /// chain put calls together.
  SharedPreferences_Editor putBoolean(jni.JniString key, bool value) {
    final result__ = SharedPreferences_Editor.fromRef(
        _putBoolean(reference, key.reference, value ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _remove = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_SharedPreferences__Editor_remove")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.SharedPreferences.Editor remove(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Mark in the editor that a preference value should be removed, which
  /// will be done in the actual preferences once \#commit is
  /// called.
  ///
  /// Note that when committing back to the preferences, all removals
  /// are done first, regardless of whether you called remove before
  /// or after put methods on this editor.
  ///@param key The name of the preference to remove.
  ///@return Returns a reference to the same Editor object, so you can
  /// chain put calls together.
  SharedPreferences_Editor remove(jni.JniString key) {
    final result__ =
        SharedPreferences_Editor.fromRef(_remove(reference, key.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _clear = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_SharedPreferences__Editor_clear")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.SharedPreferences.Editor clear()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Mark in the editor to remove _all_ values from the
  /// preferences.  Once commit is called, the only remaining preferences
  /// will be any that you have defined in this editor.
  ///
  /// Note that when committing back to the preferences, the clear
  /// is done first, regardless of whether you called clear before
  /// or after put methods on this editor.
  ///@return Returns a reference to the same Editor object, so you can
  /// chain put calls together.
  SharedPreferences_Editor clear() {
    final result__ = SharedPreferences_Editor.fromRef(_clear(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _commit =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SharedPreferences__Editor_commit")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean commit()
  ///
  /// Commit your preferences changes back from this Editor to the
  /// SharedPreferences object it is editing.  This atomically
  /// performs the requested modifications, replacing whatever is currently
  /// in the SharedPreferences.
  ///
  /// Note that when two editors are modifying preferences at the same
  /// time, the last one to call commit wins.
  ///
  /// If you don't care about the return value and you're
  /// using this from your application's main thread, consider
  /// using \#apply instead.
  ///@return Returns true if the new values were successfully written
  /// to persistent storage.
  bool commit() {
    final result__ = _commit(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _apply =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SharedPreferences__Editor_apply")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void apply()
  ///
  /// Commit your preferences changes back from this Editor to the
  /// SharedPreferences object it is editing.  This atomically
  /// performs the requested modifications, replacing whatever is currently
  /// in the SharedPreferences.
  ///
  /// Note that when two editors are modifying preferences at the same
  /// time, the last one to call apply wins.
  ///
  /// Unlike \#commit, which writes its preferences out
  /// to persistent storage synchronously, \#apply
  /// commits its changes to the in-memory
  /// SharedPreferences immediately but starts an
  /// asynchronous commit to disk and you won't be notified of
  /// any failures.  If another editor on this
  /// SharedPreferences does a regular \#commit
  /// while a \#apply is still outstanding, the
  /// \#commit will block until all async commits are
  /// completed as well as the commit itself.
  ///
  /// As SharedPreferences instances are singletons within
  /// a process, it's safe to replace any instance of \#commit with
  /// \#apply if you were already ignoring the return value.
  ///
  /// You don't need to worry about Android component
  /// lifecycles and their interaction with <code>apply()</code>
  /// writing to disk.  The framework makes sure in-flight disk
  /// writes from <code>apply()</code> complete before switching
  /// states.
  ///
  /// <p class='note'>The SharedPreferences.Editor interface
  /// isn't expected to be implemented directly.  However, if you
  /// previously did implement it and are now getting errors
  /// about missing <code>apply()</code>, you can simply call
  /// \#commit from <code>apply()</code>.
  void apply() {
    final result__ = _apply(reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.UriPermission
///
/// Description of a single Uri permission grant. This grants may have been
/// created via Intent\#FLAG_GRANT_READ_URI_PERMISSION, etc when sending
/// an Intent, or explicitly through
/// Context\#grantUriPermission(String, android.net.Uri, int).
///@see ContentResolver\#getPersistedUriPermissions()
class UriPermission extends jni.JniObject {
  UriPermission.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_UriPermission_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.UriPermission> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  /// from: static public final long INVALID_TIME
  ///
  /// Value returned when a permission has not been persisted.
  static const INVALID_TIME = -9223372036854775808;

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_UriPermission_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Parcel in)
  ///
  /// {@hide }
  UriPermission(os_.Parcel in0) : super.fromRef(_ctor(in0.reference)) {
    jni.Jni.env.checkException();
  }

  static final _getUri = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_UriPermission_getUri")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri getUri()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Uri this permission pertains to.
  jni.JniObject getUri() {
    final result__ = jni.JniObject.fromRef(_getUri(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isReadPermission =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_UriPermission_isReadPermission")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isReadPermission()
  ///
  /// Returns if this permission offers read access.
  bool isReadPermission() {
    final result__ = _isReadPermission(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isWritePermission =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_UriPermission_isWritePermission")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isWritePermission()
  ///
  /// Returns if this permission offers write access.
  bool isWritePermission() {
    final result__ = _isWritePermission(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPersistedTime =
      jniLookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_UriPermission_getPersistedTime")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getPersistedTime()
  ///
  /// Return the time when this permission was first persisted, in milliseconds
  /// since January 1, 1970 00:00:00.0 UTC. Returns \#INVALID_TIME if
  /// not persisted.
  ///@see ContentResolver\#takePersistableUriPermission(Uri, int)
  ///@see System\#currentTimeMillis()
  int getPersistedTime() {
    final result__ = _getPersistedTime(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_UriPermission_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_UriPermission_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_UriPermission_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) {
    final result__ = _writeToParcel(reference, dest.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.RestrictionEntry
///
/// Applications can expose restrictions for a restricted user on a
/// multiuser device. The administrator can configure these restrictions that will then be
/// applied to the restricted user. Each RestrictionsEntry is one configurable restriction.
/// <p/>
/// Any application that chooses to expose such restrictions does so by implementing a
/// receiver that handles the Intent\#ACTION_GET_RESTRICTION_ENTRIES action.
/// The receiver then returns a result bundle that contains an entry called "restrictions", whose
/// value is an ArrayList<RestrictionsEntry>.
class RestrictionEntry extends jni.JniObject {
  RestrictionEntry.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_RestrictionEntry_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.RestrictionEntry> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  /// from: static public final int TYPE_BOOLEAN
  ///
  /// Restriction of type "bool". Use this for storing a boolean value, typically presented as
  /// a checkbox in the UI.
  static const TYPE_BOOLEAN = 1;

  /// from: static public final int TYPE_BUNDLE
  ///
  /// Restriction of type "bundle". Use this for storing android.os.Bundle bundles of
  /// restrictions
  static const TYPE_BUNDLE = 7;

  /// from: static public final int TYPE_BUNDLE_ARRAY
  ///
  /// Restriction of type "bundle_array". Use this for storing arrays of
  /// android.os.Bundle bundles of restrictions
  static const TYPE_BUNDLE_ARRAY = 8;

  /// from: static public final int TYPE_CHOICE
  ///
  /// Restriction of type "choice". Use this for storing a string value, typically presented as
  /// a single-select list. Call \#setChoiceEntries(String[]) and
  /// \#setChoiceValues(String[]) to set the localized list entries to present to the user
  /// and the corresponding values, respectively.
  static const TYPE_CHOICE = 2;

  /// from: static public final int TYPE_INTEGER
  ///
  /// Restriction of type "integer". Use this for storing an integer value. The range of values
  /// is from Integer\#MIN_VALUE to Integer\#MAX_VALUE.
  static const TYPE_INTEGER = 5;

  /// from: static public final int TYPE_MULTI_SELECT
  ///
  /// Restriction of type "multi-select". Use this for presenting a multi-select list where more
  /// than one entry can be selected, such as for choosing specific titles to white-list.
  /// Call \#setChoiceEntries(String[]) and
  /// \#setChoiceValues(String[]) to set the localized list entries to present to the user
  /// and the corresponding values, respectively.
  /// Use \#getAllSelectedStrings() and \#setAllSelectedStrings(String[]) to
  /// manipulate the selections.
  static const TYPE_MULTI_SELECT = 4;

  /// from: static public final int TYPE_NULL
  ///
  /// Hidden restriction type. Use this type for information that needs to be transferred
  /// across but shouldn't be presented to the user in the UI. Stores a single String value.
  static const TYPE_NULL = 0;

  /// from: static public final int TYPE_STRING
  ///
  /// Restriction of type "string". Use this for storing a string value.
  ///@see \#setSelectedString
  ///@see \#getSelectedString
  static const TYPE_STRING = 6;

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int type, java.lang.String key)
  ///
  /// Constructor for specifying the type and key, with no initial value;
  ///@param type the restriction type.
  ///@param key the unique key for this restriction
  RestrictionEntry(int type, jni.JniString key)
      : super.fromRef(_ctor(type, key.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_ctor1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String key, java.lang.String selectedString)
  ///
  /// Constructor for \#TYPE_CHOICE type.
  ///@param key the unique key for this restriction
  ///@param selectedString the current value
  RestrictionEntry.ctor1(jni.JniString key, jni.JniString selectedString)
      : super.fromRef(_ctor1(key.reference, selectedString.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor2 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_content_RestrictionEntry_ctor2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String key, boolean selectedState)
  ///
  /// Constructor for \#TYPE_BOOLEAN type.
  ///@param key the unique key for this restriction
  ///@param selectedState whether this restriction is selected or not
  RestrictionEntry.ctor2(jni.JniString key, bool selectedState)
      : super.fromRef(_ctor2(key.reference, selectedState ? 1 : 0)) {
    jni.Jni.env.checkException();
  }

  static final _ctor3 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_ctor3")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String key, java.lang.String[] selectedStrings)
  ///
  /// Constructor for \#TYPE_MULTI_SELECT type.
  ///@param key the unique key for this restriction
  ///@param selectedStrings the list of values that are currently selected
  RestrictionEntry.ctor3(jni.JniString key, jni.JniObject selectedStrings)
      : super.fromRef(_ctor3(key.reference, selectedStrings.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor4 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_RestrictionEntry_ctor4")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String key, int selectedInt)
  ///
  /// Constructor for \#TYPE_INTEGER type.
  ///@param key the unique key for this restriction
  ///@param selectedInt the integer value of the restriction
  RestrictionEntry.ctor4(jni.JniString key, int selectedInt)
      : super.fromRef(_ctor4(key.reference, selectedInt)) {
    jni.Jni.env.checkException();
  }

  static final _ctor5 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_ctor5")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel in)
  RestrictionEntry.ctor5(os_.Parcel in0)
      : super.fromRef(_ctor5(in0.reference)) {
    jni.Jni.env.checkException();
  }

  static final _createBundleEntry = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_createBundleEntry")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.RestrictionEntry createBundleEntry(java.lang.String key, android.content.RestrictionEntry[] restrictionEntries)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an entry of type \#TYPE_BUNDLE.
  ///@param key the unique key for this restriction
  ///@param restrictionEntries array of nested restriction entries.
  ///@return the newly created restriction
  static RestrictionEntry createBundleEntry(
      jni.JniString key, jni.JniObject restrictionEntries) {
    final result__ = RestrictionEntry.fromRef(
        _createBundleEntry(key.reference, restrictionEntries.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _createBundleArrayEntry = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_createBundleArrayEntry")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.RestrictionEntry createBundleArrayEntry(java.lang.String key, android.content.RestrictionEntry[] restrictionEntries)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an entry of type \#TYPE_BUNDLE_ARRAY.
  ///@param key the unique key for this restriction
  ///@param restrictionEntries array of nested restriction entries. The array may only contain
  /// elements of type \#TYPE_BUNDLE bundle.
  ///@return the newly created restriction
  static RestrictionEntry createBundleArrayEntry(
      jni.JniString key, jni.JniObject restrictionEntries) {
    final result__ = RestrictionEntry.fromRef(
        _createBundleArrayEntry(key.reference, restrictionEntries.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setType = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_RestrictionEntry_setType")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setType(int type)
  ///
  /// Sets the type for this restriction.
  ///@param type the type for this restriction.
  void setType(int type) {
    final result__ = _setType(reference, type);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getType =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_RestrictionEntry_getType")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getType()
  ///
  /// Returns the type for this restriction.
  ///@return the type for this restriction
  int getType() {
    final result__ = _getType(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSelectedString = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_getSelectedString")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSelectedString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the currently selected string value.
  ///@return the currently selected value, which can be null for types that aren't for holding
  /// single string values.
  jni.JniString getSelectedString() {
    final result__ = jni.JniString.fromRef(_getSelectedString(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getAllSelectedStrings = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_getAllSelectedStrings")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getAllSelectedStrings()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of currently selected values.
  ///@return the list of current selections, if type is \#TYPE_MULTI_SELECT,
  ///  null otherwise.
  jni.JniObject getAllSelectedStrings() {
    final result__ = jni.JniObject.fromRef(_getAllSelectedStrings(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSelectedState =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_RestrictionEntry_getSelectedState")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getSelectedState()
  ///
  /// Returns the current selected state for an entry of type \#TYPE_BOOLEAN.
  ///@return the current selected state of the entry.
  bool getSelectedState() {
    final result__ = _getSelectedState(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getIntValue =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_RestrictionEntry_getIntValue")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getIntValue()
  ///
  /// Returns the value of the entry as an integer when the type is \#TYPE_INTEGER.
  ///@return the integer value of the entry.
  int getIntValue() {
    final result__ = _getIntValue(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setIntValue = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_RestrictionEntry_setIntValue")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setIntValue(int value)
  ///
  /// Sets the integer value of the entry when the type is \#TYPE_INTEGER.
  ///@param value the integer value to set.
  void setIntValue(int value) {
    final result__ = _setIntValue(reference, value);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setSelectedString = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_setSelectedString")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setSelectedString(java.lang.String selectedString)
  ///
  /// Sets the string value to use as the selected value for this restriction. This value will
  /// be persisted by the system for later use by the application.
  ///@param selectedString the string value to select.
  void setSelectedString(jni.JniString selectedString) {
    final result__ = _setSelectedString(reference, selectedString.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setSelectedState = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_content_RestrictionEntry_setSelectedState")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setSelectedState(boolean state)
  ///
  /// Sets the current selected state for an entry of type \#TYPE_BOOLEAN. This value will
  /// be persisted by the system for later use by the application.
  ///@param state the current selected state
  void setSelectedState(bool state) {
    final result__ = _setSelectedState(reference, state ? 1 : 0);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setAllSelectedStrings = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_setAllSelectedStrings")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setAllSelectedStrings(java.lang.String[] allSelectedStrings)
  ///
  /// Sets the current list of selected values for an entry of type \#TYPE_MULTI_SELECT.
  /// These values will be persisted by the system for later use by the application.
  ///@param allSelectedStrings the current list of selected values.
  void setAllSelectedStrings(jni.JniObject allSelectedStrings) {
    final result__ =
        _setAllSelectedStrings(reference, allSelectedStrings.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setChoiceValues = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_setChoiceValues")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setChoiceValues(java.lang.String[] choiceValues)
  ///
  /// Sets a list of string values that can be selected by the user. If no user-visible entries
  /// are set by a call to \#setChoiceEntries(String[]), these values will be the ones
  /// shown to the user. Values will be chosen from this list as the user's selection and the
  /// selected values can be retrieved by a call to \#getAllSelectedStrings(), or
  /// \#getSelectedString(), depending on whether it is a multi-select type or choice type.
  /// This method is not relevant for types other than
  /// \#TYPE_CHOICE, and \#TYPE_MULTI_SELECT.
  ///@param choiceValues an array of Strings which will be the selected values for the user's
  /// selections.
  ///@see \#getChoiceValues()
  ///@see \#getAllSelectedStrings()
  void setChoiceValues(jni.JniObject choiceValues) {
    final result__ = _setChoiceValues(reference, choiceValues.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setChoiceValues1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_RestrictionEntry_setChoiceValues1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setChoiceValues(android.content.Context context, int stringArrayResId)
  ///
  /// Sets a list of string values that can be selected by the user, similar to
  /// \#setChoiceValues(String[]).
  ///@param context the application context for retrieving the resources.
  ///@param stringArrayResId the resource id for a string array containing the possible values.
  ///@see \#setChoiceValues(String[])
  void setChoiceValues1(Context context, int stringArrayResId) {
    final result__ =
        _setChoiceValues1(reference, context.reference, stringArrayResId);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getRestrictions = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_getRestrictions")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.RestrictionEntry[] getRestrictions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns array of possible restriction entries that this entry may contain.
  jni.JniObject getRestrictions() {
    final result__ = jni.JniObject.fromRef(_getRestrictions(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setRestrictions = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_setRestrictions")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setRestrictions(android.content.RestrictionEntry[] restrictions)
  ///
  /// Sets an array of possible restriction entries, that this entry may contain.
  /// This method is only relevant for types \#TYPE_BUNDLE and
  /// \#TYPE_BUNDLE_ARRAY
  void setRestrictions(jni.JniObject restrictions) {
    final result__ = _setRestrictions(reference, restrictions.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getChoiceValues = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_getChoiceValues")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getChoiceValues()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of possible string values set earlier.
  ///@return the list of possible values.
  jni.JniObject getChoiceValues() {
    final result__ = jni.JniObject.fromRef(_getChoiceValues(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setChoiceEntries = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_setChoiceEntries")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setChoiceEntries(java.lang.String[] choiceEntries)
  ///
  /// Sets a list of strings that will be presented as choices to the user. When the
  /// user selects one or more of these choices, the corresponding value from the possible values
  /// are stored as the selected strings. The size of this array must match the size of the array
  /// set in \#setChoiceValues(String[]). This method is not relevant for types other
  /// than \#TYPE_CHOICE, and \#TYPE_MULTI_SELECT.
  ///@param choiceEntries the list of user-visible choices.
  ///@see \#setChoiceValues(String[])
  void setChoiceEntries(jni.JniObject choiceEntries) {
    final result__ = _setChoiceEntries(reference, choiceEntries.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setChoiceEntries1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_RestrictionEntry_setChoiceEntries1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setChoiceEntries(android.content.Context context, int stringArrayResId)
  ///
  /// Sets a list of strings that will be presented as choices to the user. This is similar to
  /// \#setChoiceEntries(String[]).
  ///@param context the application context, used for retrieving the resources.
  ///@param stringArrayResId the resource id of a string array containing the possible entries.
  void setChoiceEntries1(Context context, int stringArrayResId) {
    final result__ =
        _setChoiceEntries1(reference, context.reference, stringArrayResId);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getChoiceEntries = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_getChoiceEntries")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getChoiceEntries()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of strings, set earlier, that will be presented as choices to the user.
  ///@return the list of choices presented to the user.
  jni.JniObject getChoiceEntries() {
    final result__ = jni.JniObject.fromRef(_getChoiceEntries(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDescription = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_getDescription")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the provided user-visible description of the entry, if any.
  ///@return the user-visible description, null if none was set earlier.
  jni.JniString getDescription() {
    final result__ = jni.JniString.fromRef(_getDescription(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setDescription = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_setDescription")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setDescription(java.lang.String description)
  ///
  /// Sets the user-visible description of the entry, as a possible sub-text for the title.
  /// You can use this to describe the entry in more detail or to display the current state of
  /// the restriction.
  ///@param description the user-visible description string.
  void setDescription(jni.JniString description) {
    final result__ = _setDescription(reference, description.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getKey = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_getKey")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getKey()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This is the unique key for the restriction entry.
  ///@return the key for the restriction.
  jni.JniString getKey() {
    final result__ = jni.JniString.fromRef(_getKey(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getTitle = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_getTitle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the user-visible title for the entry, if any.
  ///@return the user-visible title for the entry, null if none was set earlier.
  jni.JniString getTitle() {
    final result__ = jni.JniString.fromRef(_getTitle(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setTitle = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_setTitle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTitle(java.lang.String title)
  ///
  /// Sets the user-visible title for the entry.
  ///@param title the user-visible title for the entry.
  void setTitle(jni.JniString title) {
    final result__ = _setTitle(reference, title.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _equals1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_equals1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) {
    final result__ = _equals1(reference, o.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hashCode1 =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_RestrictionEntry_hashCode1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    final result__ = _hashCode1(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_RestrictionEntry_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_RestrictionEntry_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) {
    final result__ = _writeToParcel(reference, dest.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_RestrictionEntry_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.EntityIterator
///
/// A specialization of Iterator that allows iterating over a collection of
/// Entity objects. In addition to the iteration functionality it also allows
/// resetting the iterator back to the beginning and provides for an explicit \#close()
/// method to indicate that the iterator is no longer needed and that its resources
/// can be released.
class EntityIterator extends jni.JniObject {
  EntityIterator.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _reset =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_EntityIterator_reset")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void reset()
  ///
  /// Reset the iterator back to the beginning.
  void reset() {
    final result__ = _reset(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _close =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_EntityIterator_close")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void close()
  ///
  /// Indicates that this iterator is no longer needed and that any associated resources
  /// may be released (such as a SQLite cursor).
  void close() {
    final result__ = _close(reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.SearchRecentSuggestionsProvider
///
/// This superclass can be used to create a simple search suggestions provider for your application.
/// It creates suggestions (as the user types) based on recent queries and/or recent views.
///
/// In order to use this class, you must do the following.
///
/// <ul>
/// <li>Implement and test query search, as described in android.app.SearchManager.  (This
/// provider will send any suggested queries via the standard
/// android.content.Intent\#ACTION_SEARCH ACTION_SEARCH Intent, which you'll already
/// support once you have implemented and tested basic searchability.)</li>
/// <li>Create a Content Provider within your application by extending
/// android.content.SearchRecentSuggestionsProvider.  The class you create will be
/// very simple - typically, it will have only a constructor.  But the constructor has a very
/// important responsibility:  When it calls \#setupSuggestions(String, int), it
/// <i>configures</i> the provider to match the requirements of your searchable activity.</li>
/// <li>Create a manifest entry describing your provider.  Typically this would be as simple
/// as adding the following lines:
/// <pre class="prettyprint">
///     &lt;!-- Content provider for search suggestions --&gt;
///     &lt;provider android:name="YourSuggestionProviderClass"
///               android:authorities="your.suggestion.authority" /&gt;</pre>
/// </li>
/// <li>Please note that you <i>do not</i> instantiate this content provider directly from within
/// your code.  This is done automatically by the system Content Resolver, when the search dialog
/// looks for suggestions.</li>
/// <li>In order for the Content Resolver to do this, you must update your searchable activity's
/// XML configuration file with information about your content provider.  The following additions
/// are usually sufficient:
/// <pre class="prettyprint">
///     android:searchSuggestAuthority="your.suggestion.authority"
///     android:searchSuggestSelection=" ? "</pre>
/// </li>
/// <li>In your searchable activities, capture any user-generated queries and record them
/// for future searches by calling android.provider.SearchRecentSuggestions\#saveRecentQuery SearchRecentSuggestions.saveRecentQuery().</li>
/// </ul>
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For information about using search suggestions in your application, read the
/// <a href="{@docRoot}guide/topics/search/index.html">Search</a> developer guide.
///
/// </div>
///@see android.provider.SearchRecentSuggestions
class SearchRecentSuggestionsProvider extends ContentProvider {
  SearchRecentSuggestionsProvider.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final int DATABASE_MODE_2LINES
  ///
  /// This mode bit configures the database to include a 2nd annotation line with each entry.
  /// <i>optional</i>
  ///@see \#setupSuggestions(String, int)
  static const DATABASE_MODE_2LINES = 2;

  /// from: static public final int DATABASE_MODE_QUERIES
  ///
  /// This mode bit configures the database to record recent queries.  <i>required</i>
  ///@see \#setupSuggestions(String, int)
  static const DATABASE_MODE_QUERIES = 1;

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_SearchRecentSuggestionsProvider_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  SearchRecentSuggestionsProvider() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _setupSuggestions = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_SearchRecentSuggestionsProvider_setupSuggestions")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: protected void setupSuggestions(java.lang.String authority, int mode)
  ///
  /// In order to use this class, you must extend it, and call this setup function from your
  /// constructor.  In your application or activities, you must provide the same values when
  /// you create the android.provider.SearchRecentSuggestions helper.
  ///@param authority This must match the authority that you've declared in your manifest.
  ///@param mode You can use mode flags here to determine certain functional aspects of your
  /// database.  Note, this value should not change from run to run, because when it does change,
  /// your suggestions database may be wiped.
  ///@see \#DATABASE_MODE_QUERIES
  ///@see \#DATABASE_MODE_2LINES
  void setupSuggestions(jni.JniString authority, int mode) {
    final result__ = _setupSuggestions(reference, authority.reference, mode);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _delete1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_SearchRecentSuggestionsProvider_delete1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int delete(android.net.Uri uri, java.lang.String selection, java.lang.String[] selectionArgs)
  ///
  /// This method is provided for use by the ContentResolver.  Do not override, or directly
  /// call from your own code.
  int delete1(
      jni.JniObject uri, jni.JniString selection, jni.JniObject selectionArgs) {
    final result__ = _delete1(
        reference, uri.reference, selection.reference, selectionArgs.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getType = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_SearchRecentSuggestionsProvider_getType")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getType(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method is provided for use by the ContentResolver.  Do not override, or directly
  /// call from your own code.
  jni.JniString getType(jni.JniObject uri) {
    final result__ = jni.JniString.fromRef(_getType(reference, uri.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _insert = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_SearchRecentSuggestionsProvider_insert")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri insert(android.net.Uri uri, android.content.ContentValues values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method is provided for use by the ContentResolver.  Do not override, or directly
  /// call from your own code.
  jni.JniObject insert(jni.JniObject uri, ContentValues values) {
    final result__ = jni.JniObject.fromRef(
        _insert(reference, uri.reference, values.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onCreate =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SearchRecentSuggestionsProvider_onCreate")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onCreate()
  ///
  /// This method is provided for use by the ContentResolver.  Do not override, or directly
  /// call from your own code.
  bool onCreate() {
    final result__ = _onCreate(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _query = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_SearchRecentSuggestionsProvider_query")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This method is provided for use by the ContentResolver.  Do not override, or directly
  /// call from your own code.
  jni.JniObject query(
      jni.JniObject uri,
      jni.JniObject projection,
      jni.JniString selection,
      jni.JniObject selectionArgs,
      jni.JniString sortOrder) {
    final result__ = jni.JniObject.fromRef(_query(
        reference,
        uri.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        sortOrder.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _update = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_SearchRecentSuggestionsProvider_update")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int update(android.net.Uri uri, android.content.ContentValues values, java.lang.String selection, java.lang.String[] selectionArgs)
  ///
  /// This method is provided for use by the ContentResolver.  Do not override, or directly
  /// call from your own code.
  int update(jni.JniObject uri, ContentValues values, jni.JniString selection,
      jni.JniObject selectionArgs) {
    final result__ = _update(reference, uri.reference, values.reference,
        selection.reference, selectionArgs.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.BroadcastReceiver
///
/// Base class for code that receives and handles broadcast intents sent by
/// android.content.Context\#sendBroadcast(Intent).
///
/// You can either dynamically register an instance of this class with
/// Context\#registerReceiver Context.registerReceiver()
/// or statically declare an implementation with the
/// android.R.styleable\#AndroidManifestReceiver &lt;receiver&gt;
/// tag in your <code>AndroidManifest.xml</code>.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using BroadcastReceiver, read the
/// <a href="{@docRoot}guide/components/broadcasts.html">Broadcasts</a> developer guide.
///</div>
class BroadcastReceiver extends jni.JniObject {
  BroadcastReceiver.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_BroadcastReceiver_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  BroadcastReceiver() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _onReceive = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_BroadcastReceiver_onReceive")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onReceive(android.content.Context context, android.content.Intent intent)
  ///
  /// This method is called when the BroadcastReceiver is receiving an Intent
  /// broadcast.  During this time you can use the other methods on
  /// BroadcastReceiver to view/modify the current result values.  This method
  /// is always called within the main thread of its process, unless you
  /// explicitly asked for it to be scheduled on a different thread using
  /// android.content.Context\#registerReceiver(BroadcastReceiver,
  /// IntentFilter, String, android.os.Handler). When it runs on the main
  /// thread you should
  /// never perform long-running operations in it (there is a timeout of
  /// 10 seconds that the system allows before considering the receiver to
  /// be blocked and a candidate to be killed). You cannot launch a popup dialog
  /// in your implementation of onReceive().
  ///
  /// __If this BroadcastReceiver was launched through a &lt;receiver&gt; tag,
  /// then the object is no longer alive after returning from this
  /// function.__ This means you should not perform any operations that
  /// return a result to you asynchronously. If you need to perform any follow up
  /// background work, schedule a android.app.job.JobService with
  /// android.app.job.JobScheduler.
  ///
  /// If you wish to interact with a service that is already running and previously
  /// bound using android.content.Context\#bindService(Intent, ServiceConnection, int) bindService(),
  /// you can use \#peekService.
  ///
  /// The Intent filters used in android.content.Context\#registerReceiver
  /// and in application manifests are _not_ guaranteed to be exclusive. They
  /// are hints to the operating system about how to find suitable recipients. It is
  /// possible for senders to force delivery to specific recipients, bypassing filter
  /// resolution.  For this reason, \#onReceive(Context, Intent) onReceive()
  /// implementations should respond only to known actions, ignoring any unexpected
  /// Intents that they may receive.
  ///@param context The Context in which the receiver is running.
  ///@param intent The Intent being received.
  void onReceive(Context context, Intent intent) {
    final result__ = _onReceive(reference, context.reference, intent.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _goAsync = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_BroadcastReceiver_goAsync")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.BroadcastReceiver.PendingResult goAsync()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This can be called by an application in \#onReceive to allow
  /// it to keep the broadcast active after returning from that function.
  /// This does _not_ change the expectation of being relatively
  /// responsive to the broadcast, but does allow
  /// the implementation to move work related to it over to another thread
  /// to avoid glitching the main UI thread due to disk IO.
  ///
  /// As a general rule, broadcast receivers are allowed to run for up to 10 seconds
  /// before they system will consider them non-responsive and ANR the app.  Since these usually
  /// execute on the app's main thread, they are already bound by the ~5 second time limit
  /// of various operations that can happen there (not to mention just avoiding UI jank), so
  /// the receive limit is generally not of concern.  However, once you use {@code goAsync}, though
  /// able to be off the main thread, the broadcast execution limit still applies, and that
  /// includes the time spent between calling this method and ultimately
  /// PendingResult\#finish() PendingResult.finish().
  ///
  ///
  /// If you are taking advantage of this method to have more time to execute, it is useful
  /// to know that the available time can be longer in certain situations.  In particular, if
  /// the broadcast you are receiving is not a foreground broadcast (that is, the sender has not
  /// used Intent\#FLAG_RECEIVER_FOREGROUND), then more time is allowed for the receivers
  /// to run, allowing them to execute for 30 seconds or even a bit more.  This is something that
  /// receivers should rarely take advantage of (long work should be punted to another system
  /// facility such as android.app.job.JobScheduler, android.app.Service, or
  /// see especially android.support.v4.app.JobIntentService), but can be useful in
  /// certain rare cases where it is necessary to do some work as soon as the broadcast is
  /// delivered.  Keep in mind that the work you do here will block further broadcasts until
  /// it completes, so taking advantage of this at all excessively can be counter-productive
  /// and cause later events to be received more slowly.
  ///
  ///@return Returns a PendingResult representing the result of
  /// the active broadcast.  The BroadcastRecord itself is no longer active;
  /// all data and other interaction must go through PendingResult
  /// APIs.  The PendingResult\#finish PendingResult.finish() method
  /// must be called once processing of the broadcast is done.
  BroadcastReceiver_PendingResult goAsync() {
    final result__ =
        BroadcastReceiver_PendingResult.fromRef(_goAsync(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _peekService = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_BroadcastReceiver_peekService")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.IBinder peekService(android.content.Context myContext, android.content.Intent service)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Provide a binder to an already-bound service.  This method is synchronous
  /// and will not start the target service if it is not present, so it is safe
  /// to call from \#onReceive.
  ///
  /// For peekService() to return a non null android.os.IBinder interface
  /// the service must have published it before. In other words some component
  /// must have called android.content.Context\#bindService(Intent, ServiceConnection, int) on it.
  ///@param myContext The Context that had been passed to \#onReceive(Context, Intent)
  ///@param service Identifies the already-bound service you wish to use. See
  /// android.content.Context\#bindService(Intent, ServiceConnection, int)
  /// for more information.
  os_.IBinder peekService(Context myContext, Intent service) {
    final result__ = os_.IBinder.fromRef(
        _peekService(reference, myContext.reference, service.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setResultCode = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_BroadcastReceiver_setResultCode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setResultCode(int code)
  ///
  /// Change the current result code of this broadcast; only works with
  /// broadcasts sent through
  /// Context\#sendOrderedBroadcast(Intent, String) Context.sendOrderedBroadcast.  Often uses the
  /// Activity android.app.Activity\#RESULT_CANCELED and
  /// android.app.Activity\#RESULT_OK constants, though the
  /// actual meaning of this value is ultimately up to the broadcaster.
  ///
  /// <p class="note">This method does not work with non-ordered broadcasts such
  /// as those sent with Context\#sendBroadcast(Intent) Context.sendBroadcast
  ///
  ///@param code The new result code.
  ///@see \#setResult(int, String, Bundle)
  void setResultCode(int code) {
    final result__ = _setResultCode(reference, code);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getResultCode =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_BroadcastReceiver_getResultCode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getResultCode()
  ///
  /// Retrieve the current result code, as set by the previous receiver.
  ///@return int The current result code.
  int getResultCode() {
    final result__ = _getResultCode(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setResultData = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_BroadcastReceiver_setResultData")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setResultData(java.lang.String data)
  ///
  /// Change the current result data of this broadcast; only works with
  /// broadcasts sent through
  /// Context\#sendOrderedBroadcast(Intent, String) Context.sendOrderedBroadcast.  This is an arbitrary
  /// string whose interpretation is up to the broadcaster.
  ///
  /// <strong>This method does not work with non-ordered broadcasts such
  /// as those sent with Context\#sendBroadcast(Intent) Context.sendBroadcast</strong>
  ///
  ///@param data The new result data; may be null.
  ///@see \#setResult(int, String, Bundle)
  void setResultData(jni.JniString data) {
    final result__ = _setResultData(reference, data.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getResultData = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_BroadcastReceiver_getResultData")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String getResultData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the current result data, as set by the previous receiver.
  /// Often this is null.
  ///@return String The current result data; may be null.
  jni.JniString getResultData() {
    final result__ = jni.JniString.fromRef(_getResultData(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setResultExtras = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_BroadcastReceiver_setResultExtras")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setResultExtras(android.os.Bundle extras)
  ///
  /// Change the current result extras of this broadcast; only works with
  /// broadcasts sent through
  /// Context\#sendOrderedBroadcast(Intent, String) Context.sendOrderedBroadcast.  This is a Bundle
  /// holding arbitrary data, whose interpretation is up to the
  /// broadcaster.  Can be set to null.  Calling this method completely
  /// replaces the current map (if any).
  ///
  /// <strong>This method does not work with non-ordered broadcasts such
  /// as those sent with Context\#sendBroadcast(Intent) Context.sendBroadcast</strong>
  ///
  ///@param extras The new extra data map; may be null.
  ///@see \#setResult(int, String, Bundle)
  void setResultExtras(os_.Bundle extras) {
    final result__ = _setResultExtras(reference, extras.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getResultExtras = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_content_BroadcastReceiver_getResultExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final android.os.Bundle getResultExtras(boolean makeMap)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the current result extra data, as set by the previous receiver.
  /// Any changes you make to the returned Map will be propagated to the next
  /// receiver.
  ///@param makeMap If true then a new empty Map will be made for you if the
  ///                current Map is null; if false you should be prepared to
  ///                receive a null Map.
  ///@return Map The current extras map.
  os_.Bundle getResultExtras(bool makeMap) {
    final result__ =
        os_.Bundle.fromRef(_getResultExtras(reference, makeMap ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setResult = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_BroadcastReceiver_setResult")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void setResult(int code, java.lang.String data, android.os.Bundle extras)
  ///
  /// Change all of the result data returned from this broadcasts; only works
  /// with broadcasts sent through
  /// Context\#sendOrderedBroadcast(Intent, String) Context.sendOrderedBroadcast.  All current result data is replaced
  /// by the value given to this method.
  ///
  /// <strong>This method does not work with non-ordered broadcasts such
  /// as those sent with Context\#sendBroadcast(Intent) Context.sendBroadcast</strong>
  ///
  ///@param code The new result code.  Often uses the
  /// Activity android.app.Activity\#RESULT_CANCELED and
  /// android.app.Activity\#RESULT_OK constants, though the
  /// actual meaning of this value is ultimately up to the broadcaster.
  ///@param data The new result data.  This is an arbitrary
  /// string whose interpretation is up to the broadcaster; may be null.
  ///@param extras The new extra data map.  This is a Bundle
  /// holding arbitrary data, whose interpretation is up to the
  /// broadcaster.  Can be set to null.  This completely
  /// replaces the current map (if any).
  void setResult(int code, jni.JniString data, os_.Bundle extras) {
    final result__ =
        _setResult(reference, code, data.reference, extras.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getAbortBroadcast =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_BroadcastReceiver_getAbortBroadcast")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean getAbortBroadcast()
  ///
  /// Returns the flag indicating whether or not this receiver should
  /// abort the current broadcast.
  ///@return True if the broadcast should be aborted.
  bool getAbortBroadcast() {
    final result__ = _getAbortBroadcast(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _abortBroadcast =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_BroadcastReceiver_abortBroadcast")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final void abortBroadcast()
  ///
  /// Sets the flag indicating that this receiver should abort the
  /// current broadcast; only works with broadcasts sent through
  /// Context\#sendOrderedBroadcast(Intent, String) Context.sendOrderedBroadcast.  This will prevent
  /// any other broadcast receivers from receiving the broadcast. It will still
  /// call \#onReceive of the BroadcastReceiver that the caller of
  /// Context\#sendOrderedBroadcast(Intent, String) Context.sendOrderedBroadcast passed in.
  ///
  /// <strong>This method does not work with non-ordered broadcasts such
  /// as those sent with Context\#sendBroadcast(Intent) Context.sendBroadcast</strong>
  ///
  void abortBroadcast() {
    final result__ = _abortBroadcast(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _clearAbortBroadcast =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_BroadcastReceiver_clearAbortBroadcast")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final void clearAbortBroadcast()
  ///
  /// Clears the flag indicating that this receiver should abort the current
  /// broadcast.
  void clearAbortBroadcast() {
    final result__ = _clearAbortBroadcast(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isOrderedBroadcast =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_BroadcastReceiver_isOrderedBroadcast")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isOrderedBroadcast()
  ///
  /// Returns true if the receiver is currently processing an ordered
  /// broadcast.
  bool isOrderedBroadcast() {
    final result__ = _isOrderedBroadcast(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isInitialStickyBroadcast =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_BroadcastReceiver_isInitialStickyBroadcast")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isInitialStickyBroadcast()
  ///
  /// Returns true if the receiver is currently processing the initial
  /// value of a sticky broadcast -- that is, the value that was last
  /// broadcast and is currently held in the sticky cache, so this is
  /// not directly the result of a broadcast right now.
  bool isInitialStickyBroadcast() {
    final result__ = _isInitialStickyBroadcast(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setOrderedHint = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_content_BroadcastReceiver_setOrderedHint")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setOrderedHint(boolean isOrdered)
  ///
  /// For internal use, sets the hint about whether this BroadcastReceiver is
  /// running in ordered mode.
  void setOrderedHint(bool isOrdered) {
    final result__ = _setOrderedHint(reference, isOrdered ? 1 : 0);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setDebugUnregister = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_content_BroadcastReceiver_setDebugUnregister")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setDebugUnregister(boolean debug)
  ///
  /// Control inclusion of debugging help for mismatched
  /// calls to Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver().
  /// If called with true, before given to registerReceiver(), then the
  /// callstack of the following Context\#unregisterReceiver(BroadcastReceiver) Context.unregisterReceiver() call is retained, to be printed if a later
  /// incorrect unregister call is made.  Note that doing this requires retaining
  /// information about the BroadcastReceiver for the lifetime of the app,
  /// resulting in a leak -- this should only be used for debugging.
  void setDebugUnregister(bool debug) {
    final result__ = _setDebugUnregister(reference, debug ? 1 : 0);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDebugUnregister =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_BroadcastReceiver_getDebugUnregister")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean getDebugUnregister()
  ///
  /// Return the last value given to \#setDebugUnregister.
  bool getDebugUnregister() {
    final result__ = _getDebugUnregister(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.BroadcastReceiver$PendingResult
///
/// State for a result that is pending for a broadcast receiver.  Returned
/// by BroadcastReceiver\#goAsync() goAsync()
/// while in BroadcastReceiver\#onReceive BroadcastReceiver.onReceive().
/// This allows you to return from onReceive() without having the broadcast
/// terminate; you must call \#finish() once you are done with the
/// broadcast.  This allows you to process the broadcast off of the main
/// thread of your app.
///
/// Note on threading: the state inside of this class is not itself
/// thread-safe, however you can use it from any thread if you properly
/// sure that you do not have races.  Typically this means you will hand
/// the entire object to another thread, which will be solely responsible
/// for setting any results and finally calling \#finish().
class BroadcastReceiver_PendingResult extends jni.JniObject {
  BroadcastReceiver_PendingResult.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Uint8,
                      ffi.Uint8,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32)>>(
          "android_content_BroadcastReceiver__PendingResult_ctor")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>,
              int,
              int)>();

  /// from: void <init>(int resultCode, java.lang.String resultData, android.os.Bundle resultExtras, int type, boolean ordered, boolean sticky, android.os.IBinder token, int userId, int flags)
  ///
  /// @hide
  BroadcastReceiver_PendingResult(
      int resultCode,
      jni.JniString resultData,
      os_.Bundle resultExtras,
      int type,
      bool ordered,
      bool sticky,
      os_.IBinder token,
      int userId,
      int flags)
      : super.fromRef(_ctor(
            resultCode,
            resultData.reference,
            resultExtras.reference,
            type,
            ordered ? 1 : 0,
            sticky ? 1 : 0,
            token.reference,
            userId,
            flags)) {
    jni.Jni.env.checkException();
  }

  static final _setResultCode = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_BroadcastReceiver__PendingResult_setResultCode")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setResultCode(int code)
  ///
  /// Version of BroadcastReceiver\#setResultCode(int) BroadcastReceiver.setResultCode(int) for
  /// asynchronous broadcast handling.
  void setResultCode(int code) {
    final result__ = _setResultCode(reference, code);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getResultCode =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_BroadcastReceiver__PendingResult_getResultCode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getResultCode()
  ///
  /// Version of BroadcastReceiver\#getResultCode() BroadcastReceiver.getResultCode() for
  /// asynchronous broadcast handling.
  int getResultCode() {
    final result__ = _getResultCode(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setResultData = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_BroadcastReceiver__PendingResult_setResultData")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setResultData(java.lang.String data)
  ///
  /// Version of BroadcastReceiver\#setResultData(String) BroadcastReceiver.setResultData(String) for
  /// asynchronous broadcast handling.
  void setResultData(jni.JniString data) {
    final result__ = _setResultData(reference, data.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getResultData = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_BroadcastReceiver__PendingResult_getResultData")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String getResultData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Version of BroadcastReceiver\#getResultData() BroadcastReceiver.getResultData() for
  /// asynchronous broadcast handling.
  jni.JniString getResultData() {
    final result__ = jni.JniString.fromRef(_getResultData(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setResultExtras = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_BroadcastReceiver__PendingResult_setResultExtras")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setResultExtras(android.os.Bundle extras)
  ///
  /// Version of BroadcastReceiver\#setResultExtras(Bundle) BroadcastReceiver.setResultExtras(Bundle) for
  /// asynchronous broadcast handling.
  void setResultExtras(os_.Bundle extras) {
    final result__ = _setResultExtras(reference, extras.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getResultExtras = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_content_BroadcastReceiver__PendingResult_getResultExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final android.os.Bundle getResultExtras(boolean makeMap)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Version of BroadcastReceiver\#getResultExtras(boolean) BroadcastReceiver.getResultExtras(boolean) for
  /// asynchronous broadcast handling.
  os_.Bundle getResultExtras(bool makeMap) {
    final result__ =
        os_.Bundle.fromRef(_getResultExtras(reference, makeMap ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setResult = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_BroadcastReceiver__PendingResult_setResult")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void setResult(int code, java.lang.String data, android.os.Bundle extras)
  ///
  /// Version of BroadcastReceiver\#setResult(int, String, Bundle) BroadcastReceiver.setResult(int, String, Bundle) for
  /// asynchronous broadcast handling.
  void setResult(int code, jni.JniString data, os_.Bundle extras) {
    final result__ =
        _setResult(reference, code, data.reference, extras.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getAbortBroadcast = jniLookup<
              ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_BroadcastReceiver__PendingResult_getAbortBroadcast")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean getAbortBroadcast()
  ///
  /// Version of BroadcastReceiver\#getAbortBroadcast() BroadcastReceiver.getAbortBroadcast() for
  /// asynchronous broadcast handling.
  bool getAbortBroadcast() {
    final result__ = _getAbortBroadcast(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _abortBroadcast =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_BroadcastReceiver__PendingResult_abortBroadcast")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final void abortBroadcast()
  ///
  /// Version of BroadcastReceiver\#abortBroadcast() BroadcastReceiver.abortBroadcast() for
  /// asynchronous broadcast handling.
  void abortBroadcast() {
    final result__ = _abortBroadcast(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _clearAbortBroadcast = jniLookup<
              ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_BroadcastReceiver__PendingResult_clearAbortBroadcast")
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final void clearAbortBroadcast()
  ///
  /// Version of BroadcastReceiver\#clearAbortBroadcast() BroadcastReceiver.clearAbortBroadcast() for
  /// asynchronous broadcast handling.
  void clearAbortBroadcast() {
    final result__ = _clearAbortBroadcast(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _finish =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_BroadcastReceiver__PendingResult_finish")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final void finish()
  ///
  /// Finish the broadcast.  The current result will be sent and the
  /// next broadcast will proceed.
  void finish() {
    final result__ = _finish(reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.CursorLoader
///
/// A loader that queries the ContentResolver and returns a Cursor.
/// This class implements the Loader protocol in a standard way for
/// querying cursors, building on AsyncTaskLoader to perform the cursor
/// query on a background thread so that it does not block the application's UI.
///
/// A CursorLoader must be built with the full information for the query to
/// perform, either through the
/// \#CursorLoader(Context, Uri, String[], String, String[], String) or
/// creating an empty instance with \#CursorLoader(Context) and filling
/// in the desired paramters with \#setUri(Uri), \#setSelection(String),
/// \#setSelectionArgs(String[]), \#setSortOrder(String),
/// and \#setProjection(String[]).
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.content.CursorLoader
class CursorLoader extends AsyncTaskLoader {
  CursorLoader.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_CursorLoader_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  ///
  /// Creates an empty unspecified CursorLoader.  You must follow this with
  /// calls to \#setUri(Uri), \#setSelection(String), etc
  /// to specify the query to perform.
  CursorLoader(Context context) : super.fromRef(_ctor(context.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_CursorLoader_ctor1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context, android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder)
  ///
  /// Creates a fully-specified CursorLoader.  See
  /// ContentResolver\#query(Uri, String[], String, String[], String) ContentResolver.query() for documentation on the meaning of the
  /// parameters.  These will be passed as-is to that call.
  CursorLoader.ctor1(
      Context context,
      jni.JniObject uri,
      jni.JniObject projection,
      jni.JniString selection,
      jni.JniObject selectionArgs,
      jni.JniString sortOrder)
      : super.fromRef(_ctor1(
            context.reference,
            uri.reference,
            projection.reference,
            selection.reference,
            selectionArgs.reference,
            sortOrder.reference)) {
    jni.Jni.env.checkException();
  }

  static final _loadInBackground1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_CursorLoader_loadInBackground1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.database.Cursor loadInBackground()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject loadInBackground1() {
    final result__ = jni.JniObject.fromRef(_loadInBackground1(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _cancelLoadInBackground =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_CursorLoader_cancelLoadInBackground")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void cancelLoadInBackground()
  void cancelLoadInBackground() {
    final result__ = _cancelLoadInBackground(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _deliverResult1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_CursorLoader_deliverResult1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void deliverResult(android.database.Cursor cursor)
  void deliverResult1(jni.JniObject cursor) {
    final result__ = _deliverResult1(reference, cursor.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onStartLoading1 =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_CursorLoader_onStartLoading1")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStartLoading()
  ///
  /// Starts an asynchronous load of the data. When the result is ready the callbacks
  /// will be called on the UI thread. If a previous load has been completed and is still valid
  /// the result may be passed to the callbacks immediately.
  ///
  /// Must be called from the UI thread
  void onStartLoading1() {
    final result__ = _onStartLoading1(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onStopLoading1 =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_CursorLoader_onStopLoading1")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStopLoading()
  ///
  /// Must be called from the UI thread
  void onStopLoading1() {
    final result__ = _onStopLoading1(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onCanceled1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_CursorLoader_onCanceled1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCanceled(android.database.Cursor cursor)
  void onCanceled1(jni.JniObject cursor) {
    final result__ = _onCanceled1(reference, cursor.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onReset1 =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_CursorLoader_onReset1")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onReset()
  void onReset1() {
    final result__ = _onReset1(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getUri = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_CursorLoader_getUri")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri getUri()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getUri() {
    final result__ = jni.JniObject.fromRef(_getUri(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setUri = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_CursorLoader_setUri")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setUri(android.net.Uri uri)
  void setUri(jni.JniObject uri) {
    final result__ = _setUri(reference, uri.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getProjection = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_CursorLoader_getProjection")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getProjection()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getProjection() {
    final result__ = jni.JniObject.fromRef(_getProjection(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setProjection = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_CursorLoader_setProjection")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setProjection(java.lang.String[] projection)
  void setProjection(jni.JniObject projection) {
    final result__ = _setProjection(reference, projection.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSelection = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_CursorLoader_getSelection")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSelection()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getSelection() {
    final result__ = jni.JniString.fromRef(_getSelection(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setSelection = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_CursorLoader_setSelection")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setSelection(java.lang.String selection)
  void setSelection(jni.JniString selection) {
    final result__ = _setSelection(reference, selection.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSelectionArgs = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_CursorLoader_getSelectionArgs")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getSelectionArgs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getSelectionArgs() {
    final result__ = jni.JniObject.fromRef(_getSelectionArgs(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setSelectionArgs = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_CursorLoader_setSelectionArgs")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setSelectionArgs(java.lang.String[] selectionArgs)
  void setSelectionArgs(jni.JniObject selectionArgs) {
    final result__ = _setSelectionArgs(reference, selectionArgs.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSortOrder = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_CursorLoader_getSortOrder")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSortOrder()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getSortOrder() {
    final result__ = jni.JniString.fromRef(_getSortOrder(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setSortOrder = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_CursorLoader_setSortOrder")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setSortOrder(java.lang.String sortOrder)
  void setSortOrder(jni.JniString sortOrder) {
    final result__ = _setSortOrder(reference, sortOrder.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _dump = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_CursorLoader_dump")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  void dump(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
      jni.JniObject args) {
    final result__ = _dump(reference, prefix.reference, fd.reference,
        writer.reference, args.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.QuickViewConstants
///
/// Constants for Intent\#ACTION_QUICK_VIEW.
class QuickViewConstants extends jni.JniObject {
  QuickViewConstants.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String FEATURE_DELETE
  ///
  /// Feature to delete an individual document. Quick viewer implementations must use
  /// Storage Access Framework to both verify delete permission and to delete content.
  ///@see DocumentsContract.Document\#FLAG_SUPPORTS_DELETE
  ///@see DocumentsContract\#deleteDocument(ContentResolver, Uri)
  static const FEATURE_DELETE = "android:delete";

  /// from: static public final java.lang.String FEATURE_DOWNLOAD
  ///
  /// Feature to download a document to the local file system.
  ///@see Intent\#EXTRA_QUICK_VIEW_FEATURES
  ///@see Intent\#ACTION_QUICK_VIEW
  static const FEATURE_DOWNLOAD = "android:download";

  /// from: static public final java.lang.String FEATURE_EDIT
  ///
  /// Feature to edit a document using system standard editing mechanism, like
  /// Intent\#ACTION_EDIT.
  ///@see Intent\#EXTRA_QUICK_VIEW_FEATURES
  ///@see Intent\#ACTION_QUICK_VIEW
  static const FEATURE_EDIT = "android:edit";

  /// from: static public final java.lang.String FEATURE_PRINT
  ///
  /// Feature to print a document.
  ///@see Intent\#EXTRA_QUICK_VIEW_FEATURES
  ///@see Intent\#ACTION_QUICK_VIEW
  static const FEATURE_PRINT = "android:print";

  /// from: static public final java.lang.String FEATURE_SEND
  ///
  /// Feature to view a document using system standard sending mechanism, like
  /// Intent\#ACTION_SEND.
  ///@see Intent\#EXTRA_QUICK_VIEW_FEATURES
  ///@see Intent\#ACTION_QUICK_VIEW
  static const FEATURE_SEND = "android:send";

  /// from: static public final java.lang.String FEATURE_VIEW
  ///
  /// Feature to view a document using system standard viewing mechanism, like
  /// Intent\#ACTION_VIEW.
  ///@see Intent\#EXTRA_QUICK_VIEW_FEATURES
  ///@see Intent\#ACTION_QUICK_VIEW
  static const FEATURE_VIEW = "android:view";

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_QuickViewConstants_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  QuickViewConstants() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }
}

/// from: android.content.ReceiverCallNotAllowedException
///
/// This exception is thrown from Context\#registerReceiver and
/// Context\#bindService when these methods are being used from
/// an BroadcastReceiver component.  In this case, the component will no
/// longer be active upon returning from receiving the Intent, so it is
/// not valid to use asynchronous APIs.
class ReceiverCallNotAllowedException extends jni.JniObject {
  ReceiverCallNotAllowedException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ReceiverCallNotAllowedException_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String msg)
  ReceiverCallNotAllowedException(jni.JniString msg)
      : super.fromRef(_ctor(msg.reference)) {
    jni.Jni.env.checkException();
  }
}

/// from: android.content.SyncInfo
///
/// Information about the sync operation that is currently underway.
class SyncInfo extends jni.JniObject {
  SyncInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_account = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncInfo_account")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public final android.accounts.Account account
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The Account that is currently being synced.
  jni.JniObject get account => jni.JniObject.fromRef(_get_account(reference));

  static final _get_authority = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncInfo_authority")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public final java.lang.String authority
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The authority of the provider that is currently being synced.
  jni.JniString get authority =>
      jni.JniString.fromRef(_get_authority(reference));

  static final _get_startTime = jniLookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncInfo_startTime")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public final long startTime
  ///
  /// The start time of the current sync operation in milliseconds since boot.
  /// This is represented in elapsed real time.
  /// See android.os.SystemClock\#elapsedRealtime().
  int get startTime => _get_startTime(reference);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_SyncInfo_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.content.SyncInfo other)
  ///
  /// @hide
  SyncInfo(SyncInfo other) : super.fromRef(_ctor(other.reference)) {
    jni.Jni.env.checkException();
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SyncInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  ///
  /// @hide
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_SyncInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  ///
  /// @hide
  void writeToParcel(os_.Parcel parcel, int flags) {
    final result__ = _writeToParcel(reference, parcel.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.SyncStatusObserver
class SyncStatusObserver extends jni.JniObject {
  SyncStatusObserver.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _onStatusChanged = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_SyncStatusObserver_onStatusChanged")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void onStatusChanged(int which)
  void onStatusChanged(int which) {
    final result__ = _onStatusChanged(reference, which);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.AsyncQueryHandler
///
/// A helper class to help make handling asynchronous ContentResolver
/// queries easier.
class AsyncQueryHandler extends os_.Handler {
  AsyncQueryHandler.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor4 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_AsyncQueryHandler_ctor4")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.ContentResolver cr)
  AsyncQueryHandler.ctor4(ContentResolver cr)
      : super.fromRef(_ctor4(cr.reference)) {
    jni.Jni.env.checkException();
  }

  static final _createHandler = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_AsyncQueryHandler_createHandler")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected android.os.Handler createHandler(android.os.Looper looper)
  /// The returned object must be deleted after use, by calling the `delete` method.
  os_.Handler createHandler(os_.Looper looper) {
    final result__ =
        os_.Handler.fromRef(_createHandler(reference, looper.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startQuery = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_AsyncQueryHandler_startQuery")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startQuery(int token, java.lang.Object cookie, android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String orderBy)
  ///
  /// This method begins an asynchronous query. When the query is done
  /// \#onQueryComplete is called.
  ///@param token A token passed into \#onQueryComplete to identify
  ///  the query.
  ///@param cookie An object that gets passed into \#onQueryComplete
  ///@param uri The URI, using the content:// scheme, for the content to
  ///         retrieve.
  ///@param projection A list of which columns to return. Passing null will
  ///         return all columns, which is discouraged to prevent reading data
  ///         from storage that isn't going to be used.
  ///@param selection A filter declaring which rows to return, formatted as an
  ///         SQL WHERE clause (excluding the WHERE itself). Passing null will
  ///         return all rows for the given URI.
  ///@param selectionArgs You may include ?s in selection, which will be
  ///         replaced by the values from selectionArgs, in the order that they
  ///         appear in the selection. The values will be bound as Strings.
  ///@param orderBy How to order the rows, formatted as an SQL ORDER BY
  ///         clause (excluding the ORDER BY itself). Passing null will use the
  ///         default sort order, which may be unordered.
  void startQuery(
      int token,
      jni.JniObject cookie,
      jni.JniObject uri,
      jni.JniObject projection,
      jni.JniString selection,
      jni.JniObject selectionArgs,
      jni.JniString orderBy) {
    final result__ = _startQuery(
        reference,
        token,
        cookie.reference,
        uri.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        orderBy.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _cancelOperation = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_AsyncQueryHandler_cancelOperation")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void cancelOperation(int token)
  ///
  /// Attempts to cancel operation that has not already started. Note that
  /// there is no guarantee that the operation will be canceled. They still may
  /// result in a call to on[Query/Insert/Update/Delete]Complete after this
  /// call has completed.
  ///@param token The token representing the operation to be canceled.
  ///  If multiple operations have the same token they will all be canceled.
  void cancelOperation(int token) {
    final result__ = _cancelOperation(reference, token);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startInsert = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_AsyncQueryHandler_startInsert")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void startInsert(int token, java.lang.Object cookie, android.net.Uri uri, android.content.ContentValues initialValues)
  ///
  /// This method begins an asynchronous insert. When the insert operation is
  /// done \#onInsertComplete is called.
  ///@param token A token passed into \#onInsertComplete to identify
  ///  the insert operation.
  ///@param cookie An object that gets passed into \#onInsertComplete
  ///@param uri the Uri passed to the insert operation.
  ///@param initialValues the ContentValues parameter passed to the insert operation.
  void startInsert(int token, jni.JniObject cookie, jni.JniObject uri,
      ContentValues initialValues) {
    final result__ = _startInsert(reference, token, cookie.reference,
        uri.reference, initialValues.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startUpdate = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_AsyncQueryHandler_startUpdate")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void startUpdate(int token, java.lang.Object cookie, android.net.Uri uri, android.content.ContentValues values, java.lang.String selection, java.lang.String[] selectionArgs)
  ///
  /// This method begins an asynchronous update. When the update operation is
  /// done \#onUpdateComplete is called.
  ///@param token A token passed into \#onUpdateComplete to identify
  ///  the update operation.
  ///@param cookie An object that gets passed into \#onUpdateComplete
  ///@param uri the Uri passed to the update operation.
  ///@param values the ContentValues parameter passed to the update operation.
  void startUpdate(
      int token,
      jni.JniObject cookie,
      jni.JniObject uri,
      ContentValues values,
      jni.JniString selection,
      jni.JniObject selectionArgs) {
    final result__ = _startUpdate(
        reference,
        token,
        cookie.reference,
        uri.reference,
        values.reference,
        selection.reference,
        selectionArgs.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startDelete = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_AsyncQueryHandler_startDelete")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void startDelete(int token, java.lang.Object cookie, android.net.Uri uri, java.lang.String selection, java.lang.String[] selectionArgs)
  ///
  /// This method begins an asynchronous delete. When the delete operation is
  /// done \#onDeleteComplete is called.
  ///@param token A token passed into \#onDeleteComplete to identify
  ///  the delete operation.
  ///@param cookie An object that gets passed into \#onDeleteComplete
  ///@param uri the Uri passed to the delete operation.
  ///@param selection the where clause.
  void startDelete(int token, jni.JniObject cookie, jni.JniObject uri,
      jni.JniString selection, jni.JniObject selectionArgs) {
    final result__ = _startDelete(reference, token, cookie.reference,
        uri.reference, selection.reference, selectionArgs.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onQueryComplete = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_AsyncQueryHandler_onQueryComplete")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void onQueryComplete(int token, java.lang.Object cookie, android.database.Cursor cursor)
  ///
  /// Called when an asynchronous query is completed.
  ///@param token the token to identify the query, passed in from
  ///            \#startQuery.
  ///@param cookie the cookie object passed in from \#startQuery.
  ///@param cursor The cursor holding the results from the query.
  void onQueryComplete(int token, jni.JniObject cookie, jni.JniObject cursor) {
    final result__ =
        _onQueryComplete(reference, token, cookie.reference, cursor.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onInsertComplete = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_AsyncQueryHandler_onInsertComplete")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void onInsertComplete(int token, java.lang.Object cookie, android.net.Uri uri)
  ///
  /// Called when an asynchronous insert is completed.
  ///@param token the token to identify the query, passed in from
  ///        \#startInsert.
  ///@param cookie the cookie object that's passed in from
  ///        \#startInsert.
  ///@param uri the uri returned from the insert operation.
  void onInsertComplete(int token, jni.JniObject cookie, jni.JniObject uri) {
    final result__ =
        _onInsertComplete(reference, token, cookie.reference, uri.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onUpdateComplete = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_AsyncQueryHandler_onUpdateComplete")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: protected void onUpdateComplete(int token, java.lang.Object cookie, int result)
  ///
  /// Called when an asynchronous update is completed.
  ///@param token the token to identify the query, passed in from
  ///        \#startUpdate.
  ///@param cookie the cookie object that's passed in from
  ///        \#startUpdate.
  ///@param result the result returned from the update operation
  void onUpdateComplete(int token, jni.JniObject cookie, int result) {
    final result__ =
        _onUpdateComplete(reference, token, cookie.reference, result);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onDeleteComplete = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_AsyncQueryHandler_onDeleteComplete")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: protected void onDeleteComplete(int token, java.lang.Object cookie, int result)
  ///
  /// Called when an asynchronous delete is completed.
  ///@param token the token to identify the query, passed in from
  ///        \#startDelete.
  ///@param cookie the cookie object that's passed in from
  ///        \#startDelete.
  ///@param result the result returned from the delete operation
  void onDeleteComplete(int token, jni.JniObject cookie, int result) {
    final result__ =
        _onDeleteComplete(reference, token, cookie.reference, result);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _handleMessage = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_AsyncQueryHandler_handleMessage")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void handleMessage(android.os.Message msg)
  void handleMessage(os_.Message msg) {
    final result__ = _handleMessage(reference, msg.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.AsyncQueryHandler$WorkerHandler
class AsyncQueryHandler_WorkerHandler extends os_.Handler {
  AsyncQueryHandler_WorkerHandler.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor2 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_AsyncQueryHandler__WorkerHandler_ctor2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Looper looper)
  AsyncQueryHandler_WorkerHandler.ctor2(os_.Looper looper)
      : super.fromRef(_ctor2(looper.reference)) {
    jni.Jni.env.checkException();
  }

  static final _handleMessage = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_AsyncQueryHandler__WorkerHandler_handleMessage")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void handleMessage(android.os.Message msg)
  void handleMessage(os_.Message msg) {
    final result__ = _handleMessage(reference, msg.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.AsyncQueryHandler$WorkerArgs
class AsyncQueryHandler_WorkerArgs extends jni.JniObject {
  AsyncQueryHandler_WorkerArgs.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_cookie = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_AsyncQueryHandler__WorkerArgs_cookie")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public java.lang.Object cookie
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get cookie => jni.JniObject.fromRef(_get_cookie(reference));
  static final _set_cookie = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_AsyncQueryHandler__WorkerArgs_cookie")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object cookie
  /// The returned object must be deleted after use, by calling the `delete` method.
  set cookie(jni.JniObject value) => _set_cookie(reference, value.reference);

  static final _get_handler = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_AsyncQueryHandler__WorkerArgs_handler")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public android.os.Handler handler
  /// The returned object must be deleted after use, by calling the `delete` method.
  os_.Handler get handler => os_.Handler.fromRef(_get_handler(reference));
  static final _set_handler = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_AsyncQueryHandler__WorkerArgs_handler")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Handler handler
  /// The returned object must be deleted after use, by calling the `delete` method.
  set handler(os_.Handler value) => _set_handler(reference, value.reference);

  static final _get_orderBy = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_AsyncQueryHandler__WorkerArgs_orderBy")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public java.lang.String orderBy
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString get orderBy => jni.JniString.fromRef(_get_orderBy(reference));
  static final _set_orderBy = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_AsyncQueryHandler__WorkerArgs_orderBy")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String orderBy
  /// The returned object must be deleted after use, by calling the `delete` method.
  set orderBy(jni.JniString value) => _set_orderBy(reference, value.reference);

  static final _get_projection = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_AsyncQueryHandler__WorkerArgs_projection")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public java.lang.String[] projection
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get projection =>
      jni.JniObject.fromRef(_get_projection(reference));
  static final _set_projection = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_AsyncQueryHandler__WorkerArgs_projection")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] projection
  /// The returned object must be deleted after use, by calling the `delete` method.
  set projection(jni.JniObject value) =>
      _set_projection(reference, value.reference);

  static final _get_result = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_AsyncQueryHandler__WorkerArgs_result")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public java.lang.Object result
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get result => jni.JniObject.fromRef(_get_result(reference));
  static final _set_result = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_AsyncQueryHandler__WorkerArgs_result")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object result
  /// The returned object must be deleted after use, by calling the `delete` method.
  set result(jni.JniObject value) => _set_result(reference, value.reference);

  static final _get_selection = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_AsyncQueryHandler__WorkerArgs_selection")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public java.lang.String selection
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString get selection =>
      jni.JniString.fromRef(_get_selection(reference));
  static final _set_selection = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_AsyncQueryHandler__WorkerArgs_selection")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String selection
  /// The returned object must be deleted after use, by calling the `delete` method.
  set selection(jni.JniString value) =>
      _set_selection(reference, value.reference);

  static final _get_selectionArgs = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_AsyncQueryHandler__WorkerArgs_selectionArgs")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public java.lang.String[] selectionArgs
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get selectionArgs =>
      jni.JniObject.fromRef(_get_selectionArgs(reference));
  static final _set_selectionArgs = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_AsyncQueryHandler__WorkerArgs_selectionArgs")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] selectionArgs
  /// The returned object must be deleted after use, by calling the `delete` method.
  set selectionArgs(jni.JniObject value) =>
      _set_selectionArgs(reference, value.reference);

  static final _get_uri = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_AsyncQueryHandler__WorkerArgs_uri")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public android.net.Uri uri
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get uri => jni.JniObject.fromRef(_get_uri(reference));
  static final _set_uri = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_AsyncQueryHandler__WorkerArgs_uri")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri uri
  /// The returned object must be deleted after use, by calling the `delete` method.
  set uri(jni.JniObject value) => _set_uri(reference, value.reference);

  static final _get_values = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_AsyncQueryHandler__WorkerArgs_values")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public android.content.ContentValues values
  /// The returned object must be deleted after use, by calling the `delete` method.
  ContentValues get values => ContentValues.fromRef(_get_values(reference));
  static final _set_values = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_AsyncQueryHandler__WorkerArgs_values")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ContentValues values
  /// The returned object must be deleted after use, by calling the `delete` method.
  set values(ContentValues value) => _set_values(reference, value.reference);

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_AsyncQueryHandler__WorkerArgs_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: protected void <init>()
  AsyncQueryHandler_WorkerArgs() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }
}

/// from: android.content.AbstractThreadedSyncAdapter
///
/// An abstract implementation of a SyncAdapter that spawns a thread to invoke a sync operation.
/// If a sync operation is already in progress when a sync request is received, an error will be
/// returned to the new request and the existing request will be allowed to continue.
/// However if there is no sync in progress then a thread will be spawned and \#onPerformSync
/// will be invoked on that thread.
///
/// Syncs can be cancelled at any time by the framework. For example a sync that was not
/// user-initiated and lasts longer than 30 minutes will be considered timed-out and cancelled.
/// Similarly the framework will attempt to determine whether or not an adapter is making progress
/// by monitoring its network activity over the course of a minute. If the network traffic over this
/// window is close enough to zero the sync will be cancelled. You can also request the sync be
/// cancelled via ContentResolver\#cancelSync(Account, String) or
/// ContentResolver\#cancelSync(SyncRequest).
///
/// A sync is cancelled by issuing a Thread\#interrupt() on the syncing thread. <strong>Either
/// your code in \#onPerformSync(Account, Bundle, String, ContentProviderClient, SyncResult)
/// must check Thread\#interrupted(), or you you must override one of
/// \#onSyncCanceled(Thread)/\#onSyncCanceled()</strong> (depending on whether or not
/// your adapter supports syncing of multiple accounts in parallel). If your adapter does not
/// respect the cancel issued by the framework you run the risk of your app's entire process being
/// killed.
///
/// In order to be a sync adapter one must extend this class, provide implementations for the
/// abstract methods and write a service that returns the result of \#getSyncAdapterBinder()
/// in the service's android.app.Service\#onBind(android.content.Intent) when invoked
/// with an intent with action <code>android.content.SyncAdapter</code>. This service
/// must specify the following intent filter and metadata tags in its AndroidManifest.xml file
/// <pre>
///   &lt;intent-filter&gt;
///     &lt;action android:name="android.content.SyncAdapter" /&gt;
///   &lt;/intent-filter&gt;
///   &lt;meta-data android:name="android.content.SyncAdapter"
///             android:resource="@xml/syncadapter" /&gt;
/// </pre>
/// The <code>android:resource</code> attribute must point to a resource that looks like:
/// <pre>
/// &lt;sync-adapter xmlns:android="http://schemas.android.com/apk/res/android"
///    android:contentAuthority="authority"
///    android:accountType="accountType"
///    android:userVisible="true|false"
///    android:supportsUploading="true|false"
///    android:allowParallelSyncs="true|false"
///    android:isAlwaysSyncable="true|false"
///    android:syncAdapterSettingsAction="ACTION_OF_SETTINGS_ACTIVITY"
/// /&gt;
/// </pre>
/// <ul>
/// <li>The <code>android:contentAuthority</code> and <code>android:accountType</code> attributes
/// indicate which content authority and for which account types this sync adapter serves.
/// <li><code>android:userVisible</code> defaults to true and controls whether or not this sync
/// adapter shows up in the Sync Settings screen.
/// <li><code>android:supportsUploading</code> defaults
/// to true and if true an upload-only sync will be requested for all syncadapters associated
/// with an authority whenever that authority's content provider does a
/// ContentResolver\#notifyChange(android.net.Uri, android.database.ContentObserver, boolean)
/// with syncToNetwork set to true.
/// <li><code>android:allowParallelSyncs</code> defaults to false and if true indicates that
/// the sync adapter can handle syncs for multiple accounts at the same time. Otherwise
/// the SyncManager will wait until the sync adapter is not in use before requesting that
/// it sync an account's data.
/// <li><code>android:isAlwaysSyncable</code> defaults to false and if true tells the SyncManager
/// to intialize the isSyncable state to 1 for that sync adapter for each account that is added.
/// <li><code>android:syncAdapterSettingsAction</code> defaults to null and if supplied it
/// specifies an Intent action of an activity that can be used to adjust the sync adapter's
/// sync settings. The activity must live in the same package as the sync adapter.
/// </ul>
class AbstractThreadedSyncAdapter extends jni.JniObject {
  AbstractThreadedSyncAdapter.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final int LOG_SYNC_DETAILS
  ///
  /// Kernel event log tag.  Also listed in data/etc/event-log-tags.
  ///@deprecated Private constant.  May go away in the next release.
  static const LOG_SYNC_DETAILS = 2743;

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_content_AbstractThreadedSyncAdapter_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Context context, boolean autoInitialize)
  ///
  /// Creates an AbstractThreadedSyncAdapter.
  ///@param context the android.content.Context that this is running within.
  ///@param autoInitialize if true then sync requests that have
  /// ContentResolver\#SYNC_EXTRAS_INITIALIZE set will be internally handled by
  /// AbstractThreadedSyncAdapter by calling
  /// ContentResolver\#setIsSyncable(android.accounts.Account, String, int) with 1 if it
  /// is currently set to <0.
  AbstractThreadedSyncAdapter(Context context, bool autoInitialize)
      : super.fromRef(_ctor(context.reference, autoInitialize ? 1 : 0)) {
    jni.Jni.env.checkException();
  }

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8, ffi.Uint8)>>(
          "android_content_AbstractThreadedSyncAdapter_ctor1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void <init>(android.content.Context context, boolean autoInitialize, boolean allowParallelSyncs)
  ///
  /// Creates an AbstractThreadedSyncAdapter.
  ///@param context the android.content.Context that this is running within.
  ///@param autoInitialize if true then sync requests that have
  /// ContentResolver\#SYNC_EXTRAS_INITIALIZE set will be internally handled by
  /// AbstractThreadedSyncAdapter by calling
  /// ContentResolver\#setIsSyncable(android.accounts.Account, String, int) with 1 if it
  /// is currently set to <0.
  ///@param allowParallelSyncs if true then allow syncs for different accounts to run
  /// at the same time, each in their own thread. This must be consistent with the setting
  /// in the SyncAdapter's configuration file.
  AbstractThreadedSyncAdapter.ctor1(
      Context context, bool autoInitialize, bool allowParallelSyncs)
      : super.fromRef(_ctor1(context.reference, autoInitialize ? 1 : 0,
            allowParallelSyncs ? 1 : 0)) {
    jni.Jni.env.checkException();
  }

  static final _getContext = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_AbstractThreadedSyncAdapter_getContext")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Context getContext() {
    final result__ = Context.fromRef(_getContext(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSyncAdapterBinder = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_AbstractThreadedSyncAdapter_getSyncAdapterBinder")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.IBinder getSyncAdapterBinder()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return a reference to the IBinder of the SyncAdapter service.
  os_.IBinder getSyncAdapterBinder() {
    final result__ = os_.IBinder.fromRef(_getSyncAdapterBinder(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onUnsyncableAccount =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_AbstractThreadedSyncAdapter_onUnsyncableAccount")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onUnsyncableAccount()
  ///
  /// Allows to defer syncing until all accounts are properly set up.
  ///
  /// Called when a account / authority pair
  /// <ul>
  /// <li>that can be handled by this adapter</li>
  /// <li>ContentResolver\#requestSync(SyncRequest) is synced</li>
  /// <li>and the account/provider ContentResolver\#getIsSyncable(Account, String) has
  /// unknown state (<0).</li>
  /// </ul>
  ///
  /// This might be called on a different service connection as \#onPerformSync.
  ///
  /// The system expects this method to immediately return. If the call stalls the system
  /// behaves as if this method returned {@code true}. If it is required to perform a longer task
  /// (such as interacting with the user), return {@code false} and proceed in a difference
  /// context, such as an android.app.Activity, or foreground service. The sync can then be
  /// rescheduled once the account becomes syncable.
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  ///@return If {@code false} syncing is deferred. Returns {@code true} by default, i.e. by
  ///         default syncing starts immediately.
  bool onUnsyncableAccount() {
    final result__ = _onUnsyncableAccount(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onPerformSync = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_AbstractThreadedSyncAdapter_onPerformSync")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onPerformSync(android.accounts.Account account, android.os.Bundle extras, java.lang.String authority, android.content.ContentProviderClient provider, android.content.SyncResult syncResult)
  ///
  /// Perform a sync for this account. SyncAdapter-specific parameters may
  /// be specified in extras, which is guaranteed to not be null. Invocations
  /// of this method are guaranteed to be serialized.
  ///@param account the account that should be synced
  ///@param extras SyncAdapter-specific parameters
  ///@param authority the authority of this sync request
  ///@param provider a ContentProviderClient that points to the ContentProvider for this
  ///   authority
  ///@param syncResult SyncAdapter-specific parameters
  void onPerformSync(
      jni.JniObject account,
      os_.Bundle extras,
      jni.JniString authority,
      ContentProviderClient provider,
      SyncResult syncResult) {
    final result__ = _onPerformSync(
        reference,
        account.reference,
        extras.reference,
        authority.reference,
        provider.reference,
        syncResult.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onSecurityException = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_AbstractThreadedSyncAdapter_onSecurityException")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onSecurityException(android.accounts.Account account, android.os.Bundle extras, java.lang.String authority, android.content.SyncResult syncResult)
  ///
  /// Report that there was a security exception when opening the content provider
  /// prior to calling \#onPerformSync.  This will be treated as a sync
  /// database failure.
  ///@param account the account that attempted to sync
  ///@param extras SyncAdapter-specific parameters
  ///@param authority the authority of the failed sync request
  ///@param syncResult SyncAdapter-specific parameters
  void onSecurityException(jni.JniObject account, os_.Bundle extras,
      jni.JniString authority, SyncResult syncResult) {
    final result__ = _onSecurityException(reference, account.reference,
        extras.reference, authority.reference, syncResult.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onSyncCanceled =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_AbstractThreadedSyncAdapter_onSyncCanceled")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onSyncCanceled()
  ///
  /// Indicates that a sync operation has been canceled. This will be invoked on a separate
  /// thread than the sync thread and so you must consider the multi-threaded implications
  /// of the work that you do in this method.
  ///
  /// This will only be invoked when the SyncAdapter indicates that it doesn't support
  /// parallel syncs.
  void onSyncCanceled() {
    final result__ = _onSyncCanceled(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onSyncCanceled1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_AbstractThreadedSyncAdapter_onSyncCanceled1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onSyncCanceled(java.lang.Thread thread)
  ///
  /// Indicates that a sync operation has been canceled. This will be invoked on a separate
  /// thread than the sync thread and so you must consider the multi-threaded implications
  /// of the work that you do in this method.
  ///
  /// This will only be invoked when the SyncAdapter indicates that it does support
  /// parallel syncs.
  ///@param thread the Thread of the sync that is to be canceled.
  void onSyncCanceled1(jni.JniObject thread) {
    final result__ = _onSyncCanceled1(reference, thread.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.Entity
///
/// A representation of a item using ContentValues. It contains one top level ContentValue
/// plus a collection of Uri, ContentValues tuples as subvalues. One example of its use
/// is in Contacts, where the top level ContentValue contains the columns from the RawContacts
/// table and the subvalues contain a ContentValues object for each row from the Data table that
/// corresponds to that RawContact. The uri refers to the Data table uri for each row.
class Entity extends jni.JniObject {
  Entity.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Entity_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.ContentValues values)
  Entity(ContentValues values) : super.fromRef(_ctor(values.reference)) {
    jni.Jni.env.checkException();
  }

  static final _getEntityValues = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Entity_getEntityValues")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ContentValues getEntityValues()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ContentValues getEntityValues() {
    final result__ = ContentValues.fromRef(_getEntityValues(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSubValues = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Entity_getSubValues")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.ArrayList<android.content.Entity.NamedContentValues> getSubValues()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getSubValues() {
    final result__ = jni.JniObject.fromRef(_getSubValues(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _addSubValue = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Entity_addSubValue")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void addSubValue(android.net.Uri uri, android.content.ContentValues values)
  void addSubValue(jni.JniObject uri, ContentValues values) {
    final result__ = _addSubValue(reference, uri.reference, values.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Entity_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.Entity$NamedContentValues
class Entity_NamedContentValues extends jni.JniObject {
  Entity_NamedContentValues.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_uri = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_Entity__NamedContentValues_uri")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public final android.net.Uri uri
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get uri => jni.JniObject.fromRef(_get_uri(reference));

  static final _get_values = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_Entity__NamedContentValues_values")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public final android.content.ContentValues values
  /// The returned object must be deleted after use, by calling the `delete` method.
  ContentValues get values => ContentValues.fromRef(_get_values(reference));

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Entity__NamedContentValues_ctor")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.net.Uri uri, android.content.ContentValues values)
  Entity_NamedContentValues(jni.JniObject uri, ContentValues values)
      : super.fromRef(_ctor(uri.reference, values.reference)) {
    jni.Jni.env.checkException();
  }
}

/// from: android.content.ContextWrapper
///
/// Proxying implementation of Context that simply delegates all of its calls to
/// another Context.  Can be subclassed to modify behavior without changing
/// the original Context.
class ContextWrapper extends Context {
  ContextWrapper.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_ctor1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context base)
  ContextWrapper.ctor1(Context base) : super.fromRef(_ctor1(base.reference)) {
    jni.Jni.env.checkException();
  }

  static final _attachBaseContext = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_attachBaseContext")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void attachBaseContext(android.content.Context base)
  ///
  /// Set the base context for this ContextWrapper.  All calls will then be
  /// delegated to the base context.  Throws
  /// IllegalStateException if a base context has already been set.
  ///@param base The new base context for this wrapper.
  void attachBaseContext(Context base) {
    final result__ = _attachBaseContext(reference, base.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getBaseContext = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getBaseContext")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context getBaseContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the base context as set by the constructor or setBaseContext
  Context getBaseContext() {
    final result__ = Context.fromRef(_getBaseContext(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getAssets = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getAssets")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.AssetManager getAssets()
  /// The returned object must be deleted after use, by calling the `delete` method.
  res_.AssetManager getAssets() {
    final result__ = res_.AssetManager.fromRef(_getAssets(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getResources = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getResources")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.Resources getResources()
  /// The returned object must be deleted after use, by calling the `delete` method.
  res_.Resources getResources() {
    final result__ = res_.Resources.fromRef(_getResources(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPackageManager = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getPackageManager")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.PackageManager getPackageManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  pm_.PackageManager getPackageManager() {
    final result__ = pm_.PackageManager.fromRef(_getPackageManager(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getContentResolver = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getContentResolver")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ContentResolver getContentResolver()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ContentResolver getContentResolver() {
    final result__ = ContentResolver.fromRef(_getContentResolver(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getMainLooper = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getMainLooper")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Looper getMainLooper()
  /// The returned object must be deleted after use, by calling the `delete` method.
  os_.Looper getMainLooper() {
    final result__ = os_.Looper.fromRef(_getMainLooper(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getMainExecutor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getMainExecutor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.concurrent.Executor getMainExecutor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getMainExecutor() {
    final result__ = jni.JniObject.fromRef(_getMainExecutor(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getApplicationContext = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getApplicationContext")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context getApplicationContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Context getApplicationContext() {
    final result__ = Context.fromRef(_getApplicationContext(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setTheme = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_ContextWrapper_setTheme")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setTheme(int resid)
  void setTheme(int resid) {
    final result__ = _setTheme(reference, resid);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getTheme = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getTheme")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.Resources.Theme getTheme()
  /// The returned object must be deleted after use, by calling the `delete` method.
  res_.Resources_Theme getTheme() {
    final result__ = res_.Resources_Theme.fromRef(_getTheme(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getClassLoader = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getClassLoader")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.ClassLoader getClassLoader()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getClassLoader() {
    final result__ = jni.JniObject.fromRef(_getClassLoader(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPackageName = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getPackageName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPackageName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getPackageName() {
    final result__ = jni.JniString.fromRef(_getPackageName(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getApplicationInfo = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getApplicationInfo")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ApplicationInfo getApplicationInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  pm_.ApplicationInfo getApplicationInfo() {
    final result__ =
        pm_.ApplicationInfo.fromRef(_getApplicationInfo(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPackageResourcePath = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getPackageResourcePath")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPackageResourcePath()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getPackageResourcePath() {
    final result__ = jni.JniString.fromRef(_getPackageResourcePath(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPackageCodePath = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getPackageCodePath")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPackageCodePath()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getPackageCodePath() {
    final result__ = jni.JniString.fromRef(_getPackageCodePath(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSharedPreferences = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_ContextWrapper_getSharedPreferences")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.SharedPreferences getSharedPreferences(java.lang.String name, int mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  SharedPreferences getSharedPreferences(jni.JniString name, int mode) {
    final result__ = SharedPreferences.fromRef(
        _getSharedPreferences(reference, name.reference, mode));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _moveSharedPreferencesFrom = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_moveSharedPreferencesFrom")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean moveSharedPreferencesFrom(android.content.Context sourceContext, java.lang.String name)
  bool moveSharedPreferencesFrom(Context sourceContext, jni.JniString name) {
    final result__ = _moveSharedPreferencesFrom(
            reference, sourceContext.reference, name.reference) !=
        0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _deleteSharedPreferences = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_deleteSharedPreferences")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean deleteSharedPreferences(java.lang.String name)
  bool deleteSharedPreferences(jni.JniString name) {
    final result__ = _deleteSharedPreferences(reference, name.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openFileInput = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_openFileInput")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.FileInputStream openFileInput(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject openFileInput(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_openFileInput(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openFileOutput = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_ContextWrapper_openFileOutput")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.io.FileOutputStream openFileOutput(java.lang.String name, int mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject openFileOutput(jni.JniString name, int mode) {
    final result__ =
        jni.JniObject.fromRef(_openFileOutput(reference, name.reference, mode));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _deleteFile = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_deleteFile")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean deleteFile(java.lang.String name)
  bool deleteFile(jni.JniString name) {
    final result__ = _deleteFile(reference, name.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getFileStreamPath = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getFileStreamPath")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.File getFileStreamPath(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getFileStreamPath(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_getFileStreamPath(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _fileList = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_fileList")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] fileList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject fileList() {
    final result__ = jni.JniObject.fromRef(_fileList(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDataDir = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getDataDir")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.File getDataDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getDataDir() {
    final result__ = jni.JniObject.fromRef(_getDataDir(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getFilesDir = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getFilesDir")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.File getFilesDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getFilesDir() {
    final result__ = jni.JniObject.fromRef(_getFilesDir(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getNoBackupFilesDir = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getNoBackupFilesDir")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.File getNoBackupFilesDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getNoBackupFilesDir() {
    final result__ = jni.JniObject.fromRef(_getNoBackupFilesDir(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getExternalFilesDir = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getExternalFilesDir")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.File getExternalFilesDir(java.lang.String type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getExternalFilesDir(jni.JniString type) {
    final result__ =
        jni.JniObject.fromRef(_getExternalFilesDir(reference, type.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getExternalFilesDirs = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getExternalFilesDirs")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.File[] getExternalFilesDirs(java.lang.String type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getExternalFilesDirs(jni.JniString type) {
    final result__ =
        jni.JniObject.fromRef(_getExternalFilesDirs(reference, type.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getObbDir = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getObbDir")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.File getObbDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getObbDir() {
    final result__ = jni.JniObject.fromRef(_getObbDir(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getObbDirs = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getObbDirs")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.File[] getObbDirs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getObbDirs() {
    final result__ = jni.JniObject.fromRef(_getObbDirs(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getCacheDir = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getCacheDir")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.File getCacheDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getCacheDir() {
    final result__ = jni.JniObject.fromRef(_getCacheDir(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getCodeCacheDir = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getCodeCacheDir")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.File getCodeCacheDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getCodeCacheDir() {
    final result__ = jni.JniObject.fromRef(_getCodeCacheDir(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getExternalCacheDir = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getExternalCacheDir")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.File getExternalCacheDir()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getExternalCacheDir() {
    final result__ = jni.JniObject.fromRef(_getExternalCacheDir(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getExternalCacheDirs = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getExternalCacheDirs")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.File[] getExternalCacheDirs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getExternalCacheDirs() {
    final result__ = jni.JniObject.fromRef(_getExternalCacheDirs(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getExternalMediaDirs = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getExternalMediaDirs")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.File[] getExternalMediaDirs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getExternalMediaDirs() {
    final result__ = jni.JniObject.fromRef(_getExternalMediaDirs(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDir = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_ContextWrapper_getDir")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.io.File getDir(java.lang.String name, int mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getDir(jni.JniString name, int mode) {
    final result__ =
        jni.JniObject.fromRef(_getDir(reference, name.reference, mode));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openOrCreateDatabase = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_openOrCreateDatabase")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.database.sqlite.SQLiteDatabase openOrCreateDatabase(java.lang.String name, int mode, android.database.sqlite.SQLiteDatabase.CursorFactory factory)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject openOrCreateDatabase(
      jni.JniString name, int mode, jni.JniObject factory0) {
    final result__ = jni.JniObject.fromRef(_openOrCreateDatabase(
        reference, name.reference, mode, factory0.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openOrCreateDatabase1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_openOrCreateDatabase1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.database.sqlite.SQLiteDatabase openOrCreateDatabase(java.lang.String name, int mode, android.database.sqlite.SQLiteDatabase.CursorFactory factory, android.database.DatabaseErrorHandler errorHandler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject openOrCreateDatabase1(jni.JniString name, int mode,
      jni.JniObject factory0, jni.JniObject errorHandler) {
    final result__ = jni.JniObject.fromRef(_openOrCreateDatabase1(reference,
        name.reference, mode, factory0.reference, errorHandler.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _moveDatabaseFrom = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_moveDatabaseFrom")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean moveDatabaseFrom(android.content.Context sourceContext, java.lang.String name)
  bool moveDatabaseFrom(Context sourceContext, jni.JniString name) {
    final result__ =
        _moveDatabaseFrom(reference, sourceContext.reference, name.reference) !=
            0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _deleteDatabase = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_deleteDatabase")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean deleteDatabase(java.lang.String name)
  bool deleteDatabase(jni.JniString name) {
    final result__ = _deleteDatabase(reference, name.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDatabasePath = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getDatabasePath")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.File getDatabasePath(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getDatabasePath(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_getDatabasePath(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _databaseList = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_databaseList")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] databaseList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject databaseList() {
    final result__ = jni.JniObject.fromRef(_databaseList(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getWallpaper = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getWallpaper")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable getWallpaper()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getWallpaper() {
    final result__ = jni.JniObject.fromRef(_getWallpaper(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _peekWallpaper = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_peekWallpaper")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable peekWallpaper()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject peekWallpaper() {
    final result__ = jni.JniObject.fromRef(_peekWallpaper(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getWallpaperDesiredMinimumWidth =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContextWrapper_getWallpaperDesiredMinimumWidth")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getWallpaperDesiredMinimumWidth()
  int getWallpaperDesiredMinimumWidth() {
    final result__ = _getWallpaperDesiredMinimumWidth(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getWallpaperDesiredMinimumHeight =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContextWrapper_getWallpaperDesiredMinimumHeight")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getWallpaperDesiredMinimumHeight()
  int getWallpaperDesiredMinimumHeight() {
    final result__ = _getWallpaperDesiredMinimumHeight(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setWallpaper = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_setWallpaper")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setWallpaper(android.graphics.Bitmap bitmap)
  void setWallpaper(jni.JniObject bitmap) {
    final result__ = _setWallpaper(reference, bitmap.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setWallpaper1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_setWallpaper1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setWallpaper(java.io.InputStream data)
  void setWallpaper1(jni.JniObject data) {
    final result__ = _setWallpaper1(reference, data.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _clearWallpaper =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContextWrapper_clearWallpaper")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void clearWallpaper()
  void clearWallpaper() {
    final result__ = _clearWallpaper(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startActivity = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_startActivity")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivity(android.content.Intent intent)
  void startActivity(Intent intent) {
    final result__ = _startActivity(reference, intent.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startActivity1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_startActivity1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivity(android.content.Intent intent, android.os.Bundle options)
  void startActivity1(Intent intent, os_.Bundle options) {
    final result__ =
        _startActivity1(reference, intent.reference, options.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startActivities = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_startActivities")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivities(android.content.Intent[] intents)
  void startActivities(jni.JniObject intents) {
    final result__ = _startActivities(reference, intents.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startActivities1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_startActivities1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivities(android.content.Intent[] intents, android.os.Bundle options)
  void startActivities1(jni.JniObject intents, os_.Bundle options) {
    final result__ =
        _startActivities1(reference, intents.reference, options.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startIntentSender = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32)>>(
          "android_content_ContextWrapper_startIntentSender")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void startIntentSender(android.content.IntentSender intent, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)
  void startIntentSender(IntentSender intent, Intent fillInIntent,
      int flagsMask, int flagsValues, int extraFlags) {
    final result__ = _startIntentSender(reference, intent.reference,
        fillInIntent.reference, flagsMask, flagsValues, extraFlags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startIntentSender1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_startIntentSender1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void startIntentSender(android.content.IntentSender intent, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, android.os.Bundle options)
  void startIntentSender1(IntentSender intent, Intent fillInIntent,
      int flagsMask, int flagsValues, int extraFlags, os_.Bundle options) {
    final result__ = _startIntentSender1(
        reference,
        intent.reference,
        fillInIntent.reference,
        flagsMask,
        flagsValues,
        extraFlags,
        options.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendBroadcast = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_sendBroadcast")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void sendBroadcast(android.content.Intent intent)
  void sendBroadcast(Intent intent) {
    final result__ = _sendBroadcast(reference, intent.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendBroadcast1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_sendBroadcast1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void sendBroadcast(android.content.Intent intent, java.lang.String receiverPermission)
  void sendBroadcast1(Intent intent, jni.JniString receiverPermission) {
    final result__ = _sendBroadcast1(
        reference, intent.reference, receiverPermission.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendOrderedBroadcast = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_sendOrderedBroadcast")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void sendOrderedBroadcast(android.content.Intent intent, java.lang.String receiverPermission)
  void sendOrderedBroadcast(Intent intent, jni.JniString receiverPermission) {
    final result__ = _sendOrderedBroadcast(
        reference, intent.reference, receiverPermission.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendOrderedBroadcast1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_sendOrderedBroadcast1")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void sendOrderedBroadcast(android.content.Intent intent, java.lang.String receiverPermission, android.content.BroadcastReceiver resultReceiver, android.os.Handler scheduler, int initialCode, java.lang.String initialData, android.os.Bundle initialExtras)
  void sendOrderedBroadcast1(
      Intent intent,
      jni.JniString receiverPermission,
      BroadcastReceiver resultReceiver,
      os_.Handler scheduler,
      int initialCode,
      jni.JniString initialData,
      os_.Bundle initialExtras) {
    final result__ = _sendOrderedBroadcast1(
        reference,
        intent.reference,
        receiverPermission.reference,
        resultReceiver.reference,
        scheduler.reference,
        initialCode,
        initialData.reference,
        initialExtras.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendBroadcastAsUser = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_sendBroadcastAsUser")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void sendBroadcastAsUser(android.content.Intent intent, android.os.UserHandle user)
  void sendBroadcastAsUser(Intent intent, os_.UserHandle user) {
    final result__ =
        _sendBroadcastAsUser(reference, intent.reference, user.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendBroadcastAsUser1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_sendBroadcastAsUser1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void sendBroadcastAsUser(android.content.Intent intent, android.os.UserHandle user, java.lang.String receiverPermission)
  void sendBroadcastAsUser1(
      Intent intent, os_.UserHandle user, jni.JniString receiverPermission) {
    final result__ = _sendBroadcastAsUser1(reference, intent.reference,
        user.reference, receiverPermission.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendOrderedBroadcastAsUser = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_sendOrderedBroadcastAsUser")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void sendOrderedBroadcastAsUser(android.content.Intent intent, android.os.UserHandle user, java.lang.String receiverPermission, android.content.BroadcastReceiver resultReceiver, android.os.Handler scheduler, int initialCode, java.lang.String initialData, android.os.Bundle initialExtras)
  void sendOrderedBroadcastAsUser(
      Intent intent,
      os_.UserHandle user,
      jni.JniString receiverPermission,
      BroadcastReceiver resultReceiver,
      os_.Handler scheduler,
      int initialCode,
      jni.JniString initialData,
      os_.Bundle initialExtras) {
    final result__ = _sendOrderedBroadcastAsUser(
        reference,
        intent.reference,
        user.reference,
        receiverPermission.reference,
        resultReceiver.reference,
        scheduler.reference,
        initialCode,
        initialData.reference,
        initialExtras.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendStickyBroadcast = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_sendStickyBroadcast")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void sendStickyBroadcast(android.content.Intent intent)
  void sendStickyBroadcast(Intent intent) {
    final result__ = _sendStickyBroadcast(reference, intent.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendStickyOrderedBroadcast = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_sendStickyOrderedBroadcast")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void sendStickyOrderedBroadcast(android.content.Intent intent, android.content.BroadcastReceiver resultReceiver, android.os.Handler scheduler, int initialCode, java.lang.String initialData, android.os.Bundle initialExtras)
  void sendStickyOrderedBroadcast(
      Intent intent,
      BroadcastReceiver resultReceiver,
      os_.Handler scheduler,
      int initialCode,
      jni.JniString initialData,
      os_.Bundle initialExtras) {
    final result__ = _sendStickyOrderedBroadcast(
        reference,
        intent.reference,
        resultReceiver.reference,
        scheduler.reference,
        initialCode,
        initialData.reference,
        initialExtras.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _removeStickyBroadcast = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_removeStickyBroadcast")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void removeStickyBroadcast(android.content.Intent intent)
  void removeStickyBroadcast(Intent intent) {
    final result__ = _removeStickyBroadcast(reference, intent.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendStickyBroadcastAsUser = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_sendStickyBroadcastAsUser")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void sendStickyBroadcastAsUser(android.content.Intent intent, android.os.UserHandle user)
  void sendStickyBroadcastAsUser(Intent intent, os_.UserHandle user) {
    final result__ =
        _sendStickyBroadcastAsUser(reference, intent.reference, user.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendStickyOrderedBroadcastAsUser = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_sendStickyOrderedBroadcastAsUser")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void sendStickyOrderedBroadcastAsUser(android.content.Intent intent, android.os.UserHandle user, android.content.BroadcastReceiver resultReceiver, android.os.Handler scheduler, int initialCode, java.lang.String initialData, android.os.Bundle initialExtras)
  void sendStickyOrderedBroadcastAsUser(
      Intent intent,
      os_.UserHandle user,
      BroadcastReceiver resultReceiver,
      os_.Handler scheduler,
      int initialCode,
      jni.JniString initialData,
      os_.Bundle initialExtras) {
    final result__ = _sendStickyOrderedBroadcastAsUser(
        reference,
        intent.reference,
        user.reference,
        resultReceiver.reference,
        scheduler.reference,
        initialCode,
        initialData.reference,
        initialExtras.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _removeStickyBroadcastAsUser = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_removeStickyBroadcastAsUser")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void removeStickyBroadcastAsUser(android.content.Intent intent, android.os.UserHandle user)
  void removeStickyBroadcastAsUser(Intent intent, os_.UserHandle user) {
    final result__ = _removeStickyBroadcastAsUser(
        reference, intent.reference, user.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _registerReceiver = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_registerReceiver")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent registerReceiver(android.content.BroadcastReceiver receiver, android.content.IntentFilter filter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) {
    final result__ = Intent.fromRef(
        _registerReceiver(reference, receiver.reference, filter.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _registerReceiver1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32)>>(
          "android_content_ContextWrapper_registerReceiver1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.Intent registerReceiver(android.content.BroadcastReceiver receiver, android.content.IntentFilter filter, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Intent registerReceiver1(
      BroadcastReceiver receiver, IntentFilter filter, int flags) {
    final result__ = Intent.fromRef(_registerReceiver1(
        reference, receiver.reference, filter.reference, flags));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _registerReceiver2 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_registerReceiver2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent registerReceiver(android.content.BroadcastReceiver receiver, android.content.IntentFilter filter, java.lang.String broadcastPermission, android.os.Handler scheduler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Intent registerReceiver2(BroadcastReceiver receiver, IntentFilter filter,
      jni.JniString broadcastPermission, os_.Handler scheduler) {
    final result__ = Intent.fromRef(_registerReceiver2(
        reference,
        receiver.reference,
        filter.reference,
        broadcastPermission.reference,
        scheduler.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _registerReceiver3 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32)>>(
          "android_content_ContextWrapper_registerReceiver3")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int)>();

  /// from: public android.content.Intent registerReceiver(android.content.BroadcastReceiver receiver, android.content.IntentFilter filter, java.lang.String broadcastPermission, android.os.Handler scheduler, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Intent registerReceiver3(BroadcastReceiver receiver, IntentFilter filter,
      jni.JniString broadcastPermission, os_.Handler scheduler, int flags) {
    final result__ = Intent.fromRef(_registerReceiver3(
        reference,
        receiver.reference,
        filter.reference,
        broadcastPermission.reference,
        scheduler.reference,
        flags));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _unregisterReceiver = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_unregisterReceiver")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterReceiver(android.content.BroadcastReceiver receiver)
  void unregisterReceiver(BroadcastReceiver receiver) {
    final result__ = _unregisterReceiver(reference, receiver.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startService = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_startService")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName startService(android.content.Intent service)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ComponentName startService(Intent service) {
    final result__ =
        ComponentName.fromRef(_startService(reference, service.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startForegroundService = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_startForegroundService")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName startForegroundService(android.content.Intent service)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ComponentName startForegroundService(Intent service) {
    final result__ = ComponentName.fromRef(
        _startForegroundService(reference, service.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _stopService = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_stopService")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean stopService(android.content.Intent name)
  bool stopService(Intent name) {
    final result__ = _stopService(reference, name.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _bindService = jniLookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_ContextWrapper_bindService")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean bindService(android.content.Intent service, android.content.ServiceConnection conn, int flags)
  bool bindService(Intent service, ServiceConnection conn, int flags) {
    final result__ =
        _bindService(reference, service.reference, conn.reference, flags) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _unbindService = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_unbindService")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unbindService(android.content.ServiceConnection conn)
  void unbindService(ServiceConnection conn) {
    final result__ = _unbindService(reference, conn.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startInstrumentation = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_startInstrumentation")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean startInstrumentation(android.content.ComponentName className, java.lang.String profileFile, android.os.Bundle arguments)
  bool startInstrumentation(ComponentName className, jni.JniString profileFile,
      os_.Bundle arguments) {
    final result__ = _startInstrumentation(reference, className.reference,
            profileFile.reference, arguments.reference) !=
        0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSystemService = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getSystemService")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object getSystemService(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getSystemService(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_getSystemService(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSystemServiceName = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_getSystemServiceName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSystemServiceName(java.lang.Class<?> serviceClass)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getSystemServiceName(jni.JniObject serviceClass) {
    final result__ = jni.JniString.fromRef(
        _getSystemServiceName(reference, serviceClass.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _checkPermission = jniLookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32)>>("android_content_ContextWrapper_checkPermission")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int checkPermission(java.lang.String permission, int pid, int uid)
  int checkPermission(jni.JniString permission, int pid, int uid) {
    final result__ =
        _checkPermission(reference, permission.reference, pid, uid);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _checkCallingPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_checkCallingPermission")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int checkCallingPermission(java.lang.String permission)
  int checkCallingPermission(jni.JniString permission) {
    final result__ = _checkCallingPermission(reference, permission.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _checkCallingOrSelfPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_checkCallingOrSelfPermission")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int checkCallingOrSelfPermission(java.lang.String permission)
  int checkCallingOrSelfPermission(jni.JniString permission) {
    final result__ =
        _checkCallingOrSelfPermission(reference, permission.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _checkSelfPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_checkSelfPermission")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int checkSelfPermission(java.lang.String permission)
  int checkSelfPermission(jni.JniString permission) {
    final result__ = _checkSelfPermission(reference, permission.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _enforcePermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_enforcePermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void enforcePermission(java.lang.String permission, int pid, int uid, java.lang.String message)
  void enforcePermission(
      jni.JniString permission, int pid, int uid, jni.JniString message) {
    final result__ = _enforcePermission(
        reference, permission.reference, pid, uid, message.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _enforceCallingPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_enforceCallingPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void enforceCallingPermission(java.lang.String permission, java.lang.String message)
  void enforceCallingPermission(
      jni.JniString permission, jni.JniString message) {
    final result__ = _enforceCallingPermission(
        reference, permission.reference, message.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _enforceCallingOrSelfPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_enforceCallingOrSelfPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void enforceCallingOrSelfPermission(java.lang.String permission, java.lang.String message)
  void enforceCallingOrSelfPermission(
      jni.JniString permission, jni.JniString message) {
    final result__ = _enforceCallingOrSelfPermission(
        reference, permission.reference, message.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _grantUriPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32)>>(
          "android_content_ContextWrapper_grantUriPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void grantUriPermission(java.lang.String toPackage, android.net.Uri uri, int modeFlags)
  void grantUriPermission(
      jni.JniString toPackage, jni.JniObject uri, int modeFlags) {
    final result__ = _grantUriPermission(
        reference, toPackage.reference, uri.reference, modeFlags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _revokeUriPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_ContextWrapper_revokeUriPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void revokeUriPermission(android.net.Uri uri, int modeFlags)
  void revokeUriPermission(jni.JniObject uri, int modeFlags) {
    final result__ = _revokeUriPermission(reference, uri.reference, modeFlags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _revokeUriPermission1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32)>>(
          "android_content_ContextWrapper_revokeUriPermission1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void revokeUriPermission(java.lang.String targetPackage, android.net.Uri uri, int modeFlags)
  void revokeUriPermission1(
      jni.JniString targetPackage, jni.JniObject uri, int modeFlags) {
    final result__ = _revokeUriPermission1(
        reference, targetPackage.reference, uri.reference, modeFlags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _checkUriPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32, ffi.Int32)>>(
          "android_content_ContextWrapper_checkUriPermission")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public int checkUriPermission(android.net.Uri uri, int pid, int uid, int modeFlags)
  int checkUriPermission(jni.JniObject uri, int pid, int uid, int modeFlags) {
    final result__ =
        _checkUriPermission(reference, uri.reference, pid, uid, modeFlags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _checkCallingUriPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_ContextWrapper_checkCallingUriPermission")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public int checkCallingUriPermission(android.net.Uri uri, int modeFlags)
  int checkCallingUriPermission(jni.JniObject uri, int modeFlags) {
    final result__ =
        _checkCallingUriPermission(reference, uri.reference, modeFlags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _checkCallingOrSelfUriPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_ContextWrapper_checkCallingOrSelfUriPermission")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public int checkCallingOrSelfUriPermission(android.net.Uri uri, int modeFlags)
  int checkCallingOrSelfUriPermission(jni.JniObject uri, int modeFlags) {
    final result__ =
        _checkCallingOrSelfUriPermission(reference, uri.reference, modeFlags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _checkUriPermission1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32)>>(
          "android_content_ContextWrapper_checkUriPermission1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public int checkUriPermission(android.net.Uri uri, java.lang.String readPermission, java.lang.String writePermission, int pid, int uid, int modeFlags)
  int checkUriPermission1(jni.JniObject uri, jni.JniString readPermission,
      jni.JniString writePermission, int pid, int uid, int modeFlags) {
    final result__ = _checkUriPermission1(
        reference,
        uri.reference,
        readPermission.reference,
        writePermission.reference,
        pid,
        uid,
        modeFlags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _enforceUriPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_enforceUriPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public void enforceUriPermission(android.net.Uri uri, int pid, int uid, int modeFlags, java.lang.String message)
  void enforceUriPermission(jni.JniObject uri, int pid, int uid, int modeFlags,
      jni.JniString message) {
    final result__ = _enforceUriPermission(
        reference, uri.reference, pid, uid, modeFlags, message.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _enforceCallingUriPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_enforceCallingUriPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void enforceCallingUriPermission(android.net.Uri uri, int modeFlags, java.lang.String message)
  void enforceCallingUriPermission(
      jni.JniObject uri, int modeFlags, jni.JniString message) {
    final result__ = _enforceCallingUriPermission(
        reference, uri.reference, modeFlags, message.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _enforceCallingOrSelfUriPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_enforceCallingOrSelfUriPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void enforceCallingOrSelfUriPermission(android.net.Uri uri, int modeFlags, java.lang.String message)
  void enforceCallingOrSelfUriPermission(
      jni.JniObject uri, int modeFlags, jni.JniString message) {
    final result__ = _enforceCallingOrSelfUriPermission(
        reference, uri.reference, modeFlags, message.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _enforceUriPermission1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_enforceUriPermission1")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void enforceUriPermission(android.net.Uri uri, java.lang.String readPermission, java.lang.String writePermission, int pid, int uid, int modeFlags, java.lang.String message)
  void enforceUriPermission1(
      jni.JniObject uri,
      jni.JniString readPermission,
      jni.JniString writePermission,
      int pid,
      int uid,
      int modeFlags,
      jni.JniString message) {
    final result__ = _enforceUriPermission1(
        reference,
        uri.reference,
        readPermission.reference,
        writePermission.reference,
        pid,
        uid,
        modeFlags,
        message.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _createPackageContext = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_ContextWrapper_createPackageContext")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.Context createPackageContext(java.lang.String packageName, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Context createPackageContext(jni.JniString packageName, int flags) {
    final result__ = Context.fromRef(
        _createPackageContext(reference, packageName.reference, flags));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _createContextForSplit = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_createContextForSplit")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context createContextForSplit(java.lang.String splitName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  Context createContextForSplit(jni.JniString splitName) {
    final result__ =
        Context.fromRef(_createContextForSplit(reference, splitName.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _createConfigurationContext = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_createConfigurationContext")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context createConfigurationContext(android.content.res.Configuration overrideConfiguration)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Context createConfigurationContext(res_.Configuration overrideConfiguration) {
    final result__ = Context.fromRef(_createConfigurationContext(
        reference, overrideConfiguration.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _createDisplayContext = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_createDisplayContext")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context createDisplayContext(android.view.Display display)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Context createDisplayContext(jni.JniObject display) {
    final result__ =
        Context.fromRef(_createDisplayContext(reference, display.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isRestricted =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContextWrapper_isRestricted")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isRestricted()
  bool isRestricted() {
    final result__ = _isRestricted(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _createDeviceProtectedStorageContext = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContextWrapper_createDeviceProtectedStorageContext")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context createDeviceProtectedStorageContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Context createDeviceProtectedStorageContext() {
    final result__ =
        Context.fromRef(_createDeviceProtectedStorageContext(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isDeviceProtectedStorage =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContextWrapper_isDeviceProtectedStorage")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isDeviceProtectedStorage()
  bool isDeviceProtectedStorage() {
    final result__ = _isDeviceProtectedStorage(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.AsyncTaskLoader
///
/// Abstract Loader that provides an AsyncTask to do the work.  See
/// Loader and android.app.LoaderManager for more details.
///
/// Here is an example implementation of an AsyncTaskLoader subclass that
/// loads the currently installed applications from the package manager.  This
/// implementation takes care of retrieving the application labels and sorting
/// its result set from them, monitoring for changes to the installed
/// applications, and rebuilding the list when a change in configuration requires
/// this (such as a locale change).
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/LoaderCustom.java
///      loader}
///
/// An example implementation of a fragment that uses the above loader to show
/// the currently installed applications in a list is below.
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/LoaderCustom.java
///      fragment}
///@param <D> the data type to be loaded.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.content.AsyncTaskLoader
class AsyncTaskLoader extends Loader {
  AsyncTaskLoader.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_AsyncTaskLoader_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  AsyncTaskLoader(Context context) : super.fromRef(_ctor(context.reference)) {
    jni.Jni.env.checkException();
  }

  static final _setUpdateThrottle = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "android_content_AsyncTaskLoader_setUpdateThrottle")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setUpdateThrottle(long delayMS)
  ///
  /// Set amount to throttle updates by.  This is the minimum time from
  /// when the last \#loadInBackground() call has completed until
  /// a new load is scheduled.
  ///@param delayMS Amount of delay, in milliseconds.
  void setUpdateThrottle(int delayMS) {
    final result__ = _setUpdateThrottle(reference, delayMS);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onForceLoad =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_AsyncTaskLoader_onForceLoad")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onForceLoad()
  void onForceLoad() {
    final result__ = _onForceLoad(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onCancelLoad =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_AsyncTaskLoader_onCancelLoad")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected boolean onCancelLoad()
  bool onCancelLoad() {
    final result__ = _onCancelLoad(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _cancelLoadInBackground =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_AsyncTaskLoader_cancelLoadInBackground")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void cancelLoadInBackground()
  ///
  /// Called on the main thread to abort a load in progress.
  ///
  /// Override this method to abort the current invocation of \#loadInBackground
  /// that is running in the background on a worker thread.
  ///
  /// This method should do nothing if \#loadInBackground has not started
  /// running or if it has already finished.
  ///@see \#loadInBackground
  void cancelLoadInBackground() {
    final result__ = _cancelLoadInBackground(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isLoadInBackgroundCanceled =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_AsyncTaskLoader_isLoadInBackgroundCanceled")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isLoadInBackgroundCanceled()
  ///
  /// Returns true if the current invocation of \#loadInBackground is being canceled.
  ///@return True if the current invocation of \#loadInBackground is being canceled.
  ///@see \#loadInBackground
  bool isLoadInBackgroundCanceled() {
    final result__ = _isLoadInBackgroundCanceled(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _dump = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_AsyncTaskLoader_dump")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  void dump(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
      jni.JniObject args) {
    final result__ = _dump(reference, prefix.reference, fd.reference,
        writer.reference, args.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.UriMatcher
///
/// Utility class to aid in matching URIs in content providers.
///
/// To use this class, build up a tree of <code>UriMatcher</code> objects.
/// For example:
/// <pre>
///    private static final int PEOPLE = 1;
///    private static final int PEOPLE_ID = 2;
///    private static final int PEOPLE_PHONES = 3;
///    private static final int PEOPLE_PHONES_ID = 4;
///    private static final int PEOPLE_CONTACTMETHODS = 7;
///    private static final int PEOPLE_CONTACTMETHODS_ID = 8;
///
///    private static final int DELETED_PEOPLE = 20;
///
///    private static final int PHONES = 9;
///    private static final int PHONES_ID = 10;
///    private static final int PHONES_FILTER = 14;
///
///    private static final int CONTACTMETHODS = 18;
///    private static final int CONTACTMETHODS_ID = 19;
///
///    private static final int CALLS = 11;
///    private static final int CALLS_ID = 12;
///    private static final int CALLS_FILTER = 15;
///
///    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
///
///    static
///    {
///        sURIMatcher.addURI("contacts", "people", PEOPLE);
///        sURIMatcher.addURI("contacts", "people/\#", PEOPLE_ID);
///        sURIMatcher.addURI("contacts", "people/\#/phones", PEOPLE_PHONES);
///        sURIMatcher.addURI("contacts", "people/\#/phones/\#", PEOPLE_PHONES_ID);
///        sURIMatcher.addURI("contacts", "people/\#/contact_methods", PEOPLE_CONTACTMETHODS);
///        sURIMatcher.addURI("contacts", "people/\#/contact_methods/\#", PEOPLE_CONTACTMETHODS_ID);
///        sURIMatcher.addURI("contacts", "deleted_people", DELETED_PEOPLE);
///        sURIMatcher.addURI("contacts", "phones", PHONES);
///        sURIMatcher.addURI("contacts", "phones/filter/*", PHONES_FILTER);
///        sURIMatcher.addURI("contacts", "phones/\#", PHONES_ID);
///        sURIMatcher.addURI("contacts", "contact_methods", CONTACTMETHODS);
///        sURIMatcher.addURI("contacts", "contact_methods/\#", CONTACTMETHODS_ID);
///        sURIMatcher.addURI("call_log", "calls", CALLS);
///        sURIMatcher.addURI("call_log", "calls/filter/*", CALLS_FILTER);
///        sURIMatcher.addURI("call_log", "calls/\#", CALLS_ID);
///    }
/// </pre>
/// Starting from API level android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2, paths can start
/// with a leading slash.  For example:
/// <pre>
///        sURIMatcher.addURI("contacts", "/people", PEOPLE);
/// </pre>
/// Then when you need to match against a URI, call \#match, providing
/// the URL that you have been given.  You can use the result to build a query,
/// return a type, insert or delete a row, or whatever you need, without duplicating
/// all of the if-else logic that you would otherwise need.  For example:
/// <pre>
///    public String getType(Uri url)
///    {
///        int match = sURIMatcher.match(url);
///        switch (match)
///        {
///            case PEOPLE:
///                return "vnd.android.cursor.dir/person";
///            case PEOPLE_ID:
///                return "vnd.android.cursor.item/person";
/// ... snip ...
///                return "vnd.android.cursor.dir/snail-mail";
///            case PEOPLE_ADDRESS_ID:
///                return "vnd.android.cursor.item/snail-mail";
///            default:
///                return null;
///        }
///    }
/// </pre>
/// instead of:
/// <pre>
///    public String getType(Uri url)
///    {
///        List<String> pathSegments = url.getPathSegments();
///        if (pathSegments.size() >= 2) {
///            if ("people".equals(pathSegments.get(1))) {
///                if (pathSegments.size() == 2) {
///                    return "vnd.android.cursor.dir/person";
///                } else if (pathSegments.size() == 3) {
///                    return "vnd.android.cursor.item/person";
/// ... snip ...
///                    return "vnd.android.cursor.dir/snail-mail";
///                } else if (pathSegments.size() == 3) {
///                    return "vnd.android.cursor.item/snail-mail";
///                }
///            }
///        }
///        return null;
///    }
/// </pre>
class UriMatcher extends jni.JniObject {
  UriMatcher.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int NO_MATCH
  static const NO_MATCH = -1;

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int32)>>(
              "android_content_UriMatcher_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: public void <init>(int code)
  ///
  /// Creates the root node of the URI tree.
  ///@param code the code to match for the root URI
  UriMatcher(int code) : super.fromRef(_ctor(code)) {
    jni.Jni.env.checkException();
  }

  static final _addURI = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_UriMatcher_addURI")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void addURI(java.lang.String authority, java.lang.String path, int code)
  ///
  /// Add a URI to match, and the code to return when this URI is
  /// matched. URI nodes may be exact match string, the token "*"
  /// that matches any text, or the token "\#" that matches only
  /// numbers.
  ///
  /// Starting from API level android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2,
  /// this method will accept a leading slash in the path.
  ///@param authority the authority to match
  ///@param path the path to match. * may be used as a wild card for
  /// any text, and \# may be used as a wild card for numbers.
  ///@param code the code that is returned when a URI is matched
  /// against the given components. Must be positive.
  void addURI(jni.JniString authority, jni.JniString path, int code) {
    final result__ =
        _addURI(reference, authority.reference, path.reference, code);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _match = jniLookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_UriMatcher_match")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int match(android.net.Uri uri)
  ///
  /// Try to match against the path in a url.
  ///@param uri The url whose path we will match against.
  ///@return The code for the matched node (added using addURI),
  /// or -1 if there is no matched node.
  int match(jni.JniObject uri) {
    final result__ = _match(reference, uri.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.ComponentName
///
/// Identifier for a specific application component
/// (android.app.Activity, android.app.Service,
/// android.content.BroadcastReceiver, or
/// android.content.ContentProvider) that is available.  Two
/// pieces of information, encapsulated here, are required to identify
/// a component: the package (a String) it exists in, and the class (a String)
/// name inside of that package.
class ComponentName extends jni.JniObject {
  ComponentName.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_ComponentName_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.ComponentName> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_ComponentName_ctor")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String pkg, java.lang.String cls)
  ///
  /// Create a new component identifier.
  ///@param pkg The name of the package that the component exists in.  Can
  /// not be null.
  /// This value must never be {@code null}.
  ///@param cls The name of the class inside of <var>pkg</var> that
  /// implements the component.  Can not be null.
  ///
  /// This value must never be {@code null}.
  ComponentName(jni.JniString pkg, jni.JniString cls)
      : super.fromRef(_ctor(pkg.reference, cls.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentName_ctor1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context pkg, java.lang.String cls)
  ///
  /// Create a new component identifier from a Context and class name.
  ///@param pkg A Context for the package implementing the component,
  /// from which the actual package name will be retrieved.
  /// This value must never be {@code null}.
  ///@param cls The name of the class inside of <var>pkg</var> that
  /// implements the component.
  ///
  /// This value must never be {@code null}.
  ComponentName.ctor1(Context pkg, jni.JniString cls)
      : super.fromRef(_ctor1(pkg.reference, cls.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor2 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentName_ctor2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context pkg, java.lang.Class<?> cls)
  ///
  /// Create a new component identifier from a Context and Class object.
  ///@param pkg A Context for the package implementing the component, from
  /// which the actual package name will be retrieved.
  /// This value must never be {@code null}.
  ///@param cls The Class object of the desired component, from which the
  /// actual class name will be retrieved.
  ///
  /// This value must never be {@code null}.
  ComponentName.ctor2(Context pkg, jni.JniObject cls)
      : super.fromRef(_ctor2(pkg.reference, cls.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor3 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentName_ctor3")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel in)
  ///
  /// Instantiate a new ComponentName from the data in a Parcel that was
  /// previously written with \#writeToParcel(Parcel, int).  Note that you
  /// must not use this with data written by
  /// \#writeToParcel(ComponentName, Parcel) since it is not possible
  /// to handle a null ComponentObject here.
  ///@param in The Parcel containing the previously written ComponentName,
  /// positioned at the location in the buffer where it was written.
  ComponentName.ctor3(os_.Parcel in0) : super.fromRef(_ctor3(in0.reference)) {
    jni.Jni.env.checkException();
  }

  static final _createRelative = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentName_createRelative")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.ComponentName createRelative(java.lang.String pkg, java.lang.String cls)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new component identifier where the class name may be specified
  /// as either absolute or relative to the containing package.
  ///
  /// Relative package names begin with a <code>'.'</code> character. For a package
  /// <code>"com.example"</code> and class name <code>".app.MyActivity"</code> this method
  /// will return a ComponentName with the package <code>"com.example"</code>and class name
  /// <code>"com.example.app.MyActivity"</code>. Fully qualified class names are also
  /// permitted.
  ///
  ///@param pkg the name of the package the component exists in
  /// This value must never be {@code null}.
  ///@param cls the name of the class inside of <var>pkg</var> that implements
  ///            the component
  /// This value must never be {@code null}.
  ///@return the new ComponentName
  ///
  /// This value will never be {@code null}.
  static ComponentName createRelative(jni.JniString pkg, jni.JniString cls) {
    final result__ =
        ComponentName.fromRef(_createRelative(pkg.reference, cls.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _createRelative1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentName_createRelative1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.ComponentName createRelative(android.content.Context pkg, java.lang.String cls)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new component identifier where the class name may be specified
  /// as either absolute or relative to the containing package.
  ///
  /// Relative package names begin with a <code>'.'</code> character. For a package
  /// <code>"com.example"</code> and class name <code>".app.MyActivity"</code> this method
  /// will return a ComponentName with the package <code>"com.example"</code>and class name
  /// <code>"com.example.app.MyActivity"</code>. Fully qualified class names are also
  /// permitted.
  ///
  ///@param pkg a Context for the package implementing the component
  /// This value must never be {@code null}.
  ///@param cls the name of the class inside of <var>pkg</var> that implements
  ///            the component
  /// This value must never be {@code null}.
  ///@return the new ComponentName
  ///
  /// This value will never be {@code null}.
  static ComponentName createRelative1(Context pkg, jni.JniString cls) {
    final result__ =
        ComponentName.fromRef(_createRelative1(pkg.reference, cls.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _clone = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentName_clone")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ComponentName clone() {
    final result__ = ComponentName.fromRef(_clone(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPackageName = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentName_getPackageName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPackageName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the package name of this component.
  ///@return This value will never be {@code null}.
  jni.JniString getPackageName() {
    final result__ = jni.JniString.fromRef(_getPackageName(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getClassName = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentName_getClassName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the class name of this component.
  ///@return This value will never be {@code null}.
  jni.JniString getClassName() {
    final result__ = jni.JniString.fromRef(_getClassName(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getShortClassName = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentName_getShortClassName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getShortClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the class name, either fully qualified or in a shortened form
  /// (with a leading '.') if it is a suffix of the package.
  jni.JniString getShortClassName() {
    final result__ = jni.JniString.fromRef(_getShortClassName(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _flattenToString = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentName_flattenToString")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String flattenToString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a String that unambiguously describes both the package and
  /// class names contained in the ComponentName.  You can later recover
  /// the ComponentName from this string through
  /// \#unflattenFromString(String).
  ///@return Returns a new String holding the package and class names.  This
  /// is represented as the package name, concatenated with a '/' and then the
  /// class name.
  ///
  /// This value will never be {@code null}.
  ///@see \#unflattenFromString(String)
  jni.JniString flattenToString() {
    final result__ = jni.JniString.fromRef(_flattenToString(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _flattenToShortString = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentName_flattenToShortString")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String flattenToShortString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The same as \#flattenToString(), but abbreviates the class
  /// name if it is a suffix of the package.  The result can still be used
  /// with \#unflattenFromString(String).
  ///@return Returns a new String holding the package and class names.  This
  /// is represented as the package name, concatenated with a '/' and then the
  /// class name.
  ///
  /// This value will never be {@code null}.
  ///@see \#unflattenFromString(String)
  jni.JniString flattenToShortString() {
    final result__ = jni.JniString.fromRef(_flattenToShortString(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _unflattenFromString = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentName_unflattenFromString")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.ComponentName unflattenFromString(java.lang.String str)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Recover a ComponentName from a String that was previously created with
  /// \#flattenToString().  It splits the string at the first '/',
  /// taking the part before as the package name and the part after as the
  /// class name.  As a special convenience (to use, for example, when
  /// parsing component names on the command line), if the '/' is immediately
  /// followed by a '.' then the final class name will be the concatenation
  /// of the package name with the string following the '/'.  Thus
  /// "com.foo/.Blah" becomes package="com.foo" class="com.foo.Blah".
  ///@param str The String that was returned by flattenToString().
  /// This value must never be {@code null}.
  ///@return Returns a new ComponentName containing the package and class
  /// names that were encoded in <var>str</var>
  ///
  /// This value may be {@code null}.
  ///@see \#flattenToString()
  static ComponentName unflattenFromString(jni.JniString str) {
    final result__ = ComponentName.fromRef(_unflattenFromString(str.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toShortString = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentName_toShortString")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toShortString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return string representation of this class without the class's name
  /// as a prefix.
  jni.JniString toShortString() {
    final result__ = jni.JniString.fromRef(_toShortString(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentName_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _equals1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentName_equals1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object obj)
  bool equals1(jni.JniObject obj) {
    final result__ = _equals1(reference, obj.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hashCode1 =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ComponentName_hashCode1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    final result__ = _hashCode1(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _compareTo = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentName_compareTo")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int compareTo(android.content.ComponentName that)
  int compareTo(ComponentName that) {
    final result__ = _compareTo(reference, that.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ComponentName_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_ComponentName_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os_.Parcel out, int flags) {
    final result__ = _writeToParcel(reference, out.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentName_writeToParcel1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void writeToParcel(android.content.ComponentName c, android.os.Parcel out)
  ///
  /// Write a ComponentName to a Parcel, handling null pointers.  Must be
  /// read with \#readFromParcel(Parcel).
  ///@param c The ComponentName to be written.
  ///@param out The Parcel in which the ComponentName will be placed.
  ///@see \#readFromParcel(Parcel)
  static void writeToParcel1(ComponentName c, os_.Parcel out) {
    final result__ = _writeToParcel1(c.reference, out.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _readFromParcel = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ComponentName_readFromParcel")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.ComponentName readFromParcel(android.os.Parcel in)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Read a ComponentName from a Parcel that was previously written
  /// with \#writeToParcel(ComponentName, Parcel), returning either
  /// a null or new object as appropriate.
  ///@param in The Parcel from which to read the ComponentName
  ///@return Returns a new ComponentName matching the previously written
  /// object, or null if a null had been written.
  ///@see \#writeToParcel(ComponentName, Parcel)
  static ComponentName readFromParcel(os_.Parcel in0) {
    final result__ = ComponentName.fromRef(_readFromParcel(in0.reference));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.SyncAdapterType
///
/// Value type that represents a SyncAdapterType. This object overrides \#equals and
/// \#hashCode, making it suitable for use as the key of a java.util.Map
class SyncAdapterType extends jni.JniObject {
  SyncAdapterType.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_SyncAdapterType_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.SyncAdapterType> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  static final _get_accountType = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncAdapterType_accountType")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public final java.lang.String accountType
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString get accountType =>
      jni.JniString.fromRef(_get_accountType(reference));

  static final _get_authority = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncAdapterType_authority")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public final java.lang.String authority
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString get authority =>
      jni.JniString.fromRef(_get_authority(reference));

  static final _get_isKey = jniLookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncAdapterType_isKey")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public final boolean isKey
  bool get isKey => _get_isKey(reference) != 0;

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Uint8)>>("android_content_SyncAdapterType_ctor")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void <init>(java.lang.String authority, java.lang.String accountType, boolean userVisible, boolean supportsUploading)
  SyncAdapterType(jni.JniString authority, jni.JniString accountType,
      bool userVisible, bool supportsUploading)
      : super.fromRef(_ctor(authority.reference, accountType.reference,
            userVisible ? 1 : 0, supportsUploading ? 1 : 0)) {
    jni.Jni.env.checkException();
  }

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_SyncAdapterType_ctor1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel source)
  SyncAdapterType.ctor1(os_.Parcel source)
      : super.fromRef(_ctor1(source.reference)) {
    jni.Jni.env.checkException();
  }

  static final _supportsUploading =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SyncAdapterType_supportsUploading")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean supportsUploading()
  bool supportsUploading() {
    final result__ = _supportsUploading(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isUserVisible =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SyncAdapterType_isUserVisible")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isUserVisible()
  bool isUserVisible() {
    final result__ = _isUserVisible(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _allowParallelSyncs =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SyncAdapterType_allowParallelSyncs")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean allowParallelSyncs()
  ///
  /// @return True if this SyncAdapter supports syncing multiple accounts simultaneously.
  /// If false then the SyncManager will take care to only start one sync at a time
  /// using this SyncAdapter.
  bool allowParallelSyncs() {
    final result__ = _allowParallelSyncs(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isAlwaysSyncable =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SyncAdapterType_isAlwaysSyncable")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isAlwaysSyncable()
  ///
  /// If true then the SyncManager will never issue an initialization sync to the SyncAdapter
  /// and will instead automatically call
  /// ContentResolver\#setIsSyncable(android.accounts.Account, String, int) with a
  /// value of 1 for each account and provider that this sync adapter supports.
  ///@return true if the SyncAdapter does not require initialization and if it is ok for the
  /// SyncAdapter to treat it as syncable automatically.
  bool isAlwaysSyncable() {
    final result__ = _isAlwaysSyncable(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSettingsActivity = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_SyncAdapterType_getSettingsActivity")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSettingsActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The activity to use to invoke this SyncAdapter's settings activity.
  /// May be null.
  jni.JniString getSettingsActivity() {
    final result__ = jni.JniString.fromRef(_getSettingsActivity(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _newKey = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_SyncAdapterType_newKey")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.SyncAdapterType newKey(java.lang.String authority, java.lang.String accountType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static SyncAdapterType newKey(
      jni.JniString authority, jni.JniString accountType) {
    final result__ = SyncAdapterType.fromRef(
        _newKey(authority.reference, accountType.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _equals1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_SyncAdapterType_equals1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) {
    final result__ = _equals1(reference, o.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hashCode1 =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SyncAdapterType_hashCode1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    final result__ = _hashCode1(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_SyncAdapterType_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SyncAdapterType_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_SyncAdapterType_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) {
    final result__ = _writeToParcel(reference, dest.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.PeriodicSync
///
/// Value type that contains information about a periodic sync.
class PeriodicSync extends jni.JniObject {
  PeriodicSync.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_PeriodicSync_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.PeriodicSync> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  static final _get_account = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_PeriodicSync_account")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public final android.accounts.Account account
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The account to be synced. Can be null.
  jni.JniObject get account => jni.JniObject.fromRef(_get_account(reference));

  static final _get_authority = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_PeriodicSync_authority")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public final java.lang.String authority
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The authority of the sync. Can be null.
  jni.JniString get authority =>
      jni.JniString.fromRef(_get_authority(reference));

  static final _get_extras = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_PeriodicSync_extras")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public final android.os.Bundle extras
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Any extras that parameters that are to be passed to the sync adapter.
  os_.Bundle get extras => os_.Bundle.fromRef(_get_extras(reference));

  static final _get_period = jniLookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_PeriodicSync_period")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public final long period
  ///
  /// How frequently the sync should be scheduled, in seconds. Kept around for API purposes.
  int get period => _get_period(reference);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_content_PeriodicSync_ctor")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.accounts.Account account, java.lang.String authority, android.os.Bundle extras, long periodInSeconds)
  ///
  /// Creates a new PeriodicSync, copying the Bundle. This constructor is no longer used.
  PeriodicSync(jni.JniObject account, jni.JniString authority,
      os_.Bundle extras, int periodInSeconds)
      : super.fromRef(_ctor(account.reference, authority.reference,
            extras.reference, periodInSeconds)) {
    jni.Jni.env.checkException();
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_PeriodicSync_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_PeriodicSync_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) {
    final result__ = _writeToParcel(reference, dest.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _equals1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_PeriodicSync_equals1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) {
    final result__ = _equals1(reference, o.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_PeriodicSync_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.OperationApplicationException
///
/// Thrown when an application of a ContentProviderOperation fails due the specified
/// constraints.
class OperationApplicationException extends jni.JniObject {
  OperationApplicationException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_OperationApplicationException_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  OperationApplicationException() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_OperationApplicationException_ctor1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String message)
  OperationApplicationException.ctor1(jni.JniString message)
      : super.fromRef(_ctor1(message.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor2 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_OperationApplicationException_ctor2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String message, java.lang.Throwable cause)
  OperationApplicationException.ctor2(
      jni.JniString message, jni.JniObject cause)
      : super.fromRef(_ctor2(message.reference, cause.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor3 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_OperationApplicationException_ctor3")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.Throwable cause)
  OperationApplicationException.ctor3(jni.JniObject cause)
      : super.fromRef(_ctor3(cause.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor4 =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int32)>>(
              "android_content_OperationApplicationException_ctor4")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: public void <init>(int numSuccessfulYieldPoints)
  OperationApplicationException.ctor4(int numSuccessfulYieldPoints)
      : super.fromRef(_ctor4(numSuccessfulYieldPoints)) {
    jni.Jni.env.checkException();
  }

  static final _ctor5 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_OperationApplicationException_ctor5")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String message, int numSuccessfulYieldPoints)
  OperationApplicationException.ctor5(
      jni.JniString message, int numSuccessfulYieldPoints)
      : super.fromRef(_ctor5(message.reference, numSuccessfulYieldPoints)) {
    jni.Jni.env.checkException();
  }

  static final _getNumSuccessfulYieldPoints = jniLookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_OperationApplicationException_getNumSuccessfulYieldPoints")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getNumSuccessfulYieldPoints()
  int getNumSuccessfulYieldPoints() {
    final result__ = _getNumSuccessfulYieldPoints(reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.IntentSender
///
/// A description of an Intent and target action to perform with it.
/// The returned object can be
/// handed to other applications so that they can perform the action you
/// described on your behalf at a later time.
///
/// By giving a IntentSender to another application,
/// you are granting it the right to perform the operation you have specified
/// as if the other application was yourself (with the same permissions and
/// identity).  As such, you should be careful about how you build the IntentSender:
/// often, for example, the base Intent you supply will have the component
/// name explicitly set to one of your own components, to ensure it is ultimately
/// sent there and nowhere else.
///
/// A IntentSender itself is simply a reference to a token maintained by
/// the system describing the original data used to retrieve it.  This means
/// that, even if its owning application's process is killed, the
/// IntentSender itself will remain usable from other processes that
/// have been given it.  If the creating application later re-retrieves the
/// same kind of IntentSender (same operation, same Intent action, data,
/// categories, and components, and same flags), it will receive a IntentSender
/// representing the same token if that is still valid.
///
/// Instances of this class can not be made directly, but rather must be
/// created from an existing android.app.PendingIntent with
/// android.app.PendingIntent\#getIntentSender() PendingIntent.getIntentSender().
class IntentSender extends jni.JniObject {
  IntentSender.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_IntentSender_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.IntentSender> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_IntentSender_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.IBinder target)
  ///
  /// @hide
  IntentSender(os_.IBinder target) : super.fromRef(_ctor(target.reference)) {
    jni.Jni.env.checkException();
  }

  static final _sendIntent = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentSender_sendIntent")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void sendIntent(android.content.Context context, int code, android.content.Intent intent, android.content.IntentSender.OnFinished onFinished, android.os.Handler handler)
  ///
  /// Perform the operation associated with this IntentSender, allowing the
  /// caller to specify information about the Intent to use and be notified
  /// when the send has completed.
  ///@param context The Context of the caller.  This may be null if
  /// <var>intent</var> is also null.
  ///@param code Result code to supply back to the IntentSender's target.
  ///@param intent Additional Intent data.  See Intent\#fillIn Intent.fillIn() for information on how this is applied to the
  /// original Intent.  Use null to not modify the original Intent.
  ///@param onFinished The object to call back on when the send has
  /// completed, or null for no callback.
  ///@param handler Handler identifying the thread on which the callback
  /// should happen.  If null, the callback will happen from the thread
  /// pool of the process.
  ///@throws SendIntentException Throws CanceledIntentException if the IntentSender
  /// is no longer allowing more intents to be sent through it.
  void sendIntent(Context context, int code, Intent intent,
      IntentSender_OnFinished onFinished, os_.Handler handler) {
    final result__ = _sendIntent(reference, context.reference, code,
        intent.reference, onFinished.reference, handler.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _sendIntent1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentSender_sendIntent1")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void sendIntent(android.content.Context context, int code, android.content.Intent intent, android.content.IntentSender.OnFinished onFinished, android.os.Handler handler, java.lang.String requiredPermission)
  ///
  /// Perform the operation associated with this IntentSender, allowing the
  /// caller to specify information about the Intent to use and be notified
  /// when the send has completed.
  ///@param context The Context of the caller.  This may be null if
  /// <var>intent</var> is also null.
  ///@param code Result code to supply back to the IntentSender's target.
  ///@param intent Additional Intent data.  See Intent\#fillIn Intent.fillIn() for information on how this is applied to the
  /// original Intent.  Use null to not modify the original Intent.
  ///@param onFinished The object to call back on when the send has
  /// completed, or null for no callback.
  ///@param handler Handler identifying the thread on which the callback
  /// should happen.  If null, the callback will happen from the thread
  /// pool of the process.
  ///@param requiredPermission Name of permission that a recipient of the PendingIntent
  /// is required to hold.  This is only valid for broadcast intents, and
  /// corresponds to the permission argument in
  /// Context\#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String).
  /// If null, no permission is required.
  ///@throws SendIntentException Throws CanceledIntentException if the IntentSender
  /// is no longer allowing more intents to be sent through it.
  void sendIntent1(
      Context context,
      int code,
      Intent intent,
      IntentSender_OnFinished onFinished,
      os_.Handler handler,
      jni.JniString requiredPermission) {
    final result__ = _sendIntent1(
        reference,
        context.reference,
        code,
        intent.reference,
        onFinished.reference,
        handler.reference,
        requiredPermission.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getTargetPackage = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentSender_getTargetPackage")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getTargetPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Renamed to \#getCreatorPackage().
  jni.JniString getTargetPackage() {
    final result__ = jni.JniString.fromRef(_getTargetPackage(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getCreatorPackage = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentSender_getCreatorPackage")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getCreatorPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the package name of the application that created this
  /// IntentSender, that is the identity under which you will actually be
  /// sending the Intent.  The returned string is supplied by the system, so
  /// that an application can not spoof its package.
  ///@return The package name of the PendingIntent, or null if there is
  /// none associated with it.
  jni.JniString getCreatorPackage() {
    final result__ = jni.JniString.fromRef(_getCreatorPackage(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getCreatorUid =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_IntentSender_getCreatorUid")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getCreatorUid()
  ///
  /// Return the uid of the application that created this
  /// PendingIntent, that is the identity under which you will actually be
  /// sending the Intent.  The returned integer is supplied by the system, so
  /// that an application can not spoof its uid.
  ///@return The uid of the PendingIntent, or -1 if there is
  /// none associated with it.
  int getCreatorUid() {
    final result__ = _getCreatorUid(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getCreatorUserHandle = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentSender_getCreatorUserHandle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.UserHandle getCreatorUserHandle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the user handle of the application that created this
  /// PendingIntent, that is the user under which you will actually be
  /// sending the Intent.  The returned UserHandle is supplied by the system, so
  /// that an application can not spoof its user.  See
  /// android.os.Process\#myUserHandle() Process.myUserHandle() for
  /// more explanation of user handles.
  ///@return The user handle of the PendingIntent, or null if there is
  /// none associated with it.
  os_.UserHandle getCreatorUserHandle() {
    final result__ = os_.UserHandle.fromRef(_getCreatorUserHandle(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _equals1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentSender_equals1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object otherObj)
  ///
  /// Comparison operator on two IntentSender objects, such that true
  /// is returned then they both represent the same operation from the
  /// same package.
  bool equals1(jni.JniObject otherObj) {
    final result__ = _equals1(reference, otherObj.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hashCode1 =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_IntentSender_hashCode1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    final result__ = _hashCode1(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentSender_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_IntentSender_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_IntentSender_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os_.Parcel out, int flags) {
    final result__ = _writeToParcel(reference, out.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeIntentSenderOrNullToParcel = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentSender_writeIntentSenderOrNullToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void writeIntentSenderOrNullToParcel(android.content.IntentSender sender, android.os.Parcel out)
  ///
  /// Convenience function for writing either a IntentSender or null pointer to
  /// a Parcel.  You must use this with \#readIntentSenderOrNullFromParcel
  /// for later reading it.
  ///@param sender The IntentSender to write, or null.
  ///@param out Where to write the IntentSender.
  static void writeIntentSenderOrNullToParcel(
      IntentSender sender, os_.Parcel out) {
    final result__ =
        _writeIntentSenderOrNullToParcel(sender.reference, out.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _readIntentSenderOrNullFromParcel = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentSender_readIntentSenderOrNullFromParcel")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.IntentSender readIntentSenderOrNullFromParcel(android.os.Parcel in)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience function for reading either a Messenger or null pointer from
  /// a Parcel.  You must have previously written the Messenger with
  /// \#writeIntentSenderOrNullToParcel.
  ///@param in The Parcel containing the written Messenger.
  ///@return Returns the Messenger read from the Parcel, or null if null had
  /// been written.
  static IntentSender readIntentSenderOrNullFromParcel(os_.Parcel in0) {
    final result__ =
        IntentSender.fromRef(_readIntentSenderOrNullFromParcel(in0.reference));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.IntentSender$SendIntentException
///
/// Exception thrown when trying to send through a PendingIntent that
/// has been canceled or is otherwise no longer able to execute the request.
class IntentSender_SendIntentException extends jni.JniObject {
  IntentSender_SendIntentException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_IntentSender__SendIntentException_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  IntentSender_SendIntentException() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentSender__SendIntentException_ctor1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String name)
  IntentSender_SendIntentException.ctor1(jni.JniString name)
      : super.fromRef(_ctor1(name.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor2 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentSender__SendIntentException_ctor2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.Exception cause)
  IntentSender_SendIntentException.ctor2(jni.JniObject cause)
      : super.fromRef(_ctor2(cause.reference)) {
    jni.Jni.env.checkException();
  }
}

/// from: android.content.IntentSender$OnFinished
///
/// Callback interface for discovering when a send operation has
/// completed.  Primarily for use with a IntentSender that is
/// performing a broadcast, this provides the same information as
/// calling Context\#sendOrderedBroadcast(Intent, String,
/// android.content.BroadcastReceiver, Handler, int, String, Bundle) Context.sendBroadcast() with a final BroadcastReceiver.
class IntentSender_OnFinished extends jni.JniObject {
  IntentSender_OnFinished.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onSendFinished = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_IntentSender__OnFinished_onSendFinished")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onSendFinished(android.content.IntentSender IntentSender, android.content.Intent intent, int resultCode, java.lang.String resultData, android.os.Bundle resultExtras)
  ///
  /// Called when a send operation as completed.
  ///@param IntentSender The IntentSender this operation was sent through.
  ///@param intent The original Intent that was sent.
  ///@param resultCode The final result code determined by the send.
  ///@param resultData The final data collected by a broadcast.
  ///@param resultExtras The final extras collected by a broadcast.
  void onSendFinished(IntentSender IntentSender, Intent intent, int resultCode,
      jni.JniString resultData, os_.Bundle resultExtras) {
    final result__ = _onSendFinished(
        reference,
        IntentSender.reference,
        intent.reference,
        resultCode,
        resultData.reference,
        resultExtras.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.SyncResult
///
/// This class is used to communicate the results of a sync operation to the SyncManager.
/// Based on the values here the SyncManager will determine the disposition of the
/// sync and whether or not a new sync operation needs to be scheduled in the future.
class SyncResult extends jni.JniObject {
  SyncResult.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_ALREADY_IN_PROGRESS =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_SyncResult_ALREADY_IN_PROGRESS")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.content.SyncResult ALREADY_IN_PROGRESS
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This instance of a SyncResult is returned by the SyncAdapter in response to a
  /// sync request when a sync is already underway. The SyncManager will reschedule the
  /// sync request to try again later.
  static SyncResult get ALREADY_IN_PROGRESS =>
      SyncResult.fromRef(_get_ALREADY_IN_PROGRESS());

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_SyncResult_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.SyncResult> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  static final _get_databaseError = jniLookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncResult_databaseError")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public boolean databaseError
  ///
  /// Used to indicate that the SyncAdapter experienced a hard error due to an error it
  /// received from interacting with the storage layer. The SyncManager will record that
  /// the sync request failed and it will not reschedule the request.
  bool get databaseError => _get_databaseError(reference) != 0;
  static final _set_databaseError = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("set_android_content_SyncResult_databaseError")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean databaseError
  ///
  /// Used to indicate that the SyncAdapter experienced a hard error due to an error it
  /// received from interacting with the storage layer. The SyncManager will record that
  /// the sync request failed and it will not reschedule the request.
  set databaseError(bool value) => _set_databaseError(reference, value ? 1 : 0);

  static final _get_delayUntil = jniLookup<
          ffi.NativeFunction<
              ffi.Int64 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncResult_delayUntil")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public long delayUntil
  ///
  /// Used to indicate to the SyncManager that future sync requests that match the request's
  /// Account and authority should be delayed until a time in seconds since Java epoch.
  ///
  /// For example, if you want to delay the next sync for at least 5 minutes, then:
  /// <pre>
  /// result.delayUntil = (System.currentTimeMillis() / 1000) + 5 * 60;
  /// </pre>
  ///
  /// By default, when a sync fails, the system retries later with an exponential back-off
  /// with the system default initial delay time, which always wins over \#delayUntil --
  /// i.e. if the system back-off time is larger than \#delayUntil, \#delayUntil
  /// will essentially be ignored.
  int get delayUntil => _get_delayUntil(reference);
  static final _set_delayUntil = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("set_android_content_SyncResult_delayUntil")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public long delayUntil
  ///
  /// Used to indicate to the SyncManager that future sync requests that match the request's
  /// Account and authority should be delayed until a time in seconds since Java epoch.
  ///
  /// For example, if you want to delay the next sync for at least 5 minutes, then:
  /// <pre>
  /// result.delayUntil = (System.currentTimeMillis() / 1000) + 5 * 60;
  /// </pre>
  ///
  /// By default, when a sync fails, the system retries later with an exponential back-off
  /// with the system default initial delay time, which always wins over \#delayUntil --
  /// i.e. if the system back-off time is larger than \#delayUntil, \#delayUntil
  /// will essentially be ignored.
  set delayUntil(int value) => _set_delayUntil(reference, value);

  static final _get_fullSyncRequested = jniLookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncResult_fullSyncRequested")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public boolean fullSyncRequested
  ///
  /// If set the SyncManager will request an immediate sync with the same Account and authority
  /// (but empty extras Bundle) as was used in the sync request.
  bool get fullSyncRequested => _get_fullSyncRequested(reference) != 0;
  static final _set_fullSyncRequested = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_android_content_SyncResult_fullSyncRequested")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean fullSyncRequested
  ///
  /// If set the SyncManager will request an immediate sync with the same Account and authority
  /// (but empty extras Bundle) as was used in the sync request.
  set fullSyncRequested(bool value) =>
      _set_fullSyncRequested(reference, value ? 1 : 0);

  static final _get_moreRecordsToGet = jniLookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncResult_moreRecordsToGet")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public boolean moreRecordsToGet
  ///
  /// This field is ignored by the SyncManager.
  bool get moreRecordsToGet => _get_moreRecordsToGet(reference) != 0;
  static final _set_moreRecordsToGet = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_android_content_SyncResult_moreRecordsToGet")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean moreRecordsToGet
  ///
  /// This field is ignored by the SyncManager.
  set moreRecordsToGet(bool value) =>
      _set_moreRecordsToGet(reference, value ? 1 : 0);

  static final _get_partialSyncUnavailable = jniLookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncResult_partialSyncUnavailable")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public boolean partialSyncUnavailable
  ///
  /// This field is ignored by the SyncManager.
  bool get partialSyncUnavailable =>
      _get_partialSyncUnavailable(reference) != 0;
  static final _set_partialSyncUnavailable = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_android_content_SyncResult_partialSyncUnavailable")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean partialSyncUnavailable
  ///
  /// This field is ignored by the SyncManager.
  set partialSyncUnavailable(bool value) =>
      _set_partialSyncUnavailable(reference, value ? 1 : 0);

  static final _get_stats = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncResult_stats")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public final android.content.SyncStats stats
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used to hold extras statistics about the sync operation. Some of these indicate that
  /// the sync request resulted in a hard or soft error, others are for purely informational
  /// purposes.
  SyncStats get stats => SyncStats.fromRef(_get_stats(reference));

  static final _get_syncAlreadyInProgress = jniLookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncResult_syncAlreadyInProgress")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public final boolean syncAlreadyInProgress
  ///
  /// Used to indicate that the SyncAdapter is already performing a sync operation, though
  /// not necessarily for the requested account and authority and that it wasn't able to
  /// process this request. The SyncManager will reschedule the request to run later.
  bool get syncAlreadyInProgress => _get_syncAlreadyInProgress(reference) != 0;

  static final _get_tooManyDeletions = jniLookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncResult_tooManyDeletions")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public boolean tooManyDeletions
  ///
  /// Used to indicate that the SyncAdapter determined that it would need to issue
  /// too many delete operations to the server in order to satisfy the request
  /// (as defined by the SyncAdapter). The SyncManager will record
  /// that the sync request failed and will cause a System Notification to be created
  /// asking the user what they want to do about this. It will give the user a chance to
  /// choose between (1) go ahead even with those deletes, (2) revert the deletes,
  /// or (3) take no action. If the user decides (1) or (2) the SyncManager will issue another
  /// sync request with either ContentResolver\#SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS
  /// or ContentResolver\#SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS set in the extras.
  /// It is then up to the SyncAdapter to decide how to honor that request.
  bool get tooManyDeletions => _get_tooManyDeletions(reference) != 0;
  static final _set_tooManyDeletions = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "set_android_content_SyncResult_tooManyDeletions")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean tooManyDeletions
  ///
  /// Used to indicate that the SyncAdapter determined that it would need to issue
  /// too many delete operations to the server in order to satisfy the request
  /// (as defined by the SyncAdapter). The SyncManager will record
  /// that the sync request failed and will cause a System Notification to be created
  /// asking the user what they want to do about this. It will give the user a chance to
  /// choose between (1) go ahead even with those deletes, (2) revert the deletes,
  /// or (3) take no action. If the user decides (1) or (2) the SyncManager will issue another
  /// sync request with either ContentResolver\#SYNC_EXTRAS_OVERRIDE_TOO_MANY_DELETIONS
  /// or ContentResolver\#SYNC_EXTRAS_DISCARD_LOCAL_DELETIONS set in the extras.
  /// It is then up to the SyncAdapter to decide how to honor that request.
  set tooManyDeletions(bool value) =>
      _set_tooManyDeletions(reference, value ? 1 : 0);

  static final _get_tooManyRetries = jniLookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_SyncResult_tooManyRetries")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public boolean tooManyRetries
  ///
  /// Used to indicate that the SyncAdapter experienced a hard error due to trying the same
  /// operation too many times (as defined by the SyncAdapter). The SyncManager will record
  /// that the sync request failed and it will not reschedule the request.
  bool get tooManyRetries => _get_tooManyRetries(reference) != 0;
  static final _set_tooManyRetries = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("set_android_content_SyncResult_tooManyRetries")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean tooManyRetries
  ///
  /// Used to indicate that the SyncAdapter experienced a hard error due to trying the same
  /// operation too many times (as defined by the SyncAdapter). The SyncManager will record
  /// that the sync request failed and it will not reschedule the request.
  set tooManyRetries(bool value) =>
      _set_tooManyRetries(reference, value ? 1 : 0);

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_SyncResult_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ///
  /// Create a "clean" SyncResult. If this is returned without any changes then the
  /// SyncManager will consider the sync to have completed successfully. The various fields
  /// can be set by the SyncAdapter in order to give the SyncManager more information as to
  /// the disposition of the sync.
  ///
  /// The errors are classified into two broad categories: hard errors and soft errors.
  /// Soft errors are retried with exponential backoff. Hard errors are not retried (except
  /// when the hard error is for a ContentResolver\#SYNC_EXTRAS_UPLOAD request,
  /// in which the request is retryed without the ContentResolver\#SYNC_EXTRAS_UPLOAD
  /// extra set). The SyncManager checks the type of error by calling
  /// SyncResult\#hasHardError() and  SyncResult\#hasSoftError(). If both are
  /// true then the SyncManager treats it as a hard error, not a soft error.
  SyncResult() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _hasHardError =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SyncResult_hasHardError")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasHardError()
  ///
  /// Convenience method for determining if the SyncResult indicates that a hard error
  /// occurred. See \#SyncResult() for an explanation of what the SyncManager does
  /// when it sees a hard error.
  ///
  /// A hard error is indicated when any of the following is true:
  /// <ul>
  /// <li> SyncStats\#numParseExceptions > 0
  /// <li> SyncStats\#numConflictDetectedExceptions > 0
  /// <li> SyncStats\#numAuthExceptions > 0
  /// <li> \#tooManyDeletions
  /// <li> \#tooManyRetries
  /// <li> \#databaseError
  ///@return true if a hard error is indicated
  bool hasHardError() {
    final result__ = _hasHardError(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hasSoftError =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SyncResult_hasSoftError")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasSoftError()
  ///
  /// Convenience method for determining if the SyncResult indicates that a soft error
  /// occurred. See \#SyncResult() for an explanation of what the SyncManager does
  /// when it sees a soft error.
  ///
  /// A soft error is indicated when any of the following is true:
  /// <ul>
  /// <li> SyncStats\#numIoExceptions > 0
  /// <li> \#syncAlreadyInProgress
  /// </ul>
  ///@return true if a soft error is indicated
  bool hasSoftError() {
    final result__ = _hasSoftError(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hasError =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SyncResult_hasError")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasError()
  ///
  /// A convenience method for determining of the SyncResult indicates that an error occurred.
  ///@return true if either a soft or hard error occurred
  bool hasError() {
    final result__ = _hasError(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _madeSomeProgress =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SyncResult_madeSomeProgress")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean madeSomeProgress()
  ///
  /// Convenience method for determining if the Sync should be rescheduled after failing for some
  /// reason.
  ///@return true if the SyncManager should reschedule this sync.
  bool madeSomeProgress() {
    final result__ = _madeSomeProgress(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _clear =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SyncResult_clear")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void clear()
  ///
  /// Clears the SyncResult to a clean state. Throws an UnsupportedOperationException
  /// if this is called when \#syncAlreadyInProgress is set.
  void clear() {
    final result__ = _clear(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_SyncResult_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_SyncResult_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  void writeToParcel(os_.Parcel parcel, int flags) {
    final result__ = _writeToParcel(reference, parcel.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_SyncResult_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toDebugString = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_SyncResult_toDebugString")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toDebugString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Generates a debugging string indicating the status.
  /// The string consist of a sequence of code letter followed by the count.
  /// Code letters are f - fullSyncRequested, r - partialSyncUnavailable,
  /// X - hardError, e - numParseExceptions, c - numConflictDetectedExceptions,
  /// a - numAuthExceptions, D - tooManyDeletions, R - tooManyRetries,
  /// b - databaseError, x - softError, l - syncAlreadyInProgress,
  /// I - numIoExceptions
  ///@return debugging string.
  jni.JniString toDebugString() {
    final result__ = jni.JniString.fromRef(_toDebugString(reference));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.ContentProviderClient
///
/// The public interface object used to interact with a specific
/// ContentProvider.
///
/// Instances can be obtained by calling
/// ContentResolver\#acquireContentProviderClient or
/// ContentResolver\#acquireUnstableContentProviderClient. Instances must
/// be released using \#close() in order to indicate to the system that
/// the underlying ContentProvider is no longer needed and can be killed
/// to free up resources.
///
/// Note that you should generally create a new ContentProviderClient instance
/// for each thread that will be performing operations. Unlike
/// ContentResolver, the methods here such as \#query and
/// \#openFile are not thread safe -- you must not call \#close()
/// on the ContentProviderClient those calls are made from until you are finished
/// with the data they have returned.
class ContentProviderClient extends jni.JniObject {
  ContentProviderClient.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_ContentProviderClient_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  ContentProviderClient() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _query = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_query")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.database.Cursor query(android.net.Uri url, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// See ContentProvider\#query ContentProvider.query
  ///@param url This value must never be {@code null}.
  ///@param projection This value may be {@code null}.
  ///@param selection This value may be {@code null}.
  ///@param selectionArgs This value may be {@code null}.
  ///@param sortOrder This value may be {@code null}.
  ///@return This value may be {@code null}.
  jni.JniObject query(
      jni.JniObject url,
      jni.JniObject projection,
      jni.JniString selection,
      jni.JniObject selectionArgs,
      jni.JniString sortOrder) {
    final result__ = jni.JniObject.fromRef(_query(
        reference,
        url.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        sortOrder.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _query1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_query1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// See ContentProvider\#query ContentProvider.query
  ///@param uri This value must never be {@code null}.
  ///@param projection This value may be {@code null}.
  ///@param selection This value may be {@code null}.
  ///@param selectionArgs This value may be {@code null}.
  ///@param sortOrder This value may be {@code null}.
  ///@param cancellationSignal This value may be {@code null}.
  ///@return This value may be {@code null}.
  jni.JniObject query1(
      jni.JniObject uri,
      jni.JniObject projection,
      jni.JniString selection,
      jni.JniObject selectionArgs,
      jni.JniString sortOrder,
      os_.CancellationSignal cancellationSignal) {
    final result__ = jni.JniObject.fromRef(_query1(
        reference,
        uri.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        sortOrder.reference,
        cancellationSignal.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _query2 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_query2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, android.os.Bundle queryArgs, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// See ContentProvider\#query ContentProvider.query
  ///@param uri This value must never be {@code null}.
  ///@param projection This value may be {@code null}.
  ///@param cancellationSignal This value may be {@code null}.
  ///@return This value may be {@code null}.
  jni.JniObject query2(jni.JniObject uri, jni.JniObject projection,
      os_.Bundle queryArgs, os_.CancellationSignal cancellationSignal) {
    final result__ = jni.JniObject.fromRef(_query2(
        reference,
        uri.reference,
        projection.reference,
        queryArgs.reference,
        cancellationSignal.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getType = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_getType")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getType(android.net.Uri url)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// See ContentProvider\#getType ContentProvider.getType
  ///@param url This value must never be {@code null}.
  ///@return This value may be {@code null}.
  jni.JniString getType(jni.JniObject url) {
    final result__ = jni.JniString.fromRef(_getType(reference, url.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getStreamTypes = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_getStreamTypes")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getStreamTypes(android.net.Uri url, java.lang.String mimeTypeFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// See ContentProvider\#getStreamTypes ContentProvider.getStreamTypes
  ///@param url This value must never be {@code null}.
  ///@param mimeTypeFilter This value must never be {@code null}.
  ///@return This value may be {@code null}.
  jni.JniObject getStreamTypes(
      jni.JniObject url, jni.JniString mimeTypeFilter) {
    final result__ = jni.JniObject.fromRef(
        _getStreamTypes(reference, url.reference, mimeTypeFilter.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _canonicalize = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_canonicalize")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.net.Uri canonicalize(android.net.Uri url)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// See ContentProvider\#canonicalize
  ///@param url This value must never be {@code null}.
  ///@return This value may be {@code null}.
  jni.JniObject canonicalize(jni.JniObject url) {
    final result__ =
        jni.JniObject.fromRef(_canonicalize(reference, url.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _uncanonicalize = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_uncanonicalize")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.net.Uri uncanonicalize(android.net.Uri url)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// See ContentProvider\#uncanonicalize
  ///@param url This value must never be {@code null}.
  ///@return This value may be {@code null}.
  jni.JniObject uncanonicalize(jni.JniObject url) {
    final result__ =
        jni.JniObject.fromRef(_uncanonicalize(reference, url.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _refresh = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_refresh")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean refresh(android.net.Uri url, android.os.Bundle args, android.os.CancellationSignal cancellationSignal)
  ///
  /// See ContentProvider\#refresh
  ///@param args This value may be {@code null}.
  ///@param cancellationSignal This value may be {@code null}.
  bool refresh(jni.JniObject url, os_.Bundle args,
      os_.CancellationSignal cancellationSignal) {
    final result__ = _refresh(reference, url.reference, args.reference,
            cancellationSignal.reference) !=
        0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _insert = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_insert")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri insert(android.net.Uri url, android.content.ContentValues initialValues)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// See ContentProvider\#insert ContentProvider.insert
  ///@param url This value must never be {@code null}.
  ///@param initialValues This value may be {@code null}.
  ///@return This value may be {@code null}.
  jni.JniObject insert(jni.JniObject url, ContentValues initialValues) {
    final result__ = jni.JniObject.fromRef(
        _insert(reference, url.reference, initialValues.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _bulkInsert = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_bulkInsert")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int bulkInsert(android.net.Uri url, android.content.ContentValues[] initialValues)
  ///
  /// See ContentProvider\#bulkInsert ContentProvider.bulkInsert
  ///@param url This value must never be {@code null}.
  ///@param initialValues This value must never be {@code null}.
  int bulkInsert(jni.JniObject url, jni.JniObject initialValues) {
    final result__ =
        _bulkInsert(reference, url.reference, initialValues.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _delete1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_delete1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int delete(android.net.Uri url, java.lang.String selection, java.lang.String[] selectionArgs)
  ///
  /// See ContentProvider\#delete ContentProvider.delete
  ///@param url This value must never be {@code null}.
  ///@param selection This value may be {@code null}.
  ///@param selectionArgs This value may be {@code null}.
  int delete1(
      jni.JniObject url, jni.JniString selection, jni.JniObject selectionArgs) {
    final result__ = _delete1(
        reference, url.reference, selection.reference, selectionArgs.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _update = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_update")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int update(android.net.Uri url, android.content.ContentValues values, java.lang.String selection, java.lang.String[] selectionArgs)
  ///
  /// See ContentProvider\#update ContentProvider.update
  ///@param url This value must never be {@code null}.
  ///@param values This value may be {@code null}.
  ///@param selection This value may be {@code null}.
  ///@param selectionArgs This value may be {@code null}.
  int update(jni.JniObject url, ContentValues values, jni.JniString selection,
      jni.JniObject selectionArgs) {
    final result__ = _update(reference, url.reference, values.reference,
        selection.reference, selectionArgs.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openFile = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_openFile")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.ParcelFileDescriptor openFile(android.net.Uri url, java.lang.String mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// See ContentProvider\#openFile ContentProvider.openFile.  Note that
  /// this _does not_
  /// take care of non-content: URIs such as file:.  It is strongly recommended
  /// you use the ContentResolver\#openFileDescriptor ContentResolver.openFileDescriptor API instead.
  ///@param url This value must never be {@code null}.
  ///@param mode This value must never be {@code null}.
  ///@return This value may be {@code null}.
  os_.ParcelFileDescriptor openFile(jni.JniObject url, jni.JniString mode) {
    final result__ = os_.ParcelFileDescriptor.fromRef(
        _openFile(reference, url.reference, mode.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openFile1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_openFile1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.ParcelFileDescriptor openFile(android.net.Uri url, java.lang.String mode, android.os.CancellationSignal signal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// See ContentProvider\#openFile ContentProvider.openFile.  Note that
  /// this _does not_
  /// take care of non-content: URIs such as file:.  It is strongly recommended
  /// you use the ContentResolver\#openFileDescriptor ContentResolver.openFileDescriptor API instead.
  ///@param url This value must never be {@code null}.
  ///@param mode This value must never be {@code null}.
  ///@param signal This value may be {@code null}.
  ///@return This value may be {@code null}.
  os_.ParcelFileDescriptor openFile1(
      jni.JniObject url, jni.JniString mode, os_.CancellationSignal signal) {
    final result__ = os_.ParcelFileDescriptor.fromRef(
        _openFile1(reference, url.reference, mode.reference, signal.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openAssetFile = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_openAssetFile")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.AssetFileDescriptor openAssetFile(android.net.Uri url, java.lang.String mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// See ContentProvider\#openAssetFile ContentProvider.openAssetFile.
  /// Note that this _does not_
  /// take care of non-content: URIs such as file:.  It is strongly recommended
  /// you use the ContentResolver\#openAssetFileDescriptor ContentResolver.openAssetFileDescriptor API instead.
  ///@param url This value must never be {@code null}.
  ///@param mode This value must never be {@code null}.
  ///@return This value may be {@code null}.
  res_.AssetFileDescriptor openAssetFile(
      jni.JniObject url, jni.JniString mode) {
    final result__ = res_.AssetFileDescriptor.fromRef(
        _openAssetFile(reference, url.reference, mode.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openAssetFile1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_openAssetFile1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.AssetFileDescriptor openAssetFile(android.net.Uri url, java.lang.String mode, android.os.CancellationSignal signal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// See ContentProvider\#openAssetFile ContentProvider.openAssetFile.
  /// Note that this _does not_
  /// take care of non-content: URIs such as file:.  It is strongly recommended
  /// you use the ContentResolver\#openAssetFileDescriptor ContentResolver.openAssetFileDescriptor API instead.
  ///@param url This value must never be {@code null}.
  ///@param mode This value must never be {@code null}.
  ///@param signal This value may be {@code null}.
  ///@return This value may be {@code null}.
  res_.AssetFileDescriptor openAssetFile1(
      jni.JniObject url, jni.JniString mode, os_.CancellationSignal signal) {
    final result__ = res_.AssetFileDescriptor.fromRef(_openAssetFile1(
        reference, url.reference, mode.reference, signal.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openTypedAssetFileDescriptor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_openTypedAssetFileDescriptor")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.AssetFileDescriptor openTypedAssetFileDescriptor(android.net.Uri uri, java.lang.String mimeType, android.os.Bundle opts)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// See ContentProvider\#openTypedAssetFile ContentProvider.openTypedAssetFile
  ///@param uri This value must never be {@code null}.
  ///@param mimeType This value must never be {@code null}.
  ///@param opts This value may be {@code null}.
  ///@return This value may be {@code null}.
  res_.AssetFileDescriptor openTypedAssetFileDescriptor(
      jni.JniObject uri, jni.JniString mimeType, os_.Bundle opts) {
    final result__ = res_.AssetFileDescriptor.fromRef(
        _openTypedAssetFileDescriptor(
            reference, uri.reference, mimeType.reference, opts.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openTypedAssetFileDescriptor1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_openTypedAssetFileDescriptor1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.AssetFileDescriptor openTypedAssetFileDescriptor(android.net.Uri uri, java.lang.String mimeType, android.os.Bundle opts, android.os.CancellationSignal signal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// See ContentProvider\#openTypedAssetFile ContentProvider.openTypedAssetFile
  ///@param uri This value must never be {@code null}.
  ///@param mimeType This value must never be {@code null}.
  ///@param opts This value may be {@code null}.
  ///@param signal This value may be {@code null}.
  ///@return This value may be {@code null}.
  res_.AssetFileDescriptor openTypedAssetFileDescriptor1(jni.JniObject uri,
      jni.JniString mimeType, os_.Bundle opts, os_.CancellationSignal signal) {
    final result__ = res_.AssetFileDescriptor.fromRef(
        _openTypedAssetFileDescriptor1(reference, uri.reference,
            mimeType.reference, opts.reference, signal.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _applyBatch = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_applyBatch")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ContentProviderResult[] applyBatch(java.util.ArrayList<android.content.ContentProviderOperation> operations)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// See ContentProvider\#applyBatch ContentProvider.applyBatch
  ///@param operations This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  jni.JniObject applyBatch(jni.JniObject operations) {
    final result__ =
        jni.JniObject.fromRef(_applyBatch(reference, operations.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _call = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_call")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle call(java.lang.String method, java.lang.String arg, android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// See ContentProvider\#call(String, String, Bundle)
  ///@param method This value must never be {@code null}.
  ///@param arg This value may be {@code null}.
  ///@param extras This value may be {@code null}.
  ///@return This value may be {@code null}.
  os_.Bundle call(jni.JniString method, jni.JniString arg, os_.Bundle extras) {
    final result__ = os_.Bundle.fromRef(
        _call(reference, method.reference, arg.reference, extras.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _close =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentProviderClient_close")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void close()
  ///
  /// Closes this client connection, indicating to the system that the
  /// underlying ContentProvider is no longer needed.
  void close() {
    final result__ = _close(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _release =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentProviderClient_release")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean release()
  ///
  /// @deprecated replaced by \#close().
  bool release() {
    final result__ = _release(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _finalize =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentProviderClient_finalize")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void finalize()
  void finalize() {
    final result__ = _finalize(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getLocalContentProvider = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderClient_getLocalContentProvider")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ContentProvider getLocalContentProvider()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a reference to the ContentProvider that is associated with this
  /// client. If the ContentProvider is running in a different process then
  /// null will be returned. This can be used if you know you are running in the same
  /// process as a provider, and want to get direct access to its implementation details.
  ///@return If the associated ContentProvider is local, returns it.
  /// Otherwise returns null.
  ContentProvider getLocalContentProvider() {
    final result__ =
        ContentProvider.fromRef(_getLocalContentProvider(reference));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.Intent
///
/// An intent is an abstract description of an operation to be performed.  It
/// can be used with Context\#startActivity(Intent) startActivity to
/// launch an android.app.Activity,
/// android.content.Context\#sendBroadcast(Intent) broadcastIntent to
/// send it to any interested BroadcastReceiver BroadcastReceiver components,
/// and android.content.Context\#startService or
/// android.content.Context\#bindService to communicate with a
/// background android.app.Service.
///
/// An Intent provides a facility for performing late runtime binding between the code in
/// different applications. Its most significant use is in the launching of activities, where it
/// can be thought of as the glue between activities. It is basically a passive data structure
/// holding an abstract description of an action to be performed.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For information about how to create and resolve intents, read the
/// <a href="{@docRoot}guide/topics/intents/intents-filters.html">Intents and Intent Filters</a>
/// developer guide.
///
/// </div>
///
/// <a name="IntentStructure"></a>
/// <h3>Intent Structure</h3>
/// The primary pieces of information in an intent are:
///
///
/// <ul>
///   <li> __action__ -- The general action to be performed, such as
///     \#ACTION_VIEW, \#ACTION_EDIT, \#ACTION_MAIN,
///     etc.
///
///   </li>
///   <li> __data__ -- The data to operate on, such as a person record
///     in the contacts database, expressed as a android.net.Uri.
///
///   </li>
/// </ul>
///
///
/// Some examples of action/data pairs are:
///
///
/// <ul>
///   <li> __\#ACTION_VIEW <i>content://contacts/people/1</i>__ -- Display
///     information about the person whose identifier is "1".
///
///   </li>
///   <li> __\#ACTION_DIAL <i>content://contacts/people/1</i>__ -- Display
///     the phone dialer with the person filled in.
///
///   </li>
///   <li> __\#ACTION_VIEW <i>tel:123</i>__ -- Display
///     the phone dialer with the given number filled in.  Note how the
///     VIEW action does what is considered the most reasonable thing for
///     a particular URI.
///
///   </li>
///   <li> __\#ACTION_DIAL <i>tel:123</i>__ -- Display
///     the phone dialer with the given number filled in.
///
///   </li>
///   <li> __\#ACTION_EDIT <i>content://contacts/people/1</i>__ -- Edit
///     information about the person whose identifier is "1".
///
///   </li>
///   <li> __\#ACTION_VIEW <i>content://contacts/people/</i>__ -- Display
///     a list of people, which the user can browse through.  This example is a
///     typical top-level entry into the Contacts application, showing you the
///     list of people. Selecting a particular person to view would result in a
///     new intent { __\#ACTION_VIEW <i>content://contacts/people/N</i>__ }
///     being used to start an activity to display that person.
///
///   </li>
/// </ul>
///
/// In addition to these primary attributes, there are a number of secondary
/// attributes that you can also include with an intent:
///
///
/// <ul>
///     <li> __category__ -- Gives additional information about the action
///         to execute.  For example, \#CATEGORY_LAUNCHER means it should
///         appear in the Launcher as a top-level application, while
///         \#CATEGORY_ALTERNATIVE means it should be included in a list
///         of alternative actions the user can perform on a piece of data.
///
///     <li> __type__ -- Specifies an explicit type (a MIME type) of the
///         intent data.  Normally the type is inferred from the data itself.
///         By setting this attribute, you disable that evaluation and force
///         an explicit type.
///
///     <li> __component__ -- Specifies an explicit name of a component
///         class to use for the intent.  Normally this is determined by looking
///         at the other information in the intent (the action, data/type, and
///         categories) and matching that with a component that can handle it.
///         If this attribute is set then none of the evaluation is performed,
///         and this component is used exactly as is.  By specifying this attribute,
///         all of the other Intent attributes become optional.
///
///     <li> __extras__ -- This is a Bundle of any additional information.
///         This can be used to provide extended information to the component.
///         For example, if we have a action to send an e-mail message, we could
///         also include extra pieces of data here to supply a subject, body,
///         etc.
///
/// </ul>
///
/// Here are some examples of other operations you can specify as intents
/// using these additional parameters:
///
///
/// <ul>
///   <li> __\#ACTION_MAIN with category \#CATEGORY_HOME__ --
///     Launch the home screen.
///
///   </li>
///   <li> __\#ACTION_GET_CONTENT with MIME type
///     <i>android.provider.Contacts.Phones\#CONTENT_URI vnd.android.cursor.item/phone</i>__
///     -- Display the list of people's phone numbers, allowing the user to
///     browse through them and pick one and return it to the parent activity.
///
///   </li>
///   <li> __\#ACTION_GET_CONTENT with MIME type
///     <i>*{@literal /}*</i> and category \#CATEGORY_OPENABLE__
///     -- Display all pickers for data that can be opened with
///     ContentResolver\#openInputStream(Uri) ContentResolver.openInputStream(),
///     allowing the user to pick one of them and then some data inside of it
///     and returning the resulting URI to the caller.  This can be used,
///     for example, in an e-mail application to allow the user to pick some
///     data to include as an attachment.
///
///   </li>
/// </ul>
///
/// There are a variety of standard Intent action and category constants
/// defined in the Intent class, but applications can also define their own.
/// These strings use Java-style scoping, to ensure they are unique -- for
/// example, the standard \#ACTION_VIEW is called
/// "android.intent.action.VIEW".
///
///
/// Put together, the set of actions, data types, categories, and extra data
/// defines a language for the system allowing for the expression of phrases
/// such as "call john smith's cell".  As applications are added to the system,
/// they can extend this language by adding new actions, types, and categories, or
/// they can modify the behavior of existing phrases by supplying their own
/// activities that handle them.
///
///
/// <a name="IntentResolution"></a>
/// <h3>Intent Resolution</h3>
///
/// There are two primary forms of intents you will use.
///
/// <ul>
///     <li> __Explicit Intents__ have specified a component (via
///     \#setComponent or \#setClass), which provides the exact
///     class to be run.  Often these will not include any other information,
///     simply being a way for an application to launch various internal
///     activities it has as the user interacts with the application.
///
///     <li> __Implicit Intents__ have not specified a component;
///     instead, they must include enough information for the system to
///     determine which of the available components is best to run for that
///     intent.
/// </ul>
///
/// When using implicit intents, given such an arbitrary intent we need to
/// know what to do with it. This is handled by the process of _Intent
/// resolution_, which maps an Intent to an android.app.Activity,
/// BroadcastReceiver, or android.app.Service (or sometimes two or
/// more activities/receivers) that can handle it.
///
///
/// The intent resolution mechanism basically revolves around matching an
/// Intent against all of the &lt;intent-filter&gt; descriptions in the
/// installed application packages.  (Plus, in the case of broadcasts, any BroadcastReceiver
/// objects explicitly registered with Context\#registerReceiver.)  More
/// details on this can be found in the documentation on the IntentFilter class.
///
///
/// There are three pieces of information in the Intent that are used for
/// resolution: the action, type, and category.  Using this information, a query
/// is done on the PackageManager for a component that can handle the
/// intent. The appropriate component is determined based on the intent
/// information supplied in the <code>AndroidManifest.xml</code> file as
/// follows:
///
///
/// <ul>
///     <li> The __action__, if given, must be listed by the component as
///         one it handles.
///
///     <li> The __type__ is retrieved from the Intent's data, if not
///         already supplied in the Intent.  Like the action, if a type is
///         included in the intent (either explicitly or implicitly in its
///         data), then this must be listed by the component as one it handles.
///
///     <li> For data that is not a <code>content:</code> URI and where no explicit
///         type is included in the Intent, instead the __scheme__ of the
///         intent data (such as <code>http:</code> or <code>mailto:</code>) is
///         considered. Again like the action, if we are matching a scheme it
///         must be listed by the component as one it can handle.
///     <li> The __categories__, if supplied, must _all_ be listed
///         by the activity as categories it handles.  That is, if you include
///         the categories \#CATEGORY_LAUNCHER and
///         \#CATEGORY_ALTERNATIVE, then you will only resolve to components
///         with an intent that lists _both_ of those categories.
///         Activities will very often need to support the
///         \#CATEGORY_DEFAULT so that they can be found by
///         Context\#startActivity Context.startActivity().
///
/// </ul>
///
/// For example, consider the Note Pad sample application that
/// allows a user to browse through a list of notes data and view details about
/// individual items.  Text in italics indicates places where you would replace a
/// name with one specific to your own package.
///
///
/// <pre> &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
///       package="<i>com.android.notepad</i>"&gt;
///     &lt;application android:icon="@drawable/app_notes"
///             android:label="@string/app_name"&gt;
///
///         &lt;provider class=".NotePadProvider"
///                 android:authorities="<i>com.google.provider.NotePad</i>" /&gt;
///
///         &lt;activity class=".NotesList" android:label="@string/title_notes_list"&gt;
///             &lt;intent-filter&gt;
///                 &lt;action android:name="android.intent.action.MAIN" /&gt;
///                 &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
///             &lt;/intent-filter&gt;
///             &lt;intent-filter&gt;
///                 &lt;action android:name="android.intent.action.VIEW" /&gt;
///                 &lt;action android:name="android.intent.action.EDIT" /&gt;
///                 &lt;action android:name="android.intent.action.PICK" /&gt;
///                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
///                 &lt;data android:mimeType="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
///             &lt;/intent-filter&gt;
///             &lt;intent-filter&gt;
///                 &lt;action android:name="android.intent.action.GET_CONTENT" /&gt;
///                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
///                 &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
///             &lt;/intent-filter&gt;
///         &lt;/activity&gt;
///
///         &lt;activity class=".NoteEditor" android:label="@string/title_note"&gt;
///             &lt;intent-filter android:label="@string/resolve_edit"&gt;
///                 &lt;action android:name="android.intent.action.VIEW" /&gt;
///                 &lt;action android:name="android.intent.action.EDIT" /&gt;
///                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
///                 &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
///             &lt;/intent-filter&gt;
///
///             &lt;intent-filter&gt;
///                 &lt;action android:name="android.intent.action.INSERT" /&gt;
///                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
///                 &lt;data android:mimeType="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
///             &lt;/intent-filter&gt;
///
///         &lt;/activity&gt;
///
///         &lt;activity class=".TitleEditor" android:label="@string/title_edit_title"
///                 android:theme="@android:style/Theme.Dialog"&gt;
///             &lt;intent-filter android:label="@string/resolve_title"&gt;
///                 &lt;action android:name="<i>com.android.notepad.action.EDIT_TITLE</i>" /&gt;
///                 &lt;category android:name="android.intent.category.DEFAULT" /&gt;
///                 &lt;category android:name="android.intent.category.ALTERNATIVE" /&gt;
///                 &lt;category android:name="android.intent.category.SELECTED_ALTERNATIVE" /&gt;
///                 &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
///             &lt;/intent-filter&gt;
///         &lt;/activity&gt;
///
///     &lt;/application&gt;
/// &lt;/manifest&gt;</pre>
///
/// The first activity,
/// <code>com.android.notepad.NotesList</code>, serves as our main
/// entry into the app.  It can do three things as described by its three intent
/// templates:
/// <ol>
/// <li><pre>
/// &lt;intent-filter&gt;
///     &lt;action android:name="\#ACTION_MAIN android.intent.action.MAIN" /&gt;
///     &lt;category android:name="\#CATEGORY_LAUNCHER android.intent.category.LAUNCHER" /&gt;
/// &lt;/intent-filter&gt;</pre>
/// This provides a top-level entry into the NotePad application: the standard
/// MAIN action is a main entry point (not requiring any other information in
/// the Intent), and the LAUNCHER category says that this entry point should be
/// listed in the application launcher.
///
/// <li><pre>
/// &lt;intent-filter&gt;
///     &lt;action android:name="\#ACTION_VIEW android.intent.action.VIEW" /&gt;
///     &lt;action android:name="\#ACTION_EDIT android.intent.action.EDIT" /&gt;
///     &lt;action android:name="\#ACTION_PICK android.intent.action.PICK" /&gt;
///     &lt;category android:name="\#CATEGORY_DEFAULT android.intent.category.DEFAULT" /&gt;
///     &lt;data android:mimeType="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
/// &lt;/intent-filter&gt;</pre>
/// This declares the things that the activity can do on a directory of
/// notes.  The type being supported is given with the &lt;type&gt; tag, where
/// <code>vnd.android.cursor.dir/vnd.google.note</code> is a URI from which
/// a Cursor of zero or more items (<code>vnd.android.cursor.dir</code>) can
/// be retrieved which holds our note pad data (<code>vnd.google.note</code>).
/// The activity allows the user to view or edit the directory of data (via
/// the VIEW and EDIT actions), or to pick a particular note and return it
/// to the caller (via the PICK action).  Note also the DEFAULT category
/// supplied here: this is _required_ for the
/// Context\#startActivity Context.startActivity method to resolve your
/// activity when its component name is not explicitly specified.
///
/// <li><pre>
/// &lt;intent-filter&gt;
///     &lt;action android:name="\#ACTION_GET_CONTENT android.intent.action.GET_CONTENT" /&gt;
///     &lt;category android:name="\#CATEGORY_DEFAULT android.intent.category.DEFAULT" /&gt;
///     &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
/// &lt;/intent-filter&gt;</pre>
/// This filter describes the ability to return to the caller a note selected by
/// the user without needing to know where it came from.  The data type
/// <code>vnd.android.cursor.item/vnd.google.note</code> is a URI from which
/// a Cursor of exactly one (<code>vnd.android.cursor.item</code>) item can
/// be retrieved which contains our note pad data (<code>vnd.google.note</code>).
/// The GET_CONTENT action is similar to the PICK action, where the activity
/// will return to its caller a piece of data selected by the user.  Here,
/// however, the caller specifies the type of data they desire instead of
/// the type of data the user will be picking from.
///
/// </ol>
///
/// Given these capabilities, the following intents will resolve to the
/// NotesList activity:
///
///
/// <ul>
///     <li> __{ action=android.app.action.MAIN }__ matches all of the
///         activities that can be used as top-level entry points into an
///         application.
///
///     <li> __{ action=android.app.action.MAIN,
///         category=android.app.category.LAUNCHER }__ is the actual intent
///         used by the Launcher to populate its top-level list.
///
///     <li> __{ action=android.intent.action.VIEW
///          data=content://com.google.provider.NotePad/notes }__
///         displays a list of all the notes under
///         "content://com.google.provider.NotePad/notes", which
///         the user can browse through and see the details on.
///
///     <li> __{ action=android.app.action.PICK
///          data=content://com.google.provider.NotePad/notes }__
///         provides a list of the notes under
///         "content://com.google.provider.NotePad/notes", from which
///         the user can pick a note whose data URL is returned back to the caller.
///
///     <li> __{ action=android.app.action.GET_CONTENT
///          type=vnd.android.cursor.item/vnd.google.note }__
///         is similar to the pick action, but allows the caller to specify the
///         kind of data they want back so that the system can find the appropriate
///         activity to pick something of that data type.
///
/// </ul>
///
/// The second activity,
/// <code>com.android.notepad.NoteEditor</code>, shows the user a single
/// note entry and allows them to edit it.  It can do two things as described
/// by its two intent templates:
/// <ol>
/// <li><pre>
/// &lt;intent-filter android:label="@string/resolve_edit"&gt;
///     &lt;action android:name="\#ACTION_VIEW android.intent.action.VIEW" /&gt;
///     &lt;action android:name="\#ACTION_EDIT android.intent.action.EDIT" /&gt;
///     &lt;category android:name="\#CATEGORY_DEFAULT android.intent.category.DEFAULT" /&gt;
///     &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
/// &lt;/intent-filter&gt;</pre>
/// The first, primary, purpose of this activity is to let the user interact
/// with a single note, as decribed by the MIME type
/// <code>vnd.android.cursor.item/vnd.google.note</code>.  The activity can
/// either VIEW a note or allow the user to EDIT it.  Again we support the
/// DEFAULT category to allow the activity to be launched without explicitly
/// specifying its component.
///
/// <li><pre>
/// &lt;intent-filter&gt;
///     &lt;action android:name="\#ACTION_INSERT android.intent.action.INSERT" /&gt;
///     &lt;category android:name="\#CATEGORY_DEFAULT android.intent.category.DEFAULT" /&gt;
///     &lt;data android:mimeType="vnd.android.cursor.dir/<i>vnd.google.note</i>" /&gt;
/// &lt;/intent-filter&gt;</pre>
/// The secondary use of this activity is to insert a new note entry into
/// an existing directory of notes.  This is used when the user creates a new
/// note: the INSERT action is executed on the directory of notes, causing
/// this activity to run and have the user create the new note data which
/// it then adds to the content provider.
///
/// </ol>
///
/// Given these capabilities, the following intents will resolve to the
/// NoteEditor activity:
///
///
/// <ul>
///     <li> __{ action=android.intent.action.VIEW
///          data=content://com.google.provider.NotePad/notes/<var>{ID}</var> }__
///         shows the user the content of note <var>{ID}</var>.
///
///     <li> __{ action=android.app.action.EDIT
///          data=content://com.google.provider.NotePad/notes/<var>{ID}</var> }__
///         allows the user to edit the content of note <var>{ID}</var>.
///
///     <li> __{ action=android.app.action.INSERT
///          data=content://com.google.provider.NotePad/notes }__
///         creates a new, empty note in the notes list at
///         "content://com.google.provider.NotePad/notes"
///         and allows the user to edit it.  If they keep their changes, the URI
///         of the newly created note is returned to the caller.
///
/// </ul>
///
/// The last activity,
/// <code>com.android.notepad.TitleEditor</code>, allows the user to
/// edit the title of a note.  This could be implemented as a class that the
/// application directly invokes (by explicitly setting its component in
/// the Intent), but here we show a way you can publish alternative
/// operations on existing data:
///
///
/// <pre>
/// &lt;intent-filter android:label="@string/resolve_title"&gt;
///     &lt;action android:name="<i>com.android.notepad.action.EDIT_TITLE</i>" /&gt;
///     &lt;category android:name="\#CATEGORY_DEFAULT android.intent.category.DEFAULT" /&gt;
///     &lt;category android:name="\#CATEGORY_ALTERNATIVE android.intent.category.ALTERNATIVE" /&gt;
///     &lt;category android:name="\#CATEGORY_SELECTED_ALTERNATIVE android.intent.category.SELECTED_ALTERNATIVE" /&gt;
///     &lt;data android:mimeType="vnd.android.cursor.item/<i>vnd.google.note</i>" /&gt;
/// &lt;/intent-filter&gt;</pre>
///
/// In the single intent template here, we
/// have created our own private action called
/// <code>com.android.notepad.action.EDIT_TITLE</code> which means to
/// edit the title of a note.  It must be invoked on a specific note
/// (data type <code>vnd.android.cursor.item/vnd.google.note</code>) like the previous
/// view and edit actions, but here displays and edits the title contained
/// in the note data.
///
/// In addition to supporting the default category as usual, our title editor
/// also supports two other standard categories: ALTERNATIVE and
/// SELECTED_ALTERNATIVE.  Implementing
/// these categories allows others to find the special action it provides
/// without directly knowing about it, through the
/// android.content.pm.PackageManager\#queryIntentActivityOptions method, or
/// more often to build dynamic menu items with
/// android.view.Menu\#addIntentOptions.  Note that in the intent
/// template here was also supply an explicit name for the template
/// (via <code>android:label="@string/resolve_title"</code>) to better control
/// what the user sees when presented with this activity as an alternative
/// action to the data they are viewing.
///
/// Given these capabilities, the following intent will resolve to the
/// TitleEditor activity:
///
///
/// <ul>
///     <li> __{ action=com.android.notepad.action.EDIT_TITLE
///          data=content://com.google.provider.NotePad/notes/<var>{ID}</var> }__
///         displays and allows the user to edit the title associated
///         with note <var>{ID}</var>.
///
/// </ul>
///
/// <h3>Standard Activity Actions</h3>
///
/// These are the current standard actions that Intent defines for launching
/// activities (usually through Context\#startActivity.  The most
/// important, and by far most frequently used, are \#ACTION_MAIN and
/// \#ACTION_EDIT.
///
/// <ul>
///     <li> \#ACTION_MAIN
///     <li> \#ACTION_VIEW
///     <li> \#ACTION_ATTACH_DATA
///     <li> \#ACTION_EDIT
///     <li> \#ACTION_PICK
///     <li> \#ACTION_CHOOSER
///     <li> \#ACTION_GET_CONTENT
///     <li> \#ACTION_DIAL
///     <li> \#ACTION_CALL
///     <li> \#ACTION_SEND
///     <li> \#ACTION_SENDTO
///     <li> \#ACTION_ANSWER
///     <li> \#ACTION_INSERT
///     <li> \#ACTION_DELETE
///     <li> \#ACTION_RUN
///     <li> \#ACTION_SYNC
///     <li> \#ACTION_PICK_ACTIVITY
///     <li> \#ACTION_SEARCH
///     <li> \#ACTION_WEB_SEARCH
///     <li> \#ACTION_FACTORY_TEST
/// </ul>
///
/// <h3>Standard Broadcast Actions</h3>
///
/// These are the current standard actions that Intent defines for receiving
/// broadcasts (usually through Context\#registerReceiver or a
/// &lt;receiver&gt; tag in a manifest).
///
/// <ul>
///     <li> \#ACTION_TIME_TICK
///     <li> \#ACTION_TIME_CHANGED
///     <li> \#ACTION_TIMEZONE_CHANGED
///     <li> \#ACTION_BOOT_COMPLETED
///     <li> \#ACTION_PACKAGE_ADDED
///     <li> \#ACTION_PACKAGE_CHANGED
///     <li> \#ACTION_PACKAGE_REMOVED
///     <li> \#ACTION_PACKAGE_RESTARTED
///     <li> \#ACTION_PACKAGE_DATA_CLEARED
///     <li> \#ACTION_PACKAGES_SUSPENDED
///     <li> \#ACTION_PACKAGES_UNSUSPENDED
///     <li> \#ACTION_UID_REMOVED
///     <li> \#ACTION_BATTERY_CHANGED
///     <li> \#ACTION_POWER_CONNECTED
///     <li> \#ACTION_POWER_DISCONNECTED
///     <li> \#ACTION_SHUTDOWN
/// </ul>
///
/// <h3>Standard Categories</h3>
///
/// These are the current standard categories that can be used to further
/// clarify an Intent via \#addCategory.
///
/// <ul>
///     <li> \#CATEGORY_DEFAULT
///     <li> \#CATEGORY_BROWSABLE
///     <li> \#CATEGORY_TAB
///     <li> \#CATEGORY_ALTERNATIVE
///     <li> \#CATEGORY_SELECTED_ALTERNATIVE
///     <li> \#CATEGORY_LAUNCHER
///     <li> \#CATEGORY_INFO
///     <li> \#CATEGORY_HOME
///     <li> \#CATEGORY_PREFERENCE
///     <li> \#CATEGORY_TEST
///     <li> \#CATEGORY_CAR_DOCK
///     <li> \#CATEGORY_DESK_DOCK
///     <li> \#CATEGORY_LE_DESK_DOCK
///     <li> \#CATEGORY_HE_DESK_DOCK
///     <li> \#CATEGORY_CAR_MODE
///     <li> \#CATEGORY_APP_MARKET
///     <li> \#CATEGORY_VR_HOME
/// </ul>
///
/// <h3>Standard Extra Data</h3>
///
/// These are the current standard fields that can be used as extra data via
/// \#putExtra.
///
/// <ul>
///     <li> \#EXTRA_ALARM_COUNT
///     <li> \#EXTRA_BCC
///     <li> \#EXTRA_CC
///     <li> \#EXTRA_CHANGED_COMPONENT_NAME
///     <li> \#EXTRA_DATA_REMOVED
///     <li> \#EXTRA_DOCK_STATE
///     <li> \#EXTRA_DOCK_STATE_HE_DESK
///     <li> \#EXTRA_DOCK_STATE_LE_DESK
///     <li> \#EXTRA_DOCK_STATE_CAR
///     <li> \#EXTRA_DOCK_STATE_DESK
///     <li> \#EXTRA_DOCK_STATE_UNDOCKED
///     <li> \#EXTRA_DONT_KILL_APP
///     <li> \#EXTRA_EMAIL
///     <li> \#EXTRA_INITIAL_INTENTS
///     <li> \#EXTRA_INTENT
///     <li> \#EXTRA_KEY_EVENT
///     <li> \#EXTRA_ORIGINATING_URI
///     <li> \#EXTRA_PHONE_NUMBER
///     <li> \#EXTRA_REFERRER
///     <li> \#EXTRA_REMOTE_INTENT_TOKEN
///     <li> \#EXTRA_REPLACING
///     <li> \#EXTRA_SHORTCUT_ICON
///     <li> \#EXTRA_SHORTCUT_ICON_RESOURCE
///     <li> \#EXTRA_SHORTCUT_INTENT
///     <li> \#EXTRA_STREAM
///     <li> \#EXTRA_SHORTCUT_NAME
///     <li> \#EXTRA_SUBJECT
///     <li> \#EXTRA_TEMPLATE
///     <li> \#EXTRA_TEXT
///     <li> \#EXTRA_TITLE
///     <li> \#EXTRA_UID
/// </ul>
///
/// <h3>Flags</h3>
///
/// These are the possible flags that can be used in the Intent via
/// \#setFlags and \#addFlags.  See \#setFlags for a list
/// of all possible flags.
class Intent extends jni.JniObject {
  Intent.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_AIRPLANE_MODE_CHANGED
  ///
  /// Broadcast Action: The user has switched the phone into or out of Airplane Mode. One or
  /// more radios have been turned off or on. The intent will have the following extra value:
  ///
  /// <ul>
  ///   <li>_state_ - A boolean value indicating whether Airplane Mode is on. If true,
  ///   then cell radio and possibly other radios such as bluetooth or WiFi may have also been
  ///   turned off</li>
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent by the system.
  ///
  static const ACTION_AIRPLANE_MODE_CHANGED =
      "android.intent.action.AIRPLANE_MODE";

  /// from: static public final java.lang.String ACTION_ALL_APPS
  ///
  /// Activity Action: List all available applications.
  /// Input: Nothing.
  /// Output: nothing.
  static const ACTION_ALL_APPS = "android.intent.action.ALL_APPS";

  /// from: static public final java.lang.String ACTION_ANSWER
  ///
  /// Activity Action: Handle an incoming phone call.
  /// Input: nothing.
  /// Output: nothing.
  static const ACTION_ANSWER = "android.intent.action.ANSWER";

  /// from: static public final java.lang.String ACTION_APPLICATION_PREFERENCES
  ///
  /// An activity that provides a user interface for adjusting application preferences.
  /// Optional but recommended settings for all applications which have settings.
  static const ACTION_APPLICATION_PREFERENCES =
      "android.intent.action.APPLICATION_PREFERENCES";

  /// from: static public final java.lang.String ACTION_APPLICATION_RESTRICTIONS_CHANGED
  ///
  /// Broadcast Action: Sent after application restrictions are changed.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  ///
  static const ACTION_APPLICATION_RESTRICTIONS_CHANGED =
      "android.intent.action.APPLICATION_RESTRICTIONS_CHANGED";

  /// from: static public final java.lang.String ACTION_APP_ERROR
  ///
  /// Activity Action: The user pressed the "Report" button in the crash/ANR dialog.
  /// This intent is delivered to the package which installed the application, usually
  /// Google Play.
  /// Input: No data is specified. The bug report is passed in using
  /// an \#EXTRA_BUG_REPORT field.
  /// Output: Nothing.
  ///@see \#EXTRA_BUG_REPORT
  static const ACTION_APP_ERROR = "android.intent.action.APP_ERROR";

  /// from: static public final java.lang.String ACTION_ASSIST
  ///
  /// Activity Action: Perform assist action.
  ///
  /// Input: \#EXTRA_ASSIST_PACKAGE, \#EXTRA_ASSIST_CONTEXT, can provide
  /// additional optional contextual information about where the user was when they
  /// requested the assist; \#EXTRA_REFERRER may be set with additional referrer
  /// information.
  /// Output: nothing.
  static const ACTION_ASSIST = "android.intent.action.ASSIST";

  /// from: static public final java.lang.String ACTION_ATTACH_DATA
  ///
  /// Used to indicate that some piece of data should be attached to some other
  /// place.  For example, image data could be attached to a contact.  It is up
  /// to the recipient to decide where the data should be attached; the intent
  /// does not specify the ultimate destination.
  /// Input: \#getData is URI of data to be attached.
  /// Output: nothing.
  static const ACTION_ATTACH_DATA = "android.intent.action.ATTACH_DATA";

  /// from: static public final java.lang.String ACTION_BATTERY_CHANGED
  ///
  /// Broadcast Action:  This is a _sticky broadcast_ containing the
  /// charging state, level, and other information about the battery.
  /// See android.os.BatteryManager for documentation on the
  /// contents of the Intent.
  ///
  /// <p class="note">
  /// You _cannot_ receive this through components declared
  /// in manifests, only by explicitly registering for it with
  /// Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver().  See \#ACTION_BATTERY_LOW,
  /// \#ACTION_BATTERY_OKAY, \#ACTION_POWER_CONNECTED,
  /// and \#ACTION_POWER_DISCONNECTED for distinct battery-related
  /// broadcasts that are sent and can be received through manifest
  /// receivers.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_BATTERY_CHANGED = "android.intent.action.BATTERY_CHANGED";

  /// from: static public final java.lang.String ACTION_BATTERY_LOW
  ///
  /// Broadcast Action:  Indicates low battery condition on the device.
  /// This broadcast corresponds to the "Low battery warning" system dialog.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_BATTERY_LOW = "android.intent.action.BATTERY_LOW";

  /// from: static public final java.lang.String ACTION_BATTERY_OKAY
  ///
  /// Broadcast Action:  Indicates the battery is now okay after being low.
  /// This will be sent after \#ACTION_BATTERY_LOW once the battery has
  /// gone back up to an okay state.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_BATTERY_OKAY = "android.intent.action.BATTERY_OKAY";

  /// from: static public final java.lang.String ACTION_BOOT_COMPLETED
  ///
  /// Broadcast Action: This is broadcast once, after the user has finished
  /// booting. It can be used to perform application-specific initialization,
  /// such as installing alarms. You must hold the
  /// android.Manifest.permission\#RECEIVE_BOOT_COMPLETED permission in
  /// order to receive this broadcast.
  ///
  /// This broadcast is sent at boot by all devices (both with and without
  /// direct boot support). Upon receipt of this broadcast, the user is
  /// unlocked and both device-protected and credential-protected storage can
  /// accessed safely.
  ///
  /// If you need to run while the user is still locked (before they've entered
  /// their lock pattern or PIN for the first time), you can listen for the
  /// \#ACTION_LOCKED_BOOT_COMPLETED broadcast.
  /// <p class="note">
  /// This is a protected intent that can only be sent by the system.
  static const ACTION_BOOT_COMPLETED = "android.intent.action.BOOT_COMPLETED";

  /// from: static public final java.lang.String ACTION_BUG_REPORT
  ///
  /// Activity Action: Show activity for reporting a bug.
  /// Input: Nothing.
  /// Output: Nothing.
  static const ACTION_BUG_REPORT = "android.intent.action.BUG_REPORT";

  /// from: static public final java.lang.String ACTION_CALL
  ///
  /// Activity Action: Perform a call to someone specified by the data.
  /// Input: If nothing, an empty dialer is started; else \#getData
  /// is URI of a phone number to be dialed or a tel: URI of an explicit phone
  /// number.
  /// Output: nothing.
  ///
  /// Note: there will be restrictions on which applications can initiate a
  /// call; most applications should use the \#ACTION_DIAL.
  /// Note: this Intent <strong>cannot</strong> be used to call emergency
  /// numbers.  Applications can <strong>dial</strong> emergency numbers using
  /// \#ACTION_DIAL, however.
  ///
  /// Note: if you app targets android.os.Build.VERSION_CODES\#M M
  /// and above and declares as using the android.Manifest.permission\#CALL_PHONE
  /// permission which is not granted, then attempting to use this action will
  /// result in a java.lang.SecurityException.
  static const ACTION_CALL = "android.intent.action.CALL";

  /// from: static public final java.lang.String ACTION_CALL_BUTTON
  ///
  /// Activity Action: The user pressed the "call" button to go to the dialer
  /// or other appropriate UI for placing a call.
  /// Input: Nothing.
  /// Output: Nothing.
  static const ACTION_CALL_BUTTON = "android.intent.action.CALL_BUTTON";

  /// from: static public final java.lang.String ACTION_CAMERA_BUTTON
  ///
  /// Broadcast Action:  The "Camera Button" was pressed.  Includes a single
  /// extra field, \#EXTRA_KEY_EVENT, containing the key event that
  /// caused the broadcast.
  static const ACTION_CAMERA_BUTTON = "android.intent.action.CAMERA_BUTTON";

  /// from: static public final java.lang.String ACTION_CARRIER_SETUP
  ///
  /// Activity Action: Main entry point for carrier setup apps.
  /// Carrier apps that provide an implementation for this action may be invoked to configure
  /// carrier service and typically require
  /// android.telephony.TelephonyManager\#hasCarrierPrivileges() carrier privileges to
  /// fulfill their duties.
  static const ACTION_CARRIER_SETUP = "android.intent.action.CARRIER_SETUP";

  /// from: static public final java.lang.String ACTION_CHOOSER
  ///
  /// Activity Action: Display an activity chooser, allowing the user to pick
  /// what they want to before proceeding.  This can be used as an alternative
  /// to the standard activity picker that is displayed by the system when
  /// you try to start an activity with multiple possible matches, with these
  /// differences in behavior:
  /// <ul>
  /// <li>You can specify the title that will appear in the activity chooser.
  /// <li>The user does not have the option to make one of the matching
  /// activities a preferred activity, and all possible activities will
  /// always be shown even if one of them is currently marked as the
  /// preferred activity.
  /// </ul>
  ///
  /// This action should be used when the user will naturally expect to
  /// select an activity in order to proceed.  An example if when not to use
  /// it is when the user clicks on a "mailto:" link.  They would naturally
  /// expect to go directly to their mail app, so startActivity() should be
  /// called directly: it will
  /// either launch the current preferred app, or put up a dialog allowing the
  /// user to pick an app to use and optionally marking that as preferred.
  ///
  /// In contrast, if the user is selecting a menu item to send a picture
  /// they are viewing to someone else, there are many different things they
  /// may want to do at this point: send it through e-mail, upload it to a
  /// web service, etc.  In this case the CHOOSER action should be used, to
  /// always present to the user a list of the things they can do, with a
  /// nice title given by the caller such as "Send this photo with:".
  ///
  /// If you need to grant URI permissions through a chooser, you must specify
  /// the permissions to be granted on the ACTION_CHOOSER Intent
  /// _in addition_ to the EXTRA_INTENT inside.  This means using
  /// \#setClipData to specify the URIs to be granted as well as
  /// \#FLAG_GRANT_READ_URI_PERMISSION and/or
  /// \#FLAG_GRANT_WRITE_URI_PERMISSION as appropriate.
  ///
  /// As a convenience, an Intent of this form can be created with the
  /// \#createChooser function.
  ///
  /// Input: No data should be specified.  get*Extra must have
  /// a \#EXTRA_INTENT field containing the Intent being executed,
  /// and can optionally have a \#EXTRA_TITLE field containing the
  /// title text to display in the chooser.
  ///
  /// Output: Depends on the protocol of \#EXTRA_INTENT.
  static const ACTION_CHOOSER = "android.intent.action.CHOOSER";

  /// from: static public final java.lang.String ACTION_CLOSE_SYSTEM_DIALOGS
  ///
  /// Broadcast Action: This is broadcast when a user action should request a
  /// temporary system dialog to dismiss.  Some examples of temporary system
  /// dialogs are the notification window-shade and the recent tasks dialog.
  static const ACTION_CLOSE_SYSTEM_DIALOGS =
      "android.intent.action.CLOSE_SYSTEM_DIALOGS";

  /// from: static public final java.lang.String ACTION_CONFIGURATION_CHANGED
  ///
  /// Broadcast Action: The current device android.content.res.Configuration
  /// (orientation, locale, etc) has changed.  When such a change happens, the
  /// UIs (view hierarchy) will need to be rebuilt based on this new
  /// information; for the most part, applications don't need to worry about
  /// this, because the system will take care of stopping and restarting the
  /// application to make sure it sees the new changes.  Some system code that
  /// can not be restarted will need to watch for this action and handle it
  /// appropriately.
  ///
  /// <p class="note">
  /// You _cannot_ receive this through components declared
  /// in manifests, only by explicitly registering for it with
  /// Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver().
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  ///@see android.content.res.Configuration
  static const ACTION_CONFIGURATION_CHANGED =
      "android.intent.action.CONFIGURATION_CHANGED";

  /// from: static public final java.lang.String ACTION_CREATE_DOCUMENT
  ///
  /// Activity Action: Allow the user to create a new document. When invoked,
  /// the system will display the various DocumentsProvider instances
  /// installed on the device, letting the user navigate through them. The
  /// returned document may be a newly created document with no content, or it
  /// may be an existing document with the requested MIME type.
  ///
  /// Each document is represented as a {@code content://} URI backed by a
  /// DocumentsProvider, which can be opened as a stream with
  /// ContentResolver\#openFileDescriptor(Uri, String), or queried for
  /// android.provider.DocumentsContract.Document metadata.
  ///
  /// Callers must indicate the concrete MIME type of the document being
  /// created by setting \#setType(String). This MIME type cannot be
  /// changed after the document is created.
  ///
  /// Callers can provide an initial display name through \#EXTRA_TITLE,
  /// but the user may change this value before creating the file.
  ///
  /// Callers must include \#CATEGORY_OPENABLE in the Intent to obtain
  /// URIs that can be opened with
  /// ContentResolver\#openFileDescriptor(Uri, String).
  ///
  /// Callers can set a document URI through
  /// DocumentsContract\#EXTRA_INITIAL_URI to indicate the initial
  /// location of documents navigator. System will do its best to launch the
  /// navigator in the specified document if it's a folder, or the folder that
  /// contains the specified document if not.
  ///
  /// Output: The URI of the item that was created. This must be a
  /// {@code content://} URI so that any receiver can access it.
  ///@see DocumentsContract
  ///@see \#ACTION_OPEN_DOCUMENT
  ///@see \#ACTION_OPEN_DOCUMENT_TREE
  ///@see \#FLAG_GRANT_PERSISTABLE_URI_PERMISSION
  static const ACTION_CREATE_DOCUMENT = "android.intent.action.CREATE_DOCUMENT";

  /// from: static public final java.lang.String ACTION_CREATE_SHORTCUT
  ///
  /// Activity Action: Creates a shortcut.
  /// Input: Nothing.
  ///
  /// Output: An Intent representing the android.content.pm.ShortcutInfo result.
  ///
  /// For compatibility with older versions of android the intent may also contain three
  /// extras: SHORTCUT_INTENT (value: Intent), SHORTCUT_NAME (value: String),
  /// and SHORTCUT_ICON (value: Bitmap) or SHORTCUT_ICON_RESOURCE
  /// (value: ShortcutIconResource).
  ///
  ///@see android.content.pm.ShortcutManager\#createShortcutResultIntent
  ///@see \#EXTRA_SHORTCUT_INTENT
  ///@see \#EXTRA_SHORTCUT_NAME
  ///@see \#EXTRA_SHORTCUT_ICON
  ///@see \#EXTRA_SHORTCUT_ICON_RESOURCE
  ///@see android.content.Intent.ShortcutIconResource
  static const ACTION_CREATE_SHORTCUT = "android.intent.action.CREATE_SHORTCUT";

  /// from: static public final java.lang.String ACTION_DATE_CHANGED
  ///
  /// Broadcast Action: The date has changed.
  static const ACTION_DATE_CHANGED = "android.intent.action.DATE_CHANGED";

  /// from: static public final java.lang.String ACTION_DEFAULT
  ///
  /// A synonym for \#ACTION_VIEW, the "standard" action that is
  /// performed on a piece of data.
  static const ACTION_DEFAULT = "android.intent.action.VIEW";

  /// from: static public final java.lang.String ACTION_DELETE
  ///
  /// Activity Action: Delete the given data from its container.
  /// Input: \#getData is URI of data to be deleted.
  /// Output: nothing.
  static const ACTION_DELETE = "android.intent.action.DELETE";

  /// from: static public final java.lang.String ACTION_DEVICE_STORAGE_LOW
  ///
  /// Broadcast Action: A sticky broadcast that indicates low storage space
  /// condition on the device
  /// <p class="note">
  /// This is a protected intent that can only be sent by the system.
  ///@deprecated if your app targets android.os.Build.VERSION_CODES\#O
  ///             or above, this broadcast will no longer be delivered to any
  ///             BroadcastReceiver defined in your manifest. Instead,
  ///             apps are strongly encouraged to use the improved
  ///             Context\#getCacheDir() behavior so the system can
  ///             automatically free up storage when needed.
  static const ACTION_DEVICE_STORAGE_LOW =
      "android.intent.action.DEVICE_STORAGE_LOW";

  /// from: static public final java.lang.String ACTION_DEVICE_STORAGE_OK
  ///
  /// Broadcast Action: Indicates low storage space condition on the device no
  /// longer exists
  /// <p class="note">
  /// This is a protected intent that can only be sent by the system.
  ///@deprecated if your app targets android.os.Build.VERSION_CODES\#O
  ///             or above, this broadcast will no longer be delivered to any
  ///             BroadcastReceiver defined in your manifest. Instead,
  ///             apps are strongly encouraged to use the improved
  ///             Context\#getCacheDir() behavior so the system can
  ///             automatically free up storage when needed.
  static const ACTION_DEVICE_STORAGE_OK =
      "android.intent.action.DEVICE_STORAGE_OK";

  /// from: static public final java.lang.String ACTION_DIAL
  ///
  /// Activity Action: Dial a number as specified by the data.  This shows a
  /// UI with the number being dialed, allowing the user to explicitly
  /// initiate the call.
  /// Input: If nothing, an empty dialer is started; else \#getData
  /// is URI of a phone number to be dialed or a tel: URI of an explicit phone
  /// number.
  /// Output: nothing.
  static const ACTION_DIAL = "android.intent.action.DIAL";

  /// from: static public final java.lang.String ACTION_DOCK_EVENT
  ///
  /// Broadcast Action:  A sticky broadcast for changes in the physical
  /// docking state of the device.
  ///
  /// The intent will have the following extra values:
  /// <ul>
  ///   <li>_\#EXTRA_DOCK_STATE_ - the current dock
  ///       state, indicating which dock the device is physically in.</li>
  /// </ul>
  /// This is intended for monitoring the current physical dock state.
  /// See android.app.UiModeManager for the normal API dealing with
  /// dock mode changes.
  static const ACTION_DOCK_EVENT = "android.intent.action.DOCK_EVENT";

  /// from: static public final java.lang.String ACTION_DREAMING_STARTED
  ///
  /// Broadcast Action: Sent after the system starts dreaming.
  ///
  /// <p class="note">This is a protected intent that can only be sent by the system.
  /// It is only sent to registered receivers.
  ///
  static const ACTION_DREAMING_STARTED =
      "android.intent.action.DREAMING_STARTED";

  /// from: static public final java.lang.String ACTION_DREAMING_STOPPED
  ///
  /// Broadcast Action: Sent after the system stops dreaming.
  ///
  /// <p class="note">This is a protected intent that can only be sent by the system.
  /// It is only sent to registered receivers.
  ///
  static const ACTION_DREAMING_STOPPED =
      "android.intent.action.DREAMING_STOPPED";

  /// from: static public final java.lang.String ACTION_EDIT
  ///
  /// Activity Action: Provide explicit editable access to the given data.
  /// Input: \#getData is URI of data to be edited.
  /// Output: nothing.
  static const ACTION_EDIT = "android.intent.action.EDIT";

  /// from: static public final java.lang.String ACTION_EXTERNAL_APPLICATIONS_AVAILABLE
  ///
  /// Broadcast Action: Resources for a set of packages (which were
  /// previously unavailable) are currently
  /// available since the media on which they exist is available.
  /// The extra data \#EXTRA_CHANGED_PACKAGE_LIST contains a
  /// list of packages whose availability changed.
  /// The extra data \#EXTRA_CHANGED_UID_LIST contains a
  /// list of uids of packages whose availability changed.
  /// Note that the
  /// packages in this list do _not_ receive this broadcast.
  /// The specified set of packages are now available on the system.
  /// Includes the following extras:
  /// <ul>
  /// <li> \#EXTRA_CHANGED_PACKAGE_LIST is the set of packages
  /// whose resources(were previously unavailable) are currently available.
  /// \#EXTRA_CHANGED_UID_LIST is the set of uids of the
  /// packages whose resources(were previously unavailable)
  /// are  currently available.
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_EXTERNAL_APPLICATIONS_AVAILABLE =
      "android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE";

  /// from: static public final java.lang.String ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE
  ///
  /// Broadcast Action: Resources for a set of packages are currently
  /// unavailable since the media on which they exist is unavailable.
  /// The extra data \#EXTRA_CHANGED_PACKAGE_LIST contains a
  /// list of packages whose availability changed.
  /// The extra data \#EXTRA_CHANGED_UID_LIST contains a
  /// list of uids of packages whose availability changed.
  /// The specified set of packages can no longer be
  /// launched and are practically unavailable on the system.
  /// Inclues the following extras:
  /// <ul>
  /// <li> \#EXTRA_CHANGED_PACKAGE_LIST is the set of packages
  /// whose resources are no longer available.
  /// \#EXTRA_CHANGED_UID_LIST is the set of packages
  /// whose resources are no longer available.
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE =
      "android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE";

  /// from: static public final java.lang.String ACTION_FACTORY_TEST
  ///
  /// Activity Action: Main entry point for factory tests.  Only used when
  ///  the device is booting in factory test node.  The implementing package
  ///  must be installed in the system image.
  ///  Input: nothing
  ///  Output: nothing
  static const ACTION_FACTORY_TEST = "android.intent.action.FACTORY_TEST";

  /// from: static public final java.lang.String ACTION_GET_CONTENT
  ///
  /// Activity Action: Allow the user to select a particular kind of data and
  /// return it.  This is different than \#ACTION_PICK in that here we
  /// just say what kind of data is desired, not a URI of existing data from
  /// which the user can pick.  An ACTION_GET_CONTENT could allow the user to
  /// create the data as it runs (for example taking a picture or recording a
  /// sound), let them browse over the web and download the desired data,
  /// etc.
  ///
  /// There are two main ways to use this action: if you want a specific kind
  /// of data, such as a person contact, you set the MIME type to the kind of
  /// data you want and launch it with Context\#startActivity(Intent).
  /// The system will then launch the best application to select that kind
  /// of data for you.
  ///
  /// You may also be interested in any of a set of types of content the user
  /// can pick.  For example, an e-mail application that wants to allow the
  /// user to add an attachment to an e-mail message can use this action to
  /// bring up a list of all of the types of content the user can attach.
  ///
  /// In this case, you should wrap the GET_CONTENT intent with a chooser
  /// (through \#createChooser), which will give the proper interface
  /// for the user to pick how to send your data and allow you to specify
  /// a prompt indicating what they are doing.  You will usually specify a
  /// broad MIME type (such as image/* or {@literal *}/*), resulting in a
  /// broad range of content types the user can select from.
  ///
  /// When using such a broad GET_CONTENT action, it is often desirable to
  /// only pick from data that can be represented as a stream.  This is
  /// accomplished by requiring the \#CATEGORY_OPENABLE in the Intent.
  ///
  /// Callers can optionally specify \#EXTRA_LOCAL_ONLY to request that
  /// the launched content chooser only returns results representing data that
  /// is locally available on the device.  For example, if this extra is set
  /// to true then an image picker should not show any pictures that are available
  /// from a remote server but not already on the local device (thus requiring
  /// they be downloaded when opened).
  ///
  /// If the caller can handle multiple returned items (the user performing
  /// multiple selection), then it can specify \#EXTRA_ALLOW_MULTIPLE
  /// to indicate this.
  ///
  /// Input: \#getType is the desired MIME type to retrieve.  Note
  /// that no URI is supplied in the intent, as there are no constraints on
  /// where the returned data originally comes from.  You may also include the
  /// \#CATEGORY_OPENABLE if you can only accept data that can be
  /// opened as a stream.  You may use \#EXTRA_LOCAL_ONLY to limit content
  /// selection to local data.  You may use \#EXTRA_ALLOW_MULTIPLE to
  /// allow the user to select multiple items.
  ///
  /// Output: The URI of the item that was picked.  This must be a content:
  /// URI so that any receiver can access it.
  static const ACTION_GET_CONTENT = "android.intent.action.GET_CONTENT";

  /// from: static public final java.lang.String ACTION_GET_RESTRICTION_ENTRIES
  ///
  /// Broadcast to a specific application to query any supported restrictions to impose
  /// on restricted users. The broadcast intent contains an extra
  /// \#EXTRA_RESTRICTIONS_BUNDLE with the currently persisted
  /// restrictions as a Bundle of key/value pairs. The value types can be Boolean, String or
  /// String[] depending on the restriction type.<p/>
  /// The response should contain an extra \#EXTRA_RESTRICTIONS_LIST,
  /// which is of type <code>ArrayList&lt;RestrictionEntry&gt;</code>. It can also
  /// contain an extra \#EXTRA_RESTRICTIONS_INTENT, which is of type <code>Intent</code>.
  /// The activity specified by that intent will be launched for a result which must contain
  /// one of the extras \#EXTRA_RESTRICTIONS_LIST or \#EXTRA_RESTRICTIONS_BUNDLE.
  /// The keys and values of the returned restrictions will be persisted.
  ///@see RestrictionEntry
  static const ACTION_GET_RESTRICTION_ENTRIES =
      "android.intent.action.GET_RESTRICTION_ENTRIES";

  /// from: static public final java.lang.String ACTION_GTALK_SERVICE_CONNECTED
  ///
  /// Broadcast Action: A GTalk connection has been established.
  static const ACTION_GTALK_SERVICE_CONNECTED =
      "android.intent.action.GTALK_CONNECTED";

  /// from: static public final java.lang.String ACTION_GTALK_SERVICE_DISCONNECTED
  ///
  /// Broadcast Action: A GTalk connection has been disconnected.
  static const ACTION_GTALK_SERVICE_DISCONNECTED =
      "android.intent.action.GTALK_DISCONNECTED";

  /// from: static public final java.lang.String ACTION_HEADSET_PLUG
  ///
  /// Broadcast Action: Wired Headset plugged in or unplugged.
  ///
  /// Same as android.media.AudioManager\#ACTION_HEADSET_PLUG, to be consulted for value
  ///   and documentation.
  /// If the minimum SDK version of your application is
  /// android.os.Build.VERSION_CODES\#LOLLIPOP, it is recommended to refer
  /// to the <code>AudioManager</code> constant in your receiver registration code instead.
  static const ACTION_HEADSET_PLUG = "android.intent.action.HEADSET_PLUG";

  /// from: static public final java.lang.String ACTION_INPUT_METHOD_CHANGED
  ///
  /// Broadcast Action: An input method has been changed.
  static const ACTION_INPUT_METHOD_CHANGED =
      "android.intent.action.INPUT_METHOD_CHANGED";

  /// from: static public final java.lang.String ACTION_INSERT
  ///
  /// Activity Action: Insert an empty item into the given container.
  /// Input: \#getData is URI of the directory (vnd.android.cursor.dir/*)
  /// in which to place the data.
  /// Output: URI of the new data that was created.
  static const ACTION_INSERT = "android.intent.action.INSERT";

  /// from: static public final java.lang.String ACTION_INSERT_OR_EDIT
  ///
  /// Activity Action: Pick an existing item, or insert a new item, and then edit it.
  /// Input: \#getType is the desired MIME type of the item to create or edit.
  /// The extras can contain type specific data to pass through to the editing/creating
  /// activity.
  /// Output: The URI of the item that was picked.  This must be a content:
  /// URI so that any receiver can access it.
  static const ACTION_INSERT_OR_EDIT = "android.intent.action.INSERT_OR_EDIT";

  /// from: static public final java.lang.String ACTION_INSTALL_FAILURE
  ///
  /// Activity Action: Activity to handle split installation failures.
  /// Splits may be installed dynamically. This happens when an Activity is launched,
  /// but the split that contains the application isn't installed. When a split is
  /// installed in this manner, the containing package usually doesn't know this is
  /// happening. However, if an error occurs during installation, the containing
  /// package can define a single activity handling this action to deal with such
  /// failures.
  /// The activity handling this action must be in the base package.
  ///
  /// Input: \#EXTRA_INTENT the original intent that started split installation.
  /// \#EXTRA_SPLIT_NAME the name of the split that failed to be installed.
  static const ACTION_INSTALL_FAILURE = "android.intent.action.INSTALL_FAILURE";

  /// from: static public final java.lang.String ACTION_INSTALL_PACKAGE
  ///
  /// Activity Action: Launch application installer.
  ///
  /// Input: The data must be a content: URI at which the application
  /// can be retrieved.  As of android.os.Build.VERSION_CODES\#JELLY_BEAN_MR1,
  /// you can also use "package:<package-name>" to install an application for the
  /// current user that is already installed for another user. You can optionally supply
  /// \#EXTRA_INSTALLER_PACKAGE_NAME, \#EXTRA_NOT_UNKNOWN_SOURCE,
  /// \#EXTRA_ALLOW_REPLACE, and \#EXTRA_RETURN_RESULT.
  ///
  /// Output: If \#EXTRA_RETURN_RESULT, returns whether the install
  /// succeeded.
  ///
  /// <strong>Note:</strong>If your app is targeting API level higher than 25 you
  /// need to hold android.Manifest.permission\#REQUEST_INSTALL_PACKAGES
  /// in order to launch the application installer.
  ///
  ///
  ///@see \#EXTRA_INSTALLER_PACKAGE_NAME
  ///@see \#EXTRA_NOT_UNKNOWN_SOURCE
  ///@see \#EXTRA_RETURN_RESULT
  static const ACTION_INSTALL_PACKAGE = "android.intent.action.INSTALL_PACKAGE";

  /// from: static public final java.lang.String ACTION_LOCALE_CHANGED
  ///
  /// Broadcast Action: The current device's locale has changed.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_LOCALE_CHANGED = "android.intent.action.LOCALE_CHANGED";

  /// from: static public final java.lang.String ACTION_LOCKED_BOOT_COMPLETED
  ///
  /// Broadcast Action: This is broadcast once, after the user has finished
  /// booting, but while still in the "locked" state. It can be used to perform
  /// application-specific initialization, such as installing alarms. You must
  /// hold the android.Manifest.permission\#RECEIVE_BOOT_COMPLETED
  /// permission in order to receive this broadcast.
  ///
  /// This broadcast is sent immediately at boot by all devices (regardless of
  /// direct boot support) running android.os.Build.VERSION_CODES\#N or
  /// higher. Upon receipt of this broadcast, the user is still locked and only
  /// device-protected storage can be accessed safely. If you want to access
  /// credential-protected storage, you need to wait for the user to be
  /// unlocked (typically by entering their lock pattern or PIN for the first
  /// time), after which the \#ACTION_USER_UNLOCKED and
  /// \#ACTION_BOOT_COMPLETED broadcasts are sent.
  ///
  /// To receive this broadcast, your receiver component must be marked as
  /// being ComponentInfo\#directBootAware.
  /// <p class="note">
  /// This is a protected intent that can only be sent by the system.
  ///@see Context\#createDeviceProtectedStorageContext()
  static const ACTION_LOCKED_BOOT_COMPLETED =
      "android.intent.action.LOCKED_BOOT_COMPLETED";

  /// from: static public final java.lang.String ACTION_MAIN
  ///
  /// Activity Action: Start as a main entry point, does not expect to
  ///  receive data.
  ///  Input: nothing
  ///  Output: nothing
  static const ACTION_MAIN = "android.intent.action.MAIN";

  /// from: static public final java.lang.String ACTION_MANAGED_PROFILE_ADDED
  ///
  /// Broadcast sent to the primary user when an associated managed profile is added (the profile
  /// was created and is ready to be used). Carries an extra \#EXTRA_USER that specifies
  /// the UserHandle of the profile that was added. Only applications (for example Launchers)
  /// that need to display merged content across both primary and managed profiles need to
  /// worry about this broadcast. This is only sent to registered receivers,
  /// not manifest receivers.
  static const ACTION_MANAGED_PROFILE_ADDED =
      "android.intent.action.MANAGED_PROFILE_ADDED";

  /// from: static public final java.lang.String ACTION_MANAGED_PROFILE_AVAILABLE
  ///
  /// Broadcast sent to the primary user when an associated managed profile has become available.
  /// Currently this includes when the user disables quiet mode for the profile. Carries an extra
  /// \#EXTRA_USER that specifies the UserHandle of the profile. When quiet mode is changed,
  /// this broadcast will carry a boolean extra \#EXTRA_QUIET_MODE indicating the new state
  /// of quiet mode. This is only sent to registered receivers, not manifest receivers.
  static const ACTION_MANAGED_PROFILE_AVAILABLE =
      "android.intent.action.MANAGED_PROFILE_AVAILABLE";

  /// from: static public final java.lang.String ACTION_MANAGED_PROFILE_REMOVED
  ///
  /// Broadcast sent to the primary user when an associated managed profile is removed. Carries an
  /// extra \#EXTRA_USER that specifies the UserHandle of the profile that was removed.
  /// Only applications (for example Launchers) that need to display merged content across both
  /// primary and managed profiles need to worry about this broadcast. This is only sent to
  /// registered receivers, not manifest receivers.
  static const ACTION_MANAGED_PROFILE_REMOVED =
      "android.intent.action.MANAGED_PROFILE_REMOVED";

  /// from: static public final java.lang.String ACTION_MANAGED_PROFILE_UNAVAILABLE
  ///
  /// Broadcast sent to the primary user when an associated managed profile has become unavailable.
  /// Currently this includes when the user enables quiet mode for the profile. Carries an extra
  /// \#EXTRA_USER that specifies the UserHandle of the profile. When quiet mode is changed,
  /// this broadcast will carry a boolean extra \#EXTRA_QUIET_MODE indicating the new state
  /// of quiet mode. This is only sent to registered receivers, not manifest receivers.
  static const ACTION_MANAGED_PROFILE_UNAVAILABLE =
      "android.intent.action.MANAGED_PROFILE_UNAVAILABLE";

  /// from: static public final java.lang.String ACTION_MANAGED_PROFILE_UNLOCKED
  ///
  /// Broadcast sent to the primary user when the credential-encrypted private storage for
  /// an associated managed profile is unlocked. Carries an extra \#EXTRA_USER that
  /// specifies the UserHandle of the profile that was unlocked. Only applications (for example
  /// Launchers) that need to display merged content across both primary and managed profiles
  /// need to worry about this broadcast. This is only sent to registered receivers,
  /// not manifest receivers.
  static const ACTION_MANAGED_PROFILE_UNLOCKED =
      "android.intent.action.MANAGED_PROFILE_UNLOCKED";

  /// from: static public final java.lang.String ACTION_MANAGE_NETWORK_USAGE
  ///
  /// Activity Action: Show settings for managing network data usage of a
  /// specific application. Applications should define an activity that offers
  /// options to control data usage.
  static const ACTION_MANAGE_NETWORK_USAGE =
      "android.intent.action.MANAGE_NETWORK_USAGE";

  /// from: static public final java.lang.String ACTION_MANAGE_PACKAGE_STORAGE
  ///
  /// Broadcast Action:  Indicates low memory condition notification acknowledged by user
  /// and package management should be started.
  /// This is triggered by the user from the ACTION_DEVICE_STORAGE_LOW
  /// notification.
  static const ACTION_MANAGE_PACKAGE_STORAGE =
      "android.intent.action.MANAGE_PACKAGE_STORAGE";

  /// from: static public final java.lang.String ACTION_MEDIA_BAD_REMOVAL
  ///
  /// Broadcast Action:  External media was removed from SD card slot, but mount point was not unmounted.
  /// The path to the mount point for the removed media is contained in the Intent.mData field.
  static const ACTION_MEDIA_BAD_REMOVAL =
      "android.intent.action.MEDIA_BAD_REMOVAL";

  /// from: static public final java.lang.String ACTION_MEDIA_BUTTON
  ///
  /// Broadcast Action:  The "Media Button" was pressed.  Includes a single
  /// extra field, \#EXTRA_KEY_EVENT, containing the key event that
  /// caused the broadcast.
  static const ACTION_MEDIA_BUTTON = "android.intent.action.MEDIA_BUTTON";

  /// from: static public final java.lang.String ACTION_MEDIA_CHECKING
  ///
  /// Broadcast Action:  External media is present, and being disk-checked
  /// The path to the mount point for the checking media is contained in the Intent.mData field.
  static const ACTION_MEDIA_CHECKING = "android.intent.action.MEDIA_CHECKING";

  /// from: static public final java.lang.String ACTION_MEDIA_EJECT
  ///
  /// Broadcast Action:  User has expressed the desire to remove the external storage media.
  /// Applications should close all files they have open within the mount point when they receive this intent.
  /// The path to the mount point for the media to be ejected is contained in the Intent.mData field.
  static const ACTION_MEDIA_EJECT = "android.intent.action.MEDIA_EJECT";

  /// from: static public final java.lang.String ACTION_MEDIA_MOUNTED
  ///
  /// Broadcast Action:  External media is present and mounted at its mount point.
  /// The path to the mount point for the mounted media is contained in the Intent.mData field.
  /// The Intent contains an extra with name "read-only" and Boolean value to indicate if the
  /// media was mounted read only.
  static const ACTION_MEDIA_MOUNTED = "android.intent.action.MEDIA_MOUNTED";

  /// from: static public final java.lang.String ACTION_MEDIA_NOFS
  ///
  /// Broadcast Action:  External media is present, but is using an incompatible fs (or is blank)
  /// The path to the mount point for the checking media is contained in the Intent.mData field.
  static const ACTION_MEDIA_NOFS = "android.intent.action.MEDIA_NOFS";

  /// from: static public final java.lang.String ACTION_MEDIA_REMOVED
  ///
  /// Broadcast Action:  External media has been removed.
  /// The path to the mount point for the removed media is contained in the Intent.mData field.
  static const ACTION_MEDIA_REMOVED = "android.intent.action.MEDIA_REMOVED";

  /// from: static public final java.lang.String ACTION_MEDIA_SCANNER_FINISHED
  ///
  /// Broadcast Action:  The media scanner has finished scanning a directory.
  /// The path to the scanned directory is contained in the Intent.mData field.
  static const ACTION_MEDIA_SCANNER_FINISHED =
      "android.intent.action.MEDIA_SCANNER_FINISHED";

  /// from: static public final java.lang.String ACTION_MEDIA_SCANNER_SCAN_FILE
  ///
  /// Broadcast Action:  Request the media scanner to scan a file and add it to the media database.
  /// The path to the file is contained in the Intent.mData field.
  static const ACTION_MEDIA_SCANNER_SCAN_FILE =
      "android.intent.action.MEDIA_SCANNER_SCAN_FILE";

  /// from: static public final java.lang.String ACTION_MEDIA_SCANNER_STARTED
  ///
  /// Broadcast Action:  The media scanner has started scanning a directory.
  /// The path to the directory being scanned is contained in the Intent.mData field.
  static const ACTION_MEDIA_SCANNER_STARTED =
      "android.intent.action.MEDIA_SCANNER_STARTED";

  /// from: static public final java.lang.String ACTION_MEDIA_SHARED
  ///
  /// Broadcast Action:  External media is unmounted because it is being shared via USB mass storage.
  /// The path to the mount point for the shared media is contained in the Intent.mData field.
  static const ACTION_MEDIA_SHARED = "android.intent.action.MEDIA_SHARED";

  /// from: static public final java.lang.String ACTION_MEDIA_UNMOUNTABLE
  ///
  /// Broadcast Action:  External media is present but cannot be mounted.
  /// The path to the mount point for the unmountable media is contained in the Intent.mData field.
  static const ACTION_MEDIA_UNMOUNTABLE =
      "android.intent.action.MEDIA_UNMOUNTABLE";

  /// from: static public final java.lang.String ACTION_MEDIA_UNMOUNTED
  ///
  /// Broadcast Action:  External media is present, but not mounted at its mount point.
  /// The path to the mount point for the unmounted media is contained in the Intent.mData field.
  static const ACTION_MEDIA_UNMOUNTED = "android.intent.action.MEDIA_UNMOUNTED";

  /// from: static public final java.lang.String ACTION_MY_PACKAGE_REPLACED
  ///
  /// Broadcast Action: A new version of your application has been installed
  /// over an existing one.  This is only sent to the application that was
  /// replaced.  It does not contain any additional data; to receive it, just
  /// use an intent filter for this action.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_MY_PACKAGE_REPLACED =
      "android.intent.action.MY_PACKAGE_REPLACED";

  /// from: static public final java.lang.String ACTION_MY_PACKAGE_SUSPENDED
  ///
  /// Broadcast Action: Sent to a package that has been suspended by the system. This is sent
  /// whenever a package is put into a suspended state or any of its app extras change while in the
  /// suspended state.
  ///  Optionally includes the following extras:
  /// <ul>
  ///     <li> \#EXTRA_SUSPENDED_PACKAGE_EXTRAS which is a Bundle which will contain
  ///     useful information for the app being suspended.
  /// </ul>
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system. _This will be delivered to BroadcastReceiver components declared in
  /// the manifest._
  ///@see \#ACTION_MY_PACKAGE_UNSUSPENDED
  ///@see \#EXTRA_SUSPENDED_PACKAGE_EXTRAS
  ///@see PackageManager\#isPackageSuspended()
  ///@see PackageManager\#getSuspendedPackageAppExtras()
  static const ACTION_MY_PACKAGE_SUSPENDED =
      "android.intent.action.MY_PACKAGE_SUSPENDED";

  /// from: static public final java.lang.String ACTION_MY_PACKAGE_UNSUSPENDED
  ///
  /// Broadcast Action: Sent to a package that has been unsuspended.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system. _This will be delivered to BroadcastReceiver components declared in
  /// the manifest._
  ///@see \#ACTION_MY_PACKAGE_SUSPENDED
  ///@see \#EXTRA_SUSPENDED_PACKAGE_EXTRAS
  ///@see PackageManager\#isPackageSuspended()
  ///@see PackageManager\#getSuspendedPackageAppExtras()
  static const ACTION_MY_PACKAGE_UNSUSPENDED =
      "android.intent.action.MY_PACKAGE_UNSUSPENDED";

  /// from: static public final java.lang.String ACTION_NEW_OUTGOING_CALL
  ///
  /// Broadcast Action: An outgoing call is about to be placed.
  ///
  /// The Intent will have the following extra value:
  ///
  /// <ul>
  ///   <li>_android.content.Intent\#EXTRA_PHONE_NUMBER_ -
  ///       the phone number originally intended to be dialed.</li>
  /// </ul>
  /// Once the broadcast is finished, the resultData is used as the actual
  /// number to call.  If  <code>null</code>, no call will be placed.
  ///
  /// It is perfectly acceptable for multiple receivers to process the
  /// outgoing call in turn: for example, a parental control application
  /// might verify that the user is authorized to place the call at that
  /// time, then a number-rewriting application might add an area code if
  /// one was not specified.
  ///
  /// For consistency, any receiver whose purpose is to prohibit phone
  /// calls should have a priority of 0, to ensure it will see the final
  /// phone number to be dialed.
  /// Any receiver whose purpose is to rewrite phone numbers to be called
  /// should have a positive priority.
  /// Negative priorities are reserved for the system for this broadcast;
  /// using them may cause problems.
  ///
  /// Any BroadcastReceiver receiving this Intent _must not_
  /// abort the broadcast.
  ///
  /// Emergency calls cannot be intercepted using this mechanism, and
  /// other calls cannot be modified to call emergency numbers using this
  /// mechanism.
  /// Some apps (such as VoIP apps) may want to redirect the outgoing
  /// call to use their own service instead. Those apps should first prevent
  /// the call from being placed by setting resultData to <code>null</code>
  /// and then start their own app to make the call.
  /// You must hold the
  /// android.Manifest.permission\#PROCESS_OUTGOING_CALLS
  /// permission to receive this Intent.
  ///
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_NEW_OUTGOING_CALL =
      "android.intent.action.NEW_OUTGOING_CALL";

  /// from: static public final java.lang.String ACTION_OPEN_DOCUMENT
  ///
  /// Activity Action: Allow the user to select and return one or more existing
  /// documents. When invoked, the system will display the various
  /// DocumentsProvider instances installed on the device, letting the
  /// user interactively navigate through them. These documents include local
  /// media, such as photos and video, and documents provided by installed
  /// cloud storage providers.
  ///
  /// Each document is represented as a {@code content://} URI backed by a
  /// DocumentsProvider, which can be opened as a stream with
  /// ContentResolver\#openFileDescriptor(Uri, String), or queried for
  /// android.provider.DocumentsContract.Document metadata.
  ///
  /// All selected documents are returned to the calling application with
  /// persistable read and write permission grants. If you want to maintain
  /// access to the documents across device reboots, you need to explicitly
  /// take the persistable permissions using
  /// ContentResolver\#takePersistableUriPermission(Uri, int).
  ///
  /// Callers must indicate the acceptable document MIME types through
  /// \#setType(String). For example, to select photos, use
  /// {@code image/*}. If multiple disjoint MIME types are acceptable, define
  /// them in \#EXTRA_MIME_TYPES and \#setType(String) to
  /// {@literal *}/*.
  ///
  /// If the caller can handle multiple returned items (the user performing
  /// multiple selection), then you can specify \#EXTRA_ALLOW_MULTIPLE
  /// to indicate this.
  ///
  /// Callers must include \#CATEGORY_OPENABLE in the Intent to obtain
  /// URIs that can be opened with
  /// ContentResolver\#openFileDescriptor(Uri, String).
  ///
  /// Callers can set a document URI through
  /// DocumentsContract\#EXTRA_INITIAL_URI to indicate the initial
  /// location of documents navigator. System will do its best to launch the
  /// navigator in the specified document if it's a folder, or the folder that
  /// contains the specified document if not.
  ///
  /// Output: The URI of the item that was picked, returned in
  /// \#getData(). This must be a {@code content://} URI so that any
  /// receiver can access it. If multiple documents were selected, they are
  /// returned in \#getClipData().
  ///@see DocumentsContract
  ///@see \#ACTION_OPEN_DOCUMENT_TREE
  ///@see \#ACTION_CREATE_DOCUMENT
  ///@see \#FLAG_GRANT_PERSISTABLE_URI_PERMISSION
  static const ACTION_OPEN_DOCUMENT = "android.intent.action.OPEN_DOCUMENT";

  /// from: static public final java.lang.String ACTION_OPEN_DOCUMENT_TREE
  ///
  /// Activity Action: Allow the user to pick a directory subtree. When
  /// invoked, the system will display the various DocumentsProvider
  /// instances installed on the device, letting the user navigate through
  /// them. Apps can fully manage documents within the returned directory.
  ///
  /// To gain access to descendant (child, grandchild, etc) documents, use
  /// DocumentsContract\#buildDocumentUriUsingTree(Uri, String) and
  /// DocumentsContract\#buildChildDocumentsUriUsingTree(Uri, String)
  /// with the returned URI.
  ///
  /// Callers can set a document URI through
  /// DocumentsContract\#EXTRA_INITIAL_URI to indicate the initial
  /// location of documents navigator. System will do its best to launch the
  /// navigator in the specified document if it's a folder, or the folder that
  /// contains the specified document if not.
  ///
  /// Output: The URI representing the selected directory tree.
  ///@see DocumentsContract
  static const ACTION_OPEN_DOCUMENT_TREE =
      "android.intent.action.OPEN_DOCUMENT_TREE";

  /// from: static public final java.lang.String ACTION_PACKAGES_SUSPENDED
  ///
  /// Broadcast Action: Packages have been suspended.
  /// Includes the following extras:
  /// <ul>
  /// <li> \#EXTRA_CHANGED_PACKAGE_LIST is the set of packages which have been suspended
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system. It is only sent to registered receivers.
  static const ACTION_PACKAGES_SUSPENDED =
      "android.intent.action.PACKAGES_SUSPENDED";

  /// from: static public final java.lang.String ACTION_PACKAGES_UNSUSPENDED
  ///
  /// Broadcast Action: Packages have been unsuspended.
  /// Includes the following extras:
  /// <ul>
  /// <li> \#EXTRA_CHANGED_PACKAGE_LIST is the set of packages which have been unsuspended
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system. It is only sent to registered receivers.
  static const ACTION_PACKAGES_UNSUSPENDED =
      "android.intent.action.PACKAGES_UNSUSPENDED";

  /// from: static public final java.lang.String ACTION_PACKAGE_ADDED
  ///
  /// Broadcast Action: A new application package has been installed on the
  /// device. The data contains the name of the package.  Note that the
  /// newly installed package does _not_ receive this broadcast.
  /// May include the following extras:
  /// <ul>
  /// <li> \#EXTRA_UID containing the integer uid assigned to the new package.
  /// <li> \#EXTRA_REPLACING is set to true if this is following
  /// an \#ACTION_PACKAGE_REMOVED broadcast for the same package.
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_PACKAGE_ADDED = "android.intent.action.PACKAGE_ADDED";

  /// from: static public final java.lang.String ACTION_PACKAGE_CHANGED
  ///
  /// Broadcast Action: An existing application package has been changed (for
  /// example, a component has been enabled or disabled).  The data contains
  /// the name of the package.
  /// <ul>
  /// <li> \#EXTRA_UID containing the integer uid assigned to the package.
  /// <li> \#EXTRA_CHANGED_COMPONENT_NAME_LIST containing the class name
  /// of the changed components (or the package name itself).
  /// <li> \#EXTRA_DONT_KILL_APP containing boolean field to override the
  /// default action of restarting the application.
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_PACKAGE_CHANGED = "android.intent.action.PACKAGE_CHANGED";

  /// from: static public final java.lang.String ACTION_PACKAGE_DATA_CLEARED
  ///
  /// Broadcast Action: The user has cleared the data of a package.  This should
  /// be preceded by \#ACTION_PACKAGE_RESTARTED, after which all of
  /// its persistent data is erased and this broadcast sent.
  /// Note that the cleared package does _not_
  /// receive this broadcast. The data contains the name of the package.
  /// <ul>
  /// <li> \#EXTRA_UID containing the integer uid assigned to the package. If the
  ///      package whose data was cleared is an uninstalled instant app, then the UID
  ///      will be -1. The platform keeps some meta-data associated with instant apps
  ///      after they are uninstalled.
  /// <li> \#EXTRA_PACKAGE_NAME containing the package name only if the cleared
  ///      data was for an instant app.
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_PACKAGE_DATA_CLEARED =
      "android.intent.action.PACKAGE_DATA_CLEARED";

  /// from: static public final java.lang.String ACTION_PACKAGE_FIRST_LAUNCH
  ///
  /// Broadcast Action: Sent to the installer package of an application when
  /// that application is first launched (that is the first time it is moved
  /// out of the stopped state).  The data contains the name of the package.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_PACKAGE_FIRST_LAUNCH =
      "android.intent.action.PACKAGE_FIRST_LAUNCH";

  /// from: static public final java.lang.String ACTION_PACKAGE_FULLY_REMOVED
  ///
  /// Broadcast Action: An existing application package has been completely
  /// removed from the device.  The data contains the name of the package.
  /// This is like \#ACTION_PACKAGE_REMOVED, but only set when
  /// \#EXTRA_DATA_REMOVED is true and
  /// \#EXTRA_REPLACING is false of that broadcast.
  ///
  /// <ul>
  /// <li> \#EXTRA_UID containing the integer uid previously assigned
  /// to the package.
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_PACKAGE_FULLY_REMOVED =
      "android.intent.action.PACKAGE_FULLY_REMOVED";

  /// from: static public final java.lang.String ACTION_PACKAGE_INSTALL
  ///
  /// Broadcast Action: Trigger the download and eventual installation
  /// of a package.
  /// Input: \#getData is the URI of the package file to download.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  ///@deprecated This constant has never been used.
  static const ACTION_PACKAGE_INSTALL = "android.intent.action.PACKAGE_INSTALL";

  /// from: static public final java.lang.String ACTION_PACKAGE_NEEDS_VERIFICATION
  ///
  /// Broadcast Action: Sent to the system package verifier when a package
  /// needs to be verified. The data contains the package URI.
  /// <p class="note">
  /// This is a protected intent that can only be sent by the system.
  ///
  ///
  static const ACTION_PACKAGE_NEEDS_VERIFICATION =
      "android.intent.action.PACKAGE_NEEDS_VERIFICATION";

  /// from: static public final java.lang.String ACTION_PACKAGE_REMOVED
  ///
  /// Broadcast Action: An existing application package has been removed from
  /// the device.  The data contains the name of the package.  The package
  /// that is being removed does _not_ receive this Intent.
  /// <ul>
  /// <li> \#EXTRA_UID containing the integer uid previously assigned
  /// to the package.
  /// <li> \#EXTRA_DATA_REMOVED is set to true if the entire
  /// application -- data and code -- is being removed.
  /// <li> \#EXTRA_REPLACING is set to true if this will be followed
  /// by an \#ACTION_PACKAGE_ADDED broadcast for the same package.
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_PACKAGE_REMOVED = "android.intent.action.PACKAGE_REMOVED";

  /// from: static public final java.lang.String ACTION_PACKAGE_REPLACED
  ///
  /// Broadcast Action: A new version of an application package has been
  /// installed, replacing an existing version that was previously installed.
  /// The data contains the name of the package.
  /// May include the following extras:
  /// <ul>
  /// <li> \#EXTRA_UID containing the integer uid assigned to the new package.
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_PACKAGE_REPLACED =
      "android.intent.action.PACKAGE_REPLACED";

  /// from: static public final java.lang.String ACTION_PACKAGE_RESTARTED
  ///
  /// Broadcast Action: The user has restarted a package, and all of its
  /// processes have been killed.  All runtime state
  /// associated with it (processes, alarms, notifications, etc) should
  /// be removed.  Note that the restarted package does _not_
  /// receive this broadcast.
  /// The data contains the name of the package.
  /// <ul>
  /// <li> \#EXTRA_UID containing the integer uid assigned to the package.
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_PACKAGE_RESTARTED =
      "android.intent.action.PACKAGE_RESTARTED";

  /// from: static public final java.lang.String ACTION_PACKAGE_VERIFIED
  ///
  /// Broadcast Action: Sent to the system package verifier when a package is
  /// verified. The data contains the package URI.
  /// <p class="note">
  /// This is a protected intent that can only be sent by the system.
  static const ACTION_PACKAGE_VERIFIED =
      "android.intent.action.PACKAGE_VERIFIED";

  /// from: static public final java.lang.String ACTION_PASTE
  ///
  /// Activity Action: Create a new item in the given container, initializing it
  /// from the current contents of the clipboard.
  /// Input: \#getData is URI of the directory (vnd.android.cursor.dir/*)
  /// in which to place the data.
  /// Output: URI of the new data that was created.
  static const ACTION_PASTE = "android.intent.action.PASTE";

  /// from: static public final java.lang.String ACTION_PICK
  ///
  /// Activity Action: Pick an item from the data, returning what was selected.
  /// Input: \#getData is URI containing a directory of data
  /// (vnd.android.cursor.dir/*) from which to pick an item.
  /// Output: The URI of the item that was picked.
  static const ACTION_PICK = "android.intent.action.PICK";

  /// from: static public final java.lang.String ACTION_PICK_ACTIVITY
  ///
  /// Activity Action: Pick an activity given an intent, returning the class
  /// selected.
  /// Input: get*Extra field \#EXTRA_INTENT is an Intent
  /// used with PackageManager\#queryIntentActivities to determine the
  /// set of activities from which to pick.
  /// Output: Class name of the activity that was selected.
  static const ACTION_PICK_ACTIVITY = "android.intent.action.PICK_ACTIVITY";

  /// from: static public final java.lang.String ACTION_POWER_CONNECTED
  ///
  /// Broadcast Action:  External power has been connected to the device.
  /// This is intended for applications that wish to register specifically to this notification.
  /// Unlike ACTION_BATTERY_CHANGED, applications will be woken for this and so do not have to
  /// stay active to receive this notification.  This action can be used to implement actions
  /// that wait until power is available to trigger.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_POWER_CONNECTED =
      "android.intent.action.ACTION_POWER_CONNECTED";

  /// from: static public final java.lang.String ACTION_POWER_DISCONNECTED
  ///
  /// Broadcast Action:  External power has been removed from the device.
  /// This is intended for applications that wish to register specifically to this notification.
  /// Unlike ACTION_BATTERY_CHANGED, applications will be woken for this and so do not have to
  /// stay active to receive this notification.  This action can be used to implement actions
  /// that wait until power is available to trigger.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_POWER_DISCONNECTED =
      "android.intent.action.ACTION_POWER_DISCONNECTED";

  /// from: static public final java.lang.String ACTION_POWER_USAGE_SUMMARY
  ///
  /// Activity Action: Show power usage information to the user.
  /// Input: Nothing.
  /// Output: Nothing.
  static const ACTION_POWER_USAGE_SUMMARY =
      "android.intent.action.POWER_USAGE_SUMMARY";

  /// from: static public final java.lang.String ACTION_PROCESS_TEXT
  ///
  /// Activity Action: Process a piece of text.
  /// Input: \#EXTRA_PROCESS_TEXT contains the text to be processed.
  /// \#EXTRA_PROCESS_TEXT_READONLY states if the resulting text will be read-only.
  ///
  /// Output: \#EXTRA_PROCESS_TEXT contains the processed text.
  ///
  static const ACTION_PROCESS_TEXT = "android.intent.action.PROCESS_TEXT";

  /// from: static public final java.lang.String ACTION_PROVIDER_CHANGED
  ///
  /// Broadcast Action: Some content providers have parts of their namespace
  /// where they publish new events or items that the user may be especially
  /// interested in. For these things, they may broadcast this action when the
  /// set of interesting items change.
  ///
  /// For example, GmailProvider sends this notification when the set of unread
  /// mail in the inbox changes.
  ///
  /// The data of the intent identifies which part of which provider
  /// changed. When queried through the content resolver, the data URI will
  /// return the data set in question.
  ///
  /// The intent will have the following extra values:
  /// <ul>
  ///   <li>_count_ - The number of items in the data set. This is the
  ///       same as the number of items in the cursor returned by querying the
  ///       data URI. </li>
  /// </ul>
  ///
  /// This intent will be sent at boot (if the count is non-zero) and when the
  /// data set changes. It is possible for the data set to change without the
  /// count changing (for example, if a new unread message arrives in the same
  /// sync operation in which a message is archived). The phone should still
  /// ring/vibrate/etc as normal in this case.
  static const ACTION_PROVIDER_CHANGED =
      "android.intent.action.PROVIDER_CHANGED";

  /// from: static public final java.lang.String ACTION_QUICK_CLOCK
  ///
  /// Sent when the user taps on the clock widget in the system's "quick settings" area.
  static const ACTION_QUICK_CLOCK = "android.intent.action.QUICK_CLOCK";

  /// from: static public final java.lang.String ACTION_QUICK_VIEW
  ///
  /// Activity Action: Quick view the data. Launches a quick viewer for
  /// a URI or a list of URIs.
  /// Activities handling this intent action should handle the vast majority of
  /// MIME types rather than only specific ones.
  /// Quick viewers must render the quick view image locally, and must not send
  /// file content outside current device.
  /// Input: \#getData is a mandatory content URI of the item to
  /// preview. \#getClipData contains an optional list of content URIs
  /// if there is more than one item to preview. \#EXTRA_INDEX is an
  /// optional index of the URI in the clip data to show first.
  /// \#EXTRA_QUICK_VIEW_FEATURES is an optional extra indicating the features
  /// that can be shown in the quick view UI.
  /// Output: nothing.
  ///@see \#EXTRA_INDEX
  ///@see \#EXTRA_QUICK_VIEW_FEATURES
  static const ACTION_QUICK_VIEW = "android.intent.action.QUICK_VIEW";

  /// from: static public final java.lang.String ACTION_REBOOT
  ///
  /// Broadcast Action: Have the device reboot.  This is only for use by
  /// system code.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_REBOOT = "android.intent.action.REBOOT";

  /// from: static public final java.lang.String ACTION_RUN
  ///
  /// Activity Action: Run the data, whatever that means.
  /// Input: ?  (Note: this is currently specific to the test harness.)
  /// Output: nothing.
  static const ACTION_RUN = "android.intent.action.RUN";

  /// from: static public final java.lang.String ACTION_SCREEN_OFF
  ///
  /// Broadcast Action: Sent when the device goes to sleep and becomes non-interactive.
  ///
  /// For historical reasons, the name of this broadcast action refers to the power
  /// state of the screen but it is actually sent in response to changes in the
  /// overall interactive state of the device.
  ///
  ///
  /// This broadcast is sent when the device becomes non-interactive which may have
  /// nothing to do with the screen turning off.  To determine the
  /// actual state of the screen, use android.view.Display\#getState.
  ///
  ///
  /// See android.os.PowerManager\#isInteractive for details.
  ///
  ///
  /// You _cannot_ receive this through components declared in
  /// manifests, only by explicitly registering for it with
  /// Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver().
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_SCREEN_OFF = "android.intent.action.SCREEN_OFF";

  /// from: static public final java.lang.String ACTION_SCREEN_ON
  ///
  /// Broadcast Action: Sent when the device wakes up and becomes interactive.
  ///
  /// For historical reasons, the name of this broadcast action refers to the power
  /// state of the screen but it is actually sent in response to changes in the
  /// overall interactive state of the device.
  ///
  ///
  /// This broadcast is sent when the device becomes interactive which may have
  /// nothing to do with the screen turning on.  To determine the
  /// actual state of the screen, use android.view.Display\#getState.
  ///
  ///
  /// See android.os.PowerManager\#isInteractive for details.
  ///
  ///
  /// You _cannot_ receive this through components declared in
  /// manifests, only by explicitly registering for it with
  /// Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver().
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_SCREEN_ON = "android.intent.action.SCREEN_ON";

  /// from: static public final java.lang.String ACTION_SEARCH
  ///
  /// Activity Action: Perform a search.
  /// Input: android.app.SearchManager\#QUERY getStringExtra(SearchManager.QUERY)
  /// is the text to search for.  If empty, simply
  /// enter your search results Activity with the search UI activated.
  /// Output: nothing.
  static const ACTION_SEARCH = "android.intent.action.SEARCH";

  /// from: static public final java.lang.String ACTION_SEARCH_LONG_PRESS
  ///
  /// Activity Action: Start action associated with long pressing on the
  /// search key.
  /// Input: Nothing.
  /// Output: Nothing.
  static const ACTION_SEARCH_LONG_PRESS =
      "android.intent.action.SEARCH_LONG_PRESS";

  /// from: static public final java.lang.String ACTION_SEND
  ///
  /// Activity Action: Deliver some data to someone else.  Who the data is
  /// being delivered to is not specified; it is up to the receiver of this
  /// action to ask the user where the data should be sent.
  ///
  /// When launching a SEND intent, you should usually wrap it in a chooser
  /// (through \#createChooser), which will give the proper interface
  /// for the user to pick how to send your data and allow you to specify
  /// a prompt indicating what they are doing.
  ///
  /// Input: \#getType is the MIME type of the data being sent.
  /// get*Extra can have either a \#EXTRA_TEXT
  /// or \#EXTRA_STREAM field, containing the data to be sent.  If
  /// using EXTRA_TEXT, the MIME type should be "text/plain"; otherwise it
  /// should be the MIME type of the data in EXTRA_STREAM.  Use {@literal *}/*
  /// if the MIME type is unknown (this will only allow senders that can
  /// handle generic data streams).  If using \#EXTRA_TEXT, you can
  /// also optionally supply \#EXTRA_HTML_TEXT for clients to retrieve
  /// your text with HTML formatting.
  ///
  /// As of android.os.Build.VERSION_CODES\#JELLY_BEAN, the data
  /// being sent can be supplied through \#setClipData(ClipData).  This
  /// allows you to use \#FLAG_GRANT_READ_URI_PERMISSION when sharing
  /// content: URIs and other advanced features of ClipData.  If
  /// using this approach, you still must supply the same data through the
  /// \#EXTRA_TEXT or \#EXTRA_STREAM fields described below
  /// for compatibility with old applications.  If you don't set a ClipData,
  /// it will be copied there for you when calling Context\#startActivity(Intent).
  ///
  /// Starting from android.os.Build.VERSION_CODES\#O, if
  /// \#CATEGORY_TYPED_OPENABLE is passed, then the Uris passed in
  /// either \#EXTRA_STREAM or via \#setClipData(ClipData) may
  /// be openable only as asset typed files using
  /// ContentResolver\#openTypedAssetFileDescriptor(Uri, String, Bundle).
  ///
  /// Optional standard extras, which may be interpreted by some recipients as
  /// appropriate, are: \#EXTRA_EMAIL, \#EXTRA_CC,
  /// \#EXTRA_BCC, \#EXTRA_SUBJECT.
  ///
  /// Output: nothing.
  static const ACTION_SEND = "android.intent.action.SEND";

  /// from: static public final java.lang.String ACTION_SENDTO
  ///
  /// Activity Action: Send a message to someone specified by the data.
  /// Input: \#getData is URI describing the target.
  /// Output: nothing.
  static const ACTION_SENDTO = "android.intent.action.SENDTO";

  /// from: static public final java.lang.String ACTION_SEND_MULTIPLE
  ///
  /// Activity Action: Deliver multiple data to someone else.
  ///
  /// Like \#ACTION_SEND, except the data is multiple.
  ///
  /// Input: \#getType is the MIME type of the data being sent.
  /// get*ArrayListExtra can have either a \#EXTRA_TEXT or \#EXTRA_STREAM field, containing the data to be sent.  If using
  /// \#EXTRA_TEXT, you can also optionally supply \#EXTRA_HTML_TEXT
  /// for clients to retrieve your text with HTML formatting.
  ///
  /// Multiple types are supported, and receivers should handle mixed types
  /// whenever possible. The right way for the receiver to check them is to
  /// use the content resolver on each URI. The intent sender should try to
  /// put the most concrete mime type in the intent type, but it can fall
  /// back to {@literal <type>/*} or {@literal *}/* as needed.
  ///
  /// e.g. if you are sending image/jpg and image/jpg, the intent's type can
  /// be image/jpg, but if you are sending image/jpg and image/png, then the
  /// intent's type should be image/*.
  ///
  /// As of android.os.Build.VERSION_CODES\#JELLY_BEAN, the data
  /// being sent can be supplied through \#setClipData(ClipData).  This
  /// allows you to use \#FLAG_GRANT_READ_URI_PERMISSION when sharing
  /// content: URIs and other advanced features of ClipData.  If
  /// using this approach, you still must supply the same data through the
  /// \#EXTRA_TEXT or \#EXTRA_STREAM fields described below
  /// for compatibility with old applications.  If you don't set a ClipData,
  /// it will be copied there for you when calling Context\#startActivity(Intent).
  ///
  /// Starting from android.os.Build.VERSION_CODES\#O, if
  /// \#CATEGORY_TYPED_OPENABLE is passed, then the Uris passed in
  /// either \#EXTRA_STREAM or via \#setClipData(ClipData) may
  /// be openable only as asset typed files using
  /// ContentResolver\#openTypedAssetFileDescriptor(Uri, String, Bundle).
  ///
  /// Optional standard extras, which may be interpreted by some recipients as
  /// appropriate, are: \#EXTRA_EMAIL, \#EXTRA_CC,
  /// \#EXTRA_BCC, \#EXTRA_SUBJECT.
  ///
  /// Output: nothing.
  static const ACTION_SEND_MULTIPLE = "android.intent.action.SEND_MULTIPLE";

  /// from: static public final java.lang.String ACTION_SET_WALLPAPER
  ///
  /// Activity Action: Show settings for choosing wallpaper.
  /// Input: Nothing.
  /// Output: Nothing.
  static const ACTION_SET_WALLPAPER = "android.intent.action.SET_WALLPAPER";

  /// from: static public final java.lang.String ACTION_SHOW_APP_INFO
  ///
  /// Activity Action: Launch an activity showing the app information.
  /// For applications which install other applications (such as app stores), it is recommended
  /// to handle this action for providing the app information to the user.
  ///
  /// Input: \#EXTRA_PACKAGE_NAME specifies the package whose information needs
  /// to be displayed.
  /// Output: Nothing.
  static const ACTION_SHOW_APP_INFO = "android.intent.action.SHOW_APP_INFO";

  /// from: static public final java.lang.String ACTION_SHUTDOWN
  ///
  /// Broadcast Action:  Device is shutting down.
  /// This is broadcast when the device is being shut down (completely turned
  /// off, not sleeping).  Once the broadcast is complete, the final shutdown
  /// will proceed and all unsaved data lost.  Apps will not normally need
  /// to handle this, since the foreground activity will be paused as well.
  /// As of Build.VERSION_CODES\#P this broadcast is only sent to receivers registered
  /// through Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  /// May include the following extras:
  /// <ul>
  /// <li> \#EXTRA_SHUTDOWN_USERSPACE_ONLY a boolean that is set to true if this
  /// shutdown is only for userspace processes.  If not set, assumed to be false.
  /// </ul>
  static const ACTION_SHUTDOWN = "android.intent.action.ACTION_SHUTDOWN";

  /// from: static public final java.lang.String ACTION_SYNC
  ///
  /// Activity Action: Perform a data synchronization.
  /// Input: ?
  /// Output: ?
  static const ACTION_SYNC = "android.intent.action.SYNC";

  /// from: static public final java.lang.String ACTION_SYSTEM_TUTORIAL
  ///
  /// Activity Action: Start the platform-defined tutorial
  /// Input: android.app.SearchManager\#QUERY getStringExtra(SearchManager.QUERY)
  /// is the text to search for.  If empty, simply
  /// enter your search results Activity with the search UI activated.
  /// Output: nothing.
  static const ACTION_SYSTEM_TUTORIAL = "android.intent.action.SYSTEM_TUTORIAL";

  /// from: static public final java.lang.String ACTION_TIMEZONE_CHANGED
  ///
  /// Broadcast Action: The timezone has changed. The intent will have the following extra values:
  ///
  /// <ul>
  ///   <li>_time-zone_ - The java.util.TimeZone.getID() value identifying the new time zone.</li>
  /// </ul>
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_TIMEZONE_CHANGED =
      "android.intent.action.TIMEZONE_CHANGED";

  /// from: static public final java.lang.String ACTION_TIME_CHANGED
  ///
  /// Broadcast Action: The time was set.
  static const ACTION_TIME_CHANGED = "android.intent.action.TIME_SET";

  /// from: static public final java.lang.String ACTION_TIME_TICK
  ///
  /// Broadcast Action: The current time has changed.  Sent every
  /// minute.  You _cannot_ receive this through components declared
  /// in manifests, only by explicitly registering for it with
  /// Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver().
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_TIME_TICK = "android.intent.action.TIME_TICK";

  /// from: static public final java.lang.String ACTION_UID_REMOVED
  ///
  /// Broadcast Action: A user ID has been removed from the system.  The user
  /// ID number is stored in the extra data under \#EXTRA_UID.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_UID_REMOVED = "android.intent.action.UID_REMOVED";

  /// from: static public final java.lang.String ACTION_UMS_CONNECTED
  ///
  /// Broadcast Action:  The device has entered USB Mass Storage mode.
  /// This is used mainly for the USB Settings panel.
  /// Apps should listen for ACTION_MEDIA_MOUNTED and ACTION_MEDIA_UNMOUNTED broadcasts to be notified
  /// when the SD card file system is mounted or unmounted
  ///@deprecated replaced by android.os.storage.StorageEventListener
  static const ACTION_UMS_CONNECTED = "android.intent.action.UMS_CONNECTED";

  /// from: static public final java.lang.String ACTION_UMS_DISCONNECTED
  ///
  /// Broadcast Action:  The device has exited USB Mass Storage mode.
  /// This is used mainly for the USB Settings panel.
  /// Apps should listen for ACTION_MEDIA_MOUNTED and ACTION_MEDIA_UNMOUNTED broadcasts to be notified
  /// when the SD card file system is mounted or unmounted
  ///@deprecated replaced by android.os.storage.StorageEventListener
  static const ACTION_UMS_DISCONNECTED =
      "android.intent.action.UMS_DISCONNECTED";

  /// from: static public final java.lang.String ACTION_UNINSTALL_PACKAGE
  ///
  /// Activity Action: Launch application uninstaller.
  ///
  /// Input: The data must be a package: URI whose scheme specific part is
  /// the package name of the current installed package to be uninstalled.
  /// You can optionally supply \#EXTRA_RETURN_RESULT.
  ///
  /// Output: If \#EXTRA_RETURN_RESULT, returns whether the install
  /// succeeded.
  ///
  /// Requires android.Manifest.permission\#REQUEST_DELETE_PACKAGES
  /// since Build.VERSION_CODES\#P.
  static const ACTION_UNINSTALL_PACKAGE =
      "android.intent.action.UNINSTALL_PACKAGE";

  /// from: static public final java.lang.String ACTION_USER_BACKGROUND
  ///
  /// Sent when a user switch is happening, causing the process's user to be
  /// sent to the background.  This is only sent to receivers registered
  /// through Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver.  It is sent to the user that is going to the
  /// background.  This is sent as a foreground
  /// broadcast, since it is part of a visible user interaction; be as quick
  /// as possible when handling it.
  static const ACTION_USER_BACKGROUND = "android.intent.action.USER_BACKGROUND";

  /// from: static public final java.lang.String ACTION_USER_FOREGROUND
  ///
  /// Sent when a user switch is happening, causing the process's user to be
  /// brought to the foreground.  This is only sent to receivers registered
  /// through Context\#registerReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver.  It is sent to the user that is going to the
  /// foreground.  This is sent as a foreground
  /// broadcast, since it is part of a visible user interaction; be as quick
  /// as possible when handling it.
  static const ACTION_USER_FOREGROUND = "android.intent.action.USER_FOREGROUND";

  /// from: static public final java.lang.String ACTION_USER_INITIALIZE
  ///
  /// Sent the first time a user is starting, to allow system apps to
  /// perform one time initialization.  (This will not be seen by third
  /// party applications because a newly initialized user does not have any
  /// third party applications installed for it.)  This is sent early in
  /// starting the user, around the time the home app is started, before
  /// \#ACTION_BOOT_COMPLETED is sent.  This is sent as a foreground
  /// broadcast, since it is part of a visible user interaction; be as quick
  /// as possible when handling it.
  static const ACTION_USER_INITIALIZE = "android.intent.action.USER_INITIALIZE";

  /// from: static public final java.lang.String ACTION_USER_PRESENT
  ///
  /// Broadcast Action: Sent when the user is present after device wakes up (e.g when the
  /// keyguard is gone).
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_USER_PRESENT = "android.intent.action.USER_PRESENT";

  /// from: static public final java.lang.String ACTION_USER_UNLOCKED
  ///
  /// Broadcast Action: Sent when the credential-encrypted private storage has
  /// become unlocked for the target user. This is only sent to registered
  /// receivers, not manifest receivers.
  static const ACTION_USER_UNLOCKED = "android.intent.action.USER_UNLOCKED";

  /// from: static public final java.lang.String ACTION_VIEW
  ///
  /// Activity Action: Display the data to the user.  This is the most common
  /// action performed on data -- it is the generic action you can use on
  /// a piece of data to get the most reasonable thing to occur.  For example,
  /// when used on a contacts entry it will view the entry; when used on a
  /// mailto: URI it will bring up a compose window filled with the information
  /// supplied by the URI; when used with a tel: URI it will invoke the
  /// dialer.
  /// Input: \#getData is URI from which to retrieve data.
  /// Output: nothing.
  static const ACTION_VIEW = "android.intent.action.VIEW";

  /// from: static public final java.lang.String ACTION_VOICE_COMMAND
  ///
  /// Activity Action: Start Voice Command.
  /// Input: Nothing.
  /// Output: Nothing.
  /// <p class="note">
  /// In some cases, a matching Activity may not exist, so ensure you
  /// safeguard against this.
  static const ACTION_VOICE_COMMAND = "android.intent.action.VOICE_COMMAND";

  /// from: static public final java.lang.String ACTION_WALLPAPER_CHANGED
  ///
  /// Broadcast Action:  The current system wallpaper has changed.  See
  /// android.app.WallpaperManager for retrieving the new wallpaper.
  /// This should _only_ be used to determine when the wallpaper
  /// has changed to show the new wallpaper to the user.  You should certainly
  /// never, in response to this, change the wallpaper or other attributes of
  /// it such as the suggested size.  That would be crazy, right?  You'd cause
  /// all kinds of loops, especially if other apps are doing similar things,
  /// right?  Of course.  So please don't do this.
  ///@deprecated Modern applications should use
  /// android.view.WindowManager.LayoutParams\#FLAG_SHOW_WALLPAPER WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER to have the wallpaper
  /// shown behind their UI, rather than watching for this broadcast and
  /// rendering the wallpaper on their own.
  static const ACTION_WALLPAPER_CHANGED =
      "android.intent.action.WALLPAPER_CHANGED";

  /// from: static public final java.lang.String ACTION_WEB_SEARCH
  ///
  /// Activity Action: Perform a web search.
  ///
  /// Input: android.app.SearchManager\#QUERY getStringExtra(SearchManager.QUERY) is the text to search for. If it is
  /// a url starts with http or https, the site will be opened. If it is plain
  /// text, Google search will be applied.
  ///
  /// Output: nothing.
  static const ACTION_WEB_SEARCH = "android.intent.action.WEB_SEARCH";

  /// from: static public final java.lang.String CATEGORY_ALTERNATIVE
  ///
  /// Set if the activity should be considered as an alternative action to
  /// the data the user is currently viewing.  See also
  /// \#CATEGORY_SELECTED_ALTERNATIVE for an alternative action that
  /// applies to the selection in a list of items.
  ///
  /// Supporting this category means that you would like your activity to be
  /// displayed in the set of alternative things the user can do, usually as
  /// part of the current activity's options menu.  You will usually want to
  /// include a specific label in the &lt;intent-filter&gt; of this action
  /// describing to the user what it does.
  ///
  /// The action of IntentFilter with this category is important in that it
  /// describes the specific action the target will perform.  This generally
  /// should not be a generic action (such as \#ACTION_VIEW, but rather
  /// a specific name such as "com.android.camera.action.CROP.  Only one
  /// alternative of any particular action will be shown to the user, so using
  /// a specific action like this makes sure that your alternative will be
  /// displayed while also allowing other applications to provide their own
  /// overrides of that particular action.
  static const CATEGORY_ALTERNATIVE = "android.intent.category.ALTERNATIVE";

  /// from: static public final java.lang.String CATEGORY_APP_BROWSER
  ///
  /// Used with \#ACTION_MAIN to launch the browser application.
  /// The activity should be able to browse the Internet.
  /// NOTE: This should not be used as the primary key of an Intent,
  /// since it will not result in the app launching with the correct
  /// action and category.  Instead, use this with
  /// \#makeMainSelectorActivity(String, String) to generate a main
  /// Intent with this category in the selector.
  ///
  static const CATEGORY_APP_BROWSER = "android.intent.category.APP_BROWSER";

  /// from: static public final java.lang.String CATEGORY_APP_CALCULATOR
  ///
  /// Used with \#ACTION_MAIN to launch the calculator application.
  /// The activity should be able to perform standard arithmetic operations.
  /// NOTE: This should not be used as the primary key of an Intent,
  /// since it will not result in the app launching with the correct
  /// action and category.  Instead, use this with
  /// \#makeMainSelectorActivity(String, String) to generate a main
  /// Intent with this category in the selector.
  ///
  static const CATEGORY_APP_CALCULATOR =
      "android.intent.category.APP_CALCULATOR";

  /// from: static public final java.lang.String CATEGORY_APP_CALENDAR
  ///
  /// Used with \#ACTION_MAIN to launch the calendar application.
  /// The activity should be able to view and manipulate calendar entries.
  /// NOTE: This should not be used as the primary key of an Intent,
  /// since it will not result in the app launching with the correct
  /// action and category.  Instead, use this with
  /// \#makeMainSelectorActivity(String, String) to generate a main
  /// Intent with this category in the selector.
  ///
  static const CATEGORY_APP_CALENDAR = "android.intent.category.APP_CALENDAR";

  /// from: static public final java.lang.String CATEGORY_APP_CONTACTS
  ///
  /// Used with \#ACTION_MAIN to launch the contacts application.
  /// The activity should be able to view and manipulate address book entries.
  /// NOTE: This should not be used as the primary key of an Intent,
  /// since it will not result in the app launching with the correct
  /// action and category.  Instead, use this with
  /// \#makeMainSelectorActivity(String, String) to generate a main
  /// Intent with this category in the selector.
  ///
  static const CATEGORY_APP_CONTACTS = "android.intent.category.APP_CONTACTS";

  /// from: static public final java.lang.String CATEGORY_APP_EMAIL
  ///
  /// Used with \#ACTION_MAIN to launch the email application.
  /// The activity should be able to send and receive email.
  /// NOTE: This should not be used as the primary key of an Intent,
  /// since it will not result in the app launching with the correct
  /// action and category.  Instead, use this with
  /// \#makeMainSelectorActivity(String, String) to generate a main
  /// Intent with this category in the selector.
  ///
  static const CATEGORY_APP_EMAIL = "android.intent.category.APP_EMAIL";

  /// from: static public final java.lang.String CATEGORY_APP_GALLERY
  ///
  /// Used with \#ACTION_MAIN to launch the gallery application.
  /// The activity should be able to view and manipulate image and video files
  /// stored on the device.
  /// NOTE: This should not be used as the primary key of an Intent,
  /// since it will not result in the app launching with the correct
  /// action and category.  Instead, use this with
  /// \#makeMainSelectorActivity(String, String) to generate a main
  /// Intent with this category in the selector.
  ///
  static const CATEGORY_APP_GALLERY = "android.intent.category.APP_GALLERY";

  /// from: static public final java.lang.String CATEGORY_APP_MAPS
  ///
  /// Used with \#ACTION_MAIN to launch the maps application.
  /// The activity should be able to show the user's current location and surroundings.
  /// NOTE: This should not be used as the primary key of an Intent,
  /// since it will not result in the app launching with the correct
  /// action and category.  Instead, use this with
  /// \#makeMainSelectorActivity(String, String) to generate a main
  /// Intent with this category in the selector.
  ///
  static const CATEGORY_APP_MAPS = "android.intent.category.APP_MAPS";

  /// from: static public final java.lang.String CATEGORY_APP_MARKET
  ///
  /// This activity allows the user to browse and download new applications.
  static const CATEGORY_APP_MARKET = "android.intent.category.APP_MARKET";

  /// from: static public final java.lang.String CATEGORY_APP_MESSAGING
  ///
  /// Used with \#ACTION_MAIN to launch the messaging application.
  /// The activity should be able to send and receive text messages.
  /// NOTE: This should not be used as the primary key of an Intent,
  /// since it will not result in the app launching with the correct
  /// action and category.  Instead, use this with
  /// \#makeMainSelectorActivity(String, String) to generate a main
  /// Intent with this category in the selector.
  ///
  static const CATEGORY_APP_MESSAGING = "android.intent.category.APP_MESSAGING";

  /// from: static public final java.lang.String CATEGORY_APP_MUSIC
  ///
  /// Used with \#ACTION_MAIN to launch the music application.
  /// The activity should be able to play, browse, or manipulate music files
  /// stored on the device.
  /// NOTE: This should not be used as the primary key of an Intent,
  /// since it will not result in the app launching with the correct
  /// action and category.  Instead, use this with
  /// \#makeMainSelectorActivity(String, String) to generate a main
  /// Intent with this category in the selector.
  ///
  static const CATEGORY_APP_MUSIC = "android.intent.category.APP_MUSIC";

  /// from: static public final java.lang.String CATEGORY_BROWSABLE
  ///
  /// Activities that can be safely invoked from a browser must support this
  /// category.  For example, if the user is viewing a web page or an e-mail
  /// and clicks on a link in the text, the Intent generated execute that
  /// link will require the BROWSABLE category, so that only activities
  /// supporting this category will be considered as possible actions.  By
  /// supporting this category, you are promising that there is nothing
  /// damaging (without user intervention) that can happen by invoking any
  /// matching Intent.
  static const CATEGORY_BROWSABLE = "android.intent.category.BROWSABLE";

  /// from: static public final java.lang.String CATEGORY_CAR_DOCK
  ///
  /// An activity to run when device is inserted into a car dock.
  /// Used with \#ACTION_MAIN to launch an activity.  For more
  /// information, see android.app.UiModeManager.
  static const CATEGORY_CAR_DOCK = "android.intent.category.CAR_DOCK";

  /// from: static public final java.lang.String CATEGORY_CAR_MODE
  ///
  /// Used to indicate that the activity can be used in a car environment.
  static const CATEGORY_CAR_MODE = "android.intent.category.CAR_MODE";

  /// from: static public final java.lang.String CATEGORY_DEFAULT
  ///
  /// Set if the activity should be an option for the default action
  /// (center press) to perform on a piece of data.  Setting this will
  /// hide from the user any activities without it set when performing an
  /// action on some data.  Note that this is normally -not- set in the
  /// Intent when initiating an action -- it is for use in intent filters
  /// specified in packages.
  static const CATEGORY_DEFAULT = "android.intent.category.DEFAULT";

  /// from: static public final java.lang.String CATEGORY_DESK_DOCK
  ///
  /// An activity to run when device is inserted into a car dock.
  /// Used with \#ACTION_MAIN to launch an activity.  For more
  /// information, see android.app.UiModeManager.
  static const CATEGORY_DESK_DOCK = "android.intent.category.DESK_DOCK";

  /// from: static public final java.lang.String CATEGORY_DEVELOPMENT_PREFERENCE
  ///
  /// This activity is a development preference panel.
  static const CATEGORY_DEVELOPMENT_PREFERENCE =
      "android.intent.category.DEVELOPMENT_PREFERENCE";

  /// from: static public final java.lang.String CATEGORY_EMBED
  ///
  /// Capable of running inside a parent activity container.
  static const CATEGORY_EMBED = "android.intent.category.EMBED";

  /// from: static public final java.lang.String CATEGORY_FRAMEWORK_INSTRUMENTATION_TEST
  ///
  /// To be used as code under test for framework instrumentation tests.
  static const CATEGORY_FRAMEWORK_INSTRUMENTATION_TEST =
      "android.intent.category.FRAMEWORK_INSTRUMENTATION_TEST";

  /// from: static public final java.lang.String CATEGORY_HE_DESK_DOCK
  ///
  /// An activity to run when device is inserted into a digital (high end) dock.
  /// Used with \#ACTION_MAIN to launch an activity.  For more
  /// information, see android.app.UiModeManager.
  static const CATEGORY_HE_DESK_DOCK = "android.intent.category.HE_DESK_DOCK";

  /// from: static public final java.lang.String CATEGORY_HOME
  ///
  /// This is the home activity, that is the first activity that is displayed
  /// when the device boots.
  static const CATEGORY_HOME = "android.intent.category.HOME";

  /// from: static public final java.lang.String CATEGORY_INFO
  ///
  /// Provides information about the package it is in; typically used if
  /// a package does not contain a \#CATEGORY_LAUNCHER to provide
  /// a front-door to the user without having to be shown in the all apps list.
  static const CATEGORY_INFO = "android.intent.category.INFO";

  /// from: static public final java.lang.String CATEGORY_LAUNCHER
  ///
  /// Should be displayed in the top-level launcher.
  static const CATEGORY_LAUNCHER = "android.intent.category.LAUNCHER";

  /// from: static public final java.lang.String CATEGORY_LEANBACK_LAUNCHER
  ///
  /// Indicates an activity optimized for Leanback mode, and that should
  /// be displayed in the Leanback launcher.
  static const CATEGORY_LEANBACK_LAUNCHER =
      "android.intent.category.LEANBACK_LAUNCHER";

  /// from: static public final java.lang.String CATEGORY_LE_DESK_DOCK
  ///
  /// An activity to run when device is inserted into a analog (low end) dock.
  /// Used with \#ACTION_MAIN to launch an activity.  For more
  /// information, see android.app.UiModeManager.
  static const CATEGORY_LE_DESK_DOCK = "android.intent.category.LE_DESK_DOCK";

  /// from: static public final java.lang.String CATEGORY_MONKEY
  ///
  /// This activity may be exercised by the monkey or other automated test tools.
  static const CATEGORY_MONKEY = "android.intent.category.MONKEY";

  /// from: static public final java.lang.String CATEGORY_OPENABLE
  ///
  /// Used to indicate that an intent only wants URIs that can be opened with
  /// ContentResolver\#openFileDescriptor(Uri, String). Openable URIs
  /// must support at least the columns defined in OpenableColumns when
  /// queried.
  ///@see \#ACTION_GET_CONTENT
  ///@see \#ACTION_OPEN_DOCUMENT
  ///@see \#ACTION_CREATE_DOCUMENT
  static const CATEGORY_OPENABLE = "android.intent.category.OPENABLE";

  /// from: static public final java.lang.String CATEGORY_PREFERENCE
  ///
  /// This activity is a preference panel.
  static const CATEGORY_PREFERENCE = "android.intent.category.PREFERENCE";

  /// from: static public final java.lang.String CATEGORY_SAMPLE_CODE
  ///
  /// To be used as a sample code example (not part of the normal user
  /// experience).
  static const CATEGORY_SAMPLE_CODE = "android.intent.category.SAMPLE_CODE";

  /// from: static public final java.lang.String CATEGORY_SELECTED_ALTERNATIVE
  ///
  /// Set if the activity should be considered as an alternative selection
  /// action to the data the user has currently selected.  This is like
  /// \#CATEGORY_ALTERNATIVE, but is used in activities showing a list
  /// of items from which the user can select, giving them alternatives to the
  /// default action that will be performed on it.
  static const CATEGORY_SELECTED_ALTERNATIVE =
      "android.intent.category.SELECTED_ALTERNATIVE";

  /// from: static public final java.lang.String CATEGORY_TAB
  ///
  /// Intended to be used as a tab inside of a containing TabActivity.
  static const CATEGORY_TAB = "android.intent.category.TAB";

  /// from: static public final java.lang.String CATEGORY_TEST
  ///
  /// To be used as a test (not part of the normal user experience).
  static const CATEGORY_TEST = "android.intent.category.TEST";

  /// from: static public final java.lang.String CATEGORY_TYPED_OPENABLE
  ///
  /// Used to indicate that an intent filter can accept files which are not necessarily
  /// openable by ContentResolver\#openFileDescriptor(Uri, String), but
  /// at least streamable via
  /// ContentResolver\#openTypedAssetFileDescriptor(Uri, String, Bundle)
  /// using one of the stream types exposed via
  /// ContentResolver\#getStreamTypes(Uri, String).
  ///@see \#ACTION_SEND
  ///@see \#ACTION_SEND_MULTIPLE
  static const CATEGORY_TYPED_OPENABLE =
      "android.intent.category.TYPED_OPENABLE";

  /// from: static public final java.lang.String CATEGORY_UNIT_TEST
  ///
  /// To be used as a unit test (run through the Test Harness).
  static const CATEGORY_UNIT_TEST = "android.intent.category.UNIT_TEST";

  /// from: static public final java.lang.String CATEGORY_VOICE
  ///
  /// Categories for activities that can participate in voice interaction.
  /// An activity that supports this category must be prepared to run with
  /// no UI shown at all (though in some case it may have a UI shown), and
  /// rely on android.app.VoiceInteractor to interact with the user.
  static const CATEGORY_VOICE = "android.intent.category.VOICE";

  /// from: static public final java.lang.String CATEGORY_VR_HOME
  ///
  /// An activity to use for the launcher when the device is placed in a VR Headset viewer.
  /// Used with \#ACTION_MAIN to launch an activity.  For more
  /// information, see android.app.UiModeManager.
  static const CATEGORY_VR_HOME = "android.intent.category.VR_HOME";

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_Intent_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.Intent> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  /// from: static public final java.lang.String EXTRA_ALARM_COUNT
  ///
  /// Used as an int extra field in android.app.AlarmManager intents
  /// to tell the application being invoked how many pending alarms are being
  /// delievered with the intent.  For one-shot alarms this will always be 1.
  /// For recurring alarms, this might be greater than 1 if the device was
  /// asleep or powered off at the time an earlier alarm would have been
  /// delivered.
  static const EXTRA_ALARM_COUNT = "android.intent.extra.ALARM_COUNT";

  /// from: static public final java.lang.String EXTRA_ALLOW_MULTIPLE
  ///
  /// Extra used to indicate that an intent can allow the user to select and
  /// return multiple items. This is a boolean extra; the default is false. If
  /// true, an implementation is allowed to present the user with a UI where
  /// they can pick multiple items that are all returned to the caller. When
  /// this happens, they should be returned as the \#getClipData() part
  /// of the result Intent.
  ///@see \#ACTION_GET_CONTENT
  ///@see \#ACTION_OPEN_DOCUMENT
  static const EXTRA_ALLOW_MULTIPLE = "android.intent.extra.ALLOW_MULTIPLE";

  /// from: static public final java.lang.String EXTRA_ALLOW_REPLACE
  ///
  /// Used as a boolean extra field with \#ACTION_INSTALL_PACKAGE to install a
  /// package.  Tells the installer UI to skip the confirmation with the user
  /// if the .apk is replacing an existing one.
  ///@deprecated As of android.os.Build.VERSION_CODES\#JELLY_BEAN, Android
  /// will no longer show an interstitial message about updating existing
  /// applications so this is no longer needed.
  static const EXTRA_ALLOW_REPLACE = "android.intent.extra.ALLOW_REPLACE";

  /// from: static public final java.lang.String EXTRA_ALTERNATE_INTENTS
  ///
  /// An Intent[] describing additional, alternate choices you would like shown with
  /// \#ACTION_CHOOSER.
  ///
  /// An app may be capable of providing several different payload types to complete a
  /// user's intended action. For example, an app invoking \#ACTION_SEND to share photos
  /// with another app may use EXTRA_ALTERNATE_INTENTS to have the chooser transparently offer
  /// several different supported sending mechanisms for sharing, such as the actual "image/*"
  /// photo data or a hosted link where the photos can be viewed.
  ///
  ///
  /// The intent present in \#EXTRA_INTENT will be treated as the
  /// first/primary/preferred intent in the set. Additional intents specified in
  /// this extra are ordered; by default intents that appear earlier in the array will be
  /// preferred over intents that appear later in the array as matches for the same
  /// target component. To alter this preference, a calling app may also supply
  /// \#EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER.
  ///
  static const EXTRA_ALTERNATE_INTENTS =
      "android.intent.extra.ALTERNATE_INTENTS";

  /// from: static public final java.lang.String EXTRA_ASSIST_CONTEXT
  ///
  /// An optional field on \#ACTION_ASSIST and containing additional contextual
  /// information supplied by the current foreground app at the time of the assist request.
  /// This is a Bundle of additional data.
  static const EXTRA_ASSIST_CONTEXT = "android.intent.extra.ASSIST_CONTEXT";

  /// from: static public final java.lang.String EXTRA_ASSIST_INPUT_DEVICE_ID
  ///
  /// An optional field on \#ACTION_ASSIST containing the InputDevice id
  /// that was used to invoke the assist.
  static const EXTRA_ASSIST_INPUT_DEVICE_ID =
      "android.intent.extra.ASSIST_INPUT_DEVICE_ID";

  /// from: static public final java.lang.String EXTRA_ASSIST_INPUT_HINT_KEYBOARD
  ///
  /// An optional field on \#ACTION_ASSIST suggesting that the user will likely use a
  /// keyboard as the primary input device for assistance.
  static const EXTRA_ASSIST_INPUT_HINT_KEYBOARD =
      "android.intent.extra.ASSIST_INPUT_HINT_KEYBOARD";

  /// from: static public final java.lang.String EXTRA_ASSIST_PACKAGE
  ///
  /// An optional field on \#ACTION_ASSIST containing the name of the current foreground
  /// application package at the time the assist was invoked.
  static const EXTRA_ASSIST_PACKAGE = "android.intent.extra.ASSIST_PACKAGE";

  /// from: static public final java.lang.String EXTRA_ASSIST_UID
  ///
  /// An optional field on \#ACTION_ASSIST containing the uid of the current foreground
  /// application package at the time the assist was invoked.
  static const EXTRA_ASSIST_UID = "android.intent.extra.ASSIST_UID";

  /// from: static public final java.lang.String EXTRA_BCC
  ///
  /// A String[] holding e-mail addresses that should be blind carbon copied.
  static const EXTRA_BCC = "android.intent.extra.BCC";

  /// from: static public final java.lang.String EXTRA_BUG_REPORT
  ///
  /// Used as a parcelable extra field in \#ACTION_APP_ERROR, containing
  /// the bug report.
  static const EXTRA_BUG_REPORT = "android.intent.extra.BUG_REPORT";

  /// from: static public final java.lang.String EXTRA_CC
  ///
  /// A String[] holding e-mail addresses that should be carbon copied.
  static const EXTRA_CC = "android.intent.extra.CC";

  /// from: static public final java.lang.String EXTRA_CHANGED_COMPONENT_NAME
  ///
  /// @deprecated See \#EXTRA_CHANGED_COMPONENT_NAME_LIST; this field
  /// will contain only the first name in the list.
  static const EXTRA_CHANGED_COMPONENT_NAME =
      "android.intent.extra.changed_component_name";

  /// from: static public final java.lang.String EXTRA_CHANGED_COMPONENT_NAME_LIST
  ///
  /// This field is part of android.content.Intent\#ACTION_PACKAGE_CHANGED,
  /// and contains a string array of all of the components that have changed.  If
  /// the state of the overall package has changed, then it will contain an entry
  /// with the package name itself.
  static const EXTRA_CHANGED_COMPONENT_NAME_LIST =
      "android.intent.extra.changed_component_name_list";

  /// from: static public final java.lang.String EXTRA_CHANGED_PACKAGE_LIST
  ///
  /// This field is part of
  /// android.content.Intent\#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE,
  /// android.content.Intent\#ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE,
  /// android.content.Intent\#ACTION_PACKAGES_SUSPENDED,
  /// android.content.Intent\#ACTION_PACKAGES_UNSUSPENDED
  /// and contains a string array of all of the components that have changed.
  static const EXTRA_CHANGED_PACKAGE_LIST =
      "android.intent.extra.changed_package_list";

  /// from: static public final java.lang.String EXTRA_CHANGED_UID_LIST
  ///
  /// This field is part of
  /// android.content.Intent\#ACTION_EXTERNAL_APPLICATIONS_AVAILABLE,
  /// android.content.Intent\#ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE
  /// and contains an integer array of uids of all of the components
  /// that have changed.
  static const EXTRA_CHANGED_UID_LIST = "android.intent.extra.changed_uid_list";

  /// from: static public final java.lang.String EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER
  ///
  /// An IntentSender for an Activity that will be invoked when the user makes a selection
  /// from the chooser activity presented by \#ACTION_CHOOSER.
  ///
  /// An app preparing an action for another app to complete may wish to allow the user to
  /// disambiguate between several options for completing the action based on the chosen target
  /// or otherwise refine the action before it is invoked.
  ///
  ///
  ///
  /// When sent, this IntentSender may be filled in with the following extras:
  ///
  /// <ul>
  ///     <li>\#EXTRA_INTENT The first intent that matched the user's chosen target</li>
  ///     <li>\#EXTRA_ALTERNATE_INTENTS Any additional intents that also matched the user's
  ///     chosen target beyond the first</li>
  ///     <li>\#EXTRA_RESULT_RECEIVER A ResultReceiver that the refinement activity
  ///     should fill in and send once the disambiguation is complete</li>
  /// </ul>
  static const EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER =
      "android.intent.extra.CHOOSER_REFINEMENT_INTENT_SENDER";

  /// from: static public final java.lang.String EXTRA_CHOOSER_TARGETS
  ///
  /// A android.service.chooser.ChooserTarget ChooserTarget[] for \#ACTION_CHOOSER
  /// describing additional high-priority deep-link targets for the chooser to present to the user.
  ///
  /// Targets provided in this way will be presented inline with all other targets provided
  /// by services from other apps. They will be prioritized before other service targets, but
  /// after those targets provided by sources that the user has manually pinned to the front.
  ///
  ///@see \#ACTION_CHOOSER
  static const EXTRA_CHOOSER_TARGETS = "android.intent.extra.CHOOSER_TARGETS";

  /// from: static public final java.lang.String EXTRA_CHOSEN_COMPONENT
  ///
  /// The ComponentName chosen by the user to complete an action.
  ///@see \#EXTRA_CHOSEN_COMPONENT_INTENT_SENDER
  static const EXTRA_CHOSEN_COMPONENT = "android.intent.extra.CHOSEN_COMPONENT";

  /// from: static public final java.lang.String EXTRA_CHOSEN_COMPONENT_INTENT_SENDER
  ///
  /// An IntentSender that will be notified if a user successfully chooses a target
  /// component to handle an action in an \#ACTION_CHOOSER activity. The IntentSender
  /// will have the extra \#EXTRA_CHOSEN_COMPONENT appended to it containing the
  /// ComponentName of the chosen component.
  ///
  /// In some situations this callback may never come, for example if the user abandons
  /// the chooser, switches to another task or any number of other reasons. Apps should not
  /// be written assuming that this callback will always occur.
  ///
  static const EXTRA_CHOSEN_COMPONENT_INTENT_SENDER =
      "android.intent.extra.CHOSEN_COMPONENT_INTENT_SENDER";

  /// from: static public final java.lang.String EXTRA_COMPONENT_NAME
  ///
  /// Intent extra: A ComponentName value.
  ///
  /// Type: String
  ///
  ///
  static const EXTRA_COMPONENT_NAME = "android.intent.extra.COMPONENT_NAME";

  /// from: static public final java.lang.String EXTRA_CONTENT_ANNOTATIONS
  ///
  /// An {@code ArrayList} of {@code String} annotations describing content for
  /// \#ACTION_CHOOSER.
  ///
  /// If \#EXTRA_CONTENT_ANNOTATIONS is present in an intent used to start a
  /// \#ACTION_CHOOSER activity, the first three annotations will be used to rank apps.
  ///
  ///
  /// Annotations should describe the major components or topics of the content. It is up to
  /// apps initiating \#ACTION_CHOOSER to learn and add annotations. Annotations should be
  /// learned in advance, e.g., when creating or saving content, to avoid increasing latency to
  /// start \#ACTION_CHOOSER. Names of customized annotations should not contain the colon
  /// character. Performance on customized annotations can suffer, if they are rarely used for
  /// \#ACTION_CHOOSER in the past 14 days. Therefore, it is recommended to use the
  /// following annotations when applicable.
  ///
  /// <ul>
  ///     <li>"product" represents that the topic of the content is mainly about products, e.g.,
  ///     health & beauty, and office supplies.</li>
  ///     <li>"emotion" represents that the topic of the content is mainly about emotions, e.g.,
  ///     happy, and sad.</li>
  ///     <li>"person" represents that the topic of the content is mainly about persons, e.g.,
  ///     face, finger, standing, and walking.</li>
  ///     <li>"child" represents that the topic of the content is mainly about children, e.g.,
  ///     child, and baby.</li>
  ///     <li>"selfie" represents that the topic of the content is mainly about selfies.</li>
  ///     <li>"crowd" represents that the topic of the content is mainly about crowds.</li>
  ///     <li>"party" represents that the topic of the content is mainly about parties.</li>
  ///     <li>"animal" represent that the topic of the content is mainly about animals.</li>
  ///     <li>"plant" represents that the topic of the content is mainly about plants, e.g.,
  ///     flowers.</li>
  ///     <li>"vacation" represents that the topic of the content is mainly about vacations.</li>
  ///     <li>"fashion" represents that the topic of the content is mainly about fashion, e.g.
  ///     sunglasses, jewelry, handbags and clothing.</li>
  ///     <li>"material" represents that the topic of the content is mainly about materials, e.g.,
  ///     paper, and silk.</li>
  ///     <li>"vehicle" represents that the topic of the content is mainly about vehicles, like
  ///     cars, and boats.</li>
  ///     <li>"document" represents that the topic of the content is mainly about documents, e.g.
  ///     posters.</li>
  ///     <li>"design" represents that the topic of the content is mainly about design, e.g. arts
  ///     and designs of houses.</li>
  ///     <li>"holiday" represents that the topic of the content is mainly about holidays, e.g.,
  ///     Christmas and Thanksgiving.</li>
  /// </ul>
  static const EXTRA_CONTENT_ANNOTATIONS =
      "android.intent.extra.CONTENT_ANNOTATIONS";

  /// from: static public final java.lang.String EXTRA_DATA_REMOVED
  ///
  /// Used as a boolean extra field in android.content.Intent\#ACTION_PACKAGE_REMOVED
  /// intents to indicate whether this represents a full uninstall (removing
  /// both the code and its data) or a partial uninstall (leaving its data,
  /// implying that this is an update).
  static const EXTRA_DATA_REMOVED = "android.intent.extra.DATA_REMOVED";

  /// from: static public final java.lang.String EXTRA_DOCK_STATE
  ///
  /// Used as an int extra field in android.content.Intent\#ACTION_DOCK_EVENT
  /// intents to request the dock state.  Possible values are
  /// android.content.Intent\#EXTRA_DOCK_STATE_UNDOCKED,
  /// android.content.Intent\#EXTRA_DOCK_STATE_DESK, or
  /// android.content.Intent\#EXTRA_DOCK_STATE_CAR, or
  /// android.content.Intent\#EXTRA_DOCK_STATE_LE_DESK, or
  /// android.content.Intent\#EXTRA_DOCK_STATE_HE_DESK.
  static const EXTRA_DOCK_STATE = "android.intent.extra.DOCK_STATE";

  /// from: static public final int EXTRA_DOCK_STATE_CAR
  ///
  /// Used as an int value for android.content.Intent\#EXTRA_DOCK_STATE
  /// to represent that the phone is in a car dock.
  static const EXTRA_DOCK_STATE_CAR = 2;

  /// from: static public final int EXTRA_DOCK_STATE_DESK
  ///
  /// Used as an int value for android.content.Intent\#EXTRA_DOCK_STATE
  /// to represent that the phone is in a desk dock.
  static const EXTRA_DOCK_STATE_DESK = 1;

  /// from: static public final int EXTRA_DOCK_STATE_HE_DESK
  ///
  /// Used as an int value for android.content.Intent\#EXTRA_DOCK_STATE
  /// to represent that the phone is in a digital (high end) dock.
  static const EXTRA_DOCK_STATE_HE_DESK = 4;

  /// from: static public final int EXTRA_DOCK_STATE_LE_DESK
  ///
  /// Used as an int value for android.content.Intent\#EXTRA_DOCK_STATE
  /// to represent that the phone is in a analog (low end) dock.
  static const EXTRA_DOCK_STATE_LE_DESK = 3;

  /// from: static public final int EXTRA_DOCK_STATE_UNDOCKED
  ///
  /// Used as an int value for android.content.Intent\#EXTRA_DOCK_STATE
  /// to represent that the phone is not in any dock.
  static const EXTRA_DOCK_STATE_UNDOCKED = 0;

  /// from: static public final java.lang.String EXTRA_DONT_KILL_APP
  ///
  /// Used as a boolean extra field in android.content.Intent\#ACTION_PACKAGE_REMOVED or
  /// android.content.Intent\#ACTION_PACKAGE_CHANGED intents to override the default action
  /// of restarting the application.
  static const EXTRA_DONT_KILL_APP = "android.intent.extra.DONT_KILL_APP";

  /// from: static public final java.lang.String EXTRA_EMAIL
  ///
  /// A String[] holding e-mail addresses that should be delivered to.
  static const EXTRA_EMAIL = "android.intent.extra.EMAIL";

  /// from: static public final java.lang.String EXTRA_EXCLUDE_COMPONENTS
  ///
  /// A ComponentName ComponentName[] describing components that should be filtered out
  /// and omitted from a list of components presented to the user.
  ///
  /// When used with \#ACTION_CHOOSER, the chooser will omit any of the components
  /// in this array if it otherwise would have shown them. Useful for omitting specific targets
  /// from your own package or other apps from your organization if the idea of sending to those
  /// targets would be redundant with other app functionality. Filtered components will not
  /// be able to present targets from an associated <code>ChooserTargetService</code>.
  ///
  static const EXTRA_EXCLUDE_COMPONENTS =
      "android.intent.extra.EXCLUDE_COMPONENTS";

  /// from: static public final java.lang.String EXTRA_FROM_STORAGE
  ///
  /// Extra that can be included on activity intents coming from the storage UI
  /// when it launches sub-activities to manage various types of storage.  For example,
  /// it may use \#ACTION_VIEW with a "image/*" MIME type to have an app show
  /// the images on the device, and in that case also include this extra to tell the
  /// app it is coming from the storage UI so should help the user manage storage of
  /// this type.
  static const EXTRA_FROM_STORAGE = "android.intent.extra.FROM_STORAGE";

  /// from: static public final java.lang.String EXTRA_HTML_TEXT
  ///
  /// A constant String that is associated with the Intent, used with
  /// \#ACTION_SEND to supply an alternative to \#EXTRA_TEXT
  /// as HTML formatted text.  Note that you _must_ also supply
  /// \#EXTRA_TEXT.
  static const EXTRA_HTML_TEXT = "android.intent.extra.HTML_TEXT";

  /// from: static public final java.lang.String EXTRA_INDEX
  ///
  /// Optional index with semantics depending on the intent action.
  ///
  /// The value must be an integer greater or equal to 0.
  ///@see \#ACTION_QUICK_VIEW
  static const EXTRA_INDEX = "android.intent.extra.INDEX";

  /// from: static public final java.lang.String EXTRA_INITIAL_INTENTS
  ///
  /// A Parcelable[] of Intent or
  /// android.content.pm.LabeledIntent objects as set with
  /// \#putExtra(String, Parcelable[]) of additional activities to place
  /// a the front of the list of choices, when shown to the user with a
  /// \#ACTION_CHOOSER.
  static const EXTRA_INITIAL_INTENTS = "android.intent.extra.INITIAL_INTENTS";

  /// from: static public final java.lang.String EXTRA_INSTALLER_PACKAGE_NAME
  ///
  /// Used as a string extra field with \#ACTION_INSTALL_PACKAGE to install a
  /// package.  Specifies the installer package name; this package will receive the
  /// \#ACTION_APP_ERROR intent.
  static const EXTRA_INSTALLER_PACKAGE_NAME =
      "android.intent.extra.INSTALLER_PACKAGE_NAME";

  /// from: static public final java.lang.String EXTRA_INTENT
  ///
  /// An Intent describing the choices you would like shown with
  /// \#ACTION_PICK_ACTIVITY or \#ACTION_CHOOSER.
  static const EXTRA_INTENT = "android.intent.extra.INTENT";

  /// from: static public final java.lang.String EXTRA_KEY_EVENT
  ///
  /// A android.view.KeyEvent object containing the event that
  /// triggered the creation of the Intent it is in.
  static const EXTRA_KEY_EVENT = "android.intent.extra.KEY_EVENT";

  /// from: static public final java.lang.String EXTRA_LOCAL_ONLY
  ///
  /// Extra used to indicate that an intent should only return data that is on
  /// the local device. This is a boolean extra; the default is false. If true,
  /// an implementation should only allow the user to select data that is
  /// already on the device, not requiring it be downloaded from a remote
  /// service when opened.
  ///@see \#ACTION_GET_CONTENT
  ///@see \#ACTION_OPEN_DOCUMENT
  ///@see \#ACTION_OPEN_DOCUMENT_TREE
  ///@see \#ACTION_CREATE_DOCUMENT
  static const EXTRA_LOCAL_ONLY = "android.intent.extra.LOCAL_ONLY";

  /// from: static public final java.lang.String EXTRA_MIME_TYPES
  ///
  /// Extra used to communicate a set of acceptable MIME types. The type of the
  /// extra is {@code String[]}. Values may be a combination of concrete MIME
  /// types (such as "image/png") and/or partial MIME types (such as
  /// "audio/*").
  ///@see \#ACTION_GET_CONTENT
  ///@see \#ACTION_OPEN_DOCUMENT
  static const EXTRA_MIME_TYPES = "android.intent.extra.MIME_TYPES";

  /// from: static public final java.lang.String EXTRA_NOT_UNKNOWN_SOURCE
  ///
  /// Used as a boolean extra field with \#ACTION_INSTALL_PACKAGE to install a
  /// package.  Specifies that the application being installed should not be
  /// treated as coming from an unknown source, but as coming from the app
  /// invoking the Intent.  For this to work you must start the installer with
  /// startActivityForResult().
  static const EXTRA_NOT_UNKNOWN_SOURCE =
      "android.intent.extra.NOT_UNKNOWN_SOURCE";

  /// from: static public final java.lang.String EXTRA_ORIGINATING_URI
  ///
  /// Used as a URI extra field with \#ACTION_INSTALL_PACKAGE and
  /// \#ACTION_VIEW to indicate the URI from which the local APK in the Intent
  /// data field originated from.
  static const EXTRA_ORIGINATING_URI = "android.intent.extra.ORIGINATING_URI";

  /// from: static public final java.lang.String EXTRA_PACKAGE_NAME
  ///
  /// Intent extra: An app package name.
  ///
  /// Type: String
  ///
  ///
  static const EXTRA_PACKAGE_NAME = "android.intent.extra.PACKAGE_NAME";

  /// from: static public final java.lang.String EXTRA_PHONE_NUMBER
  ///
  /// A String holding the phone number originally entered in
  /// android.content.Intent\#ACTION_NEW_OUTGOING_CALL, or the actual
  /// number to call in a android.content.Intent\#ACTION_CALL.
  static const EXTRA_PHONE_NUMBER = "android.intent.extra.PHONE_NUMBER";

  /// from: static public final java.lang.String EXTRA_PROCESS_TEXT
  ///
  /// The name of the extra used to define the text to be processed, as a
  /// CharSequence. Note that this may be a styled CharSequence, so you must use
  /// Bundle\#getCharSequence(String) Bundle.getCharSequence() to retrieve it.
  static const EXTRA_PROCESS_TEXT = "android.intent.extra.PROCESS_TEXT";

  /// from: static public final java.lang.String EXTRA_PROCESS_TEXT_READONLY
  ///
  /// The name of the boolean extra used to define if the processed text will be used as read-only.
  static const EXTRA_PROCESS_TEXT_READONLY =
      "android.intent.extra.PROCESS_TEXT_READONLY";

  /// from: static public final java.lang.String EXTRA_QUICK_VIEW_FEATURES
  ///
  /// An optional extra of {@code String[]} indicating which quick view features should be made
  /// available to the user in the quick view UI while handing a
  /// Intent\#ACTION_QUICK_VIEW intent.
  /// <li>Enumeration of features here is not meant to restrict capabilities of the quick viewer.
  /// Quick viewer can implement features not listed below.
  /// <li>Features included at this time are: QuickViewConstants\#FEATURE_VIEW,
  /// QuickViewConstants\#FEATURE_EDIT, QuickViewConstants\#FEATURE_DELETE,
  /// QuickViewConstants\#FEATURE_DOWNLOAD, QuickViewConstants\#FEATURE_SEND,
  /// QuickViewConstants\#FEATURE_PRINT.
  ///
  /// Requirements:
  /// <li>Quick viewer shouldn't show a feature if the feature is absent in
  /// \#EXTRA_QUICK_VIEW_FEATURES.
  /// <li>When \#EXTRA_QUICK_VIEW_FEATURES is not present, quick viewer should follow
  /// internal policies.
  /// <li>Presence of an feature in \#EXTRA_QUICK_VIEW_FEATURES, does not constitute a
  /// requirement that the feature be shown. Quick viewer may, according to its own policies,
  /// disable or hide features.
  ///@see \#ACTION_QUICK_VIEW
  static const EXTRA_QUICK_VIEW_FEATURES =
      "android.intent.extra.QUICK_VIEW_FEATURES";

  /// from: static public final java.lang.String EXTRA_QUIET_MODE
  ///
  /// Optional boolean extra indicating whether quiet mode has been switched on or off.
  /// When a profile goes into quiet mode, all apps in the profile are killed and the
  /// profile user is stopped. Widgets originating from the profile are masked, and app
  /// launcher icons are grayed out.
  static const EXTRA_QUIET_MODE = "android.intent.extra.QUIET_MODE";

  /// from: static public final java.lang.String EXTRA_REFERRER
  ///
  /// This extra can be used with any Intent used to launch an activity, supplying information
  /// about who is launching that activity.  This field contains a android.net.Uri
  /// object, typically an http: or https: URI of the web site that the referral came from;
  /// it can also use the \#URI_ANDROID_APP_SCHEME android-app: scheme to identify
  /// a native application that it came from.
  ///
  /// To retrieve this value in a client, use android.app.Activity\#getReferrer
  /// instead of directly retrieving the extra.  It is also valid for applications to
  /// instead supply \#EXTRA_REFERRER_NAME for cases where they can only create
  /// a string, not a Uri; the field here, if supplied, will always take precedence,
  /// however.
  ///
  ///@see \#EXTRA_REFERRER_NAME
  static const EXTRA_REFERRER = "android.intent.extra.REFERRER";

  /// from: static public final java.lang.String EXTRA_REFERRER_NAME
  ///
  /// Alternate version of \#EXTRA_REFERRER that supplies the URI as a String rather
  /// than a android.net.Uri object.  Only for use in cases where Uri objects can
  /// not be created, in particular when Intent extras are supplied through the
  /// \#URI_INTENT_SCHEME intent: or \#URI_ANDROID_APP_SCHEME android-app:
  /// schemes.
  ///@see \#EXTRA_REFERRER
  static const EXTRA_REFERRER_NAME = "android.intent.extra.REFERRER_NAME";

  /// from: static public final java.lang.String EXTRA_REMOTE_INTENT_TOKEN
  ///
  /// Used in the extra field in the remote intent. It's astring token passed with the
  /// remote intent.
  static const EXTRA_REMOTE_INTENT_TOKEN =
      "android.intent.extra.remote_intent_token";

  /// from: static public final java.lang.String EXTRA_REPLACEMENT_EXTRAS
  ///
  /// A Bundle forming a mapping of potential target package names to different extras Bundles
  /// to add to the default intent extras in \#EXTRA_INTENT when used with
  /// \#ACTION_CHOOSER. Each key should be a package name. The package need not
  /// be currently installed on the device.
  ///
  /// An application may choose to provide alternate extras for the case where a user
  /// selects an activity from a predetermined set of target packages. If the activity
  /// the user selects from the chooser belongs to a package with its package name as
  /// a key in this bundle, the corresponding extras for that package will be merged with
  /// the extras already present in the intent at \#EXTRA_INTENT. If a replacement
  /// extra has the same key as an extra already present in the intent it will overwrite
  /// the extra from the intent.
  ///
  ///
  /// _Examples:_
  /// <ul>
  ///     <li>An application may offer different \#EXTRA_TEXT to an application
  ///     when sharing with it via \#ACTION_SEND, augmenting a link with additional query
  ///     parameters for that target.</li>
  ///     <li>An application may offer additional metadata for known targets of a given intent
  ///     to pass along information only relevant to that target such as account or content
  ///     identifiers already known to that application.</li>
  /// </ul>
  ///
  static const EXTRA_REPLACEMENT_EXTRAS =
      "android.intent.extra.REPLACEMENT_EXTRAS";

  /// from: static public final java.lang.String EXTRA_REPLACING
  ///
  /// Used as a boolean extra field in android.content.Intent\#ACTION_PACKAGE_REMOVED
  /// intents to indicate that this is a replacement of the package, so this
  /// broadcast will immediately be followed by an add broadcast for a
  /// different version of the same package.
  static const EXTRA_REPLACING = "android.intent.extra.REPLACING";

  /// from: static public final java.lang.String EXTRA_RESTRICTIONS_BUNDLE
  ///
  /// Extra sent in the intent to the BroadcastReceiver that handles
  /// \#ACTION_GET_RESTRICTION_ENTRIES. The type of the extra is a Bundle containing
  /// the restrictions as key/value pairs.
  static const EXTRA_RESTRICTIONS_BUNDLE =
      "android.intent.extra.restrictions_bundle";

  /// from: static public final java.lang.String EXTRA_RESTRICTIONS_INTENT
  ///
  /// Extra used in the response from a BroadcastReceiver that handles
  /// \#ACTION_GET_RESTRICTION_ENTRIES.
  static const EXTRA_RESTRICTIONS_INTENT =
      "android.intent.extra.restrictions_intent";

  /// from: static public final java.lang.String EXTRA_RESTRICTIONS_LIST
  ///
  /// Extra used in the response from a BroadcastReceiver that handles
  /// \#ACTION_GET_RESTRICTION_ENTRIES. The type of the extra is
  /// <code>ArrayList&lt;RestrictionEntry&gt;</code>.
  static const EXTRA_RESTRICTIONS_LIST =
      "android.intent.extra.restrictions_list";

  /// from: static public final java.lang.String EXTRA_RESULT_RECEIVER
  ///
  /// A ResultReceiver used to return data back to the sender.
  ///
  /// Used to complete an app-specific
  /// \#EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER refinement for \#ACTION_CHOOSER.
  ///
  ///
  /// If \#EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER is present in the intent
  /// used to start a \#ACTION_CHOOSER activity this extra will be
  /// \#fillIn(Intent, int) filled in to that IntentSender and sent
  /// when the user selects a target component from the chooser. It is up to the recipient
  /// to send a result to this ResultReceiver to signal that disambiguation is complete
  /// and that the chooser should invoke the user's choice.
  ///
  ///
  /// The disambiguator should provide a Bundle to the ResultReceiver with an intent
  /// assigned to the key \#EXTRA_INTENT. This supplied intent will be used by the chooser
  /// to match and fill in the final Intent or ChooserTarget before starting it.
  /// The supplied intent must \#filterEquals(Intent) match one of the intents from
  /// \#EXTRA_INTENT or \#EXTRA_ALTERNATE_INTENTS passed to
  /// \#EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER to be accepted.
  ///
  ///
  /// The result code passed to the ResultReceiver should be
  /// android.app.Activity\#RESULT_OK if the refinement succeeded and the supplied intent's
  /// target in the chooser should be started, or android.app.Activity\#RESULT_CANCELED if
  /// the chooser should finish without starting a target.
  ///
  static const EXTRA_RESULT_RECEIVER = "android.intent.extra.RESULT_RECEIVER";

  /// from: static public final java.lang.String EXTRA_RETURN_RESULT
  ///
  /// Used as a boolean extra field with \#ACTION_INSTALL_PACKAGE or
  /// \#ACTION_UNINSTALL_PACKAGE.  Specifies that the installer UI should
  /// return to the application the result code of the install/uninstall.  The returned result
  /// code will be android.app.Activity\#RESULT_OK on success or
  /// android.app.Activity\#RESULT_FIRST_USER on failure.
  static const EXTRA_RETURN_RESULT = "android.intent.extra.RETURN_RESULT";

  /// from: static public final java.lang.String EXTRA_SHORTCUT_ICON
  ///
  /// The name of the extra used to define the icon, as a Bitmap, of a shortcut.
  ///@see \#ACTION_CREATE_SHORTCUT
  ///@deprecated Replaced with android.content.pm.ShortcutManager\#createShortcutResultIntent
  static const EXTRA_SHORTCUT_ICON = "android.intent.extra.shortcut.ICON";

  /// from: static public final java.lang.String EXTRA_SHORTCUT_ICON_RESOURCE
  ///
  /// The name of the extra used to define the icon, as a ShortcutIconResource, of a shortcut.
  ///@see \#ACTION_CREATE_SHORTCUT
  ///@see android.content.Intent.ShortcutIconResource
  ///@deprecated Replaced with android.content.pm.ShortcutManager\#createShortcutResultIntent
  static const EXTRA_SHORTCUT_ICON_RESOURCE =
      "android.intent.extra.shortcut.ICON_RESOURCE";

  /// from: static public final java.lang.String EXTRA_SHORTCUT_INTENT
  ///
  /// The name of the extra used to define the Intent of a shortcut.
  ///@see \#ACTION_CREATE_SHORTCUT
  ///@deprecated Replaced with android.content.pm.ShortcutManager\#createShortcutResultIntent
  static const EXTRA_SHORTCUT_INTENT = "android.intent.extra.shortcut.INTENT";

  /// from: static public final java.lang.String EXTRA_SHORTCUT_NAME
  ///
  /// The name of the extra used to define the name of a shortcut.
  ///@see \#ACTION_CREATE_SHORTCUT
  ///@deprecated Replaced with android.content.pm.ShortcutManager\#createShortcutResultIntent
  static const EXTRA_SHORTCUT_NAME = "android.intent.extra.shortcut.NAME";

  /// from: static public final java.lang.String EXTRA_SHUTDOWN_USERSPACE_ONLY
  ///
  /// Optional extra for \#ACTION_SHUTDOWN that allows the sender to qualify that
  /// this shutdown is only for the user space of the system, not a complete shutdown.
  /// When this is true, hardware devices can use this information to determine that
  /// they shouldn't do a complete shutdown of their device since this is not a
  /// complete shutdown down to the kernel, but only user space restarting.
  /// The default if not supplied is false.
  static const EXTRA_SHUTDOWN_USERSPACE_ONLY =
      "android.intent.extra.SHUTDOWN_USERSPACE_ONLY";

  /// from: static public final java.lang.String EXTRA_SPLIT_NAME
  ///
  /// Intent extra: An app split name.
  ///
  /// Type: String
  ///
  ///
  static const EXTRA_SPLIT_NAME = "android.intent.extra.SPLIT_NAME";

  /// from: static public final java.lang.String EXTRA_STREAM
  ///
  /// A content: URI holding a stream of data associated with the Intent,
  /// used with \#ACTION_SEND to supply the data being sent.
  static const EXTRA_STREAM = "android.intent.extra.STREAM";

  /// from: static public final java.lang.String EXTRA_SUBJECT
  ///
  /// A constant string holding the desired subject line of a message.
  static const EXTRA_SUBJECT = "android.intent.extra.SUBJECT";

  /// from: static public final java.lang.String EXTRA_SUSPENDED_PACKAGE_EXTRAS
  ///
  /// Intent extra: A Bundle of extras for a package being suspended. Will be sent as an
  /// extra with \#ACTION_MY_PACKAGE_SUSPENDED.
  ///
  /// The contents of this Bundle are a contract between the suspended app and the
  /// suspending app, i.e. any app with the permission {@code android.permission.SUSPEND_APPS}.
  /// This is meant to enable the suspended app to better handle the state of being suspended.
  ///@see \#ACTION_MY_PACKAGE_SUSPENDED
  ///@see \#ACTION_MY_PACKAGE_UNSUSPENDED
  ///@see PackageManager\#isPackageSuspended()
  ///@see PackageManager\#getSuspendedPackageAppExtras()
  static const EXTRA_SUSPENDED_PACKAGE_EXTRAS =
      "android.intent.extra.SUSPENDED_PACKAGE_EXTRAS";

  /// from: static public final java.lang.String EXTRA_TEMPLATE
  ///
  /// The initial data to place in a newly created record.  Use with
  /// \#ACTION_INSERT.  The data here is a Map containing the same
  /// fields as would be given to the underlying ContentProvider.insert()
  /// call.
  static const EXTRA_TEMPLATE = "android.intent.extra.TEMPLATE";

  /// from: static public final java.lang.String EXTRA_TEXT
  ///
  /// A constant CharSequence that is associated with the Intent, used with
  /// \#ACTION_SEND to supply the literal data to be sent.  Note that
  /// this may be a styled CharSequence, so you must use
  /// Bundle\#getCharSequence(String) Bundle.getCharSequence() to
  /// retrieve it.
  static const EXTRA_TEXT = "android.intent.extra.TEXT";

  /// from: static public final java.lang.String EXTRA_TITLE
  ///
  /// A CharSequence dialog title to provide to the user when used with a
  /// \#ACTION_CHOOSER.
  static const EXTRA_TITLE = "android.intent.extra.TITLE";

  /// from: static public final java.lang.String EXTRA_UID
  ///
  /// Used as an int extra field in android.content.Intent\#ACTION_UID_REMOVED
  /// intents to supply the uid the package had been assigned.  Also an optional
  /// extra in android.content.Intent\#ACTION_PACKAGE_REMOVED or
  /// android.content.Intent\#ACTION_PACKAGE_CHANGED for the same
  /// purpose.
  static const EXTRA_UID = "android.intent.extra.UID";

  /// from: static public final java.lang.String EXTRA_USER
  ///
  /// The UserHandle carried with broadcasts intents related to addition and removal of managed
  /// profiles - \#ACTION_MANAGED_PROFILE_ADDED and \#ACTION_MANAGED_PROFILE_REMOVED.
  static const EXTRA_USER = "android.intent.extra.USER";

  /// from: static public final int FILL_IN_ACTION
  ///
  /// Use with \#fillIn to allow the current action value to be
  /// overwritten, even if it is already set.
  static const FILL_IN_ACTION = 1;

  /// from: static public final int FILL_IN_CATEGORIES
  ///
  /// Use with \#fillIn to allow the current categories to be
  /// overwritten, even if they are already set.
  static const FILL_IN_CATEGORIES = 4;

  /// from: static public final int FILL_IN_CLIP_DATA
  ///
  /// Use with \#fillIn to allow the current ClipData to be
  /// overwritten, even if it is already set.
  static const FILL_IN_CLIP_DATA = 128;

  /// from: static public final int FILL_IN_COMPONENT
  ///
  /// Use with \#fillIn to allow the current component value to be
  /// overwritten, even if it is already set.
  static const FILL_IN_COMPONENT = 8;

  /// from: static public final int FILL_IN_DATA
  ///
  /// Use with \#fillIn to allow the current data or type value
  /// overwritten, even if it is already set.
  static const FILL_IN_DATA = 2;

  /// from: static public final int FILL_IN_PACKAGE
  ///
  /// Use with \#fillIn to allow the current package value to be
  /// overwritten, even if it is already set.
  static const FILL_IN_PACKAGE = 16;

  /// from: static public final int FILL_IN_SELECTOR
  ///
  /// Use with \#fillIn to allow the current selector to be
  /// overwritten, even if it is already set.
  static const FILL_IN_SELECTOR = 64;

  /// from: static public final int FILL_IN_SOURCE_BOUNDS
  ///
  /// Use with \#fillIn to allow the current bounds rectangle to be
  /// overwritten, even if it is already set.
  static const FILL_IN_SOURCE_BOUNDS = 32;

  /// from: static public final int FLAG_ACTIVITY_BROUGHT_TO_FRONT
  ///
  /// This flag is not normally set by application code, but set for you by
  /// the system as described in the
  /// android.R.styleable\#AndroidManifestActivity_launchMode launchMode documentation for the singleTask mode.
  static const FLAG_ACTIVITY_BROUGHT_TO_FRONT = 4194304;

  /// from: static public final int FLAG_ACTIVITY_CLEAR_TASK
  ///
  /// If set in an Intent passed to Context\#startActivity Context.startActivity(),
  /// this flag will cause any existing task that would be associated with the
  /// activity to be cleared before the activity is started.  That is, the activity
  /// becomes the new root of an otherwise empty task, and any old activities
  /// are finished.  This can only be used in conjunction with \#FLAG_ACTIVITY_NEW_TASK.
  static const FLAG_ACTIVITY_CLEAR_TASK = 32768;

  /// from: static public final int FLAG_ACTIVITY_CLEAR_TOP
  ///
  /// If set, and the activity being launched is already running in the
  /// current task, then instead of launching a new instance of that activity,
  /// all of the other activities on top of it will be closed and this Intent
  /// will be delivered to the (now on top) old activity as a new Intent.
  ///
  /// For example, consider a task consisting of the activities: A, B, C, D.
  /// If D calls startActivity() with an Intent that resolves to the component
  /// of activity B, then C and D will be finished and B receive the given
  /// Intent, resulting in the stack now being: A, B.
  ///
  /// The currently running instance of activity B in the above example will
  /// either receive the new intent you are starting here in its
  /// onNewIntent() method, or be itself finished and restarted with the
  /// new intent.  If it has declared its launch mode to be "multiple" (the
  /// default) and you have not set \#FLAG_ACTIVITY_SINGLE_TOP in
  /// the same intent, then it will be finished and re-created; for all other
  /// launch modes or if \#FLAG_ACTIVITY_SINGLE_TOP is set then this
  /// Intent will be delivered to the current instance's onNewIntent().
  ///
  /// This launch mode can also be used to good effect in conjunction with
  /// \#FLAG_ACTIVITY_NEW_TASK: if used to start the root activity
  /// of a task, it will bring any currently running instance of that task
  /// to the foreground, and then clear it to its root state.  This is
  /// especially useful, for example, when launching an activity from the
  /// notification manager.
  ///
  /// See
  /// <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
  /// Stack</a> for more information about tasks.
  static const FLAG_ACTIVITY_CLEAR_TOP = 67108864;

  /// from: static public final int FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET
  ///
  /// @deprecated As of API 21 this performs identically to
  /// \#FLAG_ACTIVITY_NEW_DOCUMENT which should be used instead of this.
  static const FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET = 524288;

  /// from: static public final int FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS
  ///
  /// If set, the new activity is not kept in the list of recently launched
  /// activities.
  static const FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS = 8388608;

  /// from: static public final int FLAG_ACTIVITY_FORWARD_RESULT
  ///
  /// If set and this intent is being used to launch a new activity from an
  /// existing one, then the reply target of the existing activity will be
  /// transfered to the new activity.  This way the new activity can call
  /// android.app.Activity\#setResult and have that result sent back to
  /// the reply target of the original activity.
  static const FLAG_ACTIVITY_FORWARD_RESULT = 33554432;

  /// from: static public final int FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY
  ///
  /// This flag is not normally set by application code, but set for you by
  /// the system if this activity is being launched from history
  /// (longpress home key).
  static const FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY = 1048576;

  /// from: static public final int FLAG_ACTIVITY_LAUNCH_ADJACENT
  ///
  /// This flag is only used in split-screen multi-window mode. The new activity will be displayed
  /// adjacent to the one launching it. This can only be used in conjunction with
  /// \#FLAG_ACTIVITY_NEW_TASK. Also, setting \#FLAG_ACTIVITY_MULTIPLE_TASK is
  /// required if you want a new instance of an existing activity to be created.
  static const FLAG_ACTIVITY_LAUNCH_ADJACENT = 4096;

  /// from: static public final int FLAG_ACTIVITY_MATCH_EXTERNAL
  ///
  /// If set in an Intent passed to Context\#startActivity Context.startActivity(),
  /// this flag will attempt to launch an instant app if no full app on the device can already
  /// handle the intent.
  ///
  /// When attempting to resolve instant apps externally, the following Intent properties
  /// are supported:
  /// <ul>
  ///     <li>Intent\#setAction(String)</li>
  ///     <li>Intent\#addCategory(String)</li>
  ///     <li>Intent\#setData(Uri)</li>
  ///     <li>Intent\#setType(String)</li>
  ///     <li>Intent\#setPackage(String)</li>
  ///     <li>Intent\#addFlags(int)</li>
  /// </ul>
  ///
  /// In the case that no instant app can be found, the installer will be launched to notify the
  /// user that the intent could not be resolved. On devices that do not support instant apps,
  /// the flag will be ignored.
  static const FLAG_ACTIVITY_MATCH_EXTERNAL = 2048;

  /// from: static public final int FLAG_ACTIVITY_MULTIPLE_TASK
  ///
  /// This flag is used to create a new task and launch an activity into it.
  /// This flag is always paired with either \#FLAG_ACTIVITY_NEW_DOCUMENT
  /// or \#FLAG_ACTIVITY_NEW_TASK. In both cases these flags alone would
  /// search through existing tasks for ones matching this Intent. Only if no such
  /// task is found would a new task be created. When paired with
  /// FLAG_ACTIVITY_MULTIPLE_TASK both of these behaviors are modified to skip
  /// the search for a matching task and unconditionally start a new task.
  ///
  /// <strong>When used with \#FLAG_ACTIVITY_NEW_TASK do not use this
  /// flag unless you are implementing your own
  /// top-level application launcher.</strong>  Used in conjunction with
  /// \#FLAG_ACTIVITY_NEW_TASK to disable the
  /// behavior of bringing an existing task to the foreground.  When set,
  /// a new task is _always_ started to host the Activity for the
  /// Intent, regardless of whether there is already an existing task running
  /// the same thing.
  ///
  /// <strong>Because the default system does not include graphical task management,
  /// you should not use this flag unless you provide some way for a user to
  /// return back to the tasks you have launched.</strong>
  ///
  /// See \#FLAG_ACTIVITY_NEW_DOCUMENT for details of this flag's use for
  /// creating new document tasks.
  ///
  /// This flag is ignored if one of \#FLAG_ACTIVITY_NEW_TASK or
  /// \#FLAG_ACTIVITY_NEW_DOCUMENT is not also set.
  ///
  /// See
  /// <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
  /// Stack</a> for more information about tasks.
  ///@see \#FLAG_ACTIVITY_NEW_DOCUMENT
  ///@see \#FLAG_ACTIVITY_NEW_TASK
  static const FLAG_ACTIVITY_MULTIPLE_TASK = 134217728;

  /// from: static public final int FLAG_ACTIVITY_NEW_DOCUMENT
  ///
  /// This flag is used to open a document into a new task rooted at the activity launched
  /// by this Intent. Through the use of this flag, or its equivalent attribute,
  /// android.R.attr\#documentLaunchMode multiple instances of the same activity
  /// containing different documents will appear in the recent tasks list.
  ///
  /// The use of the activity attribute form of this,
  /// android.R.attr\#documentLaunchMode, is
  /// preferred over the Intent flag described here. The attribute form allows the
  /// Activity to specify multiple document behavior for all launchers of the Activity
  /// whereas using this flag requires each Intent that launches the Activity to specify it.
  ///
  /// Note that the default semantics of this flag w.r.t. whether the recents entry for
  /// it is kept after the activity is finished is different than the use of
  /// \#FLAG_ACTIVITY_NEW_TASK and android.R.attr\#documentLaunchMode -- if
  /// this flag is being used to create a new recents entry, then by default that entry
  /// will be removed once the activity is finished.  You can modify this behavior with
  /// \#FLAG_ACTIVITY_RETAIN_IN_RECENTS.
  ///
  /// FLAG_ACTIVITY_NEW_DOCUMENT may be used in conjunction with \#FLAG_ACTIVITY_MULTIPLE_TASK. When used alone it is the
  /// equivalent of the Activity manifest specifying android.R.attr\#documentLaunchMode="intoExisting". When used with
  /// FLAG_ACTIVITY_MULTIPLE_TASK it is the equivalent of the Activity manifest specifying
  /// android.R.attr\#documentLaunchMode="always".
  ///
  /// Refer to android.R.attr\#documentLaunchMode for more information.
  ///@see android.R.attr\#documentLaunchMode
  ///@see \#FLAG_ACTIVITY_MULTIPLE_TASK
  static const FLAG_ACTIVITY_NEW_DOCUMENT = 524288;

  /// from: static public final int FLAG_ACTIVITY_NEW_TASK
  ///
  /// If set, this activity will become the start of a new task on this
  /// history stack.  A task (from the activity that started it to the
  /// next task activity) defines an atomic group of activities that the
  /// user can move to.  Tasks can be moved to the foreground and background;
  /// all of the activities inside of a particular task always remain in
  /// the same order.  See
  /// <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
  /// Stack</a> for more information about tasks.
  ///
  /// This flag is generally used by activities that want
  /// to present a "launcher" style behavior: they give the user a list of
  /// separate things that can be done, which otherwise run completely
  /// independently of the activity launching them.
  ///
  /// When using this flag, if a task is already running for the activity
  /// you are now starting, then a new activity will not be started; instead,
  /// the current task will simply be brought to the front of the screen with
  /// the state it was last in.  See \#FLAG_ACTIVITY_MULTIPLE_TASK for a flag
  /// to disable this behavior.
  ///
  /// This flag can not be used when the caller is requesting a result from
  /// the activity being launched.
  static const FLAG_ACTIVITY_NEW_TASK = 268435456;

  /// from: static public final int FLAG_ACTIVITY_NO_ANIMATION
  ///
  /// If set in an Intent passed to Context\#startActivity Context.startActivity(),
  /// this flag will prevent the system from applying an activity transition
  /// animation to go to the next activity state.  This doesn't mean an
  /// animation will never run -- if another activity change happens that doesn't
  /// specify this flag before the activity started here is displayed, then
  /// that transition will be used.  This flag can be put to good use
  /// when you are going to do a series of activity operations but the
  /// animation seen by the user shouldn't be driven by the first activity
  /// change but rather a later one.
  static const FLAG_ACTIVITY_NO_ANIMATION = 65536;

  /// from: static public final int FLAG_ACTIVITY_NO_HISTORY
  ///
  /// If set, the new activity is not kept in the history stack.  As soon as
  /// the user navigates away from it, the activity is finished.  This may also
  /// be set with the android.R.styleable\#AndroidManifestActivity_noHistory noHistory attribute.
  ///
  /// If set, android.app.Activity\#onActivityResult onActivityResult()
  /// is never invoked when the current activity starts a new activity which
  /// sets a result and finishes.
  static const FLAG_ACTIVITY_NO_HISTORY = 1073741824;

  /// from: static public final int FLAG_ACTIVITY_NO_USER_ACTION
  ///
  /// If set, this flag will prevent the normal android.app.Activity\#onUserLeaveHint
  /// callback from occurring on the current frontmost activity before it is
  /// paused as the newly-started activity is brought to the front.
  ///
  /// Typically, an activity can rely on that callback to indicate that an
  /// explicit user action has caused their activity to be moved out of the
  /// foreground. The callback marks an appropriate point in the activity's
  /// lifecycle for it to dismiss any notifications that it intends to display
  /// "until the user has seen them," such as a blinking LED.
  ///
  /// If an activity is ever started via any non-user-driven events such as
  /// phone-call receipt or an alarm handler, this flag should be passed to Context\#startActivity Context.startActivity, ensuring that the pausing
  /// activity does not think the user has acknowledged its notification.
  static const FLAG_ACTIVITY_NO_USER_ACTION = 262144;

  /// from: static public final int FLAG_ACTIVITY_PREVIOUS_IS_TOP
  ///
  /// If set and this intent is being used to launch a new activity from an
  /// existing one, the current activity will not be counted as the top
  /// activity for deciding whether the new intent should be delivered to
  /// the top instead of starting a new one.  The previous activity will
  /// be used as the top, with the assumption being that the current activity
  /// will finish itself immediately.
  static const FLAG_ACTIVITY_PREVIOUS_IS_TOP = 16777216;

  /// from: static public final int FLAG_ACTIVITY_REORDER_TO_FRONT
  ///
  /// If set in an Intent passed to Context\#startActivity Context.startActivity(),
  /// this flag will cause the launched activity to be brought to the front of its
  /// task's history stack if it is already running.
  ///
  /// For example, consider a task consisting of four activities: A, B, C, D.
  /// If D calls startActivity() with an Intent that resolves to the component
  /// of activity B, then B will be brought to the front of the history stack,
  /// with this resulting order:  A, C, D, B.
  ///
  /// This flag will be ignored if \#FLAG_ACTIVITY_CLEAR_TOP is also
  /// specified.
  static const FLAG_ACTIVITY_REORDER_TO_FRONT = 131072;

  /// from: static public final int FLAG_ACTIVITY_RESET_TASK_IF_NEEDED
  ///
  /// If set, and this activity is either being started in a new task or
  /// bringing to the top an existing task, then it will be launched as
  /// the front door of the task.  This will result in the application of
  /// any affinities needed to have that task in the proper state (either
  /// moving activities to or from it), or simply resetting that task to
  /// its initial state if needed.
  static const FLAG_ACTIVITY_RESET_TASK_IF_NEEDED = 2097152;

  /// from: static public final int FLAG_ACTIVITY_RETAIN_IN_RECENTS
  ///
  /// By default a document created by \#FLAG_ACTIVITY_NEW_DOCUMENT will
  /// have its entry in recent tasks removed when the user closes it (with back
  /// or however else it may finish()). If you would like to instead allow the
  /// document to be kept in recents so that it can be re-launched, you can use
  /// this flag. When set and the task's activity is finished, the recents
  /// entry will remain in the interface for the user to re-launch it, like a
  /// recents entry for a top-level application.
  ///
  /// The receiving activity can override this request with
  /// android.R.attr\#autoRemoveFromRecents or by explcitly calling
  /// android.app.Activity\#finishAndRemoveTask() Activity.finishAndRemoveTask().
  static const FLAG_ACTIVITY_RETAIN_IN_RECENTS = 8192;

  /// from: static public final int FLAG_ACTIVITY_SINGLE_TOP
  ///
  /// If set, the activity will not be launched if it is already running
  /// at the top of the history stack.
  static const FLAG_ACTIVITY_SINGLE_TOP = 536870912;

  /// from: static public final int FLAG_ACTIVITY_TASK_ON_HOME
  ///
  /// If set in an Intent passed to Context\#startActivity Context.startActivity(),
  /// this flag will cause a newly launching task to be placed on top of the current
  /// home activity task (if there is one).  That is, pressing back from the task
  /// will always return the user to home even if that was not the last activity they
  /// saw.   This can only be used in conjunction with \#FLAG_ACTIVITY_NEW_TASK.
  static const FLAG_ACTIVITY_TASK_ON_HOME = 16384;

  /// from: static public final int FLAG_DEBUG_LOG_RESOLUTION
  ///
  /// A flag you can enable for debugging: when set, log messages will be
  /// printed during the resolution of this intent to show you what has
  /// been found to create the final resolved list.
  static const FLAG_DEBUG_LOG_RESOLUTION = 8;

  /// from: static public final int FLAG_EXCLUDE_STOPPED_PACKAGES
  ///
  /// If set, this intent will not match any components in packages that
  /// are currently stopped.  If this is not set, then the default behavior
  /// is to include such applications in the result.
  static const FLAG_EXCLUDE_STOPPED_PACKAGES = 16;

  /// from: static public final int FLAG_FROM_BACKGROUND
  ///
  /// Can be set by the caller to indicate that this Intent is coming from
  /// a background operation, not from direct user interaction.
  static const FLAG_FROM_BACKGROUND = 4;

  /// from: static public final int FLAG_GRANT_PERSISTABLE_URI_PERMISSION
  ///
  /// When combined with \#FLAG_GRANT_READ_URI_PERMISSION and/or
  /// \#FLAG_GRANT_WRITE_URI_PERMISSION, the URI permission grant can be
  /// persisted across device reboots until explicitly revoked with
  /// Context\#revokeUriPermission(Uri, int). This flag only offers the
  /// grant for possible persisting; the receiving application must call
  /// ContentResolver\#takePersistableUriPermission(Uri, int) to
  /// actually persist.
  ///@see ContentResolver\#takePersistableUriPermission(Uri, int)
  ///@see ContentResolver\#releasePersistableUriPermission(Uri, int)
  ///@see ContentResolver\#getPersistedUriPermissions()
  ///@see ContentResolver\#getOutgoingPersistedUriPermissions()
  static const FLAG_GRANT_PERSISTABLE_URI_PERMISSION = 64;

  /// from: static public final int FLAG_GRANT_PREFIX_URI_PERMISSION
  ///
  /// When combined with \#FLAG_GRANT_READ_URI_PERMISSION and/or
  /// \#FLAG_GRANT_WRITE_URI_PERMISSION, the URI permission grant
  /// applies to any URI that is a prefix match against the original granted
  /// URI. (Without this flag, the URI must match exactly for access to be
  /// granted.) Another URI is considered a prefix match only when scheme,
  /// authority, and all path segments defined by the prefix are an exact
  /// match.
  static const FLAG_GRANT_PREFIX_URI_PERMISSION = 128;

  /// from: static public final int FLAG_GRANT_READ_URI_PERMISSION
  ///
  /// If set, the recipient of this Intent will be granted permission to
  /// perform read operations on the URI in the Intent's data and any URIs
  /// specified in its ClipData.  When applying to an Intent's ClipData,
  /// all URIs as well as recursive traversals through data or other ClipData
  /// in Intent items will be granted; only the grant flags of the top-level
  /// Intent are used.
  static const FLAG_GRANT_READ_URI_PERMISSION = 1;

  /// from: static public final int FLAG_GRANT_WRITE_URI_PERMISSION
  ///
  /// If set, the recipient of this Intent will be granted permission to
  /// perform write operations on the URI in the Intent's data and any URIs
  /// specified in its ClipData.  When applying to an Intent's ClipData,
  /// all URIs as well as recursive traversals through data or other ClipData
  /// in Intent items will be granted; only the grant flags of the top-level
  /// Intent are used.
  static const FLAG_GRANT_WRITE_URI_PERMISSION = 2;

  /// from: static public final int FLAG_INCLUDE_STOPPED_PACKAGES
  ///
  /// If set, this intent will always match any components in packages that
  /// are currently stopped.  This is the default behavior when
  /// \#FLAG_EXCLUDE_STOPPED_PACKAGES is not set.  If both of these
  /// flags are set, this one wins (it allows overriding of exclude for
  /// places where the framework may automatically set the exclude flag).
  static const FLAG_INCLUDE_STOPPED_PACKAGES = 32;

  /// from: static public final int FLAG_RECEIVER_FOREGROUND
  ///
  /// If set, when sending a broadcast the recipient is allowed to run at
  /// foreground priority, with a shorter timeout interval.  During normal
  /// broadcasts the receivers are not automatically hoisted out of the
  /// background priority class.
  static const FLAG_RECEIVER_FOREGROUND = 268435456;

  /// from: static public final int FLAG_RECEIVER_NO_ABORT
  ///
  /// If this is an ordered broadcast, don't allow receivers to abort the broadcast.
  /// They can still propagate results through to later receivers, but they can not prevent
  /// later receivers from seeing the broadcast.
  static const FLAG_RECEIVER_NO_ABORT = 134217728;

  /// from: static public final int FLAG_RECEIVER_REGISTERED_ONLY
  ///
  /// If set, when sending a broadcast only registered receivers will be
  /// called -- no BroadcastReceiver components will be launched.
  static const FLAG_RECEIVER_REGISTERED_ONLY = 1073741824;

  /// from: static public final int FLAG_RECEIVER_REPLACE_PENDING
  ///
  /// If set, when sending a broadcast the new broadcast will replace
  /// any existing pending broadcast that matches it.  Matching is defined
  /// by Intent\#filterEquals(Intent) Intent.filterEquals returning
  /// true for the intents of the two broadcasts.  When a match is found,
  /// the new broadcast (and receivers associated with it) will replace the
  /// existing one in the pending broadcast list, remaining at the same
  /// position in the list.
  ///
  /// This flag is most typically used with sticky broadcasts, which
  /// only care about delivering the most recent values of the broadcast
  /// to their receivers.
  static const FLAG_RECEIVER_REPLACE_PENDING = 536870912;

  /// from: static public final int FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///
  /// If set, the broadcast will be visible to receivers in Instant Apps. By default Instant Apps
  /// will not receive broadcasts.
  ///
  /// _This flag has no effect when used by an Instant App._
  static const FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS = 2097152;

  /// from: static public final java.lang.String METADATA_DOCK_HOME
  ///
  /// Boolean that can be supplied as meta-data with a dock activity, to
  /// indicate that the dock should take over the home key when it is active.
  static const METADATA_DOCK_HOME = "android.dock_home";

  /// from: static public final int URI_ALLOW_UNSAFE
  ///
  /// Flag for use with \#toUri and \#parseUri: allow parsing
  /// of unsafe information.  In particular, the flags \#FLAG_GRANT_READ_URI_PERMISSION,
  /// \#FLAG_GRANT_WRITE_URI_PERMISSION, \#FLAG_GRANT_PERSISTABLE_URI_PERMISSION,
  /// and \#FLAG_GRANT_PREFIX_URI_PERMISSION flags can not be set, so that the
  /// generated Intent can not cause unexpected data access to happen.
  ///
  /// If you do not trust the source of the URI being parsed, you should still do further
  /// processing to protect yourself from it.  In particular, when using it to start an
  /// activity you should usually add in \#CATEGORY_BROWSABLE to limit the activities
  /// that can handle it.
  ///
  static const URI_ALLOW_UNSAFE = 4;

  /// from: static public final int URI_ANDROID_APP_SCHEME
  ///
  /// Flag for use with \#toUri and \#parseUri: the URI string
  /// always has the "android-app:" scheme.  This is a variation of
  /// \#URI_INTENT_SCHEME whose format is simpler for the case of an
  /// http/https URI being delivered to a specific package name.  The format
  /// is:
  ///
  /// <pre class="prettyprint">
  /// android-app://{package_id}[/{scheme}[/{host}[/{path}]]][\#Intent;{...}]</pre>
  ///
  /// In this scheme, only the <code>package_id</code> is required.  If you include a host,
  /// you must also include a scheme; including a path also requires both a host and a scheme.
  /// The final \#Intent; fragment can be used without a scheme, host, or path.
  /// Note that this can not be
  /// used with intents that have a \#setSelector, since the base intent
  /// will always have an explicit package name.
  ///
  ///
  /// Some examples of how this scheme maps to Intent objects:
  ///
  /// <table border="2" width="85%" align="center" frame="hsides" rules="rows">
  ///     <colgroup align="left"/>
  ///     <colgroup align="left"/>
  ///     <thead>
  ///     <tr><th>URI</th> <th>Intent</th></tr>
  ///     </thead>
  ///
  ///     <tbody>
  ///     <tr><td><code>android-app://com.example.app</code></td>
  ///         <td><table style="margin:0;border:0;cellpadding:0;cellspacing:0">
  ///             <tr><td>Action: </td><td>\#ACTION_MAIN</td></tr>
  ///             <tr><td>Package: </td><td><code>com.example.app</code></td></tr>
  ///         </table></td>
  ///     </tr>
  ///     <tr><td><code>android-app://com.example.app/http/example.com</code></td>
  ///         <td><table style="margin:0;border:0;cellpadding:0;cellspacing:0">
  ///             <tr><td>Action: </td><td>\#ACTION_VIEW</td></tr>
  ///             <tr><td>Data: </td><td><code>http://example.com/</code></td></tr>
  ///             <tr><td>Package: </td><td><code>com.example.app</code></td></tr>
  ///         </table></td>
  ///     </tr>
  ///     <tr><td><code>android-app://com.example.app/http/example.com/foo?1234</code></td>
  ///         <td><table style="margin:0;border:0;cellpadding:0;cellspacing:0">
  ///             <tr><td>Action: </td><td>\#ACTION_VIEW</td></tr>
  ///             <tr><td>Data: </td><td><code>http://example.com/foo?1234</code></td></tr>
  ///             <tr><td>Package: </td><td><code>com.example.app</code></td></tr>
  ///         </table></td>
  ///     </tr>
  ///     <tr><td><code>android-app://com.example.app/<br/>\#Intent;action=com.example.MY_ACTION;end</code></td>
  ///         <td><table style="margin:0;border:0;cellpadding:0;cellspacing:0">
  ///             <tr><td>Action: </td><td><code>com.example.MY_ACTION</code></td></tr>
  ///             <tr><td>Package: </td><td><code>com.example.app</code></td></tr>
  ///         </table></td>
  ///     </tr>
  ///     <tr><td><code>android-app://com.example.app/http/example.com/foo?1234<br/>\#Intent;action=com.example.MY_ACTION;end</code></td>
  ///         <td><table style="margin:0;border:0;cellpadding:0;cellspacing:0">
  ///             <tr><td>Action: </td><td><code>com.example.MY_ACTION</code></td></tr>
  ///             <tr><td>Data: </td><td><code>http://example.com/foo?1234</code></td></tr>
  ///             <tr><td>Package: </td><td><code>com.example.app</code></td></tr>
  ///         </table></td>
  ///     </tr>
  ///     <tr><td><code>android-app://com.example.app/<br/>\#Intent;action=com.example.MY_ACTION;<br/>i.some_int=100;S.some_str=hello;end</code></td>
  ///         <td><table border="" style="margin:0">
  ///             <tr><td>Action: </td><td><code>com.example.MY_ACTION</code></td></tr>
  ///             <tr><td>Package: </td><td><code>com.example.app</code></td></tr>
  ///             <tr><td>Extras: </td><td><code>some_int=(int)100<br/>some_str=(String)hello</code></td></tr>
  ///         </table></td>
  ///     </tr>
  ///     </tbody>
  /// </table>
  static const URI_ANDROID_APP_SCHEME = 2;

  /// from: static public final int URI_INTENT_SCHEME
  ///
  /// Flag for use with \#toUri and \#parseUri: the URI string
  /// always has the "intent:" scheme.  This syntax can be used when you want
  /// to later disambiguate between URIs that are intended to describe an
  /// Intent vs. all others that should be treated as raw URIs.  When used
  /// with \#parseUri, any other scheme will result in a generic
  /// VIEW action for that raw URI.
  static const URI_INTENT_SCHEME = 1;

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_Intent_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ///
  /// Create an empty intent.
  Intent() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_ctor1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Intent o)
  ///
  /// Copy constructor.
  Intent.ctor1(Intent o) : super.fromRef(_ctor1(o.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor2 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_ctor2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String action)
  ///
  /// Create an intent with a given action.  All other fields (data, type,
  /// class) are null.  Note that the action _must_ be in a
  /// namespace because Intents are used globally in the system -- for
  /// example the system VIEW action is android.intent.action.VIEW; an
  /// application's custom action would be something like
  /// com.google.app.myapp.CUSTOM_ACTION.
  ///@param action The Intent action, such as ACTION_VIEW.
  Intent.ctor2(jni.JniString action) : super.fromRef(_ctor2(action.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor3 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_ctor3")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String action, android.net.Uri uri)
  ///
  /// Create an intent with a given action and for a given data url.  Note
  /// that the action _must_ be in a namespace because Intents are
  /// used globally in the system -- for example the system VIEW action is
  /// android.intent.action.VIEW; an application's custom action would be
  /// something like com.google.app.myapp.CUSTOM_ACTION.
  ///
  /// _Note: scheme and host name matching in the Android framework is
  /// case-sensitive, unlike the formal RFC.  As a result,
  /// you should always ensure that you write your Uri with these elements
  /// using lower case letters, and normalize any Uris you receive from
  /// outside of Android to ensure the scheme and host is lower case._
  ///
  ///@param action The Intent action, such as ACTION_VIEW.
  ///@param uri The Intent data URI.
  Intent.ctor3(jni.JniString action, jni.JniObject uri)
      : super.fromRef(_ctor3(action.reference, uri.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor4 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_ctor4")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context packageContext, java.lang.Class<?> cls)
  ///
  /// Create an intent for a specific component.  All other fields (action, data,
  /// type, class) are null, though they can be modified later with explicit
  /// calls.  This provides a convenient way to create an intent that is
  /// intended to execute a hard-coded class name, rather than relying on the
  /// system to find an appropriate class for you; see \#setComponent
  /// for more information on the repercussions of this.
  ///@param packageContext A Context of the application package implementing
  /// this class.
  ///@param cls The component class that is to be used for the intent.
  ///@see \#setClass
  ///@see \#setComponent
  ///@see \#Intent(String, android.net.Uri , Context, Class)
  Intent.ctor4(Context packageContext, jni.JniObject cls)
      : super.fromRef(_ctor4(packageContext.reference, cls.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor5 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_ctor5")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String action, android.net.Uri uri, android.content.Context packageContext, java.lang.Class<?> cls)
  ///
  /// Create an intent for a specific component with a specified action and data.
  /// This is equivalent to using \#Intent(String, android.net.Uri) to
  /// construct the Intent and then calling \#setClass to set its
  /// class.
  ///
  /// _Note: scheme and host name matching in the Android framework is
  /// case-sensitive, unlike the formal RFC.  As a result,
  /// you should always ensure that you write your Uri with these elements
  /// using lower case letters, and normalize any Uris you receive from
  /// outside of Android to ensure the scheme and host is lower case._
  ///
  ///@param action The Intent action, such as ACTION_VIEW.
  ///@param uri The Intent data URI.
  ///@param packageContext A Context of the application package implementing
  /// this class.
  ///@param cls The component class that is to be used for the intent.
  ///@see \#Intent(String, android.net.Uri)
  ///@see \#Intent(Context, Class)
  ///@see \#setClass
  ///@see \#setComponent
  Intent.ctor5(jni.JniString action, jni.JniObject uri, Context packageContext,
      jni.JniObject cls)
      : super.fromRef(_ctor5(action.reference, uri.reference,
            packageContext.reference, cls.reference)) {
    jni.Jni.env.checkException();
  }

  static final _createChooser = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_createChooser")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.Intent createChooser(android.content.Intent target, java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience function for creating a \#ACTION_CHOOSER Intent.
  ///
  /// Builds a new \#ACTION_CHOOSER Intent that wraps the given
  /// target intent, also optionally supplying a title.  If the target
  /// intent has specified \#FLAG_GRANT_READ_URI_PERMISSION or
  /// \#FLAG_GRANT_WRITE_URI_PERMISSION, then these flags will also be
  /// set in the returned chooser intent, with its ClipData set appropriately:
  /// either a direct reflection of \#getClipData() if that is non-null,
  /// or a new ClipData built from \#getData().
  ///@param target The Intent that the user will be selecting an activity
  /// to perform.
  ///@param title Optional title that will be displayed in the chooser.
  ///@return Return a new Intent object that you can hand to
  /// Context\#startActivity(Intent) Context.startActivity() and
  /// related methods.
  static Intent createChooser(Intent target, jni.JniObject title) {
    final result__ =
        Intent.fromRef(_createChooser(target.reference, title.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _createChooser1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_createChooser1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.Intent createChooser(android.content.Intent target, java.lang.CharSequence title, android.content.IntentSender sender)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience function for creating a \#ACTION_CHOOSER Intent.
  ///
  /// Builds a new \#ACTION_CHOOSER Intent that wraps the given
  /// target intent, also optionally supplying a title.  If the target
  /// intent has specified \#FLAG_GRANT_READ_URI_PERMISSION or
  /// \#FLAG_GRANT_WRITE_URI_PERMISSION, then these flags will also be
  /// set in the returned chooser intent, with its ClipData set appropriately:
  /// either a direct reflection of \#getClipData() if that is non-null,
  /// or a new ClipData built from \#getData().
  ///
  ///
  /// The caller may optionally supply an IntentSender to receive a callback
  /// when the user makes a choice. This can be useful if the calling application wants
  /// to remember the last chosen target and surface it as a more prominent or one-touch
  /// affordance elsewhere in the UI for next time.
  ///
  ///@param target The Intent that the user will be selecting an activity
  /// to perform.
  ///@param title Optional title that will be displayed in the chooser.
  ///@param sender Optional IntentSender to be called when a choice is made.
  ///@return Return a new Intent object that you can hand to
  /// Context\#startActivity(Intent) Context.startActivity() and
  /// related methods.
  static Intent createChooser1(
      Intent target, jni.JniObject title, IntentSender sender) {
    final result__ = Intent.fromRef(
        _createChooser1(target.reference, title.reference, sender.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _clone = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_clone")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject clone() {
    final result__ = jni.JniObject.fromRef(_clone(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _cloneFilter = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_cloneFilter")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent cloneFilter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Make a clone of only the parts of the Intent that are relevant for
  /// filter matching: the action, data, type, component, and categories.
  ///@return This value will never be {@code null}.
  Intent cloneFilter() {
    final result__ = Intent.fromRef(_cloneFilter(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _makeMainActivity = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_makeMainActivity")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.Intent makeMainActivity(android.content.ComponentName mainActivity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an intent to launch the main (root) activity of a task.  This
  /// is the Intent that is started when the application's is launched from
  /// Home.  For anything else that wants to launch an application in the
  /// same way, it is important that they use an Intent structured the same
  /// way, and can use this function to ensure this is the case.
  ///
  /// The returned Intent has the given Activity component as its explicit
  /// component, \#ACTION_MAIN as its action, and includes the
  /// category \#CATEGORY_LAUNCHER.  This does _not_ have
  /// \#FLAG_ACTIVITY_NEW_TASK set, though typically you will want
  /// to do that through \#addFlags(int) on the returned Intent.
  ///@param mainActivity The main activity component that this Intent will
  /// launch.
  ///@return Returns a newly created Intent that can be used to launch the
  /// activity as a main application entry.
  ///@see \#setClass
  ///@see \#setComponent
  static Intent makeMainActivity(ComponentName mainActivity) {
    final result__ = Intent.fromRef(_makeMainActivity(mainActivity.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _makeMainSelectorActivity = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_makeMainSelectorActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.Intent makeMainSelectorActivity(java.lang.String selectorAction, java.lang.String selectorCategory)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Make an Intent for the main activity of an application, without
  /// specifying a specific activity to run but giving a selector to find
  /// the activity.  This results in a final Intent that is structured
  /// the same as when the application is launched from
  /// Home.  For anything else that wants to launch an application in the
  /// same way, it is important that they use an Intent structured the same
  /// way, and can use this function to ensure this is the case.
  ///
  /// The returned Intent has \#ACTION_MAIN as its action, and includes the
  /// category \#CATEGORY_LAUNCHER.  This does _not_ have
  /// \#FLAG_ACTIVITY_NEW_TASK set, though typically you will want
  /// to do that through \#addFlags(int) on the returned Intent.
  ///@param selectorAction The action name of the Intent's selector.
  ///@param selectorCategory The name of a category to add to the Intent's
  /// selector.
  ///@return Returns a newly created Intent that can be used to launch the
  /// activity as a main application entry.
  ///@see \#setSelector(Intent)
  static Intent makeMainSelectorActivity(
      jni.JniString selectorAction, jni.JniString selectorCategory) {
    final result__ = Intent.fromRef(_makeMainSelectorActivity(
        selectorAction.reference, selectorCategory.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _makeRestartActivityTask = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_makeRestartActivityTask")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.Intent makeRestartActivityTask(android.content.ComponentName mainActivity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Make an Intent that can be used to re-launch an application's task
  /// in its base state.  This is like \#makeMainActivity(ComponentName),
  /// but also sets the flags \#FLAG_ACTIVITY_NEW_TASK and
  /// \#FLAG_ACTIVITY_CLEAR_TASK.
  ///@param mainActivity The activity component that is the root of the
  /// task; this is the activity that has been published in the application's
  /// manifest as the main launcher icon.
  ///@return Returns a newly created Intent that can be used to relaunch the
  /// activity's task in its root state.
  static Intent makeRestartActivityTask(ComponentName mainActivity) {
    final result__ =
        Intent.fromRef(_makeRestartActivityTask(mainActivity.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getIntent = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_getIntent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.Intent getIntent(java.lang.String uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Call \#parseUri with 0 flags.
  ///@deprecated Use \#parseUri instead.
  static Intent getIntent(jni.JniString uri) {
    final result__ = Intent.fromRef(_getIntent(uri.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _parseUri = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Intent_parseUri")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.content.Intent parseUri(java.lang.String uri, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an intent from a URI.  This URI may encode the action,
  /// category, and other intent fields, if it was returned by
  /// \#toUri.  If the Intent was not generate by toUri(), its data
  /// will be the entire URI and its action will be ACTION_VIEW.
  ///
  /// The URI given here must not be relative -- that is, it must include
  /// the scheme and full path.
  ///@param uri The URI to turn into an Intent.
  ///@param flags Additional processing flags.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#URI_ALLOW_UNSAFE, android.content.Intent\#URI_ANDROID_APP_SCHEME, and android.content.Intent\#URI_INTENT_SCHEME
  ///@return Intent The newly created Intent object.
  ///@throws URISyntaxException Throws URISyntaxError if the basic URI syntax
  /// it bad (as parsed by the Uri class) or the Intent data within the
  /// URI is invalid.
  ///@see \#toUri
  static Intent parseUri(jni.JniString uri, int flags) {
    final result__ = Intent.fromRef(_parseUri(uri.reference, flags));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getIntentOld = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getIntentOld")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.Intent getIntentOld(java.lang.String uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static Intent getIntentOld(jni.JniString uri) {
    final result__ = Intent.fromRef(_getIntentOld(uri.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getAction = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_getAction")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getAction()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the general action to be performed, such as
  /// \#ACTION_VIEW.  The action describes the general way the rest of
  /// the information in the intent should be interpreted -- most importantly,
  /// what to do with the data returned by \#getData.
  ///@return The action of this intent or null if none is specified.
  ///@see \#setAction
  jni.JniString getAction() {
    final result__ = jni.JniString.fromRef(_getAction(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getData = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_getData")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri getData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve data this intent is operating on.  This URI specifies the name
  /// of the data; often it uses the content: scheme, specifying data in a
  /// content provider.  Other schemes may be handled by specific activities,
  /// such as http: by the web browser.
  ///@return The URI of the data this intent is targeting or null.
  ///@see \#getScheme
  ///@see \#setData
  jni.JniObject getData() {
    final result__ = jni.JniObject.fromRef(_getData(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDataString = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getDataString")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getDataString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The same as \#getData(), but returns the URI as an encoded
  /// String.
  ///@return This value may be {@code null}.
  jni.JniString getDataString() {
    final result__ = jni.JniString.fromRef(_getDataString(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getScheme = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_getScheme")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getScheme()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the scheme portion of the intent's data.  If the data is null or
  /// does not include a scheme, null is returned.  Otherwise, the scheme
  /// prefix without the final ':' is returned, i.e. "http".
  ///
  /// This is the same as calling getData().getScheme() (and checking for
  /// null data).
  ///@return The scheme of this intent.
  ///@see \#getData
  jni.JniString getScheme() {
    final result__ = jni.JniString.fromRef(_getScheme(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getType = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_getType")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve any explicit MIME type included in the intent.  This is usually
  /// null, as the type is determined by the intent data.
  ///@return If a type was manually set, it is returned; else null is
  ///         returned.
  ///@see \#resolveType(ContentResolver)
  ///@see \#setType
  jni.JniString getType() {
    final result__ = jni.JniString.fromRef(_getType(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _resolveType = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_resolveType")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String resolveType(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the MIME data type of this intent.  If the type field is
  /// explicitly set, that is simply returned.  Otherwise, if the data is set,
  /// the type of that data is returned.  If neither fields are set, a null is
  /// returned.
  ///@param context This value must never be {@code null}.
  ///@return The MIME type of this intent.
  ///@see \#getType
  ///@see \#resolveType(ContentResolver)
  jni.JniString resolveType(Context context) {
    final result__ =
        jni.JniString.fromRef(_resolveType(reference, context.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _resolveType1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_resolveType1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String resolveType(android.content.ContentResolver resolver)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the MIME data type of this intent.  If the type field is
  /// explicitly set, that is simply returned.  Otherwise, if the data is set,
  /// the type of that data is returned.  If neither fields are set, a null is
  /// returned.
  ///@param resolver A ContentResolver that can be used to determine the MIME
  ///                 type of the intent's data.
  ///
  /// This value must never be {@code null}.
  ///@return The MIME type of this intent.
  ///@see \#getType
  ///@see \#resolveType(Context)
  jni.JniString resolveType1(ContentResolver resolver) {
    final result__ =
        jni.JniString.fromRef(_resolveType1(reference, resolver.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _resolveTypeIfNeeded = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_resolveTypeIfNeeded")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String resolveTypeIfNeeded(android.content.ContentResolver resolver)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the MIME data type of this intent, only if it will be needed for
  /// intent resolution.  This is not generally useful for application code;
  /// it is used by the frameworks for communicating with back-end system
  /// services.
  ///@param resolver A ContentResolver that can be used to determine the MIME
  ///                 type of the intent's data.
  ///
  /// This value must never be {@code null}.
  ///@return The MIME type of this intent, or null if it is unknown or not
  ///         needed.
  jni.JniString resolveTypeIfNeeded(ContentResolver resolver) {
    final result__ = jni.JniString.fromRef(
        _resolveTypeIfNeeded(reference, resolver.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hasCategory = jniLookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_hasCategory")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasCategory(java.lang.String category)
  ///
  /// Check if a category exists in the intent.
  ///@param category The category to check.
  ///@return boolean True if the intent contains the category, else false.
  ///@see \#getCategories
  ///@see \#addCategory
  bool hasCategory(jni.JniString category) {
    final result__ = _hasCategory(reference, category.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getCategories = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getCategories")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Set<java.lang.String> getCategories()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the set of all categories in the intent.  If there are no categories,
  /// returns NULL.
  ///@return The set of categories you can examine.  Do not modify!
  ///@see \#hasCategory
  ///@see \#addCategory
  jni.JniObject getCategories() {
    final result__ = jni.JniObject.fromRef(_getCategories(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSelector = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_getSelector")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent getSelector()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the specific selector associated with this Intent.  If there is
  /// none, returns null.  See \#setSelector for more information.
  ///@see \#setSelector
  Intent getSelector() {
    final result__ = Intent.fromRef(_getSelector(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getClipData = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_getClipData")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ClipData getClipData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the ClipData associated with this Intent.  If there is
  /// none, returns null.  See \#setClipData for more information.
  ///@see \#setClipData
  ClipData getClipData() {
    final result__ = ClipData.fromRef(_getClipData(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setExtrasClassLoader = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_setExtrasClassLoader")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExtrasClassLoader(java.lang.ClassLoader loader)
  ///
  /// Sets the ClassLoader that will be used when unmarshalling
  /// any Parcelable values from the extras of this Intent.
  ///@param loader a ClassLoader, or null to use the default loader
  /// at the time of unmarshalling.
  ///
  /// This value may be {@code null}.
  void setExtrasClassLoader(jni.JniObject loader) {
    final result__ = _setExtrasClassLoader(reference, loader.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hasExtra = jniLookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_hasExtra")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasExtra(java.lang.String name)
  ///
  /// Returns true if an extra value is associated with the given name.
  ///@param name the extra's name
  ///@return true if the given extra is present.
  bool hasExtra(jni.JniString name) {
    final result__ = _hasExtra(reference, name.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hasFileDescriptors =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Intent_hasFileDescriptors")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasFileDescriptors()
  ///
  /// Returns true if the Intent's extras contain a parcelled file descriptor.
  ///@return true if the Intent contains a parcelled file descriptor.
  bool hasFileDescriptors() {
    final result__ = _hasFileDescriptors(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getBooleanExtra = jniLookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_content_Intent_getBooleanExtra")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean getBooleanExtra(java.lang.String name, boolean defaultValue)
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@param defaultValue the value to be returned if no value of the desired
  /// type is stored with the given name.
  ///@return the value of an item previously added with putExtra(),
  /// or the default value if none was found.
  ///@see \#putExtra(String, boolean)
  bool getBooleanExtra(jni.JniString name, bool defaultValue) {
    final result__ =
        _getBooleanExtra(reference, name.reference, defaultValue ? 1 : 0) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getByteExtra = jniLookup<
          ffi.NativeFunction<
              ffi.Int8 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int8)>>("android_content_Intent_getByteExtra")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public byte getByteExtra(java.lang.String name, byte defaultValue)
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@param defaultValue the value to be returned if no value of the desired
  /// type is stored with the given name.
  ///@return the value of an item previously added with putExtra(),
  /// or the default value if none was found.
  ///@see \#putExtra(String, byte)
  int getByteExtra(jni.JniString name, int defaultValue) {
    final result__ = _getByteExtra(reference, name.reference, defaultValue);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getShortExtra = jniLookup<
          ffi.NativeFunction<
              ffi.Int16 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int16)>>("android_content_Intent_getShortExtra")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public short getShortExtra(java.lang.String name, short defaultValue)
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@param defaultValue the value to be returned if no value of the desired
  /// type is stored with the given name.
  ///@return the value of an item previously added with putExtra(),
  /// or the default value if none was found.
  ///@see \#putExtra(String, short)
  int getShortExtra(jni.JniString name, int defaultValue) {
    final result__ = _getShortExtra(reference, name.reference, defaultValue);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getCharExtra = jniLookup<
          ffi.NativeFunction<
              ffi.Int16 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int16)>>("android_content_Intent_getCharExtra")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public char getCharExtra(java.lang.String name, char defaultValue)
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@param defaultValue the value to be returned if no value of the desired
  /// type is stored with the given name.
  ///@return the value of an item previously added with putExtra(),
  /// or the default value if none was found.
  ///@see \#putExtra(String, char)
  int getCharExtra(jni.JniString name, int defaultValue) {
    final result__ = _getCharExtra(reference, name.reference, defaultValue);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getIntExtra = jniLookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Intent_getIntExtra")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getIntExtra(java.lang.String name, int defaultValue)
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@param defaultValue the value to be returned if no value of the desired
  /// type is stored with the given name.
  ///@return the value of an item previously added with putExtra(),
  /// or the default value if none was found.
  ///@see \#putExtra(String, int)
  int getIntExtra(jni.JniString name, int defaultValue) {
    final result__ = _getIntExtra(reference, name.reference, defaultValue);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getLongExtra = jniLookup<
          ffi.NativeFunction<
              ffi.Int64 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_content_Intent_getLongExtra")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public long getLongExtra(java.lang.String name, long defaultValue)
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@param defaultValue the value to be returned if no value of the desired
  /// type is stored with the given name.
  ///@return the value of an item previously added with putExtra(),
  /// or the default value if none was found.
  ///@see \#putExtra(String, long)
  int getLongExtra(jni.JniString name, int defaultValue) {
    final result__ = _getLongExtra(reference, name.reference, defaultValue);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getFloatExtra = jniLookup<
          ffi.NativeFunction<
              ffi.Float Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("android_content_Intent_getFloatExtra")
      .asFunction<
          double Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, double)>();

  /// from: public float getFloatExtra(java.lang.String name, float defaultValue)
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@param defaultValue the value to be returned if no value of the desired
  /// type is stored with the given name.
  ///@return the value of an item previously added with putExtra(),
  /// or the default value if no such item is present
  ///@see \#putExtra(String, float)
  double getFloatExtra(jni.JniString name, double defaultValue) {
    final result__ = _getFloatExtra(reference, name.reference, defaultValue);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDoubleExtra = jniLookup<
          ffi.NativeFunction<
              ffi.Double Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Double)>>("android_content_Intent_getDoubleExtra")
      .asFunction<
          double Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, double)>();

  /// from: public double getDoubleExtra(java.lang.String name, double defaultValue)
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@param defaultValue the value to be returned if no value of the desired
  /// type is stored with the given name.
  ///@return the value of an item previously added with putExtra(),
  /// or the default value if none was found.
  ///@see \#putExtra(String, double)
  double getDoubleExtra(jni.JniString name, double defaultValue) {
    final result__ = _getDoubleExtra(reference, name.reference, defaultValue);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getStringExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getStringExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getStringExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no String value was found.
  ///@see \#putExtra(String, String)
  jni.JniString getStringExtra(jni.JniString name) {
    final result__ =
        jni.JniString.fromRef(_getStringExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getCharSequenceExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getCharSequenceExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getCharSequenceExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no CharSequence value was found.
  ///@see \#putExtra(String, CharSequence)
  jni.JniObject getCharSequenceExtra(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_getCharSequenceExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getParcelableArrayExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getParcelableArrayExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Parcelable[] getParcelableArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no Parcelable[] value was found.
  ///@see \#putExtra(String, Parcelable[])
  jni.JniObject getParcelableArrayExtra(jni.JniString name) {
    final result__ = jni.JniObject.fromRef(
        _getParcelableArrayExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getParcelableArrayListExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getParcelableArrayListExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.ArrayList<T> getParcelableArrayListExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with
  /// putParcelableArrayListExtra(), or null if no
  /// ArrayList<Parcelable> value was found.
  ///@see \#putParcelableArrayListExtra(String, ArrayList)
  jni.JniObject getParcelableArrayListExtra(jni.JniString name) {
    final result__ = jni.JniObject.fromRef(
        _getParcelableArrayListExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSerializableExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getSerializableExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.Serializable getSerializableExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no Serializable value was found.
  ///@see \#putExtra(String, Serializable)
  jni.JniObject getSerializableExtra(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_getSerializableExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getIntegerArrayListExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getIntegerArrayListExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.ArrayList<java.lang.Integer> getIntegerArrayListExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with
  /// putIntegerArrayListExtra(), or null if no
  /// ArrayList<Integer> value was found.
  ///@see \#putIntegerArrayListExtra(String, ArrayList)
  jni.JniObject getIntegerArrayListExtra(jni.JniString name) {
    final result__ = jni.JniObject.fromRef(
        _getIntegerArrayListExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getStringArrayListExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getStringArrayListExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.ArrayList<java.lang.String> getStringArrayListExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with
  /// putStringArrayListExtra(), or null if no
  /// ArrayList<String> value was found.
  ///@see \#putStringArrayListExtra(String, ArrayList)
  jni.JniObject getStringArrayListExtra(jni.JniString name) {
    final result__ = jni.JniObject.fromRef(
        _getStringArrayListExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getCharSequenceArrayListExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getCharSequenceArrayListExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.ArrayList<java.lang.CharSequence> getCharSequenceArrayListExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with
  /// putCharSequenceArrayListExtra, or null if no
  /// ArrayList<CharSequence> value was found.
  ///@see \#putCharSequenceArrayListExtra(String, ArrayList)
  jni.JniObject getCharSequenceArrayListExtra(jni.JniString name) {
    final result__ = jni.JniObject.fromRef(
        _getCharSequenceArrayListExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getBooleanArrayExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getBooleanArrayExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean[] getBooleanArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no boolean array value was found.
  ///@see \#putExtra(String, boolean[])
  jni.JniObject getBooleanArrayExtra(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_getBooleanArrayExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getByteArrayExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getByteArrayExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public byte[] getByteArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no byte array value was found.
  ///@see \#putExtra(String, byte[])
  jni.JniObject getByteArrayExtra(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_getByteArrayExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getShortArrayExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getShortArrayExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public short[] getShortArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no short array value was found.
  ///@see \#putExtra(String, short[])
  jni.JniObject getShortArrayExtra(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_getShortArrayExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getCharArrayExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getCharArrayExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public char[] getCharArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no char array value was found.
  ///@see \#putExtra(String, char[])
  jni.JniObject getCharArrayExtra(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_getCharArrayExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getIntArrayExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getIntArrayExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int[] getIntArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no int array value was found.
  ///@see \#putExtra(String, int[])
  jni.JniObject getIntArrayExtra(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_getIntArrayExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getLongArrayExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getLongArrayExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public long[] getLongArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no long array value was found.
  ///@see \#putExtra(String, long[])
  jni.JniObject getLongArrayExtra(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_getLongArrayExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getFloatArrayExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getFloatArrayExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public float[] getFloatArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no float array value was found.
  ///@see \#putExtra(String, float[])
  jni.JniObject getFloatArrayExtra(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_getFloatArrayExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDoubleArrayExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getDoubleArrayExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public double[] getDoubleArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no double array value was found.
  ///@see \#putExtra(String, double[])
  jni.JniObject getDoubleArrayExtra(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_getDoubleArrayExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getStringArrayExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getStringArrayExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getStringArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no String array value was found.
  ///@see \#putExtra(String, String[])
  jni.JniObject getStringArrayExtra(jni.JniString name) {
    final result__ =
        jni.JniObject.fromRef(_getStringArrayExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getCharSequenceArrayExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getCharSequenceArrayExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence[] getCharSequenceArrayExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no CharSequence array value was found.
  ///@see \#putExtra(String, CharSequence[])
  jni.JniObject getCharSequenceArrayExtra(jni.JniString name) {
    final result__ = jni.JniObject.fromRef(
        _getCharSequenceArrayExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getBundleExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getBundleExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getBundleExtra(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve extended data from the intent.
  ///@param name The name of the desired item.
  ///@return the value of an item previously added with putExtra(),
  /// or null if no Bundle value was found.
  ///@see \#putExtra(String, Bundle)
  os_.Bundle getBundleExtra(jni.JniString name) {
    final result__ =
        os_.Bundle.fromRef(_getBundleExtra(reference, name.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getExtras = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_getExtras")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves a map of extended data from the intent.
  ///@return the map of all extras previously added with putExtra(),
  /// or null if none have been added.
  os_.Bundle getExtras() {
    final result__ = os_.Bundle.fromRef(_getExtras(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getFlags =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Intent_getFlags")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getFlags()
  ///
  /// Retrieve any special flags associated with this intent.  You will
  /// normally just set them with \#setFlags and let the system
  /// take the appropriate action with them.
  ///@return The currently set flags.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION, android.content.Intent\#FLAG_FROM_BACKGROUND, android.content.Intent\#FLAG_DEBUG_LOG_RESOLUTION, android.content.Intent\#FLAG_EXCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_INCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_GRANT_PERSISTABLE_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_PREFIX_URI_PERMISSION, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, android.content.Intent\#FLAG_ACTIVITY_MATCH_EXTERNAL, android.content.Intent\#FLAG_ACTIVITY_NO_HISTORY, android.content.Intent\#FLAG_ACTIVITY_SINGLE_TOP, android.content.Intent\#FLAG_ACTIVITY_NEW_TASK, android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TOP, android.content.Intent\#FLAG_ACTIVITY_FORWARD_RESULT, android.content.Intent\#FLAG_ACTIVITY_PREVIOUS_IS_TOP, android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS, android.content.Intent\#FLAG_ACTIVITY_BROUGHT_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED, android.content.Intent\#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NO_USER_ACTION, android.content.Intent\#FLAG_ACTIVITY_REORDER_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_NO_ANIMATION, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TASK, android.content.Intent\#FLAG_ACTIVITY_TASK_ON_HOME, android.content.Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS, android.content.Intent\#FLAG_ACTIVITY_LAUNCH_ADJACENT, android.content.Intent\#FLAG_RECEIVER_REGISTERED_ONLY, android.content.Intent\#FLAG_RECEIVER_REPLACE_PENDING, android.content.Intent\#FLAG_RECEIVER_FOREGROUND, android.content.Intent\#FLAG_RECEIVER_NO_ABORT, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, and android.content.Intent\#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@see \#setFlags
  ///@see \#addFlags
  ///@see \#removeFlags
  int getFlags() {
    final result__ = _getFlags(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPackage = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_getPackage")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the application package name this Intent is limited to.  When
  /// resolving an Intent, if non-null this limits the resolution to only
  /// components in the given application package.
  ///@return The name of the application package for the Intent.
  ///@see \#resolveActivity
  ///@see \#setPackage
  jni.JniString getPackage() {
    final result__ = jni.JniString.fromRef(_getPackage(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getComponent = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getComponent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getComponent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the concrete component associated with the intent.  When receiving
  /// an intent, this is the component that was found to best handle it (that is,
  /// yourself) and will always be non-null; in all other cases it will be
  /// null unless explicitly set.
  ///@return The name of the application component to handle the intent.
  ///@see \#resolveActivity
  ///@see \#setComponent
  ComponentName getComponent() {
    final result__ = ComponentName.fromRef(_getComponent(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSourceBounds = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_getSourceBounds")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Rect getSourceBounds()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the bounds of the sender of this intent, in screen coordinates.  This can be
  /// used as a hint to the receiver for animations and the like.  Null means that there
  /// is no source bounds.
  ///@return This value may be {@code null}.
  jni.JniObject getSourceBounds() {
    final result__ = jni.JniObject.fromRef(_getSourceBounds(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _resolveActivity = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_resolveActivity")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName resolveActivity(android.content.pm.PackageManager pm)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Activity component that should be used to handle this intent.
  /// The appropriate component is determined based on the information in the
  /// intent, evaluated as follows:
  ///
  /// If \#getComponent returns an explicit class, that is returned
  /// without any further consideration.
  ///
  /// The activity must handle the Intent\#CATEGORY_DEFAULT Intent
  /// category to be considered.
  ///
  /// If \#getAction is non-NULL, the activity must handle this
  /// action.
  ///
  /// If \#resolveType returns non-NULL, the activity must handle
  /// this type.
  ///
  /// If \#addCategory has added any categories, the activity must
  /// handle ALL of the categories specified.
  ///
  /// If \#getPackage is non-NULL, only activity components in
  /// that application package will be considered.
  ///
  /// If there are no activities that satisfy all of these conditions, a
  /// null string is returned.
  ///
  /// If multiple activities are found to satisfy the intent, the one with
  /// the highest priority will be used.  If there are multiple activities
  /// with the same priority, the system will either pick the best activity
  /// based on user preference, or resolve to a system class that will allow
  /// the user to pick an activity and forward from there.
  ///
  /// This method is implemented simply by calling
  /// PackageManager\#resolveActivity with the "defaultOnly" parameter
  /// true.
  ///
  ///  This API is called for you as part of starting an activity from an
  /// intent.  You do not normally need to call it yourself.
  ///
  ///@param pm The package manager with which to resolve the Intent.
  ///
  /// This value must never be {@code null}.
  ///@return Name of the component implementing an activity that can
  ///         display the intent.
  ///@see \#setComponent
  ///@see \#getComponent
  ///@see \#resolveActivityInfo
  ComponentName resolveActivity(pm_.PackageManager pm) {
    final result__ =
        ComponentName.fromRef(_resolveActivity(reference, pm.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _resolveActivityInfo = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Intent_resolveActivityInfo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.pm.ActivityInfo resolveActivityInfo(android.content.pm.PackageManager pm, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Resolve the Intent into an ActivityInfo
  /// describing the activity that should execute the intent.  Resolution
  /// follows the same rules as described for \#resolveActivity, but
  /// you get back the completely information about the resolved activity
  /// instead of just its class name.
  ///@param pm The package manager with which to resolve the Intent.
  /// This value must never be {@code null}.
  ///@param flags Addition information to retrieve as per
  /// PackageManager\#getActivityInfo(ComponentName, int) PackageManager.getActivityInfo().
  ///
  /// Value is either <code>0</code> or a combination of android.content.pm.PackageManager\#GET_META_DATA, android.content.pm.PackageManager\#GET_SHARED_LIBRARY_FILES, android.content.pm.PackageManager\#MATCH_ALL, android.content.pm.PackageManager.MATCH_DEBUG_TRIAGED_MISSING, android.content.pm.PackageManager\#MATCH_DEFAULT_ONLY, android.content.pm.PackageManager\#MATCH_DISABLED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DISABLED_UNTIL_USED_COMPONENTS, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_AWARE, android.content.pm.PackageManager\#MATCH_DIRECT_BOOT_UNAWARE, android.content.pm.PackageManager\#MATCH_SYSTEM_ONLY, android.content.pm.PackageManager\#MATCH_UNINSTALLED_PACKAGES, android.content.pm.PackageManager.MATCH_INSTANT, android.content.pm.PackageManager.MATCH_STATIC_SHARED_LIBRARIES, android.content.pm.PackageManager\#GET_DISABLED_COMPONENTS, android.content.pm.PackageManager\#GET_DISABLED_UNTIL_USED_COMPONENTS, and android.content.pm.PackageManager\#GET_UNINSTALLED_PACKAGES
  ///@return PackageManager.ActivityInfo
  ///@see \#resolveActivity
  pm_.ActivityInfo resolveActivityInfo(pm_.PackageManager pm, int flags) {
    final result__ = pm_.ActivityInfo.fromRef(
        _resolveActivityInfo(reference, pm.reference, flags));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setAction = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_setAction")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent setAction(java.lang.String action)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the general action to be performed.
  ///@param action An action name, such as ACTION_VIEW.  Application-specific
  ///               actions should be prefixed with the vendor's package name.
  ///
  /// This value may be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#getAction
  Intent setAction(jni.JniString action) {
    final result__ = Intent.fromRef(_setAction(reference, action.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setData = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_setData")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent setData(android.net.Uri data)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the data this intent is operating on.  This method automatically
  /// clears any type that was previously set by \#setType or
  /// \#setTypeAndNormalize.
  ///
  /// _Note: scheme matching in the Android framework is
  /// case-sensitive, unlike the formal RFC. As a result,
  /// you should always write your Uri with a lower case scheme,
  /// or use Uri\#normalizeScheme or
  /// \#setDataAndNormalize
  /// to ensure that the scheme is converted to lower case._
  ///@param data The Uri of the data this intent is now targeting.
  ///
  /// This value may be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#getData
  ///@see \#setDataAndNormalize
  ///@see android.net.Uri\#normalizeScheme()
  Intent setData(jni.JniObject data) {
    final result__ = Intent.fromRef(_setData(reference, data.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setDataAndNormalize = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_setDataAndNormalize")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent setDataAndNormalize(android.net.Uri data)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Normalize and set the data this intent is operating on.
  ///
  /// This method automatically clears any type that was
  /// previously set (for example, by \#setType).
  ///
  /// The data Uri is normalized using
  /// android.net.Uri\#normalizeScheme before it is set,
  /// so really this is just a convenience method for
  /// <pre>
  /// setData(data.normalize())
  /// </pre>
  ///@param data The Uri of the data this intent is now targeting.
  ///
  /// This value must never be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#getData
  ///@see \#setType
  ///@see android.net.Uri\#normalizeScheme
  Intent setDataAndNormalize(jni.JniObject data) {
    final result__ =
        Intent.fromRef(_setDataAndNormalize(reference, data.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setType = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_setType")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent setType(java.lang.String type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set an explicit MIME data type.
  ///
  /// This is used to create intents that only specify a type and not data,
  /// for example to indicate the type of data to return.
  ///
  /// This method automatically clears any data that was
  /// previously set (for example by \#setData).
  ///
  /// _Note: MIME type matching in the Android framework is
  /// case-sensitive, unlike formal RFC MIME types.  As a result,
  /// you should always write your MIME types with lower case letters,
  /// or use \#normalizeMimeType or \#setTypeAndNormalize
  /// to ensure that it is converted to lower case._
  ///@param type The MIME type of the data being handled by this intent.
  ///
  /// This value may be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#getType
  ///@see \#setTypeAndNormalize
  ///@see \#setDataAndType
  ///@see \#normalizeMimeType
  Intent setType(jni.JniString type) {
    final result__ = Intent.fromRef(_setType(reference, type.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setTypeAndNormalize = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_setTypeAndNormalize")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent setTypeAndNormalize(java.lang.String type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Normalize and set an explicit MIME data type.
  ///
  /// This is used to create intents that only specify a type and not data,
  /// for example to indicate the type of data to return.
  ///
  /// This method automatically clears any data that was
  /// previously set (for example by \#setData).
  ///
  /// The MIME type is normalized using
  /// \#normalizeMimeType before it is set,
  /// so really this is just a convenience method for
  /// <pre>
  /// setType(Intent.normalizeMimeType(type))
  /// </pre>
  ///@param type The MIME type of the data being handled by this intent.
  ///
  /// This value may be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#getType
  ///@see \#setData
  ///@see \#normalizeMimeType
  Intent setTypeAndNormalize(jni.JniString type) {
    final result__ =
        Intent.fromRef(_setTypeAndNormalize(reference, type.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setDataAndType = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_setDataAndType")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent setDataAndType(android.net.Uri data, java.lang.String type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// (Usually optional) Set the data for the intent along with an explicit
  /// MIME data type.  This method should very rarely be used -- it allows you
  /// to override the MIME type that would ordinarily be inferred from the
  /// data with your own type given here.
  ///
  /// _Note: MIME type and Uri scheme matching in the
  /// Android framework is case-sensitive, unlike the formal RFC definitions.
  /// As a result, you should always write these elements with lower case letters,
  /// or use \#normalizeMimeType or android.net.Uri\#normalizeScheme or
  /// \#setDataAndTypeAndNormalize
  /// to ensure that they are converted to lower case._
  ///@param data The Uri of the data this intent is now targeting.
  /// This value may be {@code null}.
  ///@param type The MIME type of the data being handled by this intent.
  ///
  /// This value may be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#setType
  ///@see \#setData
  ///@see \#normalizeMimeType
  ///@see android.net.Uri\#normalizeScheme
  ///@see \#setDataAndTypeAndNormalize
  Intent setDataAndType(jni.JniObject data, jni.JniString type) {
    final result__ = Intent.fromRef(
        _setDataAndType(reference, data.reference, type.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setDataAndTypeAndNormalize = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_setDataAndTypeAndNormalize")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent setDataAndTypeAndNormalize(android.net.Uri data, java.lang.String type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// (Usually optional) Normalize and set both the data Uri and an explicit
  /// MIME data type.  This method should very rarely be used -- it allows you
  /// to override the MIME type that would ordinarily be inferred from the
  /// data with your own type given here.
  ///
  /// The data Uri and the MIME type are normalize using
  /// android.net.Uri\#normalizeScheme and \#normalizeMimeType
  /// before they are set, so really this is just a convenience method for
  /// <pre>
  /// setDataAndType(data.normalize(), Intent.normalizeMimeType(type))
  /// </pre>
  ///@param data The Uri of the data this intent is now targeting.
  /// This value must never be {@code null}.
  ///@param type The MIME type of the data being handled by this intent.
  ///
  /// This value may be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#setType
  ///@see \#setData
  ///@see \#setDataAndType
  ///@see \#normalizeMimeType
  ///@see android.net.Uri\#normalizeScheme
  Intent setDataAndTypeAndNormalize(jni.JniObject data, jni.JniString type) {
    final result__ = Intent.fromRef(
        _setDataAndTypeAndNormalize(reference, data.reference, type.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _addCategory = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_addCategory")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent addCategory(java.lang.String category)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a new category to the intent.  Categories provide additional detail
  /// about the action the intent performs.  When resolving an intent, only
  /// activities that provide _all_ of the requested categories will be
  /// used.
  ///@param category The desired category.  This can be either one of the
  ///               predefined Intent categories, or a custom category in your own
  ///               namespace.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#hasCategory
  ///@see \#removeCategory
  Intent addCategory(jni.JniString category) {
    final result__ =
        Intent.fromRef(_addCategory(reference, category.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _removeCategory = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_removeCategory")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void removeCategory(java.lang.String category)
  ///
  /// Remove a category from an intent.
  ///@param category The category to remove.
  ///@see \#addCategory
  void removeCategory(jni.JniString category) {
    final result__ = _removeCategory(reference, category.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setSelector = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_setSelector")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setSelector(android.content.Intent selector)
  ///
  /// Set a selector for this Intent.  This is a modification to the kinds of
  /// things the Intent will match.  If the selector is set, it will be used
  /// when trying to find entities that can handle the Intent, instead of the
  /// main contents of the Intent.  This allows you build an Intent containing
  /// a generic protocol while targeting it more specifically.
  ///
  /// An example of where this may be used is with things like
  /// \#CATEGORY_APP_BROWSER.  This category allows you to build an
  /// Intent that will launch the Browser application.  However, the correct
  /// main entry point of an application is actually \#ACTION_MAIN
  /// \#CATEGORY_LAUNCHER with \#setComponent(ComponentName)
  /// used to specify the actual Activity to launch.  If you launch the browser
  /// with something different, undesired behavior may happen if the user has
  /// previously or later launches it the normal way, since they do not match.
  /// Instead, you can build an Intent with the MAIN action (but no ComponentName
  /// yet specified) and set a selector with \#ACTION_MAIN and
  /// \#CATEGORY_APP_BROWSER to point it specifically to the browser activity.
  ///
  /// Setting a selector does not impact the behavior of
  /// \#filterEquals(Intent) and \#filterHashCode().  This is part of the
  /// desired behavior of a selector -- it does not impact the base meaning
  /// of the Intent, just what kinds of things will be matched against it
  /// when determining who can handle it.
  ///
  ///
  /// You can not use both a selector and \#setPackage(String) on
  /// the same base Intent.
  ///
  ///@param selector The desired selector Intent; set to null to not use
  /// a special selector.
  ///
  /// This value may be {@code null}.
  void setSelector(Intent selector) {
    final result__ = _setSelector(reference, selector.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setClipData = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_setClipData")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setClipData(android.content.ClipData clip)
  ///
  /// Set a ClipData associated with this Intent.  This replaces any
  /// previously set ClipData.
  ///
  /// The ClipData in an intent is not used for Intent matching or other
  /// such operations.  Semantically it is like extras, used to transmit
  /// additional data with the Intent.  The main feature of using this over
  /// the extras for data is that \#FLAG_GRANT_READ_URI_PERMISSION
  /// and \#FLAG_GRANT_WRITE_URI_PERMISSION will operate on any URI
  /// items included in the clip data.  This is useful, in particular, if
  /// you want to transmit an Intent containing multiple <code>content:</code>
  /// URIs for which the recipient may not have global permission to access the
  /// content provider.
  ///
  /// If the ClipData contains items that are themselves Intents, any
  /// grant flags in those Intents will be ignored.  Only the top-level flags
  /// of the main Intent are respected, and will be applied to all Uri or
  /// Intent items in the clip (or sub-items of the clip).
  ///
  /// The MIME type, label, and icon in the ClipData object are not
  /// directly used by Intent.  Applications should generally rely on the
  /// MIME type of the Intent itself, not what it may find in the ClipData.
  /// A common practice is to construct a ClipData for use with an Intent
  /// with a MIME type of "*&\#47;*".
  ///@param clip The new clip to set.  May be null to clear the current clip.
  ///
  /// This value may be {@code null}.
  void setClipData(ClipData clip) {
    final result__ = _setClipData(reference, clip.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_content_Intent_putExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, boolean value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The boolean data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getBooleanExtra(String, boolean)
  Intent putExtra(jni.JniString name, bool value) {
    final result__ =
        Intent.fromRef(_putExtra(reference, name.reference, value ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra1 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int8)>>("android_content_Intent_putExtra1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, byte value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The byte data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getByteExtra(String, byte)
  Intent putExtra1(jni.JniString name, int value) {
    final result__ =
        Intent.fromRef(_putExtra1(reference, name.reference, value));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra2 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int16)>>("android_content_Intent_putExtra2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, char value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The char data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getCharExtra(String, char)
  Intent putExtra2(jni.JniString name, int value) {
    final result__ =
        Intent.fromRef(_putExtra2(reference, name.reference, value));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra3 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int16)>>("android_content_Intent_putExtra3")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, short value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The short data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getShortExtra(String, short)
  Intent putExtra3(jni.JniString name, int value) {
    final result__ =
        Intent.fromRef(_putExtra3(reference, name.reference, value));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra4 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Intent_putExtra4")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, int value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The integer data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getIntExtra(String, int)
  Intent putExtra4(jni.JniString name, int value) {
    final result__ =
        Intent.fromRef(_putExtra4(reference, name.reference, value));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra5 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_content_Intent_putExtra5")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, long value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The long data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getLongExtra(String, long)
  Intent putExtra5(jni.JniString name, int value) {
    final result__ =
        Intent.fromRef(_putExtra5(reference, name.reference, value));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra6 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("android_content_Intent_putExtra6")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, double)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, float value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The float data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getFloatExtra(String, float)
  Intent putExtra6(jni.JniString name, double value) {
    final result__ =
        Intent.fromRef(_putExtra6(reference, name.reference, value));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra7 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Double)>>("android_content_Intent_putExtra7")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, double)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, double value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The double data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getDoubleExtra(String, double)
  Intent putExtra7(jni.JniString name, double value) {
    final result__ =
        Intent.fromRef(_putExtra7(reference, name.reference, value));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra8 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_putExtra8")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, java.lang.String value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The String data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getStringExtra(String)
  Intent putExtra8(jni.JniString name, jni.JniString value) {
    final result__ =
        Intent.fromRef(_putExtra8(reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra9 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_putExtra9")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, java.lang.CharSequence value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The CharSequence data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getCharSequenceExtra(String)
  Intent putExtra9(jni.JniString name, jni.JniObject value) {
    final result__ =
        Intent.fromRef(_putExtra9(reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra10 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_putExtra10")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, android.os.Parcelable value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The Parcelable data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getParcelableExtra(String)
  Intent putExtra10(jni.JniString name, os_.Parcelable value) {
    final result__ =
        Intent.fromRef(_putExtra10(reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra11 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_putExtra11")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, android.os.Parcelable[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The Parcelable[] data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getParcelableArrayExtra(String)
  Intent putExtra11(jni.JniString name, jni.JniObject value) {
    final result__ =
        Intent.fromRef(_putExtra11(reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putParcelableArrayListExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_putParcelableArrayListExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putParcelableArrayListExtra(java.lang.String name, java.util.ArrayList<? extends android.os.Parcelable> value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The ArrayList<Parcelable> data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getParcelableArrayListExtra(String)
  Intent putParcelableArrayListExtra(jni.JniString name, jni.JniObject value) {
    final result__ = Intent.fromRef(_putParcelableArrayListExtra(
        reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putIntegerArrayListExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_putIntegerArrayListExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putIntegerArrayListExtra(java.lang.String name, java.util.ArrayList<java.lang.Integer> value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The ArrayList<Integer> data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getIntegerArrayListExtra(String)
  Intent putIntegerArrayListExtra(jni.JniString name, jni.JniObject value) {
    final result__ = Intent.fromRef(
        _putIntegerArrayListExtra(reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putStringArrayListExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_putStringArrayListExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putStringArrayListExtra(java.lang.String name, java.util.ArrayList<java.lang.String> value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The ArrayList<String> data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getStringArrayListExtra(String)
  Intent putStringArrayListExtra(jni.JniString name, jni.JniObject value) {
    final result__ = Intent.fromRef(
        _putStringArrayListExtra(reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putCharSequenceArrayListExtra = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_putCharSequenceArrayListExtra")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putCharSequenceArrayListExtra(java.lang.String name, java.util.ArrayList<java.lang.CharSequence> value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The ArrayList<CharSequence> data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getCharSequenceArrayListExtra(String)
  Intent putCharSequenceArrayListExtra(
      jni.JniString name, jni.JniObject value) {
    final result__ = Intent.fromRef(_putCharSequenceArrayListExtra(
        reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra12 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_putExtra12")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, java.io.Serializable value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The Serializable data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getSerializableExtra(String)
  Intent putExtra12(jni.JniString name, jni.JniObject value) {
    final result__ =
        Intent.fromRef(_putExtra12(reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra13 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_putExtra13")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, boolean[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The boolean array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getBooleanArrayExtra(String)
  Intent putExtra13(jni.JniString name, jni.JniObject value) {
    final result__ =
        Intent.fromRef(_putExtra13(reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra14 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_putExtra14")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, byte[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The byte array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getByteArrayExtra(String)
  Intent putExtra14(jni.JniString name, jni.JniObject value) {
    final result__ =
        Intent.fromRef(_putExtra14(reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra15 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_putExtra15")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, short[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The short array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getShortArrayExtra(String)
  Intent putExtra15(jni.JniString name, jni.JniObject value) {
    final result__ =
        Intent.fromRef(_putExtra15(reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra16 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_putExtra16")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, char[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The char array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getCharArrayExtra(String)
  Intent putExtra16(jni.JniString name, jni.JniObject value) {
    final result__ =
        Intent.fromRef(_putExtra16(reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra17 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_putExtra17")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, int[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The int array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getIntArrayExtra(String)
  Intent putExtra17(jni.JniString name, jni.JniObject value) {
    final result__ =
        Intent.fromRef(_putExtra17(reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra18 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_putExtra18")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, long[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The byte array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getLongArrayExtra(String)
  Intent putExtra18(jni.JniString name, jni.JniObject value) {
    final result__ =
        Intent.fromRef(_putExtra18(reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra19 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_putExtra19")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, float[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The float array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getFloatArrayExtra(String)
  Intent putExtra19(jni.JniString name, jni.JniObject value) {
    final result__ =
        Intent.fromRef(_putExtra19(reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra20 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_putExtra20")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, double[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The double array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getDoubleArrayExtra(String)
  Intent putExtra20(jni.JniString name, jni.JniObject value) {
    final result__ =
        Intent.fromRef(_putExtra20(reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra21 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_putExtra21")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, java.lang.String[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The String array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getStringArrayExtra(String)
  Intent putExtra21(jni.JniString name, jni.JniObject value) {
    final result__ =
        Intent.fromRef(_putExtra21(reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra22 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_putExtra22")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, java.lang.CharSequence[] value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The CharSequence array data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getCharSequenceArrayExtra(String)
  Intent putExtra22(jni.JniString name, jni.JniObject value) {
    final result__ =
        Intent.fromRef(_putExtra22(reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtra23 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_putExtra23")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putExtra(java.lang.String name, android.os.Bundle value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add extended data to the intent.  The name must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param name The name of the extra data, with package prefix.
  ///@param value The Bundle data value.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#putExtras
  ///@see \#removeExtra
  ///@see \#getBundleExtra(String)
  Intent putExtra23(jni.JniString name, os_.Bundle value) {
    final result__ =
        Intent.fromRef(_putExtra23(reference, name.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtras = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_putExtras")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putExtras(android.content.Intent src)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Copy all extras in 'src' in to this intent.
  ///@param src Contains the extras to copy.
  ///
  /// This value must never be {@code null}.
  ///@see \#putExtra
  ///@return This value will never be {@code null}.
  Intent putExtras(Intent src) {
    final result__ = Intent.fromRef(_putExtras(reference, src.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putExtras1 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_putExtras1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent putExtras(android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a set of extended data to the intent.  The keys must include a package
  /// prefix, for example the app com.android.contacts would use names
  /// like "com.android.contacts.ShowAll".
  ///@param extras The Bundle of extras to add to this intent.
  ///
  /// This value must never be {@code null}.
  ///@see \#putExtra
  ///@see \#removeExtra
  ///@return This value will never be {@code null}.
  Intent putExtras1(os_.Bundle extras) {
    final result__ = Intent.fromRef(_putExtras1(reference, extras.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _replaceExtras = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_replaceExtras")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent replaceExtras(android.content.Intent src)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Completely replace the extras in the Intent with the extras in the
  /// given Intent.
  ///@param src The exact extras contained in this Intent are copied
  /// into the target intent, replacing any that were previously there.
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  Intent replaceExtras(Intent src) {
    final result__ = Intent.fromRef(_replaceExtras(reference, src.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _replaceExtras1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_replaceExtras1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent replaceExtras(android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Completely replace the extras in the Intent with the given Bundle of
  /// extras.
  ///@param extras The new set of extras in the Intent, or null to erase
  /// all extras.
  ///
  /// This value must never be {@code null}.
  Intent replaceExtras1(os_.Bundle extras) {
    final result__ =
        Intent.fromRef(_replaceExtras1(reference, extras.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _removeExtra = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_removeExtra")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void removeExtra(java.lang.String name)
  ///
  /// Remove extended data from the intent.
  ///@see \#putExtra
  void removeExtra(jni.JniString name) {
    final result__ = _removeExtra(reference, name.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setFlags = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Intent_setFlags")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.Intent setFlags(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set special flags controlling how this intent is handled.  Most values
  /// here depend on the type of component being executed by the Intent,
  /// specifically the FLAG_ACTIVITY_* flags are all for use with
  /// Context\#startActivity Context.startActivity() and the
  /// FLAG_RECEIVER_* flags are all for use with
  /// Context\#sendBroadcast(Intent) Context.sendBroadcast().
  ///
  /// See the
  /// <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
  /// Stack</a> documentation for important information on how some of these options impact
  /// the behavior of your application.
  ///@param flags The desired flags.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION, android.content.Intent\#FLAG_FROM_BACKGROUND, android.content.Intent\#FLAG_DEBUG_LOG_RESOLUTION, android.content.Intent\#FLAG_EXCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_INCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_GRANT_PERSISTABLE_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_PREFIX_URI_PERMISSION, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, android.content.Intent\#FLAG_ACTIVITY_MATCH_EXTERNAL, android.content.Intent\#FLAG_ACTIVITY_NO_HISTORY, android.content.Intent\#FLAG_ACTIVITY_SINGLE_TOP, android.content.Intent\#FLAG_ACTIVITY_NEW_TASK, android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TOP, android.content.Intent\#FLAG_ACTIVITY_FORWARD_RESULT, android.content.Intent\#FLAG_ACTIVITY_PREVIOUS_IS_TOP, android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS, android.content.Intent\#FLAG_ACTIVITY_BROUGHT_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED, android.content.Intent\#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NO_USER_ACTION, android.content.Intent\#FLAG_ACTIVITY_REORDER_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_NO_ANIMATION, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TASK, android.content.Intent\#FLAG_ACTIVITY_TASK_ON_HOME, android.content.Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS, android.content.Intent\#FLAG_ACTIVITY_LAUNCH_ADJACENT, android.content.Intent\#FLAG_RECEIVER_REGISTERED_ONLY, android.content.Intent\#FLAG_RECEIVER_REPLACE_PENDING, android.content.Intent\#FLAG_RECEIVER_FOREGROUND, android.content.Intent\#FLAG_RECEIVER_NO_ABORT, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, and android.content.Intent\#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  /// This value will never be {@code null}.
  ///@see \#getFlags
  ///@see \#addFlags
  ///@see \#removeFlags
  Intent setFlags(int flags) {
    final result__ = Intent.fromRef(_setFlags(reference, flags));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _addFlags = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Intent_addFlags")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.Intent addFlags(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add additional flags to the intent (or with existing flags value).
  ///@param flags The new flags to set.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION, android.content.Intent\#FLAG_FROM_BACKGROUND, android.content.Intent\#FLAG_DEBUG_LOG_RESOLUTION, android.content.Intent\#FLAG_EXCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_INCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_GRANT_PERSISTABLE_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_PREFIX_URI_PERMISSION, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, android.content.Intent\#FLAG_ACTIVITY_MATCH_EXTERNAL, android.content.Intent\#FLAG_ACTIVITY_NO_HISTORY, android.content.Intent\#FLAG_ACTIVITY_SINGLE_TOP, android.content.Intent\#FLAG_ACTIVITY_NEW_TASK, android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TOP, android.content.Intent\#FLAG_ACTIVITY_FORWARD_RESULT, android.content.Intent\#FLAG_ACTIVITY_PREVIOUS_IS_TOP, android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS, android.content.Intent\#FLAG_ACTIVITY_BROUGHT_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED, android.content.Intent\#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NO_USER_ACTION, android.content.Intent\#FLAG_ACTIVITY_REORDER_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_NO_ANIMATION, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TASK, android.content.Intent\#FLAG_ACTIVITY_TASK_ON_HOME, android.content.Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS, android.content.Intent\#FLAG_ACTIVITY_LAUNCH_ADJACENT, android.content.Intent\#FLAG_RECEIVER_REGISTERED_ONLY, android.content.Intent\#FLAG_RECEIVER_REPLACE_PENDING, android.content.Intent\#FLAG_RECEIVER_FOREGROUND, android.content.Intent\#FLAG_RECEIVER_NO_ABORT, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, and android.content.Intent\#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@return Returns the same Intent object, for chaining multiple calls into
  ///         a single statement.
  /// This value will never be {@code null}.
  ///@see \#setFlags
  ///@see \#getFlags
  ///@see \#removeFlags
  Intent addFlags(int flags) {
    final result__ = Intent.fromRef(_addFlags(reference, flags));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _removeFlags = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Intent_removeFlags")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void removeFlags(int flags)
  ///
  /// Remove these flags from the intent.
  ///@param flags The flags to remove.
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FLAG_GRANT_READ_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_WRITE_URI_PERMISSION, android.content.Intent\#FLAG_FROM_BACKGROUND, android.content.Intent\#FLAG_DEBUG_LOG_RESOLUTION, android.content.Intent\#FLAG_EXCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_INCLUDE_STOPPED_PACKAGES, android.content.Intent\#FLAG_GRANT_PERSISTABLE_URI_PERMISSION, android.content.Intent\#FLAG_GRANT_PREFIX_URI_PERMISSION, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, android.content.Intent\#FLAG_ACTIVITY_MATCH_EXTERNAL, android.content.Intent\#FLAG_ACTIVITY_NO_HISTORY, android.content.Intent\#FLAG_ACTIVITY_SINGLE_TOP, android.content.Intent\#FLAG_ACTIVITY_NEW_TASK, android.content.Intent\#FLAG_ACTIVITY_MULTIPLE_TASK, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TOP, android.content.Intent\#FLAG_ACTIVITY_FORWARD_RESULT, android.content.Intent\#FLAG_ACTIVITY_PREVIOUS_IS_TOP, android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS, android.content.Intent\#FLAG_ACTIVITY_BROUGHT_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED, android.content.Intent\#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NEW_DOCUMENT, android.content.Intent\#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET, android.content.Intent\#FLAG_ACTIVITY_NO_USER_ACTION, android.content.Intent\#FLAG_ACTIVITY_REORDER_TO_FRONT, android.content.Intent\#FLAG_ACTIVITY_NO_ANIMATION, android.content.Intent\#FLAG_ACTIVITY_CLEAR_TASK, android.content.Intent\#FLAG_ACTIVITY_TASK_ON_HOME, android.content.Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS, android.content.Intent\#FLAG_ACTIVITY_LAUNCH_ADJACENT, android.content.Intent\#FLAG_RECEIVER_REGISTERED_ONLY, android.content.Intent\#FLAG_RECEIVER_REPLACE_PENDING, android.content.Intent\#FLAG_RECEIVER_FOREGROUND, android.content.Intent\#FLAG_RECEIVER_NO_ABORT, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, and android.content.Intent\#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS
  ///@see \#setFlags
  ///@see \#getFlags
  ///@see \#addFlags
  void removeFlags(int flags) {
    final result__ = _removeFlags(reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setPackage = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_setPackage")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent setPackage(java.lang.String packageName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// (Usually optional) Set an explicit application package name that limits
  /// the components this Intent will resolve to.  If left to the default
  /// value of null, all components in all applications will considered.
  /// If non-null, the Intent can only match the components in the given
  /// application package.
  ///@param packageName The name of the application package to handle the
  /// intent, or null to allow any application package.
  ///
  /// This value may be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///@see \#getPackage
  ///@see \#resolveActivity
  Intent setPackage(jni.JniString packageName) {
    final result__ =
        Intent.fromRef(_setPackage(reference, packageName.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setComponent = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_setComponent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent setComponent(android.content.ComponentName component)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// (Usually optional) Explicitly set the component to handle the intent.
  /// If left with the default value of null, the system will determine the
  /// appropriate class to use based on the other fields (action, data,
  /// type, categories) in the Intent.  If this class is defined, the
  /// specified class will always be used regardless of the other fields.  You
  /// should only set this value when you know you absolutely want a specific
  /// class to be used; otherwise it is better to let the system find the
  /// appropriate class so that you will respect the installed applications
  /// and user preferences.
  ///@param component The name of the application component to handle the
  /// intent, or null to let the system find one for you.
  ///
  /// This value may be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///@see \#setClass
  ///@see \#setClassName(Context, String)
  ///@see \#setClassName(String, String)
  ///@see \#getComponent
  ///@see \#resolveActivity
  Intent setComponent(ComponentName component) {
    final result__ =
        Intent.fromRef(_setComponent(reference, component.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setClassName = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_setClassName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent setClassName(android.content.Context packageContext, java.lang.String className)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience for calling \#setComponent with an
  /// explicit class name.
  ///@param packageContext A Context of the application package implementing
  /// this class.
  /// This value must never be {@code null}.
  ///@param className The name of a class inside of the application package
  /// that will be used as the component for this Intent.
  ///
  /// This value must never be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#setComponent
  ///@see \#setClass
  Intent setClassName(Context packageContext, jni.JniString className) {
    final result__ = Intent.fromRef(_setClassName(
        reference, packageContext.reference, className.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setClassName1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_setClassName1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent setClassName(java.lang.String packageName, java.lang.String className)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience for calling \#setComponent with an
  /// explicit application package name and class name.
  ///@param packageName The name of the package implementing the desired
  /// component.
  /// This value must never be {@code null}.
  ///@param className The name of a class inside of the application package
  /// that will be used as the component for this Intent.
  ///
  /// This value must never be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#setComponent
  ///@see \#setClass
  Intent setClassName1(jni.JniString packageName, jni.JniString className) {
    final result__ = Intent.fromRef(
        _setClassName1(reference, packageName.reference, className.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setClass = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_setClass")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent setClass(android.content.Context packageContext, java.lang.Class<?> cls)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience for calling \#setComponent(ComponentName) with the
  /// name returned by a Class object.
  ///@param packageContext A Context of the application package implementing
  /// this class.
  /// This value must never be {@code null}.
  ///@param cls The class name to set, equivalent to
  ///            <code>setClassName(context, cls.getName())</code>.
  ///
  /// This value must never be {@code null}.
  ///@return Returns the same Intent object, for chaining multiple calls
  /// into a single statement.
  ///
  /// This value will never be {@code null}.
  ///@see \#setComponent
  Intent setClass(Context packageContext, jni.JniObject cls) {
    final result__ = Intent.fromRef(
        _setClass(reference, packageContext.reference, cls.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setSourceBounds = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_setSourceBounds")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setSourceBounds(android.graphics.Rect r)
  ///
  /// Set the bounds of the sender of this intent, in screen coordinates.  This can be
  /// used as a hint to the receiver for animations and the like.  Null means that there
  /// is no source bounds.
  ///@param r This value may be {@code null}.
  void setSourceBounds(jni.JniObject r) {
    final result__ = _setSourceBounds(reference, r.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _fillIn = jniLookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Intent_fillIn")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public int fillIn(android.content.Intent other, int flags)
  ///
  /// Copy the contents of <var>other</var> in to this object, but only
  /// where fields are not defined by this object.  For purposes of a field
  /// being defined, the following pieces of data in the Intent are
  /// considered to be separate fields:
  ///
  /// <ul>
  /// <li> action, as set by \#setAction.
  /// <li> data Uri and MIME type, as set by \#setData(Uri),
  /// \#setType(String), or \#setDataAndType(Uri, String).
  /// <li> categories, as set by \#addCategory.
  /// <li> package, as set by \#setPackage.
  /// <li> component, as set by \#setComponent(ComponentName) or
  /// related methods.
  /// <li> source bounds, as set by \#setSourceBounds.
  /// <li> selector, as set by \#setSelector(Intent).
  /// <li> clip data, as set by \#setClipData(ClipData).
  /// <li> each top-level name in the associated extras.
  /// </ul>
  ///
  /// In addition, you can use the \#FILL_IN_ACTION,
  /// \#FILL_IN_DATA, \#FILL_IN_CATEGORIES, \#FILL_IN_PACKAGE,
  /// \#FILL_IN_COMPONENT, \#FILL_IN_SOURCE_BOUNDS,
  /// \#FILL_IN_SELECTOR, and \#FILL_IN_CLIP_DATA to override
  /// the restriction where the corresponding field will not be replaced if
  /// it is already set.
  ///
  /// Note: The component field will only be copied if \#FILL_IN_COMPONENT
  /// is explicitly specified.  The selector will only be copied if
  /// \#FILL_IN_SELECTOR is explicitly specified.
  ///
  /// For example, consider Intent A with {data="foo", categories="bar"}
  /// and Intent B with {action="gotit", data-type="some/thing",
  /// categories="one","two"}.
  ///
  /// Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now
  /// containing: {action="gotit", data-type="some/thing",
  /// categories="bar"}.
  ///@param other Another Intent whose values are to be used to fill in
  /// the current one.
  /// This value must never be {@code null}.
  ///@param flags Options to control which fields can be filled in.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns a bit mask of \#FILL_IN_ACTION,
  /// \#FILL_IN_DATA, \#FILL_IN_CATEGORIES, \#FILL_IN_PACKAGE,
  /// \#FILL_IN_COMPONENT, \#FILL_IN_SOURCE_BOUNDS,
  /// \#FILL_IN_SELECTOR and \#FILL_IN_CLIP_DATA indicating which fields were
  /// changed.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  int fillIn(Intent other, int flags) {
    final result__ = _fillIn(reference, other.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _filterEquals = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_filterEquals")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean filterEquals(android.content.Intent other)
  ///
  /// Determine if two intents are the same for the purposes of intent
  /// resolution (filtering). That is, if their action, data, type,
  /// class, and categories are the same.  This does _not_ compare
  /// any extra data included in the intents.
  ///@param other The other Intent to compare against.
  ///@return Returns true if action, data, type, class, and categories
  ///         are the same.
  bool filterEquals(Intent other) {
    final result__ = _filterEquals(reference, other.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _filterHashCode =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Intent_filterHashCode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int filterHashCode()
  ///
  /// Generate hash code that matches semantics of filterEquals().
  ///@return Returns the hash value of the action, data, type, class, and
  ///         categories.
  ///@see \#filterEquals
  int filterHashCode() {
    final result__ = _filterHashCode(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toURI = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_toURI")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toURI()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Call \#toUri with 0 flags.
  ///@deprecated Use \#toUri instead.
  jni.JniString toURI() {
    final result__ = jni.JniString.fromRef(_toURI(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toUri = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Intent_toUri")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String toUri(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convert this Intent into a String holding a URI representation of it.
  /// The returned URI string has been properly URI encoded, so it can be
  /// used with Uri\#parse Uri.parse(String).  The URI contains the
  /// Intent's data as the base URI, with an additional fragment describing
  /// the action, categories, type, flags, package, component, and extras.
  ///
  /// You can convert the returned string back to an Intent with
  /// \#getIntent.
  ///@param flags Additional operating flags.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Intent\#URI_ALLOW_UNSAFE, android.content.Intent\#URI_ANDROID_APP_SCHEME, and android.content.Intent\#URI_INTENT_SCHEME
  ///@return Returns a URI encoding URI string describing the entire contents
  /// of the Intent.
  jni.JniString toUri(int flags) {
    final result__ = jni.JniString.fromRef(_toUri(reference, flags));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Intent_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_Intent_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os_.Parcel out, int flags) {
    final result__ = _writeToParcel(reference, out.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _readFromParcel = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_readFromParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel in)
  void readFromParcel(os_.Parcel in0) {
    final result__ = _readFromParcel(reference, in0.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _parseIntent = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Intent_parseIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.Intent parseIntent(android.content.res.Resources resources, org.xmlpull.v1.XmlPullParser parser, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parses the "intent" element (and its children) from XML and instantiates
  /// an Intent object.  The given XML parser should be located at the tag
  /// where parsing should start (often named "intent"), from which the
  /// basic action, data, type, and package and class name will be
  /// retrieved.  The function will then parse in to any child elements,
  /// looking for <category android:name="xxx"> tags to add categories and
  /// <extra android:name="xxx" android:value="yyy"> to attach extra data
  /// to the intent.
  ///@param resources The Resources to use when inflating resources.
  /// This value must never be {@code null}.
  ///@param parser The XML parser pointing at an "intent" tag.
  /// This value must never be {@code null}.
  ///@param attrs The AttributeSet interface for retrieving extended
  /// attribute data at the current <var>parser</var> location.
  ///@return An Intent object matching the XML data.
  /// This value will never be {@code null}.
  ///@throws XmlPullParserException If there was an XML parsing error.
  ///@throws IOException If there was an I/O error.
  static Intent parseIntent(
      res_.Resources resources, jni.JniObject parser, jni.JniObject attrs) {
    final result__ = Intent.fromRef(
        _parseIntent(resources.reference, parser.reference, attrs.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _normalizeMimeType = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent_normalizeMimeType")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String normalizeMimeType(java.lang.String type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Normalize a MIME data type.
  ///
  /// A normalized MIME type has white-space trimmed,
  /// content-type parameters removed, and is lower-case.
  /// This aligns the type with Android best practices for
  /// intent filtering.
  ///
  /// For example, "text/plain; charset=utf-8" becomes "text/plain".
  /// "text/x-vCard" becomes "text/x-vcard".
  ///
  /// All MIME types received from outside Android (such as user input,
  /// or external sources like Bluetooth, NFC, or the Internet) should
  /// be normalized before they are used to create an Intent.
  ///@param type MIME data type to normalize
  /// This value may be {@code null}.
  ///@return normalized MIME data type, or null if the input was null
  ///@see \#setType
  ///@see \#setTypeAndNormalize
  static jni.JniString normalizeMimeType(jni.JniString type) {
    final result__ = jni.JniString.fromRef(_normalizeMimeType(type.reference));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.Intent$ShortcutIconResource
///
/// Represents a shortcut/live folder icon resource.
///@see Intent\#ACTION_CREATE_SHORTCUT
///@see Intent\#EXTRA_SHORTCUT_ICON_RESOURCE
///@see android.provider.LiveFolders\#ACTION_CREATE_LIVE_FOLDER
///@see android.provider.LiveFolders\#EXTRA_LIVE_FOLDER_ICON
class Intent_ShortcutIconResource extends jni.JniObject {
  Intent_ShortcutIconResource.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_Intent__ShortcutIconResource_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.Intent.ShortcutIconResource> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used to read a ShortcutIconResource from a Parcel.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  static final _get_packageName = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_Intent__ShortcutIconResource_packageName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public java.lang.String packageName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The package name of the application containing the icon.
  jni.JniString get packageName =>
      jni.JniString.fromRef(_get_packageName(reference));
  static final _set_packageName = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_Intent__ShortcutIconResource_packageName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String packageName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The package name of the application containing the icon.
  set packageName(jni.JniString value) =>
      _set_packageName(reference, value.reference);

  static final _get_resourceName = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_content_Intent__ShortcutIconResource_resourceName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();

  /// from: public java.lang.String resourceName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The resource name of the icon, including package, name and type.
  jni.JniString get resourceName =>
      jni.JniString.fromRef(_get_resourceName(reference));
  static final _set_resourceName = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "set_android_content_Intent__ShortcutIconResource_resourceName")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String resourceName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The resource name of the icon, including package, name and type.
  set resourceName(jni.JniString value) =>
      _set_resourceName(reference, value.reference);

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_Intent__ShortcutIconResource_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Intent_ShortcutIconResource() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _fromContext = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_Intent__ShortcutIconResource_fromContext")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.content.Intent.ShortcutIconResource fromContext(android.content.Context context, int resourceId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new ShortcutIconResource for the specified context and resource
  /// identifier.
  ///@param context The context of the application.
  ///@param resourceId The resource identifier for the icon.
  ///@return A new ShortcutIconResource with the specified's context package name
  ///         and icon resource identifier.``
  static Intent_ShortcutIconResource fromContext(
      Context context, int resourceId) {
    final result__ = Intent_ShortcutIconResource.fromRef(
        _fromContext(context.reference, resourceId));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Intent__ShortcutIconResource_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  ///
  /// No special parcel contents.
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_Intent__ShortcutIconResource_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) {
    final result__ = _writeToParcel(reference, dest.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent__ShortcutIconResource_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.Intent$FilterComparison
///
/// Wrapper class holding an Intent and implementing comparisons on it for
/// the purpose of filtering.  The class implements its
/// \#equals equals() and \#hashCode hashCode() methods as
/// simple calls to Intent\#filterEquals(Intent)  filterEquals()} and
/// android.content.Intent\#filterHashCode()  filterHashCode()}
/// on the wrapped Intent.
class Intent_FilterComparison extends jni.JniObject {
  Intent_FilterComparison.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent__FilterComparison_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Intent intent)
  Intent_FilterComparison(Intent intent)
      : super.fromRef(_ctor(intent.reference)) {
    jni.Jni.env.checkException();
  }

  static final _getIntent = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent__FilterComparison_getIntent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent getIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Intent that this FilterComparison represents.
  ///@return Returns the Intent held by the FilterComparison.  Do
  /// not modify!
  Intent getIntent() {
    final result__ = Intent.fromRef(_getIntent(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _equals1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Intent__FilterComparison_equals1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object obj)
  bool equals1(jni.JniObject obj) {
    final result__ = _equals1(reference, obj.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hashCode1 =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Intent__FilterComparison_hashCode1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    final result__ = _hashCode1(reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.ContentProvider
///
/// Content providers are one of the primary building blocks of Android applications, providing
/// content to applications. They encapsulate data and provide it to applications through the single
/// ContentResolver interface. A content provider is only required if you need to share
/// data between multiple applications. For example, the contacts data is used by multiple
/// applications and must be stored in a content provider. If you don't need to share data amongst
/// multiple applications you can use a database directly via
/// android.database.sqlite.SQLiteDatabase.
///
/// When a request is made via
/// a ContentResolver the system inspects the authority of the given URI and passes the
/// request to the content provider registered with the authority. The content provider can interpret
/// the rest of the URI however it wants. The UriMatcher class is helpful for parsing
/// URIs.
///
///
/// The primary methods that need to be implemented are:
/// <ul>
///   <li>\#onCreate which is called to initialize the provider</li>
///   <li>\#query which returns data to the caller</li>
///   <li>\#insert which inserts new data into the content provider</li>
///   <li>\#update which updates existing data in the content provider</li>
///   <li>\#delete which deletes data from the content provider</li>
///   <li>\#getType which returns the MIME type of data in the content provider</li>
/// </ul>
///
///
/// <p class="caution">Data access methods (such as \#insert and
/// \#update) may be called from many threads at once, and must be thread-safe.
/// Other methods (such as \#onCreate) are only called from the application
/// main thread, and must avoid performing lengthy operations.  See the method
/// descriptions for their expected thread behavior.
///
///
/// Requests to ContentResolver are automatically forwarded to the appropriate
/// ContentProvider instance, so subclasses don't have to worry about the details of
/// cross-process calls.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using content providers, read the
/// <a href="{@docRoot}guide/topics/providers/content-providers.html">Content Providers</a>
/// developer guide.
///
class ContentProvider extends jni.JniObject {
  ContentProvider.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_ContentProvider_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ///
  /// Construct a ContentProvider instance.  Content providers must be
  /// <a href="{@docRoot}guide/topics/manifest/provider-element.html">declared
  /// in the manifest</a>, accessed with ContentResolver, and created
  /// automatically by the system, so applications usually do not create
  /// ContentProvider instances directly.
  ///
  /// At construction time, the object is uninitialized, and most fields and
  /// methods are unavailable.  Subclasses should initialize themselves in
  /// \#onCreate, not the constructor.
  ///
  /// Content providers are created on the application main thread at
  /// application launch time.  The constructor must not perform lengthy
  /// operations, or application startup will be delayed.
  ContentProvider() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _getContext = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_getContext")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the Context this provider is running in.  Only available once
  /// \#onCreate has been called -- this will return {@code null} in the
  /// constructor.
  Context getContext() {
    final result__ = Context.fromRef(_getContext(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getCallingPackage = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_getCallingPackage")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String getCallingPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the package name of the caller that initiated the request being
  /// processed on the current thread. The returned package will have been
  /// verified to belong to the calling UID. Returns {@code null} if not
  /// currently processing a request.
  ///
  /// This will always return {@code null} when processing
  /// \#getType(Uri) or \#getStreamTypes(Uri, String) requests.
  ///@see Binder\#getCallingUid()
  ///@see Context\#grantUriPermission(String, Uri, int)
  ///@throws SecurityException if the calling package doesn't belong to the
  ///             calling UID.
  jni.JniString getCallingPackage() {
    final result__ = jni.JniString.fromRef(_getCallingPackage(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setReadPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_setReadPermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected final void setReadPermission(java.lang.String permission)
  ///
  /// Change the permission required to read data from the content
  /// provider.  This is normally set for you from its manifest information
  /// when the provider is first created.
  ///@param permission Name of the permission required for read-only access.
  ///
  /// This value may be {@code null}.
  void setReadPermission(jni.JniString permission) {
    final result__ = _setReadPermission(reference, permission.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getReadPermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_getReadPermission")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String getReadPermission()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the name of the permission required for read-only access to
  /// this content provider.  This method can be called from multiple
  /// threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///@return This value may be {@code null}.
  jni.JniString getReadPermission() {
    final result__ = jni.JniString.fromRef(_getReadPermission(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setWritePermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_setWritePermission")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected final void setWritePermission(java.lang.String permission)
  ///
  /// Change the permission required to read and write data in the content
  /// provider.  This is normally set for you from its manifest information
  /// when the provider is first created.
  ///@param permission Name of the permission required for read/write access.
  ///
  /// This value may be {@code null}.
  void setWritePermission(jni.JniString permission) {
    final result__ = _setWritePermission(reference, permission.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getWritePermission = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_getWritePermission")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String getWritePermission()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the name of the permission required for read/write access to
  /// this content provider.  This method can be called from multiple
  /// threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///@return This value may be {@code null}.
  jni.JniString getWritePermission() {
    final result__ = jni.JniString.fromRef(_getWritePermission(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _setPathPermissions = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_setPathPermissions")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected final void setPathPermissions(android.content.pm.PathPermission[] permissions)
  ///
  /// Change the path-based permission required to read and/or write data in
  /// the content provider.  This is normally set for you from its manifest
  /// information when the provider is first created.
  ///@param permissions Array of path permission descriptions.
  ///
  /// This value may be {@code null}.
  void setPathPermissions(jni.JniObject permissions) {
    final result__ = _setPathPermissions(reference, permissions.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getPathPermissions = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_getPathPermissions")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.pm.PathPermission[] getPathPermissions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the path-based permissions required for read and/or write access to
  /// this content provider.  This method can be called from multiple
  /// threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///@return This value may be {@code null}.
  jni.JniObject getPathPermissions() {
    final result__ = jni.JniObject.fromRef(_getPathPermissions(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onCreate =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentProvider_onCreate")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean onCreate()
  ///
  /// Implement this to initialize your content provider on startup.
  /// This method is called for all registered content providers on the
  /// application main thread at application launch time.  It must not perform
  /// lengthy operations, or application startup will be delayed.
  ///
  /// You should defer nontrivial initialization (such as opening,
  /// upgrading, and scanning databases) until the content provider is used
  /// (via \#query, \#insert, etc).  Deferred initialization
  /// keeps application startup fast, avoids unnecessary work if the provider
  /// turns out not to be needed, and stops database errors (such as a full
  /// disk) from halting application launch.
  ///
  /// If you use SQLite, android.database.sqlite.SQLiteOpenHelper
  /// is a helpful utility class that makes it easy to manage databases,
  /// and will automatically defer opening until first use.  If you do use
  /// SQLiteOpenHelper, make sure to avoid calling
  /// android.database.sqlite.SQLiteOpenHelper\#getReadableDatabase or
  /// android.database.sqlite.SQLiteOpenHelper\#getWritableDatabase
  /// from this method.  (Instead, override
  /// android.database.sqlite.SQLiteOpenHelper\#onOpen to initialize the
  /// database when it is first opened.)
  ///@return true if the provider was successfully loaded, false otherwise
  bool onCreate() {
    final result__ = _onCreate(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onConfigurationChanged = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_onConfigurationChanged")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onConfigurationChanged(android.content.res.Configuration newConfig)
  ///
  /// {@inheritDoc}
  /// This method is always called on the application main thread, and must
  /// not perform lengthy operations.
  ///
  /// The default content provider implementation does nothing.
  /// Override this method to take appropriate action.
  /// (Content providers do not usually care about things like screen
  /// orientation, but may want to know about locale changes.)
  void onConfigurationChanged(res_.Configuration newConfig) {
    final result__ = _onConfigurationChanged(reference, newConfig.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onLowMemory =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentProvider_onLowMemory")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onLowMemory()
  ///
  /// {@inheritDoc}
  /// This method is always called on the application main thread, and must
  /// not perform lengthy operations.
  ///
  /// The default content provider implementation does nothing.
  /// Subclasses may override this method to take appropriate action.
  void onLowMemory() {
    final result__ = _onLowMemory(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onTrimMemory = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_ContentProvider_onTrimMemory")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onTrimMemory(int level)
  void onTrimMemory(int level) {
    final result__ = _onTrimMemory(reference, level);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _query = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_query")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implement this to handle query requests from clients.
  ///
  /// Apps targeting android.os.Build.VERSION_CODES\#O or higher should override
  /// \#query(Uri, String[], Bundle, CancellationSignal) and provide a stub
  /// implementation of this method.
  ///
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///
  /// Example client call:
  /// <pre>// Request a specific record.
  /// Cursor managedCursor = managedQuery(
  ///      ContentUris.withAppendedId(Contacts.People.CONTENT_URI, 2),
  ///      projection,    // Which columns to return.
  ///      null,          // WHERE clause.
  ///      null,          // WHERE clause value substitution
  ///      People.NAME + " ASC");   // Sort order.</pre>
  /// Example implementation:
  /// <pre>// SQLiteQueryBuilder is a helper class that creates the
  /// // proper SQL syntax for us.
  /// SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder();
  ///
  /// // Set the table we're querying.
  /// qBuilder.setTables(DATABASE_TABLE_NAME);
  ///
  /// // If the query ends in a specific record number, we're
  /// // being asked for a specific record, so set the
  /// // WHERE clause in our query.
  /// if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){
  ///  qBuilder.appendWhere("_id=" + uri.getPathLeafId());
  /// }
  ///
  /// // Make the query.
  /// Cursor c = qBuilder.query(mDb,
  ///      projection,
  ///      selection,
  ///      selectionArgs,
  ///      groupBy,
  ///      having,
  ///      sortOrder);
  /// c.setNotificationUri(getContext().getContentResolver(), uri);
  /// return c;</pre>
  ///@param uri The URI to query. This will be the full URI sent by the client;
  ///      if the client is requesting a specific record, the URI will end in a record number
  ///      that the implementation should parse and add to a WHERE or HAVING clause, specifying
  ///      that _id value.
  /// This value must never be {@code null}.
  ///@param projection The list of columns to put into the cursor. If
  ///      {@code null} all columns are included.
  /// This value may be {@code null}.
  ///@param selection A selection criteria to apply when filtering rows.
  ///      If {@code null} then all rows are included.
  /// This value may be {@code null}.
  ///@param selectionArgs You may include ?s in selection, which will be replaced by
  ///      the values from selectionArgs, in order that they appear in the selection.
  ///      The values will be bound as Strings.
  /// This value may be {@code null}.
  ///@param sortOrder How the rows in the cursor should be sorted.
  ///      If {@code null} then the provider is free to define the sort order.
  /// This value may be {@code null}.
  ///@return a Cursor or {@code null}.
  jni.JniObject query(
      jni.JniObject uri,
      jni.JniObject projection,
      jni.JniString selection,
      jni.JniObject selectionArgs,
      jni.JniString sortOrder) {
    final result__ = jni.JniObject.fromRef(_query(
        reference,
        uri.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        sortOrder.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _query1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_query1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implement this to handle query requests from clients with support for cancellation.
  ///
  /// Apps targeting android.os.Build.VERSION_CODES\#O or higher should override
  /// \#query(Uri, String[], Bundle, CancellationSignal) instead of this method.
  ///
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///
  /// Example client call:
  /// <pre>// Request a specific record.
  /// Cursor managedCursor = managedQuery(
  ///     ContentUris.withAppendedId(Contacts.People.CONTENT_URI, 2),
  ///     projection,    // Which columns to return.
  ///     null,          // WHERE clause.
  ///     null,          // WHERE clause value substitution
  ///     People.NAME + " ASC");   // Sort order.</pre>
  /// Example implementation:
  /// <pre>// SQLiteQueryBuilder is a helper class that creates the
  /// // proper SQL syntax for us.
  /// SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder();
  ///
  /// // Set the table we're querying.
  /// qBuilder.setTables(DATABASE_TABLE_NAME);
  ///
  /// // If the query ends in a specific record number, we're
  /// // being asked for a specific record, so set the
  /// // WHERE clause in our query.
  /// if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){
  /// qBuilder.appendWhere("_id=" + uri.getPathLeafId());
  /// }
  ///
  /// // Make the query.
  /// Cursor c = qBuilder.query(mDb,
  ///     projection,
  ///     selection,
  ///     selectionArgs,
  ///     groupBy,
  ///     having,
  ///     sortOrder);
  /// c.setNotificationUri(getContext().getContentResolver(), uri);
  /// return c;</pre>
  ///
  /// If you implement this method then you must also implement the version of
  /// \#query(Uri, String[], String, String[], String) that does not take a cancellation
  /// signal to ensure correct operation on older versions of the Android Framework in
  /// which the cancellation signal overload was not available.
  ///@param uri The URI to query. This will be the full URI sent by the client;
  ///      if the client is requesting a specific record, the URI will end in a record number
  ///      that the implementation should parse and add to a WHERE or HAVING clause, specifying
  ///      that _id value.
  /// This value must never be {@code null}.
  ///@param projection The list of columns to put into the cursor. If
  ///      {@code null} all columns are included.
  /// This value may be {@code null}.
  ///@param selection A selection criteria to apply when filtering rows.
  ///      If {@code null} then all rows are included.
  /// This value may be {@code null}.
  ///@param selectionArgs You may include ?s in selection, which will be replaced by
  ///      the values from selectionArgs, in order that they appear in the selection.
  ///      The values will be bound as Strings.
  /// This value may be {@code null}.
  ///@param sortOrder How the rows in the cursor should be sorted.
  ///      If {@code null} then the provider is free to define the sort order.
  /// This value may be {@code null}.
  ///@param cancellationSignal A signal to cancel the operation in progress, or {@code null} if none.
  /// If the operation is canceled, then android.os.OperationCanceledException will be thrown
  /// when the query is executed.
  /// This value may be {@code null}.
  ///@return a Cursor or {@code null}.
  jni.JniObject query1(
      jni.JniObject uri,
      jni.JniObject projection,
      jni.JniString selection,
      jni.JniObject selectionArgs,
      jni.JniString sortOrder,
      os_.CancellationSignal cancellationSignal) {
    final result__ = jni.JniObject.fromRef(_query1(
        reference,
        uri.reference,
        projection.reference,
        selection.reference,
        selectionArgs.reference,
        sortOrder.reference,
        cancellationSignal.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _query2 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_query2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.database.Cursor query(android.net.Uri uri, java.lang.String[] projection, android.os.Bundle queryArgs, android.os.CancellationSignal cancellationSignal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implement this to handle query requests where the arguments are packed into a Bundle.
  /// Arguments may include traditional SQL style query arguments. When present these
  /// should be handled  according to the contract established in
  /// {@link \#query(Uri, String[], String, String[], String, CancellationSignal).
  ///
  /// Traditional SQL arguments can be found in the bundle using the following keys:
  /// <li>ContentResolver\#QUERY_ARG_SQL_SELECTION
  /// <li>ContentResolver\#QUERY_ARG_SQL_SELECTION_ARGS
  /// <li>ContentResolver\#QUERY_ARG_SQL_SORT_ORDER
  ///
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///
  ///
  /// Example client call:
  /// <pre>// Request 20 records starting at row index 30.
  ///  Bundle queryArgs = new Bundle();
  ///  queryArgs.putInt(ContentResolver.QUERY_ARG_OFFSET, 30);
  ///  queryArgs.putInt(ContentResolver.QUERY_ARG_LIMIT, 20);
  ///
  ///  Cursor cursor = getContentResolver().query(
  ///           contentUri,    // Content Uri is specific to individual content providers.
  ///           projection,    // String[] describing which columns to return.
  ///           queryArgs,     // Query arguments.
  ///           null);         // Cancellation signal.</pre>
  ///
  /// Example implementation:
  /// <pre>
  ///
  ///   int recordsetSize = 0x1000;  // Actual value is implementation specific.
  ///   queryArgs = queryArgs != null ? queryArgs : Bundle.EMPTY;  // ensure queryArgs is non-null
  ///
  ///   int offset = queryArgs.getInt(ContentResolver.QUERY_ARG_OFFSET, 0);
  ///   int limit = queryArgs.getInt(ContentResolver.QUERY_ARG_LIMIT, Integer.MIN_VALUE);
  ///
  ///   MatrixCursor c = new MatrixCursor(PROJECTION, limit);
  ///
  ///   // Calculate the number of items to include in the cursor.
  ///   int numItems = MathUtils.constrain(recordsetSize - offset, 0, limit);
  ///
  ///   // Build the paged result set....
  ///   for (int i = offset; i < offset + numItems; i++) {
  ///       // populate row from your data.
  ///   }
  ///
  ///   Bundle extras = new Bundle();
  ///   c.setExtras(extras);
  ///
  ///   // Any QUERY_ARG_* key may be included if honored.
  ///   // In an actual implementation, include only keys that are both present in queryArgs
  ///   // and reflected in the Cursor output. For example, if QUERY_ARG_OFFSET were included
  ///   // in queryArgs, but was ignored because it contained an invalid value (like \u2013273),
  ///   // then QUERY_ARG_OFFSET should be omitted.
  ///   extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, new String[] {
  ///       ContentResolver.QUERY_ARG_OFFSET,
  ///       ContentResolver.QUERY_ARG_LIMIT
  ///   });
  ///
  ///   extras.putInt(ContentResolver.EXTRA_TOTAL_COUNT, recordsetSize);
  ///
  ///   cursor.setNotificationUri(getContext().getContentResolver(), uri);
  ///
  ///   return cursor;</pre>
  ///
  ///@see \#query(Uri, String[], String, String[], String, CancellationSignal) for
  ///     implementation details.
  ///@param uri The URI to query. This will be the full URI sent by the client.
  ///@param projection The list of columns to put into the cursor.
  ///            If {@code null} provide a default set of columns.
  ///@param queryArgs A Bundle containing all additional information necessary for the query.
  ///            Values in the Bundle may include SQL style arguments.
  ///@param cancellationSignal A signal to cancel the operation in progress,
  ///            or {@code null}.
  ///@return a Cursor or {@code null}.
  ///@param uri This value must never be {@code null}.
  ///@param projection This value may be {@code null}.
  ///@param queryArgs This value may be {@code null}.
  ///@param cancellationSignal This value may be {@code null}.
  jni.JniObject query2(jni.JniObject uri, jni.JniObject projection,
      os_.Bundle queryArgs, os_.CancellationSignal cancellationSignal) {
    final result__ = jni.JniObject.fromRef(_query2(
        reference,
        uri.reference,
        projection.reference,
        queryArgs.reference,
        cancellationSignal.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getType = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_getType")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getType(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implement this to handle requests for the MIME type of the data at the
  /// given URI.  The returned MIME type should start with
  /// <code>vnd.android.cursor.item</code> for a single record,
  /// or <code>vnd.android.cursor.dir/</code> for multiple items.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///
  /// Note that there are no permissions needed for an application to
  /// access this information; if your content provider requires read and/or
  /// write permissions, or is not exported, all applications can still call
  /// this method regardless of their access permissions.  This allows them
  /// to retrieve the MIME type for a URI when dispatching intents.
  ///@param uri the URI to query.
  /// This value must never be {@code null}.
  ///@return a MIME type string, or {@code null} if there is no type.
  jni.JniString getType(jni.JniObject uri) {
    final result__ = jni.JniString.fromRef(_getType(reference, uri.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _canonicalize = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_canonicalize")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri canonicalize(android.net.Uri url)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implement this to support canonicalization of URIs that refer to your
  /// content provider.  A canonical URI is one that can be transported across
  /// devices, backup/restore, and other contexts, and still be able to refer
  /// to the same data item.  Typically this is implemented by adding query
  /// params to the URI allowing the content provider to verify that an incoming
  /// canonical URI references the same data as it was originally intended for and,
  /// if it doesn't, to find that data (if it exists) in the current environment.
  ///
  /// For example, if the content provider holds people and a normal URI in it
  /// is created with a row index into that people database, the cananical representation
  /// may have an additional query param at the end which specifies the name of the
  /// person it is intended for.  Later calls into the provider with that URI will look
  /// up the row of that URI's base index and, if it doesn't match or its entry's
  /// name doesn't match the name in the query param, perform a query on its database
  /// to find the correct row to operate on.
  ///
  ///
  /// If you implement support for canonical URIs, __all__ incoming calls with
  /// URIs (including this one) must perform this verification and recovery of any
  /// canonical URIs they receive.  In addition, you must also implement
  /// \#uncanonicalize to strip the canonicalization of any of these URIs.
  ///
  ///
  /// The default implementation of this method returns null, indicating that
  /// canonical URIs are not supported.
  ///
  ///@param url The Uri to canonicalize.
  ///
  /// This value must never be {@code null}.
  ///@return Return the canonical representation of <var>url</var>, or null if
  /// canonicalization of that Uri is not supported.
  jni.JniObject canonicalize(jni.JniObject url) {
    final result__ =
        jni.JniObject.fromRef(_canonicalize(reference, url.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _uncanonicalize = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_uncanonicalize")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri uncanonicalize(android.net.Uri url)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Remove canonicalization from canonical URIs previously returned by
  /// \#canonicalize.  For example, if your implementation is to add
  /// a query param to canonicalize a URI, this method can simply trip any
  /// query params on the URI.  The default implementation always returns the
  /// same <var>url</var> that was passed in.
  ///@param url The Uri to remove any canonicalization from.
  ///
  /// This value must never be {@code null}.
  ///@return Return the non-canonical representation of <var>url</var>, return
  /// the <var>url</var> as-is if there is nothing to do, or return null if
  /// the data identified by the canonical representation can not be found in
  /// the current environment.
  jni.JniObject uncanonicalize(jni.JniObject url) {
    final result__ =
        jni.JniObject.fromRef(_uncanonicalize(reference, url.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _refresh = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_refresh")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean refresh(android.net.Uri uri, android.os.Bundle args, android.os.CancellationSignal cancellationSignal)
  ///
  /// Implement this to support refresh of content identified by {@code uri}. By default, this
  /// method returns false; providers who wish to implement this should return true to signal the
  /// client that the provider has tried refreshing with its own implementation.
  ///
  /// This allows clients to request an explicit refresh of content identified by {@code uri}.
  ///
  /// Client code should only invoke this method when there is a strong indication (such as a user
  /// initiated pull to refresh gesture) that the content is stale.
  ///
  /// Remember to send ContentResolver\#notifyChange(Uri, android.database.ContentObserver)
  /// notifications when content changes.
  ///@param uri The Uri identifying the data to refresh.
  ///@param args Additional options from the client. The definitions of these are specific to the
  ///            content provider being called.
  /// This value may be {@code null}.
  ///@param cancellationSignal A signal to cancel the operation in progress, or {@code null} if
  ///            none. For example, if you called refresh on a particular uri, you should call
  ///            CancellationSignal\#throwIfCanceled() to check whether the client has
  ///            canceled the refresh request.
  /// This value may be {@code null}.
  ///@return true if the provider actually tried refreshing.
  bool refresh(jni.JniObject uri, os_.Bundle args,
      os_.CancellationSignal cancellationSignal) {
    final result__ = _refresh(reference, uri.reference, args.reference,
            cancellationSignal.reference) !=
        0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _insert = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_insert")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.net.Uri insert(android.net.Uri uri, android.content.ContentValues values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Implement this to handle requests to insert a new row.
  /// As a courtesy, call ContentResolver\#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()
  /// after inserting.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///@param uri The content:// URI of the insertion request. This must not be {@code null}.
  /// This value must never be {@code null}.
  ///@param values A set of column_name/value pairs to add to the database.
  ///     This must not be {@code null}.
  /// This value may be {@code null}.
  ///@return The URI for the newly inserted item.
  jni.JniObject insert(jni.JniObject uri, ContentValues values) {
    final result__ = jni.JniObject.fromRef(
        _insert(reference, uri.reference, values.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _bulkInsert = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_bulkInsert")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int bulkInsert(android.net.Uri uri, android.content.ContentValues[] values)
  ///
  /// Override this to handle requests to insert a set of new rows, or the
  /// default implementation will iterate over the values and call
  /// \#insert on each of them.
  /// As a courtesy, call ContentResolver\#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()
  /// after inserting.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///@param uri The content:// URI of the insertion request.
  /// This value must never be {@code null}.
  ///@param values An array of sets of column_name/value pairs to add to the database.
  ///    This must not be {@code null}.
  /// This value must never be {@code null}.
  ///@return The number of values that were inserted.
  int bulkInsert(jni.JniObject uri, jni.JniObject values) {
    final result__ = _bulkInsert(reference, uri.reference, values.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _delete1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_delete1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int delete(android.net.Uri uri, java.lang.String selection, java.lang.String[] selectionArgs)
  ///
  /// Implement this to handle requests to delete one or more rows.
  /// The implementation should apply the selection clause when performing
  /// deletion, allowing the operation to affect multiple rows in a directory.
  /// As a courtesy, call ContentResolver\#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()
  /// after deleting.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///
  /// The implementation is responsible for parsing out a row ID at the end
  /// of the URI, if a specific row is being deleted. That is, the client would
  /// pass in <code>content://contacts/people/22</code> and the implementation is
  /// responsible for parsing the record number (22) when creating a SQL statement.
  ///@param uri The full URI to query, including a row ID (if a specific record is requested).
  /// This value must never be {@code null}.
  ///@param selection An optional restriction to apply to rows when deleting.
  /// This value may be {@code null}.
  ///@param selectionArgs This value may be {@code null}.
  ///@return The number of rows affected.
  ///@throws SQLException
  int delete1(
      jni.JniObject uri, jni.JniString selection, jni.JniObject selectionArgs) {
    final result__ = _delete1(
        reference, uri.reference, selection.reference, selectionArgs.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _update = jniLookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_update")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int update(android.net.Uri uri, android.content.ContentValues values, java.lang.String selection, java.lang.String[] selectionArgs)
  ///
  /// Implement this to handle requests to update one or more rows.
  /// The implementation should update all rows matching the selection
  /// to set the columns according to the provided values map.
  /// As a courtesy, call ContentResolver\#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()
  /// after updating.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///@param uri The URI to query. This can potentially have a record ID if this
  /// is an update request for a specific record.
  /// This value must never be {@code null}.
  ///@param values A set of column_name/value pairs to update in the database.
  ///     This must not be {@code null}.
  /// This value may be {@code null}.
  ///@param selection An optional filter to match rows to update.
  /// This value may be {@code null}.
  ///@param selectionArgs This value may be {@code null}.
  ///@return the number of rows affected.
  int update(jni.JniObject uri, ContentValues values, jni.JniString selection,
      jni.JniObject selectionArgs) {
    final result__ = _update(reference, uri.reference, values.reference,
        selection.reference, selectionArgs.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openFile = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_openFile")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.ParcelFileDescriptor openFile(android.net.Uri uri, java.lang.String mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Override this to handle requests to open a file blob.
  /// The default implementation always throws FileNotFoundException.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///
  /// This method returns a ParcelFileDescriptor, which is returned directly
  /// to the caller.  This way large data (such as images and documents) can be
  /// returned without copying the content.
  ///
  /// The returned ParcelFileDescriptor is owned by the caller, so it is
  /// their responsibility to close it when done.  That is, the implementation
  /// of this method should create a new ParcelFileDescriptor for each call.
  ///
  /// If opened with the exclusive "r" or "w" modes, the returned
  /// ParcelFileDescriptor can be a pipe or socket pair to enable streaming
  /// of data. Opening with the "rw" or "rwt" modes implies a file on disk that
  /// supports seeking.
  ///
  /// If you need to detect when the returned ParcelFileDescriptor has been
  /// closed, or if the remote process has crashed or encountered some other
  /// error, you can use ParcelFileDescriptor\#open(File, int,
  /// android.os.Handler, android.os.ParcelFileDescriptor.OnCloseListener),
  /// ParcelFileDescriptor\#createReliablePipe(), or
  /// ParcelFileDescriptor\#createReliableSocketPair().
  ///
  /// If you need to return a large file that isn't backed by a real file on
  /// disk, such as a file on a network share or cloud storage service,
  /// consider using
  /// StorageManager\#openProxyFileDescriptor(int, android.os.ProxyFileDescriptorCallback, android.os.Handler)
  /// which will let you to stream the content on-demand.
  ///
  /// <p class="note">For use in Intents, you will want to implement \#getType
  /// to return the appropriate MIME type for the data returned here with
  /// the same URI.  This will allow intent resolution to automatically determine the data MIME
  /// type and select the appropriate matching targets as part of its operation.
  ///
  ///
  /// <p class="note">For better interoperability with other applications, it is recommended
  /// that for any URIs that can be opened, you also support queries on them
  /// containing at least the columns specified by android.provider.OpenableColumns.
  /// You may also want to support other common columns if you have additional meta-data
  /// to supply, such as android.provider.MediaStore.MediaColumns\#DATE_ADDED
  /// in android.provider.MediaStore.MediaColumns.
  ///
  ///@param uri The URI whose file is to be opened.
  /// This value must never be {@code null}.
  ///@param mode Access mode for the file.  May be "r" for read-only access,
  /// "rw" for read and write access, or "rwt" for read and write access
  /// that truncates any existing file.
  ///
  /// This value must never be {@code null}.
  ///@return Returns a new ParcelFileDescriptor which you can use to access
  /// the file.
  ///
  /// This value may be {@code null}.
  ///@throws FileNotFoundException Throws FileNotFoundException if there is
  /// no file associated with the given URI or the mode is invalid.
  ///@throws SecurityException Throws SecurityException if the caller does
  /// not have permission to access the file.
  ///@see \#openAssetFile(Uri, String)
  ///@see \#openFileHelper(Uri, String)
  ///@see \#getType(android.net.Uri)
  ///@see ParcelFileDescriptor\#parseMode(String)
  os_.ParcelFileDescriptor openFile(jni.JniObject uri, jni.JniString mode) {
    final result__ = os_.ParcelFileDescriptor.fromRef(
        _openFile(reference, uri.reference, mode.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openFile1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_openFile1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.ParcelFileDescriptor openFile(android.net.Uri uri, java.lang.String mode, android.os.CancellationSignal signal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Override this to handle requests to open a file blob.
  /// The default implementation always throws FileNotFoundException.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///
  /// This method returns a ParcelFileDescriptor, which is returned directly
  /// to the caller.  This way large data (such as images and documents) can be
  /// returned without copying the content.
  ///
  /// The returned ParcelFileDescriptor is owned by the caller, so it is
  /// their responsibility to close it when done.  That is, the implementation
  /// of this method should create a new ParcelFileDescriptor for each call.
  ///
  /// If opened with the exclusive "r" or "w" modes, the returned
  /// ParcelFileDescriptor can be a pipe or socket pair to enable streaming
  /// of data. Opening with the "rw" or "rwt" modes implies a file on disk that
  /// supports seeking.
  ///
  /// If you need to detect when the returned ParcelFileDescriptor has been
  /// closed, or if the remote process has crashed or encountered some other
  /// error, you can use ParcelFileDescriptor\#open(File, int,
  /// android.os.Handler, android.os.ParcelFileDescriptor.OnCloseListener),
  /// ParcelFileDescriptor\#createReliablePipe(), or
  /// ParcelFileDescriptor\#createReliableSocketPair().
  ///
  /// <p class="note">For use in Intents, you will want to implement \#getType
  /// to return the appropriate MIME type for the data returned here with
  /// the same URI.  This will allow intent resolution to automatically determine the data MIME
  /// type and select the appropriate matching targets as part of its operation.
  ///
  ///
  /// <p class="note">For better interoperability with other applications, it is recommended
  /// that for any URIs that can be opened, you also support queries on them
  /// containing at least the columns specified by android.provider.OpenableColumns.
  /// You may also want to support other common columns if you have additional meta-data
  /// to supply, such as android.provider.MediaStore.MediaColumns\#DATE_ADDED
  /// in android.provider.MediaStore.MediaColumns.
  ///
  ///@param uri The URI whose file is to be opened.
  /// This value must never be {@code null}.
  ///@param mode Access mode for the file. May be "r" for read-only access,
  ///            "w" for write-only access, "rw" for read and write access, or
  ///            "rwt" for read and write access that truncates any existing
  ///            file.
  /// This value must never be {@code null}.
  ///@param signal A signal to cancel the operation in progress, or
  ///            {@code null} if none. For example, if you are downloading a
  ///            file from the network to service a "rw" mode request, you
  ///            should periodically call
  ///            CancellationSignal\#throwIfCanceled() to check whether
  ///            the client has canceled the request and abort the download.
  ///
  /// This value may be {@code null}.
  ///@return Returns a new ParcelFileDescriptor which you can use to access
  /// the file.
  ///@throws FileNotFoundException Throws FileNotFoundException if there is
  /// no file associated with the given URI or the mode is invalid.
  ///@throws SecurityException Throws SecurityException if the caller does
  /// not have permission to access the file.
  ///@see \#openAssetFile(Uri, String)
  ///@see \#openFileHelper(Uri, String)
  ///@see \#getType(android.net.Uri)
  ///@see ParcelFileDescriptor\#parseMode(String)
  os_.ParcelFileDescriptor openFile1(
      jni.JniObject uri, jni.JniString mode, os_.CancellationSignal signal) {
    final result__ = os_.ParcelFileDescriptor.fromRef(
        _openFile1(reference, uri.reference, mode.reference, signal.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openAssetFile = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_openAssetFile")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.AssetFileDescriptor openAssetFile(android.net.Uri uri, java.lang.String mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This is like \#openFile, but can be implemented by providers
  /// that need to be able to return sub-sections of files, often assets
  /// inside of their .apk.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///
  /// If you implement this, your clients must be able to deal with such
  /// file slices, either directly with
  /// ContentResolver\#openAssetFileDescriptor, or by using the higher-level
  /// ContentResolver\#openInputStream ContentResolver.openInputStream
  /// or ContentResolver\#openOutputStream ContentResolver.openOutputStream
  /// methods.
  ///
  /// The returned AssetFileDescriptor can be a pipe or socket pair to enable
  /// streaming of data.
  ///
  /// <p class="note">If you are implementing this to return a full file, you
  /// should create the AssetFileDescriptor with
  /// AssetFileDescriptor\#UNKNOWN_LENGTH to be compatible with
  /// applications that cannot handle sub-sections of files.
  ///
  ///
  /// <p class="note">For use in Intents, you will want to implement \#getType
  /// to return the appropriate MIME type for the data returned here with
  /// the same URI.  This will allow intent resolution to automatically determine the data MIME
  /// type and select the appropriate matching targets as part of its operation.
  ///
  ///
  /// <p class="note">For better interoperability with other applications, it is recommended
  /// that for any URIs that can be opened, you also support queries on them
  /// containing at least the columns specified by android.provider.OpenableColumns.
  ///
  ///@param uri The URI whose file is to be opened.
  /// This value must never be {@code null}.
  ///@param mode Access mode for the file.  May be "r" for read-only access,
  /// "w" for write-only access (erasing whatever data is currently in
  /// the file), "wa" for write-only access to append to any existing data,
  /// "rw" for read and write access on any existing data, and "rwt" for read
  /// and write access that truncates any existing file.
  ///
  /// This value must never be {@code null}.
  ///@return Returns a new AssetFileDescriptor which you can use to access
  /// the file.
  ///
  /// This value may be {@code null}.
  ///@throws FileNotFoundException Throws FileNotFoundException if there is
  /// no file associated with the given URI or the mode is invalid.
  ///@throws SecurityException Throws SecurityException if the caller does
  /// not have permission to access the file.
  ///@see \#openFile(Uri, String)
  ///@see \#openFileHelper(Uri, String)
  ///@see \#getType(android.net.Uri)
  res_.AssetFileDescriptor openAssetFile(
      jni.JniObject uri, jni.JniString mode) {
    final result__ = res_.AssetFileDescriptor.fromRef(
        _openAssetFile(reference, uri.reference, mode.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openAssetFile1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_openAssetFile1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.AssetFileDescriptor openAssetFile(android.net.Uri uri, java.lang.String mode, android.os.CancellationSignal signal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This is like \#openFile, but can be implemented by providers
  /// that need to be able to return sub-sections of files, often assets
  /// inside of their .apk.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///
  /// If you implement this, your clients must be able to deal with such
  /// file slices, either directly with
  /// ContentResolver\#openAssetFileDescriptor, or by using the higher-level
  /// ContentResolver\#openInputStream ContentResolver.openInputStream
  /// or ContentResolver\#openOutputStream ContentResolver.openOutputStream
  /// methods.
  ///
  /// The returned AssetFileDescriptor can be a pipe or socket pair to enable
  /// streaming of data.
  ///
  /// <p class="note">If you are implementing this to return a full file, you
  /// should create the AssetFileDescriptor with
  /// AssetFileDescriptor\#UNKNOWN_LENGTH to be compatible with
  /// applications that cannot handle sub-sections of files.
  ///
  ///
  /// <p class="note">For use in Intents, you will want to implement \#getType
  /// to return the appropriate MIME type for the data returned here with
  /// the same URI.  This will allow intent resolution to automatically determine the data MIME
  /// type and select the appropriate matching targets as part of its operation.
  ///
  ///
  /// <p class="note">For better interoperability with other applications, it is recommended
  /// that for any URIs that can be opened, you also support queries on them
  /// containing at least the columns specified by android.provider.OpenableColumns.
  ///
  ///@param uri The URI whose file is to be opened.
  /// This value must never be {@code null}.
  ///@param mode Access mode for the file.  May be "r" for read-only access,
  /// "w" for write-only access (erasing whatever data is currently in
  /// the file), "wa" for write-only access to append to any existing data,
  /// "rw" for read and write access on any existing data, and "rwt" for read
  /// and write access that truncates any existing file.
  /// This value must never be {@code null}.
  ///@param signal A signal to cancel the operation in progress, or
  ///            {@code null} if none. For example, if you are downloading a
  ///            file from the network to service a "rw" mode request, you
  ///            should periodically call
  ///            CancellationSignal\#throwIfCanceled() to check whether
  ///            the client has canceled the request and abort the download.
  ///
  /// This value may be {@code null}.
  ///@return Returns a new AssetFileDescriptor which you can use to access
  /// the file.
  ///@throws FileNotFoundException Throws FileNotFoundException if there is
  /// no file associated with the given URI or the mode is invalid.
  ///@throws SecurityException Throws SecurityException if the caller does
  /// not have permission to access the file.
  ///@see \#openFile(Uri, String)
  ///@see \#openFileHelper(Uri, String)
  ///@see \#getType(android.net.Uri)
  res_.AssetFileDescriptor openAssetFile1(
      jni.JniObject uri, jni.JniString mode, os_.CancellationSignal signal) {
    final result__ = res_.AssetFileDescriptor.fromRef(_openAssetFile1(
        reference, uri.reference, mode.reference, signal.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openFileHelper = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_openFileHelper")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected final android.os.ParcelFileDescriptor openFileHelper(android.net.Uri uri, java.lang.String mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience for subclasses that wish to implement \#openFile
  /// by looking up a column named "_data" at the given URI.
  ///@param uri The URI to be opened.
  /// This value must never be {@code null}.
  ///@param mode The file mode.  May be "r" for read-only access,
  /// "w" for write-only access (erasing whatever data is currently in
  /// the file), "wa" for write-only access to append to any existing data,
  /// "rw" for read and write access on any existing data, and "rwt" for read
  /// and write access that truncates any existing file.
  ///
  /// This value must never be {@code null}.
  ///@return Returns a new ParcelFileDescriptor that can be used by the
  /// client to access the file.
  ///
  /// This value will never be {@code null}.
  os_.ParcelFileDescriptor openFileHelper(
      jni.JniObject uri, jni.JniString mode) {
    final result__ = os_.ParcelFileDescriptor.fromRef(
        _openFileHelper(reference, uri.reference, mode.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getStreamTypes = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_getStreamTypes")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getStreamTypes(android.net.Uri uri, java.lang.String mimeTypeFilter)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a client to determine the types of data streams that this
  /// content provider supports for the given URI.  The default implementation
  /// returns {@code null}, meaning no types.  If your content provider stores data
  /// of a particular type, return that MIME type if it matches the given
  /// mimeTypeFilter.  If it can perform type conversions, return an array
  /// of all supported MIME types that match mimeTypeFilter.
  ///@param uri The data in the content provider being queried.
  /// This value must never be {@code null}.
  ///@param mimeTypeFilter The type of data the client desires.  May be
  /// a pattern, such as *&\#47;* to retrieve all possible data types.
  /// This value must never be {@code null}.
  ///@return Returns {@code null} if there are no possible data streams for the
  /// given mimeTypeFilter.  Otherwise returns an array of all available
  /// concrete MIME types.
  ///@see \#getType(Uri)
  ///@see \#openTypedAssetFile(Uri, String, Bundle)
  ///@see ClipDescription\#compareMimeTypes(String, String)
  jni.JniObject getStreamTypes(
      jni.JniObject uri, jni.JniString mimeTypeFilter) {
    final result__ = jni.JniObject.fromRef(
        _getStreamTypes(reference, uri.reference, mimeTypeFilter.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openTypedAssetFile = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_openTypedAssetFile")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.AssetFileDescriptor openTypedAssetFile(android.net.Uri uri, java.lang.String mimeTypeFilter, android.os.Bundle opts)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a client to open a read-only stream containing data of a
  /// particular MIME type.  This is like \#openAssetFile(Uri, String),
  /// except the file can only be read-only and the content provider may
  /// perform data conversions to generate data of the desired type.
  ///
  /// The default implementation compares the given mimeType against the
  /// result of \#getType(Uri) and, if they match, simply calls
  /// \#openAssetFile(Uri, String).
  ///
  /// See ClipData for examples of the use and implementation
  /// of this method.
  ///
  /// The returned AssetFileDescriptor can be a pipe or socket pair to enable
  /// streaming of data.
  ///
  /// <p class="note">For better interoperability with other applications, it is recommended
  /// that for any URIs that can be opened, you also support queries on them
  /// containing at least the columns specified by android.provider.OpenableColumns.
  /// You may also want to support other common columns if you have additional meta-data
  /// to supply, such as android.provider.MediaStore.MediaColumns\#DATE_ADDED
  /// in android.provider.MediaStore.MediaColumns.
  ///
  ///@param uri The data in the content provider being queried.
  /// This value must never be {@code null}.
  ///@param mimeTypeFilter The type of data the client desires.  May be
  /// a pattern, such as *&\#47;*, if the caller does not have specific type
  /// requirements; in this case the content provider will pick its best
  /// type matching the pattern.
  /// This value must never be {@code null}.
  ///@param opts Additional options from the client.  The definitions of
  /// these are specific to the content provider being called.
  ///
  /// This value may be {@code null}.
  ///@return Returns a new AssetFileDescriptor from which the client can
  /// read data of the desired type.
  ///
  /// This value may be {@code null}.
  ///@throws FileNotFoundException Throws FileNotFoundException if there is
  /// no file associated with the given URI or the mode is invalid.
  ///@throws SecurityException Throws SecurityException if the caller does
  /// not have permission to access the data.
  ///@throws IllegalArgumentException Throws IllegalArgumentException if the
  /// content provider does not support the requested MIME type.
  ///@see \#getStreamTypes(Uri, String)
  ///@see \#openAssetFile(Uri, String)
  ///@see ClipDescription\#compareMimeTypes(String, String)
  res_.AssetFileDescriptor openTypedAssetFile(
      jni.JniObject uri, jni.JniString mimeTypeFilter, os_.Bundle opts) {
    final result__ = res_.AssetFileDescriptor.fromRef(_openTypedAssetFile(
        reference, uri.reference, mimeTypeFilter.reference, opts.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _openTypedAssetFile1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_openTypedAssetFile1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.AssetFileDescriptor openTypedAssetFile(android.net.Uri uri, java.lang.String mimeTypeFilter, android.os.Bundle opts, android.os.CancellationSignal signal)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by a client to open a read-only stream containing data of a
  /// particular MIME type.  This is like \#openAssetFile(Uri, String),
  /// except the file can only be read-only and the content provider may
  /// perform data conversions to generate data of the desired type.
  ///
  /// The default implementation compares the given mimeType against the
  /// result of \#getType(Uri) and, if they match, simply calls
  /// \#openAssetFile(Uri, String).
  ///
  /// See ClipData for examples of the use and implementation
  /// of this method.
  ///
  /// The returned AssetFileDescriptor can be a pipe or socket pair to enable
  /// streaming of data.
  ///
  /// <p class="note">For better interoperability with other applications, it is recommended
  /// that for any URIs that can be opened, you also support queries on them
  /// containing at least the columns specified by android.provider.OpenableColumns.
  /// You may also want to support other common columns if you have additional meta-data
  /// to supply, such as android.provider.MediaStore.MediaColumns\#DATE_ADDED
  /// in android.provider.MediaStore.MediaColumns.
  ///
  ///@param uri The data in the content provider being queried.
  /// This value must never be {@code null}.
  ///@param mimeTypeFilter The type of data the client desires.  May be
  /// a pattern, such as *&\#47;*, if the caller does not have specific type
  /// requirements; in this case the content provider will pick its best
  /// type matching the pattern.
  /// This value must never be {@code null}.
  ///@param opts Additional options from the client.  The definitions of
  /// these are specific to the content provider being called.
  /// This value may be {@code null}.
  ///@param signal A signal to cancel the operation in progress, or
  ///            {@code null} if none. For example, if you are downloading a
  ///            file from the network to service a "rw" mode request, you
  ///            should periodically call
  ///            CancellationSignal\#throwIfCanceled() to check whether
  ///            the client has canceled the request and abort the download.
  ///
  /// This value may be {@code null}.
  ///@return Returns a new AssetFileDescriptor from which the client can
  /// read data of the desired type.
  ///@throws FileNotFoundException Throws FileNotFoundException if there is
  /// no file associated with the given URI or the mode is invalid.
  ///@throws SecurityException Throws SecurityException if the caller does
  /// not have permission to access the data.
  ///@throws IllegalArgumentException Throws IllegalArgumentException if the
  /// content provider does not support the requested MIME type.
  ///@see \#getStreamTypes(Uri, String)
  ///@see \#openAssetFile(Uri, String)
  ///@see ClipDescription\#compareMimeTypes(String, String)
  res_.AssetFileDescriptor openTypedAssetFile1(
      jni.JniObject uri,
      jni.JniString mimeTypeFilter,
      os_.Bundle opts,
      os_.CancellationSignal signal) {
    final result__ = res_.AssetFileDescriptor.fromRef(_openTypedAssetFile1(
        reference,
        uri.reference,
        mimeTypeFilter.reference,
        opts.reference,
        signal.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isTemporary =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentProvider_isTemporary")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected boolean isTemporary()
  ///
  /// Returns true if this instance is a temporary content provider.
  ///@return true if this instance is a temporary content provider
  bool isTemporary() {
    final result__ = _isTemporary(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _attachInfo = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_attachInfo")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void attachInfo(android.content.Context context, android.content.pm.ProviderInfo info)
  ///
  /// After being instantiated, this is called to tell the content provider
  /// about itself.
  ///@param context The context this provider is running in
  ///@param info Registered information about this content provider
  void attachInfo(Context context, pm_.ProviderInfo info) {
    final result__ = _attachInfo(reference, context.reference, info.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _applyBatch = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_applyBatch")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ContentProviderResult[] applyBatch(java.util.ArrayList<android.content.ContentProviderOperation> operations)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Override this to handle requests to perform a batch of operations, or the
  /// default implementation will iterate over the operations and call
  /// ContentProviderOperation\#apply on each of them.
  /// If all calls to ContentProviderOperation\#apply succeed
  /// then a ContentProviderResult array with as many
  /// elements as there were operations will be returned.  If any of the calls
  /// fail, it is up to the implementation how many of the others take effect.
  /// This method can be called from multiple threads, as described in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html\#Threads">Processes
  /// and Threads</a>.
  ///@param operations the operations to apply
  /// This value must never be {@code null}.
  ///@return the results of the applications
  /// This value will never be {@code null}.
  ///@throws OperationApplicationException thrown if any operation fails.
  ///@see ContentProviderOperation\#apply
  jni.JniObject applyBatch(jni.JniObject operations) {
    final result__ =
        jni.JniObject.fromRef(_applyBatch(reference, operations.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _call = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_call")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle call(java.lang.String method, java.lang.String arg, android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Call a provider-defined method.  This can be used to implement
  /// interfaces that are cheaper and/or unnatural for a table-like
  /// model.
  ///
  /// <p class="note"><strong>WARNING:</strong> The framework does no permission checking
  /// on this entry into the content provider besides the basic ability for the application
  /// to get access to the provider at all.  For example, it has no idea whether the call
  /// being executed may read or write data in the provider, so can't enforce those
  /// individual permissions.  Any implementation of this method <strong>must</strong>
  /// do its own permission checks on incoming calls to make sure they are allowed.
  ///
  ///@param method method name to call.  Opaque to framework, but should not be {@code null}.
  /// This value must never be {@code null}.
  ///@param arg provider-defined String argument.  May be {@code null}.
  /// This value may be {@code null}.
  ///@param extras provider-defined Bundle argument.  May be {@code null}.
  /// This value may be {@code null}.
  ///@return provider-defined return value.  May be {@code null}, which is also
  ///   the default for providers which don't implement any call methods.
  os_.Bundle call(jni.JniString method, jni.JniString arg, os_.Bundle extras) {
    final result__ = os_.Bundle.fromRef(
        _call(reference, method.reference, arg.reference, extras.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _shutdown =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentProvider_shutdown")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void shutdown()
  ///
  /// Implement this to shut down the ContentProvider instance. You can then
  /// invoke this method in unit tests.
  ///
  ///
  /// Android normally handles ContentProvider startup and shutdown
  /// automatically. You do not need to start up or shut down a
  /// ContentProvider. When you invoke a test method on a ContentProvider,
  /// however, a ContentProvider instance is started and keeps running after
  /// the test finishes, even if a succeeding test instantiates another
  /// ContentProvider. A conflict develops because the two instances are
  /// usually running against the same underlying data source (for example, an
  /// sqlite database).
  ///
  ///
  ///
  /// Implementing shutDown() avoids this conflict by providing a way to
  /// terminate the ContentProvider. This method can also prevent memory leaks
  /// from multiple instantiations of the ContentProvider, and it can ensure
  /// unit test isolation by allowing you to completely clean up the test
  /// fixture before moving on to the next test.
  ///
  ///
  void shutdown() {
    final result__ = _shutdown(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _dump = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProvider_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  ///
  /// Print the Provider's state into the given stream.  This gets invoked if
  /// you run "adb shell dumpsys activity provider &lt;provider_component_name&gt;".
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer The PrintWriter to which you should dump your state.  This will be
  /// closed for you after you return.
  ///@param args additional arguments to the dump request.
  void dump(jni.JniObject fd, jni.JniObject writer, jni.JniObject args) {
    final result__ =
        _dump(reference, fd.reference, writer.reference, args.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.ContentProvider$PipeDataWriter
///
/// Interface to write a stream of data to a pipe.  Use with
/// ContentProvider\#openPipeHelper.
class ContentProvider_PipeDataWriter extends jni.JniObject {
  ContentProvider_PipeDataWriter.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);
}

/// from: android.content.ContentValues
///
/// This class is used to store a set of values that the ContentResolver
/// can process.
class ContentValues extends jni.JniObject {
  ContentValues.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_ContentValues_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.ContentValues> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  /// from: static public final java.lang.String TAG
  static const TAG = "ContentValues";

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_ContentValues_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ///
  /// Creates an empty set of values using the default initial size
  ContentValues() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _ctor1 =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int32)>>(
              "android_content_ContentValues_ctor1")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: public void <init>(int size)
  ///
  /// Creates an empty set of values using the given initial size
  ///@param size the initial size of the set of values
  ContentValues.ctor1(int size) : super.fromRef(_ctor1(size)) {
    jni.Jni.env.checkException();
  }

  static final _ctor2 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentValues_ctor2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.ContentValues from)
  ///
  /// Creates a set of values copied from the given set
  ///@param from the values to copy
  ContentValues.ctor2(ContentValues from)
      : super.fromRef(_ctor2(from.reference)) {
    jni.Jni.env.checkException();
  }

  static final _equals1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentValues_equals1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(jni.JniObject object) {
    final result__ = _equals1(reference, object.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _hashCode1 =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentValues_hashCode1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    final result__ = _hashCode1(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _put = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_ContentValues_put")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void put(java.lang.String key, java.lang.String value)
  ///
  /// Adds a value to the set.
  ///@param key the name of the value to put
  ///@param value the data for the value to put
  void put(jni.JniString key, jni.JniString value) {
    final result__ = _put(reference, key.reference, value.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putAll = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentValues_putAll")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void putAll(android.content.ContentValues other)
  ///
  /// Adds all values from the passed in ContentValues.
  ///@param other the ContentValues from which to copy
  void putAll(ContentValues other) {
    final result__ = _putAll(reference, other.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _put1 = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_ContentValues_put1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void put(java.lang.String key, java.lang.Byte value)
  ///
  /// Adds a value to the set.
  ///@param key the name of the value to put
  ///@param value the data for the value to put
  void put1(jni.JniString key, jni.JniObject value) {
    final result__ = _put1(reference, key.reference, value.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _put2 = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_ContentValues_put2")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void put(java.lang.String key, java.lang.Short value)
  ///
  /// Adds a value to the set.
  ///@param key the name of the value to put
  ///@param value the data for the value to put
  void put2(jni.JniString key, jni.JniObject value) {
    final result__ = _put2(reference, key.reference, value.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _put3 = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_ContentValues_put3")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void put(java.lang.String key, java.lang.Integer value)
  ///
  /// Adds a value to the set.
  ///@param key the name of the value to put
  ///@param value the data for the value to put
  void put3(jni.JniString key, jni.JniObject value) {
    final result__ = _put3(reference, key.reference, value.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _put4 = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_ContentValues_put4")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void put(java.lang.String key, java.lang.Long value)
  ///
  /// Adds a value to the set.
  ///@param key the name of the value to put
  ///@param value the data for the value to put
  void put4(jni.JniString key, jni.JniObject value) {
    final result__ = _put4(reference, key.reference, value.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _put5 = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_ContentValues_put5")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void put(java.lang.String key, java.lang.Float value)
  ///
  /// Adds a value to the set.
  ///@param key the name of the value to put
  ///@param value the data for the value to put
  void put5(jni.JniString key, jni.JniObject value) {
    final result__ = _put5(reference, key.reference, value.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _put6 = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_ContentValues_put6")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void put(java.lang.String key, java.lang.Double value)
  ///
  /// Adds a value to the set.
  ///@param key the name of the value to put
  ///@param value the data for the value to put
  void put6(jni.JniString key, jni.JniObject value) {
    final result__ = _put6(reference, key.reference, value.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _put7 = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_ContentValues_put7")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void put(java.lang.String key, java.lang.Boolean value)
  ///
  /// Adds a value to the set.
  ///@param key the name of the value to put
  ///@param value the data for the value to put
  void put7(jni.JniString key, jni.JniObject value) {
    final result__ = _put7(reference, key.reference, value.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _put8 = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_ContentValues_put8")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void put(java.lang.String key, byte[] value)
  ///
  /// Adds a value to the set.
  ///@param key the name of the value to put
  ///@param value the data for the value to put
  void put8(jni.JniString key, jni.JniObject value) {
    final result__ = _put8(reference, key.reference, value.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _putNull = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentValues_putNull")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void putNull(java.lang.String key)
  ///
  /// Adds a null value to the set.
  ///@param key the name of the value to make null
  void putNull(jni.JniString key) {
    final result__ = _putNull(reference, key.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _size =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentValues_size")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int size()
  ///
  /// Returns the number of values.
  ///@return the number of values
  int size() {
    final result__ = _size(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _remove = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentValues_remove")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void remove(java.lang.String key)
  ///
  /// Remove a single value.
  ///@param key the name of the value to remove
  void remove(jni.JniString key) {
    final result__ = _remove(reference, key.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _clear =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentValues_clear")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void clear()
  ///
  /// Removes all values.
  void clear() {
    final result__ = _clear(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _containsKey = jniLookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentValues_containsKey")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean containsKey(java.lang.String key)
  ///
  /// Returns true if this object has the named value.
  ///@param key the value to check for
  ///@return {@code true} if the value is present, {@code false} otherwise
  bool containsKey(jni.JniString key) {
    final result__ = _containsKey(reference, key.reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _get0 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_ContentValues_get0")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object get(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a value. Valid value types are String, Boolean,
  /// Number, and {@code byte[]} implementations.
  ///@param key the value to get
  ///@return the data for the value, or {@code null} if the value is missing or if {@code null}
  ///         was previously added with the given {@code key}
  jni.JniObject get0(jni.JniString key) {
    final result__ = jni.JniObject.fromRef(_get0(reference, key.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getAsString = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentValues_getAsString")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getAsString(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a value and converts it to a String.
  ///@param key the value to get
  ///@return the String for the value
  jni.JniString getAsString(jni.JniString key) {
    final result__ =
        jni.JniString.fromRef(_getAsString(reference, key.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getAsLong = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentValues_getAsLong")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Long getAsLong(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a value and converts it to a Long.
  ///@param key the value to get
  ///@return the Long value, or {@code null} if the value is missing or cannot be converted
  jni.JniObject getAsLong(jni.JniString key) {
    final result__ =
        jni.JniObject.fromRef(_getAsLong(reference, key.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getAsInteger = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentValues_getAsInteger")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Integer getAsInteger(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a value and converts it to an Integer.
  ///@param key the value to get
  ///@return the Integer value, or {@code null} if the value is missing or cannot be converted
  jni.JniObject getAsInteger(jni.JniString key) {
    final result__ =
        jni.JniObject.fromRef(_getAsInteger(reference, key.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getAsShort = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentValues_getAsShort")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Short getAsShort(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a value and converts it to a Short.
  ///@param key the value to get
  ///@return the Short value, or {@code null} if the value is missing or cannot be converted
  jni.JniObject getAsShort(jni.JniString key) {
    final result__ =
        jni.JniObject.fromRef(_getAsShort(reference, key.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getAsByte = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentValues_getAsByte")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Byte getAsByte(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a value and converts it to a Byte.
  ///@param key the value to get
  ///@return the Byte value, or {@code null} if the value is missing or cannot be converted
  jni.JniObject getAsByte(jni.JniString key) {
    final result__ =
        jni.JniObject.fromRef(_getAsByte(reference, key.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getAsDouble = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentValues_getAsDouble")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Double getAsDouble(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a value and converts it to a Double.
  ///@param key the value to get
  ///@return the Double value, or {@code null} if the value is missing or cannot be converted
  jni.JniObject getAsDouble(jni.JniString key) {
    final result__ =
        jni.JniObject.fromRef(_getAsDouble(reference, key.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getAsFloat = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentValues_getAsFloat")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Float getAsFloat(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a value and converts it to a Float.
  ///@param key the value to get
  ///@return the Float value, or {@code null} if the value is missing or cannot be converted
  jni.JniObject getAsFloat(jni.JniString key) {
    final result__ =
        jni.JniObject.fromRef(_getAsFloat(reference, key.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getAsBoolean = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentValues_getAsBoolean")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Boolean getAsBoolean(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a value and converts it to a Boolean.
  ///@param key the value to get
  ///@return the Boolean value, or {@code null} if the value is missing or cannot be converted
  jni.JniObject getAsBoolean(jni.JniString key) {
    final result__ =
        jni.JniObject.fromRef(_getAsBoolean(reference, key.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getAsByteArray = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentValues_getAsByteArray")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public byte[] getAsByteArray(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a value that is a byte array. Note that this method will not convert
  /// any other types to byte arrays.
  ///@param key the value to get
  ///@return the {@code byte[]} value, or {@code null} is the value is missing or not a
  ///         {@code byte[]}
  jni.JniObject getAsByteArray(jni.JniString key) {
    final result__ =
        jni.JniObject.fromRef(_getAsByteArray(reference, key.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _valueSet = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentValues_valueSet")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Set<java.util.Map.Entry<java.lang.String,java.lang.Object>> valueSet()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a set of all of the keys and values
  ///@return a set of all of the keys and values
  jni.JniObject valueSet() {
    final result__ = jni.JniObject.fromRef(_valueSet(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _keySet = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentValues_keySet")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Set<java.lang.String> keySet()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a set of all of the keys
  ///@return a set of all of the keys
  jni.JniObject keySet() {
    final result__ = jni.JniObject.fromRef(_keySet(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentValues_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_ContentValues_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  void writeToParcel(os_.Parcel parcel, int flags) {
    final result__ = _writeToParcel(reference, parcel.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentValues_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a string containing a concise, human-readable description of this object.
  ///@return a printable representation of this object.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.Loader
///
/// A class that performs asynchronous loading of data. While Loaders are active
/// they should monitor the source of their data and deliver new results when the contents
/// change.  See android.app.LoaderManager for more detail.
///
/// __Note on threading:__ Clients of loaders should as a rule perform
/// any calls on to a Loader from the main thread of their process (that is,
/// the thread the Activity callbacks and other things occur on).  Subclasses
/// of Loader (such as AsyncTaskLoader) will often perform their work
/// in a separate thread, but when delivering their results this too should
/// be done on the main thread.
///
///
/// Subclasses generally must implement at least \#onStartLoading(),
/// \#onStopLoading(), \#onForceLoad(), and \#onReset().
///
///
/// Most implementations should not derive directly from this class, but
/// instead inherit from AsyncTaskLoader.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using loaders, read the
/// <a href="{@docRoot}guide/components/loaders.html">Loaders</a> developer guide.
///
/// </div>
///@param <D> The result returned when the load is complete
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.content.Loader
class Loader extends jni.JniObject {
  Loader.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Loader_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  ///
  /// Stores away the application context associated with context.
  /// Since Loaders can be used across multiple activities it's dangerous to
  /// store the context directly; always use \#getContext() to retrieve
  /// the Loader's Context, don't use the constructor argument directly.
  /// The Context returned by \#getContext is safe to use across
  /// Activity instances.
  ///@param context used to retrieve the application context.
  Loader(Context context) : super.fromRef(_ctor(context.reference)) {
    jni.Jni.env.checkException();
  }

  static final _deliverCancellation =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_deliverCancellation")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void deliverCancellation()
  ///
  /// Informs the registered OnLoadCanceledListener that the load has been canceled.
  /// Should only be called by subclasses.
  ///
  /// Must be called from the process's main thread.
  void deliverCancellation() {
    final result__ = _deliverCancellation(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getContext = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Loader_getContext")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return an application context retrieved from the Context passed to the constructor.
  Context getContext() {
    final result__ = Context.fromRef(_getContext(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getId =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_getId")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getId()
  ///
  /// @return the ID of this loader
  int getId() {
    final result__ = _getId(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _registerListener = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_Loader_registerListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerListener(int id, android.content.Loader.OnLoadCompleteListener<D> listener)
  ///
  /// Registers a class that will receive callbacks when a load is complete.
  /// The callback will be called on the process's main thread so it's safe to
  /// pass the results to widgets.
  ///
  /// Must be called from the process's main thread.
  void registerListener(int id, Loader_OnLoadCompleteListener listener) {
    final result__ = _registerListener(reference, id, listener.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _unregisterListener = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Loader_unregisterListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterListener(android.content.Loader.OnLoadCompleteListener<D> listener)
  ///
  /// Remove a listener that was previously added with \#registerListener.
  ///
  /// Must be called from the process's main thread.
  void unregisterListener(Loader_OnLoadCompleteListener listener) {
    final result__ = _unregisterListener(reference, listener.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _registerOnLoadCanceledListener = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Loader_registerOnLoadCanceledListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerOnLoadCanceledListener(android.content.Loader.OnLoadCanceledListener<D> listener)
  ///
  /// Registers a listener that will receive callbacks when a load is canceled.
  /// The callback will be called on the process's main thread so it's safe to
  /// pass the results to widgets.
  ///
  /// Must be called from the process's main thread.
  ///@param listener The listener to register.
  void registerOnLoadCanceledListener(Loader_OnLoadCanceledListener listener) {
    final result__ =
        _registerOnLoadCanceledListener(reference, listener.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _unregisterOnLoadCanceledListener = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Loader_unregisterOnLoadCanceledListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterOnLoadCanceledListener(android.content.Loader.OnLoadCanceledListener<D> listener)
  ///
  /// Unregisters a listener that was previously added with
  /// \#registerOnLoadCanceledListener.
  ///
  /// Must be called from the process's main thread.
  ///@param listener The listener to unregister.
  void unregisterOnLoadCanceledListener(
      Loader_OnLoadCanceledListener listener) {
    final result__ =
        _unregisterOnLoadCanceledListener(reference, listener.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isStarted =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_isStarted")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isStarted()
  ///
  /// Return whether this load has been started.  That is, its \#startLoading()
  /// has been called and no calls to \#stopLoading() or
  /// \#reset() have yet been made.
  bool isStarted() {
    final result__ = _isStarted(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isAbandoned =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_isAbandoned")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isAbandoned()
  ///
  /// Return whether this loader has been abandoned.  In this state, the
  /// loader _must not_ report any new data, and _must_ keep
  /// its last reported data valid until it is finally reset.
  bool isAbandoned() {
    final result__ = _isAbandoned(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isReset =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_isReset")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isReset()
  ///
  /// Return whether this load has been reset.  That is, either the loader
  /// has not yet been started for the first time, or its \#reset()
  /// has been called.
  bool isReset() {
    final result__ = _isReset(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _startLoading =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_startLoading")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final void startLoading()
  ///
  /// This function will normally be called for you automatically by
  /// android.app.LoaderManager when the associated fragment/activity
  /// is being started.  When using a Loader with android.app.LoaderManager,
  /// you _must not_ call this method yourself, or you will conflict
  /// with its management of the Loader.
  ///
  /// Starts an asynchronous load of the Loader's data. When the result
  /// is ready the callbacks will be called on the process's main thread.
  /// If a previous load has been completed and is still valid
  /// the result may be passed to the callbacks immediately.
  /// The loader will monitor the source of
  /// the data set and may deliver future callbacks if the source changes.
  /// Calling \#stopLoading will stop the delivery of callbacks.
  ///
  /// This updates the Loader's internal state so that
  /// \#isStarted() and \#isReset() will return the correct
  /// values, and then calls the implementation's \#onStartLoading().
  ///
  /// Must be called from the process's main thread.
  void startLoading() {
    final result__ = _startLoading(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onStartLoading =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_onStartLoading")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStartLoading()
  ///
  /// Subclasses must implement this to take care of loading their data,
  /// as per \#startLoading().  This is not called by clients directly,
  /// but as a result of a call to \#startLoading().
  void onStartLoading() {
    final result__ = _onStartLoading(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _cancelLoad =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_cancelLoad")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean cancelLoad()
  ///
  /// Attempt to cancel the current load task.
  /// Must be called on the main thread of the process.
  ///
  /// Cancellation is not an immediate operation, since the load is performed
  /// in a background thread.  If there is currently a load in progress, this
  /// method requests that the load be canceled, and notes this is the case;
  /// once the background thread has completed its work its remaining state
  /// will be cleared.  If another load request comes in during this time,
  /// it will be held until the canceled load is complete.
  ///@return Returns <tt>false</tt> if the task could not be canceled,
  /// typically because it has already completed normally, or
  /// because \#startLoading() hasn't been called; returns
  /// <tt>true</tt> otherwise.  When <tt>true</tt> is returned, the task
  /// is still running and the OnLoadCanceledListener will be called
  /// when the task completes.
  bool cancelLoad() {
    final result__ = _cancelLoad(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onCancelLoad =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_onCancelLoad")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected boolean onCancelLoad()
  ///
  /// Subclasses must implement this to take care of requests to \#cancelLoad().
  /// This will always be called from the process's main thread.
  ///@return Returns <tt>false</tt> if the task could not be canceled,
  /// typically because it has already completed normally, or
  /// because \#startLoading() hasn't been called; returns
  /// <tt>true</tt> otherwise.  When <tt>true</tt> is returned, the task
  /// is still running and the OnLoadCanceledListener will be called
  /// when the task completes.
  bool onCancelLoad() {
    final result__ = _onCancelLoad(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _forceLoad =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_forceLoad")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void forceLoad()
  ///
  /// Force an asynchronous load. Unlike \#startLoading() this will ignore a previously
  /// loaded data set and load a new one.  This simply calls through to the
  /// implementation's \#onForceLoad().  You generally should only call this
  /// when the loader is started -- that is, \#isStarted() returns true.
  ///
  /// Must be called from the process's main thread.
  void forceLoad() {
    final result__ = _forceLoad(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onForceLoad =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_onForceLoad")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onForceLoad()
  ///
  /// Subclasses must implement this to take care of requests to \#forceLoad().
  /// This will always be called from the process's main thread.
  void onForceLoad() {
    final result__ = _onForceLoad(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _stopLoading =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_stopLoading")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void stopLoading()
  ///
  /// This function will normally be called for you automatically by
  /// android.app.LoaderManager when the associated fragment/activity
  /// is being stopped.  When using a Loader with android.app.LoaderManager,
  /// you _must not_ call this method yourself, or you will conflict
  /// with its management of the Loader.
  ///
  /// Stops delivery of updates until the next time \#startLoading() is called.
  /// Implementations should _not_ invalidate their data at this point --
  /// clients are still free to use the last data the loader reported.  They will,
  /// however, typically stop reporting new data if the data changes; they can
  /// still monitor for changes, but must not report them to the client until and
  /// if \#startLoading() is later called.
  ///
  /// This updates the Loader's internal state so that
  /// \#isStarted() will return the correct
  /// value, and then calls the implementation's \#onStopLoading().
  ///
  /// Must be called from the process's main thread.
  void stopLoading() {
    final result__ = _stopLoading(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onStopLoading =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_onStopLoading")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStopLoading()
  ///
  /// Subclasses must implement this to take care of stopping their loader,
  /// as per \#stopLoading().  This is not called by clients directly,
  /// but as a result of a call to \#stopLoading().
  /// This will always be called from the process's main thread.
  void onStopLoading() {
    final result__ = _onStopLoading(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _abandon =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_abandon")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void abandon()
  ///
  /// This function will normally be called for you automatically by
  /// android.app.LoaderManager when restarting a Loader.  When using
  /// a Loader with android.app.LoaderManager,
  /// you _must not_ call this method yourself, or you will conflict
  /// with its management of the Loader.
  ///
  /// Tell the Loader that it is being abandoned.  This is called prior
  /// to \#reset to have it retain its current data but not report
  /// any new data.
  void abandon() {
    final result__ = _abandon(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onAbandon =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_onAbandon")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onAbandon()
  ///
  /// Subclasses implement this to take care of being abandoned.  This is
  /// an optional intermediate state prior to \#onReset() -- it means that
  /// the client is no longer interested in any new data from the loader,
  /// so the loader must not report any further updates.  However, the
  /// loader _must_ keep its last reported data valid until the final
  /// \#onReset() happens.  You can retrieve the current abandoned
  /// state with \#isAbandoned.
  void onAbandon() {
    final result__ = _onAbandon(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _reset =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_reset")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void reset()
  ///
  /// This function will normally be called for you automatically by
  /// android.app.LoaderManager when destroying a Loader.  When using
  /// a Loader with android.app.LoaderManager,
  /// you _must not_ call this method yourself, or you will conflict
  /// with its management of the Loader.
  ///
  /// Resets the state of the Loader.  The Loader should at this point free
  /// all of its resources, since it may never be called again; however, its
  /// \#startLoading() may later be called at which point it must be
  /// able to start running again.
  ///
  /// This updates the Loader's internal state so that
  /// \#isStarted() and \#isReset() will return the correct
  /// values, and then calls the implementation's \#onReset().
  ///
  /// Must be called from the process's main thread.
  void reset() {
    final result__ = _reset(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onReset =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_onReset")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onReset()
  ///
  /// Subclasses must implement this to take care of resetting their loader,
  /// as per \#reset().  This is not called by clients directly,
  /// but as a result of a call to \#reset().
  /// This will always be called from the process's main thread.
  void onReset() {
    final result__ = _onReset(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _takeContentChanged =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_takeContentChanged")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean takeContentChanged()
  ///
  /// Take the current flag indicating whether the loader's content had
  /// changed while it was stopped.  If it had, true is returned and the
  /// flag is cleared.
  bool takeContentChanged() {
    final result__ = _takeContentChanged(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _commitContentChanged =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_commitContentChanged")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void commitContentChanged()
  ///
  /// Commit that you have actually fully processed a content change that
  /// was returned by \#takeContentChanged.  This is for use with
  /// \#rollbackContentChanged() to handle situations where a load
  /// is cancelled.  Call this when you have completely processed a load
  /// without it being cancelled.
  void commitContentChanged() {
    final result__ = _commitContentChanged(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _rollbackContentChanged =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_rollbackContentChanged")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void rollbackContentChanged()
  ///
  /// Report that you have abandoned the processing of a content change that
  /// was returned by \#takeContentChanged() and would like to rollback
  /// to the state where there is again a pending content change.  This is
  /// to handle the case where a data load due to a content change has been
  /// canceled before its data was delivered back to the loader.
  void rollbackContentChanged() {
    final result__ = _rollbackContentChanged(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onContentChanged =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_Loader_onContentChanged")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onContentChanged()
  ///
  /// Called when ForceLoadContentObserver detects a change.  The
  /// default implementation checks to see if the loader is currently started;
  /// if so, it simply calls \#forceLoad(); otherwise, it sets a flag
  /// so that \#takeContentChanged() returns true.
  ///
  /// Must be called from the process's main thread.
  void onContentChanged() {
    final result__ = _onContentChanged(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_Loader_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _dump = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_Loader_dump")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  ///
  /// Print the Loader's state into the given stream.
  ///@param prefix Text to print at the front of each line.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer A PrintWriter to which the dump is to be set.
  ///@param args Additional arguments to the dump request.
  void dump(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
      jni.JniObject args) {
    final result__ = _dump(reference, prefix.reference, fd.reference,
        writer.reference, args.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.Loader$OnLoadCompleteListener
///
/// Interface that is implemented to discover when a Loader has finished
/// loading its data.  You do not normally need to implement this yourself;
/// it is used in the implementation of android.app.LoaderManager
/// to find out when a Loader it is managing has completed so that this can
/// be reported to its client.  This interface should only be used if a
/// Loader is not being used in conjunction with LoaderManager.
///@deprecated Use android.support.v4.content.Loader.OnLoadCompleteListener
class Loader_OnLoadCompleteListener extends jni.JniObject {
  Loader_OnLoadCompleteListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);
}

/// from: android.content.Loader$OnLoadCanceledListener
///
/// Interface that is implemented to discover when a Loader has been canceled
/// before it finished loading its data.  You do not normally need to implement
/// this yourself; it is used in the implementation of android.app.LoaderManager
/// to find out when a Loader it is managing has been canceled so that it
/// can schedule the next Loader.  This interface should only be used if a
/// Loader is not being used in conjunction with LoaderManager.
///@deprecated Use android.support.v4.content.Loader.OnLoadCanceledListener
class Loader_OnLoadCanceledListener extends jni.JniObject {
  Loader_OnLoadCanceledListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onLoadCanceled = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_Loader__OnLoadCanceledListener_onLoadCanceled")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onLoadCanceled(android.content.Loader<D> loader)
  ///
  /// Called on the thread that created the Loader when the load is canceled.
  ///@param loader the loader that canceled the load
  void onLoadCanceled(Loader loader) {
    final result__ = _onLoadCanceled(reference, loader.reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.Loader$ForceLoadContentObserver
///
/// An implementation of a ContentObserver that takes care of connecting
/// it to the Loader to have the loader re-load its data when the observer
/// is told it has changed.  You do not normally need to use this yourself;
/// it is used for you by CursorLoader to take care of executing
/// an update when the cursor's backing data changes.
///@deprecated Use android.support.v4.content.Loader.ForceLoadContentObserver
class Loader_ForceLoadContentObserver extends jni.JniObject {
  Loader_ForceLoadContentObserver.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_Loader__ForceLoadContentObserver_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Loader_ForceLoadContentObserver() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _deliverSelfNotifications = jniLookup<
              ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_Loader__ForceLoadContentObserver_deliverSelfNotifications")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean deliverSelfNotifications()
  bool deliverSelfNotifications() {
    final result__ = _deliverSelfNotifications(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _onChange = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_content_Loader__ForceLoadContentObserver_onChange")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onChange(boolean selfChange)
  void onChange(bool selfChange) {
    final result__ = _onChange(reference, selfChange ? 1 : 0);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.SyncContext
class SyncContext extends jni.JniObject {
  SyncContext.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_content_SyncContext_ctor")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  SyncContext() : super.fromRef(_ctor()) {
    jni.Jni.env.checkException();
  }

  static final _onFinished = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_SyncContext_onFinished")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onFinished(android.content.SyncResult result)
  void onFinished(SyncResult result) {
    final result__ = _onFinished(reference, result.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getSyncContextBinder = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_SyncContext_getSyncContextBinder")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.IBinder getSyncContextBinder()
  /// The returned object must be deleted after use, by calling the `delete` method.
  os_.IBinder getSyncContextBinder() {
    final result__ = os_.IBinder.fromRef(_getSyncContextBinder(reference));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.ContentProviderOperation
///
/// Represents a single operation to be performed as part of a batch of operations.
///@see ContentProvider\#applyBatch(ArrayList)
class ContentProviderOperation extends jni.JniObject {
  ContentProviderOperation.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_ContentProviderOperation_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.ContentProviderOperation> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderOperation_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.content.ContentProviderOperation.Builder builder)
  ///
  /// Creates a ContentProviderOperation by copying the contents of a
  /// Builder.
  ContentProviderOperation(ContentProviderOperation_Builder builder)
      : super.fromRef(_ctor(builder.reference)) {
    jni.Jni.env.checkException();
  }

  static final _writeToParcel = jniLookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_ContentProviderOperation_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) {
    final result__ = _writeToParcel(reference, dest.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _newInsert = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderOperation_newInsert")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.ContentProviderOperation.Builder newInsert(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a Builder suitable for building an insert ContentProviderOperation.
  ///@param uri The Uri that is the target of the insert.
  ///@return a Builder
  static ContentProviderOperation_Builder newInsert(jni.JniObject uri) {
    final result__ =
        ContentProviderOperation_Builder.fromRef(_newInsert(uri.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _newUpdate = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderOperation_newUpdate")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.ContentProviderOperation.Builder newUpdate(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a Builder suitable for building an update ContentProviderOperation.
  ///@param uri The Uri that is the target of the update.
  ///@return a Builder
  static ContentProviderOperation_Builder newUpdate(jni.JniObject uri) {
    final result__ =
        ContentProviderOperation_Builder.fromRef(_newUpdate(uri.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _newDelete = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderOperation_newDelete")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.ContentProviderOperation.Builder newDelete(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a Builder suitable for building a delete ContentProviderOperation.
  ///@param uri The Uri that is the target of the delete.
  ///@return a Builder
  static ContentProviderOperation_Builder newDelete(jni.JniObject uri) {
    final result__ =
        ContentProviderOperation_Builder.fromRef(_newDelete(uri.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _newAssertQuery = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderOperation_newAssertQuery")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.ContentProviderOperation.Builder newAssertQuery(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a Builder suitable for building a
  /// ContentProviderOperation to assert a set of values as provided
  /// through Builder\#withValues(ContentValues).
  static ContentProviderOperation_Builder newAssertQuery(jni.JniObject uri) {
    final result__ = ContentProviderOperation_Builder.fromRef(
        _newAssertQuery(uri.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getUri = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderOperation_getUri")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri getUri()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the Uri for the target of the operation.
  jni.JniObject getUri() {
    final result__ = jni.JniObject.fromRef(_getUri(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isYieldAllowed =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentProviderOperation_isYieldAllowed")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isYieldAllowed()
  ///
  /// Returns true if the operation allows yielding the database to other transactions
  /// if the database is contended.
  ///@see android.database.sqlite.SQLiteDatabase\#yieldIfContendedSafely()
  bool isYieldAllowed() {
    final result__ = _isYieldAllowed(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isInsert =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentProviderOperation_isInsert")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isInsert()
  ///
  /// Returns true if the operation represents an insertion.
  ///@see \#newInsert
  bool isInsert() {
    final result__ = _isInsert(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isDelete =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentProviderOperation_isDelete")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isDelete()
  ///
  /// Returns true if the operation represents a deletion.
  ///@see \#newDelete
  bool isDelete() {
    final result__ = _isDelete(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isUpdate =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentProviderOperation_isUpdate")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isUpdate()
  ///
  /// Returns true if the operation represents an update.
  ///@see \#newUpdate
  bool isUpdate() {
    final result__ = _isUpdate(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isAssertQuery =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentProviderOperation_isAssertQuery")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isAssertQuery()
  ///
  /// Returns true if the operation represents an assert query.
  ///@see \#newAssertQuery
  bool isAssertQuery() {
    final result__ = _isAssertQuery(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isWriteOperation =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentProviderOperation_isWriteOperation")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isWriteOperation()
  ///
  /// Returns true if the operation represents an insertion, deletion, or update.
  ///@see \#isInsert
  ///@see \#isDelete
  ///@see \#isUpdate
  bool isWriteOperation() {
    final result__ = _isWriteOperation(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _isReadOperation =
      jniLookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentProviderOperation_isReadOperation")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isReadOperation()
  ///
  /// Returns true if the operation represents an assert query.
  ///@see \#isAssertQuery
  bool isReadOperation() {
    final result__ = _isReadOperation(reference) != 0;
    jni.Jni.env.checkException();
    return result__;
  }

  static final _apply = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_ContentProviderOperation_apply")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.ContentProviderResult apply(android.content.ContentProvider provider, android.content.ContentProviderResult[] backRefs, int numBackRefs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Applies this operation using the given provider. The backRefs array is used to resolve any
  /// back references that were requested using
  /// Builder\#withValueBackReferences(ContentValues) and
  /// Builder\#withSelectionBackReference.
  ///@param provider the ContentProvider on which this batch is applied
  ///@param backRefs a ContentProviderResult array that will be consulted
  /// to resolve any requested back references.
  ///@param numBackRefs the number of valid results on the backRefs array.
  ///@return a ContentProviderResult that contains either the Uri of the inserted
  /// row if this was an insert otherwise the number of rows affected.
  ///@throws OperationApplicationException thrown if either the insert fails or
  /// if the number of rows affected didn't match the expected count
  ContentProviderResult apply(
      ContentProvider provider, jni.JniObject backRefs, int numBackRefs) {
    final result__ = ContentProviderResult.fromRef(
        _apply(reference, provider.reference, backRefs.reference, numBackRefs));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _resolveValueBackReferences = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_ContentProviderOperation_resolveValueBackReferences")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.ContentValues resolveValueBackReferences(android.content.ContentProviderResult[] backRefs, int numBackRefs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The ContentValues back references are represented as a ContentValues object where the
  /// key refers to a column and the value is an index of the back reference whose
  /// valued should be associated with the column.
  ///
  /// This is intended to be a private method but it is exposed for
  /// unit testing purposes
  ///@param backRefs an array of previous results
  ///@param numBackRefs the number of valid previous results in backRefs
  ///@return the ContentValues that should be used in this operation application after
  /// expansion of back references. This can be called if either mValues or mValuesBackReferences
  /// is null
  ContentValues resolveValueBackReferences(
      jni.JniObject backRefs, int numBackRefs) {
    final result__ = ContentValues.fromRef(_resolveValueBackReferences(
        reference, backRefs.reference, numBackRefs));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _resolveSelectionArgsBackReferences = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_ContentProviderOperation_resolveSelectionArgsBackReferences")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String[] resolveSelectionArgsBackReferences(android.content.ContentProviderResult[] backRefs, int numBackRefs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The Selection Arguments back references are represented as a Map of Integer->Integer where
  /// the key is an index into the selection argument array (see Builder\#withSelection)
  /// and the value is the index of the previous result that should be used for that selection
  /// argument array slot.
  ///
  /// This is intended to be a private method but it is exposed for
  /// unit testing purposes
  ///@param backRefs an array of previous results
  ///@param numBackRefs the number of valid previous results in backRefs
  ///@return the ContentValues that should be used in this operation application after
  /// expansion of back references. This can be called if either mValues or mValuesBackReferences
  /// is null
  jni.JniObject resolveSelectionArgsBackReferences(
      jni.JniObject backRefs, int numBackRefs) {
    final result__ = jni.JniObject.fromRef(_resolveSelectionArgsBackReferences(
        reference, backRefs.reference, numBackRefs));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderOperation_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentProviderOperation_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.ContentProviderOperation$Builder
///
/// Used to add parameters to a ContentProviderOperation. The Builder is
/// first created by calling ContentProviderOperation\#newInsert(android.net.Uri),
/// ContentProviderOperation\#newUpdate(android.net.Uri),
/// ContentProviderOperation\#newDelete(android.net.Uri) or
/// ContentProviderOperation\#newAssertQuery(Uri). The withXXX methods
/// can then be used to add parameters to the builder. See the specific methods to find for
/// which Builder type each is allowed. Call \#build to create the
/// ContentProviderOperation once all the parameters have been supplied.
class ContentProviderOperation_Builder extends jni.JniObject {
  ContentProviderOperation_Builder.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderOperation__Builder_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(int, ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(int type, android.net.Uri uri)
  ///
  /// Create a Builder of a given type. The uri must not be null.
  ContentProviderOperation_Builder(int type, jni.JniObject uri)
      : super.fromRef(_ctor(type, uri.reference)) {
    jni.Jni.env.checkException();
  }

  static final _build = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderOperation__Builder_build")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ContentProviderOperation build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a ContentProviderOperation from this Builder.
  ContentProviderOperation build() {
    final result__ = ContentProviderOperation.fromRef(_build(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _withValueBackReferences = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderOperation__Builder_withValueBackReferences")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ContentProviderOperation.Builder withValueBackReferences(android.content.ContentValues backReferences)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a ContentValues of back references. The key is the name of the column
  /// and the value is an integer that is the index of the previous result whose
  /// value should be used for the column. The value is added as a String.
  /// A column value from the back references takes precedence over a value specified in
  /// \#withValues.
  /// This can only be used with builders of type insert, update, or assert.
  ///@return this builder, to allow for chaining.
  ContentProviderOperation_Builder withValueBackReferences(
      ContentValues backReferences) {
    final result__ = ContentProviderOperation_Builder.fromRef(
        _withValueBackReferences(reference, backReferences.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _withValueBackReference = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_ContentProviderOperation__Builder_withValueBackReference")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.ContentProviderOperation.Builder withValueBackReference(java.lang.String key, int previousResult)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a ContentValues back reference.
  /// A column value from the back references takes precedence over a value specified in
  /// \#withValues.
  /// This can only be used with builders of type insert, update, or assert.
  ///@return this builder, to allow for chaining.
  ContentProviderOperation_Builder withValueBackReference(
      jni.JniString key, int previousResult) {
    final result__ = ContentProviderOperation_Builder.fromRef(
        _withValueBackReference(reference, key.reference, previousResult));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _withSelectionBackReference = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_content_ContentProviderOperation__Builder_withSelectionBackReference")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.content.ContentProviderOperation.Builder withSelectionBackReference(int selectionArgIndex, int previousResult)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a back references as a selection arg. Any value at that index of the selection arg
  /// that was specified by \#withSelection will be overwritten.
  /// This can only be used with builders of type update, delete, or assert.
  ///@return this builder, to allow for chaining.
  ContentProviderOperation_Builder withSelectionBackReference(
      int selectionArgIndex, int previousResult) {
    final result__ = ContentProviderOperation_Builder.fromRef(
        _withSelectionBackReference(
            reference, selectionArgIndex, previousResult));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _withValues = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderOperation__Builder_withValues")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ContentProviderOperation.Builder withValues(android.content.ContentValues values)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The ContentValues to use. This may be null. These values may be overwritten by
  /// the corresponding value specified by \#withValueBackReference or by
  /// future calls to \#withValues or \#withValue.
  /// This can only be used with builders of type insert, update, or assert.
  ///@return this builder, to allow for chaining.
  ContentProviderOperation_Builder withValues(ContentValues values) {
    final result__ = ContentProviderOperation_Builder.fromRef(
        _withValues(reference, values.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _withValue = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderOperation__Builder_withValue")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ContentProviderOperation.Builder withValue(java.lang.String key, java.lang.Object value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A value to insert or update. This value may be overwritten by
  /// the corresponding value specified by \#withValueBackReference.
  /// This can only be used with builders of type insert, update, or assert.
  ///@param key the name of this value
  ///@param value the value itself. the type must be acceptable for insertion by
  /// ContentValues\#put
  ///@return this builder, to allow for chaining.
  ContentProviderOperation_Builder withValue(
      jni.JniString key, jni.JniObject value) {
    final result__ = ContentProviderOperation_Builder.fromRef(
        _withValue(reference, key.reference, value.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _withSelection = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentProviderOperation__Builder_withSelection")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ContentProviderOperation.Builder withSelection(java.lang.String selection, java.lang.String[] selectionArgs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The selection and arguments to use. An occurrence of '?' in the selection will be
  /// replaced with the corresponding occurence of the selection argument. Any of the
  /// selection arguments may be overwritten by a selection argument back reference as
  /// specified by \#withSelectionBackReference.
  /// This can only be used with builders of type update, delete, or assert.
  ///@return this builder, to allow for chaining.
  ContentProviderOperation_Builder withSelection(
      jni.JniString selection, jni.JniObject selectionArgs) {
    final result__ = ContentProviderOperation_Builder.fromRef(_withSelection(
        reference, selection.reference, selectionArgs.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _withExpectedCount = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_content_ContentProviderOperation__Builder_withExpectedCount")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.ContentProviderOperation.Builder withExpectedCount(int count)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If set then if the number of rows affected by this operation does not match
  /// this count OperationApplicationException will be throw.
  /// This can only be used with builders of type update, delete, or assert.
  ///@return this builder, to allow for chaining.
  ContentProviderOperation_Builder withExpectedCount(int count) {
    final result__ = ContentProviderOperation_Builder.fromRef(
        _withExpectedCount(reference, count));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _withYieldAllowed = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_content_ContentProviderOperation__Builder_withYieldAllowed")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.ContentProviderOperation.Builder withYieldAllowed(boolean yieldAllowed)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If set to true then the operation allows yielding the database to other transactions
  /// if the database is contended.
  ///@return this builder, to allow for chaining.
  ///@see android.database.sqlite.SQLiteDatabase\#yieldIfContendedSafely()
  ContentProviderOperation_Builder withYieldAllowed(bool yieldAllowed) {
    final result__ = ContentProviderOperation_Builder.fromRef(
        _withYieldAllowed(reference, yieldAllowed ? 1 : 0));
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.ContentQueryMap
///
/// Caches the contents of a cursor into a Map of String->ContentValues and optionally
/// keeps the cache fresh by registering for updates on the content backing the cursor. The column of
/// the database that is to be used as the key of the map is user-configurable, and the
/// ContentValues contains all columns other than the one that is designated the key.
///
/// The cursor data is accessed by row key and column name via getValue().
class ContentQueryMap extends jni.JniObject {
  ContentQueryMap.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Uint8,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentQueryMap_ctor")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.database.Cursor cursor, java.lang.String columnNameOfKey, boolean keepUpdated, android.os.Handler handlerForUpdateNotifications)
  ///
  /// Creates a ContentQueryMap that caches the content backing the cursor
  ///@param cursor the cursor whose contents should be cached
  ///@param columnNameOfKey the column that is to be used as the key of the values map
  ///@param keepUpdated true if the cursor's ContentProvider should be monitored for changes and
  /// the map updated when changes do occur
  ///@param handlerForUpdateNotifications the Handler that should be used to receive
  ///  notifications of changes (if requested). Normally you pass null here, but if
  ///  you know that the thread that is creating this isn't a thread that can receive
  ///  messages then you can create your own handler and use that here.
  ContentQueryMap(jni.JniObject cursor, jni.JniString columnNameOfKey,
      bool keepUpdated, os_.Handler handlerForUpdateNotifications)
      : super.fromRef(_ctor(cursor.reference, columnNameOfKey.reference,
            keepUpdated ? 1 : 0, handlerForUpdateNotifications.reference)) {
    jni.Jni.env.checkException();
  }

  static final _setKeepUpdated = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_content_ContentQueryMap_setKeepUpdated")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setKeepUpdated(boolean keepUpdated)
  ///
  /// Change whether or not the ContentQueryMap will register with the cursor's ContentProvider
  /// for change notifications. If you use a ContentQueryMap in an activity you should call this
  /// with false in onPause(), which means you need to call it with true in onResume()
  /// if want it to be kept updated.
  ///@param keepUpdated if true the ContentQueryMap should be registered with the cursor's
  /// ContentProvider, false otherwise
  void setKeepUpdated(bool keepUpdated) {
    final result__ = _setKeepUpdated(reference, keepUpdated ? 1 : 0);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getValues = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentQueryMap_getValues")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: synchronized public android.content.ContentValues getValues(java.lang.String rowName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Access the ContentValues for the row specified by rowName
  ///@param rowName which row to read
  ///@return the ContentValues for the row, or null if the row wasn't present in the cursor
  ContentValues getValues(jni.JniString rowName) {
    final result__ =
        ContentValues.fromRef(_getValues(reference, rowName.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _requery =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentQueryMap_requery")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void requery()
  ///
  /// Requeries the cursor and reads the contents into the cache
  void requery() {
    final result__ = _requery(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getRows = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ContentQueryMap_getRows")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: synchronized public java.util.Map<java.lang.String,android.content.ContentValues> getRows()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getRows() {
    final result__ = jni.JniObject.fromRef(_getRows(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _close =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentQueryMap_close")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: synchronized public void close()
  void close() {
    final result__ = _close(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _finalize =
      jniLookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ContentQueryMap_finalize")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void finalize()
  void finalize() {
    final result__ = _finalize(reference);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.ClipData
///
/// Representation of a clipped data on the clipboard.
///
/// ClipData is a complex type containing one or more Item instances,
/// each of which can hold one or more representations of an item of data.
/// For display to the user, it also has a label.
///
///
/// A ClipData contains a ClipDescription, which describes
/// important meta-data about the clip.  In particular, its
/// ClipDescription\#getMimeType(int) getDescription().getMimeType(int)
/// must return correct MIME type(s) describing the data in the clip.  For help
/// in correctly constructing a clip with the correct MIME type, use
/// \#newPlainText(CharSequence, CharSequence),
/// \#newUri(ContentResolver, CharSequence, Uri), and
/// \#newIntent(CharSequence, Intent).
///
/// Each Item instance can be one of three main classes of data: a simple
/// CharSequence of text, a single Intent object, or a Uri.  See Item
/// for more details.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using the clipboard framework, read the
/// <a href="{@docRoot}guide/topics/clipboard/copy-paste.html">Copy and Paste</a>
/// developer guide.
///
/// </div>
///
/// <a name="ImplementingPaste"></a>
/// <h3>Implementing Paste or Drop</h3>
///
/// To implement a paste or drop of a ClipData object into an application,
/// the application must correctly interpret the data for its use.  If the Item
/// it contains is simple text or an Intent, there is little to be done: text
/// can only be interpreted as text, and an Intent will typically be used for
/// creating shortcuts (such as placing icons on the home screen) or other
/// actions.
///
/// If all you want is the textual representation of the clipped data, you
/// can use the convenience method Item\#coerceToText Item.coerceToText.
/// In this case there is generally no need to worry about the MIME types
/// reported by ClipDescription\#getMimeType(int) getDescription().getMimeType(int),
/// since any clip item can always be converted to a string.
///
/// More complicated exchanges will be done through URIs, in particular
/// "content:" URIs.  A content URI allows the recipient of a ClipData item
/// to interact closely with the ContentProvider holding the data in order to
/// negotiate the transfer of that data.  The clip must also be filled in with
/// the available MIME types; \#newUri(ContentResolver, CharSequence, Uri)
/// will take care of correctly doing this.
///
/// For example, here is the paste function of a simple NotePad application.
/// When retrieving the data from the clipboard, it can do either two things:
/// if the clipboard contains a URI reference to an existing note, it copies
/// the entire structure of the note into a new note; otherwise, it simply
/// coerces the clip into text and uses that as the new note's contents.
///
/// {@sample development/samples/NotePad/src/com/example/android/notepad/NoteEditor.java
///      paste}
///
/// In many cases an application can paste various types of streams of data.  For
/// example, an e-mail application may want to allow the user to paste an image
/// or other binary data as an attachment.  This is accomplished through the
/// ContentResolver ContentResolver\#getStreamTypes(Uri, String) and
/// ContentResolver\#openTypedAssetFileDescriptor(Uri, String, android.os.Bundle)
/// methods.  These allow a client to discover the type(s) of data that a particular
/// content URI can make available as a stream and retrieve the stream of data.
///
/// For example, the implementation of Item\#coerceToText Item.coerceToText
/// itself uses this to try to retrieve a URI clip as a stream of text:
///
/// {@sample frameworks/base/core/java/android/content/ClipData.java coerceToText}
///
/// <a name="ImplementingCopy"></a>
/// <h3>Implementing Copy or Drag</h3>
///
/// To be the source of a clip, the application must construct a ClipData
/// object that any recipient can interpret best for their context.  If the clip
/// is to contain a simple text, Intent, or URI, this is easy: an Item
/// containing the appropriate data type can be constructed and used.
///
/// More complicated data types require the implementation of support in
/// a ContentProvider for describing and generating the data for the recipient.
/// A common scenario is one where an application places on the clipboard the
/// content: URI of an object that the user has copied, with the data at that
/// URI consisting of a complicated structure that only other applications with
/// direct knowledge of the structure can use.
///
/// For applications that do not have intrinsic knowledge of the data structure,
/// the content provider holding it can make the data available as an arbitrary
/// number of types of data streams.  This is done by implementing the
/// ContentProvider ContentProvider\#getStreamTypes(Uri, String) and
/// ContentProvider\#openTypedAssetFile(Uri, String, android.os.Bundle)
/// methods.
///
/// Going back to our simple NotePad application, this is the implementation
/// it may have to convert a single note URI (consisting of a title and the note
/// text) into a stream of plain text data.
///
/// {@sample development/samples/NotePad/src/com/example/android/notepad/NotePadProvider.java
///      stream}
///
/// The copy operation in our NotePad application is now just a simple matter
/// of making a clip containing the URI of the note being copied:
///
/// {@sample development/samples/NotePad/src/com/example/android/notepad/NotesList.java
///      copy}
///
/// Note if a paste operation needs this clip as text (for example to paste
/// into an editor), then Item\#coerceToText(Context) will ask the content
/// provider for the clip URI as text and successfully paste the entire note.
class ClipData extends jni.JniObject {
  ClipData.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_content_ClipData_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.ClipData> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR());

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_ClipData_ctor")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.CharSequence label, java.lang.String[] mimeTypes, android.content.ClipData.Item item)
  ///
  /// Create a new clip.
  ///@param label Label to show to the user describing this clip.
  ///@param mimeTypes An array of MIME types this data is available as.
  ///@param item The contents of the first item in the clip.
  ClipData(jni.JniObject label, jni.JniObject mimeTypes, ClipData_Item item)
      : super.fromRef(
            _ctor(label.reference, mimeTypes.reference, item.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_ClipData_ctor1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.ClipDescription description, android.content.ClipData.Item item)
  ///
  /// Create a new clip.
  ///@param description The ClipDescription describing the clip contents.
  ///@param item The contents of the first item in the clip.
  ClipData.ctor1(ClipDescription description, ClipData_Item item)
      : super.fromRef(_ctor1(description.reference, item.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor2 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_ClipData_ctor2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.ClipData other)
  ///
  /// Create a new clip that is a copy of another clip.  This does a deep-copy
  /// of all items in the clip.
  ///@param other The existing ClipData that is to be copied.
  ClipData.ctor2(ClipData other) : super.fromRef(_ctor2(other.reference)) {
    jni.Jni.env.checkException();
  }

  static final _newPlainText = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipData_newPlainText")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.ClipData newPlainText(java.lang.CharSequence label, java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new ClipData holding data of the type
  /// ClipDescription\#MIMETYPE_TEXT_PLAIN.
  ///@param label User-visible label for the clip data.
  ///@param text The actual text in the clip.
  ///@return Returns a new ClipData containing the specified data.
  static ClipData newPlainText(jni.JniObject label, jni.JniObject text) {
    final result__ =
        ClipData.fromRef(_newPlainText(label.reference, text.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _newHtmlText = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipData_newHtmlText")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.ClipData newHtmlText(java.lang.CharSequence label, java.lang.CharSequence text, java.lang.String htmlText)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new ClipData holding data of the type
  /// ClipDescription\#MIMETYPE_TEXT_HTML.
  ///@param label User-visible label for the clip data.
  ///@param text The text of clip as plain text, for receivers that don't
  /// handle HTML.  This is required.
  ///@param htmlText The actual HTML text in the clip.
  ///@return Returns a new ClipData containing the specified data.
  static ClipData newHtmlText(
      jni.JniObject label, jni.JniObject text, jni.JniString htmlText) {
    final result__ = ClipData.fromRef(
        _newHtmlText(label.reference, text.reference, htmlText.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _newIntent = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_ClipData_newIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.ClipData newIntent(java.lang.CharSequence label, android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new ClipData holding an Intent with MIME type
  /// ClipDescription\#MIMETYPE_TEXT_INTENT.
  ///@param label User-visible label for the clip data.
  ///@param intent The actual Intent in the clip.
  ///@return Returns a new ClipData containing the specified data.
  static ClipData newIntent(jni.JniObject label, Intent intent) {
    final result__ =
        ClipData.fromRef(_newIntent(label.reference, intent.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _newUri = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_ClipData_newUri")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.ClipData newUri(android.content.ContentResolver resolver, java.lang.CharSequence label, android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new ClipData holding a URI.  If the URI is a content: URI,
  /// this will query the content provider for the MIME type of its data and
  /// use that as the MIME type.  Otherwise, it will use the MIME type
  /// ClipDescription\#MIMETYPE_TEXT_URILIST.
  ///@param resolver ContentResolver used to get information about the URI.
  ///@param label User-visible label for the clip data.
  ///@param uri The URI in the clip.
  ///@return Returns a new ClipData containing the specified data.
  static ClipData newUri(
      ContentResolver resolver, jni.JniObject label, jni.JniObject uri) {
    final result__ = ClipData.fromRef(
        _newUri(resolver.reference, label.reference, uri.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _newRawUri = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_ClipData_newRawUri")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.ClipData newRawUri(java.lang.CharSequence label, android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new ClipData holding an URI with MIME type
  /// ClipDescription\#MIMETYPE_TEXT_URILIST.
  /// Unlike \#newUri(ContentResolver, CharSequence, Uri), nothing
  /// is inferred about the URI -- if it is a content: URI holding a bitmap,
  /// the reported type will still be uri-list.  Use this with care!
  ///@param label User-visible label for the clip data.
  ///@param uri The URI in the clip.
  ///@return Returns a new ClipData containing the specified data.
  static ClipData newRawUri(jni.JniObject label, jni.JniObject uri) {
    final result__ =
        ClipData.fromRef(_newRawUri(label.reference, uri.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getDescription = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipData_getDescription")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ClipDescription getDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the ClipDescription associated with this data, describing
  /// what it contains.
  ClipDescription getDescription() {
    final result__ = ClipDescription.fromRef(_getDescription(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _addItem = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_ClipData_addItem")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void addItem(android.content.ClipData.Item item)
  ///
  /// Add a new Item to the overall ClipData container.
  ///  This method will _not_ update the list of available MIME types in the
  /// ClipDescription. It should be used only when adding items which do not add new
  /// MIME types to this clip. If this is not the case, use \#addItem(ContentResolver, Item)
  /// or call \#ClipData(CharSequence, String[], Item) with a complete list of MIME types.
  ///@param item Item to be added.
  void addItem(ClipData_Item item) {
    final result__ = _addItem(reference, item.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _addItem1 = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_content_ClipData_addItem1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void addItem(android.content.ContentResolver resolver, android.content.ClipData.Item item)
  ///
  /// Add a new Item to the overall ClipData container.
  ///  Unlike \#addItem(Item), this method will update the list of available MIME types
  /// in the ClipDescription.
  ///@param resolver ContentResolver used to get information about the URI possibly contained in
  /// the item.
  ///@param item Item to be added.
  void addItem1(ContentResolver resolver, ClipData_Item item) {
    final result__ = _addItem1(reference, resolver.reference, item.reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getItemCount =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ClipData_getItemCount")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getItemCount()
  ///
  /// Return the number of items in the clip data.
  int getItemCount() {
    final result__ = _getItemCount(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getItemAt = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_ClipData_getItemAt")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.ClipData.Item getItemAt(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a single item inside of the clip data.  The index can range
  /// from 0 to \#getItemCount()-1.
  ClipData_Item getItemAt(int index) {
    final result__ = ClipData_Item.fromRef(_getItemAt(reference, index));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_content_ClipData_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _describeContents =
      jniLookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_content_ClipData_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    final result__ = _describeContents(reference);
    jni.Jni.env.checkException();
    return result__;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_content_ClipData_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) {
    final result__ = _writeToParcel(reference, dest.reference, flags);
    jni.Jni.env.checkException();
    return result__;
  }
}

/// from: android.content.ClipData$Item
///
/// Description of a single item in a ClipData.
///
/// The types than an individual item can currently contain are:
///
///
/// <ul>
/// <li> Text: a basic string of text.  This is actually a CharSequence,
/// so it can be formatted text supported by corresponding Android built-in
/// style spans.  (Custom application spans are not supported and will be
/// stripped when transporting through the clipboard.)
/// <li> Intent: an arbitrary Intent object.  A typical use is the shortcut
/// to create when pasting a clipped item on to the home screen.
/// <li> Uri: a URI reference.  This may be any URI (such as an http: URI
/// representing a bookmark), however it is often a content: URI.  Using
/// content provider references as clips like this allows an application to
/// share complex or large clips through the standard content provider
/// facilities.
/// </ul>
class ClipData_Item extends jni.JniObject {
  ClipData_Item.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipData__Item_ctor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.CharSequence text)
  ///
  /// Create an Item consisting of a single block of (possibly styled) text.
  ClipData_Item(jni.JniObject text) : super.fromRef(_ctor(text.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipData__Item_ctor1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.CharSequence text, java.lang.String htmlText)
  ///
  /// Create an Item consisting of a single block of (possibly styled) text,
  /// with an alternative HTML formatted representation.  You _must_
  /// supply a plain text representation in addition to HTML text; coercion
  /// will not be done from HTML formated text into plain text.
  ClipData_Item.ctor1(jni.JniObject text, jni.JniString htmlText)
      : super.fromRef(_ctor1(text.reference, htmlText.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor2 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipData__Item_ctor2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Intent intent)
  ///
  /// Create an Item consisting of an arbitrary Intent.
  ClipData_Item.ctor2(Intent intent) : super.fromRef(_ctor2(intent.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor3 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipData__Item_ctor3")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.net.Uri uri)
  ///
  /// Create an Item consisting of an arbitrary URI.
  ClipData_Item.ctor3(jni.JniObject uri)
      : super.fromRef(_ctor3(uri.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor4 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipData__Item_ctor4")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.CharSequence text, android.content.Intent intent, android.net.Uri uri)
  ///
  /// Create a complex Item, containing multiple representations of
  /// text, Intent, and/or URI.
  ClipData_Item.ctor4(jni.JniObject text, Intent intent, jni.JniObject uri)
      : super.fromRef(_ctor4(text.reference, intent.reference, uri.reference)) {
    jni.Jni.env.checkException();
  }

  static final _ctor5 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipData__Item_ctor5")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.CharSequence text, java.lang.String htmlText, android.content.Intent intent, android.net.Uri uri)
  ///
  /// Create a complex Item, containing multiple representations of
  /// text, HTML text, Intent, and/or URI.  If providing HTML text, you
  /// _must_ supply a plain text representation as well; coercion
  /// will not be done from HTML formated text into plain text.
  ClipData_Item.ctor5(jni.JniObject text, jni.JniString htmlText, Intent intent,
      jni.JniObject uri)
      : super.fromRef(_ctor5(text.reference, htmlText.reference,
            intent.reference, uri.reference)) {
    jni.Jni.env.checkException();
  }

  static final _getText = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipData__Item_getText")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the raw text contained in this Item.
  jni.JniObject getText() {
    final result__ = jni.JniObject.fromRef(_getText(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getHtmlText = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipData__Item_getHtmlText")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getHtmlText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the raw HTML text contained in this Item.
  jni.JniString getHtmlText() {
    final result__ = jni.JniString.fromRef(_getHtmlText(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getIntent = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipData__Item_getIntent")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent getIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the raw Intent contained in this Item.
  Intent getIntent() {
    final result__ = Intent.fromRef(_getIntent(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _getUri = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipData__Item_getUri")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri getUri()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the raw URI contained in this Item.
  jni.JniObject getUri() {
    final result__ = jni.JniObject.fromRef(_getUri(reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _coerceToText = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipData__Item_coerceToText")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence coerceToText(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Turn this item into text, regardless of the type of data it
  /// actually contains.
  ///
  /// The algorithm for deciding what text to return is:
  /// <ul>
  /// <li> If \#getText is non-null, return that.
  /// <li> If \#getUri is non-null, try to retrieve its data
  /// as a text stream from its content provider.  If this succeeds, copy
  /// the text into a String and return it.  If it is not a content: URI or
  /// the content provider does not supply a text representation, return
  /// the raw URI as a string.
  /// <li> If \#getIntent is non-null, convert that to an intent:
  /// URI and return it.
  /// <li> Otherwise, return an empty string.
  /// </ul>
  ///@param context The caller's Context, from which its ContentResolver
  /// and other things can be retrieved.
  ///@return Returns the item's textual representation.
  jni.JniObject coerceToText(Context context) {
    final result__ =
        jni.JniObject.fromRef(_coerceToText(reference, context.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _coerceToStyledText = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipData__Item_coerceToStyledText")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence coerceToStyledText(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#coerceToHtmlText(Context), but any text that would
  /// be returned as HTML formatting will be returned as text with
  /// style spans.
  ///@param context The caller's Context, from which its ContentResolver
  /// and other things can be retrieved.
  ///@return Returns the item's textual representation.
  jni.JniObject coerceToStyledText(Context context) {
    final result__ = jni.JniObject.fromRef(
        _coerceToStyledText(reference, context.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _coerceToHtmlText = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipData__Item_coerceToHtmlText")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String coerceToHtmlText(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Turn this item into HTML text, regardless of the type of data it
  /// actually contains.
  ///
  /// The algorithm for deciding what text to return is:
  /// <ul>
  /// <li> If \#getHtmlText is non-null, return that.
  /// <li> If \#getText is non-null, return that, converting to
  /// valid HTML text.  If this text contains style spans,
  /// Html\#toHtml(Spanned) Html.toHtml(Spanned) is used to
  /// convert them to HTML formatting.
  /// <li> If \#getUri is non-null, try to retrieve its data
  /// as a text stream from its content provider.  If the provider can
  /// supply text/html data, that will be preferred and returned as-is.
  /// Otherwise, any text/* data will be returned and escaped to HTML.
  /// If it is not a content: URI or the content provider does not supply
  /// a text representation, HTML text containing a link to the URI
  /// will be returned.
  /// <li> If \#getIntent is non-null, convert that to an intent:
  /// URI and return as an HTML link.
  /// <li> Otherwise, return an empty string.
  /// </ul>
  ///@param context The caller's Context, from which its ContentResolver
  /// and other things can be retrieved.
  ///@return Returns the item's representation as HTML text.
  jni.JniString coerceToHtmlText(Context context) {
    final result__ =
        jni.JniString.fromRef(_coerceToHtmlText(reference, context.reference));
    jni.Jni.env.checkException();
    return result__;
  }

  static final _toString1 = jniLookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_content_ClipData__Item_toString1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() {
    final result__ = jni.JniString.fromRef(_toString1(reference));
    jni.Jni.env.checkException();
    return result__;
  }
}
