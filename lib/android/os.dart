// Autogenerated by jni_gen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_element

import "dart:ffi" as ffi;

import "package:jni/jni.dart" as jni;

import "os/strictmode.dart" as strictmode;

import "package:content_plugin/android/content.dart" as content;
import "../init.dart" show jlookup;

/// Describes the source of some work that may be done by someone else.
/// Currently the public representation of what a work source is is not
/// defined; this is an opaque container.
class WorkSource extends jni.JlObject {
  WorkSource.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.os.WorkSource> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_WorkSource_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static Parcelable_Creator get CREATOR =>
      Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_WorkSource_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Create an empty work source.
  WorkSource() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_WorkSource_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.WorkSource orig)
  /// Create a new WorkSource that is a copy of an existing one.
  /// If <var>orig</var> is null, an empty WorkSource is created.
  WorkSource.ctor_1(WorkSource orig) : super.fromRef(_ctor_1(orig.reference));

  static final _clear =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_WorkSource_clear")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void clear()
  /// Clear this WorkSource to be empty.
  void clear() => _clear(reference);

  static final _equals_1 = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_WorkSource_equals_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object o)
  bool equals_1(jni.JlObject o) => _equals_1(reference, o.reference) != 0;

  static final _hashCode_1 =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_WorkSource_hashCode_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode_1() => _hashCode_1(reference);

  static final _diff = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_WorkSource_diff")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean diff(android.os.WorkSource other)
  /// Compare this WorkSource with another.
  ///@param other The WorkSource to compare against.
  ///@return If there is a difference, true is returned.
  bool diff(WorkSource other) => _diff(reference, other.reference) != 0;

  static final _set_ = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_WorkSource_set_")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void set(android.os.WorkSource other)
  /// Replace the current contents of this work source with the given
  /// work source.  If {@code other} is null, the current work source
  /// will be made empty.
  void set_(WorkSource other) => _set_(reference, other.reference);

  static final _add = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_WorkSource_add")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean add(android.os.WorkSource other)
  /// Merge the contents of <var>other</var> WorkSource in to this one.
  ///@param other The other WorkSource whose contents are to be merged.
  ///@return Returns true if any new sources were added.
  bool add(WorkSource other) => _add(reference, other.reference) != 0;

  static final _remove = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_WorkSource_remove")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean remove(android.os.WorkSource other)
  bool remove(WorkSource other) => _remove(reference, other.reference) != 0;

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_WorkSource_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_WorkSource_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _toString_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_WorkSource_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));
}

/// Parent exception for all Binder remote-invocation errors
class RemoteException extends jni.JlObject {
  RemoteException.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_RemoteException_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  RemoteException() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_RemoteException_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String message)
  RemoteException.ctor_1(jni.JlString message)
      : super.fromRef(_ctor_1(message.reference));
}

/// A VibrationEffect describes a haptic effect to be performed by a Vibrator.
///
/// These effects may be any number of things, from single shot vibrations to complex waveforms.
class VibrationEffect extends jni.JlObject {
  VibrationEffect.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.os.VibrationEffect> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_VibrationEffect_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static Parcelable_Creator get CREATOR =>
      Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int DEFAULT_AMPLITUDE
  /// The default vibration strength of the device.
  static const DEFAULT_AMPLITUDE = -1;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_VibrationEffect_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  /// @hide to prevent subclassing from outside of the framework
  VibrationEffect() : super.fromRef(_ctor());

  static final _createOneShot = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Int64,
                  ffi.Int32)>>("android_os_VibrationEffect_createOneShot")
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  /// from: static public android.os.VibrationEffect createOneShot(long milliseconds, int amplitude)
  /// Create a one shot vibration.
  ///
  /// One shot vibrations will vibrate constantly for the specified period of time at the
  /// specified amplitude, and then stop.
  ///@param milliseconds The number of milliseconds to vibrate. This must be a positive number.
  ///@param amplitude The strength of the vibration. This must be a value between 1 and 255, or
  /// \#DEFAULT_AMPLITUDE.
  ///@return The desired effect.
  static VibrationEffect createOneShot(int milliseconds, int amplitude) =>
      VibrationEffect.fromRef(_createOneShot(milliseconds, amplitude));

  static final _createWaveform = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_VibrationEffect_createWaveform")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.os.VibrationEffect createWaveform(long[] timings, int repeat)
  /// Create a waveform vibration.
  ///
  /// Waveform vibrations are a potentially repeating series of timing and amplitude pairs. For
  /// each pair, the value in the amplitude array determines the strength of the vibration and the
  /// value in the timing array determines how long it vibrates for. An amplitude of 0 implies no
  /// vibration (i.e. off), and any pairs with a timing value of 0 will be ignored.
  ///
  /// The amplitude array of the generated waveform will be the same size as the given
  /// timing array with alternating values of 0 (i.e. off) and \#DEFAULT_AMPLITUDE,
  /// starting with 0. Therefore the first timing value will be the period to wait before turning
  /// the vibrator on, the second value will be how long to vibrate at \#DEFAULT_AMPLITUDE
  /// strength, etc.
  ///
  ///
  /// To cause the pattern to repeat, pass the index into the timings array at which to start the
  /// repetition, or -1 to disable repeating.
  ///
  ///
  ///@param timings The pattern of alternating on-off timings, starting with off. Timing values
  ///                of 0 will cause the timing / amplitude pair to be ignored.
  ///@param repeat The index into the timings array at which to repeat, or -1 if you you don't
  ///               want to repeat.
  ///@return The desired effect.
  static VibrationEffect createWaveform(jni.JlObject timings, int repeat) =>
      VibrationEffect.fromRef(_createWaveform(timings.reference, repeat));

  static final _createWaveform_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_VibrationEffect_createWaveform_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.os.VibrationEffect createWaveform(long[] timings, int[] amplitudes, int repeat)
  /// Create a waveform vibration.
  ///
  /// Waveform vibrations are a potentially repeating series of timing and amplitude pairs. For
  /// each pair, the value in the amplitude array determines the strength of the vibration and the
  /// value in the timing array determines how long it vibrates for. An amplitude of 0 implies no
  /// vibration (i.e. off), and any pairs with a timing value of 0 will be ignored.
  ///
  ///
  /// To cause the pattern to repeat, pass the index into the timings array at which to start the
  /// repetition, or -1 to disable repeating.
  ///
  ///
  ///@param timings The timing values of the timing / amplitude pairs. Timing values of 0
  ///                will cause the pair to be ignored.
  ///@param amplitudes The amplitude values of the timing / amplitude pairs. Amplitude values
  ///                   must be between 0 and 255, or equal to \#DEFAULT_AMPLITUDE. An
  ///                   amplitude value of 0 implies the motor is off.
  ///@param repeat The index into the timings array at which to repeat, or -1 if you you don't
  ///               want to repeat.
  ///@return The desired effect.
  static VibrationEffect createWaveform_1(
          jni.JlObject timings, jni.JlObject amplitudes, int repeat) =>
      VibrationEffect.fromRef(
          _createWaveform_1(timings.reference, amplitudes.reference, repeat));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_VibrationEffect_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);
}

/// A simple pattern matcher, which is safe to use on untrusted data: it does
/// not provide full reg-exp support, only simple globbing that can not be
/// used maliciously.
class PatternMatcher extends jni.JlObject {
  PatternMatcher.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.os.PatternMatcher> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_PatternMatcher_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static Parcelable_Creator get CREATOR =>
      Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int PATTERN_ADVANCED_GLOB
  /// Pattern type: the given pattern is interpreted with a regular
  /// expression-like syntax for matching against the string it is tested
  /// against. Supported tokens include dot ({@code .}) and sets ({@code [...]})
  /// with full support for character ranges and the not ({@code ^}) modifier.
  /// Supported modifiers include star ({@code *}) for zero-or-more, plus ({@code +})
  /// for one-or-more and full range ({@code {...}}) support. This is a simple
  /// evaluation implementation in which matching is done against the pattern in
  /// real time with no backtracking support.
  static const PATTERN_ADVANCED_GLOB = 3;

  /// from: static public final int PATTERN_LITERAL
  /// Pattern type: the given pattern must exactly match the string it is
  /// tested against.
  static const PATTERN_LITERAL = 0;

  /// from: static public final int PATTERN_PREFIX
  /// Pattern type: the given pattern must match the
  /// beginning of the string it is tested against.
  static const PATTERN_PREFIX = 1;

  /// from: static public final int PATTERN_SIMPLE_GLOB
  /// Pattern type: the given pattern is interpreted with a
  /// simple glob syntax for matching against the string it is tested against.
  /// In this syntax, you can use the '*' character to match against zero or
  /// more occurrences of the character immediately before.  If the
  /// character before it is '.' it will match any character.  The character
  /// '\' can be used as an escape.  This essentially provides only the '*'
  /// wildcard part of a normal regexp.
  static const PATTERN_SIMPLE_GLOB = 2;

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_PatternMatcher_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String pattern, int type)
  PatternMatcher(jni.JlString pattern, int type)
      : super.fromRef(_ctor(pattern.reference, type));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_PatternMatcher_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel src)
  PatternMatcher.ctor_1(Parcel src) : super.fromRef(_ctor_1(src.reference));

  static final _getPath = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_PatternMatcher_getPath")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String getPath()
  jni.JlString getPath() => jni.JlString.fromRef(_getPath(reference));

  static final _getType =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_PatternMatcher_getType")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getType()
  int getType() => _getType(reference);

  static final _match = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_PatternMatcher_match")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean match(java.lang.String str)
  bool match(jni.JlString str) => _match(reference, str.reference) != 0;

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_PatternMatcher_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_PatternMatcher_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_PatternMatcher_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);
}

/// StrictMode is a developer tool which detects things you might be doing by accident and brings
/// them to your attention so you can fix them.
///
/// StrictMode is most commonly used to catch accidental disk or network access on the
/// application's main thread, where UI operations are received and animations take place. Keeping
/// disk and network operations off the main thread makes for much smoother, more responsive
/// applications. By keeping your application's main thread responsive, you also prevent <a href="{@docRoot}guide/practices/design/responsiveness.html">ANR dialogs</a> from being shown to
/// users.
///
/// <p class="note">Note that even though an Android device's disk is often on flash memory, many
/// devices run a filesystem on top of that memory with very limited concurrency. It's often the case
/// that almost all disk accesses are fast, but may in individual cases be dramatically slower when
/// certain I/O is happening in the background from other processes. If possible, it's best to assume
/// that such things are not fast.
///
/// Example code to enable from early in your android.app.Application, android.app.Activity, or other application component's android.app.Application\#onCreate
/// method:
///
/// <pre>
/// public void onCreate() {
///     if (DEVELOPER_MODE) {
///         StrictMode.setThreadPolicy(new ThreadPolicy.Builder StrictMode.ThreadPolicy.Builder()
///                 .detectDiskReads()
///                 .detectDiskWrites()
///                 .detectNetwork()   // or .detectAll() for all detectable problems
///                 .penaltyLog()
///                 .build());
///         StrictMode.setVmPolicy(new VmPolicy.Builder StrictMode.VmPolicy.Builder()
///                 .detectLeakedSqlLiteObjects()
///                 .detectLeakedClosableObjects()
///                 .penaltyLog()
///                 .penaltyDeath()
///                 .build());
///     }
///     super.onCreate();
/// }
/// </pre>
///
/// You can decide what should happen when a violation is detected. For example, using ThreadPolicy.Builder\#penaltyLog you can watch the output of <code>adb logcat</code> while you
/// use your application to see the violations as they happen.
///
/// If you find violations that you feel are problematic, there are a variety of tools to help
/// solve them: threads, android.os.Handler, android.os.AsyncTask, android.app.IntentService, etc. But don't feel compelled to fix everything that StrictMode
/// finds. In particular, many cases of disk access are often necessary during the normal activity
/// lifecycle. Use StrictMode to find things you did by accident. Network requests on the UI thread
/// are almost always a problem, though.
///
/// <p class="note">StrictMode is not a security mechanism and is not guaranteed to find all disk or
/// network accesses. While it does propagate its state across process boundaries when doing android.os.Binder calls, it's still ultimately a best effort mechanism. Notably, disk or network
/// access from JNI calls won't necessarily trigger it. Future versions of Android may catch more (or
/// fewer) operations, so you should never leave StrictMode enabled in applications distributed on
/// Google Play.
class StrictMode extends jni.JlObject {
  StrictMode.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_StrictMode_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  StrictMode() : super.fromRef(_ctor());

  static final _setThreadPolicy =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_StrictMode_setThreadPolicy")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void setThreadPolicy(android.os.StrictMode.ThreadPolicy policy)
  /// Sets the policy for what actions on the current thread should be detected, as well as the
  /// penalty if such actions occur.
  ///
  /// Internally this sets a thread-local variable which is propagated across cross-process IPC
  /// calls, meaning you can catch violations when a system service or another process accesses the
  /// disk or network on your behalf.
  ///@param policy the policy to put into place
  static void setThreadPolicy(StrictMode_ThreadPolicy policy) =>
      _setThreadPolicy(policy.reference);

  static final _getThreadPolicy =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_StrictMode_getThreadPolicy")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.os.StrictMode.ThreadPolicy getThreadPolicy()
  /// Returns the current thread's policy.
  static StrictMode_ThreadPolicy getThreadPolicy() =>
      StrictMode_ThreadPolicy.fromRef(_getThreadPolicy());

  static final _allowThreadDiskWrites =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_StrictMode_allowThreadDiskWrites")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.os.StrictMode.ThreadPolicy allowThreadDiskWrites()
  /// A convenience wrapper that takes the current ThreadPolicy from \#getThreadPolicy, modifies it to permit both disk reads &amp; writes, and sets the new
  /// policy with \#setThreadPolicy, returning the old policy so you can restore it at the
  /// end of a block.
  ///@return the old policy, to be passed to \#setThreadPolicy to restore the policy at the
  ///     end of a block
  static StrictMode_ThreadPolicy allowThreadDiskWrites() =>
      StrictMode_ThreadPolicy.fromRef(_allowThreadDiskWrites());

  static final _allowThreadDiskReads =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_StrictMode_allowThreadDiskReads")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.os.StrictMode.ThreadPolicy allowThreadDiskReads()
  /// A convenience wrapper that takes the current ThreadPolicy from \#getThreadPolicy, modifies it to permit disk reads, and sets the new policy with \#setThreadPolicy, returning the old policy so you can restore it at the end of a block.
  ///@return the old policy, to be passed to setThreadPolicy to restore the policy.
  static StrictMode_ThreadPolicy allowThreadDiskReads() =>
      StrictMode_ThreadPolicy.fromRef(_allowThreadDiskReads());

  static final _setVmPolicy =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_StrictMode_setVmPolicy")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void setVmPolicy(android.os.StrictMode.VmPolicy policy)
  /// Sets the policy for what actions in the VM process (on any thread) should be detected, as
  /// well as the penalty if such actions occur.
  ///@param policy the policy to put into place
  static void setVmPolicy(StrictMode_VmPolicy policy) =>
      _setVmPolicy(policy.reference);

  static final _getVmPolicy =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_StrictMode_getVmPolicy")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.os.StrictMode.VmPolicy getVmPolicy()
  /// Gets the current VM policy.
  static StrictMode_VmPolicy getVmPolicy() =>
      StrictMode_VmPolicy.fromRef(_getVmPolicy());

  static final _enableDefaults =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_StrictMode_enableDefaults")
          .asFunction<void Function()>();

  /// from: static public void enableDefaults()
  /// Enable the recommended StrictMode defaults, with violations just being logged.
  ///
  /// This catches disk and network access on the main thread, as well as leaked SQLite cursors
  /// and unclosed resources. This is simply a wrapper around \#setVmPolicy and \#setThreadPolicy.
  static void enableDefaults() => _enableDefaults();

  static final _noteSlowCall =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_StrictMode_noteSlowCall")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void noteSlowCall(java.lang.String name)
  /// For code to note that it's slow. This is a no-op unless the current thread's android.os.StrictMode.ThreadPolicy has android.os.StrictMode.ThreadPolicy.Builder\#detectCustomSlowCalls enabled.
  ///@param name a short string for the exception stack trace that's built if when this fires.
  static void noteSlowCall(jni.JlString name) => _noteSlowCall(name.reference);
}

/// StrictMode policy applied to all threads in the virtual machine's process.
///
/// The policy is enabled by \#setVmPolicy.
class StrictMode_VmPolicy extends jni.JlObject {
  StrictMode_VmPolicy.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.StrictMode.VmPolicy LAX
  /// The default, lax policy which doesn't catch anything.
  static final _getLAX =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_StrictMode__VmPolicy_LAX")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static StrictMode_VmPolicy get LAX => StrictMode_VmPolicy.fromRef(_getLAX());

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(int mask, java.util.HashMap<java.lang.Class,java.lang.Integer> classInstanceLimit, android.os.StrictMode.OnVmViolationListener listener, java.util.concurrent.Executor executor)
  StrictMode_VmPolicy(int mask, jni.JlObject classInstanceLimit,
      StrictMode_OnVmViolationListener listener, jni.JlObject executor)
      : super.fromRef(_ctor(mask, classInstanceLimit.reference,
            listener.reference, executor.reference));

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));
}

/// Creates VmPolicy instances. Methods whose names start with {@code detect} specify
/// what problems we should look for. Methods whose names start with {@code penalty} specify
/// what we should do when we detect a problem.
///
/// You can call as many {@code detect} and {@code penalty} methods as you like. Currently
/// order is insignificant: all penalties apply to all detected problems.
///
/// For example, detect everything and log anything that's found:
///
/// <pre>
/// StrictMode.VmPolicy policy = new StrictMode.VmPolicy.Builder()
///     .detectAll()
///     .penaltyLog()
///     .build();
/// StrictMode.setVmPolicy(policy);
/// </pre>
class StrictMode_VmPolicy_Builder extends jni.JlObject {
  StrictMode_VmPolicy_Builder.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_StrictMode__VmPolicy__Builder_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  StrictMode_VmPolicy_Builder() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.StrictMode.VmPolicy base)
  /// Build upon an existing VmPolicy.
  StrictMode_VmPolicy_Builder.ctor_1(StrictMode_VmPolicy base)
      : super.fromRef(_ctor_1(base.reference));

  static final _setClassInstanceLimit = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_os_StrictMode__VmPolicy__Builder_setClassInstanceLimit")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.os.StrictMode.VmPolicy.Builder setClassInstanceLimit(java.lang.Class klass, int instanceLimit)
  /// Set an upper bound on how many instances of a class can be in memory at once. Helps
  /// to prevent object leaks.
  StrictMode_VmPolicy_Builder setClassInstanceLimit(
          jni.JlObject klass, int instanceLimit) =>
      StrictMode_VmPolicy_Builder.fromRef(
          _setClassInstanceLimit(reference, klass.reference, instanceLimit));

  static final _detectActivityLeaks = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_detectActivityLeaks")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.VmPolicy.Builder detectActivityLeaks()
  /// Detect leaks of android.app.Activity subclasses.
  StrictMode_VmPolicy_Builder detectActivityLeaks() =>
      StrictMode_VmPolicy_Builder.fromRef(_detectActivityLeaks(reference));

  static final _detectNonSdkApiUsage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_detectNonSdkApiUsage")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.VmPolicy.Builder detectNonSdkApiUsage()
  /// Detect reflective usage of APIs that are not part of the public Android SDK.
  ///
  /// Note that any non-SDK APIs that this processes accesses before this detection is
  /// enabled may not be detected. To ensure that all such API accesses are detected,
  /// you should apply this policy as early as possible after process creation.
  StrictMode_VmPolicy_Builder detectNonSdkApiUsage() =>
      StrictMode_VmPolicy_Builder.fromRef(_detectNonSdkApiUsage(reference));

  static final _permitNonSdkApiUsage = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_permitNonSdkApiUsage")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.VmPolicy.Builder permitNonSdkApiUsage()
  /// Permit reflective usage of APIs that are not part of the public Android SDK. Note
  /// that this __only__ affects {@code StrictMode}, the underlying runtime may
  /// continue to restrict or warn on access to methods that are not part of the
  /// public SDK.
  StrictMode_VmPolicy_Builder permitNonSdkApiUsage() =>
      StrictMode_VmPolicy_Builder.fromRef(_permitNonSdkApiUsage(reference));

  static final _detectAll = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_detectAll")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.VmPolicy.Builder detectAll()
  /// Detect everything that's potentially suspect.
  ///
  /// In the Honeycomb release this includes leaks of SQLite cursors, Activities, and
  /// other closable objects but will likely expand in future releases.
  StrictMode_VmPolicy_Builder detectAll() =>
      StrictMode_VmPolicy_Builder.fromRef(_detectAll(reference));

  static final _detectLeakedSqlLiteObjects = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_detectLeakedSqlLiteObjects")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.VmPolicy.Builder detectLeakedSqlLiteObjects()
  /// Detect when an android.database.sqlite.SQLiteCursor or other SQLite object is
  /// finalized without having been closed.
  ///
  /// You always want to explicitly close your SQLite cursors to avoid unnecessary
  /// database contention and temporary memory leaks.
  StrictMode_VmPolicy_Builder detectLeakedSqlLiteObjects() =>
      StrictMode_VmPolicy_Builder.fromRef(
          _detectLeakedSqlLiteObjects(reference));

  static final _detectLeakedClosableObjects = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_detectLeakedClosableObjects")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.VmPolicy.Builder detectLeakedClosableObjects()
  /// Detect when an java.io.Closeable or other object with an explicit termination
  /// method is finalized without having been closed.
  ///
  /// You always want to explicitly close such objects to avoid unnecessary resources
  /// leaks.
  StrictMode_VmPolicy_Builder detectLeakedClosableObjects() =>
      StrictMode_VmPolicy_Builder.fromRef(
          _detectLeakedClosableObjects(reference));

  static final _detectLeakedRegistrationObjects = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_detectLeakedRegistrationObjects")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.VmPolicy.Builder detectLeakedRegistrationObjects()
  /// Detect when a BroadcastReceiver or ServiceConnection is leaked during
  /// Context teardown.
  StrictMode_VmPolicy_Builder detectLeakedRegistrationObjects() =>
      StrictMode_VmPolicy_Builder.fromRef(
          _detectLeakedRegistrationObjects(reference));

  static final _detectFileUriExposure = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_detectFileUriExposure")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.VmPolicy.Builder detectFileUriExposure()
  /// Detect when the calling application exposes a {@code file://} android.net.Uri
  /// to another app.
  ///
  /// This exposure is discouraged since the receiving app may not have access to the
  /// shared path. For example, the receiving app may not have requested the android.Manifest.permission\#READ_EXTERNAL_STORAGE runtime permission, or the
  /// platform may be sharing the android.net.Uri across user profile boundaries.
  ///
  /// Instead, apps should use {@code content://} Uris so the platform can extend
  /// temporary permission for the receiving app to access the resource.
  ///@see android.support.v4.content.FileProvider
  ///@see Intent\#FLAG_GRANT_READ_URI_PERMISSION
  StrictMode_VmPolicy_Builder detectFileUriExposure() =>
      StrictMode_VmPolicy_Builder.fromRef(_detectFileUriExposure(reference));

  static final _detectCleartextNetwork = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_detectCleartextNetwork")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.VmPolicy.Builder detectCleartextNetwork()
  /// Detect any network traffic from the calling app which is not wrapped in SSL/TLS. This
  /// can help you detect places that your app is inadvertently sending cleartext data
  /// across the network.
  ///
  /// Using \#penaltyDeath() or \#penaltyDeathOnCleartextNetwork() will
  /// block further traffic on that socket to prevent accidental data leakage, in addition
  /// to crashing your process.
  ///
  /// Using \#penaltyDropBox() will log the raw contents of the packet that
  /// triggered the violation.
  ///
  /// This inspects both IPv4/IPv6 and TCP/UDP network traffic, but it may be subject to
  /// false positives, such as when STARTTLS protocols or HTTP proxies are used.
  StrictMode_VmPolicy_Builder detectCleartextNetwork() =>
      StrictMode_VmPolicy_Builder.fromRef(_detectCleartextNetwork(reference));

  static final _detectContentUriWithoutPermission = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_detectContentUriWithoutPermission")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.VmPolicy.Builder detectContentUriWithoutPermission()
  /// Detect when the calling application sends a {@code content://} android.net.Uri to another app without setting Intent\#FLAG_GRANT_READ_URI_PERMISSION or Intent\#FLAG_GRANT_WRITE_URI_PERMISSION.
  ///
  /// Forgetting to include one or more of these flags when sending an intent is
  /// typically an app bug.
  ///@see Intent\#FLAG_GRANT_READ_URI_PERMISSION
  ///@see Intent\#FLAG_GRANT_WRITE_URI_PERMISSION
  StrictMode_VmPolicy_Builder detectContentUriWithoutPermission() =>
      StrictMode_VmPolicy_Builder.fromRef(
          _detectContentUriWithoutPermission(reference));

  static final _detectUntaggedSockets = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_detectUntaggedSockets")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.VmPolicy.Builder detectUntaggedSockets()
  /// Detect any sockets in the calling app which have not been tagged using TrafficStats. Tagging sockets can help you investigate network usage inside your
  /// app, such as a narrowing down heavy usage to a specific library or component.
  ///
  /// This currently does not detect sockets created in native code.
  ///@see TrafficStats\#setThreadStatsTag(int)
  ///@see TrafficStats\#tagSocket(java.net.Socket)
  ///@see TrafficStats\#tagDatagramSocket(java.net.DatagramSocket)
  StrictMode_VmPolicy_Builder detectUntaggedSockets() =>
      StrictMode_VmPolicy_Builder.fromRef(_detectUntaggedSockets(reference));

  static final _penaltyDeath = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_penaltyDeath")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.VmPolicy.Builder penaltyDeath()
  /// Crashes the whole process on violation. This penalty runs at the end of all enabled
  /// penalties so you'll still get your logging or other violations before the process
  /// dies.
  StrictMode_VmPolicy_Builder penaltyDeath() =>
      StrictMode_VmPolicy_Builder.fromRef(_penaltyDeath(reference));

  static final _penaltyDeathOnCleartextNetwork = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_penaltyDeathOnCleartextNetwork")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.VmPolicy.Builder penaltyDeathOnCleartextNetwork()
  /// Crashes the whole process when cleartext network traffic is detected.
  ///@see \#detectCleartextNetwork()
  StrictMode_VmPolicy_Builder penaltyDeathOnCleartextNetwork() =>
      StrictMode_VmPolicy_Builder.fromRef(
          _penaltyDeathOnCleartextNetwork(reference));

  static final _penaltyDeathOnFileUriExposure = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_penaltyDeathOnFileUriExposure")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.VmPolicy.Builder penaltyDeathOnFileUriExposure()
  /// Crashes the whole process when a {@code file://} android.net.Uri is exposed
  /// beyond this app.
  ///@see \#detectFileUriExposure()
  StrictMode_VmPolicy_Builder penaltyDeathOnFileUriExposure() =>
      StrictMode_VmPolicy_Builder.fromRef(
          _penaltyDeathOnFileUriExposure(reference));

  static final _penaltyLog = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_penaltyLog")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.VmPolicy.Builder penaltyLog()
  /// Log detected violations to the system log.
  StrictMode_VmPolicy_Builder penaltyLog() =>
      StrictMode_VmPolicy_Builder.fromRef(_penaltyLog(reference));

  static final _penaltyDropBox = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_penaltyDropBox")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.VmPolicy.Builder penaltyDropBox()
  /// Enable detected violations log a stacktrace and timing data to the android.os.DropBoxManager DropBox on policy violation. Intended mostly for platform
  /// integrators doing beta user field data collection.
  StrictMode_VmPolicy_Builder penaltyDropBox() =>
      StrictMode_VmPolicy_Builder.fromRef(_penaltyDropBox(reference));

  static final _penaltyListener = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_penaltyListener")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.VmPolicy.Builder penaltyListener(java.util.concurrent.Executor executor, android.os.StrictMode.OnVmViolationListener listener)
  /// Call \#OnVmViolationListener\#onVmViolation(Violation) on every violation.
  ///@param executor This value must never be {@code null}.
  ///@param listener This value must never be {@code null}.
  StrictMode_VmPolicy_Builder penaltyListener(
          jni.JlObject executor, StrictMode_OnVmViolationListener listener) =>
      StrictMode_VmPolicy_Builder.fromRef(
          _penaltyListener(reference, executor.reference, listener.reference));

  static final _build = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__VmPolicy__Builder_build")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.VmPolicy build()
  /// Construct the VmPolicy instance.
  ///
  /// Note: if no penalties are enabled before calling <code>build</code>, \#penaltyLog is implicitly set.
  StrictMode_VmPolicy build() => StrictMode_VmPolicy.fromRef(_build(reference));
}

/// StrictMode policy applied to a certain thread.
///
/// The policy is enabled by \#setThreadPolicy. The current policy can be retrieved
/// with \#getThreadPolicy.
///
/// Note that multiple penalties may be provided and they're run in order from least to most
/// severe (logging before process death, for example). There's currently no mechanism to choose
/// different penalties for different detected actions.
class StrictMode_ThreadPolicy extends jni.JlObject {
  StrictMode_ThreadPolicy.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final android.os.StrictMode.ThreadPolicy LAX
  /// The default, lax policy which doesn't catch anything.
  static final _getLAX =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_StrictMode__ThreadPolicy_LAX")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static StrictMode_ThreadPolicy get LAX =>
      StrictMode_ThreadPolicy.fromRef(_getLAX());

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(int mask, android.os.StrictMode.OnThreadViolationListener listener, java.util.concurrent.Executor executor)
  StrictMode_ThreadPolicy(int mask,
      StrictMode_OnThreadViolationListener listener, jni.JlObject executor)
      : super.fromRef(_ctor(mask, listener.reference, executor.reference));

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));
}

/// Creates ThreadPolicy instances. Methods whose names start with {@code detect}
/// specify what problems we should look for. Methods whose names start with {@code penalty}
/// specify what we should do when we detect a problem.
///
/// You can call as many {@code detect} and {@code penalty} methods as you like. Currently
/// order is insignificant: all penalties apply to all detected problems.
///
/// For example, detect everything and log anything that's found:
///
/// <pre>
/// StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder()
///     .detectAll()
///     .penaltyLog()
///     .build();
/// StrictMode.setThreadPolicy(policy);
/// </pre>
class StrictMode_ThreadPolicy_Builder extends jni.JlObject {
  StrictMode_ThreadPolicy_Builder.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_StrictMode__ThreadPolicy__Builder_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Create a Builder that detects nothing and has no violations. (but note that \#build will default to enabling \#penaltyLog if no other penalties are
  /// specified)
  StrictMode_ThreadPolicy_Builder() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.StrictMode.ThreadPolicy policy)
  /// Initialize a Builder from an existing ThreadPolicy.
  StrictMode_ThreadPolicy_Builder.ctor_1(StrictMode_ThreadPolicy policy)
      : super.fromRef(_ctor_1(policy.reference));

  static final _detectAll = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_detectAll")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder detectAll()
  /// Detect everything that's potentially suspect.
  ///
  /// As of the Gingerbread release this includes network and disk operations but will
  /// likely expand in future releases.
  StrictMode_ThreadPolicy_Builder detectAll() =>
      StrictMode_ThreadPolicy_Builder.fromRef(_detectAll(reference));

  static final _permitAll = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_permitAll")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder permitAll()
  /// Disable the detection of everything.
  StrictMode_ThreadPolicy_Builder permitAll() =>
      StrictMode_ThreadPolicy_Builder.fromRef(_permitAll(reference));

  static final _detectNetwork = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_detectNetwork")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder detectNetwork()
  /// Enable detection of network operations.
  StrictMode_ThreadPolicy_Builder detectNetwork() =>
      StrictMode_ThreadPolicy_Builder.fromRef(_detectNetwork(reference));

  static final _permitNetwork = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_permitNetwork")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder permitNetwork()
  /// Disable detection of network operations.
  StrictMode_ThreadPolicy_Builder permitNetwork() =>
      StrictMode_ThreadPolicy_Builder.fromRef(_permitNetwork(reference));

  static final _detectDiskReads = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_detectDiskReads")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder detectDiskReads()
  /// Enable detection of disk reads.
  StrictMode_ThreadPolicy_Builder detectDiskReads() =>
      StrictMode_ThreadPolicy_Builder.fromRef(_detectDiskReads(reference));

  static final _permitDiskReads = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_permitDiskReads")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder permitDiskReads()
  /// Disable detection of disk reads.
  StrictMode_ThreadPolicy_Builder permitDiskReads() =>
      StrictMode_ThreadPolicy_Builder.fromRef(_permitDiskReads(reference));

  static final _detectCustomSlowCalls = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_detectCustomSlowCalls")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder detectCustomSlowCalls()
  /// Enable detection of slow calls.
  StrictMode_ThreadPolicy_Builder detectCustomSlowCalls() =>
      StrictMode_ThreadPolicy_Builder.fromRef(
          _detectCustomSlowCalls(reference));

  static final _permitCustomSlowCalls = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_permitCustomSlowCalls")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder permitCustomSlowCalls()
  /// Disable detection of slow calls.
  StrictMode_ThreadPolicy_Builder permitCustomSlowCalls() =>
      StrictMode_ThreadPolicy_Builder.fromRef(
          _permitCustomSlowCalls(reference));

  static final _permitResourceMismatches = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_permitResourceMismatches")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder permitResourceMismatches()
  /// Disable detection of mismatches between defined resource types and getter calls.
  StrictMode_ThreadPolicy_Builder permitResourceMismatches() =>
      StrictMode_ThreadPolicy_Builder.fromRef(
          _permitResourceMismatches(reference));

  static final _detectUnbufferedIo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_detectUnbufferedIo")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder detectUnbufferedIo()
  /// Detect unbuffered input/output operations.
  StrictMode_ThreadPolicy_Builder detectUnbufferedIo() =>
      StrictMode_ThreadPolicy_Builder.fromRef(_detectUnbufferedIo(reference));

  static final _permitUnbufferedIo = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_permitUnbufferedIo")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder permitUnbufferedIo()
  /// Disable detection of unbuffered input/output operations.
  StrictMode_ThreadPolicy_Builder permitUnbufferedIo() =>
      StrictMode_ThreadPolicy_Builder.fromRef(_permitUnbufferedIo(reference));

  static final _detectResourceMismatches = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_detectResourceMismatches")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder detectResourceMismatches()
  /// Enables detection of mismatches between defined resource types and getter calls.
  ///
  /// This helps detect accidental type mismatches and potentially expensive type
  /// conversions when obtaining typed resources.
  ///
  /// For example, a strict mode violation would be thrown when calling android.content.res.TypedArray\#getInt(int, int) on an index that contains a
  /// String-type resource. If the string value can be parsed as an integer, this method
  /// call will return a value without crashing; however, the developer should format the
  /// resource as an integer to avoid unnecessary type conversion.
  StrictMode_ThreadPolicy_Builder detectResourceMismatches() =>
      StrictMode_ThreadPolicy_Builder.fromRef(
          _detectResourceMismatches(reference));

  static final _detectDiskWrites = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_detectDiskWrites")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder detectDiskWrites()
  /// Enable detection of disk writes.
  StrictMode_ThreadPolicy_Builder detectDiskWrites() =>
      StrictMode_ThreadPolicy_Builder.fromRef(_detectDiskWrites(reference));

  static final _permitDiskWrites = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_permitDiskWrites")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder permitDiskWrites()
  /// Disable detection of disk writes.
  StrictMode_ThreadPolicy_Builder permitDiskWrites() =>
      StrictMode_ThreadPolicy_Builder.fromRef(_permitDiskWrites(reference));

  static final _penaltyDialog = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_penaltyDialog")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder penaltyDialog()
  /// Show an annoying dialog to the developer on detected violations, rate-limited to be
  /// only a little annoying.
  StrictMode_ThreadPolicy_Builder penaltyDialog() =>
      StrictMode_ThreadPolicy_Builder.fromRef(_penaltyDialog(reference));

  static final _penaltyDeath = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_penaltyDeath")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder penaltyDeath()
  /// Crash the whole process on violation. This penalty runs at the end of all enabled
  /// penalties so you'll still get see logging or other violations before the process
  /// dies.
  ///
  /// Unlike \#penaltyDeathOnNetwork, this applies to disk reads, disk writes,
  /// and network usage if their corresponding detect flags are set.
  StrictMode_ThreadPolicy_Builder penaltyDeath() =>
      StrictMode_ThreadPolicy_Builder.fromRef(_penaltyDeath(reference));

  static final _penaltyDeathOnNetwork = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_penaltyDeathOnNetwork")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder penaltyDeathOnNetwork()
  /// Crash the whole process on any network usage. Unlike \#penaltyDeath, this
  /// penalty runs _before_ anything else. You must still have called \#detectNetwork to enable this.
  ///
  /// In the Honeycomb or later SDKs, this is on by default.
  StrictMode_ThreadPolicy_Builder penaltyDeathOnNetwork() =>
      StrictMode_ThreadPolicy_Builder.fromRef(
          _penaltyDeathOnNetwork(reference));

  static final _penaltyFlashScreen = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_penaltyFlashScreen")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder penaltyFlashScreen()
  /// Flash the screen during a violation.
  StrictMode_ThreadPolicy_Builder penaltyFlashScreen() =>
      StrictMode_ThreadPolicy_Builder.fromRef(_penaltyFlashScreen(reference));

  static final _penaltyLog = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_penaltyLog")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder penaltyLog()
  /// Log detected violations to the system log.
  StrictMode_ThreadPolicy_Builder penaltyLog() =>
      StrictMode_ThreadPolicy_Builder.fromRef(_penaltyLog(reference));

  static final _penaltyDropBox = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_penaltyDropBox")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder penaltyDropBox()
  /// Enable detected violations log a stacktrace and timing data to the android.os.DropBoxManager DropBox on policy violation. Intended mostly for platform
  /// integrators doing beta user field data collection.
  StrictMode_ThreadPolicy_Builder penaltyDropBox() =>
      StrictMode_ThreadPolicy_Builder.fromRef(_penaltyDropBox(reference));

  static final _penaltyListener = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_penaltyListener")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy.Builder penaltyListener(java.util.concurrent.Executor executor, android.os.StrictMode.OnThreadViolationListener listener)
  /// Call \#OnThreadViolationListener\#onThreadViolation(Violation) on specified
  /// executor every violation.
  ///@param executor This value must never be {@code null}.
  ///@param listener This value must never be {@code null}.
  StrictMode_ThreadPolicy_Builder penaltyListener(jni.JlObject executor,
          StrictMode_OnThreadViolationListener listener) =>
      StrictMode_ThreadPolicy_Builder.fromRef(
          _penaltyListener(reference, executor.reference, listener.reference));

  static final _build = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__ThreadPolicy__Builder_build")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.StrictMode.ThreadPolicy build()
  /// Construct the ThreadPolicy instance.
  ///
  /// Note: if no penalties are enabled before calling <code>build</code>, \#penaltyLog is implicitly set.
  StrictMode_ThreadPolicy build() =>
      StrictMode_ThreadPolicy.fromRef(_build(reference));
}

/// When \#VmPolicy.Builder\#penaltyListener is enabled, the listener is called on the
/// provided executor when a VM violation occurs.
class StrictMode_OnVmViolationListener extends jni.JlObject {
  StrictMode_OnVmViolationListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onVmViolation = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__OnVmViolationListener_onVmViolation")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onVmViolation(android.os.strictmode.Violation v)
  /// Called on a VM policy violation.
  void onVmViolation(strictmode.Violation v) =>
      _onVmViolation(reference, v.reference);
}

/// When \#ThreadPolicy.Builder\#penaltyListener is enabled, the listener is called on the
/// provided executor when a Thread violation occurs.
class StrictMode_OnThreadViolationListener extends jni.JlObject {
  StrictMode_OnThreadViolationListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onThreadViolation = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_StrictMode__OnThreadViolationListener_onThreadViolation")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onThreadViolation(android.os.strictmode.Violation v)
  /// Called on a thread policy violation.
  void onThreadViolation(strictmode.Violation v) =>
      _onThreadViolation(reference, v.reference);
}

/// Class that operates the vibrator on the device.
///
/// If your process exits, any vibration you started will stop.
///
///
class Vibrator extends jni.JlObject {
  Vibrator.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Vibrator_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  /// @hide to prevent subclassing from outside of the framework
  Vibrator() : super.fromRef(_ctor());

  static final _hasVibrator =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Vibrator_hasVibrator")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean hasVibrator()
  /// Check whether the hardware has a vibrator.
  ///@return True if the hardware has a vibrator, else false.
  bool hasVibrator() => _hasVibrator(reference) != 0;

  static final _hasAmplitudeControl =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Vibrator_hasAmplitudeControl")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean hasAmplitudeControl()
  /// Check whether the vibrator has amplitude control.
  ///@return True if the hardware can control the amplitude of the vibrations, otherwise false.
  bool hasAmplitudeControl() => _hasAmplitudeControl(reference) != 0;

  static final _vibrate = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_os_Vibrator_vibrate")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void vibrate(long milliseconds)
  /// Vibrate constantly for the specified period of time.
  ///
  /// Requires android.Manifest.permission\#VIBRATE
  ///@param milliseconds The number of milliseconds to vibrate.
  ///@deprecated Use \#vibrate(VibrationEffect) instead.
  void vibrate(int milliseconds) => _vibrate(reference, milliseconds);

  static final _vibrate_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("android_os_Vibrator_vibrate_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void vibrate(long milliseconds, android.media.AudioAttributes attributes)
  /// Vibrate constantly for the specified period of time.
  ///
  /// Requires android.Manifest.permission\#VIBRATE
  ///@param milliseconds The number of milliseconds to vibrate.
  ///@param attributes AudioAttributes corresponding to the vibration. For example,
  ///        specify AudioAttributes\#USAGE_ALARM for alarm vibrations or
  ///        AudioAttributes\#USAGE_NOTIFICATION_RINGTONE for
  ///        vibrations associated with incoming calls.
  ///@deprecated Use \#vibrate(VibrationEffect, AudioAttributes) instead.
  void vibrate_1(int milliseconds, jni.JlObject attributes) =>
      _vibrate_1(reference, milliseconds, attributes.reference);

  static final _vibrate_2 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Vibrator_vibrate_2")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void vibrate(long[] pattern, int repeat)
  /// Vibrate with a given pattern.
  ///
  ///
  /// Pass in an array of ints that are the durations for which to turn on or off
  /// the vibrator in milliseconds.  The first value indicates the number of milliseconds
  /// to wait before turning the vibrator on.  The next value indicates the number of milliseconds
  /// for which to keep the vibrator on before turning it off.  Subsequent values alternate
  /// between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
  ///
  ///
  /// To cause the pattern to repeat, pass the index into the pattern array at which
  /// to start the repeat, or -1 to disable repeating.
  ///
  ///
  ///
  /// Requires android.Manifest.permission\#VIBRATE
  ///@param pattern an array of longs of times for which to turn the vibrator on or off.
  ///@param repeat the index into pattern at which to repeat, or -1 if
  ///        you don't want to repeat.
  ///@deprecated Use \#vibrate(VibrationEffect) instead.
  void vibrate_2(jni.JlObject pattern, int repeat) =>
      _vibrate_2(reference, pattern.reference, repeat);

  static final _vibrate_3 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_os_Vibrator_vibrate_3")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void vibrate(long[] pattern, int repeat, android.media.AudioAttributes attributes)
  /// Vibrate with a given pattern.
  ///
  ///
  /// Pass in an array of ints that are the durations for which to turn on or off
  /// the vibrator in milliseconds.  The first value indicates the number of milliseconds
  /// to wait before turning the vibrator on.  The next value indicates the number of milliseconds
  /// for which to keep the vibrator on before turning it off.  Subsequent values alternate
  /// between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
  ///
  ///
  /// To cause the pattern to repeat, pass the index into the pattern array at which
  /// to start the repeat, or -1 to disable repeating.
  ///
  ///
  ///
  /// Requires android.Manifest.permission\#VIBRATE
  ///@param pattern an array of longs of times for which to turn the vibrator on or off.
  ///@param repeat the index into pattern at which to repeat, or -1 if
  ///        you don't want to repeat.
  ///@param attributes AudioAttributes corresponding to the vibration. For example,
  ///        specify AudioAttributes\#USAGE_ALARM for alarm vibrations or
  ///        AudioAttributes\#USAGE_NOTIFICATION_RINGTONE for
  ///        vibrations associated with incoming calls.
  ///@deprecated Use \#vibrate(VibrationEffect, AudioAttributes) instead.
  void vibrate_3(jni.JlObject pattern, int repeat, jni.JlObject attributes) =>
      _vibrate_3(reference, pattern.reference, repeat, attributes.reference);

  static final _vibrate_4 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Vibrator_vibrate_4")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void vibrate(android.os.VibrationEffect vibe)
  /// Requires android.Manifest.permission\#VIBRATE
  void vibrate_4(VibrationEffect vibe) => _vibrate_4(reference, vibe.reference);

  static final _vibrate_5 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Vibrator_vibrate_5")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void vibrate(android.os.VibrationEffect vibe, android.media.AudioAttributes attributes)
  /// Requires android.Manifest.permission\#VIBRATE
  void vibrate_5(VibrationEffect vibe, jni.JlObject attributes) =>
      _vibrate_5(reference, vibe.reference, attributes.reference);

  static final _cancel =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Vibrator_cancel")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void cancel()
  /// Turn the vibrator off.
  ///
  /// Requires android.Manifest.permission\#VIBRATE
  void cancel() => _cancel(reference);
}

/// A mapping from String keys to values of various types. In most cases, you
/// should work directly with either the Bundle or
/// PersistableBundle subclass.
class BaseBundle extends jni.JlObject {
  BaseBundle.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_BaseBundle_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  /// Constructs a new, empty Bundle.
  BaseBundle() : super.fromRef(_ctor());

  static final _size =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_BaseBundle_size")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int size()
  /// Returns the number of mappings contained in this Bundle.
  ///@return the number of mappings as an int.
  int size() => _size(reference);

  static final _isEmpty =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_BaseBundle_isEmpty")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isEmpty()
  /// Returns true if the mapping of this Bundle is empty, false otherwise.
  bool isEmpty() => _isEmpty(reference) != 0;

  static final _clear =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_BaseBundle_clear")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void clear()
  /// Removes all elements from the mapping of this Bundle.
  void clear() => _clear(reference);

  static final _containsKey = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_BaseBundle_containsKey")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean containsKey(java.lang.String key)
  /// Returns true if the given key is contained in the mapping
  /// of this Bundle.
  ///@param key a String key
  ///@return true if the key is part of the mapping, false otherwise
  bool containsKey(jni.JlString key) =>
      _containsKey(reference, key.reference) != 0;

  static final _get_ = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_BaseBundle_get_")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object get(java.lang.String key)
  /// Returns the entry with the given key as an object.
  ///@param key a String key
  ///@return an Object, or null
  jni.JlObject get_(jni.JlString key) =>
      jni.JlObject.fromRef(_get_(reference, key.reference));

  static final _remove = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_BaseBundle_remove")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void remove(java.lang.String key)
  /// Removes any entry with the given key from the mapping of this Bundle.
  ///@param key a String key
  void remove(jni.JlString key) => _remove(reference, key.reference);

  static final _keySet = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_BaseBundle_keySet")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Set<java.lang.String> keySet()
  /// Returns a Set containing the Strings used as keys in this Bundle.
  ///@return a Set of String keys
  jni.JlObject keySet() => jni.JlObject.fromRef(_keySet(reference));

  static final _putBoolean = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_os_BaseBundle_putBoolean")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void putBoolean(java.lang.String key, boolean value)
  /// Inserts a Boolean value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a boolean
  void putBoolean(jni.JlString key, bool value) =>
      _putBoolean(reference, key.reference, value ? 1 : 0);

  static final _putInt = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_BaseBundle_putInt")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void putInt(java.lang.String key, int value)
  /// Inserts an int value into the mapping of this Bundle, replacing
  /// any existing value for the given key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value an int
  void putInt(jni.JlString key, int value) =>
      _putInt(reference, key.reference, value);

  static final _putLong = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_os_BaseBundle_putLong")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void putLong(java.lang.String key, long value)
  /// Inserts a long value into the mapping of this Bundle, replacing
  /// any existing value for the given key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a long
  void putLong(jni.JlString key, int value) =>
      _putLong(reference, key.reference, value);

  static final _putDouble = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Double)>>("android_os_BaseBundle_putDouble")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, double)>();

  /// from: public void putDouble(java.lang.String key, double value)
  /// Inserts a double value into the mapping of this Bundle, replacing
  /// any existing value for the given key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a double
  void putDouble(jni.JlString key, double value) =>
      _putDouble(reference, key.reference, value);

  static final _putString = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_BaseBundle_putString")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putString(java.lang.String key, java.lang.String value)
  /// Inserts a String value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a String, or null
  ///
  /// This value may be {@code null}.
  void putString(jni.JlString key, jni.JlString value) =>
      _putString(reference, key.reference, value.reference);

  static final _putBooleanArray = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_BaseBundle_putBooleanArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putBooleanArray(java.lang.String key, boolean[] value)
  /// Inserts a boolean array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a boolean array object, or null
  ///
  /// This value may be {@code null}.
  void putBooleanArray(jni.JlString key, jni.JlObject value) =>
      _putBooleanArray(reference, key.reference, value.reference);

  static final _putIntArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_BaseBundle_putIntArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putIntArray(java.lang.String key, int[] value)
  /// Inserts an int array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value an int array object, or null
  ///
  /// This value may be {@code null}.
  void putIntArray(jni.JlString key, jni.JlObject value) =>
      _putIntArray(reference, key.reference, value.reference);

  static final _putLongArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_BaseBundle_putLongArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putLongArray(java.lang.String key, long[] value)
  /// Inserts a long array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a long array object, or null
  ///
  /// This value may be {@code null}.
  void putLongArray(jni.JlString key, jni.JlObject value) =>
      _putLongArray(reference, key.reference, value.reference);

  static final _putDoubleArray = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_BaseBundle_putDoubleArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putDoubleArray(java.lang.String key, double[] value)
  /// Inserts a double array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a double array object, or null
  ///
  /// This value may be {@code null}.
  void putDoubleArray(jni.JlString key, jni.JlObject value) =>
      _putDoubleArray(reference, key.reference, value.reference);

  static final _putStringArray = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_BaseBundle_putStringArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putStringArray(java.lang.String key, java.lang.String[] value)
  /// Inserts a String array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a String array object, or null
  ///
  /// This value may be {@code null}.
  void putStringArray(jni.JlString key, jni.JlObject value) =>
      _putStringArray(reference, key.reference, value.reference);

  static final _getBoolean = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_BaseBundle_getBoolean")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getBoolean(java.lang.String key)
  /// Returns the value associated with the given key, or false if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@return a boolean value
  bool getBoolean(jni.JlString key) =>
      _getBoolean(reference, key.reference) != 0;

  static final _getBoolean_1 = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_os_BaseBundle_getBoolean_1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean getBoolean(java.lang.String key, boolean defaultValue)
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@param defaultValue Value to return if key does not exist
  ///@return a boolean value
  bool getBoolean_1(jni.JlString key, bool defaultValue) =>
      _getBoolean_1(reference, key.reference, defaultValue ? 1 : 0) != 0;

  static final _getInt = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_BaseBundle_getInt")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getInt(java.lang.String key)
  /// Returns the value associated with the given key, or 0 if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@return an int value
  int getInt(jni.JlString key) => _getInt(reference, key.reference);

  static final _getInt_1 = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_BaseBundle_getInt_1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getInt(java.lang.String key, int defaultValue)
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@param defaultValue Value to return if key does not exist
  ///@return an int value
  int getInt_1(jni.JlString key, int defaultValue) =>
      _getInt_1(reference, key.reference, defaultValue);

  static final _getLong = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_BaseBundle_getLong")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public long getLong(java.lang.String key)
  /// Returns the value associated with the given key, or 0L if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@return a long value
  int getLong(jni.JlString key) => _getLong(reference, key.reference);

  static final _getLong_1 = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_os_BaseBundle_getLong_1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public long getLong(java.lang.String key, long defaultValue)
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@param defaultValue Value to return if key does not exist
  ///@return a long value
  int getLong_1(jni.JlString key, int defaultValue) =>
      _getLong_1(reference, key.reference, defaultValue);

  static final _getDouble = jlookup<
          ffi.NativeFunction<
              ffi.Double Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_BaseBundle_getDouble")
      .asFunction<
          double Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public double getDouble(java.lang.String key)
  /// Returns the value associated with the given key, or 0.0 if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@return a double value
  double getDouble(jni.JlString key) => _getDouble(reference, key.reference);

  static final _getDouble_1 = jlookup<
          ffi.NativeFunction<
              ffi.Double Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Double)>>("android_os_BaseBundle_getDouble_1")
      .asFunction<
          double Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, double)>();

  /// from: public double getDouble(java.lang.String key, double defaultValue)
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@param defaultValue Value to return if key does not exist
  ///@return a double value
  double getDouble_1(jni.JlString key, double defaultValue) =>
      _getDouble_1(reference, key.reference, defaultValue);

  static final _getString = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_BaseBundle_getString")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getString(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a String value, or null
  jni.JlString getString(jni.JlString key) =>
      jni.JlString.fromRef(_getString(reference, key.reference));

  static final _getString_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_BaseBundle_getString_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getString(java.lang.String key, java.lang.String defaultValue)
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key or if a null
  /// value is explicitly associated with the given key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param defaultValue Value to return if key does not exist or if a null
  ///     value is associated with the given key.
  ///@return the String value associated with the given key, or defaultValue
  ///     if no valid String object is currently mapped to that key.
  jni.JlString getString_1(jni.JlString key, jni.JlString defaultValue) =>
      jni.JlString.fromRef(
          _getString_1(reference, key.reference, defaultValue.reference));

  static final _getBooleanArray = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_BaseBundle_getBooleanArray")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean[] getBooleanArray(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a boolean[] value, or null
  jni.JlObject getBooleanArray(jni.JlString key) =>
      jni.JlObject.fromRef(_getBooleanArray(reference, key.reference));

  static final _getIntArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_BaseBundle_getIntArray")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int[] getIntArray(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return an int[] value, or null
  jni.JlObject getIntArray(jni.JlString key) =>
      jni.JlObject.fromRef(_getIntArray(reference, key.reference));

  static final _getLongArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_BaseBundle_getLongArray")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public long[] getLongArray(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a long[] value, or null
  jni.JlObject getLongArray(jni.JlString key) =>
      jni.JlObject.fromRef(_getLongArray(reference, key.reference));

  static final _getDoubleArray = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_BaseBundle_getDoubleArray")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public double[] getDoubleArray(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a double[] value, or null
  jni.JlObject getDoubleArray(jni.JlString key) =>
      jni.JlObject.fromRef(_getDoubleArray(reference, key.reference));

  static final _getStringArray = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_BaseBundle_getStringArray")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getStringArray(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a String[] value, or null
  jni.JlObject getStringArray(jni.JlString key) =>
      jni.JlObject.fromRef(_getStringArray(reference, key.reference));
}

/// RecoverySystem contains methods for interacting with the Android
/// recovery system (the separate partition that can be used to install
/// system updates, wipe user data, etc.)
class RecoverySystem extends jni.JlObject {
  RecoverySystem.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_RecoverySystem_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  /// @removed Was previously made visible by accident.
  RecoverySystem() : super.fromRef(_ctor());

  static final _verifyPackage = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_RecoverySystem_verifyPackage")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void verifyPackage(java.io.File packageFile, android.os.RecoverySystem.ProgressListener listener, java.io.File deviceCertsZipFile)
  /// Verify the cryptographic signature of a system update package
  /// before installing it.  Note that the package is also verified
  /// separately by the installer once the device is rebooted into
  /// the recovery system.  This function will return only if the
  /// package was successfully verified; otherwise it will throw an
  /// exception.
  ///
  /// Verification of a package can take significant time, so this
  /// function should not be called from a UI thread.  Interrupting
  /// the thread while this function is in progress will result in a
  /// SecurityException being thrown (and the thread's interrupt flag
  /// will be cleared).
  ///@param packageFile the package to be verified
  ///@param listener an object to receive periodic progress
  /// updates as verification proceeds.  May be null.
  ///@param deviceCertsZipFile the zip file of certificates whose
  /// public keys we will accept.  Verification succeeds if the
  /// package is signed by the private key corresponding to any
  /// public key in this file.  May be null to use the system default
  /// file (currently "/system/etc/security/otacerts.zip").
  ///@throws IOException if there were any errors reading the
  /// package or certs files.
  ///@throws GeneralSecurityException if verification failed
  static void verifyPackage(
          jni.JlObject packageFile,
          RecoverySystem_ProgressListener listener,
          jni.JlObject deviceCertsZipFile) =>
      _verifyPackage(packageFile.reference, listener.reference,
          deviceCertsZipFile.reference);

  static final _installPackage = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_RecoverySystem_installPackage")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void installPackage(android.content.Context context, java.io.File packageFile)
  /// Reboots the device in order to install the given update
  /// package.
  /// Requires the android.Manifest.permission\#REBOOT permission.
  ///
  /// Requires android.Manifest.permission\#RECOVERY
  ///@param context the Context to use
  ///@param packageFile the update package to install.  Must be on
  /// a partition mountable by recovery.  (The set of partitions
  /// known to recovery may vary from device to device.  Generally,
  /// /cache and /data are safe.)
  ///@throws IOException if writing the recovery command file
  /// fails, or if the reboot itself fails.
  static void installPackage(
          content.Context context, jni.JlObject packageFile) =>
      _installPackage(context.reference, packageFile.reference);

  static final _rebootWipeUserData =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_RecoverySystem_rebootWipeUserData")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void rebootWipeUserData(android.content.Context context)
  /// Reboots the device and wipes the user data and cache
  /// partitions.  This is sometimes called a "factory reset", which
  /// is something of a misnomer because the system partition is not
  /// restored to its factory state.  Requires the
  /// android.Manifest.permission\#REBOOT permission.
  ///@param context the Context to use
  ///@throws IOException if writing the recovery command file
  /// fails, or if the reboot itself fails.
  ///@throws SecurityException if the current user is not allowed to wipe data.
  static void rebootWipeUserData(content.Context context) =>
      _rebootWipeUserData(context.reference);

  static final _rebootWipeCache =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_RecoverySystem_rebootWipeCache")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void rebootWipeCache(android.content.Context context)
  /// Reboot into the recovery system to wipe the /cache partition.
  ///@throws IOException if something goes wrong.
  static void rebootWipeCache(content.Context context) =>
      _rebootWipeCache(context.reference);
}

/// Interface definition for a callback to be invoked regularly as
/// verification proceeds.
class RecoverySystem_ProgressListener extends jni.JlObject {
  RecoverySystem_ProgressListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onProgress = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_os_RecoverySystem__ProgressListener_onProgress")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void onProgress(int progress)
  /// Called periodically as the verification progresses.
  ///@param progress the approximate percentage of the
  ///        verification that has been completed, ranging from 0
  ///        to 100 (inclusive).
  void onProgress(int progress) => _onProgress(reference, progress);
}

/// Base interface for a remotable object, the core part of a lightweight
/// remote procedure call mechanism designed for high performance when
/// performing in-process and cross-process calls.  This
/// interface describes the abstract protocol for interacting with a
/// remotable object.  Do not implement this interface directly, instead
/// extend from Binder.
///
/// The key IBinder API is \#transact transact() matched by
/// Binder\#onTransact Binder.onTransact().  These
/// methods allow you to send a call to an IBinder object and receive a
/// call coming in to a Binder object, respectively.  This transaction API
/// is synchronous, such that a call to \#transact transact() does not
/// return until the target has returned from
/// Binder\#onTransact Binder.onTransact(); this is the
/// expected behavior when calling an object that exists in the local
/// process, and the underlying inter-process communication (IPC) mechanism
/// ensures that these same semantics apply when going across processes.
///
/// The data sent through transact() is a Parcel, a generic buffer
/// of data that also maintains some meta-data about its contents.  The meta
/// data is used to manage IBinder object references in the buffer, so that those
/// references can be maintained as the buffer moves across processes.  This
/// mechanism ensures that when an IBinder is written into a Parcel and sent to
/// another process, if that other process sends a reference to that same IBinder
/// back to the original process, then the original process will receive the
/// same IBinder object back.  These semantics allow IBinder/Binder objects to
/// be used as a unique identity (to serve as a token or for other purposes)
/// that can be managed across processes.
///
/// The system maintains a pool of transaction threads in each process that
/// it runs in.  These threads are used to dispatch all
/// IPCs coming in from other processes.  For example, when an IPC is made from
/// process A to process B, the calling thread in A blocks in transact() as
/// it sends the transaction to process B.  The next available pool thread in
/// B receives the incoming transaction, calls Binder.onTransact() on the target
/// object, and replies with the result Parcel.  Upon receiving its result, the
/// thread in process A returns to allow its execution to continue.  In effect,
/// other processes appear to use as additional threads that you did not create
/// executing in your own process.
///
/// The Binder system also supports recursion across processes.  For example
/// if process A performs a transaction to process B, and process B while
/// handling that transaction calls transact() on an IBinder that is implemented
/// in A, then the thread in A that is currently waiting for the original
/// transaction to finish will take care of calling Binder.onTransact() on the
/// object being called by B.  This ensures that the recursion semantics when
/// calling remote binder object are the same as when calling local objects.
///
/// When working with remote objects, you often want to find out when they
/// are no longer valid.  There are three ways this can be determined:
/// <ul>
/// <li> The \#transact transact() method will throw a
/// RemoteException exception if you try to call it on an IBinder
/// whose process no longer exists.
/// <li> The \#pingBinder() method can be called, and will return false
/// if the remote process no longer exists.
/// <li> The \#linkToDeath linkToDeath() method can be used to register
/// a DeathRecipient with the IBinder, which will be called when its
/// containing process goes away.
/// </ul>
///@see Binder
class IBinder extends jni.JlObject {
  IBinder.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int DUMP_TRANSACTION
  /// IBinder protocol transaction code: dump internal state.
  static const DUMP_TRANSACTION = 1598311760;

  /// from: static public final int FIRST_CALL_TRANSACTION
  /// The first transaction code available for user commands.
  static const FIRST_CALL_TRANSACTION = 1;

  /// from: static public final int FLAG_ONEWAY
  /// Flag to \#transact: this is a one-way call, meaning that the
  /// caller returns immediately, without waiting for a result from the
  /// callee. Applies only if the caller and callee are in different
  /// processes.
  ///
  /// The system provides special ordering semantics for multiple oneway calls
  /// being made to the same IBinder object: these calls will be dispatched in the
  /// other process one at a time, with the same order as the original calls.  These
  /// are still dispatched by the IPC thread pool, so may execute on different threads,
  /// but the next one will not be dispatched until the previous one completes.  This
  /// ordering is not guaranteed for calls on different IBinder objects or when mixing
  /// oneway and non-oneway calls on the same IBinder object.
  ///
  static const FLAG_ONEWAY = 1;

  /// from: static public final int INTERFACE_TRANSACTION
  /// IBinder protocol transaction code: interrogate the recipient side
  /// of the transaction for its canonical interface descriptor.
  static const INTERFACE_TRANSACTION = 1598968902;

  /// from: static public final int LAST_CALL_TRANSACTION
  /// The last transaction code available for user commands.
  static const LAST_CALL_TRANSACTION = 16777215;

  /// from: static public final int LIKE_TRANSACTION
  /// IBinder protocol transaction code: tell an app asynchronously that the
  /// caller likes it.  The app is responsible for incrementing and maintaining
  /// its own like counter, and may display this value to the user to indicate the
  /// quality of the app.  This is an optional command that applications do not
  /// need to handle, so the default implementation is to do nothing.
  ///
  /// There is no response returned and nothing about the
  /// system will be functionally affected by it, but it will improve the
  /// app's self-esteem.
  static const LIKE_TRANSACTION = 1598835019;

  /// from: static public final int PING_TRANSACTION
  /// IBinder protocol transaction code: pingBinder().
  static const PING_TRANSACTION = 1599098439;

  /// from: static public final int TWEET_TRANSACTION
  /// IBinder protocol transaction code: send a tweet to the target
  /// object.  The data in the parcel is intended to be delivered to
  /// a shared messaging service associated with the object; it can be
  /// anything, as long as it is not more than 130 UTF-8 characters to
  /// conservatively fit within common messaging services.  As part of
  /// Build.VERSION_CODES\#HONEYCOMB_MR2, all Binder objects are
  /// expected to support this protocol for fully integrated tweeting
  /// across the platform.  To support older code, the default implementation
  /// logs the tweet to the main log as a simple emulation of broadcasting
  /// it publicly over the Internet.
  ///
  /// Also, upon completing the dispatch, the object must make a cup
  /// of tea, return it to the caller, and exclaim "jolly good message
  /// old boy!".
  static const TWEET_TRANSACTION = 1599362900;

  static final _getInterfaceDescriptor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_IBinder_getInterfaceDescriptor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getInterfaceDescriptor()
  /// Get the canonical name of the interface supported by this binder.
  ///@return This value may be {@code null}.
  jni.JlString getInterfaceDescriptor() =>
      jni.JlString.fromRef(_getInterfaceDescriptor(reference));

  static final _pingBinder =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_IBinder_pingBinder")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean pingBinder()
  /// Check to see if the object still exists.
  ///@return Returns false if the
  /// hosting process is gone, otherwise the result (always by default
  /// true) returned by the pingBinder() implementation on the other
  /// side.
  bool pingBinder() => _pingBinder(reference) != 0;

  static final _isBinderAlive =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_IBinder_isBinderAlive")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isBinderAlive()
  /// Check to see if the process that the binder is in is still alive.
  ///@return false if the process is not alive.  Note that if it returns
  /// true, the process may have died while the call is returning.
  bool isBinderAlive() => _isBinderAlive(reference) != 0;

  static final _queryLocalInterface = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_IBinder_queryLocalInterface")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.os.IInterface queryLocalInterface(java.lang.String descriptor)
  /// Attempt to retrieve a local implementation of an interface
  /// for this Binder object.  If null is returned, you will need
  /// to instantiate a proxy class to marshall calls through
  /// the transact() method.
  ///@param descriptor This value must never be {@code null}.
  IInterface queryLocalInterface(jni.JlString descriptor) =>
      IInterface.fromRef(_queryLocalInterface(reference, descriptor.reference));

  static final _dump = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_IBinder_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void dump(java.io.FileDescriptor fd, java.lang.String[] args)
  /// Print the object's state into the given stream.
  ///@param fd The raw file descriptor that the dump is being sent to.
  /// This value must never be {@code null}.
  ///@param args additional arguments to the dump request.
  ///
  /// This value may be {@code null}.
  void dump(jni.JlObject fd, jni.JlObject args) =>
      _dump(reference, fd.reference, args.reference);

  static final _dumpAsync = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_IBinder_dumpAsync")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void dumpAsync(java.io.FileDescriptor fd, java.lang.String[] args)
  /// Like \#dump(FileDescriptor, String[]) but always executes
  /// asynchronously.  If the object is local, a new thread is created
  /// to perform the dump.
  ///@param fd The raw file descriptor that the dump is being sent to.
  /// This value must never be {@code null}.
  ///@param args additional arguments to the dump request.
  ///
  /// This value may be {@code null}.
  void dumpAsync(jni.JlObject fd, jni.JlObject args) =>
      _dumpAsync(reference, fd.reference, args.reference);

  static final _transact = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_IBinder_transact")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract boolean transact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)
  /// Perform a generic operation with the object.
  ///@param code The action to perform.  This should
  /// be a number between \#FIRST_CALL_TRANSACTION and
  /// \#LAST_CALL_TRANSACTION.
  ///@param data Marshalled data to send to the target.  Must not be null.
  /// If you are not sending any data, you must create an empty Parcel
  /// that is given here.
  /// This value must never be {@code null}.
  ///@param reply Marshalled data to be received from the target.  May be
  /// null if you are not interested in the return value.
  /// This value may be {@code null}.
  ///@param flags Additional operation flags.  Either 0 for a normal
  /// RPC, or \#FLAG_ONEWAY for a one-way RPC.
  ///@return Returns the result from Binder\#onTransact.  A successful call
  /// generally returns true; false generally means the transaction code was not
  /// understood.
  bool transact(int code, Parcel data, Parcel reply, int flags) =>
      _transact(reference, code, data.reference, reply.reference, flags) != 0;

  static final _linkToDeath = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_IBinder_linkToDeath")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void linkToDeath(android.os.IBinder.DeathRecipient recipient, int flags)
  /// Register the recipient for a notification if this binder
  /// goes away.  If this binder object unexpectedly goes away
  /// (typically because its hosting process has been killed),
  /// then the given DeathRecipient's
  /// DeathRecipient\#binderDied DeathRecipient.binderDied() method
  /// will be called.
  ///
  /// You will only receive death notifications for remote binders,
  /// as local binders by definition can't die without you dying as well.
  ///@throws RemoteException if the target IBinder's
  /// process has already died.
  ///@see \#unlinkToDeath
  ///@param recipient This value must never be {@code null}.
  void linkToDeath(IBinder_DeathRecipient recipient, int flags) =>
      _linkToDeath(reference, recipient.reference, flags);

  static final _unlinkToDeath = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_IBinder_unlinkToDeath")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract boolean unlinkToDeath(android.os.IBinder.DeathRecipient recipient, int flags)
  /// Remove a previously registered death notification.
  /// The recipient will no longer be called if this object
  /// dies.
  ///@param recipient This value must never be {@code null}.
  ///@return {@code true} if the <var>recipient</var> is successfully
  /// unlinked, assuring you that its
  /// DeathRecipient\#binderDied DeathRecipient.binderDied() method
  /// will not be called;  {@code false} if the target IBinder has already
  /// died, meaning the method has been (or soon will be) called.
  ///@throws java.util.NoSuchElementException if the given
  /// <var>recipient</var> has not been registered with the IBinder, and
  /// the IBinder is still alive.  Note that if the <var>recipient</var>
  /// was never registered, but the IBinder has already died, then this
  /// exception will _not_ be thrown, and you will receive a false
  /// return value instead.
  bool unlinkToDeath(IBinder_DeathRecipient recipient, int flags) =>
      _unlinkToDeath(reference, recipient.reference, flags) != 0;
}

/// Interface for receiving a callback when the process hosting an IBinder
/// has gone away.
///@see \#linkToDeath
class IBinder_DeathRecipient extends jni.JlObject {
  IBinder_DeathRecipient.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _binderDied =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_IBinder__DeathRecipient_binderDied")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void binderDied()
  void binderDied() => _binderDied(reference);
}

/// Blocks a looper from executing any messages, and allows the holder of this object
/// to control when and which messages get executed until it is released.
///
/// A TestLooperManager should be acquired using
/// android.app.Instrumentation\#acquireLooperManager. Until \#release() is called,
/// the Looper thread will not execute any messages except when \#execute(Message) is called.
/// The test code may use \#next() to acquire messages that have been queued to this
/// Looper/MessageQueue and then \#execute to run any that desires.
class TestLooperManager extends jni.JlObject {
  TestLooperManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_TestLooperManager_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Looper looper)
  /// @hide
  TestLooperManager(Looper looper) : super.fromRef(_ctor(looper.reference));

  static final _getMessageQueue = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_TestLooperManager_getMessageQueue")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.MessageQueue getMessageQueue()
  /// Returns the MessageQueue this object is wrapping.
  MessageQueue getMessageQueue() =>
      MessageQueue.fromRef(_getMessageQueue(reference));

  static final _next = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_TestLooperManager_next")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Message next()
  /// Returns the next message that should be executed by this queue, may block
  /// if no messages are ready.
  ///
  /// Callers should always call \#recycle(Message) on the message when all
  /// interactions with it have completed.
  Message next() => Message.fromRef(_next(reference));

  static final _release =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_TestLooperManager_release")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void release()
  /// Releases the looper to continue standard looping and processing of messages,
  /// no further interactions with TestLooperManager will be allowed after
  /// release() has been called.
  void release() => _release(reference);

  static final _execute = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_TestLooperManager_execute")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void execute(android.os.Message message)
  /// Executes the given message on the Looper thread this wrapper is
  /// attached to.
  ///
  /// Execution will happen on the Looper's thread (whether it is the current thread
  /// or not), but all RuntimeExceptions encountered while executing the message will
  /// be thrown on the calling thread.
  void execute(Message message) => _execute(reference, message.reference);

  static final _recycle = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_TestLooperManager_recycle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void recycle(android.os.Message msg)
  /// Called to indicate that a Message returned by \#next() has been parsed
  /// and should be recycled.
  void recycle(Message msg) => _recycle(reference, msg.reference);

  static final _hasMessages = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_TestLooperManager_hasMessages")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean hasMessages(android.os.Handler h, java.lang.Object object, int what)
  /// Returns true if there are any queued messages that match the parameters.
  ///@param h the value of Message\#getTarget()
  ///@param what the value of Message\#what
  ///@param object the value of Message\#obj, null for any
  bool hasMessages(Handler h, jni.JlObject object, int what) =>
      _hasMessages(reference, h.reference, object.reference, what) != 0;

  static final _hasMessages_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_os_TestLooperManager_hasMessages_1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasMessages(android.os.Handler h, java.lang.Object object, java.lang.Runnable r)
  /// Returns true if there are any queued messages that match the parameters.
  ///@param h the value of Message\#getTarget()
  ///@param r the value of Message\#getCallback()
  ///@param object the value of Message\#obj, null for any
  bool hasMessages_1(Handler h, jni.JlObject object, jni.JlObject r) =>
      _hasMessages_1(reference, h.reference, object.reference, r.reference) !=
      0;
}

/// AsyncTask enables proper and easy use of the UI thread. This class allows you
/// to perform background operations and publish results on the UI thread without
/// having to manipulate threads and/or handlers.
///
///
/// AsyncTask is designed to be a helper class around Thread and Handler
/// and does not constitute a generic threading framework. AsyncTasks should ideally be
/// used for short operations (a few seconds at the most.) If you need to keep threads
/// running for long periods of time, it is highly recommended you use the various APIs
/// provided by the <code>java.util.concurrent</code> package such as Executor,
/// ThreadPoolExecutor and FutureTask.
///
///
/// An asynchronous task is defined by a computation that runs on a background thread and
/// whose result is published on the UI thread. An asynchronous task is defined by 3 generic
/// types, called <code>Params</code>, <code>Progress</code> and <code>Result</code>,
/// and 4 steps, called <code>onPreExecute</code>, <code>doInBackground</code>,
/// <code>onProgressUpdate</code> and <code>onPostExecute</code>.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using tasks and threads, read the
/// <a href="{@docRoot}guide/components/processes-and-threads.html">Processes and
/// Threads</a> developer guide.
///
/// </div>
///
/// <h2>Usage</h2>
/// AsyncTask must be subclassed to be used. The subclass will override at least
/// one method (\#doInBackground), and most often will override a
/// second one (\#onPostExecute.)
///
///
/// Here is an example of subclassing:
///
/// <pre class="prettyprint">
/// private class DownloadFilesTask extends AsyncTask&lt;URL, Integer, Long&gt; {
///     protected Long doInBackground(URL... urls) {
///         int count = urls.length;
///         long totalSize = 0;
///         for (int i = 0; i < count; i++) {
///             totalSize += Downloader.downloadFile(urls[i]);
///             publishProgress((int) ((i / (float) count) * 100));
///             // Escape early if cancel() is called
///             if (isCancelled()) break;
///         }
///         return totalSize;
///     }
///
///     protected void onProgressUpdate(Integer... progress) {
///         setProgressPercent(progress[0]);
///     }
///
///     protected void onPostExecute(Long result) {
///         showDialog("Downloaded " + result + " bytes");
///     }
/// }
/// </pre>
///
/// Once created, a task is executed very simply:
///
/// <pre class="prettyprint">
/// new DownloadFilesTask().execute(url1, url2, url3);
/// </pre>
///
/// <h2>AsyncTask's generic types</h2>
/// The three types used by an asynchronous task are the following:
///
/// <ol>
///     <li><code>Params</code>, the type of the parameters sent to the task upon
///     execution.</li>
///     <li><code>Progress</code>, the type of the progress units published during
///     the background computation.</li>
///     <li><code>Result</code>, the type of the result of the background
///     computation.</li>
/// </ol>
/// Not all types are always used by an asynchronous task. To mark a type as unused,
/// simply use the type Void:
///
/// <pre>
/// private class MyTask extends AsyncTask&lt;Void, Void, Void&gt; { ... }
/// </pre>
///
/// <h2>The 4 steps</h2>
/// When an asynchronous task is executed, the task goes through 4 steps:
///
/// <ol>
///     <li>\#onPreExecute(), invoked on the UI thread before the task
///     is executed. This step is normally used to setup the task, for instance by
///     showing a progress bar in the user interface.</li>
///     <li>\#doInBackground, invoked on the background thread
///     immediately after \#onPreExecute() finishes executing. This step is used
///     to perform background computation that can take a long time. The parameters
///     of the asynchronous task are passed to this step. The result of the computation must
///     be returned by this step and will be passed back to the last step. This step
///     can also use \#publishProgress to publish one or more units
///     of progress. These values are published on the UI thread, in the
///     \#onProgressUpdate step.</li>
///     <li>\#onProgressUpdate, invoked on the UI thread after a
///     call to \#publishProgress. The timing of the execution is
///     undefined. This method is used to display any form of progress in the user
///     interface while the background computation is still executing. For instance,
///     it can be used to animate a progress bar or show logs in a text field.</li>
///     <li>\#onPostExecute, invoked on the UI thread after the background
///     computation finishes. The result of the background computation is passed to
///     this step as a parameter.</li>
/// </ol>
///
/// <h2>Cancelling a task</h2>
/// A task can be cancelled at any time by invoking \#cancel(boolean). Invoking
/// this method will cause subsequent calls to \#isCancelled() to return true.
/// After invoking this method, \#onCancelled(Object), instead of
/// \#onPostExecute(Object) will be invoked after \#doInBackground(Object[])
/// returns. To ensure that a task is cancelled as quickly as possible, you should always
/// check the return value of \#isCancelled() periodically from
/// \#doInBackground(Object[]), if possible (inside a loop for instance.)
///
///
/// <h2>Threading rules</h2>
/// There are a few threading rules that must be followed for this class to
/// work properly:
///
/// <ul>
///     <li>The AsyncTask class must be loaded on the UI thread. This is done
///     automatically as of android.os.Build.VERSION_CODES\#JELLY_BEAN.</li>
///     <li>The task instance must be created on the UI thread.</li>
///     <li>\#execute must be invoked on the UI thread.</li>
///     <li>Do not call \#onPreExecute(), \#onPostExecute,
///     \#doInBackground, \#onProgressUpdate manually.</li>
///     <li>The task can be executed only once (an exception will be thrown if
///     a second execution is attempted.)</li>
/// </ul>
///
/// <h2>Memory observability</h2>
/// AsyncTask guarantees that all callback calls are synchronized in such a way that the following
/// operations are safe without explicit synchronizations.
///
/// <ul>
///     <li>Set member fields in the constructor or \#onPreExecute, and refer to them
///     in \#doInBackground.
///     <li>Set member fields in \#doInBackground, and refer to them in
///     \#onProgressUpdate and \#onPostExecute.
/// </ul>
///
/// <h2>Order of execution</h2>
/// When first introduced, AsyncTasks were executed serially on a single background
/// thread. Starting with android.os.Build.VERSION_CODES\#DONUT, this was changed
/// to a pool of threads allowing multiple tasks to operate in parallel. Starting with
/// android.os.Build.VERSION_CODES\#HONEYCOMB, tasks are executed on a single
/// thread to avoid common application errors caused by parallel execution.
///
/// If you truly want parallel execution, you can invoke
/// \#executeOnExecutor(java.util.concurrent.Executor, Object[]) with
/// \#THREAD_POOL_EXECUTOR.
///
class AsyncTask extends jni.JlObject {
  AsyncTask.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.util.concurrent.Executor SERIAL_EXECUTOR
  /// An Executor that executes tasks one at a time in serial
  /// order.  This serialization is global to a particular process.
  static final _getSERIAL_EXECUTOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_AsyncTask_SERIAL_EXECUTOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlObject get SERIAL_EXECUTOR =>
      jni.JlObject.fromRef(_getSERIAL_EXECUTOR());

  /// from: static public final java.util.concurrent.Executor THREAD_POOL_EXECUTOR
  /// An Executor that can be used to execute tasks in parallel.
  static final _getTHREAD_POOL_EXECUTOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_AsyncTask_THREAD_POOL_EXECUTOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlObject get THREAD_POOL_EXECUTOR =>
      jni.JlObject.fromRef(_getTHREAD_POOL_EXECUTOR());

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_AsyncTask_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Creates a new asynchronous task. This constructor must be invoked on the UI thread.
  AsyncTask() : super.fromRef(_ctor());

  static final _getStatus = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_AsyncTask_getStatus")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.AsyncTask.Status getStatus()
  /// Returns the current status of this task.
  ///@return The current status.
  AsyncTask_Status getStatus() =>
      AsyncTask_Status.fromRef(_getStatus(reference));

  static final _onPreExecute =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_AsyncTask_onPreExecute")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPreExecute()
  /// Runs on the UI thread before \#doInBackground.
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  ///@see \#onPostExecute
  ///@see \#doInBackground
  void onPreExecute() => _onPreExecute(reference);

  static final _onProgressUpdate = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_AsyncTask_onProgressUpdate")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onProgressUpdate(Progress[] values)
  /// Runs on the UI thread after \#publishProgress is invoked.
  /// The specified values are the values passed to \#publishProgress.
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  ///@param values The values indicating progress.
  ///@see \#publishProgress
  ///@see \#doInBackground
  void onProgressUpdate(jni.JlObject values) =>
      _onProgressUpdate(reference, values.reference);

  static final _onCancelled_1 =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_AsyncTask_onCancelled_1")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onCancelled()
  /// Applications should preferably override \#onCancelled(Object).
  /// This method is invoked by the default implementation of
  /// \#onCancelled(Object).
  ///
  ///
  /// Runs on the UI thread after \#cancel(boolean) is invoked and
  /// \#doInBackground(Object[]) has finished.
  ///
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  ///@see \#onCancelled(Object)
  ///@see \#cancel(boolean)
  ///@see \#isCancelled()
  void onCancelled_1() => _onCancelled_1(reference);

  static final _isCancelled =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_AsyncTask_isCancelled")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isCancelled()
  /// Returns <tt>true</tt> if this task was cancelled before it completed
  /// normally. If you are calling \#cancel(boolean) on the task,
  /// the value returned by this method should be checked periodically from
  /// \#doInBackground(Object[]) to end the task as soon as possible.
  ///@return <tt>true</tt> if task was cancelled before it completed
  ///@see \#cancel(boolean)
  bool isCancelled() => _isCancelled(reference) != 0;

  static final _cancel = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_os_AsyncTask_cancel")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final boolean cancel(boolean mayInterruptIfRunning)
  /// Attempts to cancel execution of this task.  This attempt will
  /// fail if the task has already completed, already been cancelled,
  /// or could not be cancelled for some other reason. If successful,
  /// and this task has not started when <tt>cancel</tt> is called,
  /// this task should never run. If the task has already started,
  /// then the <tt>mayInterruptIfRunning</tt> parameter determines
  /// whether the thread executing this task should be interrupted in
  /// an attempt to stop the task.
  ///
  ///
  /// Calling this method will result in \#onCancelled(Object) being
  /// invoked on the UI thread after \#doInBackground(Object[])
  /// returns. Calling this method guarantees that \#onPostExecute(Object)
  /// is never invoked. After invoking this method, you should check the
  /// value returned by \#isCancelled() periodically from
  /// \#doInBackground(Object[]) to finish the task as early as
  /// possible.
  ///
  ///@param mayInterruptIfRunning <tt>true</tt> if the thread executing this
  ///        task should be interrupted; otherwise, in-progress tasks are allowed
  ///        to complete.
  ///@return <tt>false</tt> if the task could not be cancelled,
  ///         typically because it has already completed normally;
  ///         <tt>true</tt> otherwise
  ///@see \#isCancelled()
  ///@see \#onCancelled(Object)
  bool cancel(bool mayInterruptIfRunning) =>
      _cancel(reference, mayInterruptIfRunning ? 1 : 0) != 0;

  static final _execute = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_AsyncTask_execute")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.AsyncTask<Params,Progress,Result> execute(Params[] params)
  /// Executes the task with the specified parameters. The task returns
  /// itself (this) so that the caller can keep a reference to it.
  ///
  /// Note: this function schedules the task on a queue for a single background
  /// thread or pool of threads depending on the platform version.  When first
  /// introduced, AsyncTasks were executed serially on a single background thread.
  /// Starting with android.os.Build.VERSION_CODES\#DONUT, this was changed
  /// to a pool of threads allowing multiple tasks to operate in parallel. Starting
  /// android.os.Build.VERSION_CODES\#HONEYCOMB, tasks are back to being
  /// executed on a single thread to avoid common application errors caused
  /// by parallel execution.  If you truly want parallel execution, you can use
  /// the \#executeOnExecutor version of this method
  /// with \#THREAD_POOL_EXECUTOR; however, see commentary there for warnings
  /// on its use.
  ///
  /// This method must be invoked on the UI thread.
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  ///@param params The parameters of the task.
  ///@return This instance of AsyncTask.
  ///@throws IllegalStateException If \#getStatus() returns either
  ///         AsyncTask.Status\#RUNNING or AsyncTask.Status\#FINISHED.
  ///@see \#executeOnExecutor(java.util.concurrent.Executor, Object[])
  ///@see \#execute(Runnable)
  AsyncTask execute(jni.JlObject params) =>
      AsyncTask.fromRef(_execute(reference, params.reference));

  static final _executeOnExecutor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_AsyncTask_executeOnExecutor")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.AsyncTask<Params,Progress,Result> executeOnExecutor(java.util.concurrent.Executor exec, Params[] params)
  /// Executes the task with the specified parameters. The task returns
  /// itself (this) so that the caller can keep a reference to it.
  ///
  /// This method is typically used with \#THREAD_POOL_EXECUTOR to
  /// allow multiple tasks to run in parallel on a pool of threads managed by
  /// AsyncTask, however you can also use your own Executor for custom
  /// behavior.
  ///
  /// _Warning:_ Allowing multiple tasks to run in parallel from
  /// a thread pool is generally _not_ what one wants, because the order
  /// of their operation is not defined.  For example, if these tasks are used
  /// to modify any state in common (such as writing a file due to a button click),
  /// there are no guarantees on the order of the modifications.
  /// Without careful work it is possible in rare cases for the newer version
  /// of the data to be over-written by an older one, leading to obscure data
  /// loss and stability issues.  Such changes are best
  /// executed in serial; to guarantee such work is serialized regardless of
  /// platform version you can use this function with \#SERIAL_EXECUTOR.
  ///
  /// This method must be invoked on the UI thread.
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  ///@param exec The executor to use.  \#THREAD_POOL_EXECUTOR is available as a
  ///              convenient process-wide thread pool for tasks that are loosely coupled.
  ///@param params The parameters of the task.
  ///@return This instance of AsyncTask.
  ///@throws IllegalStateException If \#getStatus() returns either
  ///         AsyncTask.Status\#RUNNING or AsyncTask.Status\#FINISHED.
  ///@see \#execute(Object[])
  AsyncTask executeOnExecutor(jni.JlObject exec, jni.JlObject params) =>
      AsyncTask.fromRef(
          _executeOnExecutor(reference, exec.reference, params.reference));

  static final _execute_1 =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_AsyncTask_execute_1")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void execute(java.lang.Runnable runnable)
  /// Convenience version of \#execute(Object...) for use with
  /// a simple Runnable object. See \#execute(Object[]) for more
  /// information on the order of execution.
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  ///@see \#execute(Object[])
  ///@see \#executeOnExecutor(java.util.concurrent.Executor, Object[])
  static void execute_1(jni.JlObject runnable) =>
      _execute_1(runnable.reference);

  static final _publishProgress = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_AsyncTask_publishProgress")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected final void publishProgress(Progress[] values)
  /// This method can be invoked from \#doInBackground to
  /// publish updates on the UI thread while the background computation is
  /// still running. Each call to this method will trigger the execution of
  /// \#onProgressUpdate on the UI thread.
  ///
  /// \#onProgressUpdate will not be called if the task has been
  /// canceled.
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param values The progress values to update the UI with.
  ///@see \#onProgressUpdate
  ///@see \#doInBackground
  void publishProgress(jni.JlObject values) =>
      _publishProgress(reference, values.reference);
}

/// Indicates the current status of the task. Each status will be set only once
/// during the lifetime of a task.
class AsyncTask_Status extends jni.JlObject {
  AsyncTask_Status.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _values =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_AsyncTask__Status_values")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.os.AsyncTask.Status[] values()
  static jni.JlObject values() => jni.JlObject.fromRef(_values());

  static final _valueOf = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_AsyncTask__Status_valueOf")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.AsyncTask.Status valueOf(java.lang.String name)
  static AsyncTask_Status valueOf(jni.JlString name) =>
      AsyncTask_Status.fromRef(_valueOf(name.reference));

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_AsyncTask__Status_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: private void <init>()
  AsyncTask_Status() : super.fromRef(_ctor());
}

/// The FileDescriptor returned by Parcel\#readFileDescriptor, allowing
/// you to close it when done with it.
class ParcelFileDescriptor extends jni.JlObject {
  ParcelFileDescriptor.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.os.ParcelFileDescriptor> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_ParcelFileDescriptor_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static Parcelable_Creator get CREATOR =>
      Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final int MODE_APPEND
  /// For use with \#open: append to end of file while writing.
  static const MODE_APPEND = 33554432;

  /// from: static public final int MODE_CREATE
  /// For use with \#open: create the file if it doesn't already exist.
  static const MODE_CREATE = 134217728;

  /// from: static public final int MODE_READ_ONLY
  /// For use with \#open: open the file with read-only access.
  static const MODE_READ_ONLY = 268435456;

  /// from: static public final int MODE_READ_WRITE
  /// For use with \#open: open the file with read and write access.
  static const MODE_READ_WRITE = 805306368;

  /// from: static public final int MODE_TRUNCATE
  /// For use with \#open: erase contents of file when opening.
  static const MODE_TRUNCATE = 67108864;

  /// from: static public final int MODE_WORLD_READABLE
  /// For use with \#open: if \#MODE_CREATE has been supplied and
  /// this file doesn't already exist, then create the file with permissions
  /// such that any application can read it.
  ///@deprecated Creating world-readable files is very dangerous, and likely
  ///             to cause security holes in applications. It is strongly
  ///             discouraged; instead, applications should use more formal
  ///             mechanism for interactions such as ContentProvider,
  ///             BroadcastReceiver, and android.app.Service.
  ///             There are no guarantees that this access mode will remain on
  ///             a file, such as when it goes through a backup and restore.
  static const MODE_WORLD_READABLE = 1;

  /// from: static public final int MODE_WORLD_WRITEABLE
  /// For use with \#open: if \#MODE_CREATE has been supplied and
  /// this file doesn't already exist, then create the file with permissions
  /// such that any application can write it.
  ///@deprecated Creating world-writable files is very dangerous, and likely
  ///             to cause security holes in applications. It is strongly
  ///             discouraged; instead, applications should use more formal
  ///             mechanism for interactions such as ContentProvider,
  ///             BroadcastReceiver, and android.app.Service.
  ///             There are no guarantees that this access mode will remain on
  ///             a file, such as when it goes through a backup and restore.
  static const MODE_WORLD_WRITEABLE = 2;

  /// from: static public final int MODE_WRITE_ONLY
  /// For use with \#open: open the file with write-only access.
  static const MODE_WRITE_ONLY = 536870912;

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_ParcelFileDescriptor_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.ParcelFileDescriptor wrapped)
  /// Create a new ParcelFileDescriptor wrapped around another descriptor. By
  /// default all method calls are delegated to the wrapped descriptor.
  ParcelFileDescriptor(ParcelFileDescriptor wrapped)
      : super.fromRef(_ctor(wrapped.reference));

  static final _open = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_ParcelFileDescriptor_open")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.os.ParcelFileDescriptor open(java.io.File file, int mode)
  /// Create a new ParcelFileDescriptor accessing a given file.
  ///@param file The file to be opened.
  ///@param mode The desired access mode, must be one of
  ///            \#MODE_READ_ONLY, \#MODE_WRITE_ONLY, or
  ///            \#MODE_READ_WRITE; may also be any combination of
  ///            \#MODE_CREATE, \#MODE_TRUNCATE,
  ///            \#MODE_WORLD_READABLE, and
  ///            \#MODE_WORLD_WRITEABLE.
  ///@return a new ParcelFileDescriptor pointing to the given file.
  ///@throws FileNotFoundException if the given file does not exist or can not
  ///             be opened with the requested mode.
  ///@see \#parseMode(String)
  static ParcelFileDescriptor open(jni.JlObject file, int mode) =>
      ParcelFileDescriptor.fromRef(_open(file.reference, mode));

  static final _open_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_os_ParcelFileDescriptor_open_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.ParcelFileDescriptor open(java.io.File file, int mode, android.os.Handler handler, android.os.ParcelFileDescriptor.OnCloseListener listener)
  /// Create a new ParcelFileDescriptor accessing a given file.
  ///@param file The file to be opened.
  ///@param mode The desired access mode, must be one of
  ///            \#MODE_READ_ONLY, \#MODE_WRITE_ONLY, or
  ///            \#MODE_READ_WRITE; may also be any combination of
  ///            \#MODE_CREATE, \#MODE_TRUNCATE,
  ///            \#MODE_WORLD_READABLE, and
  ///            \#MODE_WORLD_WRITEABLE.
  ///@param handler to call listener from; must not be null.
  ///@param listener to be invoked when the returned descriptor has been
  ///            closed; must not be null.
  ///@return a new ParcelFileDescriptor pointing to the given file.
  ///@throws FileNotFoundException if the given file does not exist or can not
  ///             be opened with the requested mode.
  ///@see \#parseMode(String)
  static ParcelFileDescriptor open_1(jni.JlObject file, int mode,
          Handler handler, ParcelFileDescriptor_OnCloseListener listener) =>
      ParcelFileDescriptor.fromRef(
          _open_1(file.reference, mode, handler.reference, listener.reference));

  static final _dup = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_ParcelFileDescriptor_dup")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.ParcelFileDescriptor dup(java.io.FileDescriptor orig)
  /// Create a new ParcelFileDescriptor that is a dup of an existing
  /// FileDescriptor.  This obeys standard POSIX semantics, where the
  /// new file descriptor shared state such as file position with the
  /// original file descriptor.
  static ParcelFileDescriptor dup(jni.JlObject orig) =>
      ParcelFileDescriptor.fromRef(_dup(orig.reference));

  static final _dup_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_ParcelFileDescriptor_dup_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.ParcelFileDescriptor dup()
  /// Create a new ParcelFileDescriptor that is a dup of the existing
  /// FileDescriptor.  This obeys standard POSIX semantics, where the
  /// new file descriptor shared state such as file position with the
  /// original file descriptor.
  ParcelFileDescriptor dup_1() =>
      ParcelFileDescriptor.fromRef(_dup_1(reference));

  static final _fromFd =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int32)>>(
              "android_os_ParcelFileDescriptor_fromFd")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: static public android.os.ParcelFileDescriptor fromFd(int fd)
  /// Create a new ParcelFileDescriptor from a raw native fd.  The new
  /// ParcelFileDescriptor holds a dup of the original fd passed in here,
  /// so you must still close that fd as well as the new ParcelFileDescriptor.
  ///@param fd The native fd that the ParcelFileDescriptor should dup.
  ///@return Returns a new ParcelFileDescriptor holding a FileDescriptor
  /// for a dup of the given fd.
  static ParcelFileDescriptor fromFd(int fd) =>
      ParcelFileDescriptor.fromRef(_fromFd(fd));

  static final _adoptFd =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int32)>>(
              "android_os_ParcelFileDescriptor_adoptFd")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: static public android.os.ParcelFileDescriptor adoptFd(int fd)
  /// Take ownership of a raw native fd in to a new ParcelFileDescriptor.
  /// The returned ParcelFileDescriptor now owns the given fd, and will be
  /// responsible for closing it.  You must not close the fd yourself.
  ///@param fd The native fd that the ParcelFileDescriptor should adopt.
  ///@return Returns a new ParcelFileDescriptor holding a FileDescriptor
  /// for the given fd.
  static ParcelFileDescriptor adoptFd(int fd) =>
      ParcelFileDescriptor.fromRef(_adoptFd(fd));

  static final _fromSocket = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_ParcelFileDescriptor_fromSocket")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.ParcelFileDescriptor fromSocket(java.net.Socket socket)
  /// Create a new ParcelFileDescriptor from the specified Socket.  The new
  /// ParcelFileDescriptor holds a dup of the original FileDescriptor in
  /// the Socket, so you must still close the Socket as well as the new
  /// ParcelFileDescriptor.
  ///@param socket The Socket whose FileDescriptor is used to create
  ///               a new ParcelFileDescriptor.
  ///@return A new ParcelFileDescriptor with the FileDescriptor of the
  ///         specified Socket.
  static ParcelFileDescriptor fromSocket(jni.JlObject socket) =>
      ParcelFileDescriptor.fromRef(_fromSocket(socket.reference));

  static final _fromDatagramSocket = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_ParcelFileDescriptor_fromDatagramSocket")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.ParcelFileDescriptor fromDatagramSocket(java.net.DatagramSocket datagramSocket)
  /// Create a new ParcelFileDescriptor from the specified DatagramSocket.
  ///@param datagramSocket The DatagramSocket whose FileDescriptor is used
  ///               to create a new ParcelFileDescriptor.
  ///@return A new ParcelFileDescriptor with the FileDescriptor of the
  ///         specified DatagramSocket.
  static ParcelFileDescriptor fromDatagramSocket(jni.JlObject datagramSocket) =>
      ParcelFileDescriptor.fromRef(
          _fromDatagramSocket(datagramSocket.reference));

  static final _createPipe =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_ParcelFileDescriptor_createPipe")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.os.ParcelFileDescriptor[] createPipe()
  /// Create two ParcelFileDescriptors structured as a data pipe.  The first
  /// ParcelFileDescriptor in the returned array is the read side; the second
  /// is the write side.
  static jni.JlObject createPipe() => jni.JlObject.fromRef(_createPipe());

  static final _createReliablePipe =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_ParcelFileDescriptor_createReliablePipe")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.os.ParcelFileDescriptor[] createReliablePipe()
  /// Create two ParcelFileDescriptors structured as a data pipe. The first
  /// ParcelFileDescriptor in the returned array is the read side; the second
  /// is the write side.
  ///
  /// The write end has the ability to deliver an error message through
  /// \#closeWithError(String) which can be handled by the read end
  /// calling \#checkError(), usually after detecting an EOF.
  /// This can also be used to detect remote crashes.
  static jni.JlObject createReliablePipe() =>
      jni.JlObject.fromRef(_createReliablePipe());

  static final _createSocketPair =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_ParcelFileDescriptor_createSocketPair")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.os.ParcelFileDescriptor[] createSocketPair()
  /// Create two ParcelFileDescriptors structured as a pair of sockets
  /// connected to each other. The two sockets are indistinguishable.
  static jni.JlObject createSocketPair() =>
      jni.JlObject.fromRef(_createSocketPair());

  static final _createReliableSocketPair =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_ParcelFileDescriptor_createReliableSocketPair")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.os.ParcelFileDescriptor[] createReliableSocketPair()
  /// Create two ParcelFileDescriptors structured as a pair of sockets
  /// connected to each other. The two sockets are indistinguishable.
  ///
  /// Both ends have the ability to deliver an error message through
  /// \#closeWithError(String) which can be detected by the other end
  /// calling \#checkError(), usually after detecting an EOF.
  /// This can also be used to detect remote crashes.
  static jni.JlObject createReliableSocketPair() =>
      jni.JlObject.fromRef(_createReliableSocketPair());

  static final _parseMode =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ParcelFileDescriptor_parseMode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public int parseMode(java.lang.String mode)
  /// Converts a string representing a file mode, such as "rw", into a bitmask suitable for use
  /// with \#open.
  ///
  ///@param mode The string representation of the file mode. Can be "r", "w", "wt", "wa", "rw"
  ///             or "rwt".
  ///@return A bitmask representing the given file mode.
  ///@throws IllegalArgumentException if the given string does not match a known file mode.
  static int parseMode(jni.JlString mode) => _parseMode(mode.reference);

  static final _getFileDescriptor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_ParcelFileDescriptor_getFileDescriptor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.FileDescriptor getFileDescriptor()
  /// Retrieve the actual FileDescriptor associated with this object.
  ///@return Returns the FileDescriptor associated with this object.
  jni.JlObject getFileDescriptor() =>
      jni.JlObject.fromRef(_getFileDescriptor(reference));

  static final _getStatSize =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ParcelFileDescriptor_getStatSize")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getStatSize()
  /// Return the total size of the file representing this fd, as determined by
  /// {@code stat()}. Returns -1 if the fd is not a file.
  int getStatSize() => _getStatSize(reference);

  static final _getFd =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ParcelFileDescriptor_getFd")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getFd()
  /// Return the native fd int for this ParcelFileDescriptor.  The
  /// ParcelFileDescriptor still owns the fd, and it still must be closed
  /// through this API.
  int getFd() => _getFd(reference);

  static final _detachFd =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ParcelFileDescriptor_detachFd")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int detachFd()
  /// Return the native fd int for this ParcelFileDescriptor and detach it from
  /// the object here. You are now responsible for closing the fd in native
  /// code.
  ///
  /// You should not detach when the original creator of the descriptor is
  /// expecting a reliable signal through \#close() or
  /// \#closeWithError(String).
  ///@see \#canDetectErrors()
  int detachFd() => _detachFd(reference);

  static final _close =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ParcelFileDescriptor_close")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void close()
  /// Close the ParcelFileDescriptor. This implementation closes the underlying
  /// OS resources allocated to represent this stream.
  ///@throws IOException If an error occurs attempting to close this ParcelFileDescriptor.
  void close() => _close(reference);

  static final _closeWithError = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_ParcelFileDescriptor_closeWithError")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void closeWithError(java.lang.String msg)
  /// Close the ParcelFileDescriptor, informing any peer that an error occurred
  /// while processing. If the creator of this descriptor is not observing
  /// errors, it will close normally.
  ///@param msg describing the error; must not be null.
  void closeWithError(jni.JlString msg) =>
      _closeWithError(reference, msg.reference);

  static final _canDetectErrors =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ParcelFileDescriptor_canDetectErrors")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean canDetectErrors()
  /// Indicates if this ParcelFileDescriptor can communicate and detect remote
  /// errors/crashes.
  ///@see \#checkError()
  bool canDetectErrors() => _canDetectErrors(reference) != 0;

  static final _checkError =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ParcelFileDescriptor_checkError")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void checkError()
  /// Detect and throw if the other end of a pipe or socket pair encountered an
  /// error or crashed. This allows a reader to distinguish between a valid EOF
  /// and an error/crash.
  ///
  /// If this ParcelFileDescriptor is unable to detect remote errors, it will
  /// return silently.
  ///@throws IOException for normal errors.
  ///@throws FileDescriptorDetachedException if the remote side called \#detachFd(). Once detached, the remote
  ///            side is unable to communicate any errors through
  ///            \#closeWithError(String).
  ///@see \#canDetectErrors()
  void checkError() => _checkError(reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_ParcelFileDescriptor_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _finalize =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ParcelFileDescriptor_finalize")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void finalize()
  void finalize() => _finalize(reference);

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ParcelFileDescriptor_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_ParcelFileDescriptor_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  /// {@inheritDoc}
  /// If Parcelable\#PARCELABLE_WRITE_RETURN_VALUE is set in flags,
  /// the file descriptor will be closed after a copy is written to the Parcel.
  void writeToParcel(Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags);
}

/// Callback indicating that a ParcelFileDescriptor has been closed.
class ParcelFileDescriptor_OnCloseListener extends jni.JlObject {
  ParcelFileDescriptor_OnCloseListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onClose = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_ParcelFileDescriptor__OnCloseListener_onClose")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onClose(java.io.IOException e)
  /// Event indicating the ParcelFileDescriptor to which this listener was
  /// attached has been closed.
  ///@param e error state, or {@code null} if closed cleanly.
  ///        If the close event was the result of
  ///        ParcelFileDescriptor\#detachFd(), this will be a
  ///        FileDescriptorDetachedException. After detach the
  ///        remote side may continue reading/writing to the underlying
  ///        FileDescriptor, but they can no longer deliver
  ///        reliable close/error events.
  void onClose(jni.JlObject e) => _onClose(reference, e.reference);
}

/// Exception that indicates that the file descriptor was detached.
class ParcelFileDescriptor_FileDescriptorDetachedException
    extends jni.JlObject {
  ParcelFileDescriptor_FileDescriptorDetachedException.fromRef(
      ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
          "android_os_ParcelFileDescriptor__FileDescriptorDetachedException_new")
      .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ParcelFileDescriptor_FileDescriptorDetachedException()
      : super.fromRef(_ctor());
}

/// An OutputStream you can create on a ParcelFileDescriptor, which will
/// take care of calling ParcelFileDescriptor\#close ParcelFileDescriptor.close() for you when the stream is closed.
class ParcelFileDescriptor_AutoCloseOutputStream extends jni.JlObject {
  ParcelFileDescriptor_AutoCloseOutputStream.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_ParcelFileDescriptor__AutoCloseOutputStream_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.ParcelFileDescriptor pfd)
  ParcelFileDescriptor_AutoCloseOutputStream(ParcelFileDescriptor pfd)
      : super.fromRef(_ctor(pfd.reference));

  static final _close =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ParcelFileDescriptor__AutoCloseOutputStream_close")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void close()
  void close() => _close(reference);
}

/// An InputStream you can create on a ParcelFileDescriptor, which will
/// take care of calling ParcelFileDescriptor\#close ParcelFileDescriptor.close() for you when the stream is closed.
class ParcelFileDescriptor_AutoCloseInputStream extends jni.JlObject {
  ParcelFileDescriptor_AutoCloseInputStream.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_ParcelFileDescriptor__AutoCloseInputStream_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.ParcelFileDescriptor pfd)
  ParcelFileDescriptor_AutoCloseInputStream(ParcelFileDescriptor pfd)
      : super.fromRef(_ctor(pfd.reference));

  static final _close =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ParcelFileDescriptor__AutoCloseInputStream_close")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void close()
  void close() => _close(reference);
}

/// The core Android system has died and is going through a runtime restart. All
/// running apps will be promptly killed.
class DeadSystemException extends DeadObjectException {
  DeadSystemException.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_DeadSystemException_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  DeadSystemException() : super.fromRef(_ctor());
}

/// Information about the current build, extracted from system properties.
class Build extends jni.JlObject {
  Build.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String BOARD
  /// The name of the underlying board, like "goldfish".
  static final _getBOARD =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_BOARD")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get BOARD => jni.JlString.fromRef(_getBOARD());

  /// from: static public final java.lang.String BOOTLOADER
  /// The system bootloader version number.
  static final _getBOOTLOADER =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_BOOTLOADER")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get BOOTLOADER => jni.JlString.fromRef(_getBOOTLOADER());

  /// from: static public final java.lang.String BRAND
  /// The consumer-visible brand with which the product/hardware will be associated, if any.
  static final _getBRAND =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_BRAND")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get BRAND => jni.JlString.fromRef(_getBRAND());

  /// from: static public final java.lang.String CPU_ABI
  /// The name of the instruction set (CPU type + ABI convention) of native code.
  ///@deprecated Use \#SUPPORTED_ABIS instead.
  static final _getCPU_ABI =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_CPU_ABI")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get CPU_ABI => jni.JlString.fromRef(_getCPU_ABI());

  /// from: static public final java.lang.String CPU_ABI2
  /// The name of the second instruction set (CPU type + ABI convention) of native code.
  ///@deprecated Use \#SUPPORTED_ABIS instead.
  static final _getCPU_ABI2 =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_CPU_ABI2")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get CPU_ABI2 => jni.JlString.fromRef(_getCPU_ABI2());

  /// from: static public final java.lang.String DEVICE
  /// The name of the industrial design.
  static final _getDEVICE =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_DEVICE")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get DEVICE => jni.JlString.fromRef(_getDEVICE());

  /// from: static public final java.lang.String DISPLAY
  /// A build ID string meant for displaying to the user
  static final _getDISPLAY =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_DISPLAY")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get DISPLAY => jni.JlString.fromRef(_getDISPLAY());

  /// from: static public final java.lang.String FINGERPRINT
  /// A string that uniquely identifies this build.  Do not attempt to parse this value.
  static final _getFINGERPRINT =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_FINGERPRINT")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get FINGERPRINT =>
      jni.JlString.fromRef(_getFINGERPRINT());

  /// from: static public final java.lang.String HARDWARE
  /// The name of the hardware (from the kernel command line or /proc).
  static final _getHARDWARE =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_HARDWARE")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get HARDWARE => jni.JlString.fromRef(_getHARDWARE());

  /// from: static public final java.lang.String HOST
  static final _getHOST =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_HOST")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get HOST => jni.JlString.fromRef(_getHOST());

  /// from: static public final java.lang.String ID
  /// Either a changelist number, or a label like "M4-rc20".
  static final _getID =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_ID")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get ID => jni.JlString.fromRef(_getID());

  /// from: static public final java.lang.String MANUFACTURER
  /// The manufacturer of the product/hardware.
  static final _getMANUFACTURER =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_MANUFACTURER")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get MANUFACTURER =>
      jni.JlString.fromRef(_getMANUFACTURER());

  /// from: static public final java.lang.String MODEL
  /// The end-user-visible name for the end product.
  static final _getMODEL =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_MODEL")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get MODEL => jni.JlString.fromRef(_getMODEL());

  /// from: static public final java.lang.String PRODUCT
  /// The name of the overall product.
  static final _getPRODUCT =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_PRODUCT")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get PRODUCT => jni.JlString.fromRef(_getPRODUCT());

  /// from: static public final java.lang.String RADIO
  /// The radio firmware version number.
  ///@deprecated The radio firmware version is frequently not
  /// available when this class is initialized, leading to a blank or
  /// "unknown" value for this string.  Use
  /// \#getRadioVersion instead.
  static final _getRADIO =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_RADIO")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get RADIO => jni.JlString.fromRef(_getRADIO());

  /// from: static public final java.lang.String SERIAL
  /// A hardware serial number, if available. Alphanumeric only, case-insensitive.
  /// For apps targeting SDK higher than Build.VERSION_CODES\#O_MR1 this
  /// field is set to Build\#UNKNOWN.
  ///@deprecated Use \#getSerial() instead.
  static final _getSERIAL =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_SERIAL")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get SERIAL => jni.JlString.fromRef(_getSERIAL());

  /// from: static public final java.lang.String[] SUPPORTED_32_BIT_ABIS
  /// An ordered list of __32 bit__ ABIs supported by this device. The most preferred ABI
  /// is the first element in the list.
  ///
  /// See \#SUPPORTED_ABIS and \#SUPPORTED_64_BIT_ABIS.
  static final _getSUPPORTED_32_BIT_ABIS =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_SUPPORTED_32_BIT_ABIS")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlObject get SUPPORTED_32_BIT_ABIS =>
      jni.JlObject.fromRef(_getSUPPORTED_32_BIT_ABIS());

  /// from: static public final java.lang.String[] SUPPORTED_64_BIT_ABIS
  /// An ordered list of __64 bit__ ABIs supported by this device. The most preferred ABI
  /// is the first element in the list.
  ///
  /// See \#SUPPORTED_ABIS and \#SUPPORTED_32_BIT_ABIS.
  static final _getSUPPORTED_64_BIT_ABIS =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_SUPPORTED_64_BIT_ABIS")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlObject get SUPPORTED_64_BIT_ABIS =>
      jni.JlObject.fromRef(_getSUPPORTED_64_BIT_ABIS());

  /// from: static public final java.lang.String[] SUPPORTED_ABIS
  /// An ordered list of ABIs supported by this device. The most preferred ABI is the first
  /// element in the list.
  ///
  /// See \#SUPPORTED_32_BIT_ABIS and \#SUPPORTED_64_BIT_ABIS.
  static final _getSUPPORTED_ABIS =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_SUPPORTED_ABIS")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlObject get SUPPORTED_ABIS =>
      jni.JlObject.fromRef(_getSUPPORTED_ABIS());

  /// from: static public final java.lang.String TAGS
  /// Comma-separated tags describing the build, like "unsigned,debug".
  static final _getTAGS =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_TAGS")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get TAGS => jni.JlString.fromRef(_getTAGS());

  /// from: static public final long TIME
  static final _getTIME = jlookup<ffi.NativeFunction<ffi.Int64 Function()>>(
          "get_android_os_Build_TIME")
      .asFunction<int Function()>();
  static int get TIME => _getTIME();

  /// from: static public final java.lang.String TYPE
  /// The type of build, like "user" or "eng".
  static final _getTYPE =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_TYPE")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get TYPE => jni.JlString.fromRef(_getTYPE());

  /// from: static public final java.lang.String UNKNOWN
  /// Value used for when a build property is unknown.
  static const UNKNOWN = "unknown";

  /// from: static public final java.lang.String USER
  static final _getUSER =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build_USER")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get USER => jni.JlString.fromRef(_getUSER());

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Build_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Build() : super.fromRef(_ctor());

  static final _getSerial =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Build_getSerial")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public java.lang.String getSerial()
  /// Gets the hardware serial number, if available.
  ///
  /// <p class="note">__Note:__ Root access may allow you to modify device identifiers, such as
  /// the hardware serial number. If you change these identifiers, you can use
  /// <a href="/training/articles/security-key-attestation.html">key attestation</a> to obtain
  /// proof of the device's original identifiers.
  ///
  /// Requires android.Manifest.permission\#READ_PHONE_STATE
  ///@return The serial number if specified.
  static jni.JlString getSerial() => jni.JlString.fromRef(_getSerial());

  static final _getRadioVersion =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Build_getRadioVersion")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public java.lang.String getRadioVersion()
  /// Returns the version string for the radio firmware.  May return
  /// null (if, for instance, the radio is not currently on).
  static jni.JlString getRadioVersion() =>
      jni.JlString.fromRef(_getRadioVersion());
}

/// Enumeration of the currently known SDK version codes.  These are the
/// values that can be found in VERSION\#SDK.  Version numbers
/// increment monotonically with each official platform release.
class Build_VERSION_CODES extends jni.JlObject {
  Build_VERSION_CODES.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int BASE
  /// October 2008: The original, first, version of Android.  Yay!
  static const BASE = 1;

  /// from: static public final int BASE_1_1
  /// February 2009: First Android update, officially called 1.1.
  static const BASE_1_1 = 2;

  /// from: static public final int CUPCAKE
  /// May 2009: Android 1.5.
  static const CUPCAKE = 3;

  /// from: static public final int CUR_DEVELOPMENT
  /// Magic version number for a current development build, which has
  /// not yet turned into an official release.
  static const CUR_DEVELOPMENT = 10000;

  /// from: static public final int DONUT
  /// September 2009: Android 1.6.
  ///
  /// Applications targeting this or a later release will get these
  /// new changes in behavior:
  ///
  /// <ul>
  /// <li> They must explicitly request the
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE permission to be
  /// able to modify the contents of the SD card.  (Apps targeting
  /// earlier versions will always request the permission.)
  /// <li> They must explicitly request the
  /// android.Manifest.permission\#READ_PHONE_STATE permission to be
  /// able to be able to retrieve phone state info.  (Apps targeting
  /// earlier versions will always request the permission.)
  /// <li> They are assumed to support different screen densities and
  /// sizes.  (Apps targeting earlier versions are assumed to only support
  /// medium density normal size screens unless otherwise indicated).
  /// They can still explicitly specify screen support either way with the
  /// supports-screens manifest tag.
  /// <li> android.widget.TabHost will use the new dark tab
  /// background design.
  /// </ul>
  static const DONUT = 4;

  /// from: static public final int ECLAIR
  /// November 2009: Android 2.0
  ///
  /// Applications targeting this or a later release will get these
  /// new changes in behavior:
  ///
  /// <ul>
  /// <li> The android.app.Service\#onStartCommand Service.onStartCommand function will return the new
  /// android.app.Service\#START_STICKY behavior instead of the
  /// old compatibility android.app.Service\#START_STICKY_COMPATIBILITY.
  /// <li> The android.app.Activity class will now execute back
  /// key presses on the key up instead of key down, to be able to detect
  /// canceled presses from virtual keys.
  /// <li> The android.widget.TabWidget class will use a new color scheme
  /// for tabs. In the new scheme, the foreground tab has a medium gray background
  /// the background tabs have a dark gray background.
  /// </ul>
  static const ECLAIR = 5;

  /// from: static public final int ECLAIR_0_1
  /// December 2009: Android 2.0.1
  static const ECLAIR_0_1 = 6;

  /// from: static public final int ECLAIR_MR1
  /// January 2010: Android 2.1
  static const ECLAIR_MR1 = 7;

  /// from: static public final int FROYO
  /// June 2010: Android 2.2
  static const FROYO = 8;

  /// from: static public final int GINGERBREAD
  /// November 2010: Android 2.3
  ///
  /// Applications targeting this or a later release will get these
  /// new changes in behavior:
  ///
  /// <ul>
  /// <li> The application's notification icons will be shown on the new
  /// dark status bar background, so must be visible in this situation.
  /// </ul>
  static const GINGERBREAD = 9;

  /// from: static public final int GINGERBREAD_MR1
  /// February 2011: Android 2.3.3.
  static const GINGERBREAD_MR1 = 10;

  /// from: static public final int HONEYCOMB
  /// February 2011: Android 3.0.
  ///
  /// Applications targeting this or a later release will get these
  /// new changes in behavior:
  ///
  /// <ul>
  /// <li> The default theme for applications is now dark holographic:
  ///      android.R.style\#Theme_Holo.
  /// <li> On large screen devices that do not have a physical menu
  /// button, the soft (compatibility) menu is disabled.
  /// <li> The activity lifecycle has changed slightly as per
  /// android.app.Activity.
  /// <li> An application will crash if it does not call through
  /// to the super implementation of its
  /// android.app.Activity\#onPause Activity.onPause() method.
  /// <li> When an application requires a permission to access one of
  /// its components (activity, receiver, service, provider), this
  /// permission is no longer enforced when the application wants to
  /// access its own component.  This means it can require a permission
  /// on a component that it does not itself hold and still access that
  /// component.
  /// <li> android.content.Context\#getSharedPreferences Context.getSharedPreferences() will not automatically reload
  /// the preferences if they have changed on storage, unless
  /// android.content.Context\#MODE_MULTI_PROCESS is used.
  /// <li> android.view.ViewGroup\#setMotionEventSplittingEnabled
  /// will default to true.
  /// <li> android.view.WindowManager.LayoutParams\#FLAG_SPLIT_TOUCH
  /// is enabled by default on windows.
  /// <li> android.widget.PopupWindow\#isSplitTouchEnabled() PopupWindow.isSplitTouchEnabled() will return true by default.
  /// <li> android.widget.GridView and android.widget.ListView
  /// will use android.view.View\#setActivated View.setActivated
  /// for selected items if they do not implement android.widget.Checkable.
  /// <li> android.widget.Scroller will be constructed with
  /// "flywheel" behavior enabled by default.
  /// </ul>
  static const HONEYCOMB = 11;

  /// from: static public final int HONEYCOMB_MR1
  /// May 2011: Android 3.1.
  static const HONEYCOMB_MR1 = 12;

  /// from: static public final int HONEYCOMB_MR2
  /// June 2011: Android 3.2.
  ///
  /// Update to Honeycomb MR1 to support 7 inch tablets, improve
  /// screen compatibility mode, etc.
  ///
  ///
  /// As of this version, applications that don't say whether they
  /// support XLARGE screens will be assumed to do so only if they target
  /// \#HONEYCOMB or later; it had been \#GINGERBREAD or
  /// later.  Applications that don't support a screen size at least as
  /// large as the current screen will provide the user with a UI to
  /// switch them in to screen size compatibility mode.
  ///
  ///
  /// This version introduces new screen size resource qualifiers
  /// based on the screen size in dp: see
  /// android.content.res.Configuration\#screenWidthDp,
  /// android.content.res.Configuration\#screenHeightDp, and
  /// android.content.res.Configuration\#smallestScreenWidthDp.
  /// Supplying these in &lt;supports-screens&gt; as per
  /// android.content.pm.ApplicationInfo\#requiresSmallestWidthDp,
  /// android.content.pm.ApplicationInfo\#compatibleWidthLimitDp, and
  /// android.content.pm.ApplicationInfo\#largestWidthLimitDp is
  /// preferred over the older screen size buckets and for older devices
  /// the appropriate buckets will be inferred from them.
  ///
  ///
  /// Applications targeting this or a later release will get these
  /// new changes in behavior:
  ///
  /// <ul>
  /// <li>New android.content.pm.PackageManager\#FEATURE_SCREEN_PORTRAIT
  /// and android.content.pm.PackageManager\#FEATURE_SCREEN_LANDSCAPE
  /// features were introduced in this release.  Applications that target
  /// previous platform versions are assumed to require both portrait and
  /// landscape support in the device; when targeting Honeycomb MR1 or
  /// greater the application is responsible for specifying any specific
  /// orientation it requires.
  ///
  /// <li>android.os.AsyncTask will use the serial executor
  /// by default when calling android.os.AsyncTask\#execute.
  ///
  /// <li>android.content.pm.ActivityInfo\#configChanges ActivityInfo.configChanges will have the
  /// android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE and
  /// android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE
  /// bits set; these need to be cleared for older applications because
  /// some developers have done absolute comparisons against this value
  /// instead of correctly masking the bits they are interested in.
  /// </ul>
  static const HONEYCOMB_MR2 = 13;

  /// from: static public final int ICE_CREAM_SANDWICH
  /// October 2011: Android 4.0.
  ///
  /// Applications targeting this or a later release will get these
  /// new changes in behavior:
  ///
  /// <ul>
  /// <li> For devices without a dedicated menu key, the software compatibility
  /// menu key will not be shown even on phones.  By targeting Ice Cream Sandwich
  /// or later, your UI must always have its own menu UI affordance if needed,
  /// on both tablets and phones.  The ActionBar will take care of this for you.
  /// <li> 2d drawing hardware acceleration is now turned on by default.
  /// You can use
  /// android.R.attr\#hardwareAccelerated android:hardwareAccelerated
  /// to turn it off if needed, although this is strongly discouraged since
  /// it will result in poor performance on larger screen devices.
  /// <li> The default theme for applications is now the "device default" theme:
  ///      android.R.style\#Theme_DeviceDefault. This may be the
  ///      holo dark theme or a different dark theme defined by the specific device.
  ///      The android.R.style\#Theme_Holo family must not be modified
  ///      for a device to be considered compatible. Applications that explicitly
  ///      request a theme from the Holo family will be guaranteed that these themes
  ///      will not change character within the same platform version. Applications
  ///      that wish to blend in with the device should use a theme from the
  ///      android.R.style\#Theme_DeviceDefault family.
  /// <li> Managed cursors can now throw an exception if you directly close
  /// the cursor yourself without stopping the management of it; previously failures
  /// would be silently ignored.
  /// <li> The fadingEdge attribute on views will be ignored (fading edges is no
  /// longer a standard part of the UI).  A new requiresFadingEdge attribute allows
  /// applications to still force fading edges on for special cases.
  /// <li> android.content.Context\#bindService Context.bindService()
  /// will not automatically add in android.content.Context\#BIND_WAIVE_PRIORITY.
  /// <li> App Widgets will have standard padding automatically added around
  /// them, rather than relying on the padding being baked into the widget itself.
  /// <li> An exception will be thrown if you try to change the type of a
  /// window after it has been added to the window manager.  Previously this
  /// would result in random incorrect behavior.
  /// <li> android.view.animation.AnimationSet will parse out
  /// the duration, fillBefore, fillAfter, repeatMode, and startOffset
  /// XML attributes that are defined.
  /// <li> android.app.ActionBar\#setHomeButtonEnabled ActionBar.setHomeButtonEnabled() is false by default.
  /// </ul>
  static const ICE_CREAM_SANDWICH = 14;

  /// from: static public final int ICE_CREAM_SANDWICH_MR1
  /// December 2011: Android 4.0.3.
  static const ICE_CREAM_SANDWICH_MR1 = 15;

  /// from: static public final int JELLY_BEAN
  /// June 2012: Android 4.1.
  ///
  /// Applications targeting this or a later release will get these
  /// new changes in behavior:
  ///
  /// <ul>
  /// <li> You must explicitly request the android.Manifest.permission\#READ_CALL_LOG
  /// and/or android.Manifest.permission\#WRITE_CALL_LOG permissions;
  /// access to the call log is no longer implicitly provided through
  /// android.Manifest.permission\#READ_CONTACTS and
  /// android.Manifest.permission\#WRITE_CONTACTS.
  /// <li> android.widget.RemoteViews will throw an exception if
  /// setting an onClick handler for views being generated by a
  /// android.widget.RemoteViewsService for a collection container;
  /// previously this just resulted in a warning log message.
  /// <li> New android.app.ActionBar policy for embedded tabs:
  /// embedded tabs are now always stacked in the action bar when in portrait
  /// mode, regardless of the size of the screen.
  /// <li> android.webkit.WebSettings\#setAllowFileAccessFromFileURLs(boolean) WebSettings.setAllowFileAccessFromFileURLs and
  /// android.webkit.WebSettings\#setAllowUniversalAccessFromFileURLs(boolean) WebSettings.setAllowUniversalAccessFromFileURLs default to false.
  /// <li> Calls to android.content.pm.PackageManager\#setComponentEnabledSetting PackageManager.setComponentEnabledSetting will now throw an
  /// IllegalArgumentException if the given component class name does not
  /// exist in the application's manifest.
  /// <li> android.nfc.NfcAdapter\#setNdefPushMessage NfcAdapter.setNdefPushMessage,
  /// android.nfc.NfcAdapter\#setNdefPushMessageCallback NfcAdapter.setNdefPushMessageCallback and
  /// android.nfc.NfcAdapter\#setOnNdefPushCompleteCallback NfcAdapter.setOnNdefPushCompleteCallback will throw
  /// IllegalStateException if called after the Activity has been destroyed.
  /// <li> Accessibility services must require the new
  /// android.Manifest.permission\#BIND_ACCESSIBILITY_SERVICE permission or
  /// they will not be available for use.
  /// <li> android.accessibilityservice.AccessibilityServiceInfo\#FLAG_INCLUDE_NOT_IMPORTANT_VIEWS AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS must be set
  /// for unimportant views to be included in queries.
  /// </ul>
  static const JELLY_BEAN = 16;

  /// from: static public final int JELLY_BEAN_MR1
  /// November 2012: Android 4.2, Moar jelly beans!
  ///
  /// Applications targeting this or a later release will get these
  /// new changes in behavior:
  ///
  /// <ul>
  /// <li>Content Providers: The default value of {@code android:exported} is now
  /// {@code false}. See
  /// <a href="{@docRoot}guide/topics/manifest/provider-element.html\#exported">
  /// the android:exported section</a> in the provider documentation for more details.</li>
  /// <li>android.view.View\#getLayoutDirection() View.getLayoutDirection()
  /// can return different values than android.view.View\#LAYOUT_DIRECTION_LTR
  /// based on the locale etc.
  /// <li> android.webkit.WebView\#addJavascriptInterface(Object, String) WebView.addJavascriptInterface requires explicit annotations on methods
  /// for them to be accessible from Javascript.
  /// </ul>
  static const JELLY_BEAN_MR1 = 17;

  /// from: static public final int JELLY_BEAN_MR2
  /// July 2013: Android 4.3, the revenge of the beans.
  static const JELLY_BEAN_MR2 = 18;

  /// from: static public final int KITKAT
  /// October 2013: Android 4.4, KitKat, another tasty treat.
  ///
  /// Applications targeting this or a later release will get these
  /// new changes in behavior:
  ///
  /// <ul>
  /// <li> The default result of
  /// android.preference.PreferenceActivity\#isValidFragment(String) PreferenceActivity.isValueFragment becomes false instead of true.</li>
  /// <li> In android.webkit.WebView, apps targeting earlier versions will have
  /// JS URLs evaluated directly and any result of the evaluation will not replace
  /// the current page content.  Apps targetting KITKAT or later that load a JS URL will
  /// have the result of that URL replace the content of the current page</li>
  /// <li> android.app.AlarmManager\#set AlarmManager.set becomes interpreted as
  /// an inexact value, to give the system more flexibility in scheduling alarms.</li>
  /// <li> android.content.Context\#getSharedPreferences(String, int) Context.getSharedPreferences no longer allows a null name.</li>
  /// <li> android.widget.RelativeLayout changes to compute wrapped content
  /// margins correctly.</li>
  /// <li> android.app.ActionBar's window content overlay is allowed to be
  /// drawn.</li>
  /// <li>The android.Manifest.permission\#READ_EXTERNAL_STORAGE
  /// permission is now always enforced.</li>
  /// <li>Access to package-specific external storage directories belonging
  /// to the calling app no longer requires the
  /// android.Manifest.permission\#READ_EXTERNAL_STORAGE or
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE
  /// permissions.</li>
  /// </ul>
  static const KITKAT = 19;

  /// from: static public final int KITKAT_WATCH
  /// June 2014: Android 4.4W. KitKat for watches, snacks on the run.
  ///
  /// Applications targeting this or a later release will get these
  /// new changes in behavior:
  ///
  /// <ul>
  /// <li>android.app.AlertDialog might not have a default background if the theme does
  /// not specify one.</li>
  /// </ul>
  static const KITKAT_WATCH = 20;

  /// from: static public final int LOLLIPOP
  /// November 2014: Lollipop.  A flat one with beautiful shadows.  But still tasty.
  ///
  /// Applications targeting this or a later release will get these
  /// new changes in behavior:
  ///
  /// <ul>
  /// <li> android.content.Context\#bindService Context.bindService now
  /// requires an explicit Intent, and will throw an exception if given an implicit
  /// Intent.</li>
  /// <li> android.app.Notification.Builder Notification.Builder will
  /// not have the colors of their various notification elements adjusted to better
  /// match the new material design look.</li>
  /// <li> android.os.Message will validate that a message is not currently
  /// in use when it is recycled.</li>
  /// <li> Hardware accelerated drawing in windows will be enabled automatically
  /// in most places.</li>
  /// <li> android.widget.Spinner throws an exception if attaching an
  /// adapter with more than one item type.</li>
  /// <li> If the app is a launcher, the launcher will be available to the user
  /// even when they are using corporate profiles (which requires that the app
  /// use android.content.pm.LauncherApps to correctly populate its
  /// apps UI).</li>
  /// <li> Calling android.app.Service\#stopForeground Service.stopForeground
  /// with removeNotification false will modify the still posted notification so that
  /// it is no longer forced to be ongoing.</li>
  /// <li> A android.service.dreams.DreamService must require the
  /// android.Manifest.permission\#BIND_DREAM_SERVICE permission to be usable.</li>
  /// </ul>
  static const LOLLIPOP = 21;

  /// from: static public final int LOLLIPOP_MR1
  /// March 2015: Lollipop with an extra sugar coating on the outside!
  static const LOLLIPOP_MR1 = 22;

  /// from: static public final int M
  /// M is for Marshmallow!
  ///
  /// Applications targeting this or a later release will get these
  /// new changes in behavior:
  ///
  /// <ul>
  /// <li> Runtime permissions.  Dangerous permissions are no longer granted at
  /// install time, but must be requested by the application at runtime through
  /// android.app.Activity\#requestPermissions.</li>
  /// <li> Bluetooth and Wi-Fi scanning now requires holding the location permission.</li>
  /// <li> android.app.AlarmManager\#setTimeZone AlarmManager.setTimeZone will fail if
  /// the given timezone is non-Olson.</li>
  /// <li> Activity transitions will only return shared
  /// elements mapped in the returned view hierarchy back to the calling activity.</li>
  /// <li> android.view.View allows a number of behaviors that may break
  /// existing apps: Canvas throws an exception if restore() is called too many times,
  /// widgets may return a hint size when returning UNSPECIFIED measure specs, and it
  /// will respect the attributes android.R.attr\#foreground,
  /// android.R.attr\#foregroundGravity, android.R.attr\#foregroundTint, and
  /// android.R.attr\#foregroundTintMode.</li>
  /// <li> android.view.MotionEvent\#getButtonState MotionEvent.getButtonState
  /// will no longer report android.view.MotionEvent\#BUTTON_PRIMARY
  /// and android.view.MotionEvent\#BUTTON_SECONDARY as synonyms for
  /// android.view.MotionEvent\#BUTTON_STYLUS_PRIMARY and
  /// android.view.MotionEvent\#BUTTON_STYLUS_SECONDARY.</li>
  /// <li> android.widget.ScrollView now respects the layout param margins
  /// when measuring.</li>
  /// </ul>
  static const M = 23;

  /// from: static public final int N
  /// N is for Nougat.
  ///
  /// Applications targeting this or a later release will get these
  /// new changes in behavior:
  ///
  /// <ul>
  /// <li> android.app.DownloadManager.Request\#setAllowedNetworkTypes DownloadManager.Request.setAllowedNetworkTypes
  /// will disable "allow over metered" when specifying only
  /// android.app.DownloadManager.Request\#NETWORK_WIFI.</li>
  /// <li> android.app.DownloadManager no longer allows access to raw
  /// file paths.</li>
  /// <li> android.app.Notification.Builder\#setShowWhen Notification.Builder.setShowWhen
  /// must be called explicitly to have the time shown, and various other changes in
  /// android.app.Notification.Builder Notification.Builder to how notifications
  /// are shown.</li>
  /// <li>android.content.Context\#MODE_WORLD_READABLE and
  /// android.content.Context\#MODE_WORLD_WRITEABLE are no longer supported.</li>
  /// <li>android.os.FileUriExposedException will be thrown to applications.</li>
  /// <li>Applications will see global drag and drops as per
  /// android.view.View\#DRAG_FLAG_GLOBAL.</li>
  /// <li>android.webkit.WebView\#evaluateJavascript WebView.evaluateJavascript
  /// will not persist state from an empty WebView.</li>
  /// <li>android.animation.AnimatorSet will not ignore calls to end() before
  /// start().</li>
  /// <li>android.app.AlarmManager\#cancel(android.app.PendingIntent) AlarmManager.cancel will throw a NullPointerException if given a null operation.</li>
  /// <li>android.app.FragmentManager will ensure fragments have been created
  /// before being placed on the back stack.</li>
  /// <li>android.app.FragmentManager restores fragments in
  /// android.app.Fragment\#onCreate Fragment.onCreate rather than after the
  /// method returns.</li>
  /// <li>android.R.attr\#resizeableActivity defaults to true.</li>
  /// <li>android.graphics.drawable.AnimatedVectorDrawable throws exceptions when
  /// opening invalid VectorDrawable animations.</li>
  /// <li>android.view.ViewGroup.MarginLayoutParams will no longer be dropped
  /// when converting between some types of layout params (such as
  /// android.widget.LinearLayout.LayoutParams LinearLayout.LayoutParams to
  /// android.widget.RelativeLayout.LayoutParams RelativeLayout.LayoutParams).</li>
  /// <li>Your application processes will not be killed when the device density changes.</li>
  /// <li>Drag and drop. After a view receives the
  /// android.view.DragEvent\#ACTION_DRAG_ENTERED event, when the drag shadow moves into
  /// a descendant view that can accept the data, the view receives the
  /// android.view.DragEvent\#ACTION_DRAG_EXITED event and won\u2019t receive
  /// android.view.DragEvent\#ACTION_DRAG_LOCATION and
  /// android.view.DragEvent\#ACTION_DROP events while the drag shadow is within that
  /// descendant view, even if the descendant view returns <code>false</code> from its handler
  /// for these events.</li>
  /// </ul>
  static const N = 24;

  /// from: static public final int N_MR1
  /// N MR1: Nougat++.
  static const N_MR1 = 25;

  /// from: static public final int O
  /// O.
  ///
  /// Applications targeting this or a later release will get these
  /// new changes in behavior:
  ///
  /// <ul>
  /// <li><a href="{@docRoot}about/versions/oreo/background.html">Background execution limits</a>
  /// are applied to the application.</li>
  /// <li>The behavior of AccountManager's
  /// android.accounts.AccountManager\#getAccountsByType,
  /// android.accounts.AccountManager\#getAccountsByTypeAndFeatures, and
  /// android.accounts.AccountManager\#hasFeatures has changed as documented there.</li>
  /// <li>android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_PERCEPTIBLE_PRE_26
  /// is now returned as
  /// android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_PERCEPTIBLE.</li>
  /// <li>The android.app.NotificationManager now requires the use of notification
  /// channels.</li>
  /// <li>Changes to the strict mode that are set in
  /// Application\#onCreate Application.onCreate will no longer be clobbered after
  /// that function returns.</li>
  /// <li>A shared library apk with native code will have that native code included in
  /// the library path of its clients.</li>
  /// <li>android.content.Context\#getSharedPreferences Context.getSharedPreferences
  /// in credential encrypted storage will throw an exception before the user is unlocked.</li>
  /// <li>Attempting to retrieve a Context\#FINGERPRINT_SERVICE on a device that
  /// does not support that feature will now throw a runtime exception.</li>
  /// <li>android.app.Fragment will stop any active view animations when
  /// the fragment is stopped.</li>
  /// <li>Some compatibility code in Resources that attempts to use the default Theme
  /// the app may be using will be turned off, requiring the app to explicitly request
  /// resources with the right theme.</li>
  /// <li>android.content.ContentResolver\#notifyChange ContentResolver.notifyChange and
  /// android.content.ContentResolver\#registerContentObserver ContentResolver.registerContentObserver
  /// will throw a SecurityException if the caller does not have permission to access
  /// the provider (or the provider doesn't exit); otherwise the call will be silently
  /// ignored.</li>
  /// <li>android.hardware.camera2.CameraDevice\#createCaptureRequest CameraDevice.createCaptureRequest will enable
  /// android.hardware.camera2.CaptureRequest\#CONTROL_ENABLE_ZSL by default for
  /// still image capture.</li>
  /// <li>WallpaperManager's android.app.WallpaperManager\#getWallpaperFile,
  /// android.app.WallpaperManager\#getDrawable,
  /// android.app.WallpaperManager\#getFastDrawable,
  /// android.app.WallpaperManager\#peekDrawable, and
  /// android.app.WallpaperManager\#peekFastDrawable will throw an exception
  /// if you can not access the wallpaper.</li>
  /// <li>The behavior of
  /// android.hardware.usb.UsbDeviceConnection\#requestWait UsbDeviceConnection.requestWait
  /// is modified as per the documentation there.</li>
  /// <li>StrictMode.VmPolicy.Builder\#detectAll StrictMode.VmPolicy.Builder.detectAll
  /// will also enable StrictMode.VmPolicy.Builder\#detectContentUriWithoutPermission
  /// and StrictMode.VmPolicy.Builder\#detectUntaggedSockets.</li>
  /// <li>StrictMode.ThreadPolicy.Builder\#detectAll StrictMode.ThreadPolicy.Builder.detectAll
  /// will also enable StrictMode.ThreadPolicy.Builder\#detectUnbufferedIo.</li>
  /// <li>android.provider.DocumentsContract's various methods will throw failure
  /// exceptions back to the caller instead of returning null.
  /// <li>View\#hasFocusable View.hasFocusable now includes auto-focusable views.</li>
  /// <li>android.view.SurfaceView will no longer always change the underlying
  /// Surface object when something about it changes; apps need to look at the current
  /// state of the object to determine which things they are interested in have changed.</li>
  /// <li>android.view.WindowManager.LayoutParams\#TYPE_APPLICATION_OVERLAY must be
  /// used for overlay windows, other system overlay window types are not allowed.</li>
  /// <li>android.view.ViewTreeObserver\#addOnDrawListener ViewTreeObserver.addOnDrawListener will throw an exception if called from within
  /// onDraw.</li>
  /// <li>android.graphics.Canvas\#setBitmap Canvas.setBitmap will no longer preserve
  /// the current matrix and clip stack of the canvas.</li>
  /// <li>android.widget.ListPopupWindow\#setHeight ListPopupWindow.setHeight
  /// will throw an exception if a negative height is supplied.</li>
  /// <li>android.widget.TextView will use internationalized input for numbers,
  /// dates, and times.</li>
  /// <li>android.widget.Toast must be used for showing toast windows; the toast
  /// window type can not be directly used.</li>
  /// <li>android.net.wifi.WifiManager\#getConnectionInfo WifiManager.getConnectionInfo
  /// requires that the caller hold the location permission to return BSSID/SSID</li>
  /// <li>android.net.wifi.p2p.WifiP2pManager\#requestPeers WifiP2pManager.requestPeers
  /// requires the caller hold the location permission.</li>
  /// <li>android.R.attr\#maxAspectRatio defaults to 0, meaning there is no restriction
  /// on the app's maximum aspect ratio (so it can be stretched to fill larger screens).</li>
  /// <li>android.R.attr\#focusable defaults to a new state ({@code auto}) where it will
  /// inherit the value of android.R.attr\#clickable unless explicitly overridden.</li>
  /// <li>A default theme-appropriate focus-state highlight will be supplied to all Views
  /// which don't provide a focus-state drawable themselves. This can be disabled by setting
  /// android.R.attr\#defaultFocusHighlightEnabled to false.</li>
  /// </ul>
  static const O = 26;

  /// from: static public final int O_MR1
  /// O MR1.
  ///
  /// Applications targeting this or a later release will get these
  /// new changes in behavior:
  ///
  /// <ul>
  /// <li>Apps exporting and linking to apk shared libraries must explicitly
  /// enumerate all signing certificates in a consistent order.</li>
  /// <li>android.R.attr\#screenOrientation can not be used to request a fixed
  /// orientation if the associated activity is not fullscreen and opaque.</li>
  /// </ul>
  static const O_MR1 = 27;

  /// from: static public final int P
  /// P.
  ///
  /// Applications targeting this or a later release will get these
  /// new changes in behavior:
  ///
  /// <ul>
  /// <li>android.app.Service\#startForeground Service.startForeground requires
  /// that apps hold the permission
  /// android.Manifest.permission\#FOREGROUND_SERVICE.</li>
  /// <li>android.widget.LinearLayout will always remeasure weighted children,
  /// even if there is no excess space.</li>
  /// </ul>
  static const P = 28;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Build__VERSION_CODES_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Build_VERSION_CODES() : super.fromRef(_ctor());
}

/// Various version strings.
class Build_VERSION extends jni.JlObject {
  Build_VERSION.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String BASE_OS
  /// The base OS build the product is based on.
  static final _getBASE_OS =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build__VERSION_BASE_OS")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get BASE_OS => jni.JlString.fromRef(_getBASE_OS());

  /// from: static public final java.lang.String CODENAME
  /// The current development codename, or the string "REL" if this is
  /// a release build.
  static final _getCODENAME =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build__VERSION_CODENAME")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get CODENAME => jni.JlString.fromRef(_getCODENAME());

  /// from: static public final java.lang.String INCREMENTAL
  /// The internal value used by the underlying source control to
  /// represent this build.  E.g., a perforce changelist number
  /// or a git hash.
  static final _getINCREMENTAL =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build__VERSION_INCREMENTAL")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get INCREMENTAL =>
      jni.JlString.fromRef(_getINCREMENTAL());

  /// from: static public final int PREVIEW_SDK_INT
  /// The developer preview revision of a prerelease SDK. This value will always
  /// be <code>0</code> on production platform builds/devices.
  ///
  /// When this value is nonzero, any new API added since the last
  /// officially published \#SDK_INT API level is only guaranteed to be present
  /// on that specific preview revision. For example, an API <code>Activity.fooBar()</code>
  /// might be present in preview revision 1 but renamed or removed entirely in
  /// preview revision 2, which may cause an app attempting to call it to crash
  /// at runtime.
  ///
  ///
  /// Experimental apps targeting preview APIs should check this value for
  /// equality (<code>==</code>) with the preview SDK revision they were built for
  /// before using any prerelease platform APIs. Apps that detect a preview SDK revision
  /// other than the specific one they expect should fall back to using APIs from
  /// the previously published API level only to avoid unwanted runtime exceptions.
  ///
  ///
  static final _getPREVIEW_SDK_INT =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "get_android_os_Build__VERSION_PREVIEW_SDK_INT")
          .asFunction<int Function()>();
  static int get PREVIEW_SDK_INT => _getPREVIEW_SDK_INT();

  /// from: static public final java.lang.String RELEASE
  /// The user-visible version string.  E.g., "1.0" or "3.4b5".
  static final _getRELEASE =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build__VERSION_RELEASE")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get RELEASE => jni.JlString.fromRef(_getRELEASE());

  /// from: static public final java.lang.String SDK
  /// The user-visible SDK version of the framework in its raw String
  /// representation; use \#SDK_INT instead.
  ///@deprecated Use \#SDK_INT to easily get this as an integer.
  static final _getSDK =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build__VERSION_SDK")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get SDK => jni.JlString.fromRef(_getSDK());

  /// from: static public final int SDK_INT
  /// The SDK version of the software currently running on this hardware
  /// device. This value never changes while a device is booted, but it may
  /// increase when the hardware manufacturer provides an OTA update.
  ///
  /// Possible values are defined in Build.VERSION_CODES.
  ///@see \#FIRST_SDK_INT
  static final _getSDK_INT = jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          "get_android_os_Build__VERSION_SDK_INT")
      .asFunction<int Function()>();
  static int get SDK_INT => _getSDK_INT();

  /// from: static public final java.lang.String SECURITY_PATCH
  /// The user-visible security patch level.
  static final _getSECURITY_PATCH =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Build__VERSION_SECURITY_PATCH")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get SECURITY_PATCH =>
      jni.JlString.fromRef(_getSECURITY_PATCH());

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Build__VERSION_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Build_VERSION() : super.fromRef(_ctor());
}

/// This class is a Parcelable wrapper around UUID which is an
/// immutable representation of a 128-bit universally unique
/// identifier.
class ParcelUuid extends jni.JlObject {
  ParcelUuid.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.os.ParcelUuid> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_ParcelUuid_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static Parcelable_Creator get CREATOR =>
      Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_ParcelUuid_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.util.UUID uuid)
  /// Constructor creates a ParcelUuid instance from the
  /// given UUID.
  ///@param uuid UUID
  ParcelUuid(jni.JlObject uuid) : super.fromRef(_ctor(uuid.reference));

  static final _fromString = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_ParcelUuid_fromString")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.ParcelUuid fromString(java.lang.String uuid)
  /// Creates a new ParcelUuid from a string representation of UUID.
  ///@param uuid the UUID string to parse.
  ///@return a ParcelUuid instance.
  ///@throws NullPointerException if {@code uuid} is {@code null}.
  ///@throws IllegalArgumentException if {@code uuid} is not formatted correctly.
  static ParcelUuid fromString(jni.JlString uuid) =>
      ParcelUuid.fromRef(_fromString(uuid.reference));

  static final _getUuid = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_ParcelUuid_getUuid")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.UUID getUuid()
  /// Get the UUID represented by the ParcelUuid.
  ///@return UUID contained in the ParcelUuid.
  jni.JlObject getUuid() => jni.JlObject.fromRef(_getUuid(reference));

  static final _toString_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_ParcelUuid_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// Returns a string representation of the ParcelUuid
  /// For example: 0000110B-0000-1000-8000-00805F9B34FB will be the return value.
  ///@return a String instance.
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _hashCode_1 =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ParcelUuid_hashCode_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode_1() => _hashCode_1(reference);

  static final _equals_1 = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_ParcelUuid_equals_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  /// Compares this ParcelUuid to another object for equality. If {@code object}
  /// is not {@code null}, is a ParcelUuid instance, and all bits are equal, then
  /// {@code true} is returned.
  ///@param object the {@code Object} to compare to.
  ///@return {@code true} if this ParcelUuid is equal to {@code object}
  ///         or {@code false} if not.
  bool equals_1(jni.JlObject object) =>
      _equals_1(reference, object.reference) != 0;

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ParcelUuid_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_ParcelUuid_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);
}

/// LocaleList is an immutable list of Locales, typically used to keep an ordered list of user
/// preferences for locales.
class LocaleList extends jni.JlObject {
  LocaleList.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.os.LocaleList> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_LocaleList_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static Parcelable_Creator get CREATOR =>
      Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_LocaleList_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.util.Locale[] list)
  /// Creates a new LocaleList.
  ///
  /// For empty lists of Locale items it is better to use \#getEmptyLocaleList(),
  /// which returns a pre-constructed empty list.
  ///
  ///@throws NullPointerException if any of the input locales is <code>null</code>.
  ///@throws IllegalArgumentException if any of the input locales repeat.
  ///@param list This value must never be {@code null}.
  LocaleList(jni.JlObject list) : super.fromRef(_ctor(list.reference));

  static final _get_ = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_LocaleList_get_")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.util.Locale get(int index)
  /// Retrieves the Locale at the specified index.
  ///@param index The position to retrieve.
  ///@return The Locale in the given index.
  jni.JlObject get_(int index) => jni.JlObject.fromRef(_get_(reference, index));

  static final _isEmpty =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_LocaleList_isEmpty")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isEmpty()
  /// Returns whether the LocaleList contains no Locale items.
  ///@return {@code true} if this LocaleList has no Locale items, {@code false}
  ///     otherwise.
  bool isEmpty() => _isEmpty(reference) != 0;

  static final _size =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_LocaleList_size")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int size()
  /// Returns the number of Locale items in this LocaleList.
  ///@return Value is 0 or greater
  int size() => _size(reference);

  static final _indexOf = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_LocaleList_indexOf")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int indexOf(java.util.Locale locale)
  /// Searches this LocaleList for the specified Locale and returns the index of
  /// the first occurrence.
  ///@param locale The Locale to search for.
  ///@return The index of the first occurrence of the Locale or {@code -1} if the item
  ///     wasn't found.
  ///
  /// Value is -1 or greater
  int indexOf(jni.JlObject locale) => _indexOf(reference, locale.reference);

  static final _equals_1 = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_LocaleList_equals_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object other)
  bool equals_1(jni.JlObject other) =>
      _equals_1(reference, other.reference) != 0;

  static final _hashCode_1 =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_LocaleList_hashCode_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode_1() => _hashCode_1(reference);

  static final _toString_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_LocaleList_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_LocaleList_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_LocaleList_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags);

  static final _toLanguageTags = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_LocaleList_toLanguageTags")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toLanguageTags()
  /// Retrieves a String representation of the language tags in this list.
  ///@return This value will never be {@code null}.
  jni.JlString toLanguageTags() =>
      jni.JlString.fromRef(_toLanguageTags(reference));

  static final _getEmptyLocaleList =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_LocaleList_getEmptyLocaleList")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.os.LocaleList getEmptyLocaleList()
  /// Retrieve an empty instance of LocaleList.
  ///@return This value will never be {@code null}.
  static LocaleList getEmptyLocaleList() =>
      LocaleList.fromRef(_getEmptyLocaleList());

  static final _forLanguageTags = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_LocaleList_forLanguageTags")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.LocaleList forLanguageTags(java.lang.String list)
  /// Generates a new LocaleList with the given language tags.
  ///@param list The language tags to be included as a single String separated by commas.
  /// This value may be {@code null}.
  ///@return A new instance with the Locale items identified by the given tags.
  ///
  /// This value will never be {@code null}.
  static LocaleList forLanguageTags(jni.JlString list) =>
      LocaleList.fromRef(_forLanguageTags(list.reference));

  static final _getFirstMatch = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_LocaleList_getFirstMatch")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Locale getFirstMatch(java.lang.String[] supportedLocales)
  /// Returns the first match in the locale list given an unordered array of supported locales
  /// in BCP 47 format.
  ///@return The first Locale from this list that appears in the given array, or
  ///     {@code null} if the LocaleList is empty.
  jni.JlObject getFirstMatch(jni.JlObject supportedLocales) =>
      jni.JlObject.fromRef(
          _getFirstMatch(reference, supportedLocales.reference));

  static final _getDefault =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_LocaleList_getDefault")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.os.LocaleList getDefault()
  /// The result is guaranteed to include the default Locale returned by Locale.getDefault(), but
  /// not necessarily at the top of the list. The default locale not being at the top of the list
  /// is an indication that the system has set the default locale to one of the user's other
  /// preferred locales, having concluded that the primary preference is not supported but a
  /// secondary preference is.
  ///
  /// Note that the default LocaleList would change if Locale.setDefault() is called. This
  /// method takes that into account by always checking the output of Locale.getDefault() and
  /// recalculating the default LocaleList if needed.
  ///
  ///@return This value will never be {@code null}.
  static LocaleList getDefault() => LocaleList.fromRef(_getDefault());

  static final _getAdjustedDefault =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_LocaleList_getAdjustedDefault")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.os.LocaleList getAdjustedDefault()
  /// Returns the default locale list, adjusted by moving the default locale to its first
  /// position.
  ///@return This value will never be {@code null}.
  static LocaleList getAdjustedDefault() =>
      LocaleList.fromRef(_getAdjustedDefault());

  static final _setDefault =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_LocaleList_setDefault")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void setDefault(android.os.LocaleList locales)
  /// Also sets the default locale by calling Locale.setDefault() with the first locale in the
  /// list.
  ///@throws NullPointerException if the input is <code>null</code>.
  ///@throws IllegalArgumentException if the input is empty.
  ///@param locales This value must never be {@code null}.
  static void setDefault(LocaleList locales) => _setDefault(locales.reference);
}

/// Container for a message (data and object references) that can
/// be sent through an IBinder.  A Parcel can contain both flattened data
/// that will be unflattened on the other side of the IPC (using the various
/// methods here for writing specific types, or the general
/// Parcelable interface), and references to live IBinder
/// objects that will result in the other side receiving a proxy IBinder
/// connected with the original IBinder in the Parcel.
///
/// <p class="note">Parcel is <strong>not</strong> a general-purpose
/// serialization mechanism.  This class (and the corresponding
/// Parcelable API for placing arbitrary objects into a Parcel) is
/// designed as a high-performance IPC transport.  As such, it is not
/// appropriate to place any Parcel data in to persistent storage: changes
/// in the underlying implementation of any of the data in the Parcel can
/// render older data unreadable.
///
///
/// The bulk of the Parcel API revolves around reading and writing data
/// of various types.  There are six major classes of such functions available.
///
///
/// <h3>Primitives</h3>
///
/// The most basic data functions are for writing and reading primitive
/// data types: \#writeByte, \#readByte, \#writeDouble,
/// \#readDouble, \#writeFloat, \#readFloat, \#writeInt,
/// \#readInt, \#writeLong, \#readLong,
/// \#writeString, \#readString.  Most other
/// data operations are built on top of these.  The given data is written and
/// read using the endianess of the host CPU.
///
///
/// <h3>Primitive Arrays</h3>
///
/// There are a variety of methods for reading and writing raw arrays
/// of primitive objects, which generally result in writing a 4-byte length
/// followed by the primitive data items.  The methods for reading can either
/// read the data into an existing array, or create and return a new array.
/// These available types are:
///
///
/// <ul>
/// <li> \#writeBooleanArray(boolean[]),
/// \#readBooleanArray(boolean[]), \#createBooleanArray()
/// <li> \#writeByteArray(byte[]),
/// \#writeByteArray(byte[], int, int), \#readByteArray(byte[]),
/// \#createByteArray()
/// <li> \#writeCharArray(char[]), \#readCharArray(char[]),
/// \#createCharArray()
/// <li> \#writeDoubleArray(double[]), \#readDoubleArray(double[]),
/// \#createDoubleArray()
/// <li> \#writeFloatArray(float[]), \#readFloatArray(float[]),
/// \#createFloatArray()
/// <li> \#writeIntArray(int[]), \#readIntArray(int[]),
/// \#createIntArray()
/// <li> \#writeLongArray(long[]), \#readLongArray(long[]),
/// \#createLongArray()
/// <li> \#writeStringArray(String[]), \#readStringArray(String[]),
/// \#createStringArray().
/// <li> \#writeSparseBooleanArray(SparseBooleanArray),
/// \#readSparseBooleanArray().
/// </ul>
///
/// <h3>Parcelables</h3>
///
/// The Parcelable protocol provides an extremely efficient (but
/// low-level) protocol for objects to write and read themselves from Parcels.
/// You can use the direct methods \#writeParcelable(Parcelable, int)
/// and \#readParcelable(ClassLoader) or
/// \#writeParcelableArray and
/// \#readParcelableArray(ClassLoader) to write or read.  These
/// methods write both the class type and its data to the Parcel, allowing
/// that class to be reconstructed from the appropriate class loader when
/// later reading.
///
///
/// There are also some methods that provide a more efficient way to work
/// with Parcelables: \#writeTypedObject, \#writeTypedArray,
/// \#writeTypedList, \#readTypedObject,
/// \#createTypedArray and \#createTypedArrayList.  These methods
/// do not write the class information of the original object: instead, the
/// caller of the read function must know what type to expect and pass in the
/// appropriate Parcelable.Creator Parcelable.Creator instead to
/// properly construct the new object and read its data.  (To more efficient
/// write and read a single Parcelable object that is not null, you can directly
/// call Parcelable\#writeToParcel Parcelable.writeToParcel and
/// Parcelable.Creator\#createFromParcel Parcelable.Creator.createFromParcel
/// yourself.)
///
///
/// <h3>Bundles</h3>
///
/// A special type-safe container, called Bundle, is available
/// for key/value maps of heterogeneous values.  This has many optimizations
/// for improved performance when reading and writing data, and its type-safe
/// API avoids difficult to debug type errors when finally marshalling the
/// data contents into a Parcel.  The methods to use are
/// \#writeBundle(Bundle), \#readBundle(), and
/// \#readBundle(ClassLoader).
///
/// <h3>Active Objects</h3>
///
/// An unusual feature of Parcel is the ability to read and write active
/// objects.  For these objects the actual contents of the object is not
/// written, rather a special token referencing the object is written.  When
/// reading the object back from the Parcel, you do not get a new instance of
/// the object, but rather a handle that operates on the exact same object that
/// was originally written.  There are two forms of active objects available.
///
///
/// Binder objects are a core facility of Android's general cross-process
/// communication system.  The IBinder interface describes an abstract
/// protocol with a Binder object.  Any such interface can be written in to
/// a Parcel, and upon reading you will receive either the original object
/// implementing that interface or a special proxy implementation
/// that communicates calls back to the original object.  The methods to use are
/// \#writeStrongBinder(IBinder),
/// \#writeStrongInterface(IInterface), \#readStrongBinder(),
/// \#writeBinderArray(IBinder[]), \#readBinderArray(IBinder[]),
/// \#createBinderArray(),
/// \#writeBinderList(List), \#readBinderList(List),
/// \#createBinderArrayList().
///
///
/// FileDescriptor objects, representing raw Linux file descriptor identifiers,
/// can be written and ParcelFileDescriptor objects returned to operate
/// on the original file descriptor.  The returned file descriptor is a dup
/// of the original file descriptor: the object and fd is different, but
/// operating on the same underlying file stream, with the same position, etc.
/// The methods to use are \#writeFileDescriptor(FileDescriptor),
/// \#readFileDescriptor().
///
/// <h3>Untyped Containers</h3>
///
/// A final class of methods are for writing and reading standard Java
/// containers of arbitrary types.  These all revolve around the
/// \#writeValue(Object) and \#readValue(ClassLoader) methods
/// which define the types of objects allowed.  The container methods are
/// \#writeArray(Object[]), \#readArray(ClassLoader),
/// \#writeList(List), \#readList(List, ClassLoader),
/// \#readArrayList(ClassLoader),
/// \#writeMap(Map), \#readMap(Map, ClassLoader),
/// \#writeSparseArray(SparseArray),
/// \#readSparseArray(ClassLoader).
class Parcel extends jni.JlObject {
  Parcel.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<java.lang.String> STRING_CREATOR
  static final _getSTRING_CREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Parcel_STRING_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static Parcelable_Creator get STRING_CREATOR =>
      Parcelable_Creator.fromRef(_getSTRING_CREATOR());

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int64)>>(
              "android_os_Parcel_new")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: void <init>(long nativePtr)
  Parcel(int nativePtr) : super.fromRef(_ctor(nativePtr));

  static final _obtain =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Parcel_obtain")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.os.Parcel obtain()
  /// Retrieve a new Parcel object from the pool.
  static Parcel obtain() => Parcel.fromRef(_obtain());

  static final _recycle =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Parcel_recycle")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void recycle()
  /// Put a Parcel object back into the pool.  You must not touch
  /// the object after this call.
  void recycle() => _recycle(reference);

  static final _dataSize =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Parcel_dataSize")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int dataSize()
  /// Returns the total amount of data contained in the parcel.
  int dataSize() => _dataSize(reference);

  static final _dataAvail =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Parcel_dataAvail")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int dataAvail()
  /// Returns the amount of data remaining to be read from the
  /// parcel.  That is, \#dataSize-\#dataPosition.
  int dataAvail() => _dataAvail(reference);

  static final _dataPosition =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Parcel_dataPosition")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int dataPosition()
  /// Returns the current position in the parcel data.  Never
  /// more than \#dataSize.
  int dataPosition() => _dataPosition(reference);

  static final _dataCapacity =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Parcel_dataCapacity")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int dataCapacity()
  /// Returns the total amount of space in the parcel.  This is always
  /// >= \#dataSize.  The difference between it and dataSize() is the
  /// amount of room left until the parcel needs to re-allocate its
  /// data buffer.
  int dataCapacity() => _dataCapacity(reference);

  static final _setDataSize = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Parcel_setDataSize")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setDataSize(int size)
  /// Change the amount of data in the parcel.  Can be either smaller or
  /// larger than the current size.  If larger than the current capacity,
  /// more memory will be allocated.
  ///@param size The new number of bytes in the Parcel.
  void setDataSize(int size) => _setDataSize(reference, size);

  static final _setDataPosition = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Parcel_setDataPosition")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setDataPosition(int pos)
  /// Move the current read/write position in the parcel.
  ///@param pos New offset in the parcel; must be between 0 and
  /// \#dataSize.
  void setDataPosition(int pos) => _setDataPosition(reference, pos);

  static final _setDataCapacity = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Parcel_setDataCapacity")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setDataCapacity(int size)
  /// Change the capacity (current available space) of the parcel.
  ///@param size The new capacity of the parcel, in bytes.  Can not be
  /// less than \#dataSize -- that is, you can not drop existing data
  /// with this method.
  void setDataCapacity(int size) => _setDataCapacity(reference, size);

  static final _marshall = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_marshall")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public byte[] marshall()
  /// Returns the raw bytes of the parcel.
  ///
  /// <p class="note">The data you retrieve here <strong>must not</strong>
  /// be placed in any kind of persistent storage (on local disk, across
  /// a network, etc).  For that, you should use standard serialization
  /// or another kind of general serialization mechanism.  The Parcel
  /// marshalled representation is highly optimized for local IPC, and as
  /// such does not attempt to maintain compatibility with data created
  /// in different versions of the platform.
  jni.JlObject marshall() => jni.JlObject.fromRef(_marshall(reference));

  static final _unmarshall = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32, ffi.Int32)>>("android_os_Parcel_unmarshall")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void unmarshall(byte[] data, int offset, int length)
  /// Set the bytes in data to be the raw bytes of this Parcel.
  void unmarshall(jni.JlObject data, int offset, int length) =>
      _unmarshall(reference, data.reference, offset, length);

  static final _appendFrom = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32, ffi.Int32)>>("android_os_Parcel_appendFrom")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void appendFrom(android.os.Parcel parcel, int offset, int length)
  void appendFrom(Parcel parcel, int offset, int length) =>
      _appendFrom(reference, parcel.reference, offset, length);

  static final _hasFileDescriptors =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Parcel_hasFileDescriptors")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasFileDescriptors()
  /// Report whether the parcel contains any marshalled file descriptors.
  bool hasFileDescriptors() => _hasFileDescriptors(reference) != 0;

  static final _writeInterfaceToken = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_writeInterfaceToken")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeInterfaceToken(java.lang.String interfaceName)
  /// Store or read an IBinder interface token in the parcel at the current
  /// \#dataPosition.  This is used to validate that the marshalled
  /// transaction is intended for the target interface.
  void writeInterfaceToken(jni.JlString interfaceName) =>
      _writeInterfaceToken(reference, interfaceName.reference);

  static final _enforceInterface = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_enforceInterface")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void enforceInterface(java.lang.String interfaceName)
  void enforceInterface(jni.JlString interfaceName) =>
      _enforceInterface(reference, interfaceName.reference);

  static final _writeByteArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeByteArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeByteArray(byte[] b)
  /// Write a byte array into the parcel at the current \#dataPosition,
  /// growing \#dataCapacity if needed.
  ///@param b Bytes to place into the parcel.
  void writeByteArray(jni.JlObject b) =>
      _writeByteArray(reference, b.reference);

  static final _writeByteArray_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32, ffi.Int32)>>("android_os_Parcel_writeByteArray_1")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void writeByteArray(byte[] b, int offset, int len)
  /// Write a byte array into the parcel at the current \#dataPosition,
  /// growing \#dataCapacity if needed.
  ///@param b Bytes to place into the parcel.
  ///@param offset Index of first byte to be written.
  ///@param len Number of bytes to write.
  void writeByteArray_1(jni.JlObject b, int offset, int len) =>
      _writeByteArray_1(reference, b.reference, offset, len);

  static final _writeInt = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Parcel_writeInt")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeInt(int val)
  /// Write an integer value into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writeInt(int val) => _writeInt(reference, val);

  static final _writeLong = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_os_Parcel_writeLong")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeLong(long val)
  /// Write a long integer value into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writeLong(int val) => _writeLong(reference, val);

  static final _writeFloat = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("android_os_Parcel_writeFloat")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void writeFloat(float val)
  /// Write a floating point value into the parcel at the current
  /// dataPosition(), growing dataCapacity() if needed.
  void writeFloat(double val) => _writeFloat(reference, val);

  static final _writeDouble = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Double)>>("android_os_Parcel_writeDouble")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void writeDouble(double val)
  /// Write a double precision floating point value into the parcel at the
  /// current dataPosition(), growing dataCapacity() if needed.
  void writeDouble(double val) => _writeDouble(reference, val);

  static final _writeString = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeString")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeString(java.lang.String val)
  /// Write a string value into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writeString(jni.JlString val) => _writeString(reference, val.reference);

  static final _writeStrongBinder = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_writeStrongBinder")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeStrongBinder(android.os.IBinder val)
  /// Write an object into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writeStrongBinder(IBinder val) =>
      _writeStrongBinder(reference, val.reference);

  static final _writeStrongInterface = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_writeStrongInterface")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeStrongInterface(android.os.IInterface val)
  /// Write an object into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writeStrongInterface(IInterface val) =>
      _writeStrongInterface(reference, val.reference);

  static final _writeFileDescriptor = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_writeFileDescriptor")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeFileDescriptor(java.io.FileDescriptor val)
  /// Write a FileDescriptor into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  ///
  /// <p class="caution">The file descriptor will not be closed, which may
  /// result in file descriptor leaks when objects are returned from Binder
  /// calls.  Use ParcelFileDescriptor\#writeToParcel instead, which
  /// accepts contextual flags and will close the original file descriptor
  /// if Parcelable\#PARCELABLE_WRITE_RETURN_VALUE is set.
  ///
  void writeFileDescriptor(jni.JlObject val) =>
      _writeFileDescriptor(reference, val.reference);

  static final _writeByte = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int8)>>("android_os_Parcel_writeByte")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeByte(byte val)
  /// Write a byte value into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writeByte(int val) => _writeByte(reference, val);

  static final _writeMap = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeMap")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeMap(java.util.Map val)
  /// Please use \#writeBundle instead.  Flattens a Map into the parcel
  /// at the current dataPosition(),
  /// growing dataCapacity() if needed.  The Map keys must be String objects.
  /// The Map values are written using \#writeValue and must follow
  /// the specification there.
  ///
  /// It is strongly recommended to use \#writeBundle instead of
  /// this method, since the Bundle class provides a type-safe API that
  /// allows you to avoid mysterious type errors at the point of marshalling.
  void writeMap(jni.JlObject val) => _writeMap(reference, val.reference);

  static final _writeBundle = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeBundle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeBundle(android.os.Bundle val)
  /// Flatten a Bundle into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writeBundle(Bundle val) => _writeBundle(reference, val.reference);

  static final _writePersistableBundle = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_writePersistableBundle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writePersistableBundle(android.os.PersistableBundle val)
  /// Flatten a PersistableBundle into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writePersistableBundle(PersistableBundle val) =>
      _writePersistableBundle(reference, val.reference);

  static final _writeSize = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeSize")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeSize(android.util.Size val)
  /// Flatten a Size into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writeSize(jni.JlObject val) => _writeSize(reference, val.reference);

  static final _writeSizeF = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeSizeF")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeSizeF(android.util.SizeF val)
  /// Flatten a SizeF into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.
  void writeSizeF(jni.JlObject val) => _writeSizeF(reference, val.reference);

  static final _writeList = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeList")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeList(java.util.List val)
  /// Flatten a List into the parcel at the current dataPosition(), growing
  /// dataCapacity() if needed.  The List values are written using
  /// \#writeValue and must follow the specification there.
  void writeList(jni.JlObject val) => _writeList(reference, val.reference);

  static final _writeArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeArray(java.lang.Object[] val)
  /// Flatten an Object array into the parcel at the current dataPosition(),
  /// growing dataCapacity() if needed.  The array values are written using
  /// \#writeValue and must follow the specification there.
  void writeArray(jni.JlObject val) => _writeArray(reference, val.reference);

  static final _writeSparseArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeSparseArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeSparseArray(android.util.SparseArray<java.lang.Object> val)
  /// Flatten a generic SparseArray into the parcel at the current
  /// dataPosition(), growing dataCapacity() if needed.  The SparseArray
  /// values are written using \#writeValue and must follow the
  /// specification there.
  void writeSparseArray(jni.JlObject val) =>
      _writeSparseArray(reference, val.reference);

  static final _writeSparseBooleanArray = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_writeSparseBooleanArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeSparseBooleanArray(android.util.SparseBooleanArray val)
  void writeSparseBooleanArray(jni.JlObject val) =>
      _writeSparseBooleanArray(reference, val.reference);

  static final _writeBooleanArray = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_writeBooleanArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeBooleanArray(boolean[] val)
  void writeBooleanArray(jni.JlObject val) =>
      _writeBooleanArray(reference, val.reference);

  static final _createBooleanArray = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_createBooleanArray")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean[] createBooleanArray()
  jni.JlObject createBooleanArray() =>
      jni.JlObject.fromRef(_createBooleanArray(reference));

  static final _readBooleanArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readBooleanArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readBooleanArray(boolean[] val)
  void readBooleanArray(jni.JlObject val) =>
      _readBooleanArray(reference, val.reference);

  static final _writeCharArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeCharArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeCharArray(char[] val)
  void writeCharArray(jni.JlObject val) =>
      _writeCharArray(reference, val.reference);

  static final _createCharArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_createCharArray")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public char[] createCharArray()
  jni.JlObject createCharArray() =>
      jni.JlObject.fromRef(_createCharArray(reference));

  static final _readCharArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readCharArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readCharArray(char[] val)
  void readCharArray(jni.JlObject val) =>
      _readCharArray(reference, val.reference);

  static final _writeIntArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeIntArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeIntArray(int[] val)
  void writeIntArray(jni.JlObject val) =>
      _writeIntArray(reference, val.reference);

  static final _createIntArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_createIntArray")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int[] createIntArray()
  jni.JlObject createIntArray() =>
      jni.JlObject.fromRef(_createIntArray(reference));

  static final _readIntArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readIntArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readIntArray(int[] val)
  void readIntArray(jni.JlObject val) =>
      _readIntArray(reference, val.reference);

  static final _writeLongArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeLongArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeLongArray(long[] val)
  void writeLongArray(jni.JlObject val) =>
      _writeLongArray(reference, val.reference);

  static final _createLongArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_createLongArray")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long[] createLongArray()
  jni.JlObject createLongArray() =>
      jni.JlObject.fromRef(_createLongArray(reference));

  static final _readLongArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readLongArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readLongArray(long[] val)
  void readLongArray(jni.JlObject val) =>
      _readLongArray(reference, val.reference);

  static final _writeFloatArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeFloatArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeFloatArray(float[] val)
  void writeFloatArray(jni.JlObject val) =>
      _writeFloatArray(reference, val.reference);

  static final _createFloatArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_createFloatArray")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float[] createFloatArray()
  jni.JlObject createFloatArray() =>
      jni.JlObject.fromRef(_createFloatArray(reference));

  static final _readFloatArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readFloatArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFloatArray(float[] val)
  void readFloatArray(jni.JlObject val) =>
      _readFloatArray(reference, val.reference);

  static final _writeDoubleArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeDoubleArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeDoubleArray(double[] val)
  void writeDoubleArray(jni.JlObject val) =>
      _writeDoubleArray(reference, val.reference);

  static final _createDoubleArray = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_createDoubleArray")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public double[] createDoubleArray()
  jni.JlObject createDoubleArray() =>
      jni.JlObject.fromRef(_createDoubleArray(reference));

  static final _readDoubleArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readDoubleArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readDoubleArray(double[] val)
  void readDoubleArray(jni.JlObject val) =>
      _readDoubleArray(reference, val.reference);

  static final _writeStringArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeStringArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeStringArray(java.lang.String[] val)
  void writeStringArray(jni.JlObject val) =>
      _writeStringArray(reference, val.reference);

  static final _createStringArray = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_createStringArray")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] createStringArray()
  jni.JlObject createStringArray() =>
      jni.JlObject.fromRef(_createStringArray(reference));

  static final _readStringArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readStringArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readStringArray(java.lang.String[] val)
  void readStringArray(jni.JlObject val) =>
      _readStringArray(reference, val.reference);

  static final _writeBinderArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeBinderArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeBinderArray(android.os.IBinder[] val)
  void writeBinderArray(jni.JlObject val) =>
      _writeBinderArray(reference, val.reference);

  static final _createBinderArray = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_createBinderArray")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.IBinder[] createBinderArray()
  jni.JlObject createBinderArray() =>
      jni.JlObject.fromRef(_createBinderArray(reference));

  static final _readBinderArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readBinderArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readBinderArray(android.os.IBinder[] val)
  void readBinderArray(jni.JlObject val) =>
      _readBinderArray(reference, val.reference);

  static final _writeTypedList = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeTypedList")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeTypedList(java.util.List<T> val)
  /// Flatten a List containing a particular object type into the parcel, at
  /// the current dataPosition() and growing dataCapacity() if needed.  The
  /// type of the objects in the list must be one that implements Parcelable.
  /// Unlike the generic writeList() method, however, only the raw data of the
  /// objects is written and not their type, so you must use the corresponding
  /// readTypedList() to unmarshall them.
  ///@param val The list of objects to be written.
  ///@see \#createTypedArrayList
  ///@see \#readTypedList
  ///@see Parcelable
  void writeTypedList(jni.JlObject val) =>
      _writeTypedList(reference, val.reference);

  static final _writeStringList = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeStringList")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeStringList(java.util.List<java.lang.String> val)
  /// Flatten a List containing String objects into the parcel, at
  /// the current dataPosition() and growing dataCapacity() if needed.  They
  /// can later be retrieved with \#createStringArrayList or
  /// \#readStringList.
  ///@param val The list of strings to be written.
  ///@see \#createStringArrayList
  ///@see \#readStringList
  void writeStringList(jni.JlObject val) =>
      _writeStringList(reference, val.reference);

  static final _writeBinderList = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeBinderList")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeBinderList(java.util.List<android.os.IBinder> val)
  /// Flatten a List containing IBinder objects into the parcel, at
  /// the current dataPosition() and growing dataCapacity() if needed.  They
  /// can later be retrieved with \#createBinderArrayList or
  /// \#readBinderList.
  ///@param val The list of strings to be written.
  ///@see \#createBinderArrayList
  ///@see \#readBinderList
  void writeBinderList(jni.JlObject val) =>
      _writeBinderList(reference, val.reference);

  static final _writeTypedArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Parcel_writeTypedArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeTypedArray(T[] val, int parcelableFlags)
  /// Flatten a homogeneous array containing a particular object type into
  /// the parcel, at
  /// the current dataPosition() and growing dataCapacity() if needed.  The
  /// type of the objects in the array must be one that implements Parcelable.
  /// Unlike the \#writeParcelableArray method, however, only the
  /// raw data of the objects is written and not their type, so you must use
  /// \#readTypedArray with the correct corresponding
  /// Parcelable.Creator implementation to unmarshall them.
  ///@param val The array of objects to be written.
  ///@param parcelableFlags Contextual flags as per
  /// Parcelable\#writeToParcel(Parcel, int) Parcelable.writeToParcel().
  ///@see \#readTypedArray
  ///@see \#writeParcelableArray
  ///@see Parcelable.Creator
  void writeTypedArray(jni.JlObject val, int parcelableFlags) =>
      _writeTypedArray(reference, val.reference, parcelableFlags);

  static final _writeValue = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeValue")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeValue(java.lang.Object v)
  /// Flatten a generic object in to a parcel.  The given Object value may
  /// currently be one of the following types:
  ///
  /// <ul>
  /// <li> null
  /// <li> String
  /// <li> Byte
  /// <li> Short
  /// <li> Integer
  /// <li> Long
  /// <li> Float
  /// <li> Double
  /// <li> Boolean
  /// <li> String[]
  /// <li> boolean[]
  /// <li> byte[]
  /// <li> int[]
  /// <li> long[]
  /// <li> Object[] (supporting objects of the same type defined here).
  /// <li> Bundle
  /// <li> Map (as supported by \#writeMap).
  /// <li> Any object that implements the Parcelable protocol.
  /// <li> Parcelable[]
  /// <li> CharSequence (as supported by TextUtils\#writeToParcel).
  /// <li> List (as supported by \#writeList).
  /// <li> SparseArray (as supported by \#writeSparseArray(SparseArray)).
  /// <li> IBinder
  /// <li> Any object that implements Serializable (but see
  ///      \#writeSerializable for caveats).  Note that all of the
  ///      previous types have relatively efficient implementations for
  ///      writing to a Parcel; having to rely on the generic serialization
  ///      approach is much less efficient and should be avoided whenever
  ///      possible.
  /// </ul>
  ///
  /// <p class="caution">Parcelable objects are written with
  /// Parcelable\#writeToParcel using contextual flags of 0.  When
  /// serializing objects containing ParcelFileDescriptors,
  /// this may result in file descriptor leaks when they are returned from
  /// Binder calls (where Parcelable\#PARCELABLE_WRITE_RETURN_VALUE
  /// should be used).
  ///
  void writeValue(jni.JlObject v) => _writeValue(reference, v.reference);

  static final _writeParcelable = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Parcel_writeParcelable")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeParcelable(android.os.Parcelable p, int parcelableFlags)
  /// Flatten the name of the class of the Parcelable and its contents
  /// into the parcel.
  ///@param p The Parcelable object to be written.
  ///@param parcelableFlags Contextual flags as per
  /// Parcelable\#writeToParcel(Parcel, int) Parcelable.writeToParcel().
  void writeParcelable(Parcelable p, int parcelableFlags) =>
      _writeParcelable(reference, p.reference, parcelableFlags);

  static final _writeSerializable = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_writeSerializable")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeSerializable(java.io.Serializable s)
  /// Write a generic serializable object in to a Parcel.  It is strongly
  /// recommended that this method be avoided, since the serialization
  /// overhead is extremely large, and this approach will be much slower than
  /// using the other approaches to writing data in to a Parcel.
  void writeSerializable(jni.JlObject s) =>
      _writeSerializable(reference, s.reference);

  static final _writeException = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_writeException")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void writeException(java.lang.Exception e)
  /// Special function for writing an exception result at the header of
  /// a parcel, to be used when returning an exception from a transaction.
  /// Note that this currently only supports a few exception types; any other
  /// exception will be re-thrown by this function as a RuntimeException
  /// (to be caught by the system's last-resort exception handling when
  /// dispatching a transaction).
  ///
  /// The supported exception types are:
  /// <ul>
  /// <li>BadParcelableException
  /// <li>IllegalArgumentException
  /// <li>IllegalStateException
  /// <li>NullPointerException
  /// <li>SecurityException
  /// <li>UnsupportedOperationException
  /// <li>NetworkOnMainThreadException
  /// </ul>
  ///@param e The Exception to be written.
  ///@see \#writeNoException
  ///@see \#readException
  void writeException(jni.JlObject e) =>
      _writeException(reference, e.reference);

  static final _writeNoException =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Parcel_writeNoException")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void writeNoException()
  /// Special function for writing information at the front of the Parcel
  /// indicating that no exception occurred.
  ///@see \#writeException
  ///@see \#readException
  void writeNoException() => _writeNoException(reference);

  static final _readException =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Parcel_readException")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void readException()
  /// Special function for reading an exception result from the header of
  /// a parcel, to be used after receiving the result of a transaction.  This
  /// will throw the exception for you if it had been written to the Parcel,
  /// otherwise return and let you read the normal result data from the Parcel.
  ///@see \#writeException
  ///@see \#writeNoException
  void readException() => _readException(reference);

  static final _readException_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readException_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void readException(int code, java.lang.String msg)
  /// Throw an exception with the given message. Not intended for use
  /// outside the Parcel class.
  ///@param code Used to determine which exception class to throw.
  ///@param msg The exception message.
  void readException_1(int code, jni.JlString msg) =>
      _readException_1(reference, code, msg.reference);

  static final _readInt =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Parcel_readInt")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int readInt()
  /// Read an integer value from the parcel at the current dataPosition().
  int readInt() => _readInt(reference);

  static final _readLong =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Parcel_readLong")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long readLong()
  /// Read a long integer value from the parcel at the current dataPosition().
  int readLong() => _readLong(reference);

  static final _readFloat =
      jlookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Parcel_readFloat")
          .asFunction<double Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float readFloat()
  /// Read a floating point value from the parcel at the current
  /// dataPosition().
  double readFloat() => _readFloat(reference);

  static final _readDouble =
      jlookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Parcel_readDouble")
          .asFunction<double Function(ffi.Pointer<ffi.Void>)>();

  /// from: public double readDouble()
  /// Read a double precision floating point value from the parcel at the
  /// current dataPosition().
  double readDouble() => _readDouble(reference);

  static final _readString = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readString")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String readString()
  /// Read a string value from the parcel at the current dataPosition().
  jni.JlString readString() => jni.JlString.fromRef(_readString(reference));

  static final _readStrongBinder = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readStrongBinder")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.IBinder readStrongBinder()
  /// Read an object from the parcel at the current dataPosition().
  IBinder readStrongBinder() => IBinder.fromRef(_readStrongBinder(reference));

  static final _readFileDescriptor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_readFileDescriptor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.ParcelFileDescriptor readFileDescriptor()
  /// Read a FileDescriptor from the parcel at the current dataPosition().
  ParcelFileDescriptor readFileDescriptor() =>
      ParcelFileDescriptor.fromRef(_readFileDescriptor(reference));

  static final _readByte =
      jlookup<ffi.NativeFunction<ffi.Int8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Parcel_readByte")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public byte readByte()
  /// Read a byte value from the parcel at the current dataPosition().
  int readByte() => _readByte(reference);

  static final _readMap = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readMap")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void readMap(java.util.Map outVal, java.lang.ClassLoader loader)
  /// Please use \#readBundle(ClassLoader) instead (whose data must have
  /// been written with \#writeBundle.  Read into an existing Map object
  /// from the parcel at the current dataPosition().
  void readMap(jni.JlObject outVal, jni.JlObject loader) =>
      _readMap(reference, outVal.reference, loader.reference);

  static final _readList = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readList")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void readList(java.util.List outVal, java.lang.ClassLoader loader)
  /// Read into an existing List object from the parcel at the current
  /// dataPosition(), using the given class loader to load any enclosed
  /// Parcelables.  If it is null, the default class loader is used.
  void readList(jni.JlObject outVal, jni.JlObject loader) =>
      _readList(reference, outVal.reference, loader.reference);

  static final _readHashMap = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readHashMap")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.HashMap readHashMap(java.lang.ClassLoader loader)
  /// Please use \#readBundle(ClassLoader) instead (whose data must have
  /// been written with \#writeBundle.  Read and return a new HashMap
  /// object from the parcel at the current dataPosition(), using the given
  /// class loader to load any enclosed Parcelables.  Returns null if
  /// the previously written map object was null.
  jni.JlObject readHashMap(jni.JlObject loader) =>
      jni.JlObject.fromRef(_readHashMap(reference, loader.reference));

  static final _readBundle = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readBundle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle readBundle()
  /// Read and return a new Bundle object from the parcel at the current
  /// dataPosition().  Returns null if the previously written Bundle object was
  /// null.
  Bundle readBundle() => Bundle.fromRef(_readBundle(reference));

  static final _readBundle_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readBundle_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle readBundle(java.lang.ClassLoader loader)
  /// Read and return a new Bundle object from the parcel at the current
  /// dataPosition(), using the given class loader to initialize the class
  /// loader of the Bundle for later retrieval of Parcelable objects.
  /// Returns null if the previously written Bundle object was null.
  Bundle readBundle_1(jni.JlObject loader) =>
      Bundle.fromRef(_readBundle_1(reference, loader.reference));

  static final _readPersistableBundle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_readPersistableBundle")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.PersistableBundle readPersistableBundle()
  /// Read and return a new Bundle object from the parcel at the current
  /// dataPosition().  Returns null if the previously written Bundle object was
  /// null.
  PersistableBundle readPersistableBundle() =>
      PersistableBundle.fromRef(_readPersistableBundle(reference));

  static final _readPersistableBundle_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_readPersistableBundle_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.PersistableBundle readPersistableBundle(java.lang.ClassLoader loader)
  /// Read and return a new Bundle object from the parcel at the current
  /// dataPosition(), using the given class loader to initialize the class
  /// loader of the Bundle for later retrieval of Parcelable objects.
  /// Returns null if the previously written Bundle object was null.
  PersistableBundle readPersistableBundle_1(jni.JlObject loader) =>
      PersistableBundle.fromRef(
          _readPersistableBundle_1(reference, loader.reference));

  static final _readSize = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readSize")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.util.Size readSize()
  /// Read a Size from the parcel at the current dataPosition().
  jni.JlObject readSize() => jni.JlObject.fromRef(_readSize(reference));

  static final _readSizeF = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readSizeF")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.util.SizeF readSizeF()
  /// Read a SizeF from the parcel at the current dataPosition().
  jni.JlObject readSizeF() => jni.JlObject.fromRef(_readSizeF(reference));

  static final _createByteArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_createByteArray")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public byte[] createByteArray()
  /// Read and return a byte[] object from the parcel.
  jni.JlObject createByteArray() =>
      jni.JlObject.fromRef(_createByteArray(reference));

  static final _readByteArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readByteArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readByteArray(byte[] val)
  /// Read a byte[] object from the parcel and copy it into the
  /// given byte array.
  void readByteArray(jni.JlObject val) =>
      _readByteArray(reference, val.reference);

  static final _readArrayList = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readArrayList")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.ArrayList readArrayList(java.lang.ClassLoader loader)
  /// Read and return a new ArrayList object from the parcel at the current
  /// dataPosition().  Returns null if the previously written list object was
  /// null.  The given class loader will be used to load any enclosed
  /// Parcelables.
  jni.JlObject readArrayList(jni.JlObject loader) =>
      jni.JlObject.fromRef(_readArrayList(reference, loader.reference));

  static final _readArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readArray")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object[] readArray(java.lang.ClassLoader loader)
  /// Read and return a new Object array from the parcel at the current
  /// dataPosition().  Returns null if the previously written array was
  /// null.  The given class loader will be used to load any enclosed
  /// Parcelables.
  jni.JlObject readArray(jni.JlObject loader) =>
      jni.JlObject.fromRef(_readArray(reference, loader.reference));

  static final _readSparseArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readSparseArray")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.util.SparseArray readSparseArray(java.lang.ClassLoader loader)
  /// Read and return a new SparseArray object from the parcel at the current
  /// dataPosition().  Returns null if the previously written list object was
  /// null.  The given class loader will be used to load any enclosed
  /// Parcelables.
  jni.JlObject readSparseArray(jni.JlObject loader) =>
      jni.JlObject.fromRef(_readSparseArray(reference, loader.reference));

  static final _readSparseBooleanArray = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_readSparseBooleanArray")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.util.SparseBooleanArray readSparseBooleanArray()
  /// Read and return a new SparseBooleanArray object from the parcel at the current
  /// dataPosition().  Returns null if the previously written list object was
  /// null.
  jni.JlObject readSparseBooleanArray() =>
      jni.JlObject.fromRef(_readSparseBooleanArray(reference));

  static final _createTypedArrayList = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_createTypedArrayList")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.ArrayList<T> createTypedArrayList(android.os.Parcelable.Creator<T> c)
  /// Read and return a new ArrayList containing a particular object type from
  /// the parcel that was written with \#writeTypedList at the
  /// current dataPosition().  Returns null if the
  /// previously written list object was null.  The list _must_ have
  /// previously been written via \#writeTypedList with the same object
  /// type.
  ///@return A newly created ArrayList containing objects with the same data
  ///         as those that were previously written.
  ///@see \#writeTypedList
  jni.JlObject createTypedArrayList(Parcelable_Creator c) =>
      jni.JlObject.fromRef(_createTypedArrayList(reference, c.reference));

  static final _readTypedList = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readTypedList")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void readTypedList(java.util.List<T> list, android.os.Parcelable.Creator<T> c)
  /// Read into the given List items containing a particular object type
  /// that were written with \#writeTypedList at the
  /// current dataPosition().  The list _must_ have
  /// previously been written via \#writeTypedList with the same object
  /// type.
  ///@return A newly created ArrayList containing objects with the same data
  ///         as those that were previously written.
  ///@see \#writeTypedList
  void readTypedList(jni.JlObject list, Parcelable_Creator c) =>
      _readTypedList(reference, list.reference, c.reference);

  static final _createStringArrayList = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_createStringArrayList")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.ArrayList<java.lang.String> createStringArrayList()
  /// Read and return a new ArrayList containing String objects from
  /// the parcel that was written with \#writeStringList at the
  /// current dataPosition().  Returns null if the
  /// previously written list object was null.
  ///@return A newly created ArrayList containing strings with the same data
  ///         as those that were previously written.
  ///@see \#writeStringList
  jni.JlObject createStringArrayList() =>
      jni.JlObject.fromRef(_createStringArrayList(reference));

  static final _createBinderArrayList = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_createBinderArrayList")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.ArrayList<android.os.IBinder> createBinderArrayList()
  /// Read and return a new ArrayList containing IBinder objects from
  /// the parcel that was written with \#writeBinderList at the
  /// current dataPosition().  Returns null if the
  /// previously written list object was null.
  ///@return A newly created ArrayList containing strings with the same data
  ///         as those that were previously written.
  ///@see \#writeBinderList
  jni.JlObject createBinderArrayList() =>
      jni.JlObject.fromRef(_createBinderArrayList(reference));

  static final _readStringList = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readStringList")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readStringList(java.util.List<java.lang.String> list)
  /// Read into the given List items String objects that were written with
  /// \#writeStringList at the current dataPosition().
  ///@see \#writeStringList
  void readStringList(jni.JlObject list) =>
      _readStringList(reference, list.reference);

  static final _readBinderList = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readBinderList")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readBinderList(java.util.List<android.os.IBinder> list)
  /// Read into the given List items IBinder objects that were written with
  /// \#writeBinderList at the current dataPosition().
  ///@see \#writeBinderList
  void readBinderList(jni.JlObject list) =>
      _readBinderList(reference, list.reference);

  static final _createTypedArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_createTypedArray")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public T[] createTypedArray(android.os.Parcelable.Creator<T> c)
  /// Read and return a new array containing a particular object type from
  /// the parcel at the current dataPosition().  Returns null if the
  /// previously written array was null.  The array _must_ have
  /// previously been written via \#writeTypedArray with the same
  /// object type.
  ///@return A newly created array containing objects with the same data
  ///         as those that were previously written.
  ///@see \#writeTypedArray
  jni.JlObject createTypedArray(Parcelable_Creator c) =>
      jni.JlObject.fromRef(_createTypedArray(reference, c.reference));

  static final _readTypedArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readTypedArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void readTypedArray(T[] val, android.os.Parcelable.Creator<T> c)
  void readTypedArray(jni.JlObject val, Parcelable_Creator c) =>
      _readTypedArray(reference, val.reference, c.reference);

  static final _writeParcelableArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Parcel_writeParcelableArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeParcelableArray(T[] value, int parcelableFlags)
  /// Write a heterogeneous array of Parcelable objects into the Parcel.
  /// Each object in the array is written along with its class name, so
  /// that the correct class can later be instantiated.  As a result, this
  /// has significantly more overhead than \#writeTypedArray, but will
  /// correctly handle an array containing more than one type of object.
  ///@param value The array of objects to be written.
  ///@param parcelableFlags Contextual flags as per
  /// Parcelable\#writeToParcel(Parcel, int) Parcelable.writeToParcel().
  ///@see \#writeTypedArray
  void writeParcelableArray(jni.JlObject value, int parcelableFlags) =>
      _writeParcelableArray(reference, value.reference, parcelableFlags);

  static final _readValue = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readValue")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object readValue(java.lang.ClassLoader loader)
  /// Read a typed object from a parcel.  The given class loader will be
  /// used to load any enclosed Parcelables.  If it is null, the default class
  /// loader will be used.
  jni.JlObject readValue(jni.JlObject loader) =>
      jni.JlObject.fromRef(_readValue(reference, loader.reference));

  static final _readParcelableArray = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Parcel_readParcelableArray")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Parcelable[] readParcelableArray(java.lang.ClassLoader loader)
  /// Read and return a new Parcelable array from the parcel.
  /// The given class loader will be used to load any enclosed
  /// Parcelables.
  ///@return the Parcelable array, or null if the array is null
  jni.JlObject readParcelableArray(jni.JlObject loader) =>
      jni.JlObject.fromRef(_readParcelableArray(reference, loader.reference));

  static final _readSerializable = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Parcel_readSerializable")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.Serializable readSerializable()
  /// Read and return a new Serializable object from the parcel.
  ///@return the Serializable object, or null if the Serializable name
  /// wasn't found in the parcel.
  jni.JlObject readSerializable() =>
      jni.JlObject.fromRef(_readSerializable(reference));

  static final _finalize =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Parcel_finalize")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void finalize()
  void finalize() => _finalize(reference);
}

/// Reference to a Handler, which others can use to send messages to it.
/// This allows for the implementation of message-based communication across
/// processes, by creating a Messenger pointing to a Handler in one process,
/// and handing that Messenger to another process.
///
/// Note: the implementation underneath is just a simple wrapper around
/// a Binder that is used to perform the communication.  This means
/// semantically you should treat it as such: this class does not impact process
/// lifecycle management (you must be using some higher-level component to tell
/// the system that your process needs to continue running), the connection will
/// break if your process goes away for any reason, etc.
///
class Messenger extends jni.JlObject {
  Messenger.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.os.Messenger> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Messenger_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static Parcelable_Creator get CREATOR =>
      Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Messenger_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Handler target)
  /// Create a new Messenger pointing to the given Handler.  Any Message
  /// objects sent through this Messenger will appear in the Handler as if
  /// Handler\#sendMessage(Message) Handler.sendMessage(Message) had
  /// been called directly.
  ///@param target The Handler that will receive sent messages.
  Messenger(Handler target) : super.fromRef(_ctor(target.reference));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Messenger_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.IBinder target)
  /// Create a Messenger from a raw IBinder, which had previously been
  /// retrieved with \#getBinder.
  ///@param target The IBinder this Messenger should communicate with.
  Messenger.ctor_1(IBinder target) : super.fromRef(_ctor_1(target.reference));

  static final _send = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Messenger_send")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void send(android.os.Message message)
  /// Send a Message to this Messenger's Handler.
  ///@param message The Message to send.  Usually retrieved through
  /// Message\#obtain() Message.obtain().
  ///@throws RemoteException Throws DeadObjectException if the target
  /// Handler no longer exists.
  void send(Message message) => _send(reference, message.reference);

  static final _getBinder = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Messenger_getBinder")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.IBinder getBinder()
  /// Retrieve the IBinder that this Messenger is using to communicate with
  /// its associated Handler.
  ///@return Returns the IBinder backing this Messenger.
  IBinder getBinder() => IBinder.fromRef(_getBinder(reference));

  static final _equals_1 = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Messenger_equals_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object otherObj)
  /// Comparison operator on two Messenger objects, such that true
  /// is returned then they both point to the same Handler.
  bool equals_1(jni.JlObject otherObj) =>
      _equals_1(reference, otherObj.reference) != 0;

  static final _hashCode_1 =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Messenger_hashCode_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode_1() => _hashCode_1(reference);

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Messenger_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Messenger_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags);

  static final _writeMessengerOrNullToParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Messenger_writeMessengerOrNullToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void writeMessengerOrNullToParcel(android.os.Messenger messenger, android.os.Parcel out)
  /// Convenience function for writing either a Messenger or null pointer to
  /// a Parcel.  You must use this with \#readMessengerOrNullFromParcel
  /// for later reading it.
  ///@param messenger The Messenger to write, or null.
  ///@param out Where to write the Messenger.
  static void writeMessengerOrNullToParcel(Messenger messenger, Parcel out) =>
      _writeMessengerOrNullToParcel(messenger.reference, out.reference);

  static final _readMessengerOrNullFromParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_Messenger_readMessengerOrNullFromParcel")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.Messenger readMessengerOrNullFromParcel(android.os.Parcel in)
  /// Convenience function for reading either a Messenger or null pointer from
  /// a Parcel.  You must have previously written the Messenger with
  /// \#writeMessengerOrNullToParcel.
  ///@param in The Parcel containing the written Messenger.
  ///@return Returns the Messenger read from the Parcel, or null if null had
  /// been written.
  static Messenger readMessengerOrNullFromParcel(Parcel in_) =>
      Messenger.fromRef(_readMessengerOrNullFromParcel(in_.reference));
}

/// SharedMemory enables the creation, mapping, and protection control over anonymous shared memory.
class SharedMemory extends jni.JlObject {
  SharedMemory.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.os.SharedMemory> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_SharedMemory_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static Parcelable_Creator get CREATOR =>
      Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_SharedMemory_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(java.io.FileDescriptor fd)
  SharedMemory(jni.JlObject fd) : super.fromRef(_ctor(fd.reference));

  static final _create = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_SharedMemory_create")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.os.SharedMemory create(java.lang.String name, int size)
  /// Creates an anonymous SharedMemory instance with the provided debug name and size. The name
  /// is only used for debugging purposes and can help identify what the shared memory is used
  /// for when inspecting memory maps for the processes that have mapped this SharedMemory
  /// instance.
  ///@param name The debug name to use for this SharedMemory instance. This can be null, however
  ///             a debug name is recommended to help identify memory usage when using tools
  ///             such as lsof or examining /proc/[pid]/maps
  /// This value may be {@code null}.
  ///@param size The size of the shared memory to create. Must be greater than 0.
  ///@return A SharedMemory instance of the requested size
  ///@throws ErrnoException if the requested allocation fails.
  static SharedMemory create(jni.JlString name, int size) =>
      SharedMemory.fromRef(_create(name.reference, size));

  static final _setProtect = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_SharedMemory_setProtect")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean setProtect(int prot)
  /// Sets the protection on the shared memory to the combination specified in prot, which
  /// is either a bitwise-or'd combination of android.system.OsConstants\#PROT_READ,
  /// android.system.OsConstants\#PROT_WRITE, android.system.OsConstants\#PROT_EXEC
  /// from android.system.OsConstants, or android.system.OsConstants\#PROT_NONE,
  /// to remove all further access.
  ///
  /// Note that protection can only ever be removed, not added. By default shared memory
  /// is created with protection set to PROT_READ | PROT_WRITE | PROT_EXEC. The protection
  /// passed here also only applies to any mappings created after calling this method. Existing
  /// mmaps of the shared memory retain whatever protection they had when they were created.
  ///
  /// A common usage of this is to share a read-only copy of the data with something else. To do
  /// that first create the read/write mapping with PROT_READ | PROT_WRITE,
  /// then call setProtect(PROT_READ) to remove write capability, then send the SharedMemory
  /// to another process. That process will only be able to mmap with PROT_READ.
  ///@param prot Any bitwise-or'ed combination of
  ///                  android.system.OsConstants\#PROT_READ,
  ///                  android.system.OsConstants\#PROT_WRITE, and
  ///                  android.system.OsConstants\#PROT_EXEC; or
  ///                  android.system.OsConstants\#PROT_NONE
  ///@return Whether or not the requested protection was applied. Returns true on success,
  /// false if the requested protection was broader than the existing protection.
  bool setProtect(int prot) => _setProtect(reference, prot) != 0;

  static final _getSize =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_SharedMemory_getSize")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getSize()
  /// @return The size of the SharedMemory region.
  int getSize() => _getSize(reference);

  static final _mapReadWrite = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_SharedMemory_mapReadWrite")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.nio.ByteBuffer mapReadWrite()
  /// Creates a read/write mapping of the entire shared memory region. This requires the the
  /// protection level of the shared memory is at least PROT_READ|PROT_WRITE or the map will fail.
  ///
  /// Use \#map(int, int, int) to have more control over the mapping if desired.
  /// This is equivalent to map(OsConstants.PROT_READ | OsConstants.PROT_WRITE, 0, getSize())
  ///@return A ByteBuffer mapping
  /// This value will never be {@code null}.
  ///@throws ErrnoException if the mmap call failed.
  jni.JlObject mapReadWrite() => jni.JlObject.fromRef(_mapReadWrite(reference));

  static final _mapReadOnly = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_SharedMemory_mapReadOnly")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.nio.ByteBuffer mapReadOnly()
  /// Creates a read-only mapping of the entire shared memory region. This requires the the
  /// protection level of the shared memory is at least PROT_READ or the map will fail.
  ///
  /// Use \#map(int, int, int) to have more control over the mapping if desired.
  /// This is equivalent to map(OsConstants.PROT_READ, 0, getSize())
  ///@return A ByteBuffer mapping
  /// This value will never be {@code null}.
  ///@throws ErrnoException if the mmap call failed.
  jni.JlObject mapReadOnly() => jni.JlObject.fromRef(_mapReadOnly(reference));

  static final _map = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32)>>("android_os_SharedMemory_map")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public java.nio.ByteBuffer map(int prot, int offset, int length)
  /// Creates an mmap of the SharedMemory with the specified prot, offset, and length. This will
  /// always produce a new ByteBuffer window to the backing shared memory region. Every call
  /// to map() may be paired with a call to \#unmap(ByteBuffer) when the ByteBuffer
  /// returned by map() is no longer needed.
  ///@param prot A bitwise-or'd combination of PROT_READ, PROT_WRITE, PROT_EXEC, or PROT_NONE.
  ///@param offset The offset into the shared memory to begin mapping. Must be >= 0 and less than
  ///         getSize().
  ///@param length The length of the region to map. Must be > 0 and offset + length must not
  ///         exceed getSize().
  ///@return A ByteBuffer mapping.
  /// This value will never be {@code null}.
  ///@throws ErrnoException if the mmap call failed.
  jni.JlObject map(int prot, int offset, int length) =>
      jni.JlObject.fromRef(_map(reference, prot, offset, length));

  static final _unmap =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_SharedMemory_unmap")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void unmap(java.nio.ByteBuffer buffer)
  /// Unmaps a buffer previously returned by \#map(int, int, int). This will immediately
  /// release the backing memory of the ByteBuffer, invalidating all references to it. Only
  /// call this method if there are no duplicates of the ByteBuffer in use and don't
  /// access the ByteBuffer after calling this method.
  ///@param buffer The buffer to unmap
  ///
  /// This value must never be {@code null}.
  static void unmap(jni.JlObject buffer) => _unmap(buffer.reference);

  static final _close =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_SharedMemory_close")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void close()
  /// Close the backing FileDescriptor of this SharedMemory instance. Note that all
  /// open mappings of the shared memory will remain valid and may continue to be used. The
  /// shared memory will not be freed until all file descriptor handles are closed and all
  /// memory mappings are unmapped.
  void close() => _close(reference);

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_SharedMemory_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_SharedMemory_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  /// @param dest This value must never be {@code null}.
  void writeToParcel(Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);
}

/// Writes trace events to the system trace buffer.  These trace events can be
/// collected and visualized using the Systrace tool.
///
/// This tracing mechanism is independent of the method tracing mechanism
/// offered by Debug\#startMethodTracing.  In particular, it enables
/// tracing of events that occur across multiple processes.
/// For information about using the Systrace tool, read <a href="{@docRoot}tools/debugging/systrace.html">Analyzing Display and Performance
/// with Systrace</a>.
class Trace extends jni.JlObject {
  Trace.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Trace_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  Trace() : super.fromRef(_ctor());

  static final _beginSection =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Trace_beginSection")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void beginSection(java.lang.String sectionName)
  /// Writes a trace message to indicate that a given section of code has begun. This call must
  /// be followed by a corresponding call to \#endSection() on the same thread.
  ///
  /// <p class="note"> At this time the vertical bar character '|', newline character '\n', and
  /// null character '\0' are used internally by the tracing mechanism.  If sectionName contains
  /// these characters they will be replaced with a space character in the trace.
  ///@param sectionName The name of the code section to appear in the trace.  This may be at
  /// most 127 Unicode code units long.
  static void beginSection(jni.JlString sectionName) =>
      _beginSection(sectionName.reference);

  static final _endSection = jlookup<ffi.NativeFunction<ffi.Void Function()>>(
          "android_os_Trace_endSection")
      .asFunction<void Function()>();

  /// from: static public void endSection()
  /// Writes a trace message to indicate that a given section of code has ended. This call must
  /// be preceeded by a corresponding call to \#beginSection(String). Calling this method
  /// will mark the end of the most recently begun section of code, so care must be taken to
  /// ensure that beginSection / endSection pairs are properly nested and called from the same
  /// thread.
  static void endSection() => _endSection();
}

/// Retrieve overall information about the space on a filesystem. This is a
/// wrapper for Unix statvfs().
class StatFs extends jni.JlObject {
  StatFs.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_StatFs_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String path)
  /// Construct a new StatFs for looking at the stats of the filesystem at
  /// {@code path}. Upon construction, the stat of the file system will be
  /// performed, and the values retrieved available from the methods on this
  /// class.
  ///@param path path in the desired file system to stat.
  ///@throws IllegalArgumentException if the file system access fails
  StatFs(jni.JlString path) : super.fromRef(_ctor(path.reference));

  static final _restat = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_StatFs_restat")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void restat(java.lang.String path)
  /// Perform a restat of the file system referenced by this object. This is
  /// the same as re-constructing the object with the same file system path,
  /// and the new stat values are available upon return.
  ///@throws IllegalArgumentException if the file system access fails
  void restat(jni.JlString path) => _restat(reference, path.reference);

  static final _getBlockSize =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_StatFs_getBlockSize")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getBlockSize()
  /// @deprecated Use \#getBlockSizeLong() instead.
  int getBlockSize() => _getBlockSize(reference);

  static final _getBlockSizeLong =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_StatFs_getBlockSizeLong")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getBlockSizeLong()
  /// The size, in bytes, of a block on the file system. This corresponds to
  /// the Unix {@code statvfs.f_frsize} field.
  int getBlockSizeLong() => _getBlockSizeLong(reference);

  static final _getBlockCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_StatFs_getBlockCount")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getBlockCount()
  /// @deprecated Use \#getBlockCountLong() instead.
  int getBlockCount() => _getBlockCount(reference);

  static final _getBlockCountLong =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_StatFs_getBlockCountLong")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getBlockCountLong()
  /// The total number of blocks on the file system. This corresponds to the
  /// Unix {@code statvfs.f_blocks} field.
  int getBlockCountLong() => _getBlockCountLong(reference);

  static final _getFreeBlocks =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_StatFs_getFreeBlocks")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getFreeBlocks()
  /// @deprecated Use \#getFreeBlocksLong() instead.
  int getFreeBlocks() => _getFreeBlocks(reference);

  static final _getFreeBlocksLong =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_StatFs_getFreeBlocksLong")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getFreeBlocksLong()
  /// The total number of blocks that are free on the file system, including
  /// reserved blocks (that are not available to normal applications). This
  /// corresponds to the Unix {@code statvfs.f_bfree} field. Most applications
  /// will want to use \#getAvailableBlocks() instead.
  int getFreeBlocksLong() => _getFreeBlocksLong(reference);

  static final _getFreeBytes =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_StatFs_getFreeBytes")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getFreeBytes()
  /// The number of bytes that are free on the file system, including reserved
  /// blocks (that are not available to normal applications). Most applications
  /// will want to use \#getAvailableBytes() instead.
  int getFreeBytes() => _getFreeBytes(reference);

  static final _getAvailableBlocks =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_StatFs_getAvailableBlocks")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getAvailableBlocks()
  /// @deprecated Use \#getAvailableBlocksLong() instead.
  int getAvailableBlocks() => _getAvailableBlocks(reference);

  static final _getAvailableBlocksLong =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_StatFs_getAvailableBlocksLong")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getAvailableBlocksLong()
  /// The number of blocks that are free on the file system and available to
  /// applications. This corresponds to the Unix {@code statvfs.f_bavail} field.
  int getAvailableBlocksLong() => _getAvailableBlocksLong(reference);

  static final _getAvailableBytes =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_StatFs_getAvailableBytes")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getAvailableBytes()
  /// The number of bytes that are free on the file system and available to
  /// applications.
  int getAvailableBytes() => _getAvailableBytes(reference);

  static final _getTotalBytes =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_StatFs_getTotalBytes")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTotalBytes()
  /// The total number of bytes supported by the file system.
  int getTotalBytes() => _getTotalBytes(reference);
}

/// The HardwarePropertiesManager class provides a mechanism of accessing hardware state of a
/// device: CPU, GPU and battery temperatures, CPU usage per core, fan speed, etc.
class HardwarePropertiesManager extends jni.JlObject {
  HardwarePropertiesManager.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final int DEVICE_TEMPERATURE_BATTERY
  /// Temperature of battery in Celsius.
  static const DEVICE_TEMPERATURE_BATTERY = 2;

  /// from: static public final int DEVICE_TEMPERATURE_CPU
  /// Temperature of CPUs in Celsius.
  static const DEVICE_TEMPERATURE_CPU = 0;

  /// from: static public final int DEVICE_TEMPERATURE_GPU
  /// Temperature of GPUs in Celsius.
  static const DEVICE_TEMPERATURE_GPU = 1;

  /// from: static public final int DEVICE_TEMPERATURE_SKIN
  /// Temperature of device skin in Celsius.
  static const DEVICE_TEMPERATURE_SKIN = 3;

  /// from: static public final int TEMPERATURE_CURRENT
  /// Get current temperature.
  static const TEMPERATURE_CURRENT = 0;

  /// from: static public final int TEMPERATURE_SHUTDOWN
  /// Get shutdown temperature threshold.
  static const TEMPERATURE_SHUTDOWN = 2;

  /// from: static public final int TEMPERATURE_THROTTLING
  /// Get throttling temperature threshold.
  static const TEMPERATURE_THROTTLING = 1;

  /// from: static public final int TEMPERATURE_THROTTLING_BELOW_VR_MIN
  /// Get throttling temperature threshold above which minimum clockrates for VR mode will not be
  /// met.
  static const TEMPERATURE_THROTTLING_BELOW_VR_MIN = 3;

  /// from: static public final float UNDEFINED_TEMPERATURE
  /// Undefined temperature constant.
  static const UNDEFINED_TEMPERATURE = -3.4028235e+38;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_HardwarePropertiesManager_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  HardwarePropertiesManager() : super.fromRef(_ctor());

  static final _getDeviceTemperatures = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "android_os_HardwarePropertiesManager_getDeviceTemperatures")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public float[] getDeviceTemperatures(int type, int source)
  /// Return an array of device temperatures in Celsius.
  ///@param type type of requested device temperature, one of \#DEVICE_TEMPERATURE_CPU,
  /// \#DEVICE_TEMPERATURE_GPU, \#DEVICE_TEMPERATURE_BATTERY or \#DEVICE_TEMPERATURE_SKIN.
  /// Value is android.os.HardwarePropertiesManager\#DEVICE_TEMPERATURE_CPU, android.os.HardwarePropertiesManager\#DEVICE_TEMPERATURE_GPU, android.os.HardwarePropertiesManager\#DEVICE_TEMPERATURE_BATTERY, or android.os.HardwarePropertiesManager\#DEVICE_TEMPERATURE_SKIN
  ///@param source source of requested device temperature, one of \#TEMPERATURE_CURRENT,
  /// \#TEMPERATURE_THROTTLING, \#TEMPERATURE_THROTTLING_BELOW_VR_MIN or
  /// \#TEMPERATURE_SHUTDOWN.
  /// Value is android.os.HardwarePropertiesManager\#TEMPERATURE_CURRENT, android.os.HardwarePropertiesManager\#TEMPERATURE_THROTTLING, android.os.HardwarePropertiesManager\#TEMPERATURE_SHUTDOWN, or android.os.HardwarePropertiesManager\#TEMPERATURE_THROTTLING_BELOW_VR_MIN
  ///@return an array of requested float device temperatures. Temperature equals to
  ///         \#UNDEFINED_TEMPERATURE if undefined.
  ///         Empty if platform doesn't provide the queried temperature.
  ///
  /// This value will never be {@code null}.
  ///@throws SecurityException if something other than the device owner or the current VR service
  ///         tries to retrieve information provided by this service.
  jni.JlObject getDeviceTemperatures(int type, int source) =>
      jni.JlObject.fromRef(_getDeviceTemperatures(reference, type, source));

  static final _getCpuUsages = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_HardwarePropertiesManager_getCpuUsages")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.CpuUsageInfo[] getCpuUsages()
  /// Return an array of CPU usage info for each core.
  ///@return an array of android.os.CpuUsageInfo for each core. Return {@code null} for
  ///         each unplugged core.
  ///         Empty if CPU usage is not supported on this system.
  ///@throws SecurityException if something other than the device owner or the current VR service
  ///         tries to retrieve information provided by this service.
  jni.JlObject getCpuUsages() => jni.JlObject.fromRef(_getCpuUsages(reference));

  static final _getFanSpeeds = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_HardwarePropertiesManager_getFanSpeeds")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float[] getFanSpeeds()
  /// Return an array of fan speeds in RPM.
  ///@return an array of float fan speeds in RPM. Empty if there are no fans or fan speed is not
  /// supported on this system.
  ///
  /// This value will never be {@code null}.
  ///@throws SecurityException if something other than the device owner or the current VR service
  ///         tries to retrieve information provided by this service.
  jni.JlObject getFanSpeeds() => jni.JlObject.fromRef(_getFanSpeeds(reference));
}

/// Enqueues chunks of data (from various sources -- application crashes, kernel
/// log records, etc.).  The queue is size bounded and will drop old data if the
/// enqueued data exceeds the maximum size.  You can think of this as a
/// persistent, system-wide, blob-oriented "logcat".
///
/// DropBoxManager entries are not sent anywhere directly, but other system
/// services and debugging tools may scan and upload entries for processing.
class DropBoxManager extends jni.JlObject {
  DropBoxManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_DROPBOX_ENTRY_ADDED
  /// Broadcast Action: This is broadcast when a new entry is added in the dropbox.
  /// You must hold the android.Manifest.permission\#READ_LOGS permission
  /// in order to receive this broadcast.
  ///
  /// <p class="note">This is a protected intent that can only be sent
  /// by the system.
  static const ACTION_DROPBOX_ENTRY_ADDED =
      "android.intent.action.DROPBOX_ENTRY_ADDED";

  /// from: static public final java.lang.String EXTRA_TAG
  /// Extra for android.os.DropBoxManager\#ACTION_DROPBOX_ENTRY_ADDED:
  /// string containing the dropbox tag.
  static const EXTRA_TAG = "tag";

  /// from: static public final java.lang.String EXTRA_TIME
  /// Extra for android.os.DropBoxManager\#ACTION_DROPBOX_ENTRY_ADDED:
  /// long integer value containing time (in milliseconds since January 1, 1970 00:00:00 UTC)
  /// when the entry was created.
  static const EXTRA_TIME = "time";

  /// from: static public final int IS_EMPTY
  /// Flag value: Entry's content was deleted to save space.
  static const IS_EMPTY = 1;

  /// from: static public final int IS_GZIPPED
  /// Flag value: Content can be decompressed with java.util.zip.GZIPOutputStream.
  static const IS_GZIPPED = 4;

  /// from: static public final int IS_TEXT
  /// Flag value: Content is human-readable UTF-8 text (can be combined with IS_GZIPPED).
  static const IS_TEXT = 2;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_DropBoxManager_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: protected void <init>()
  /// Create a dummy instance for testing.  All methods will fail unless
  /// overridden with an appropriate mock implementation.  To obtain a
  /// functional instance, use android.content.Context\#getSystemService.
  DropBoxManager() : super.fromRef(_ctor());

  static final _addText = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_DropBoxManager_addText")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void addText(java.lang.String tag, java.lang.String data)
  /// Stores human-readable text.  The data may be discarded eventually (or even
  /// immediately) if space is limited, or ignored entirely if the tag has been
  /// blocked (see \#isTagEnabled).
  ///@param tag describing the type of entry being stored
  ///@param data value to store
  void addText(jni.JlString tag, jni.JlString data) =>
      _addText(reference, tag.reference, data.reference);

  static final _addData = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_DropBoxManager_addData")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void addData(java.lang.String tag, byte[] data, int flags)
  /// Stores binary data, which may be ignored or discarded as with \#addText.
  ///@param tag describing the type of entry being stored
  ///@param data value to store
  ///@param flags describing the data
  void addData(jni.JlString tag, jni.JlObject data, int flags) =>
      _addData(reference, tag.reference, data.reference, flags);

  static final _addFile = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_DropBoxManager_addFile")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void addFile(java.lang.String tag, java.io.File file, int flags)
  /// Stores the contents of a file, which may be ignored or discarded as with
  /// \#addText.
  ///@param tag describing the type of entry being stored
  ///@param file to read from
  ///@param flags describing the data
  ///@throws IOException if the file can't be opened
  void addFile(jni.JlString tag, jni.JlObject file, int flags) =>
      _addFile(reference, tag.reference, file.reference, flags);

  static final _isTagEnabled = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_DropBoxManager_isTagEnabled")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isTagEnabled(java.lang.String tag)
  /// Checks any blacklists (set in system settings) to see whether a certain
  /// tag is allowed.  Entries with disabled tags will be dropped immediately,
  /// so you can save the work of actually constructing and sending the data.
  ///@param tag that would be used in \#addText or \#addFile
  ///@return whether events with that tag would be accepted
  bool isTagEnabled(jni.JlString tag) =>
      _isTagEnabled(reference, tag.reference) != 0;

  static final _getNextEntry = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_os_DropBoxManager_getNextEntry")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.os.DropBoxManager.Entry getNextEntry(java.lang.String tag, long msec)
  /// Gets the next entry from the drop box _after_ the specified time.
  /// Requires <code>android.permission.READ_LOGS</code>.  You must always call
  /// Entry\#close() on the return value!
  ///
  /// Requires android.Manifest.permission\#READ_LOGS and android.Manifest.permission\#PACKAGE_USAGE_STATS
  ///@param tag of entry to look for, null for all tags
  ///@param msec time of the last entry seen
  ///@return the next entry, or null if there are no more entries
  DropBoxManager_Entry getNextEntry(jni.JlString tag, int msec) =>
      DropBoxManager_Entry.fromRef(
          _getNextEntry(reference, tag.reference, msec));
}

/// A single entry retrieved from the drop box.
/// This may include a reference to a stream, so you must call
/// \#close() when you are done using it.
class DropBoxManager_Entry extends jni.JlObject {
  DropBoxManager_Entry.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.os.DropBoxManager.Entry> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_DropBoxManager__Entry_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static Parcelable_Creator get CREATOR =>
      Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_os_DropBoxManager__Entry_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String tag, long millis)
  /// Create a new empty Entry with no contents.
  DropBoxManager_Entry(jni.JlString tag, int millis)
      : super.fromRef(_ctor(tag.reference, millis));

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int64, ffi.Pointer<ffi.Void>)>>(
          "android_os_DropBoxManager__Entry_new_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String tag, long millis, java.lang.String text)
  /// Create a new Entry with plain text contents.
  DropBoxManager_Entry.ctor_1(jni.JlString tag, int millis, jni.JlString text)
      : super.fromRef(_ctor_1(tag.reference, millis, text.reference));

  static final _ctor_2 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_DropBoxManager__Entry_new_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String tag, long millis, byte[] data, int flags)
  /// Create a new Entry with byte array contents.
  /// The data array must not be modified after creating this entry.
  DropBoxManager_Entry.ctor_2(
      jni.JlString tag, int millis, jni.JlObject data, int flags)
      : super.fromRef(_ctor_2(tag.reference, millis, data.reference, flags));

  static final _ctor_3 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_DropBoxManager__Entry_new_3")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String tag, long millis, android.os.ParcelFileDescriptor data, int flags)
  /// Create a new Entry with streaming data contents.
  /// Takes ownership of the ParcelFileDescriptor.
  DropBoxManager_Entry.ctor_3(
      jni.JlString tag, int millis, ParcelFileDescriptor data, int flags)
      : super.fromRef(_ctor_3(tag.reference, millis, data.reference, flags));

  static final _ctor_4 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_DropBoxManager__Entry_new_4")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String tag, long millis, java.io.File data, int flags)
  /// Create a new Entry with the contents read from a file.
  /// The file will be read when the entry's contents are requested.
  DropBoxManager_Entry.ctor_4(
      jni.JlString tag, int millis, jni.JlObject data, int flags)
      : super.fromRef(_ctor_4(tag.reference, millis, data.reference, flags));

  static final _close =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_DropBoxManager__Entry_close")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void close()
  /// Close the input stream associated with this entry.
  void close() => _close(reference);

  static final _getTag = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_DropBoxManager__Entry_getTag")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getTag()
  /// @return the tag originally attached to the entry.
  jni.JlString getTag() => jni.JlString.fromRef(_getTag(reference));

  static final _getTimeMillis =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_DropBoxManager__Entry_getTimeMillis")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTimeMillis()
  /// @return time when the entry was originally created.
  int getTimeMillis() => _getTimeMillis(reference);

  static final _getFlags =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_DropBoxManager__Entry_getFlags")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getFlags()
  /// @return flags describing the content returned by \#getInputStream().
  int getFlags() => _getFlags(reference);

  static final _getText = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_DropBoxManager__Entry_getText")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getText(int maxBytes)
  /// @param maxBytes of string to return (will truncate at this length).
  ///@return the uncompressed text contents of the entry, null if the entry is not text.
  jni.JlString getText(int maxBytes) =>
      jni.JlString.fromRef(_getText(reference, maxBytes));

  static final _getInputStream = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_DropBoxManager__Entry_getInputStream")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.InputStream getInputStream()
  /// @return the uncompressed contents of the entry, or null if the contents were lost
  jni.JlObject getInputStream() =>
      jni.JlObject.fromRef(_getInputStream(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_DropBoxManager__Entry_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_DropBoxManager__Entry_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags);
}

/// Schedule a countdown until a time in the future, with
/// regular notifications on intervals along the way.
///
/// Example of showing a 30 second countdown in a text field:
///
/// <pre class="prettyprint">
/// new CountDownTimer(30000, 1000) {
///
///     public void onTick(long millisUntilFinished) {
///         mTextField.setText("seconds remaining: " + millisUntilFinished / 1000);
///     }
///
///     public void onFinish() {
///         mTextField.setText("done!");
///     }
///  }.start();
/// </pre>
///
/// The calls to \#onTick(long) are synchronized to this object so that
/// one call to \#onTick(long) won't ever occur before the previous
/// callback is complete.  This is only relevant when the implementation of
/// \#onTick(long) takes an amount of time to execute that is significant
/// compared to the countdown interval.
class CountDownTimer extends jni.JlObject {
  CountDownTimer.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Int64, ffi.Int64)>>("android_os_CountDownTimer_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  /// from: public void <init>(long millisInFuture, long countDownInterval)
  /// @param millisInFuture The number of millis in the future from the call
  ///   to \#start() until the countdown is done and \#onFinish()
  ///   is called.
  ///@param countDownInterval The interval along the way to receive
  ///   \#onTick(long) callbacks.
  CountDownTimer(int millisInFuture, int countDownInterval)
      : super.fromRef(_ctor(millisInFuture, countDownInterval));

  static final _cancel =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_CountDownTimer_cancel")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: synchronized public final void cancel()
  /// Cancel the countdown.
  void cancel() => _cancel(reference);

  static final _start = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_CountDownTimer_start")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: synchronized public final android.os.CountDownTimer start()
  /// Start the countdown.
  CountDownTimer start() => CountDownTimer.fromRef(_start(reference));

  static final _onTick = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_os_CountDownTimer_onTick")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void onTick(long millisUntilFinished)
  /// Callback fired on regular interval.
  ///@param millisUntilFinished The amount of time until finished.
  void onTick(int millisUntilFinished) =>
      _onTick(reference, millisUntilFinished);

  static final _onFinish =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_CountDownTimer_onFinish")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onFinish()
  /// Callback fired when the time is up.
  void onFinish() => _onFinish(reference);
}

/// Provides the ability to cancel an operation in progress.
class CancellationSignal extends jni.JlObject {
  CancellationSignal.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_CancellationSignal_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Creates a cancellation signal, initially not canceled.
  CancellationSignal() : super.fromRef(_ctor());

  static final _isCanceled =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_CancellationSignal_isCanceled")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isCanceled()
  /// Returns true if the operation has been canceled.
  ///@return True if the operation has been canceled.
  bool isCanceled() => _isCanceled(reference) != 0;

  static final _throwIfCanceled =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_CancellationSignal_throwIfCanceled")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void throwIfCanceled()
  /// Throws OperationCanceledException if the operation has been canceled.
  ///@throws OperationCanceledException if the operation has been canceled.
  void throwIfCanceled() => _throwIfCanceled(reference);

  static final _cancel =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_CancellationSignal_cancel")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void cancel()
  /// Cancels the operation and signals the cancellation listener.
  /// If the operation has not yet started, then it will be canceled as soon as it does.
  void cancel() => _cancel(reference);

  static final _setOnCancelListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_CancellationSignal_setOnCancelListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnCancelListener(android.os.CancellationSignal.OnCancelListener listener)
  /// Sets the cancellation listener to be called when canceled.
  ///
  /// This method is intended to be used by the recipient of a cancellation signal
  /// such as a database or a content provider to handle cancellation requests
  /// while performing a long-running operation.  This method is not intended to be
  /// used by applications themselves.
  ///
  /// If CancellationSignal\#cancel has already been called, then the provided
  /// listener is invoked immediately.
  ///
  /// This method is guaranteed that the listener will not be called after it
  /// has been removed.
  ///@param listener The cancellation listener, or null to remove the current listener.
  void setOnCancelListener(CancellationSignal_OnCancelListener listener) =>
      _setOnCancelListener(reference, listener.reference);
}

/// Listens for cancellation.
class CancellationSignal_OnCancelListener extends jni.JlObject {
  CancellationSignal_OnCancelListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onCancel =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_CancellationSignal__OnCancelListener_onCancel")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onCancel()
  /// Called when CancellationSignal\#cancel is invoked.
  void onCancel() => _onCancel(reference);
}

/// An exception type that is thrown when an operation in progress is canceled.
///@see CancellationSignal
class OperationCanceledException extends jni.JlObject {
  OperationCanceledException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_OperationCanceledException_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  OperationCanceledException() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_OperationCanceledException_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String message)
  OperationCanceledException.ctor_1(jni.JlString message)
      : super.fromRef(_ctor_1(message.reference));
}

/// The exception that is thrown when an application attempts
/// to perform a networking operation on its main thread.
///
/// This is only thrown for applications targeting the Honeycomb
/// SDK or higher.  Applications targeting earlier SDK versions
/// are allowed to do networking on their main event loop threads,
/// but it's heavily discouraged.  See the document
/// <a href="{@docRoot}guide/practices/design/responsiveness.html">
/// Designing for Responsiveness</a>.
///
/// Also see StrictMode.
class NetworkOnMainThreadException extends jni.JlObject {
  NetworkOnMainThreadException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_NetworkOnMainThreadException_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  NetworkOnMainThreadException() : super.fromRef(_ctor());
}

/// This class gives you control of the power state of the device.
///
///
/// __Device battery life will be significantly affected by the use of this API.__
/// Do not acquire WakeLocks unless you really need them, use the minimum levels
/// possible, and be sure to release them as soon as possible.
///
///
/// The primary API you'll use is \#newWakeLock(int, String) newWakeLock().
/// This will create a PowerManager.WakeLock object.  You can then use methods
/// on the wake lock object to control the power state of the device.
///
///
/// In practice it's quite simple:
/// {@samplecode PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
/// PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.SCREEN_DIM_WAKE_LOCK, "My Tag");
/// wl.acquire();
///   ..screen will stay on during this section..
/// wl.release();
/// }
///
///
/// The following wake lock levels are defined, with varying effects on system power.
/// <i>These levels are mutually exclusive - you may only specify one of them.</i>
///
/// <table>
///     <tr><th>Flag Value</th>
///     <th>CPU</th> <th>Screen</th> <th>Keyboard</th></tr>
///
///     <tr><td>\#PARTIAL_WAKE_LOCK</td>
///         <td>On*</td> <td>Off</td> <td>Off</td>
///     </tr>
///
///     <tr><td>\#SCREEN_DIM_WAKE_LOCK</td>
///         <td>On</td> <td>Dim</td> <td>Off</td>
///     </tr>
///
///     <tr><td>\#SCREEN_BRIGHT_WAKE_LOCK</td>
///         <td>On</td> <td>Bright</td> <td>Off</td>
///     </tr>
///
///     <tr><td>\#FULL_WAKE_LOCK</td>
///         <td>On</td> <td>Bright</td> <td>Bright</td>
///     </tr>
/// </table>
///
///
/// *<i>If you hold a partial wake lock, the CPU will continue to run, regardless of any
/// display timeouts or the state of the screen and even after the user presses the power button.
/// In all other wake locks, the CPU will run, but the user can still put the device to sleep
/// using the power button.</i>
///
///
/// In addition, you can add two more flags, which affect behavior of the screen only.
/// <i>These flags have no effect when combined with a \#PARTIAL_WAKE_LOCK.</i>
///
///
/// <table>
///     <tr><th>Flag Value</th> <th>Description</th></tr>
///
///     <tr><td>\#ACQUIRE_CAUSES_WAKEUP</td>
///         <td>Normal wake locks don't actually turn on the illumination.  Instead, they cause
///         the illumination to remain on once it turns on (e.g. from user activity).  This flag
///         will force the screen and/or keyboard to turn on immediately, when the WakeLock is
///         acquired.  A typical use would be for notifications which are important for the user to
///         see immediately.</td>
///     </tr>
///
///     <tr><td>\#ON_AFTER_RELEASE</td>
///         <td>If this flag is set, the user activity timer will be reset when the WakeLock is
///         released, causing the illumination to remain on a bit longer.  This can be used to
///         reduce flicker if you are cycling between wake lock conditions.</td>
///     </tr>
/// </table>
///
/// Any application using a WakeLock must request the {@code android.permission.WAKE_LOCK}
/// permission in an {@code <uses-permission>} element of the application's manifest.
///
///
class PowerManager extends jni.JlObject {
  PowerManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int ACQUIRE_CAUSES_WAKEUP
  /// Wake lock flag: Turn the screen on when the wake lock is acquired.
  ///
  /// Normally wake locks don't actually wake the device, they just cause
  /// the screen to remain on once it's already on.  Think of the video player
  /// application as the normal behavior.  Notifications that pop up and want
  /// the device to be on are the exception; use this flag to be like them.
  ///
  ///
  /// Cannot be used with \#PARTIAL_WAKE_LOCK.
  ///
  ///
  static const ACQUIRE_CAUSES_WAKEUP = 268435456;

  /// from: static public final java.lang.String ACTION_DEVICE_IDLE_MODE_CHANGED
  /// Intent that is broadcast when the state of \#isDeviceIdleMode() changes.
  /// This broadcast is only sent to registered receivers.
  static const ACTION_DEVICE_IDLE_MODE_CHANGED =
      "android.os.action.DEVICE_IDLE_MODE_CHANGED";

  /// from: static public final java.lang.String ACTION_POWER_SAVE_MODE_CHANGED
  /// Intent that is broadcast when the state of \#isPowerSaveMode() changes.
  /// This broadcast is only sent to registered receivers.
  static const ACTION_POWER_SAVE_MODE_CHANGED =
      "android.os.action.POWER_SAVE_MODE_CHANGED";

  /// from: static public final int FULL_WAKE_LOCK
  /// Wake lock level: Ensures that the screen and keyboard backlight are on at
  /// full brightness.
  ///
  /// If the user presses the power button, then the \#FULL_WAKE_LOCK will be
  /// implicitly released by the system, causing both the screen and the CPU to be turned off.
  /// Contrast with \#PARTIAL_WAKE_LOCK.
  ///
  ///
  ///@deprecated Most applications should use
  /// android.view.WindowManager.LayoutParams\#FLAG_KEEP_SCREEN_ON instead
  /// of this type of wake lock, as it will be correctly managed by the platform
  /// as the user moves between applications and doesn't require a special permission.
  static const FULL_WAKE_LOCK = 26;

  /// from: static public final int LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF
  /// All location providers should be disabled when battery saver is on and
  /// the device is non-interactive.
  static const LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF = 2;

  /// from: static public final int LOCATION_MODE_FOREGROUND_ONLY
  /// In this mode, all the location providers will be kept available, but location fixes
  /// should only be provided to foreground apps.
  static const LOCATION_MODE_FOREGROUND_ONLY = 3;

  /// from: static public final int LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF
  /// In this mode, the GPS based location provider should be disabled when battery saver is on and
  /// the device is non-interactive.
  static const LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF = 1;

  /// from: static public final int LOCATION_MODE_NO_CHANGE
  /// Either the location providers shouldn't be affected by battery saver,
  /// or battery saver is off.
  static const LOCATION_MODE_NO_CHANGE = 0;

  /// from: static public final int ON_AFTER_RELEASE
  /// Wake lock flag: When this wake lock is released, poke the user activity timer
  /// so the screen stays on for a little longer.
  ///
  /// Will not turn the screen on if it is not already on.
  /// See \#ACQUIRE_CAUSES_WAKEUP if you want that.
  ///
  ///
  /// Cannot be used with \#PARTIAL_WAKE_LOCK.
  ///
  ///
  static const ON_AFTER_RELEASE = 536870912;

  /// from: static public final int PARTIAL_WAKE_LOCK
  /// Wake lock level: Ensures that the CPU is running; the screen and keyboard
  /// backlight will be allowed to go off.
  ///
  /// If the user presses the power button, then the screen will be turned off
  /// but the CPU will be kept on until all partial wake locks have been released.
  ///
  ///
  static const PARTIAL_WAKE_LOCK = 1;

  /// from: static public final int PROXIMITY_SCREEN_OFF_WAKE_LOCK
  /// Wake lock level: Turns the screen off when the proximity sensor activates.
  ///
  /// If the proximity sensor detects that an object is nearby, the screen turns off
  /// immediately.  Shortly after the object moves away, the screen turns on again.
  ///
  ///
  /// A proximity wake lock does not prevent the device from falling asleep
  /// unlike \#FULL_WAKE_LOCK, \#SCREEN_BRIGHT_WAKE_LOCK and
  /// \#SCREEN_DIM_WAKE_LOCK.  If there is no user activity and no other
  /// wake locks are held, then the device will fall asleep (and lock) as usual.
  /// However, the device will not fall asleep while the screen has been turned off
  /// by the proximity sensor because it effectively counts as ongoing user activity.
  ///
  ///
  /// Since not all devices have proximity sensors, use \#isWakeLockLevelSupported
  /// to determine whether this wake lock level is supported.
  ///
  ///
  /// Cannot be used with \#ACQUIRE_CAUSES_WAKEUP.
  ///
  ///
  static const PROXIMITY_SCREEN_OFF_WAKE_LOCK = 32;

  /// from: static public final int RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY
  /// Flag for WakeLock\#release WakeLock.release(int): Defer releasing a
  /// \#PROXIMITY_SCREEN_OFF_WAKE_LOCK wake lock until the proximity sensor
  /// indicates that an object is not in close proximity.
  static const RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY = 1;

  /// from: static public final int SCREEN_BRIGHT_WAKE_LOCK
  /// Wake lock level: Ensures that the screen is on at full brightness;
  /// the keyboard backlight will be allowed to go off.
  ///
  /// If the user presses the power button, then the \#SCREEN_BRIGHT_WAKE_LOCK will be
  /// implicitly released by the system, causing both the screen and the CPU to be turned off.
  /// Contrast with \#PARTIAL_WAKE_LOCK.
  ///
  ///
  ///@deprecated Most applications should use
  /// android.view.WindowManager.LayoutParams\#FLAG_KEEP_SCREEN_ON instead
  /// of this type of wake lock, as it will be correctly managed by the platform
  /// as the user moves between applications and doesn't require a special permission.
  static const SCREEN_BRIGHT_WAKE_LOCK = 10;

  /// from: static public final int SCREEN_DIM_WAKE_LOCK
  /// Wake lock level: Ensures that the screen is on (but may be dimmed);
  /// the keyboard backlight will be allowed to go off.
  ///
  /// If the user presses the power button, then the \#SCREEN_DIM_WAKE_LOCK will be
  /// implicitly released by the system, causing both the screen and the CPU to be turned off.
  /// Contrast with \#PARTIAL_WAKE_LOCK.
  ///
  ///
  ///@deprecated Most applications should use
  /// android.view.WindowManager.LayoutParams\#FLAG_KEEP_SCREEN_ON instead
  /// of this type of wake lock, as it will be correctly managed by the platform
  /// as the user moves between applications and doesn't require a special permission.
  static const SCREEN_DIM_WAKE_LOCK = 6;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_PowerManager_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  PowerManager() : super.fromRef(_ctor());

  static final _newWakeLock = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_os_PowerManager_newWakeLock")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.PowerManager.WakeLock newWakeLock(int levelAndFlags, java.lang.String tag)
  /// Creates a new wake lock with the specified level and flags.
  ///
  /// The {@code levelAndFlags} parameter specifies a wake lock level and optional flags
  /// combined using the logical OR operator.
  ///
  ///
  /// The wake lock levels are: \#PARTIAL_WAKE_LOCK,
  /// \#FULL_WAKE_LOCK, \#SCREEN_DIM_WAKE_LOCK
  /// and \#SCREEN_BRIGHT_WAKE_LOCK.  Exactly one wake lock level must be
  /// specified as part of the {@code levelAndFlags} parameter.
  ///
  ///
  /// The wake lock flags are: \#ACQUIRE_CAUSES_WAKEUP
  /// and \#ON_AFTER_RELEASE.  Multiple flags can be combined as part of the
  /// {@code levelAndFlags} parameters.
  ///
  ///
  /// Call WakeLock\#acquire() acquire() on the object to acquire the
  /// wake lock, and WakeLock\#release release() when you are done.
  ///
  ///
  /// {@samplecode PowerManager pm = (PowerManager)mContext.getSystemService(
  ///                                          Context.POWER_SERVICE);
  /// PowerManager.WakeLock wl = pm.newWakeLock(
  ///                                      PowerManager.SCREEN_DIM_WAKE_LOCK
  ///                                      | PowerManager.ON_AFTER_RELEASE,
  ///                                      TAG);
  /// wl.acquire();
  /// // ... do work...
  /// wl.release();
  /// }
  ///
  ///
  /// Although a wake lock can be created without special permissions,
  /// the android.Manifest.permission\#WAKE_LOCK permission is
  /// required to actually acquire or release the wake lock that is returned.
  ///
  ///<p class="note">
  /// If using this to keep the screen on, you should strongly consider using
  /// android.view.WindowManager.LayoutParams\#FLAG_KEEP_SCREEN_ON instead.
  /// This window flag will be correctly managed by the platform
  /// as the user moves between applications and doesn't require a special permission.
  ///
  ///
  ///
  ///
  /// Recommended naming conventions for tags to make debugging easier:
  /// <ul>
  /// <li>use a unique prefix delimited by a colon for your app/library (e.g.
  /// gmail:mytag) to make it easier to understand where the wake locks comes
  /// from. This namespace will also avoid collision for tags inside your app
  /// coming from different libraries which will make debugging easier.
  /// <li>use constants (e.g. do not include timestamps in the tag) to make it
  /// easier for tools to aggregate similar wake locks. When collecting
  /// debugging data, the platform only monitors a finite number of tags,
  /// using constants will help tools to provide better debugging data.
  /// <li>avoid using Class\#getName() or similar method since this class name
  /// can be transformed by java optimizer and obfuscator tools.
  /// <li>avoid wrapping the tag or a prefix to avoid collision with wake lock
  /// tags from the platform (e.g. *alarm*).
  /// <li>never include personnally identifiable information for privacy
  /// reasons.
  /// </ul>
  ///
  ///
  ///@param levelAndFlags Combination of wake lock level and flag values defining
  /// the requested behavior of the WakeLock.
  ///@param tag Your class name (or other tag) for debugging purposes.
  ///@see WakeLock\#acquire()
  ///@see WakeLock\#release()
  ///@see \#PARTIAL_WAKE_LOCK
  ///@see \#FULL_WAKE_LOCK
  ///@see \#SCREEN_DIM_WAKE_LOCK
  ///@see \#SCREEN_BRIGHT_WAKE_LOCK
  ///@see \#PROXIMITY_SCREEN_OFF_WAKE_LOCK
  ///@see \#ACQUIRE_CAUSES_WAKEUP
  ///@see \#ON_AFTER_RELEASE
  PowerManager_WakeLock newWakeLock(int levelAndFlags, jni.JlString tag) =>
      PowerManager_WakeLock.fromRef(
          _newWakeLock(reference, levelAndFlags, tag.reference));

  static final _isWakeLockLevelSupported = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_os_PowerManager_isWakeLockLevelSupported")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean isWakeLockLevelSupported(int level)
  /// Returns true if the specified wake lock level is supported.
  ///@param level The wake lock level to check.
  ///@return True if the specified wake lock level is supported.
  bool isWakeLockLevelSupported(int level) =>
      _isWakeLockLevelSupported(reference, level) != 0;

  static final _isScreenOn =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_PowerManager_isScreenOn")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isScreenOn()
  /// Returns true if the device is in an interactive state.
  ///
  /// For historical reasons, the name of this method refers to the power state of
  /// the screen but it actually describes the overall interactive state of
  /// the device.  This method has been replaced by \#isInteractive.
  ///
  ///
  /// The value returned by this method only indicates whether the device is
  /// in an interactive state which may have nothing to do with the screen being
  /// on or off.  To determine the actual state of the screen,
  /// use android.view.Display\#getState.
  ///
  ///
  ///@return True if the device is in an interactive state.
  ///@deprecated Use \#isInteractive instead.
  bool isScreenOn() => _isScreenOn(reference) != 0;

  static final _isInteractive =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_PowerManager_isInteractive")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isInteractive()
  /// Returns true if the device is in an interactive state.
  ///
  /// When this method returns true, the device is awake and ready to interact
  /// with the user (although this is not a guarantee that the user is actively
  /// interacting with the device just this moment).  The main screen is usually
  /// turned on while in this state.  Certain features, such as the proximity
  /// sensor, may temporarily turn off the screen while still leaving the device in an
  /// interactive state.  Note in particular that the device is still considered
  /// to be interactive while dreaming (since dreams can be interactive) but not
  /// when it is dozing or asleep.
  ///
  ///
  /// When this method returns false, the device is dozing or asleep and must
  /// be awoken before it will become ready to interact with the user again.  The
  /// main screen is usually turned off while in this state.  Certain features,
  /// such as "ambient mode" may cause the main screen to remain on (albeit in a
  /// low power state) to display system-provided content while the device dozes.
  ///
  ///
  /// The system will send a android.content.Intent\#ACTION_SCREEN_ON screen on
  /// or android.content.Intent\#ACTION_SCREEN_OFF screen off broadcast
  /// whenever the interactive state of the device changes.  For historical reasons,
  /// the names of these broadcasts refer to the power state of the screen
  /// but they are actually sent in response to changes in the overall interactive
  /// state of the device, as described by this method.
  ///
  ///
  /// Services may use the non-interactive state as a hint to conserve power
  /// since the user is not present.
  ///
  ///
  ///@return True if the device is in an interactive state.
  ///@see android.content.Intent\#ACTION_SCREEN_ON
  ///@see android.content.Intent\#ACTION_SCREEN_OFF
  bool isInteractive() => _isInteractive(reference) != 0;

  static final _reboot = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_PowerManager_reboot")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void reboot(java.lang.String reason)
  /// Reboot the device.  Will not return if the reboot is successful.
  ///
  /// Requires the android.Manifest.permission\#REBOOT permission.
  ///
  ///
  ///@param reason code to pass to the kernel (e.g., "recovery") to
  ///               request special boot modes, or null.
  void reboot(jni.JlString reason) => _reboot(reference, reason.reference);

  static final _isPowerSaveMode =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_PowerManager_isPowerSaveMode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isPowerSaveMode()
  /// Returns true if the device is currently in power save mode.  When in this mode,
  /// applications should reduce their functionality in order to conserve battery as
  /// much as possible.  You can monitor for changes to this state with
  /// \#ACTION_POWER_SAVE_MODE_CHANGED.
  ///@return Returns true if currently in low power mode, else false.
  bool isPowerSaveMode() => _isPowerSaveMode(reference) != 0;

  static final _getLocationPowerSaveMode =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_PowerManager_getLocationPowerSaveMode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLocationPowerSaveMode()
  /// Returns how location features should behave when battery saver is on. When battery saver
  /// is off, this will always return \#LOCATION_MODE_NO_CHANGE.
  ///
  /// This API is normally only useful for components that provide location features.
  ///@see \#isPowerSaveMode()
  ///@see \#ACTION_POWER_SAVE_MODE_CHANGED
  ///@return Value is android.os.PowerManager\#LOCATION_MODE_NO_CHANGE, android.os.PowerManager\#LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF, android.os.PowerManager\#LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF, or android.os.PowerManager\#LOCATION_MODE_FOREGROUND_ONLY
  int getLocationPowerSaveMode() => _getLocationPowerSaveMode(reference);

  static final _isDeviceIdleMode =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_PowerManager_isDeviceIdleMode")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isDeviceIdleMode()
  /// Returns true if the device is currently in idle mode.  This happens when a device
  /// has been sitting unused and unmoving for a sufficiently long period of time, so that
  /// it decides to go into a lower power-use state.  This may involve things like turning
  /// off network access to apps.  You can monitor for changes to this state with
  /// \#ACTION_DEVICE_IDLE_MODE_CHANGED.
  ///@return Returns true if currently in active device idle mode, else false.  This is
  /// when idle mode restrictions are being actively applied; it will return false if the
  /// device is in a long-term idle mode but currently running a maintenance window where
  /// restrictions have been lifted.
  bool isDeviceIdleMode() => _isDeviceIdleMode(reference) != 0;

  static final _isIgnoringBatteryOptimizations = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_PowerManager_isIgnoringBatteryOptimizations")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isIgnoringBatteryOptimizations(java.lang.String packageName)
  /// Return whether the given application package name is on the device's power whitelist.
  /// Apps can be placed on the whitelist through the settings UI invoked by
  /// android.provider.Settings\#ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS.
  bool isIgnoringBatteryOptimizations(jni.JlString packageName) =>
      _isIgnoringBatteryOptimizations(reference, packageName.reference) != 0;

  static final _isSustainedPerformanceModeSupported =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_PowerManager_isSustainedPerformanceModeSupported")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isSustainedPerformanceModeSupported()
  /// This function checks if the device has implemented Sustained Performance
  /// Mode. This needs to be checked only once and is constant for a particular
  /// device/release.
  ///
  /// Sustained Performance Mode is intended to provide a consistent level of
  /// performance for prolonged amount of time.
  ///
  /// Applications should check if the device supports this mode, before using
  /// android.view.Window\#setSustainedPerformanceMode.
  ///@return Returns True if the device supports it, false otherwise.
  ///@see android.view.Window\#setSustainedPerformanceMode
  bool isSustainedPerformanceModeSupported() =>
      _isSustainedPerformanceModeSupported(reference) != 0;
}

/// A wake lock is a mechanism to indicate that your application needs
/// to have the device stay on.
///
/// Any application using a WakeLock must request the {@code android.permission.WAKE_LOCK}
/// permission in an {@code <uses-permission>} element of the application's manifest.
/// Obtain a wake lock by calling PowerManager\#newWakeLock(int, String).
///
///
/// Call \#acquire() to acquire the wake lock and force the device to stay
/// on at the level that was requested when the wake lock was created.
///
///
/// Call \#release() when you are done and don't need the lock anymore.
/// It is very important to do this as soon as possible to avoid running down the
/// device's battery excessively.
///
///
class PowerManager_WakeLock extends jni.JlObject {
  PowerManager_WakeLock.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_PowerManager__WakeLock_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(int flags, java.lang.String tag, java.lang.String packageName)
  PowerManager_WakeLock(int flags, jni.JlString tag, jni.JlString packageName)
      : super.fromRef(_ctor(flags, tag.reference, packageName.reference));

  static final _finalize =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_PowerManager__WakeLock_finalize")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void finalize()
  void finalize() => _finalize(reference);

  static final _setReferenceCounted = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "android_os_PowerManager__WakeLock_setReferenceCounted")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setReferenceCounted(boolean value)
  /// Sets whether this WakeLock is reference counted.
  ///
  /// Wake locks are reference counted by default.  If a wake lock is
  /// reference counted, then each call to \#acquire() must be
  /// balanced by an equal number of calls to \#release().  If a wake
  /// lock is not reference counted, then one call to \#release() is
  /// sufficient to undo the effect of all previous calls to \#acquire().
  ///
  ///
  ///@param value True to make the wake lock reference counted, false to
  /// make the wake lock non-reference counted.
  void setReferenceCounted(bool value) =>
      _setReferenceCounted(reference, value ? 1 : 0);

  static final _acquire =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_PowerManager__WakeLock_acquire")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void acquire()
  /// Acquires the wake lock.
  ///
  /// Ensures that the device is on at the level requested when
  /// the wake lock was created.
  ///
  ///
  void acquire() => _acquire(reference);

  static final _acquire_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_os_PowerManager__WakeLock_acquire_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void acquire(long timeout)
  /// Acquires the wake lock with a timeout.
  ///
  /// Ensures that the device is on at the level requested when
  /// the wake lock was created.  The lock will be released after the given timeout
  /// expires.
  ///
  ///
  ///@param timeout The timeout after which to release the wake lock, in milliseconds.
  void acquire_1(int timeout) => _acquire_1(reference, timeout);

  static final _release =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_PowerManager__WakeLock_release")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void release()
  /// Releases the wake lock.
  ///
  /// This method releases your claim to the CPU or screen being on.
  /// The screen may turn off shortly after you release the wake lock, or it may
  /// not if there are other wake locks still held.
  ///
  ///
  void release() => _release(reference);

  static final _release_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_PowerManager__WakeLock_release_1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void release(int flags)
  /// Releases the wake lock with flags to modify the release behavior.
  ///
  /// This method releases your claim to the CPU or screen being on.
  /// The screen may turn off shortly after you release the wake lock, or it may
  /// not if there are other wake locks still held.
  ///
  ///
  ///@param flags Combination of flag values to modify the release behavior.
  /// Currently only \#RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY is supported.
  /// Passing 0 is equivalent to calling \#release().
  void release_1(int flags) => _release_1(reference, flags);

  static final _isHeld =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_PowerManager__WakeLock_isHeld")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isHeld()
  /// Returns true if the wake lock has been acquired but not yet released.
  ///@return True if the wake lock is held.
  bool isHeld() => _isHeld(reference) != 0;

  static final _setWorkSource = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_PowerManager__WakeLock_setWorkSource")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setWorkSource(android.os.WorkSource ws)
  /// Sets the work source associated with the wake lock.
  ///
  /// The work source is used to determine on behalf of which application
  /// the wake lock is being held.  This is useful in the case where a
  /// service is performing work on behalf of an application so that the
  /// cost of that work can be accounted to the application.
  ///
  ///
  ///
  ///
  /// Make sure to follow the tag naming convention when using WorkSource
  /// to make it easier for app developers to understand wake locks
  /// attributed to them. See PowerManager\#newWakeLock(int, String)
  /// documentation.
  ///
  ///
  ///@param ws The work source, or null if none.
  void setWorkSource(WorkSource ws) => _setWorkSource(reference, ws.reference);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_PowerManager__WakeLock_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));
}

/// Interface for classes whose instances can be written to
/// and restored from a Parcel.  Classes implementing the Parcelable
/// interface must also have a non-null static field called <code>CREATOR</code>
/// of a type that implements the Parcelable.Creator interface.
///
/// A typical implementation of Parcelable is:
///
///
/// <pre>
/// public class MyParcelable implements Parcelable {
///     private int mData;
///
///     public int describeContents() {
///         return 0;
///     }
///
///     public void writeToParcel(Parcel out, int flags) {
///         out.writeInt(mData);
///     }
///
///     public static final Parcelable.Creator&lt;MyParcelable&gt; CREATOR
///             = new Parcelable.Creator&lt;MyParcelable&gt;() {
///         public MyParcelable createFromParcel(Parcel in) {
///             return new MyParcelable(in);
///         }
///
///         public MyParcelable[] newArray(int size) {
///             return new MyParcelable[size];
///         }
///     };
///
///     private MyParcelable(Parcel in) {
///         mData = in.readInt();
///     }
/// }</pre>
class Parcelable extends jni.JlObject {
  Parcelable.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int CONTENTS_FILE_DESCRIPTOR
  /// Descriptor bit used with \#describeContents(): indicates that
  /// the Parcelable object's flattened representation includes a file descriptor.
  ///@see \#describeContents()
  static const CONTENTS_FILE_DESCRIPTOR = 1;

  /// from: static public final int PARCELABLE_WRITE_RETURN_VALUE
  /// Flag for use with \#writeToParcel: the object being written
  /// is a return value, that is the result of a function such as
  /// "<code>Parcelable someFunction()</code>",
  /// "<code>void someFunction(out Parcelable)</code>", or
  /// "<code>void someFunction(inout Parcelable)</code>".  Some implementations
  /// may want to release resources at this point.
  static const PARCELABLE_WRITE_RETURN_VALUE = 1;

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Parcelable_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int describeContents()
  /// Describe the kinds of special objects contained in this Parcelable
  /// instance's marshaled representation. For example, if the object will
  /// include a file descriptor in the output of \#writeToParcel(Parcel, int),
  /// the return value of this method must include the
  /// \#CONTENTS_FILE_DESCRIPTOR bit.
  ///@return a bitmask indicating the set of special object types marshaled
  /// by this Parcelable object instance.
  ///
  /// Value is either <code>0</code> or android.os.Parcelable\#CONTENTS_FILE_DESCRIPTOR
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Parcelable_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void writeToParcel(android.os.Parcel dest, int flags)
  /// Flatten this object in to a Parcel.
  ///@param dest The Parcel in which the object should be written.
  ///@param flags Additional flags about how the object should be written.
  /// May be 0 or \#PARCELABLE_WRITE_RETURN_VALUE.
  ///
  /// Value is either <code>0</code> or a combination of android.os.Parcelable\#PARCELABLE_WRITE_RETURN_VALUE, and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES
  void writeToParcel(Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);
}

/// Interface that must be implemented and provided as a public CREATOR
/// field that generates instances of your Parcelable class from a Parcel.
class Parcelable_Creator extends jni.JlObject {
  Parcelable_Creator.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _newArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Parcelable__Creator_newArray")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract T[] newArray(int size)
  /// Create a new array of the Parcelable class.
  ///@param size Size of the array.
  ///@return Returns an array of the Parcelable class, with every entry
  /// initialized to null.
  jni.JlObject newArray(int size) =>
      jni.JlObject.fromRef(_newArray(reference, size));
}

/// Specialization of Creator that allows you to receive the
/// ClassLoader the object is being created in.
class Parcelable_ClassLoaderCreator extends jni.JlObject {
  Parcelable_ClassLoaderCreator.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);
}

/// The object you are calling has died, because its hosting process
/// no longer exists.
class DeadObjectException extends RemoteException {
  DeadObjectException.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_DeadObjectException_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  DeadObjectException() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_DeadObjectException_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String message)
  DeadObjectException.ctor_1(jni.JlString message)
      : super.fromRef(_ctor_1(message.reference));
}

/// Handy class for starting a new thread that has a looper. The looper can then be
/// used to create handler classes. Note that start() must still be called.
class HandlerThread extends jni.JlObject {
  HandlerThread.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_HandlerThread_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String name)
  HandlerThread(jni.JlString name) : super.fromRef(_ctor(name.reference));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_HandlerThread_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String name, int priority)
  /// Constructs a HandlerThread.
  ///@param name
  ///@param priority The priority to run the thread at. The value supplied must be from
  /// android.os.Process and not from java.lang.Thread.
  HandlerThread.ctor_1(jni.JlString name, int priority)
      : super.fromRef(_ctor_1(name.reference, priority));

  static final _onLooperPrepared =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_HandlerThread_onLooperPrepared")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onLooperPrepared()
  /// Call back method that can be explicitly overridden if needed to execute some
  /// setup before Looper loops.
  void onLooperPrepared() => _onLooperPrepared(reference);

  static final _run =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_HandlerThread_run")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void run()
  void run() => _run(reference);

  static final _getLooper = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_HandlerThread_getLooper")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Looper getLooper()
  /// This method returns the Looper associated with this thread. If this thread not been started
  /// or for any reason isAlive() returns false, this method will return null. If this thread
  /// has been started, this method will block until the looper has been initialized.
  ///@return The looper.
  Looper getLooper() => Looper.fromRef(_getLooper(reference));

  static final _quit =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_HandlerThread_quit")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean quit()
  /// Quits the handler thread's looper.
  ///
  /// Causes the handler thread's looper to terminate without processing any
  /// more messages in the message queue.
  ///
  ///
  /// Any attempt to post messages to the queue after the looper is asked to quit will fail.
  /// For example, the Handler\#sendMessage(Message) method will return false.
  ///
  ///<p class="note">
  /// Using this method may be unsafe because some messages may not be delivered
  /// before the looper terminates.  Consider using \#quitSafely instead to ensure
  /// that all pending work is completed in an orderly manner.
  ///
  ///
  ///@return True if the looper looper has been asked to quit or false if the
  /// thread had not yet started running.
  ///@see \#quitSafely
  bool quit() => _quit(reference) != 0;

  static final _quitSafely =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_HandlerThread_quitSafely")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean quitSafely()
  /// Quits the handler thread's looper safely.
  ///
  /// Causes the handler thread's looper to terminate as soon as all remaining messages
  /// in the message queue that are already due to be delivered have been handled.
  /// Pending delayed messages with due times in the future will not be delivered.
  ///
  ///
  /// Any attempt to post messages to the queue after the looper is asked to quit will fail.
  /// For example, the Handler\#sendMessage(Message) method will return false.
  ///
  ///
  /// If the thread has not been started or has finished (that is if
  /// \#getLooper returns null), then false is returned.
  /// Otherwise the looper is asked to quit and true is returned.
  ///
  ///
  ///@return True if the looper looper has been asked to quit or false if the
  /// thread had not yet started running.
  bool quitSafely() => _quitSafely(reference) != 0;

  static final _getThreadId =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_HandlerThread_getThreadId")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getThreadId()
  /// Returns the identifier of this thread. See Process.myTid().
  int getThreadId() => _getThreadId(reference);
}

/// Representation of a user on the device.
class UserHandle extends jni.JlObject {
  UserHandle.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.os.UserHandle> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_UserHandle_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static Parcelable_Creator get CREATOR =>
      Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_UserHandle_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel in)
  /// Instantiate a new UserHandle from the data in a Parcel that was
  /// previously written with \#writeToParcel(Parcel, int).  Note that you
  /// must not use this with data written by
  /// \#writeToParcel(UserHandle, Parcel) since it is not possible
  /// to handle a null UserHandle here.
  ///@param in The Parcel containing the previously written UserHandle,
  /// positioned at the location in the buffer where it was written.
  UserHandle(Parcel in_) : super.fromRef(_ctor(in_.reference));

  static final _getUserHandleForUid =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int32)>>(
              "android_os_UserHandle_getUserHandleForUid")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: static public android.os.UserHandle getUserHandleForUid(int uid)
  /// Returns the user for a given uid.
  ///@param uid A uid for an application running in a particular user.
  ///@return A UserHandle for that user.
  static UserHandle getUserHandleForUid(int uid) =>
      UserHandle.fromRef(_getUserHandleForUid(uid));

  static final _toString_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_UserHandle_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _equals_1 = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_UserHandle_equals_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object obj)
  bool equals_1(jni.JlObject obj) => _equals_1(reference, obj.reference) != 0;

  static final _hashCode_1 =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_UserHandle_hashCode_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode_1() => _hashCode_1(reference);

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_UserHandle_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_UserHandle_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags);

  static final _writeToParcel_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_UserHandle_writeToParcel_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void writeToParcel(android.os.UserHandle h, android.os.Parcel out)
  /// Write a UserHandle to a Parcel, handling null pointers.  Must be
  /// read with \#readFromParcel(Parcel).
  ///@param h The UserHandle to be written.
  ///@param out The Parcel in which the UserHandle will be placed.
  ///@see \#readFromParcel(Parcel)
  static void writeToParcel_1(UserHandle h, Parcel out) =>
      _writeToParcel_1(h.reference, out.reference);

  static final _readFromParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_UserHandle_readFromParcel")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.UserHandle readFromParcel(android.os.Parcel in)
  /// Read a UserHandle from a Parcel that was previously written
  /// with \#writeToParcel(UserHandle, Parcel), returning either
  /// a null or new object as appropriate.
  ///@param in The Parcel from which to read the UserHandle
  ///@return Returns a new UserHandle matching the previously written
  /// object, or null if a null had been written.
  ///@see \#writeToParcel(UserHandle, Parcel)
  static UserHandle readFromParcel(Parcel in_) =>
      UserHandle.fromRef(_readFromParcel(in_.reference));
}

/// Class used to run a message loop for a thread.  Threads by default do
/// not have a message loop associated with them; to create one, call
/// \#prepare in the thread that is to run the loop, and then
/// \#loop to have it process messages until the loop is stopped.
///
/// Most interaction with a message loop is through the
/// Handler class.
///
/// This is a typical example of the implementation of a Looper thread,
/// using the separation of \#prepare and \#loop to create an
/// initial Handler to communicate with the Looper.
///
/// <pre>
///  class LooperThread extends Thread {
///      public Handler mHandler;
///
///      public void run() {
///          Looper.prepare();
///
///          mHandler = new Handler() {
///              public void handleMessage(Message msg) {
///                  // process incoming messages here
///              }
///          };
///
///          Looper.loop();
///      }
///  }</pre>
class Looper extends jni.JlObject {
  Looper.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Uint8)>>(
              "android_os_Looper_new")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: void <init>(boolean quitAllowed)
  Looper(bool quitAllowed) : super.fromRef(_ctor(quitAllowed ? 1 : 0));

  static final _prepare = jlookup<ffi.NativeFunction<ffi.Void Function()>>(
          "android_os_Looper_prepare")
      .asFunction<void Function()>();

  /// from: static public void prepare()
  /// Initialize the current thread as a looper.
  /// This gives you a chance to create handlers that then reference
  /// this looper, before actually starting the loop. Be sure to call
  /// \#loop() after calling this method, and end it by calling
  /// \#quit().
  static void prepare() => _prepare();

  static final _prepareMainLooper =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Looper_prepareMainLooper")
          .asFunction<void Function()>();

  /// from: static public void prepareMainLooper()
  /// Initialize the current thread as a looper, marking it as an
  /// application's main looper. The main looper for your application
  /// is created by the Android environment, so you should never need
  /// to call this function yourself.  See also: \#prepare()
  static void prepareMainLooper() => _prepareMainLooper();

  static final _getMainLooper =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Looper_getMainLooper")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.os.Looper getMainLooper()
  /// Returns the application's main looper, which lives in the main thread of the application.
  static Looper getMainLooper() => Looper.fromRef(_getMainLooper());

  static final _loop =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>("android_os_Looper_loop")
          .asFunction<void Function()>();

  /// from: static public void loop()
  /// Run the message queue in this thread. Be sure to call
  /// \#quit() to end the loop.
  static void loop() => _loop();

  static final _myLooper =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Looper_myLooper")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.os.Looper myLooper()
  /// Return the Looper object associated with the current thread.  Returns
  /// null if the calling thread is not associated with a Looper.
  static Looper myLooper() => Looper.fromRef(_myLooper());

  static final _myQueue =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Looper_myQueue")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.os.MessageQueue myQueue()
  /// Return the MessageQueue object associated with the current
  /// thread.  This must be called from a thread running a Looper, or a
  /// NullPointerException will be thrown.
  ///@return This value will never be {@code null}.
  static MessageQueue myQueue() => MessageQueue.fromRef(_myQueue());

  static final _isCurrentThread =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Looper_isCurrentThread")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isCurrentThread()
  /// Returns true if the current thread is this looper's thread.
  bool isCurrentThread() => _isCurrentThread(reference) != 0;

  static final _setMessageLogging = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Looper_setMessageLogging")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setMessageLogging(android.util.Printer printer)
  /// Control logging of messages as they are processed by this Looper.  If
  /// enabled, a log message will be written to <var>printer</var>
  /// at the beginning and ending of each message dispatch, identifying the
  /// target Handler and message contents.
  ///@param printer A Printer object that will receive log messages, or
  /// null to disable message logging.
  ///
  /// This value may be {@code null}.
  void setMessageLogging(jni.JlObject printer) =>
      _setMessageLogging(reference, printer.reference);

  static final _quit =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Looper_quit")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void quit()
  /// Quits the looper.
  ///
  /// Causes the \#loop method to terminate without processing any
  /// more messages in the message queue.
  ///
  ///
  /// Any attempt to post messages to the queue after the looper is asked to quit will fail.
  /// For example, the Handler\#sendMessage(Message) method will return false.
  ///
  ///<p class="note">
  /// Using this method may be unsafe because some messages may not be delivered
  /// before the looper terminates.  Consider using \#quitSafely instead to ensure
  /// that all pending work is completed in an orderly manner.
  ///
  ///
  ///@see \#quitSafely
  void quit() => _quit(reference);

  static final _quitSafely =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Looper_quitSafely")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void quitSafely()
  /// Quits the looper safely.
  ///
  /// Causes the \#loop method to terminate as soon as all remaining messages
  /// in the message queue that are already due to be delivered have been handled.
  /// However pending delayed messages with due times in the future will not be
  /// delivered before the loop terminates.
  ///
  ///
  /// Any attempt to post messages to the queue after the looper is asked to quit will fail.
  /// For example, the Handler\#sendMessage(Message) method will return false.
  ///
  ///
  void quitSafely() => _quitSafely(reference);

  static final _getThread = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Looper_getThread")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Thread getThread()
  /// Gets the Thread associated with this Looper.
  ///@return The looper's thread.
  ///
  /// This value will never be {@code null}.
  jni.JlObject getThread() => jni.JlObject.fromRef(_getThread(reference));

  static final _getQueue = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Looper_getQueue")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.MessageQueue getQueue()
  /// Gets this looper's message queue.
  ///@return The looper's message queue.
  ///
  /// This value will never be {@code null}.
  MessageQueue getQueue() => MessageQueue.fromRef(_getQueue(reference));

  static final _dump = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Looper_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  /// Dumps the state of the looper for debugging purposes.
  ///@param pw A printer to receive the contents of the dump.
  /// This value must never be {@code null}.
  ///@param prefix A prefix to prepend to each line which is printed.
  ///
  /// This value must never be {@code null}.
  void dump(jni.JlObject pw, jni.JlString prefix) =>
      _dump(reference, pw.reference, prefix.reference);

  static final _toString_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Looper_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));
}

/// Low-level class holding the list of messages to be dispatched by a
/// Looper.  Messages are not added directly to a MessageQueue,
/// but rather through Handler objects associated with the Looper.
///
/// You can retrieve the MessageQueue for the current thread with
/// Looper\#myQueue() Looper.myQueue().
class MessageQueue extends jni.JlObject {
  MessageQueue.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Uint8)>>(
              "android_os_MessageQueue_new")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: void <init>(boolean quitAllowed)
  MessageQueue(bool quitAllowed) : super.fromRef(_ctor(quitAllowed ? 1 : 0));

  static final _finalize =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_MessageQueue_finalize")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void finalize()
  void finalize() => _finalize(reference);

  static final _isIdle =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_MessageQueue_isIdle")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isIdle()
  /// Returns true if the looper has no pending messages which are due to be processed.
  ///
  /// This method is safe to call from any thread.
  ///@return True if the looper is idle.
  bool isIdle() => _isIdle(reference) != 0;

  static final _addIdleHandler = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_MessageQueue_addIdleHandler")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void addIdleHandler(android.os.MessageQueue.IdleHandler handler)
  /// Add a new IdleHandler to this message queue.  This may be
  /// removed automatically for you by returning false from
  /// IdleHandler\#queueIdle IdleHandler.queueIdle() when it is
  /// invoked, or explicitly removing it with \#removeIdleHandler.
  ///
  /// This method is safe to call from any thread.
  ///@param handler The IdleHandler to be added.
  ///
  /// This value must never be {@code null}.
  void addIdleHandler(MessageQueue_IdleHandler handler) =>
      _addIdleHandler(reference, handler.reference);

  static final _removeIdleHandler = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_MessageQueue_removeIdleHandler")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void removeIdleHandler(android.os.MessageQueue.IdleHandler handler)
  /// Remove an IdleHandler from the queue that was previously added
  /// with \#addIdleHandler.  If the given object is not currently
  /// in the idle list, nothing is done.
  ///
  /// This method is safe to call from any thread.
  ///@param handler The IdleHandler to be removed.
  ///
  /// This value must never be {@code null}.
  void removeIdleHandler(MessageQueue_IdleHandler handler) =>
      _removeIdleHandler(reference, handler.reference);

  static final _addOnFileDescriptorEventListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_os_MessageQueue_addOnFileDescriptorEventListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void addOnFileDescriptorEventListener(java.io.FileDescriptor fd, int events, android.os.MessageQueue.OnFileDescriptorEventListener listener)
  /// Adds a file descriptor listener to receive notification when file descriptor
  /// related events occur.
  ///
  /// If the file descriptor has already been registered, the specified events
  /// and listener will replace any that were previously associated with it.
  /// It is not possible to set more than one listener per file descriptor.
  ///
  ///
  /// It is important to always unregister the listener when the file descriptor
  /// is no longer of use.
  ///
  ///
  ///@param fd The file descriptor for which a listener will be registered.
  /// This value must never be {@code null}.
  ///@param events The set of events to receive: a combination of the
  /// OnFileDescriptorEventListener\#EVENT_INPUT,
  /// OnFileDescriptorEventListener\#EVENT_OUTPUT, and
  /// OnFileDescriptorEventListener\#EVENT_ERROR event masks.  If the requested
  /// set of events is zero, then the listener is unregistered.
  /// Value is either <code>0</code> or a combination of android.os.MessageQueue.OnFileDescriptorEventListener\#EVENT_INPUT, android.os.MessageQueue.OnFileDescriptorEventListener\#EVENT_OUTPUT, and android.os.MessageQueue.OnFileDescriptorEventListener\#EVENT_ERROR
  ///@param listener The listener to invoke when file descriptor events occur.
  ///
  /// This value must never be {@code null}.
  ///@see OnFileDescriptorEventListener
  ///@see \#removeOnFileDescriptorEventListener
  void addOnFileDescriptorEventListener(jni.JlObject fd, int events,
          MessageQueue_OnFileDescriptorEventListener listener) =>
      _addOnFileDescriptorEventListener(
          reference, fd.reference, events, listener.reference);

  static final _removeOnFileDescriptorEventListener = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_MessageQueue_removeOnFileDescriptorEventListener")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void removeOnFileDescriptorEventListener(java.io.FileDescriptor fd)
  /// Removes a file descriptor listener.
  ///
  /// This method does nothing if no listener has been registered for the
  /// specified file descriptor.
  ///
  ///
  ///@param fd The file descriptor whose listener will be unregistered.
  ///
  /// This value must never be {@code null}.
  ///@see OnFileDescriptorEventListener
  ///@see \#addOnFileDescriptorEventListener
  void removeOnFileDescriptorEventListener(jni.JlObject fd) =>
      _removeOnFileDescriptorEventListener(reference, fd.reference);
}

/// A listener which is invoked when file descriptor related events occur.
class MessageQueue_OnFileDescriptorEventListener extends jni.JlObject {
  MessageQueue_OnFileDescriptorEventListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final int EVENT_ERROR
  /// File descriptor event: Indicates that the file descriptor encountered a
  /// fatal error.
  ///
  /// File descriptor errors can occur for various reasons.  One common error
  /// is when the remote peer of a socket or pipe closes its end of the connection.
  ///
  ///
  /// This event may be generated at any time regardless of whether the
  /// \#EVENT_ERROR event mask was specified when the listener was added.
  ///
  ///
  static const EVENT_ERROR = 4;

  /// from: static public final int EVENT_INPUT
  /// File descriptor event: Indicates that the file descriptor is ready for input
  /// operations, such as reading.
  ///
  /// The listener should read all available data from the file descriptor
  /// then return <code>true</code> to keep the listener active or <code>false</code>
  /// to remove the listener.
  ///
  ///
  /// In the case of a socket, this event may be generated to indicate
  /// that there is at least one incoming connection that the listener
  /// should accept.
  ///
  ///
  /// This event will only be generated if the \#EVENT_INPUT event mask was
  /// specified when the listener was added.
  ///
  ///
  static const EVENT_INPUT = 1;

  /// from: static public final int EVENT_OUTPUT
  /// File descriptor event: Indicates that the file descriptor is ready for output
  /// operations, such as writing.
  ///
  /// The listener should write as much data as it needs.  If it could not
  /// write everything at once, then it should return <code>true</code> to
  /// keep the listener active.  Otherwise, it should return <code>false</code>
  /// to remove the listener then re-register it later when it needs to write
  /// something else.
  ///
  ///
  /// This event will only be generated if the \#EVENT_OUTPUT event mask was
  /// specified when the listener was added.
  ///
  ///
  static const EVENT_OUTPUT = 2;

  static final _onFileDescriptorEvents = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_os_MessageQueue__OnFileDescriptorEventListener_onFileDescriptorEvents")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract int onFileDescriptorEvents(java.io.FileDescriptor fd, int events)
  /// Called when a file descriptor receives events.
  ///@param fd The file descriptor.
  /// This value must never be {@code null}.
  ///@param events The set of events that occurred: a combination of the
  /// \#EVENT_INPUT, \#EVENT_OUTPUT, and \#EVENT_ERROR event masks.
  /// Value is either <code>0</code> or a combination of android.os.MessageQueue.OnFileDescriptorEventListener\#EVENT_INPUT, android.os.MessageQueue.OnFileDescriptorEventListener\#EVENT_OUTPUT, and android.os.MessageQueue.OnFileDescriptorEventListener\#EVENT_ERROR
  ///@return The new set of events to watch, or 0 to unregister the listener.
  ///
  /// Value is either <code>0</code> or a combination of android.os.MessageQueue.OnFileDescriptorEventListener\#EVENT_INPUT, android.os.MessageQueue.OnFileDescriptorEventListener\#EVENT_OUTPUT, and android.os.MessageQueue.OnFileDescriptorEventListener\#EVENT_ERROR
  ///@see \#EVENT_INPUT
  ///@see \#EVENT_OUTPUT
  ///@see \#EVENT_ERROR
  int onFileDescriptorEvents(jni.JlObject fd, int events) =>
      _onFileDescriptorEvents(reference, fd.reference, events);
}

/// Callback interface for discovering when a thread is going to block
/// waiting for more messages.
class MessageQueue_IdleHandler extends jni.JlObject {
  MessageQueue_IdleHandler.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _queueIdle =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_MessageQueue__IdleHandler_queueIdle")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean queueIdle()
  /// Called when the message queue has run out of messages and will now
  /// wait for more.  Return true to keep your idle handler active, false
  /// to have it removed.  This may be called if there are still messages
  /// pending in the queue, but they are all scheduled to be dispatched
  /// after the current time.
  bool queueIdle() => _queueIdle(reference) != 0;
}

/// The BatteryManager class contains strings and constants used for values
/// in the android.content.Intent\#ACTION_BATTERY_CHANGED Intent, and
/// provides a method for querying battery and charging properties.
class BatteryManager extends jni.JlObject {
  BatteryManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_CHARGING
  /// Sent when the device's battery has started charging (or has reached full charge
  /// and the device is on power).  This is a good time to do work that you would like to
  /// avoid doing while on battery (that is to avoid draining the user's battery due to
  /// things they don't care enough about).
  ///
  /// This is paired with \#ACTION_DISCHARGING.  The current state can always
  /// be retrieved with \#isCharging().
  static const ACTION_CHARGING = "android.os.action.CHARGING";

  /// from: static public final java.lang.String ACTION_DISCHARGING
  /// Sent when the device's battery may be discharging, so apps should avoid doing
  /// extraneous work that would cause it to discharge faster.
  ///
  /// This is paired with \#ACTION_CHARGING.  The current state can always
  /// be retrieved with \#isCharging().
  static const ACTION_DISCHARGING = "android.os.action.DISCHARGING";

  /// from: static public final int BATTERY_HEALTH_COLD
  static const BATTERY_HEALTH_COLD = 7;

  /// from: static public final int BATTERY_HEALTH_DEAD
  static const BATTERY_HEALTH_DEAD = 4;

  /// from: static public final int BATTERY_HEALTH_GOOD
  static const BATTERY_HEALTH_GOOD = 2;

  /// from: static public final int BATTERY_HEALTH_OVERHEAT
  static const BATTERY_HEALTH_OVERHEAT = 3;

  /// from: static public final int BATTERY_HEALTH_OVER_VOLTAGE
  static const BATTERY_HEALTH_OVER_VOLTAGE = 5;

  /// from: static public final int BATTERY_HEALTH_UNKNOWN
  static const BATTERY_HEALTH_UNKNOWN = 1;

  /// from: static public final int BATTERY_HEALTH_UNSPECIFIED_FAILURE
  static const BATTERY_HEALTH_UNSPECIFIED_FAILURE = 6;

  /// from: static public final int BATTERY_PLUGGED_AC
  /// Power source is an AC charger.
  static const BATTERY_PLUGGED_AC = 1;

  /// from: static public final int BATTERY_PLUGGED_USB
  /// Power source is a USB port.
  static const BATTERY_PLUGGED_USB = 2;

  /// from: static public final int BATTERY_PLUGGED_WIRELESS
  /// Power source is wireless.
  static const BATTERY_PLUGGED_WIRELESS = 4;

  /// from: static public final int BATTERY_PROPERTY_CAPACITY
  /// Remaining battery capacity as an integer percentage of total capacity
  /// (with no fractional part).
  static const BATTERY_PROPERTY_CAPACITY = 4;

  /// from: static public final int BATTERY_PROPERTY_CHARGE_COUNTER
  /// Battery capacity in microampere-hours, as an integer.
  static const BATTERY_PROPERTY_CHARGE_COUNTER = 1;

  /// from: static public final int BATTERY_PROPERTY_CURRENT_AVERAGE
  /// Average battery current in microamperes, as an integer.  Positive
  /// values indicate net current entering the battery from a charge source,
  /// negative values indicate net current discharging from the battery.
  /// The time period over which the average is computed may depend on the
  /// fuel gauge hardware and its configuration.
  static const BATTERY_PROPERTY_CURRENT_AVERAGE = 3;

  /// from: static public final int BATTERY_PROPERTY_CURRENT_NOW
  /// Instantaneous battery current in microamperes, as an integer.  Positive
  /// values indicate net current entering the battery from a charge source,
  /// negative values indicate net current discharging from the battery.
  static const BATTERY_PROPERTY_CURRENT_NOW = 2;

  /// from: static public final int BATTERY_PROPERTY_ENERGY_COUNTER
  /// Battery remaining energy in nanowatt-hours, as a long integer.
  static const BATTERY_PROPERTY_ENERGY_COUNTER = 5;

  /// from: static public final int BATTERY_PROPERTY_STATUS
  /// Battery charge status, from a BATTERY_STATUS_* value.
  static const BATTERY_PROPERTY_STATUS = 6;

  /// from: static public final int BATTERY_STATUS_CHARGING
  static const BATTERY_STATUS_CHARGING = 2;

  /// from: static public final int BATTERY_STATUS_DISCHARGING
  static const BATTERY_STATUS_DISCHARGING = 3;

  /// from: static public final int BATTERY_STATUS_FULL
  static const BATTERY_STATUS_FULL = 5;

  /// from: static public final int BATTERY_STATUS_NOT_CHARGING
  static const BATTERY_STATUS_NOT_CHARGING = 4;

  /// from: static public final int BATTERY_STATUS_UNKNOWN
  static const BATTERY_STATUS_UNKNOWN = 1;

  /// from: static public final java.lang.String EXTRA_BATTERY_LOW
  /// Extra for android.content.Intent\#ACTION_BATTERY_CHANGED:
  /// Boolean field indicating whether the battery is currently considered to be
  /// low, that is whether a Intent\#ACTION_BATTERY_LOW broadcast
  /// has been sent.
  static const EXTRA_BATTERY_LOW = "battery_low";

  /// from: static public final java.lang.String EXTRA_HEALTH
  /// Extra for android.content.Intent\#ACTION_BATTERY_CHANGED:
  /// integer containing the current health constant.
  static const EXTRA_HEALTH = "health";

  /// from: static public final java.lang.String EXTRA_ICON_SMALL
  /// Extra for android.content.Intent\#ACTION_BATTERY_CHANGED:
  /// integer containing the resource ID of a small status bar icon
  /// indicating the current battery state.
  static const EXTRA_ICON_SMALL = "icon-small";

  /// from: static public final java.lang.String EXTRA_LEVEL
  /// Extra for android.content.Intent\#ACTION_BATTERY_CHANGED:
  /// integer field containing the current battery level, from 0 to
  /// \#EXTRA_SCALE.
  static const EXTRA_LEVEL = "level";

  /// from: static public final java.lang.String EXTRA_PLUGGED
  /// Extra for android.content.Intent\#ACTION_BATTERY_CHANGED:
  /// integer indicating whether the device is plugged in to a power
  /// source; 0 means it is on battery, other constants are different
  /// types of power sources.
  static const EXTRA_PLUGGED = "plugged";

  /// from: static public final java.lang.String EXTRA_PRESENT
  /// Extra for android.content.Intent\#ACTION_BATTERY_CHANGED:
  /// boolean indicating whether a battery is present.
  static const EXTRA_PRESENT = "present";

  /// from: static public final java.lang.String EXTRA_SCALE
  /// Extra for android.content.Intent\#ACTION_BATTERY_CHANGED:
  /// integer containing the maximum battery level.
  static const EXTRA_SCALE = "scale";

  /// from: static public final java.lang.String EXTRA_STATUS
  /// Extra for android.content.Intent\#ACTION_BATTERY_CHANGED:
  /// integer containing the current status constant.
  static const EXTRA_STATUS = "status";

  /// from: static public final java.lang.String EXTRA_TECHNOLOGY
  /// Extra for android.content.Intent\#ACTION_BATTERY_CHANGED:
  /// String describing the technology of the current battery.
  static const EXTRA_TECHNOLOGY = "technology";

  /// from: static public final java.lang.String EXTRA_TEMPERATURE
  /// Extra for android.content.Intent\#ACTION_BATTERY_CHANGED:
  /// integer containing the current battery temperature.
  static const EXTRA_TEMPERATURE = "temperature";

  /// from: static public final java.lang.String EXTRA_VOLTAGE
  /// Extra for android.content.Intent\#ACTION_BATTERY_CHANGED:
  /// integer containing the current battery voltage level.
  static const EXTRA_VOLTAGE = "voltage";

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_BatteryManager_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  /// @removed Was previously made visible by accident.
  BatteryManager() : super.fromRef(_ctor());

  static final _isCharging =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_BatteryManager_isCharging")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isCharging()
  /// Return true if the battery is currently considered to be charging.  This means that
  /// the device is plugged in and is supplying sufficient power that the battery level is
  /// going up (or the battery is fully charged).  Changes in this state are matched by
  /// broadcasts of \#ACTION_CHARGING and \#ACTION_DISCHARGING.
  bool isCharging() => _isCharging(reference) != 0;

  static final _getIntProperty = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_BatteryManager_getIntProperty")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getIntProperty(int id)
  /// Return the value of a battery property of integer type.
  ///@param id identifier of the requested property
  ///@return the property value. If the property is not supported or there is any other error,
  ///    return (a) 0 if {@code targetSdkVersion < VERSION_CODES.P} or (b) Integer.MIN_VALUE
  ///    if {@code targetSdkVersion >= VERSION_CODES.P}.
  int getIntProperty(int id) => _getIntProperty(reference, id);

  static final _getLongProperty = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_BatteryManager_getLongProperty")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public long getLongProperty(int id)
  /// Return the value of a battery property of long type If the
  /// platform does not provide the property queried, this value will
  /// be Long.MIN_VALUE.
  ///@param id identifier of the requested property
  ///@return the property value, or Long.MIN_VALUE if not supported.
  int getLongProperty(int id) => _getLongProperty(reference, id);

  static final _computeChargeTimeRemaining =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_BatteryManager_computeChargeTimeRemaining")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long computeChargeTimeRemaining()
  /// Compute an approximation for how much time (in milliseconds) remains until the battery is
  /// fully charged. Returns -1 if no time can be computed: either there is not enough current
  /// data to make a decision or the battery is currently discharging.
  ///@return how much time is left, in milliseconds, until the battery is fully charged or -1 if
  ///         the computation fails
  int computeChargeTimeRemaining() => _computeChargeTimeRemaining(reference);
}

/// Base class for Binder interfaces.  When defining a new interface,
/// you must derive it from IInterface.
class IInterface extends jni.JlObject {
  IInterface.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _asBinder = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_IInterface_asBinder")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.os.IBinder asBinder()
  /// Retrieve the Binder object associated with this interface.
  /// You must use this instead of a plain cast, so that proxy objects
  /// can return the correct result.
  IBinder asBinder() => IBinder.fromRef(_asBinder(reference));
}

/// Defines a message containing a description and arbitrary data object that can be
/// sent to a Handler.  This object contains two extra int fields and an
/// extra object field that allow you to not do allocations in many cases.
///
/// <p class="note">While the constructor of Message is public, the best way to get
/// one of these is to call \#obtain Message.obtain() or one of the
/// Handler\#obtainMessage Handler.obtainMessage() methods, which will pull
/// them from a pool of recycled objects.
///
class Message extends jni.JlObject {
  Message.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.os.Message> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Message_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static Parcelable_Creator get CREATOR =>
      Parcelable_Creator.fromRef(_getCREATOR());

  /// from: public int arg1
  /// arg1 and arg2 are lower-cost alternatives to using
  /// \#setData(Bundle) setData() if you only need to store a
  /// few integer values.
  static final _getarg1 = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_os_Message_arg1")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get arg1 => _getarg1(reference);
  static final _setarg1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_os_Message_arg1")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set arg1(int value) => _setarg1(reference, value);

  /// from: public int arg2
  /// arg1 and arg2 are lower-cost alternatives to using
  /// \#setData(Bundle) setData() if you only need to store a
  /// few integer values.
  static final _getarg2 = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_os_Message_arg2")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get arg2 => _getarg2(reference);
  static final _setarg2 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_os_Message_arg2")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set arg2(int value) => _setarg2(reference, value);

  /// from: public java.lang.Object obj
  /// An arbitrary object to send to the recipient.  When using
  /// Messenger to send the message across processes this can only
  /// be non-null if it contains a Parcelable of a framework class (not one
  /// implemented by the application).   For other data transfer use
  /// \#setData.
  ///
  /// Note that Parcelable objects here are not supported prior to
  /// the android.os.Build.VERSION_CODES\#FROYO release.
  static final _getobj = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_os_Message_obj")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  jni.JlObject get obj => jni.JlObject.fromRef(_getobj(reference));
  static final _setobj = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("set_android_os_Message_obj")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set obj(jni.JlObject value) => _setobj(reference, value.reference);

  /// from: public android.os.Messenger replyTo
  /// Optional Messenger where replies to this message can be sent.  The
  /// semantics of exactly how this is used are up to the sender and
  /// receiver.
  static final _getreplyTo = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_os_Message_replyTo")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void>,
  )>();
  Messenger get replyTo => Messenger.fromRef(_getreplyTo(reference));
  static final _setreplyTo = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("set_android_os_Message_replyTo")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();
  set replyTo(Messenger value) => _setreplyTo(reference, value.reference);

  /// from: public int sendingUid
  /// Optional field indicating the uid that sent the message.  This is
  /// only valid for messages posted by a Messenger; otherwise,
  /// it will be -1.
  static final _getsendingUid = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_os_Message_sendingUid")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get sendingUid => _getsendingUid(reference);
  static final _setsendingUid = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_os_Message_sendingUid")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set sendingUid(int value) => _setsendingUid(reference, value);

  /// from: public int what
  /// User-defined message code so that the recipient can identify
  /// what this message is about. Each Handler has its own name-space
  /// for message codes, so you do not need to worry about yours conflicting
  /// with other handlers.
  static final _getwhat = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_os_Message_what")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get what => _getwhat(reference);
  static final _setwhat = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_os_Message_what")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set what(int value) => _setwhat(reference, value);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Message_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Constructor (but the preferred way to get a Message is to call \#obtain() Message.obtain()).
  Message() : super.fromRef(_ctor());

  static final _obtain =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Message_obtain")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.os.Message obtain()
  /// Return a new Message instance from the global pool. Allows us to
  /// avoid allocating new objects in many cases.
  static Message obtain() => Message.fromRef(_obtain());

  static final _obtain_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Message_obtain_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.Message obtain(android.os.Message orig)
  /// Same as \#obtain(), but copies the values of an existing
  /// message (including its target) into the new one.
  ///@param orig Original message to copy.
  ///@return A Message object from the global pool.
  static Message obtain_1(Message orig) =>
      Message.fromRef(_obtain_1(orig.reference));

  static final _obtain_2 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Message_obtain_2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.Message obtain(android.os.Handler h)
  /// Same as \#obtain(), but sets the value for the _target_ member on the Message returned.
  ///@param h Handler to assign to the returned Message object's _target_ member.
  ///@return A Message object from the global pool.
  static Message obtain_2(Handler h) => Message.fromRef(_obtain_2(h.reference));

  static final _obtain_3 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Message_obtain_3")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.Message obtain(android.os.Handler h, java.lang.Runnable callback)
  /// Same as \#obtain(Handler), but assigns a callback Runnable on
  /// the Message that is returned.
  ///@param h Handler to assign to the returned Message object's _target_ member.
  ///@param callback Runnable that will execute when the message is handled.
  ///@return A Message object from the global pool.
  static Message obtain_3(Handler h, jni.JlObject callback) =>
      Message.fromRef(_obtain_3(h.reference, callback.reference));

  static final _obtain_4 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Message_obtain_4")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.os.Message obtain(android.os.Handler h, int what)
  /// Same as \#obtain(), but sets the values for both _target_ and
  /// _what_ members on the Message.
  ///@param h Value to assign to the _target_ member.
  ///@param what Value to assign to the _what_ member.
  ///@return A Message object from the global pool.
  static Message obtain_4(Handler h, int what) =>
      Message.fromRef(_obtain_4(h.reference, what));

  static final _obtain_5 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_os_Message_obtain_5")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.Message obtain(android.os.Handler h, int what, java.lang.Object obj)
  /// Same as \#obtain(), but sets the values of the _target_, _what_, and _obj_
  /// members.
  ///@param h The _target_ value to set.
  ///@param what The _what_ value to set.
  ///@param obj The _object_ method to set.
  ///@return A Message object from the global pool.
  static Message obtain_5(Handler h, int what, jni.JlObject obj) =>
      Message.fromRef(_obtain_5(h.reference, what, obj.reference));

  static final _obtain_6 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32)>>("android_os_Message_obtain_6")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: static public android.os.Message obtain(android.os.Handler h, int what, int arg1, int arg2)
  /// Same as \#obtain(), but sets the values of the _target_, _what_,
  /// _arg1_, and _arg2_ members.
  ///@param h The _target_ value to set.
  ///@param what The _what_ value to set.
  ///@param arg1 The _arg1_ value to set.
  ///@param arg2 The _arg2_ value to set.
  ///@return A Message object from the global pool.
  static Message obtain_6(Handler h, int what, int arg1, int arg2) =>
      Message.fromRef(_obtain_6(h.reference, what, arg1, arg2));

  static final _obtain_7 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_os_Message_obtain_7")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.Message obtain(android.os.Handler h, int what, int arg1, int arg2, java.lang.Object obj)
  /// Same as \#obtain(), but sets the values of the _target_, _what_,
  /// _arg1_, _arg2_, and _obj_ members.
  ///@param h The _target_ value to set.
  ///@param what The _what_ value to set.
  ///@param arg1 The _arg1_ value to set.
  ///@param arg2 The _arg2_ value to set.
  ///@param obj The _obj_ value to set.
  ///@return A Message object from the global pool.
  static Message obtain_7(
          Handler h, int what, int arg1, int arg2, jni.JlObject obj) =>
      Message.fromRef(_obtain_7(h.reference, what, arg1, arg2, obj.reference));

  static final _recycle =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Message_recycle")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void recycle()
  /// Return a Message instance to the global pool.
  ///
  /// You MUST NOT touch the Message after calling this function because it has
  /// effectively been freed.  It is an error to recycle a message that is currently
  /// enqueued or that is in the process of being delivered to a Handler.
  ///
  ///
  void recycle() => _recycle(reference);

  static final _copyFrom = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Message_copyFrom")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void copyFrom(android.os.Message o)
  /// Make this message like o.  Performs a shallow copy of the data field.
  /// Does not copy the linked list fields, nor the timestamp or
  /// target/callback of the original message.
  void copyFrom(Message o) => _copyFrom(reference, o.reference);

  static final _getWhen =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Message_getWhen")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getWhen()
  /// Return the targeted delivery time of this message, in milliseconds.
  int getWhen() => _getWhen(reference);

  static final _setTarget = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Message_setTarget")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTarget(android.os.Handler target)
  void setTarget(Handler target) => _setTarget(reference, target.reference);

  static final _getTarget = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Message_getTarget")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Handler getTarget()
  /// Retrieve the a android.os.Handler Handler implementation that
  /// will receive this message. The object must implement
  /// android.os.Handler\#handleMessage(android.os.Message) Handler.handleMessage(). Each Handler has its own name-space for
  /// message codes, so you do not need to
  /// worry about yours conflicting with other handlers.
  Handler getTarget() => Handler.fromRef(_getTarget(reference));

  static final _getCallback = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Message_getCallback")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Runnable getCallback()
  /// Retrieve callback object that will execute when this message is handled.
  /// This object must implement Runnable. This is called by
  /// the _target_ Handler that is receiving this Message to
  /// dispatch it.  If
  /// not set, the message will be dispatched to the receiving Handler's
  /// Handler\#handleMessage(Message Handler.handleMessage()).
  jni.JlObject getCallback() => jni.JlObject.fromRef(_getCallback(reference));

  static final _getData = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Message_getData")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getData()
  /// Obtains a Bundle of arbitrary data associated with this
  /// event, lazily creating it if necessary. Set this value by calling
  /// \#setData(Bundle).  Note that when transferring data across
  /// processes via Messenger, you will need to set your ClassLoader
  /// on the Bundle via Bundle\#setClassLoader(ClassLoader) Bundle.setClassLoader() so that it can instantiate your objects when
  /// you retrieve them.
  ///@see \#peekData()
  ///@see \#setData(Bundle)
  Bundle getData() => Bundle.fromRef(_getData(reference));

  static final _peekData = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Message_peekData")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle peekData()
  /// Like getData(), but does not lazily create the Bundle.  A null
  /// is returned if the Bundle does not already exist.  See
  /// \#getData for further information on this.
  ///@see \#getData()
  ///@see \#setData(Bundle)
  Bundle peekData() => Bundle.fromRef(_peekData(reference));

  static final _setData = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Message_setData")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setData(android.os.Bundle data)
  /// Sets a Bundle of arbitrary data values. Use arg1 and arg2 members
  /// as a lower cost way to send a few simple integer values, if you can.
  ///@see \#getData()
  ///@see \#peekData()
  void setData(Bundle data) => _setData(reference, data.reference);

  static final _sendToTarget =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Message_sendToTarget")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void sendToTarget()
  /// Sends this Message to the Handler specified by \#getTarget.
  /// Throws a null pointer exception if this field has not been set.
  void sendToTarget() => _sendToTarget(reference);

  static final _isAsynchronous =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Message_isAsynchronous")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isAsynchronous()
  /// Returns true if the message is asynchronous, meaning that it is not
  /// subject to Looper synchronization barriers.
  ///@return True if the message is asynchronous.
  ///@see \#setAsynchronous(boolean)
  bool isAsynchronous() => _isAsynchronous(reference) != 0;

  static final _setAsynchronous = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_os_Message_setAsynchronous")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setAsynchronous(boolean async)
  /// Sets whether the message is asynchronous, meaning that it is not
  /// subject to Looper synchronization barriers.
  ///
  /// Certain operations, such as view invalidation, may introduce synchronization
  /// barriers into the Looper's message queue to prevent subsequent messages
  /// from being delivered until some condition is met.  In the case of view invalidation,
  /// messages which are posted after a call to android.view.View\#invalidate
  /// are suspended by means of a synchronization barrier until the next frame is
  /// ready to be drawn.  The synchronization barrier ensures that the invalidation
  /// request is completely handled before resuming.
  ///
  ///
  /// Asynchronous messages are exempt from synchronization barriers.  They typically
  /// represent interrupts, input events, and other signals that must be handled independently
  /// even while other work has been suspended.
  ///
  ///
  /// Note that asynchronous messages may be delivered out of order with respect to
  /// synchronous messages although they are always delivered in order among themselves.
  /// If the relative order of these messages matters then they probably should not be
  /// asynchronous in the first place.  Use with caution.
  ///
  ///
  ///@param async True if the message is asynchronous.
  ///@see \#isAsynchronous()
  void setAsynchronous(bool async_) =>
      _setAsynchronous(reference, async_ ? 1 : 0);

  static final _toString_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Message_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Message_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Message_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);
}

/// CPU usage information per core.
class CpuUsageInfo extends jni.JlObject {
  CpuUsageInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.os.CpuUsageInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_CpuUsageInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static Parcelable_Creator get CREATOR =>
      Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_CpuUsageInfo_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Parcel in)
  CpuUsageInfo(Parcel in_) : super.fromRef(_ctor(in_.reference));

  static final _getActive =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_CpuUsageInfo_getActive")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getActive()
  /// Gets the active time in milliseconds since the system last booted.
  ///@return Active time in milliseconds.
  int getActive() => _getActive(reference);

  static final _getTotal =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_CpuUsageInfo_getTotal")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTotal()
  /// Gets the total time in milliseconds that the CPU has been enabled since the system last
  /// booted. This includes time the CPU spent idle.
  ///@return Total time in milliseconds.
  int getTotal() => _getTotal(reference);

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_CpuUsageInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_CpuUsageInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags);
}

/// Generic interface for receiving a callback result from someone.  Use this
/// by creating a subclass and implement \#onReceiveResult, which you can
/// then pass to others and send through IPC, and receive results they
/// supply with \#send.
///
/// Note: the implementation underneath is just a simple wrapper around
/// a Binder that is used to perform the communication.  This means
/// semantically you should treat it as such: this class does not impact process
/// lifecycle management (you must be using some higher-level component to tell
/// the system that your process needs to continue running), the connection will
/// break if your process goes away for any reason, etc.
///
class ResultReceiver extends jni.JlObject {
  ResultReceiver.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.os.ResultReceiver> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_ResultReceiver_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static Parcelable_Creator get CREATOR =>
      Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_ResultReceiver_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Handler handler)
  /// Create a new ResultReceive to receive results.  Your
  /// \#onReceiveResult method will be called from the thread running
  /// <var>handler</var> if given, or from an arbitrary thread if null.
  ResultReceiver(Handler handler) : super.fromRef(_ctor(handler.reference));

  static final _send = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_os_ResultReceiver_send")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void send(int resultCode, android.os.Bundle resultData)
  /// Deliver a result to this receiver.  Will call \#onReceiveResult,
  /// always asynchronously if the receiver has supplied a Handler in which
  /// to dispatch the result.
  ///@param resultCode Arbitrary result code to deliver, as defined by you.
  ///@param resultData Any additional data provided by you.
  void send(int resultCode, Bundle resultData) =>
      _send(reference, resultCode, resultData.reference);

  static final _onReceiveResult = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_os_ResultReceiver_onReceiveResult")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onReceiveResult(int resultCode, android.os.Bundle resultData)
  /// Override to receive results delivered to this object.
  ///@param resultCode Arbitrary result code delivered by the sender, as
  /// defined by the sender.
  ///@param resultData Any additional data provided by the sender.
  void onReceiveResult(int resultCode, Bundle resultData) =>
      _onReceiveResult(reference, resultCode, resultData.reference);

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ResultReceiver_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_ResultReceiver_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags);
}

/// A TokenWatcher watches a collection of IBinders. IBinders are added
/// to the collection by calling \#acquire, and removed by calling \#release. IBinders are also implicitly removed when they become weakly
/// reachable. Each IBinder may be added at most once.
///
/// The \#acquired method is invoked by posting to the specified handler
/// whenever the size of the watched collection becomes nonzero.  The \#released method is invoked on the specified handler whenever the size of
/// the watched collection becomes zero.
class TokenWatcher extends jni.JlObject {
  TokenWatcher.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_TokenWatcher_new")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Handler h, java.lang.String tag)
  /// Construct the TokenWatcher
  ///@param h A handler to call \#acquired and \#released
  /// on.  If you don't care, just call it like this, although your thread
  /// will have to be a Looper thread.
  /// <code>new TokenWatcher(new Handler())</code>
  ///@param tag A debugging tag for this TokenWatcher
  TokenWatcher(Handler h, jni.JlString tag)
      : super.fromRef(_ctor(h.reference, tag.reference));

  static final _acquired =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_TokenWatcher_acquired")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void acquired()
  /// Called when the number of active tokens goes from 0 to 1.
  void acquired() => _acquired(reference);

  static final _released =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_TokenWatcher_released")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void released()
  /// Called when the number of active tokens goes from 1 to 0.
  void released() => _released(reference);

  static final _acquire = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_TokenWatcher_acquire")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void acquire(android.os.IBinder token, java.lang.String tag)
  /// Record that this token has been acquired.  When acquire is called, and
  /// the current count is 0, the acquired method is called on the given
  /// handler.
  ///
  /// Note that the same {@code token} can only be acquired once. If this
  /// {@code token} has already been acquired, no action is taken. The first
  /// subsequent call to \#release will release this {@code token}
  /// immediately.
  ///@param token An IBinder object.
  ///@param tag A string used by the \#dump method for debugging,
  ///              to see who has references.
  void acquire(IBinder token, jni.JlString tag) =>
      _acquire(reference, token.reference, tag.reference);

  static final _cleanup = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_os_TokenWatcher_cleanup")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void cleanup(android.os.IBinder token, boolean unlink)
  void cleanup(IBinder token, bool unlink) =>
      _cleanup(reference, token.reference, unlink ? 1 : 0);

  static final _release = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_TokenWatcher_release")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void release(android.os.IBinder token)
  void release(IBinder token) => _release(reference, token.reference);

  static final _isAcquired =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_TokenWatcher_isAcquired")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isAcquired()
  bool isAcquired() => _isAcquired(reference) != 0;

  static final _dump =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_TokenWatcher_dump")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dump()
  void dump() => _dump(reference);

  static final _dump_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_TokenWatcher_dump_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(java.io.PrintWriter pw)
  void dump_1(jni.JlObject pw) => _dump_1(reference, pw.reference);
}

/// Takes care of the grunt work of maintaining a list of remote interfaces,
/// typically for the use of performing callbacks from a
/// android.app.Service to its clients.  In particular, this:
///
/// <ul>
/// <li> Keeps track of a set of registered IInterface callbacks,
/// taking care to identify them through their underlying unique IBinder
/// (by calling IInterface\#asBinder IInterface.asBinder().
/// <li> Attaches a IBinder.DeathRecipient IBinder.DeathRecipient to
/// each registered interface, so that it can be cleaned out of the list if its
/// process goes away.
/// <li> Performs locking of the underlying list of interfaces to deal with
/// multithreaded incoming calls, and a thread-safe way to iterate over a
/// snapshot of the list without holding its lock.
/// </ul>
///
/// To use this class, simply create a single instance along with your
/// service, and call its \#register and \#unregister methods
/// as client register and unregister with your service.  To call back on to
/// the registered clients, use \#beginBroadcast,
/// \#getBroadcastItem, and \#finishBroadcast.
///
/// If a registered callback's process goes away, this class will take
/// care of automatically removing it from the list.  If you want to do
/// additional work in this situation, you can create a subclass that
/// implements the \#onCallbackDied method.
class RemoteCallbackList extends jni.JlObject {
  RemoteCallbackList.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_RemoteCallbackList_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  RemoteCallbackList() : super.fromRef(_ctor());

  static final _kill =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_RemoteCallbackList_kill")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void kill()
  /// Disable this callback list.  All registered callbacks are unregistered,
  /// and the list is disabled so that future calls to \#register will
  /// fail.  This should be used when a Service is stopping, to prevent clients
  /// from registering callbacks after it is stopped.
  ///@see \#register
  void kill() => _kill(reference);

  static final _beginBroadcast =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_RemoteCallbackList_beginBroadcast")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int beginBroadcast()
  /// Prepare to start making calls to the currently registered callbacks.
  /// This creates a copy of the callback list, which you can retrieve items
  /// from using \#getBroadcastItem.  Note that only one broadcast can
  /// be active at a time, so you must be sure to always call this from the
  /// same thread (usually by scheduling with Handler) or
  /// do your own synchronization.  You must call \#finishBroadcast
  /// when done.
  ///
  /// A typical loop delivering a broadcast looks like this:
  ///
  /// <pre>
  /// int i = callbacks.beginBroadcast();
  /// while (i &gt; 0) {
  ///     i--;
  ///     try {
  ///         callbacks.getBroadcastItem(i).somethingHappened();
  ///     } catch (RemoteException e) {
  ///         // The RemoteCallbackList will take care of removing
  ///         // the dead object for us.
  ///     }
  /// }
  /// callbacks.finishBroadcast();</pre>
  ///@return Returns the number of callbacks in the broadcast, to be used
  /// with \#getBroadcastItem to determine the range of indices you
  /// can supply.
  ///@see \#getBroadcastItem
  ///@see \#finishBroadcast
  int beginBroadcast() => _beginBroadcast(reference);

  static final _getBroadcastCookie = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_os_RemoteCallbackList_getBroadcastCookie")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.Object getBroadcastCookie(int index)
  /// Retrieve the cookie associated with the item
  /// returned by \#getBroadcastItem(int).
  ///@see \#getBroadcastItem
  jni.JlObject getBroadcastCookie(int index) =>
      jni.JlObject.fromRef(_getBroadcastCookie(reference, index));

  static final _finishBroadcast =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_RemoteCallbackList_finishBroadcast")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void finishBroadcast()
  /// Clean up the state of a broadcast previously initiated by calling
  /// \#beginBroadcast.  This must always be called when you are done
  /// with a broadcast.
  ///@see \#beginBroadcast
  void finishBroadcast() => _finishBroadcast(reference);

  static final _getRegisteredCallbackCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_RemoteCallbackList_getRegisteredCallbackCount")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getRegisteredCallbackCount()
  /// Returns the number of registered callbacks. Note that the number of registered
  /// callbacks may differ from the value returned by \#beginBroadcast() since
  /// the former returns the number of callbacks registered at the time of the call
  /// and the second the number of callback to which the broadcast will be delivered.
  ///
  /// This function is useful to decide whether to schedule a broadcast if this
  /// requires doing some work which otherwise would not be performed.
  ///
  ///
  ///@return The size.
  int getRegisteredCallbackCount() => _getRegisteredCallbackCount(reference);

  static final _getRegisteredCallbackCookie = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_os_RemoteCallbackList_getRegisteredCallbackCookie")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.Object getRegisteredCallbackCookie(int index)
  /// Return any cookie associated with a currently registered callback.  Note that this is
  /// _not_ the same as \#getBroadcastCookie and should not be used
  /// interchangeably with it.  This method returns the current cookie registered at the given
  /// index, not the current broadcast state.  This means that it is not itself thread-safe:
  /// any call to \#register or \#unregister will change these indices, so you
  /// must do your own thread safety between these to protect from such changes.
  ///@param index Index of which registration cookie to return, from 0 to
  /// \#getRegisteredCallbackCount() - 1.
  ///@return Returns whatever cookie object is associated with this index, or null if
  /// \#kill() has been called.
  jni.JlObject getRegisteredCallbackCookie(int index) =>
      jni.JlObject.fromRef(_getRegisteredCallbackCookie(reference, index));
}

/// Class that implements the condition variable locking paradigm.
///
///
/// This differs from the built-in java.lang.Object wait() and notify()
/// in that this class contains the condition to wait on itself.  That means
/// open(), close() and block() are sticky.  If open() is called before block(),
/// block() will not block, and instead return immediately.
///
///
/// This class uses itself as the object to wait on, so if you wait()
/// or notify() on a ConditionVariable, the results are undefined.
class ConditionVariable extends jni.JlObject {
  ConditionVariable.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_ConditionVariable_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Create the ConditionVariable in the default closed state.
  ConditionVariable() : super.fromRef(_ctor());

  static final _ctor_1 =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Uint8)>>(
              "android_os_ConditionVariable_new_1")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: public void <init>(boolean state)
  /// Create the ConditionVariable with the given state.
  ///
  ///
  /// Pass true for opened and false for closed.
  ConditionVariable.ctor_1(bool state) : super.fromRef(_ctor_1(state ? 1 : 0));

  static final _open =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ConditionVariable_open")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void open()
  /// Open the condition, and release all threads that are blocked.
  ///
  ///
  /// Any threads that later approach block() will not block unless close()
  /// is called.
  void open() => _open(reference);

  static final _close =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ConditionVariable_close")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void close()
  /// Reset the condition to the closed state.
  ///
  ///
  /// Any threads that call block() will block until someone calls open.
  void close() => _close(reference);

  static final _block =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ConditionVariable_block")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void block()
  /// Block the current thread until the condition is opened.
  ///
  ///
  /// If the condition is already opened, return immediately.
  void block() => _block(reference);

  static final _block_1 = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_os_ConditionVariable_block_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean block(long timeout)
  /// Block the current thread until the condition is opened or until
  /// timeout milliseconds have passed.
  ///
  ///
  /// If the condition is already opened, return immediately.
  ///@param timeout the maximum time to wait in milliseconds.
  ///@return true if the condition was opened, false if the call returns
  /// because of the timeout.
  bool block_1(int timeout) => _block_1(reference, timeout) != 0;
}

/// The exception that is thrown when an application exposes a {@code file://}
/// android.net.Uri to another app.
///
/// This exposure is discouraged since the receiving app may not have access to
/// the shared path. For example, the receiving app may not have requested the
/// android.Manifest.permission\#READ_EXTERNAL_STORAGE runtime permission,
/// or the platform may be sharing the android.net.Uri across user
/// profile boundaries.
///
/// Instead, apps should use {@code content://} Uris so the platform can extend
/// temporary permission for the receiving app to access the resource.
///
/// This is only thrown for applications targeting Build.VERSION_CODES\#N
/// or higher. Applications targeting earlier SDK versions are allowed to share
/// {@code file://} android.net.Uri, but it's strongly discouraged.
///@see android.support.v4.content.FileProvider
///@see Intent\#FLAG_GRANT_READ_URI_PERMISSION
class FileUriExposedException extends jni.JlObject {
  FileUriExposedException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_FileUriExposedException_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String message)
  FileUriExposedException(jni.JlString message)
      : super.fromRef(_ctor(message.reference));
}

/// Monitors files (using <a href="http://en.wikipedia.org/wiki/Inotify">inotify</a>)
/// to fire an event after files are accessed or changed by by any process on
/// the device (including this one).  FileObserver is an abstract class;
/// subclasses must implement the event handler \#onEvent(int, String).
///
/// Each FileObserver instance monitors a single file or directory.
/// If a directory is monitored, events will be triggered for all files and
/// subdirectories inside the monitored directory.
///
///
/// An event mask is used to specify which changes or actions to report.
/// Event type constants are used to describe the possible changes in the
/// event mask as well as what actually happened in event callbacks.
///
///
/// <p class="caution">__Warning__: If a FileObserver is garbage collected, it
/// will stop sending events.  To ensure you keep receiving events, you must
/// keep a reference to the FileObserver instance from some other live object.
///
class FileObserver extends jni.JlObject {
  FileObserver.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int ACCESS
  /// Event type: Data was read from a file
  static const ACCESS = 1;

  /// from: static public final int ALL_EVENTS
  /// Event mask: All valid event types, combined
  static const ALL_EVENTS = 4095;

  /// from: static public final int ATTRIB
  /// Event type: Metadata (permissions, owner, timestamp) was changed explicitly
  static const ATTRIB = 4;

  /// from: static public final int CLOSE_NOWRITE
  /// Event type: Someone had a file or directory open read-only, and closed it
  static const CLOSE_NOWRITE = 16;

  /// from: static public final int CLOSE_WRITE
  /// Event type: Someone had a file or directory open for writing, and closed it
  static const CLOSE_WRITE = 8;

  /// from: static public final int CREATE
  /// Event type: A new file or subdirectory was created under the monitored directory
  static const CREATE = 256;

  /// from: static public final int DELETE
  /// Event type: A file was deleted from the monitored directory
  static const DELETE = 512;

  /// from: static public final int DELETE_SELF
  /// Event type: The monitored file or directory was deleted; monitoring effectively stops
  static const DELETE_SELF = 1024;

  /// from: static public final int MODIFY
  /// Event type: Data was written to a file
  static const MODIFY = 2;

  /// from: static public final int MOVED_FROM
  /// Event type: A file or subdirectory was moved from the monitored directory
  static const MOVED_FROM = 64;

  /// from: static public final int MOVED_TO
  /// Event type: A file or subdirectory was moved to the monitored directory
  static const MOVED_TO = 128;

  /// from: static public final int MOVE_SELF
  /// Event type: The monitored file or directory was moved; monitoring continues
  static const MOVE_SELF = 2048;

  /// from: static public final int OPEN
  /// Event type: A file or directory was opened
  static const OPEN = 32;

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_FileObserver_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String path)
  /// Equivalent to FileObserver(path, FileObserver.ALL_EVENTS).
  FileObserver(jni.JlString path) : super.fromRef(_ctor(path.reference));

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_FileObserver_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String path, int mask)
  /// Create a new file observer for a certain file or directory.
  /// Monitoring does not start on creation!  You must call
  /// \#startWatching() before you will receive events.
  ///@param path The file or directory to monitor
  ///@param mask The event or events (added together) to watch for
  FileObserver.ctor_1(jni.JlString path, int mask)
      : super.fromRef(_ctor_1(path.reference, mask));

  static final _finalize =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_FileObserver_finalize")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void finalize()
  void finalize() => _finalize(reference);

  static final _startWatching =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_FileObserver_startWatching")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void startWatching()
  /// Start watching for events.  The monitored file or directory must exist at
  /// this time, or else no events will be reported (even if it appears later).
  /// If monitoring is already started, this call has no effect.
  void startWatching() => _startWatching(reference);

  static final _stopWatching =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_FileObserver_stopWatching")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void stopWatching()
  /// Stop watching for events.  Some events may be in process, so events
  /// may continue to be reported even after this method completes.  If
  /// monitoring is already stopped, this call has no effect.
  void stopWatching() => _stopWatching(reference);

  static final _onEvent = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_os_FileObserver_onEvent")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onEvent(int event, java.lang.String path)
  /// The event handler, which must be implemented by subclasses.
  ///
  /// <p class="note">This method is invoked on a special FileObserver thread.
  /// It runs independently of any threads, so take care to use appropriate
  /// synchronization!  Consider using Handler\#post(Runnable) to shift
  /// event handling work to the main thread to avoid concurrency problems.
  ///
  ///
  /// Event handlers must not throw exceptions.
  ///
  ///@param event The type of event which happened
  ///@param path The path, relative to the main monitored file or directory,
  ///     of the file or directory which triggered the event.  This value can
  ///     be {@code null} for certain events, such as \#MOVE_SELF.
  ///
  /// This value may be {@code null}.
  void onEvent(int event, jni.JlString path) =>
      _onEvent(reference, event, path.reference);
}

/// The contents of a Parcel (usually during unmarshalling) does not
/// contain the expected data.
class ParcelFormatException extends jni.JlObject {
  ParcelFormatException.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_ParcelFormatException_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ParcelFormatException() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_ParcelFormatException_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String reason)
  ParcelFormatException.ctor_1(jni.JlString reason)
      : super.fromRef(_ctor_1(reason.reference));
}

/// MemoryFile is a wrapper for SharedMemory which can optionally be set to purgeable.
///
/// Applications should generally prefer to use SharedMemory which offers more flexible
/// access & control over the shared memory region than MemoryFile does.
///
/// Purgeable files may have their contents reclaimed by the kernel
/// in low memory conditions (only if allowPurging is set to true).
/// After a file is purged, attempts to read or write the file will
/// cause an IOException to be thrown.
class MemoryFile extends jni.JlObject {
  MemoryFile.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_MemoryFile_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String name, int length)
  /// Allocates a new ashmem region. The region is initially not purgable.
  ///@param name optional name for the file (can be null).
  ///@param length of the memory file in bytes, must be positive.
  ///@throws IOException if the memory file could not be created.
  MemoryFile(jni.JlString name, int length)
      : super.fromRef(_ctor(name.reference, length));

  static final _close =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_MemoryFile_close")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void close()
  /// Closes the memory file. If there are no other open references to the memory
  /// file, it will be deleted.
  void close() => _close(reference);

  static final _length =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_MemoryFile_length")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int length()
  /// Returns the length of the memory file.
  ///@return file length.
  int length() => _length(reference);

  static final _isPurgingAllowed =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_MemoryFile_isPurgingAllowed")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isPurgingAllowed()
  /// Is memory file purging enabled?
  ///@return true if the file may be purged.
  ///@deprecated Purgable is considered generally fragile and hard to use safely. Applications
  /// are recommend to instead use android.content.ComponentCallbacks2\#onTrimMemory(int)
  /// to react to memory events and release shared memory regions as appropriate.
  bool isPurgingAllowed() => _isPurgingAllowed(reference) != 0;

  static final _allowPurging = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_os_MemoryFile_allowPurging")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: synchronized public boolean allowPurging(boolean allowPurging)
  /// Enables or disables purging of the memory file.
  ///@param allowPurging true if the operating system can purge the contents
  /// of the file in low memory situations
  ///@return previous value of allowPurging
  ///@deprecated Purgable is considered generally fragile and hard to use safely. Applications
  /// are recommend to instead use android.content.ComponentCallbacks2\#onTrimMemory(int)
  /// to react to memory events and release shared memory regions as appropriate.
  bool allowPurging(bool allowPurging_) =>
      _allowPurging(reference, allowPurging_ ? 1 : 0) != 0;

  static final _getInputStream = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_MemoryFile_getInputStream")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.InputStream getInputStream()
  /// Creates a new InputStream for reading from the memory file.
  ///@return InputStream
  jni.JlObject getInputStream() =>
      jni.JlObject.fromRef(_getInputStream(reference));

  static final _getOutputStream = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_MemoryFile_getOutputStream")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.OutputStream getOutputStream()
  /// Creates a new OutputStream for writing to the memory file.
  ///@return OutputStream
  jni.JlObject getOutputStream() =>
      jni.JlObject.fromRef(_getOutputStream(reference));

  static final _readBytes = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("android_os_MemoryFile_readBytes")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public int readBytes(byte[] buffer, int srcOffset, int destOffset, int count)
  /// Reads bytes from the memory file.
  /// Will throw an IOException if the file has been purged.
  ///@param buffer byte array to read bytes into.
  ///@param srcOffset offset into the memory file to read from.
  ///@param destOffset offset into the byte array buffer to read into.
  ///@param count number of bytes to read.
  ///@return number of bytes read.
  ///@throws IOException if the memory file has been purged or deactivated.
  int readBytes(
          jni.JlObject buffer, int srcOffset, int destOffset, int count) =>
      _readBytes(reference, buffer.reference, srcOffset, destOffset, count);

  static final _writeBytes = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("android_os_MemoryFile_writeBytes")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void writeBytes(byte[] buffer, int srcOffset, int destOffset, int count)
  /// Write bytes to the memory file.
  /// Will throw an IOException if the file has been purged.
  ///@param buffer byte array to write bytes from.
  ///@param srcOffset offset into the byte array buffer to write from.
  ///@param destOffset offset  into the memory file to write to.
  ///@param count number of bytes to write.
  ///@throws IOException if the memory file has been purged or deactivated.
  void writeBytes(
          jni.JlObject buffer, int srcOffset, int destOffset, int count) =>
      _writeBytes(reference, buffer.reference, srcOffset, destOffset, count);
}

/// Exception thrown when a Parcelable is malformed or otherwise invalid.
///
/// This is typically encountered when a custom Parcelable object is
/// passed to another process that doesn't have the same Parcelable class
/// in its ClassLoader.
class BadParcelableException extends jni.JlObject {
  BadParcelableException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_BadParcelableException_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String msg)
  BadParcelableException(jni.JlString msg)
      : super.fromRef(_ctor(msg.reference));

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_BadParcelableException_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.Exception cause)
  BadParcelableException.ctor_1(jni.JlObject cause)
      : super.fromRef(_ctor_1(cause.reference));
}

/// The Binder transaction failed because it was too large.
///
/// During a remote procedure call, the arguments and the return value of the call
/// are transferred as Parcel objects stored in the Binder transaction buffer.
/// If the arguments or the return value are too large to fit in the transaction buffer,
/// then the call will fail and TransactionTooLargeException will be thrown.
///
///
/// The Binder transaction buffer has a limited fixed size, currently 1Mb, which
/// is shared by all transactions in progress for the process.  Consequently this
/// exception can be thrown when there are many transactions in progress even when
/// most of the individual transactions are of moderate size.
///
///
/// There are two possible outcomes when a remote procedure call throws
/// TransactionTooLargeException.  Either the client was unable to send
/// its request to the service (most likely if the arguments were too large to fit in
/// the transaction buffer), or the service was unable to send its response back
/// to the client (most likely if the return value was too large to fit
/// in the transaction buffer).  It is not possible to tell which of these outcomes
/// actually occurred.  The client should assume that a partial failure occurred.
///
///
/// The key to avoiding TransactionTooLargeException is to keep all
/// transactions relatively small.  Try to minimize the amount of memory needed to create
/// a Parcel for the arguments and the return value of the remote procedure call.
/// Avoid transferring huge arrays of strings or large bitmaps.
/// If possible, try to break up big requests into smaller pieces.
///
///
/// If you are implementing a service, it may help to impose size or complexity
/// contraints on the queries that clients can perform.  For example, if the result set
/// could become large, then don't allow the client to request more than a few records
/// at a time.  Alternately, instead of returning all of the available data all at once,
/// return the essential information first and make the client ask for additional information
/// later as needed.
///
///
class TransactionTooLargeException extends RemoteException {
  TransactionTooLargeException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_TransactionTooLargeException_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  TransactionTooLargeException() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_TransactionTooLargeException_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String msg)
  TransactionTooLargeException.ctor_1(jni.JlString msg)
      : super.fromRef(_ctor_1(msg.reference));
}

/// A Handler allows you to send and process Message and Runnable
/// objects associated with a thread's MessageQueue.  Each Handler
/// instance is associated with a single thread and that thread's message
/// queue.  When you create a new Handler, it is bound to the thread /
/// message queue of the thread that is creating it -- from that point on,
/// it will deliver messages and runnables to that message queue and execute
/// them as they come out of the message queue.
///
/// There are two main uses for a Handler: (1) to schedule messages and
/// runnables to be executed as some point in the future; and (2) to enqueue
/// an action to be performed on a different thread than your own.
///
/// Scheduling messages is accomplished with the
/// \#post, \#postAtTime(Runnable, long),
/// \#postDelayed, \#sendEmptyMessage,
/// \#sendMessage, \#sendMessageAtTime, and
/// \#sendMessageDelayed methods.  The _post_ versions allow
/// you to enqueue Runnable objects to be called by the message queue when
/// they are received; the _sendMessage_ versions allow you to enqueue
/// a Message object containing a bundle of data that will be
/// processed by the Handler's \#handleMessage method (requiring that
/// you implement a subclass of Handler).
///
/// When posting or sending to a Handler, you can either
/// allow the item to be processed as soon as the message queue is ready
/// to do so, or specify a delay before it gets processed or absolute time for
/// it to be processed.  The latter two allow you to implement timeouts,
/// ticks, and other timing-based behavior.
///
/// When a
/// process is created for your application, its main thread is dedicated to
/// running a message queue that takes care of managing the top-level
/// application objects (activities, broadcast receivers, etc) and any windows
/// they create.  You can create your own threads, and communicate back with
/// the main application thread through a Handler.  This is done by calling
/// the same _post_ or _sendMessage_ methods as before, but from
/// your new thread.  The given Runnable or Message will then be scheduled
/// in the Handler's message queue and processed when appropriate.
class Handler extends jni.JlObject {
  Handler.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Handler_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Default constructor associates this handler with the Looper for the
  /// current thread.
  ///
  /// If this thread does not have a looper, this handler won't be able to receive messages
  /// so an exception is thrown.
  Handler() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Handler_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Handler.Callback callback)
  /// Constructor associates this handler with the Looper for the
  /// current thread and takes a callback interface in which you can handle
  /// messages.
  ///
  /// If this thread does not have a looper, this handler won't be able to receive messages
  /// so an exception is thrown.
  ///@param callback The callback interface in which to handle messages, or null.
  Handler.ctor_1(Handler_Callback callback)
      : super.fromRef(_ctor_1(callback.reference));

  static final _ctor_2 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Handler_new_2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Looper looper)
  /// Use the provided Looper instead of the default one.
  ///@param looper The looper, must not be null.
  Handler.ctor_2(Looper looper) : super.fromRef(_ctor_2(looper.reference));

  static final _ctor_3 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Handler_new_3")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Looper looper, android.os.Handler.Callback callback)
  /// Use the provided Looper instead of the default one and take a callback
  /// interface in which to handle messages.
  ///@param looper The looper, must not be null.
  ///@param callback The callback interface in which to handle messages, or null.
  Handler.ctor_3(Looper looper, Handler_Callback callback)
      : super.fromRef(_ctor_3(looper.reference, callback.reference));

  static final _handleMessage = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Handler_handleMessage")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void handleMessage(android.os.Message msg)
  /// Subclasses must implement this to receive messages.
  void handleMessage(Message msg) => _handleMessage(reference, msg.reference);

  static final _dispatchMessage = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Handler_dispatchMessage")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchMessage(android.os.Message msg)
  /// Handle system messages here.
  void dispatchMessage(Message msg) =>
      _dispatchMessage(reference, msg.reference);

  static final _createAsync = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Handler_createAsync")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.Handler createAsync(android.os.Looper looper)
  /// Create a new Handler whose posted messages and runnables are not subject to
  /// synchronization barriers such as display vsync.
  ///
  /// Messages sent to an async handler are guaranteed to be ordered with respect to one another,
  /// but not necessarily with respect to messages from other Handlers.
  ///
  ///@see \#createAsync(Looper, Callback) to create an async Handler with custom message handling.
  ///@param looper the Looper that the new Handler should be bound to
  /// This value must never be {@code null}.
  ///@return a new async Handler instance
  ///
  /// This value will never be {@code null}.
  static Handler createAsync(Looper looper) =>
      Handler.fromRef(_createAsync(looper.reference));

  static final _createAsync_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Handler_createAsync_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.Handler createAsync(android.os.Looper looper, android.os.Handler.Callback callback)
  /// Create a new Handler whose posted messages and runnables are not subject to
  /// synchronization barriers such as display vsync.
  ///
  /// Messages sent to an async handler are guaranteed to be ordered with respect to one another,
  /// but not necessarily with respect to messages from other Handlers.
  ///
  ///@see \#createAsync(Looper) to create an async Handler without custom message handling.
  ///@param looper the Looper that the new Handler should be bound to
  /// This value must never be {@code null}.
  ///@param callback This value must never be {@code null}.
  ///@return a new async Handler instance
  ///
  /// This value will never be {@code null}.
  static Handler createAsync_1(Looper looper, Handler_Callback callback) =>
      Handler.fromRef(_createAsync_1(looper.reference, callback.reference));

  static final _getMessageName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Handler_getMessageName")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getMessageName(android.os.Message message)
  /// Returns a string representing the name of the specified message.
  /// The default implementation will either return the class name of the
  /// message callback if any, or the hexadecimal representation of the
  /// message "what" field.
  ///@param message The message whose name is being queried
  jni.JlString getMessageName(Message message) =>
      jni.JlString.fromRef(_getMessageName(reference, message.reference));

  static final _obtainMessage = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Handler_obtainMessage")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.Message obtainMessage()
  /// Returns a new android.os.Message Message from the global message pool. More efficient than
  /// creating and allocating new instances. The retrieved message has its handler set to this instance (Message.target == this).
  ///  If you don't want that facility, just call Message.obtain() instead.
  Message obtainMessage() => Message.fromRef(_obtainMessage(reference));

  static final _obtainMessage_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Handler_obtainMessage_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final android.os.Message obtainMessage(int what)
  /// Same as \#obtainMessage(), except that it also sets the what member of the returned Message.
  ///@param what Value to assign to the returned Message.what field.
  ///@return A Message from the global message pool.
  Message obtainMessage_1(int what) =>
      Message.fromRef(_obtainMessage_1(reference, what));

  static final _obtainMessage_2 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_os_Handler_obtainMessage_2")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.Message obtainMessage(int what, java.lang.Object obj)
  /// Same as \#obtainMessage(), except that it also sets the what and obj members
  /// of the returned Message.
  ///@param what Value to assign to the returned Message.what field.
  ///@param obj Value to assign to the returned Message.obj field.
  ///@return A Message from the global message pool.
  Message obtainMessage_2(int what, jni.JlObject obj) =>
      Message.fromRef(_obtainMessage_2(reference, what, obj.reference));

  static final _obtainMessage_3 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32)>>("android_os_Handler_obtainMessage_3")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public final android.os.Message obtainMessage(int what, int arg1, int arg2)
  /// Same as \#obtainMessage(), except that it also sets the what, arg1 and arg2 members of the returned
  /// Message.
  ///@param what Value to assign to the returned Message.what field.
  ///@param arg1 Value to assign to the returned Message.arg1 field.
  ///@param arg2 Value to assign to the returned Message.arg2 field.
  ///@return A Message from the global message pool.
  Message obtainMessage_3(int what, int arg1, int arg2) =>
      Message.fromRef(_obtainMessage_3(reference, what, arg1, arg2));

  static final _obtainMessage_4 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_os_Handler_obtainMessage_4")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.Message obtainMessage(int what, int arg1, int arg2, java.lang.Object obj)
  /// Same as \#obtainMessage(), except that it also sets the what, obj, arg1,and arg2 values on the
  /// returned Message.
  ///@param what Value to assign to the returned Message.what field.
  ///@param arg1 Value to assign to the returned Message.arg1 field.
  ///@param arg2 Value to assign to the returned Message.arg2 field.
  ///@param obj Value to assign to the returned Message.obj field.
  ///@return A Message from the global message pool.
  Message obtainMessage_4(int what, int arg1, int arg2, jni.JlObject obj) =>
      Message.fromRef(
          _obtainMessage_4(reference, what, arg1, arg2, obj.reference));

  static final _post = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Handler_post")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean post(java.lang.Runnable r)
  /// Causes the Runnable r to be added to the message queue.
  /// The runnable will be run on the thread to which this handler is
  /// attached.
  ///@param r The Runnable that will be executed.
  ///@return Returns true if the Runnable was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.
  bool post(jni.JlObject r) => _post(reference, r.reference) != 0;

  static final _postAtTime = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_os_Handler_postAtTime")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public final boolean postAtTime(java.lang.Runnable r, long uptimeMillis)
  /// Causes the Runnable r to be added to the message queue, to be run
  /// at a specific time given by <var>uptimeMillis</var>.
  /// __The time-base is android.os.SystemClock\#uptimeMillis.__
  /// Time spent in deep sleep will add an additional delay to execution.
  /// The runnable will be run on the thread to which this handler is attached.
  ///@param r The Runnable that will be executed.
  ///@param uptimeMillis The absolute time at which the callback should run,
  ///         using the android.os.SystemClock\#uptimeMillis time-base.
  ///@return Returns true if the Runnable was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.  Note that a
  ///         result of true does not mean the Runnable will be processed -- if
  ///         the looper is quit before the delivery time of the message
  ///         occurs then the message will be dropped.
  bool postAtTime(jni.JlObject r, int uptimeMillis) =>
      _postAtTime(reference, r.reference, uptimeMillis) != 0;

  static final _postAtTime_1 = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_os_Handler_postAtTime_1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public final boolean postAtTime(java.lang.Runnable r, java.lang.Object token, long uptimeMillis)
  /// Causes the Runnable r to be added to the message queue, to be run
  /// at a specific time given by <var>uptimeMillis</var>.
  /// __The time-base is android.os.SystemClock\#uptimeMillis.__
  /// Time spent in deep sleep will add an additional delay to execution.
  /// The runnable will be run on the thread to which this handler is attached.
  ///@param r The Runnable that will be executed.
  ///@param token An instance which can be used to cancel {@code r} via
  ///         \#removeCallbacksAndMessages.
  ///@param uptimeMillis The absolute time at which the callback should run,
  ///         using the android.os.SystemClock\#uptimeMillis time-base.
  ///@return Returns true if the Runnable was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.  Note that a
  ///         result of true does not mean the Runnable will be processed -- if
  ///         the looper is quit before the delivery time of the message
  ///         occurs then the message will be dropped.
  ///@see android.os.SystemClock\#uptimeMillis
  bool postAtTime_1(jni.JlObject r, jni.JlObject token, int uptimeMillis) =>
      _postAtTime_1(reference, r.reference, token.reference, uptimeMillis) != 0;

  static final _postDelayed = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_os_Handler_postDelayed")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public final boolean postDelayed(java.lang.Runnable r, long delayMillis)
  /// Causes the Runnable r to be added to the message queue, to be run
  /// after the specified amount of time elapses.
  /// The runnable will be run on the thread to which this handler
  /// is attached.
  /// __The time-base is android.os.SystemClock\#uptimeMillis.__
  /// Time spent in deep sleep will add an additional delay to execution.
  ///@param r The Runnable that will be executed.
  ///@param delayMillis The delay (in milliseconds) until the Runnable
  ///        will be executed.
  ///@return Returns true if the Runnable was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.  Note that a
  ///         result of true does not mean the Runnable will be processed --
  ///         if the looper is quit before the delivery time of the message
  ///         occurs then the message will be dropped.
  bool postDelayed(jni.JlObject r, int delayMillis) =>
      _postDelayed(reference, r.reference, delayMillis) != 0;

  static final _postDelayed_1 = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_os_Handler_postDelayed_1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public final boolean postDelayed(java.lang.Runnable r, java.lang.Object token, long delayMillis)
  /// Causes the Runnable r to be added to the message queue, to be run
  /// after the specified amount of time elapses.
  /// The runnable will be run on the thread to which this handler
  /// is attached.
  /// __The time-base is android.os.SystemClock\#uptimeMillis.__
  /// Time spent in deep sleep will add an additional delay to execution.
  ///@param r The Runnable that will be executed.
  ///@param token An instance which can be used to cancel {@code r} via
  ///         \#removeCallbacksAndMessages.
  ///@param delayMillis The delay (in milliseconds) until the Runnable
  ///        will be executed.
  ///@return Returns true if the Runnable was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.  Note that a
  ///         result of true does not mean the Runnable will be processed --
  ///         if the looper is quit before the delivery time of the message
  ///         occurs then the message will be dropped.
  bool postDelayed_1(jni.JlObject r, jni.JlObject token, int delayMillis) =>
      _postDelayed_1(reference, r.reference, token.reference, delayMillis) != 0;

  static final _postAtFrontOfQueue = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Handler_postAtFrontOfQueue")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean postAtFrontOfQueue(java.lang.Runnable r)
  /// Posts a message to an object that implements Runnable.
  /// Causes the Runnable r to executed on the next iteration through the
  /// message queue. The runnable will be run on the thread to which this
  /// handler is attached.
  /// __This method is only for use in very special circumstances -- it
  /// can easily starve the message queue, cause ordering problems, or have
  /// other unexpected side-effects.__
  ///@param r The Runnable that will be executed.
  ///@return Returns true if the message was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.
  bool postAtFrontOfQueue(jni.JlObject r) =>
      _postAtFrontOfQueue(reference, r.reference) != 0;

  static final _removeCallbacks = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Handler_removeCallbacks")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void removeCallbacks(java.lang.Runnable r)
  /// Remove any pending posts of Runnable r that are in the message queue.
  void removeCallbacks(jni.JlObject r) =>
      _removeCallbacks(reference, r.reference);

  static final _removeCallbacks_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Handler_removeCallbacks_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void removeCallbacks(java.lang.Runnable r, java.lang.Object token)
  /// Remove any pending posts of Runnable <var>r</var> with Object
  /// <var>token</var> that are in the message queue.  If <var>token</var> is null,
  /// all callbacks will be removed.
  void removeCallbacks_1(jni.JlObject r, jni.JlObject token) =>
      _removeCallbacks_1(reference, r.reference, token.reference);

  static final _sendMessage = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Handler_sendMessage")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean sendMessage(android.os.Message msg)
  /// Pushes a message onto the end of the message queue after all pending messages
  /// before the current time. It will be received in \#handleMessage,
  /// in the thread attached to this handler.
  ///@return Returns true if the message was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.
  bool sendMessage(Message msg) => _sendMessage(reference, msg.reference) != 0;

  static final _sendEmptyMessage = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Handler_sendEmptyMessage")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final boolean sendEmptyMessage(int what)
  /// Sends a Message containing only the what value.
  ///@return Returns true if the message was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.
  bool sendEmptyMessage(int what) => _sendEmptyMessage(reference, what) != 0;

  static final _sendEmptyMessageDelayed = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int64)>>("android_os_Handler_sendEmptyMessageDelayed")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final boolean sendEmptyMessageDelayed(int what, long delayMillis)
  /// Sends a Message containing only the what value, to be delivered
  /// after the specified amount of time elapses.
  ///@see \#sendMessageDelayed(android.os.Message, long)
  ///@return Returns true if the message was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.
  bool sendEmptyMessageDelayed(int what, int delayMillis) =>
      _sendEmptyMessageDelayed(reference, what, delayMillis) != 0;

  static final _sendEmptyMessageAtTime = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int64)>>("android_os_Handler_sendEmptyMessageAtTime")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis)
  /// Sends a Message containing only the what value, to be delivered
  /// at a specific time.
  ///@see \#sendMessageAtTime(android.os.Message, long)
  ///@return Returns true if the message was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.
  bool sendEmptyMessageAtTime(int what, int uptimeMillis) =>
      _sendEmptyMessageAtTime(reference, what, uptimeMillis) != 0;

  static final _sendMessageDelayed = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_os_Handler_sendMessageDelayed")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public final boolean sendMessageDelayed(android.os.Message msg, long delayMillis)
  /// Enqueue a message into the message queue after all pending messages
  /// before (current time + delayMillis). You will receive it in
  /// \#handleMessage, in the thread attached to this handler.
  ///@return Returns true if the message was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.  Note that a
  ///         result of true does not mean the message will be processed -- if
  ///         the looper is quit before the delivery time of the message
  ///         occurs then the message will be dropped.
  bool sendMessageDelayed(Message msg, int delayMillis) =>
      _sendMessageDelayed(reference, msg.reference, delayMillis) != 0;

  static final _sendMessageAtTime = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_os_Handler_sendMessageAtTime")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean sendMessageAtTime(android.os.Message msg, long uptimeMillis)
  /// Enqueue a message into the message queue after all pending messages
  /// before the absolute time (in milliseconds) <var>uptimeMillis</var>.
  /// __The time-base is android.os.SystemClock\#uptimeMillis.__
  /// Time spent in deep sleep will add an additional delay to execution.
  /// You will receive it in \#handleMessage, in the thread attached
  /// to this handler.
  ///@param uptimeMillis The absolute time at which the message should be
  ///         delivered, using the
  ///         android.os.SystemClock\#uptimeMillis time-base.
  ///@return Returns true if the message was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.  Note that a
  ///         result of true does not mean the message will be processed -- if
  ///         the looper is quit before the delivery time of the message
  ///         occurs then the message will be dropped.
  bool sendMessageAtTime(Message msg, int uptimeMillis) =>
      _sendMessageAtTime(reference, msg.reference, uptimeMillis) != 0;

  static final _sendMessageAtFrontOfQueue = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Handler_sendMessageAtFrontOfQueue")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean sendMessageAtFrontOfQueue(android.os.Message msg)
  /// Enqueue a message at the front of the message queue, to be processed on
  /// the next iteration of the message loop.  You will receive it in
  /// \#handleMessage, in the thread attached to this handler.
  /// __This method is only for use in very special circumstances -- it
  /// can easily starve the message queue, cause ordering problems, or have
  /// other unexpected side-effects.__
  ///@return Returns true if the message was successfully placed in to the
  ///         message queue.  Returns false on failure, usually because the
  ///         looper processing the message queue is exiting.
  bool sendMessageAtFrontOfQueue(Message msg) =>
      _sendMessageAtFrontOfQueue(reference, msg.reference) != 0;

  static final _removeMessages = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Handler_removeMessages")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void removeMessages(int what)
  /// Remove any pending posts of messages with code 'what' that are in the
  /// message queue.
  void removeMessages(int what) => _removeMessages(reference, what);

  static final _removeMessages_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "android_os_Handler_removeMessages_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final void removeMessages(int what, java.lang.Object object)
  /// Remove any pending posts of messages with code 'what' and whose obj is
  /// 'object' that are in the message queue.  If <var>object</var> is null,
  /// all messages will be removed.
  void removeMessages_1(int what, jni.JlObject object) =>
      _removeMessages_1(reference, what, object.reference);

  static final _removeCallbacksAndMessages = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Handler_removeCallbacksAndMessages")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void removeCallbacksAndMessages(java.lang.Object token)
  /// Remove any pending posts of callbacks and sent messages whose
  /// <var>obj</var> is <var>token</var>.  If <var>token</var> is null,
  /// all callbacks and messages will be removed.
  void removeCallbacksAndMessages(jni.JlObject token) =>
      _removeCallbacksAndMessages(reference, token.reference);

  static final _hasMessages = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Handler_hasMessages")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final boolean hasMessages(int what)
  /// Check if there are any pending posts of messages with code 'what' in
  /// the message queue.
  bool hasMessages(int what) => _hasMessages(reference, what) != 0;

  static final _hasMessages_1 = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("android_os_Handler_hasMessages_1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean hasMessages(int what, java.lang.Object object)
  /// Check if there are any pending posts of messages with code 'what' and
  /// whose obj is 'object' in the message queue.
  bool hasMessages_1(int what, jni.JlObject object) =>
      _hasMessages_1(reference, what, object.reference) != 0;

  static final _getLooper = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Handler_getLooper")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.Looper getLooper()
  Looper getLooper() => Looper.fromRef(_getLooper(reference));

  static final _dump = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Handler_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void dump(android.util.Printer pw, java.lang.String prefix)
  void dump(jni.JlObject pw, jni.JlString prefix) =>
      _dump(reference, pw.reference, prefix.reference);

  static final _toString_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Handler_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));
}

/// Callback interface you can use when instantiating a Handler to avoid
/// having to implement your own subclass of Handler.
class Handler_Callback extends jni.JlObject {
  Handler_Callback.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _handleMessage = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Handler__Callback_handleMessage")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean handleMessage(android.os.Message msg)
  /// @param msg A android.os.Message Message object
  ///@return True if no further handling is desired
  bool handleMessage(Message msg) =>
      _handleMessage(reference, msg.reference) != 0;
}

/// Provides various debugging methods for Android applications, including
/// tracing and allocation counts.
/// <strong>Logging Trace Files</strong>
///
/// Debug can create log files that give details about an application, such as
/// a call stack and start/stop times for any running methods. See <a href="{@docRoot}studio/profile/traceview.html">Inspect Trace Logs with
/// Traceview</a> for information about reading trace files. To start logging
/// trace files, call one of the startMethodTracing() methods. To stop tracing,
/// call \#stopMethodTracing().
class Debug extends jni.JlObject {
  Debug.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int SHOW_CLASSLOADER
  static const SHOW_CLASSLOADER = 2;

  /// from: static public final int SHOW_FULL_DETAIL
  /// Flags for printLoadedClasses().  Default behavior is to only show
  /// the class name.
  static const SHOW_FULL_DETAIL = 1;

  /// from: static public final int SHOW_INITIALIZED
  static const SHOW_INITIALIZED = 4;

  /// from: static public final int TRACE_COUNT_ALLOCS
  /// Flags for startMethodTracing().  These can be ORed together.
  ///
  /// TRACE_COUNT_ALLOCS adds the results from startAllocCounting to the
  /// trace key file.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static const TRACE_COUNT_ALLOCS = 1;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Debug_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  Debug() : super.fromRef(_ctor());

  static final _waitForDebugger =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_waitForDebugger")
          .asFunction<void Function()>();

  /// from: static public void waitForDebugger()
  /// Wait until a debugger attaches.  As soon as the debugger attaches,
  /// this returns, so you will need to place a breakpoint after the
  /// waitForDebugger() call if you want to start tracing immediately.
  static void waitForDebugger() => _waitForDebugger();

  static final _waitingForDebugger =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function()>>(
              "android_os_Debug_waitingForDebugger")
          .asFunction<int Function()>();

  /// from: static public boolean waitingForDebugger()
  /// Returns "true" if one or more threads is waiting for a debugger
  /// to attach.
  static bool waitingForDebugger() => _waitingForDebugger() != 0;

  static final _isDebuggerConnected =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function()>>(
              "android_os_Debug_isDebuggerConnected")
          .asFunction<int Function()>();

  /// from: static public boolean isDebuggerConnected()
  /// Determine if a debugger is currently attached.
  static bool isDebuggerConnected() => _isDebuggerConnected() != 0;

  static final _changeDebugPort =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
              "android_os_Debug_changeDebugPort")
          .asFunction<void Function(int)>();

  /// from: static public void changeDebugPort(int port)
  /// Change the JDWP port.
  ///@deprecated no longer needed or useful
  static void changeDebugPort(int port) => _changeDebugPort(port);

  static final _startNativeTracing =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_startNativeTracing")
          .asFunction<void Function()>();

  /// from: static public void startNativeTracing()
  /// Enable qemu tracing. For this to work requires running everything inside
  /// the qemu emulator; otherwise, this method will have no effect. The trace
  /// file is specified on the command line when the emulator is started. For
  /// example, the following command line <br/>
  /// <code>emulator -trace foo</code><br/>
  /// will start running the emulator and create a trace file named "foo". This
  /// method simply enables writing the trace records to the trace file.
  ///
  ///
  /// The main differences between this and \#startMethodTracing() are
  /// that tracing in the qemu emulator traces every cpu instruction of every
  /// process, including kernel code, so we have more complete information,
  /// including all context switches. We can also get more detailed information
  /// such as cache misses. The sequence of calls is determined by
  /// post-processing the instruction trace. The qemu tracing is also done
  /// without modifying the application or perturbing the timing of calls
  /// because no instrumentation is added to the application being traced.
  ///
  ///
  ///
  ///
  /// One limitation of using this method compared to using
  /// \#startMethodTracing() on the real device is that the emulator
  /// does not model all of the real hardware effects such as memory and
  /// bus contention.  The emulator also has a simple cache model and cannot
  /// capture all the complexities of a real cache.
  ///
  ///
  static void startNativeTracing() => _startNativeTracing();

  static final _stopNativeTracing =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_stopNativeTracing")
          .asFunction<void Function()>();

  /// from: static public void stopNativeTracing()
  /// Stop qemu tracing.  See \#startNativeTracing() to start tracing.
  ///
  /// Tracing can be started and stopped as many times as desired.  When
  /// the qemu emulator itself is stopped then the buffered trace records
  /// are flushed and written to the trace file.  In fact, it is not necessary
  /// to call this method at all; simply killing qemu is sufficient.  But
  /// starting and stopping a trace is useful for examining a specific
  /// region of code.
  ///
  static void stopNativeTracing() => _stopNativeTracing();

  static final _enableEmulatorTraceOutput =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_enableEmulatorTraceOutput")
          .asFunction<void Function()>();

  /// from: static public void enableEmulatorTraceOutput()
  /// Enable "emulator traces", in which information about the current
  /// method is made available to the "emulator -trace" feature.  There
  /// is no corresponding "disable" call -- this is intended for use by
  /// the framework when tracing should be turned on and left that way, so
  /// that traces captured with F9/F10 will include the necessary data.
  ///
  /// This puts the VM into "profile" mode, which has performance
  /// consequences.
  ///
  /// To temporarily enable tracing, use \#startNativeTracing().
  static void enableEmulatorTraceOutput() => _enableEmulatorTraceOutput();

  static final _startMethodTracing =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_startMethodTracing")
          .asFunction<void Function()>();

  /// from: static public void startMethodTracing()
  /// Start method tracing with default log name and buffer size.
  ///
  /// By default, the trace file is called "dmtrace.trace" and it's placed
  /// under your package-specific directory on primary shared/external storage,
  /// as returned by Context\#getExternalFilesDir(String).
  ///
  /// See <a href="{@docRoot}studio/profile/traceview.html">Inspect Trace Logs
  /// with Traceview</a> for information about reading trace files.
  /// <p class="note">
  /// When method tracing is enabled, the VM will run more slowly than usual,
  /// so the timings from the trace files should only be considered in relative
  /// terms (e.g. was run \#1 faster than run \#2). The times for native methods
  /// will not change, so don't try to use this to compare the performance of
  /// interpreted and native implementations of the same method. As an
  /// alternative, consider using sampling-based method tracing via
  /// \#startMethodTracingSampling(String, int, int) or "native" tracing
  /// in the emulator via \#startNativeTracing().
  ///
  ///
  static void startMethodTracing() => _startMethodTracing();

  static final _startMethodTracing_1 =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Debug_startMethodTracing_1")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void startMethodTracing(java.lang.String tracePath)
  /// Start method tracing, specifying the trace log file path.
  ///
  /// When a relative file path is given, the trace file will be placed under
  /// your package-specific directory on primary shared/external storage, as
  /// returned by Context\#getExternalFilesDir(String).
  ///
  /// See <a href="{@docRoot}studio/profile/traceview.html">Inspect Trace Logs
  /// with Traceview</a> for information about reading trace files.
  /// <p class="note">
  /// When method tracing is enabled, the VM will run more slowly than usual,
  /// so the timings from the trace files should only be considered in relative
  /// terms (e.g. was run \#1 faster than run \#2). The times for native methods
  /// will not change, so don't try to use this to compare the performance of
  /// interpreted and native implementations of the same method. As an
  /// alternative, consider using sampling-based method tracing via
  /// \#startMethodTracingSampling(String, int, int) or "native" tracing
  /// in the emulator via \#startNativeTracing().
  ///
  ///
  ///@param tracePath Path to the trace log file to create. If {@code null},
  ///            this will default to "dmtrace.trace". If the file already
  ///            exists, it will be truncated. If the path given does not end
  ///            in ".trace", it will be appended for you.
  static void startMethodTracing_1(jni.JlString tracePath) =>
      _startMethodTracing_1(tracePath.reference);

  static final _startMethodTracing_2 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Debug_startMethodTracing_2")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: static public void startMethodTracing(java.lang.String tracePath, int bufferSize)
  /// Start method tracing, specifying the trace log file name and the buffer
  /// size.
  ///
  /// When a relative file path is given, the trace file will be placed under
  /// your package-specific directory on primary shared/external storage, as
  /// returned by Context\#getExternalFilesDir(String).
  ///
  /// See <a href="{@docRoot}studio/profile/traceview.html">Inspect Trace Logs
  /// with Traceview</a> for information about reading trace files.
  /// <p class="note">
  /// When method tracing is enabled, the VM will run more slowly than usual,
  /// so the timings from the trace files should only be considered in relative
  /// terms (e.g. was run \#1 faster than run \#2). The times for native methods
  /// will not change, so don't try to use this to compare the performance of
  /// interpreted and native implementations of the same method. As an
  /// alternative, consider using sampling-based method tracing via
  /// \#startMethodTracingSampling(String, int, int) or "native" tracing
  /// in the emulator via \#startNativeTracing().
  ///
  ///
  ///@param tracePath Path to the trace log file to create. If {@code null},
  ///            this will default to "dmtrace.trace". If the file already
  ///            exists, it will be truncated. If the path given does not end
  ///            in ".trace", it will be appended for you.
  ///@param bufferSize The maximum amount of trace data we gather. If not
  ///            given, it defaults to 8MB.
  static void startMethodTracing_2(jni.JlString tracePath, int bufferSize) =>
      _startMethodTracing_2(tracePath.reference, bufferSize);

  static final _startMethodTracing_3 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_os_Debug_startMethodTracing_3")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: static public void startMethodTracing(java.lang.String tracePath, int bufferSize, int flags)
  /// Start method tracing, specifying the trace log file name, the buffer
  /// size, and flags.
  ///
  /// When a relative file path is given, the trace file will be placed under
  /// your package-specific directory on primary shared/external storage, as
  /// returned by Context\#getExternalFilesDir(String).
  ///
  /// See <a href="{@docRoot}studio/profile/traceview.html">Inspect Trace Logs
  /// with Traceview</a> for information about reading trace files.
  /// <p class="note">
  /// When method tracing is enabled, the VM will run more slowly than usual,
  /// so the timings from the trace files should only be considered in relative
  /// terms (e.g. was run \#1 faster than run \#2). The times for native methods
  /// will not change, so don't try to use this to compare the performance of
  /// interpreted and native implementations of the same method. As an
  /// alternative, consider using sampling-based method tracing via
  /// \#startMethodTracingSampling(String, int, int) or "native" tracing
  /// in the emulator via \#startNativeTracing().
  ///
  ///
  ///@param tracePath Path to the trace log file to create. If {@code null},
  ///            this will default to "dmtrace.trace". If the file already
  ///            exists, it will be truncated. If the path given does not end
  ///            in ".trace", it will be appended for you.
  ///@param bufferSize The maximum amount of trace data we gather. If not
  ///            given, it defaults to 8MB.
  ///@param flags Flags to control method tracing. The only one that is
  ///            currently defined is \#TRACE_COUNT_ALLOCS.
  static void startMethodTracing_3(
          jni.JlString tracePath, int bufferSize, int flags) =>
      _startMethodTracing_3(tracePath.reference, bufferSize, flags);

  static final _startMethodTracingSampling = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("android_os_Debug_startMethodTracingSampling")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: static public void startMethodTracingSampling(java.lang.String tracePath, int bufferSize, int intervalUs)
  /// Start sampling-based method tracing, specifying the trace log file name,
  /// the buffer size, and the sampling interval.
  ///
  /// When a relative file path is given, the trace file will be placed under
  /// your package-specific directory on primary shared/external storage, as
  /// returned by Context\#getExternalFilesDir(String).
  ///
  /// See <a href="{@docRoot}studio/profile/traceview.html">Inspect Trace Logs
  /// with Traceview</a> for information about reading trace files.
  ///@param tracePath Path to the trace log file to create. If {@code null},
  ///            this will default to "dmtrace.trace". If the file already
  ///            exists, it will be truncated. If the path given does not end
  ///            in ".trace", it will be appended for you.
  ///@param bufferSize The maximum amount of trace data we gather. If not
  ///            given, it defaults to 8MB.
  ///@param intervalUs The amount of time between each sample in microseconds.
  static void startMethodTracingSampling(
          jni.JlString tracePath, int bufferSize, int intervalUs) =>
      _startMethodTracingSampling(tracePath.reference, bufferSize, intervalUs);

  static final _stopMethodTracing =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_stopMethodTracing")
          .asFunction<void Function()>();

  /// from: static public void stopMethodTracing()
  /// Stop method tracing.
  static void stopMethodTracing() => _stopMethodTracing();

  static final _threadCpuTimeNanos =
      jlookup<ffi.NativeFunction<ffi.Int64 Function()>>(
              "android_os_Debug_threadCpuTimeNanos")
          .asFunction<int Function()>();

  /// from: static public long threadCpuTimeNanos()
  /// Get an indication of thread CPU usage.  The value returned
  /// indicates the amount of time that the current thread has spent
  /// executing code or waiting for certain types of I/O.
  ///
  /// The time is expressed in nanoseconds, and is only meaningful
  /// when compared to the result from an earlier call.  Note that
  /// nanosecond resolution does not imply nanosecond accuracy.
  ///
  /// On system which don't support this operation, the call returns -1.
  static int threadCpuTimeNanos() => _threadCpuTimeNanos();

  static final _startAllocCounting =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_startAllocCounting")
          .asFunction<void Function()>();

  /// from: static public void startAllocCounting()
  /// Start counting the number and aggregate size of memory allocations.
  ///
  /// The \#startAllocCounting() start method resets the counts and enables counting.
  /// The \#stopAllocCounting() stop method disables the counting so that the analysis
  /// code doesn't cause additional allocations.  The various <code>get</code> methods return
  /// the specified value. And the various <code>reset</code> methods reset the specified
  /// count.
  ///
  ///
  /// Counts are kept for the system as a whole (global) and for each thread.
  /// The per-thread counts for threads other than the current thread
  /// are not cleared by the "reset" or "start" calls.
  ///
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void startAllocCounting() => _startAllocCounting();

  static final _stopAllocCounting =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_stopAllocCounting")
          .asFunction<void Function()>();

  /// from: static public void stopAllocCounting()
  /// Stop counting the number and aggregate size of memory allocations.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void stopAllocCounting() => _stopAllocCounting();

  static final _getGlobalAllocCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getGlobalAllocCount")
          .asFunction<int Function()>();

  /// from: static public int getGlobalAllocCount()
  /// Returns the global count of objects allocated by the runtime between a
  /// \#startAllocCounting() start and \#stopAllocCounting() stop.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getGlobalAllocCount() => _getGlobalAllocCount();

  static final _resetGlobalAllocCount =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_resetGlobalAllocCount")
          .asFunction<void Function()>();

  /// from: static public void resetGlobalAllocCount()
  /// Clears the global count of objects allocated.
  ///@see \#getGlobalAllocCount()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetGlobalAllocCount() => _resetGlobalAllocCount();

  static final _getGlobalAllocSize =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getGlobalAllocSize")
          .asFunction<int Function()>();

  /// from: static public int getGlobalAllocSize()
  /// Returns the global size, in bytes, of objects allocated by the runtime between a
  /// \#startAllocCounting() start and \#stopAllocCounting() stop.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getGlobalAllocSize() => _getGlobalAllocSize();

  static final _resetGlobalAllocSize =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_resetGlobalAllocSize")
          .asFunction<void Function()>();

  /// from: static public void resetGlobalAllocSize()
  /// Clears the global size of objects allocated.
  ///@see \#getGlobalAllocSize()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetGlobalAllocSize() => _resetGlobalAllocSize();

  static final _getGlobalFreedCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getGlobalFreedCount")
          .asFunction<int Function()>();

  /// from: static public int getGlobalFreedCount()
  /// Returns the global count of objects freed by the runtime between a
  /// \#startAllocCounting() start and \#stopAllocCounting() stop.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getGlobalFreedCount() => _getGlobalFreedCount();

  static final _resetGlobalFreedCount =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_resetGlobalFreedCount")
          .asFunction<void Function()>();

  /// from: static public void resetGlobalFreedCount()
  /// Clears the global count of objects freed.
  ///@see \#getGlobalFreedCount()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetGlobalFreedCount() => _resetGlobalFreedCount();

  static final _getGlobalFreedSize =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getGlobalFreedSize")
          .asFunction<int Function()>();

  /// from: static public int getGlobalFreedSize()
  /// Returns the global size, in bytes, of objects freed by the runtime between a
  /// \#startAllocCounting() start and \#stopAllocCounting() stop.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getGlobalFreedSize() => _getGlobalFreedSize();

  static final _resetGlobalFreedSize =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_resetGlobalFreedSize")
          .asFunction<void Function()>();

  /// from: static public void resetGlobalFreedSize()
  /// Clears the global size of objects freed.
  ///@see \#getGlobalFreedSize()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetGlobalFreedSize() => _resetGlobalFreedSize();

  static final _getGlobalGcInvocationCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getGlobalGcInvocationCount")
          .asFunction<int Function()>();

  /// from: static public int getGlobalGcInvocationCount()
  /// Returns the number of non-concurrent GC invocations between a
  /// \#startAllocCounting() start and \#stopAllocCounting() stop.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getGlobalGcInvocationCount() => _getGlobalGcInvocationCount();

  static final _resetGlobalGcInvocationCount =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_resetGlobalGcInvocationCount")
          .asFunction<void Function()>();

  /// from: static public void resetGlobalGcInvocationCount()
  /// Clears the count of non-concurrent GC invocations.
  ///@see \#getGlobalGcInvocationCount()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetGlobalGcInvocationCount() => _resetGlobalGcInvocationCount();

  static final _getGlobalClassInitCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getGlobalClassInitCount")
          .asFunction<int Function()>();

  /// from: static public int getGlobalClassInitCount()
  /// Returns the number of classes successfully initialized (ie those that executed without
  /// throwing an exception) between a \#startAllocCounting() start and
  /// \#stopAllocCounting() stop.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getGlobalClassInitCount() => _getGlobalClassInitCount();

  static final _resetGlobalClassInitCount =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_resetGlobalClassInitCount")
          .asFunction<void Function()>();

  /// from: static public void resetGlobalClassInitCount()
  /// Clears the count of classes initialized.
  ///@see \#getGlobalClassInitCount()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetGlobalClassInitCount() => _resetGlobalClassInitCount();

  static final _getGlobalClassInitTime =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getGlobalClassInitTime")
          .asFunction<int Function()>();

  /// from: static public int getGlobalClassInitTime()
  /// Returns the time spent successfully initializing classes between a
  /// \#startAllocCounting() start and \#stopAllocCounting() stop.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getGlobalClassInitTime() => _getGlobalClassInitTime();

  static final _resetGlobalClassInitTime =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_resetGlobalClassInitTime")
          .asFunction<void Function()>();

  /// from: static public void resetGlobalClassInitTime()
  /// Clears the count of time spent initializing classes.
  ///@see \#getGlobalClassInitTime()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetGlobalClassInitTime() => _resetGlobalClassInitTime();

  static final _getGlobalExternalAllocCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getGlobalExternalAllocCount")
          .asFunction<int Function()>();

  /// from: static public int getGlobalExternalAllocCount()
  /// This method exists for compatibility and always returns 0.
  ///@deprecated This method is now obsolete.
  static int getGlobalExternalAllocCount() => _getGlobalExternalAllocCount();

  static final _resetGlobalExternalAllocSize =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_resetGlobalExternalAllocSize")
          .asFunction<void Function()>();

  /// from: static public void resetGlobalExternalAllocSize()
  /// This method exists for compatibility and has no effect.
  ///@deprecated This method is now obsolete.
  static void resetGlobalExternalAllocSize() => _resetGlobalExternalAllocSize();

  static final _resetGlobalExternalAllocCount =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_resetGlobalExternalAllocCount")
          .asFunction<void Function()>();

  /// from: static public void resetGlobalExternalAllocCount()
  /// This method exists for compatibility and has no effect.
  ///@deprecated This method is now obsolete.
  static void resetGlobalExternalAllocCount() =>
      _resetGlobalExternalAllocCount();

  static final _getGlobalExternalAllocSize =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getGlobalExternalAllocSize")
          .asFunction<int Function()>();

  /// from: static public int getGlobalExternalAllocSize()
  /// This method exists for compatibility and always returns 0.
  ///@deprecated This method is now obsolete.
  static int getGlobalExternalAllocSize() => _getGlobalExternalAllocSize();

  static final _getGlobalExternalFreedCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getGlobalExternalFreedCount")
          .asFunction<int Function()>();

  /// from: static public int getGlobalExternalFreedCount()
  /// This method exists for compatibility and always returns 0.
  ///@deprecated This method is now obsolete.
  static int getGlobalExternalFreedCount() => _getGlobalExternalFreedCount();

  static final _resetGlobalExternalFreedCount =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_resetGlobalExternalFreedCount")
          .asFunction<void Function()>();

  /// from: static public void resetGlobalExternalFreedCount()
  /// This method exists for compatibility and has no effect.
  ///@deprecated This method is now obsolete.
  static void resetGlobalExternalFreedCount() =>
      _resetGlobalExternalFreedCount();

  static final _getGlobalExternalFreedSize =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getGlobalExternalFreedSize")
          .asFunction<int Function()>();

  /// from: static public int getGlobalExternalFreedSize()
  /// This method exists for compatibility and has no effect.
  ///@deprecated This method is now obsolete.
  static int getGlobalExternalFreedSize() => _getGlobalExternalFreedSize();

  static final _resetGlobalExternalFreedSize =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_resetGlobalExternalFreedSize")
          .asFunction<void Function()>();

  /// from: static public void resetGlobalExternalFreedSize()
  /// This method exists for compatibility and has no effect.
  ///@deprecated This method is now obsolete.
  static void resetGlobalExternalFreedSize() => _resetGlobalExternalFreedSize();

  static final _getThreadAllocCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getThreadAllocCount")
          .asFunction<int Function()>();

  /// from: static public int getThreadAllocCount()
  /// Returns the thread-local count of objects allocated by the runtime between a
  /// \#startAllocCounting() start and \#stopAllocCounting() stop.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getThreadAllocCount() => _getThreadAllocCount();

  static final _resetThreadAllocCount =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_resetThreadAllocCount")
          .asFunction<void Function()>();

  /// from: static public void resetThreadAllocCount()
  /// Clears the thread-local count of objects allocated.
  ///@see \#getThreadAllocCount()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetThreadAllocCount() => _resetThreadAllocCount();

  static final _getThreadAllocSize =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getThreadAllocSize")
          .asFunction<int Function()>();

  /// from: static public int getThreadAllocSize()
  /// Returns the thread-local size of objects allocated by the runtime between a
  /// \#startAllocCounting() start and \#stopAllocCounting() stop.
  ///@return The allocated size in bytes.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getThreadAllocSize() => _getThreadAllocSize();

  static final _resetThreadAllocSize =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_resetThreadAllocSize")
          .asFunction<void Function()>();

  /// from: static public void resetThreadAllocSize()
  /// Clears the thread-local count of objects allocated.
  ///@see \#getThreadAllocSize()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetThreadAllocSize() => _resetThreadAllocSize();

  static final _getThreadExternalAllocCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getThreadExternalAllocCount")
          .asFunction<int Function()>();

  /// from: static public int getThreadExternalAllocCount()
  /// This method exists for compatibility and has no effect.
  ///@deprecated This method is now obsolete.
  static int getThreadExternalAllocCount() => _getThreadExternalAllocCount();

  static final _resetThreadExternalAllocCount =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_resetThreadExternalAllocCount")
          .asFunction<void Function()>();

  /// from: static public void resetThreadExternalAllocCount()
  /// This method exists for compatibility and has no effect.
  ///@deprecated This method is now obsolete.
  static void resetThreadExternalAllocCount() =>
      _resetThreadExternalAllocCount();

  static final _getThreadExternalAllocSize =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getThreadExternalAllocSize")
          .asFunction<int Function()>();

  /// from: static public int getThreadExternalAllocSize()
  /// This method exists for compatibility and has no effect.
  ///@deprecated This method is now obsolete.
  static int getThreadExternalAllocSize() => _getThreadExternalAllocSize();

  static final _resetThreadExternalAllocSize =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_resetThreadExternalAllocSize")
          .asFunction<void Function()>();

  /// from: static public void resetThreadExternalAllocSize()
  /// This method exists for compatibility and has no effect.
  ///@deprecated This method is now obsolete.
  static void resetThreadExternalAllocSize() => _resetThreadExternalAllocSize();

  static final _getThreadGcInvocationCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getThreadGcInvocationCount")
          .asFunction<int Function()>();

  /// from: static public int getThreadGcInvocationCount()
  /// Returns the number of thread-local non-concurrent GC invocations between a
  /// \#startAllocCounting() start and \#stopAllocCounting() stop.
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static int getThreadGcInvocationCount() => _getThreadGcInvocationCount();

  static final _resetThreadGcInvocationCount =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_resetThreadGcInvocationCount")
          .asFunction<void Function()>();

  /// from: static public void resetThreadGcInvocationCount()
  /// Clears the thread-local count of non-concurrent GC invocations.
  ///@see \#getThreadGcInvocationCount()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetThreadGcInvocationCount() => _resetThreadGcInvocationCount();

  static final _resetAllCounts =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Debug_resetAllCounts")
          .asFunction<void Function()>();

  /// from: static public void resetAllCounts()
  /// Clears all the global and thread-local memory allocation counters.
  ///@see \#startAllocCounting()
  ///@deprecated Accurate counting is a burden on the runtime and may be removed.
  static void resetAllCounts() => _resetAllCounts();

  static final _getRuntimeStat = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Debug_getRuntimeStat")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String getRuntimeStat(java.lang.String statName)
  /// Returns the value of a particular runtime statistic or {@code null} if no
  /// such runtime statistic exists.
  ///
  /// The following table lists the runtime statistics that the runtime supports.
  /// Note runtime statistics may be added or removed in a future API level.
  ///
  ///
  /// <table>
  ///     <thead>
  ///         <tr>
  ///             <th>Runtime statistic name</th>
  ///             <th>Meaning</th>
  ///             <th>Example</th>
  ///             <th>Supported (API Levels)</th>
  ///         </tr>
  ///     </thead>
  ///     <tbody>
  ///         <tr>
  ///             <td>art.gc.gc-count</td>
  ///             <td>The number of garbage collection runs.</td>
  ///             <td>{@code 164}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>art.gc.gc-time</td>
  ///             <td>The total duration of garbage collection runs in ms.</td>
  ///             <td>{@code 62364}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>art.gc.bytes-allocated</td>
  ///             <td>The total number of bytes that the application allocated.</td>
  ///             <td>{@code 1463948408}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>art.gc.bytes-freed</td>
  ///             <td>The total number of bytes that garbage collection reclaimed.</td>
  ///             <td>{@code 1313493084}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>art.gc.blocking-gc-count</td>
  ///             <td>The number of blocking garbage collection runs.</td>
  ///             <td>{@code 2}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>art.gc.blocking-gc-time</td>
  ///             <td>The total duration of blocking garbage collection runs in ms.</td>
  ///             <td>{@code 804}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>art.gc.gc-count-rate-histogram</td>
  ///             <td>Every 10 seconds, the gc-count-rate is computed as the number of garbage
  ///                 collection runs that have occurred over the last 10
  ///                 seconds. art.gc.gc-count-rate-histogram is a histogram of the gc-count-rate
  ///                 samples taken since the process began. The histogram can be used to identify
  ///                 instances of high rates of garbage collection runs. For example, a histogram
  ///                 of "0:34503,1:45350,2:11281,3:8088,4:43,5:8" shows that most of the time
  ///                 there are between 0 and 2 garbage collection runs every 10 seconds, but there
  ///                 were 8 distinct 10-second intervals in which 5 garbage collection runs
  ///                 occurred.</td>
  ///             <td>{@code 0:34503,1:45350,2:11281,3:8088,4:43,5:8}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>art.gc.blocking-gc-count-rate-histogram</td>
  ///             <td>Every 10 seconds, the blocking-gc-count-rate is computed as the number of
  ///                 blocking garbage collection runs that have occurred over the last 10
  ///                 seconds. art.gc.blocking-gc-count-rate-histogram is a histogram of the
  ///                 blocking-gc-count-rate samples taken since the process began. The histogram
  ///                 can be used to identify instances of high rates of blocking garbage
  ///                 collection runs. For example, a histogram of "0:99269,1:1,2:1" shows that
  ///                 most of the time there are zero blocking garbage collection runs every 10
  ///                 seconds, but there was one 10-second interval in which one blocking garbage
  ///                 collection run occurred, and there was one interval in which two blocking
  ///                 garbage collection runs occurred.</td>
  ///             <td>{@code 0:99269,1:1,2:1}</td>
  ///             <td>23</td>
  ///         </tr>
  ///     </tbody>
  /// </table>
  ///@param statName the name of the runtime statistic to look up.
  ///@return the value of the specified runtime statistic or {@code null} if the
  ///         runtime statistic doesn't exist.
  static jni.JlString getRuntimeStat(jni.JlString statName) =>
      jni.JlString.fromRef(_getRuntimeStat(statName.reference));

  static final _getRuntimeStats =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Debug_getRuntimeStats")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public java.util.Map<java.lang.String,java.lang.String> getRuntimeStats()
  /// Returns a map of the names/values of the runtime statistics
  /// that \#getRuntimeStat(String) supports.
  ///@return a map of the names/values of the supported runtime statistics.
  static jni.JlObject getRuntimeStats() =>
      jni.JlObject.fromRef(_getRuntimeStats());

  static final _getNativeHeapSize =
      jlookup<ffi.NativeFunction<ffi.Int64 Function()>>(
              "android_os_Debug_getNativeHeapSize")
          .asFunction<int Function()>();

  /// from: static public native long getNativeHeapSize()
  /// Returns the size of the native heap.
  ///@return The size of the native heap in bytes.
  static int getNativeHeapSize() => _getNativeHeapSize();

  static final _getNativeHeapAllocatedSize =
      jlookup<ffi.NativeFunction<ffi.Int64 Function()>>(
              "android_os_Debug_getNativeHeapAllocatedSize")
          .asFunction<int Function()>();

  /// from: static public native long getNativeHeapAllocatedSize()
  /// Returns the amount of allocated memory in the native heap.
  ///@return The allocated size in bytes.
  static int getNativeHeapAllocatedSize() => _getNativeHeapAllocatedSize();

  static final _getNativeHeapFreeSize =
      jlookup<ffi.NativeFunction<ffi.Int64 Function()>>(
              "android_os_Debug_getNativeHeapFreeSize")
          .asFunction<int Function()>();

  /// from: static public native long getNativeHeapFreeSize()
  /// Returns the amount of free memory in the native heap.
  ///@return The freed size in bytes.
  static int getNativeHeapFreeSize() => _getNativeHeapFreeSize();

  static final _getMemoryInfo =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Debug_getMemoryInfo")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public native void getMemoryInfo(android.os.Debug.MemoryInfo memoryInfo)
  /// Retrieves information about this processes memory usages. This information is broken down by
  /// how much is in use by dalvik, the native heap, and everything else.
  ///
  /// __Note:__ this method directly retrieves memory information for the given process
  /// from low-level data available to it.  It may not be able to retrieve information about
  /// some protected allocations, such as graphics.  If you want to be sure you can see
  /// all information about allocations by the process, use
  /// android.app.ActivityManager\#getProcessMemoryInfo(int[]) instead.
  ///
  static void getMemoryInfo(Debug_MemoryInfo memoryInfo) =>
      _getMemoryInfo(memoryInfo.reference);

  static final _getPss = jlookup<ffi.NativeFunction<ffi.Int64 Function()>>(
          "android_os_Debug_getPss")
      .asFunction<int Function()>();

  /// from: static public native long getPss()
  /// Retrieves the PSS memory used by the process as given by the
  /// smaps.
  static int getPss() => _getPss();

  static final _setAllocationLimit =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
              "android_os_Debug_setAllocationLimit")
          .asFunction<int Function(int)>();

  /// from: static public int setAllocationLimit(int limit)
  /// Establish an object allocation limit in the current thread.
  /// This feature was never enabled in release builds.  The
  /// allocation limits feature was removed in Honeycomb.  This
  /// method exists for compatibility and always returns -1 and has
  /// no effect.
  ///@deprecated This method is now obsolete.
  static int setAllocationLimit(int limit) => _setAllocationLimit(limit);

  static final _setGlobalAllocationLimit =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
              "android_os_Debug_setGlobalAllocationLimit")
          .asFunction<int Function(int)>();

  /// from: static public int setGlobalAllocationLimit(int limit)
  /// Establish a global object allocation limit.  This feature was
  /// never enabled in release builds.  The allocation limits feature
  /// was removed in Honeycomb.  This method exists for compatibility
  /// and always returns -1 and has no effect.
  ///@deprecated This method is now obsolete.
  static int setGlobalAllocationLimit(int limit) =>
      _setGlobalAllocationLimit(limit);

  static final _printLoadedClasses =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
              "android_os_Debug_printLoadedClasses")
          .asFunction<void Function(int)>();

  /// from: static public void printLoadedClasses(int flags)
  /// Dump a list of all currently loaded class to the log file.
  ///@param flags See constants above.
  static void printLoadedClasses(int flags) => _printLoadedClasses(flags);

  static final _getLoadedClassCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getLoadedClassCount")
          .asFunction<int Function()>();

  /// from: static public int getLoadedClassCount()
  /// Get the number of loaded classes.
  ///@return the number of loaded classes.
  static int getLoadedClassCount() => _getLoadedClassCount();

  static final _dumpHprofData =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Debug_dumpHprofData")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void dumpHprofData(java.lang.String fileName)
  /// Dump "hprof" data to the specified file.  This may cause a GC.
  ///@param fileName Full pathname of output file (e.g. "/sdcard/dump.hprof").
  ///@throws UnsupportedOperationException if the VM was built without
  ///         HPROF support.
  ///@throws IOException if an error occurs while opening or writing files.
  static void dumpHprofData(jni.JlString fileName) =>
      _dumpHprofData(fileName.reference);

  static final _getBinderSentTransactions =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getBinderSentTransactions")
          .asFunction<int Function()>();

  /// from: static public native int getBinderSentTransactions()
  /// Returns the number of sent transactions from this process.
  ///@return The number of sent transactions or -1 if it could not read t.
  static int getBinderSentTransactions() => _getBinderSentTransactions();

  static final _getBinderReceivedTransactions =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getBinderReceivedTransactions")
          .asFunction<int Function()>();

  /// from: static public native int getBinderReceivedTransactions()
  /// Returns the number of received transactions from the binder driver.
  ///@return The number of received transactions or -1 if it could not read the stats.
  static int getBinderReceivedTransactions() =>
      _getBinderReceivedTransactions();

  static final _getBinderLocalObjectCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getBinderLocalObjectCount")
          .asFunction<int Function()>();

  /// from: static public native int getBinderLocalObjectCount()
  /// Returns the number of active local Binder objects that exist in the
  /// current process.
  static int getBinderLocalObjectCount() => _getBinderLocalObjectCount();

  static final _getBinderProxyObjectCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getBinderProxyObjectCount")
          .asFunction<int Function()>();

  /// from: static public native int getBinderProxyObjectCount()
  /// Returns the number of references to remote proxy Binder objects that
  /// exist in the current process.
  static int getBinderProxyObjectCount() => _getBinderProxyObjectCount();

  static final _getBinderDeathObjectCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Debug_getBinderDeathObjectCount")
          .asFunction<int Function()>();

  /// from: static public native int getBinderDeathObjectCount()
  /// Returns the number of death notification links to Binder objects that
  /// exist in the current process.
  static int getBinderDeathObjectCount() => _getBinderDeathObjectCount();

  static final _dumpService = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Debug_dumpService")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean dumpService(java.lang.String name, java.io.FileDescriptor fd, java.lang.String[] args)
  /// Get a debugging dump of a system service by name.
  ///
  /// Most services require the caller to hold android.permission.DUMP.
  ///@param name of the service to dump
  ///@param fd to write dump output to (usually an output log file)
  ///@param args to pass to the service's dump method, may be null
  ///@return true if the service was dumped successfully, false if
  ///     the service could not be found or had an error while dumping
  static bool dumpService(
          jni.JlString name, jni.JlObject fd, jni.JlObject args) =>
      _dumpService(name.reference, fd.reference, args.reference) != 0;

  static final _attachJvmtiAgent = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Debug_attachJvmtiAgent")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void attachJvmtiAgent(java.lang.String library, java.lang.String options, java.lang.ClassLoader classLoader)
  /// Attach a library as a jvmti agent to the current runtime, with the given classloader
  /// determining the library search path.
  ///
  /// Note: agents may only be attached to debuggable apps. Otherwise, this function will
  /// throw a SecurityException.
  ///@param library the library containing the agent.
  /// This value must never be {@code null}.
  ///@param options the options passed to the agent.
  /// This value may be {@code null}.
  ///@param classLoader the classloader determining the library search path.
  ///
  /// This value may be {@code null}.
  ///@throws IOException if the agent could not be attached.
  ///@throws SecurityException if the app is not debuggable.
  static void attachJvmtiAgent(jni.JlString library_, jni.JlString options,
          jni.JlObject classLoader) =>
      _attachJvmtiAgent(
          library_.reference, options.reference, classLoader.reference);
}

/// This class is used to retrieved various statistics about the memory mappings for this
/// process. The returned info is broken down by dalvik, native, and other. All results are in kB.
class Debug_MemoryInfo extends jni.JlObject {
  Debug_MemoryInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.os.Debug.MemoryInfo> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Debug__MemoryInfo_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static Parcelable_Creator get CREATOR =>
      Parcelable_Creator.fromRef(_getCREATOR());

  /// from: public int dalvikPrivateDirty
  /// The private dirty pages used by dalvik heap.
  static final _getdalvikPrivateDirty = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_os_Debug__MemoryInfo_dalvikPrivateDirty")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get dalvikPrivateDirty => _getdalvikPrivateDirty(reference);
  static final _setdalvikPrivateDirty = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_os_Debug__MemoryInfo_dalvikPrivateDirty")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set dalvikPrivateDirty(int value) => _setdalvikPrivateDirty(reference, value);

  /// from: public int dalvikPss
  /// The proportional set size for dalvik heap.  (Doesn't include other Dalvik overhead.)
  static final _getdalvikPss = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_os_Debug__MemoryInfo_dalvikPss")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get dalvikPss => _getdalvikPss(reference);
  static final _setdalvikPss = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_os_Debug__MemoryInfo_dalvikPss")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set dalvikPss(int value) => _setdalvikPss(reference, value);

  /// from: public int dalvikSharedDirty
  /// The shared dirty pages used by dalvik heap.
  static final _getdalvikSharedDirty = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_os_Debug__MemoryInfo_dalvikSharedDirty")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get dalvikSharedDirty => _getdalvikSharedDirty(reference);
  static final _setdalvikSharedDirty = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_os_Debug__MemoryInfo_dalvikSharedDirty")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set dalvikSharedDirty(int value) => _setdalvikSharedDirty(reference, value);

  /// from: public int nativePrivateDirty
  /// The private dirty pages used by the native heap.
  static final _getnativePrivateDirty = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_os_Debug__MemoryInfo_nativePrivateDirty")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get nativePrivateDirty => _getnativePrivateDirty(reference);
  static final _setnativePrivateDirty = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_os_Debug__MemoryInfo_nativePrivateDirty")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set nativePrivateDirty(int value) => _setnativePrivateDirty(reference, value);

  /// from: public int nativePss
  /// The proportional set size for the native heap.
  static final _getnativePss = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_os_Debug__MemoryInfo_nativePss")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get nativePss => _getnativePss(reference);
  static final _setnativePss = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_os_Debug__MemoryInfo_nativePss")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set nativePss(int value) => _setnativePss(reference, value);

  /// from: public int nativeSharedDirty
  /// The shared dirty pages used by the native heap.
  static final _getnativeSharedDirty = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_os_Debug__MemoryInfo_nativeSharedDirty")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get nativeSharedDirty => _getnativeSharedDirty(reference);
  static final _setnativeSharedDirty = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_os_Debug__MemoryInfo_nativeSharedDirty")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set nativeSharedDirty(int value) => _setnativeSharedDirty(reference, value);

  /// from: public int otherPrivateDirty
  /// The private dirty pages used by everything else.
  static final _getotherPrivateDirty = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_os_Debug__MemoryInfo_otherPrivateDirty")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get otherPrivateDirty => _getotherPrivateDirty(reference);
  static final _setotherPrivateDirty = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_os_Debug__MemoryInfo_otherPrivateDirty")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set otherPrivateDirty(int value) => _setotherPrivateDirty(reference, value);

  /// from: public int otherPss
  /// The proportional set size for everything else.
  static final _getotherPss = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_os_Debug__MemoryInfo_otherPss")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get otherPss => _getotherPss(reference);
  static final _setotherPss = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("set_android_os_Debug__MemoryInfo_otherPss")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set otherPss(int value) => _setotherPss(reference, value);

  /// from: public int otherSharedDirty
  /// The shared dirty pages used by everything else.
  static final _getotherSharedDirty = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
    ffi.Pointer<ffi.Void>,
  )>>("get_android_os_Debug__MemoryInfo_otherSharedDirty")
      .asFunction<
          int Function(
    ffi.Pointer<ffi.Void>,
  )>();
  int get otherSharedDirty => _getotherSharedDirty(reference);
  static final _setotherSharedDirty = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "set_android_os_Debug__MemoryInfo_otherSharedDirty")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();
  set otherSharedDirty(int value) => _setotherSharedDirty(reference, value);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Debug__MemoryInfo_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Debug_MemoryInfo() : super.fromRef(_ctor());

  static final _getTotalPss =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Debug__MemoryInfo_getTotalPss")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getTotalPss()
  /// Return total PSS memory usage in kB.
  int getTotalPss() => _getTotalPss(reference);

  static final _getTotalSwappablePss =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Debug__MemoryInfo_getTotalSwappablePss")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getTotalSwappablePss()
  /// Return total PSS memory usage in kB mapping a file of one of the following extension:
  /// .so, .jar, .apk, .ttf, .dex, .odex, .oat, .art .
  int getTotalSwappablePss() => _getTotalSwappablePss(reference);

  static final _getTotalPrivateDirty =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Debug__MemoryInfo_getTotalPrivateDirty")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getTotalPrivateDirty()
  /// Return total private dirty memory usage in kB.
  int getTotalPrivateDirty() => _getTotalPrivateDirty(reference);

  static final _getTotalSharedDirty =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Debug__MemoryInfo_getTotalSharedDirty")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getTotalSharedDirty()
  /// Return total shared dirty memory usage in kB.
  int getTotalSharedDirty() => _getTotalSharedDirty(reference);

  static final _getTotalPrivateClean =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Debug__MemoryInfo_getTotalPrivateClean")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getTotalPrivateClean()
  /// Return total shared clean memory usage in kB.
  int getTotalPrivateClean() => _getTotalPrivateClean(reference);

  static final _getTotalSharedClean =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Debug__MemoryInfo_getTotalSharedClean")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getTotalSharedClean()
  /// Return total shared clean memory usage in kB.
  int getTotalSharedClean() => _getTotalSharedClean(reference);

  static final _getMemoryStat = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Debug__MemoryInfo_getMemoryStat")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getMemoryStat(java.lang.String statName)
  /// Returns the value of a particular memory statistic or {@code null} if no
  /// such memory statistic exists.
  ///
  /// The following table lists the memory statistics that are supported.
  /// Note that memory statistics may be added or removed in a future API level.
  ///
  ///
  /// <table>
  ///     <thead>
  ///         <tr>
  ///             <th>Memory statistic name</th>
  ///             <th>Meaning</th>
  ///             <th>Example</th>
  ///             <th>Supported (API Levels)</th>
  ///         </tr>
  ///     </thead>
  ///     <tbody>
  ///         <tr>
  ///             <td>summary.java-heap</td>
  ///             <td>The private Java Heap usage in kB. This corresponds to the Java Heap field
  ///                 in the App Summary section output by dumpsys meminfo.</td>
  ///             <td>{@code 1442}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>summary.native-heap</td>
  ///             <td>The private Native Heap usage in kB. This corresponds to the Native Heap
  ///                 field in the App Summary section output by dumpsys meminfo.</td>
  ///             <td>{@code 1442}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>summary.code</td>
  ///             <td>The memory usage for static code and resources in kB. This corresponds to
  ///                 the Code field in the App Summary section output by dumpsys meminfo.</td>
  ///             <td>{@code 1442}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>summary.stack</td>
  ///             <td>The stack usage in kB. This corresponds to the Stack field in the
  ///                 App Summary section output by dumpsys meminfo.</td>
  ///             <td>{@code 1442}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>summary.graphics</td>
  ///             <td>The graphics usage in kB. This corresponds to the Graphics field in the
  ///                 App Summary section output by dumpsys meminfo.</td>
  ///             <td>{@code 1442}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>summary.private-other</td>
  ///             <td>Other private memory usage in kB. This corresponds to the Private Other
  ///                 field output in the App Summary section by dumpsys meminfo.</td>
  ///             <td>{@code 1442}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>summary.system</td>
  ///             <td>Shared and system memory usage in kB. This corresponds to the System
  ///                 field output in the App Summary section by dumpsys meminfo.</td>
  ///             <td>{@code 1442}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>summary.total-pss</td>
  ///             <td>Total PPS memory usage in kB.</td>
  ///             <td>{@code 1442}</td>
  ///             <td>23</td>
  ///         </tr>
  ///         <tr>
  ///             <td>summary.total-swap</td>
  ///             <td>Total swap usage in kB.</td>
  ///             <td>{@code 1442}</td>
  ///             <td>23</td>
  ///         </tr>
  ///     </tbody>
  /// </table>
  jni.JlString getMemoryStat(jni.JlString statName) =>
      jni.JlString.fromRef(_getMemoryStat(reference, statName.reference));

  static final _getMemoryStats = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_Debug__MemoryInfo_getMemoryStats")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Map<java.lang.String,java.lang.String> getMemoryStats()
  /// Returns a map of the names/values of the memory statistics
  /// that \#getMemoryStat(String) supports.
  ///@return a map of the names/values of the supported memory statistics.
  jni.JlObject getMemoryStats() =>
      jni.JlObject.fromRef(_getMemoryStats(reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Debug__MemoryInfo_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Debug__MemoryInfo_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags);

  static final _readFromParcel = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Debug__MemoryInfo_readFromParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(Parcel source) =>
      _readFromParcel(reference, source.reference);
}

/// API for gathering and querying instruction counts.
///
/// Example usage:
/// <pre>
///   Debug.InstructionCount icount = new Debug.InstructionCount();
///   icount.resetAndStart();
///    [... do lots of stuff ...]
///   if (icount.collect()) {
///       System.out.println("Total instructions executed: "
///           + icount.globalTotal());
///       System.out.println("Method invocations: "
///           + icount.globalMethodInvocations());
///   }
/// </pre>
///@deprecated Instruction counting is no longer supported.
class Debug_InstructionCount extends jni.JlObject {
  Debug_InstructionCount.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Debug__InstructionCount_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Debug_InstructionCount() : super.fromRef(_ctor());

  static final _resetAndStart =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Debug__InstructionCount_resetAndStart")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean resetAndStart()
  /// Reset counters and ensure counts are running.  Counts may
  /// have already been running.
  ///@return true if counting was started
  bool resetAndStart() => _resetAndStart(reference) != 0;

  static final _collect =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Debug__InstructionCount_collect")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean collect()
  /// Collect instruction counts.  May or may not stop the
  /// counting process.
  bool collect() => _collect(reference) != 0;

  static final _globalTotal =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Debug__InstructionCount_globalTotal")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int globalTotal()
  /// Return the total number of instructions executed globally (i.e. in
  /// all threads).
  int globalTotal() => _globalTotal(reference);

  static final _globalMethodInvocations =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Debug__InstructionCount_globalMethodInvocations")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int globalMethodInvocations()
  /// Return the total number of method-invocation instructions
  /// executed globally.
  int globalMethodInvocations() => _globalMethodInvocations(reference);
}

/// A mapping from String keys to various Parcelable values.
///@see PersistableBundle
class Bundle extends BaseBundle {
  Bundle.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.os.Bundle> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Bundle_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static Parcelable_Creator get CREATOR =>
      Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final android.os.Bundle EMPTY
  static final _getEMPTY =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Bundle_EMPTY")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static Bundle get EMPTY => Bundle.fromRef(_getEMPTY());

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Bundle_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Constructs a new, empty Bundle.
  Bundle() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.ClassLoader loader)
  /// Constructs a new, empty Bundle that uses a specific ClassLoader for
  /// instantiating Parcelable and Serializable objects.
  ///@param loader An explicit ClassLoader to use when instantiating objects
  /// inside of the Bundle.
  Bundle.ctor_1(jni.JlObject loader) : super.fromRef(_ctor_1(loader.reference));

  static final _ctor_2 =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int32)>>(
              "android_os_Bundle_new_2")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: public void <init>(int capacity)
  /// Constructs a new, empty Bundle sized to hold the given number of
  /// elements. The Bundle will grow as needed.
  ///@param capacity the initial capacity of the Bundle
  Bundle.ctor_2(int capacity) : super.fromRef(_ctor_2(capacity));

  static final _ctor_3 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_new_3")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Bundle b)
  /// Constructs a Bundle containing a copy of the mappings from the given
  /// Bundle.  Does only a shallow copy of the original Bundle -- see
  /// \#deepCopy() if that is not what you want.
  ///@param b a Bundle to be copied.
  ///@see \#deepCopy()
  Bundle.ctor_3(Bundle b) : super.fromRef(_ctor_3(b.reference));

  static final _ctor_4 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_new_4")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.PersistableBundle b)
  /// Constructs a Bundle containing a copy of the mappings from the given
  /// PersistableBundle.  Does only a shallow copy of the PersistableBundle -- see
  /// PersistableBundle\#deepCopy() if you don't want that.
  ///@param b a PersistableBundle to be copied.
  Bundle.ctor_4(PersistableBundle b) : super.fromRef(_ctor_4(b.reference));

  static final _setClassLoader = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_setClassLoader")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setClassLoader(java.lang.ClassLoader loader)
  /// Changes the ClassLoader this Bundle uses when instantiating objects.
  ///@param loader An explicit ClassLoader to use when instantiating objects
  /// inside of the Bundle.
  void setClassLoader(jni.JlObject loader) =>
      _setClassLoader(reference, loader.reference);

  static final _getClassLoader = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_getClassLoader")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.ClassLoader getClassLoader()
  /// Return the ClassLoader currently associated with this Bundle.
  jni.JlObject getClassLoader() =>
      jni.JlObject.fromRef(_getClassLoader(reference));

  static final _clone = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_clone")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object clone()
  /// Clones the current Bundle. The internal map is cloned, but the keys and
  /// values to which it refers are copied by reference.
  jni.JlObject clone() => jni.JlObject.fromRef(_clone(reference));

  static final _deepCopy = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_deepCopy")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle deepCopy()
  /// Make a deep copy of the given bundle.  Traverses into inner containers and copies
  /// them as well, so they are not shared across bundles.  Will traverse in to
  /// Bundle, PersistableBundle, ArrayList, and all types of
  /// primitive arrays.  Other types of objects (such as Parcelable or Serializable)
  /// are referenced as-is and not copied in any way.
  Bundle deepCopy() => Bundle.fromRef(_deepCopy(reference));

  static final _clear =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Bundle_clear")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void clear()
  /// Removes all elements from the mapping of this Bundle.
  void clear() => _clear(reference);

  static final _remove = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_remove")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void remove(java.lang.String key)
  /// Removes any entry with the given key from the mapping of this Bundle.
  ///@param key a String key
  void remove(jni.JlString key) => _remove(reference, key.reference);

  static final _putAll = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_putAll")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void putAll(android.os.Bundle bundle)
  /// Inserts all mappings from the given Bundle into this Bundle.
  ///@param bundle a Bundle
  void putAll(Bundle bundle) => _putAll(reference, bundle.reference);

  static final _hasFileDescriptors =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Bundle_hasFileDescriptors")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasFileDescriptors()
  /// Reports whether the bundle contains any parcelled file descriptors.
  bool hasFileDescriptors() => _hasFileDescriptors(reference) != 0;

  static final _putByte = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int8)>>("android_os_Bundle_putByte")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void putByte(java.lang.String key, byte value)
  /// Inserts a byte value into the mapping of this Bundle, replacing
  /// any existing value for the given key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a byte
  void putByte(jni.JlString key, int value) =>
      _putByte(reference, key.reference, value);

  static final _putChar = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int16)>>("android_os_Bundle_putChar")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void putChar(java.lang.String key, char value)
  /// Inserts a char value into the mapping of this Bundle, replacing
  /// any existing value for the given key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a char
  void putChar(jni.JlString key, int value) =>
      _putChar(reference, key.reference, value);

  static final _putShort = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int16)>>("android_os_Bundle_putShort")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void putShort(java.lang.String key, short value)
  /// Inserts a short value into the mapping of this Bundle, replacing
  /// any existing value for the given key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a short
  void putShort(jni.JlString key, int value) =>
      _putShort(reference, key.reference, value);

  static final _putFloat = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("android_os_Bundle_putFloat")
      .asFunction<
          void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, double)>();

  /// from: public void putFloat(java.lang.String key, float value)
  /// Inserts a float value into the mapping of this Bundle, replacing
  /// any existing value for the given key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a float
  void putFloat(jni.JlString key, double value) =>
      _putFloat(reference, key.reference, value);

  static final _putCharSequence = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_putCharSequence")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putCharSequence(java.lang.String key, java.lang.CharSequence value)
  /// Inserts a CharSequence value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a CharSequence, or null
  ///
  /// This value may be {@code null}.
  void putCharSequence(jni.JlString key, jni.JlObject value) =>
      _putCharSequence(reference, key.reference, value.reference);

  static final _putParcelable = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_putParcelable")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putParcelable(java.lang.String key, android.os.Parcelable value)
  /// Inserts a Parcelable value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a Parcelable object, or null
  ///
  /// This value may be {@code null}.
  void putParcelable(jni.JlString key, Parcelable value) =>
      _putParcelable(reference, key.reference, value.reference);

  static final _putSize = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_putSize")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putSize(java.lang.String key, android.util.Size value)
  /// Inserts a Size value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a Size object, or null
  ///
  /// This value may be {@code null}.
  void putSize(jni.JlString key, jni.JlObject value) =>
      _putSize(reference, key.reference, value.reference);

  static final _putSizeF = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_putSizeF")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putSizeF(java.lang.String key, android.util.SizeF value)
  /// Inserts a SizeF value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a SizeF object, or null
  ///
  /// This value may be {@code null}.
  void putSizeF(jni.JlString key, jni.JlObject value) =>
      _putSizeF(reference, key.reference, value.reference);

  static final _putParcelableArray = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Bundle_putParcelableArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putParcelableArray(java.lang.String key, android.os.Parcelable[] value)
  /// Inserts an array of Parcelable values into the mapping of this Bundle,
  /// replacing any existing value for the given key.  Either key or value may
  /// be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value an array of Parcelable objects, or null
  ///
  /// This value may be {@code null}.
  void putParcelableArray(jni.JlString key, jni.JlObject value) =>
      _putParcelableArray(reference, key.reference, value.reference);

  static final _putParcelableArrayList = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Bundle_putParcelableArrayList")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putParcelableArrayList(java.lang.String key, java.util.ArrayList<? extends android.os.Parcelable> value)
  /// Inserts a List of Parcelable values into the mapping of this Bundle,
  /// replacing any existing value for the given key.  Either key or value may
  /// be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value an ArrayList of Parcelable objects, or null
  ///
  /// This value may be {@code null}.
  void putParcelableArrayList(jni.JlString key, jni.JlObject value) =>
      _putParcelableArrayList(reference, key.reference, value.reference);

  static final _putSparseParcelableArray = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Bundle_putSparseParcelableArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putSparseParcelableArray(java.lang.String key, android.util.SparseArray<? extends android.os.Parcelable> value)
  /// Inserts a SparceArray of Parcelable values into the mapping of this
  /// Bundle, replacing any existing value for the given key.  Either key
  /// or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a SparseArray of Parcelable objects, or null
  ///
  /// This value may be {@code null}.
  void putSparseParcelableArray(jni.JlString key, jni.JlObject value) =>
      _putSparseParcelableArray(reference, key.reference, value.reference);

  static final _putIntegerArrayList = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Bundle_putIntegerArrayList")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putIntegerArrayList(java.lang.String key, java.util.ArrayList<java.lang.Integer> value)
  /// Inserts an ArrayList<Integer> value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value an ArrayList<Integer> object, or null
  ///
  /// This value may be {@code null}.
  void putIntegerArrayList(jni.JlString key, jni.JlObject value) =>
      _putIntegerArrayList(reference, key.reference, value.reference);

  static final _putStringArrayList = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Bundle_putStringArrayList")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putStringArrayList(java.lang.String key, java.util.ArrayList<java.lang.String> value)
  /// Inserts an ArrayList<String> value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value an ArrayList<String> object, or null
  ///
  /// This value may be {@code null}.
  void putStringArrayList(jni.JlString key, jni.JlObject value) =>
      _putStringArrayList(reference, key.reference, value.reference);

  static final _putCharSequenceArrayList = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Bundle_putCharSequenceArrayList")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putCharSequenceArrayList(java.lang.String key, java.util.ArrayList<java.lang.CharSequence> value)
  /// Inserts an ArrayList<CharSequence> value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value an ArrayList<CharSequence> object, or null
  ///
  /// This value may be {@code null}.
  void putCharSequenceArrayList(jni.JlString key, jni.JlObject value) =>
      _putCharSequenceArrayList(reference, key.reference, value.reference);

  static final _putSerializable = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_putSerializable")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putSerializable(java.lang.String key, java.io.Serializable value)
  /// Inserts a Serializable value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a Serializable object, or null
  ///
  /// This value may be {@code null}.
  void putSerializable(jni.JlString key, jni.JlObject value) =>
      _putSerializable(reference, key.reference, value.reference);

  static final _putByteArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_putByteArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putByteArray(java.lang.String key, byte[] value)
  /// Inserts a byte array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a byte array object, or null
  ///
  /// This value may be {@code null}.
  void putByteArray(jni.JlString key, jni.JlObject value) =>
      _putByteArray(reference, key.reference, value.reference);

  static final _putShortArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_putShortArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putShortArray(java.lang.String key, short[] value)
  /// Inserts a short array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a short array object, or null
  ///
  /// This value may be {@code null}.
  void putShortArray(jni.JlString key, jni.JlObject value) =>
      _putShortArray(reference, key.reference, value.reference);

  static final _putCharArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_putCharArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putCharArray(java.lang.String key, char[] value)
  /// Inserts a char array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a char array object, or null
  ///
  /// This value may be {@code null}.
  void putCharArray(jni.JlString key, jni.JlObject value) =>
      _putCharArray(reference, key.reference, value.reference);

  static final _putFloatArray = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_putFloatArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putFloatArray(java.lang.String key, float[] value)
  /// Inserts a float array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a float array object, or null
  ///
  /// This value may be {@code null}.
  void putFloatArray(jni.JlString key, jni.JlObject value) =>
      _putFloatArray(reference, key.reference, value.reference);

  static final _putCharSequenceArray = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Bundle_putCharSequenceArray")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putCharSequenceArray(java.lang.String key, java.lang.CharSequence[] value)
  /// Inserts a CharSequence array value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a CharSequence array object, or null
  ///
  /// This value may be {@code null}.
  void putCharSequenceArray(jni.JlString key, jni.JlObject value) =>
      _putCharSequenceArray(reference, key.reference, value.reference);

  static final _putBundle = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_putBundle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putBundle(java.lang.String key, android.os.Bundle value)
  /// Inserts a Bundle value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a Bundle object, or null
  ///
  /// This value may be {@code null}.
  void putBundle(jni.JlString key, Bundle value) =>
      _putBundle(reference, key.reference, value.reference);

  static final _putBinder = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_putBinder")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putBinder(java.lang.String key, android.os.IBinder value)
  /// Inserts an IBinder value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///
  /// <p class="note">You should be very careful when using this function.  In many
  /// places where Bundles are used (such as inside of Intent objects), the Bundle
  /// can live longer inside of another process than the process that had originally
  /// created it.  In that case, the IBinder you supply here will become invalid
  /// when your process goes away, and no longer usable, even if a new process is
  /// created for you later on.
  ///
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value an IBinder object, or null
  ///
  /// This value may be {@code null}.
  void putBinder(jni.JlString key, IBinder value) =>
      _putBinder(reference, key.reference, value.reference);

  static final _getByte = jlookup<
          ffi.NativeFunction<
              ffi.Int8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_getByte")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public byte getByte(java.lang.String key)
  /// Returns the value associated with the given key, or (byte) 0 if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@return a byte value
  int getByte(jni.JlString key) => _getByte(reference, key.reference);

  static final _getByte_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int8)>>("android_os_Bundle_getByte_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.Byte getByte(java.lang.String key, byte defaultValue)
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@param defaultValue Value to return if key does not exist
  ///@return a byte value
  jni.JlObject getByte_1(jni.JlString key, int defaultValue) =>
      jni.JlObject.fromRef(_getByte_1(reference, key.reference, defaultValue));

  static final _getChar = jlookup<
          ffi.NativeFunction<
              ffi.Int16 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_getChar")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public char getChar(java.lang.String key)
  /// Returns the value associated with the given key, or (char) 0 if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@return a char value
  int getChar(jni.JlString key) => _getChar(reference, key.reference);

  static final _getChar_1 = jlookup<
          ffi.NativeFunction<
              ffi.Int16 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int16)>>("android_os_Bundle_getChar_1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public char getChar(java.lang.String key, char defaultValue)
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@param defaultValue Value to return if key does not exist
  ///@return a char value
  int getChar_1(jni.JlString key, int defaultValue) =>
      _getChar_1(reference, key.reference, defaultValue);

  static final _getShort = jlookup<
          ffi.NativeFunction<
              ffi.Int16 Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_getShort")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public short getShort(java.lang.String key)
  /// Returns the value associated with the given key, or (short) 0 if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@return a short value
  int getShort(jni.JlString key) => _getShort(reference, key.reference);

  static final _getShort_1 = jlookup<
          ffi.NativeFunction<
              ffi.Int16 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int16)>>("android_os_Bundle_getShort_1")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public short getShort(java.lang.String key, short defaultValue)
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@param defaultValue Value to return if key does not exist
  ///@return a short value
  int getShort_1(jni.JlString key, int defaultValue) =>
      _getShort_1(reference, key.reference, defaultValue);

  static final _getFloat = jlookup<
          ffi.NativeFunction<
              ffi.Float Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_getFloat")
      .asFunction<
          double Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public float getFloat(java.lang.String key)
  /// Returns the value associated with the given key, or 0.0f if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@return a float value
  double getFloat(jni.JlString key) => _getFloat(reference, key.reference);

  static final _getFloat_1 = jlookup<
          ffi.NativeFunction<
              ffi.Float Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("android_os_Bundle_getFloat_1")
      .asFunction<
          double Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, double)>();

  /// from: public float getFloat(java.lang.String key, float defaultValue)
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key.
  ///@param key a String
  ///@param defaultValue Value to return if key does not exist
  ///@return a float value
  double getFloat_1(jni.JlString key, double defaultValue) =>
      _getFloat_1(reference, key.reference, defaultValue);

  static final _getCharSequence = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_getCharSequence")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getCharSequence(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a CharSequence value, or null
  jni.JlObject getCharSequence(jni.JlString key) =>
      jni.JlObject.fromRef(_getCharSequence(reference, key.reference));

  static final _getCharSequence_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Bundle_getCharSequence_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getCharSequence(java.lang.String key, java.lang.CharSequence defaultValue)
  /// Returns the value associated with the given key, or defaultValue if
  /// no mapping of the desired type exists for the given key or if a null
  /// value is explicitly associatd with the given key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param defaultValue Value to return if key does not exist or if a null
  ///     value is associated with the given key.
  ///@return the CharSequence value associated with the given key, or defaultValue
  ///     if no valid CharSequence object is currently mapped to that key.
  jni.JlObject getCharSequence_1(jni.JlString key, jni.JlObject defaultValue) =>
      jni.JlObject.fromRef(
          _getCharSequence_1(reference, key.reference, defaultValue.reference));

  static final _getSize = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_getSize")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.util.Size getSize(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a Size value, or null
  jni.JlObject getSize(jni.JlString key) =>
      jni.JlObject.fromRef(_getSize(reference, key.reference));

  static final _getSizeF = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_getSizeF")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.util.SizeF getSizeF(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a Size value, or null
  jni.JlObject getSizeF(jni.JlString key) =>
      jni.JlObject.fromRef(_getSizeF(reference, key.reference));

  static final _getBundle = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_getBundle")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getBundle(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a Bundle value, or null
  Bundle getBundle(jni.JlString key) =>
      Bundle.fromRef(_getBundle(reference, key.reference));

  static final _getParcelableArray = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Bundle_getParcelableArray")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Parcelable[] getParcelableArray(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a Parcelable[] value, or null
  jni.JlObject getParcelableArray(jni.JlString key) =>
      jni.JlObject.fromRef(_getParcelableArray(reference, key.reference));

  static final _getParcelableArrayList = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Bundle_getParcelableArrayList")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.ArrayList<T> getParcelableArrayList(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return an ArrayList<T> value, or null
  jni.JlObject getParcelableArrayList(jni.JlString key) =>
      jni.JlObject.fromRef(_getParcelableArrayList(reference, key.reference));

  static final _getSparseParcelableArray = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Bundle_getSparseParcelableArray")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.util.SparseArray<T> getSparseParcelableArray(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  ///
  /// This value may be {@code null}.
  ///@return a SparseArray of T values, or null
  jni.JlObject getSparseParcelableArray(jni.JlString key) =>
      jni.JlObject.fromRef(_getSparseParcelableArray(reference, key.reference));

  static final _getSerializable = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_getSerializable")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.Serializable getSerializable(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a Serializable value, or null
  jni.JlObject getSerializable(jni.JlString key) =>
      jni.JlObject.fromRef(_getSerializable(reference, key.reference));

  static final _getIntegerArrayList = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Bundle_getIntegerArrayList")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.ArrayList<java.lang.Integer> getIntegerArrayList(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return an ArrayList<String> value, or null
  jni.JlObject getIntegerArrayList(jni.JlString key) =>
      jni.JlObject.fromRef(_getIntegerArrayList(reference, key.reference));

  static final _getStringArrayList = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Bundle_getStringArrayList")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.ArrayList<java.lang.String> getStringArrayList(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return an ArrayList<String> value, or null
  jni.JlObject getStringArrayList(jni.JlString key) =>
      jni.JlObject.fromRef(_getStringArrayList(reference, key.reference));

  static final _getCharSequenceArrayList = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Bundle_getCharSequenceArrayList")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.ArrayList<java.lang.CharSequence> getCharSequenceArrayList(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return an ArrayList<CharSequence> value, or null
  jni.JlObject getCharSequenceArrayList(jni.JlString key) =>
      jni.JlObject.fromRef(_getCharSequenceArrayList(reference, key.reference));

  static final _getByteArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_getByteArray")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public byte[] getByteArray(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a byte[] value, or null
  jni.JlObject getByteArray(jni.JlString key) =>
      jni.JlObject.fromRef(_getByteArray(reference, key.reference));

  static final _getShortArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_getShortArray")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public short[] getShortArray(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a short[] value, or null
  jni.JlObject getShortArray(jni.JlString key) =>
      jni.JlObject.fromRef(_getShortArray(reference, key.reference));

  static final _getCharArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_getCharArray")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public char[] getCharArray(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a char[] value, or null
  jni.JlObject getCharArray(jni.JlString key) =>
      jni.JlObject.fromRef(_getCharArray(reference, key.reference));

  static final _getFloatArray = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_getFloatArray")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public float[] getFloatArray(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a float[] value, or null
  jni.JlObject getFloatArray(jni.JlString key) =>
      jni.JlObject.fromRef(_getFloatArray(reference, key.reference));

  static final _getCharSequenceArray = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Bundle_getCharSequenceArray")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence[] getCharSequenceArray(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a CharSequence[] value, or null
  jni.JlObject getCharSequenceArray(jni.JlString key) =>
      jni.JlObject.fromRef(_getCharSequenceArray(reference, key.reference));

  static final _getBinder = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_getBinder")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.IBinder getBinder(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return an IBinder value, or null
  IBinder getBinder(jni.JlString key) =>
      IBinder.fromRef(_getBinder(reference, key.reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Bundle_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  /// Report the nature of this Parcelable's contents
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Bundle_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  /// Writes the Bundle contents to a Parcel, typically in order for
  /// it to be passed through an IBinder connection.
  ///@param parcel The parcel to copy this bundle to.
  void writeToParcel(Parcel parcel, int flags) =>
      _writeToParcel(reference, parcel.reference, flags);

  static final _readFromParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_readFromParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel parcel)
  /// Reads the Parcel contents into this Bundle, typically in order for
  /// it to be passed through an IBinder connection.
  ///@param parcel The parcel to overwrite this bundle from.
  void readFromParcel(Parcel parcel) =>
      _readFromParcel(reference, parcel.reference);

  static final _toString_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_Bundle_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: synchronized public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));
}

/// Provides access to environment variables.
class Environment extends jni.JlObject {
  Environment.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public java.lang.String DIRECTORY_ALARMS
  /// Standard directory in which to place any audio files that should be
  /// in the list of alarms that the user can select (not as regular
  /// music).
  /// This may be combined with \#DIRECTORY_MUSIC,
  /// \#DIRECTORY_PODCASTS, \#DIRECTORY_NOTIFICATIONS,
  /// and \#DIRECTORY_RINGTONES as a series
  /// of directories to categories a particular audio file as more than one
  /// type.
  static final _getDIRECTORY_ALARMS =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Environment_DIRECTORY_ALARMS")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get DIRECTORY_ALARMS =>
      jni.JlString.fromRef(_getDIRECTORY_ALARMS());
  static final _setDIRECTORY_ALARMS =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "set_android_os_Environment_DIRECTORY_ALARMS")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();
  static set DIRECTORY_ALARMS(jni.JlString value) =>
      _setDIRECTORY_ALARMS(value.reference);

  /// from: static public java.lang.String DIRECTORY_DCIM
  /// The traditional location for pictures and videos when mounting the
  /// device as a camera.  Note that this is primarily a convention for the
  /// top-level public directory, as this convention makes no sense elsewhere.
  static final _getDIRECTORY_DCIM =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Environment_DIRECTORY_DCIM")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get DIRECTORY_DCIM =>
      jni.JlString.fromRef(_getDIRECTORY_DCIM());
  static final _setDIRECTORY_DCIM =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "set_android_os_Environment_DIRECTORY_DCIM")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();
  static set DIRECTORY_DCIM(jni.JlString value) =>
      _setDIRECTORY_DCIM(value.reference);

  /// from: static public java.lang.String DIRECTORY_DOCUMENTS
  /// Standard directory in which to place documents that have been created by
  /// the user.
  static final _getDIRECTORY_DOCUMENTS =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Environment_DIRECTORY_DOCUMENTS")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get DIRECTORY_DOCUMENTS =>
      jni.JlString.fromRef(_getDIRECTORY_DOCUMENTS());
  static final _setDIRECTORY_DOCUMENTS =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "set_android_os_Environment_DIRECTORY_DOCUMENTS")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();
  static set DIRECTORY_DOCUMENTS(jni.JlString value) =>
      _setDIRECTORY_DOCUMENTS(value.reference);

  /// from: static public java.lang.String DIRECTORY_DOWNLOADS
  /// Standard directory in which to place files that have been downloaded by
  /// the user.  Note that this is primarily a convention for the top-level
  /// public directory, you are free to download files anywhere in your own
  /// private directories.  Also note that though the constant here is
  /// named DIRECTORY_DOWNLOADS (plural), the actual file name is non-plural for
  /// backwards compatibility reasons.
  static final _getDIRECTORY_DOWNLOADS =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Environment_DIRECTORY_DOWNLOADS")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get DIRECTORY_DOWNLOADS =>
      jni.JlString.fromRef(_getDIRECTORY_DOWNLOADS());
  static final _setDIRECTORY_DOWNLOADS =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "set_android_os_Environment_DIRECTORY_DOWNLOADS")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();
  static set DIRECTORY_DOWNLOADS(jni.JlString value) =>
      _setDIRECTORY_DOWNLOADS(value.reference);

  /// from: static public java.lang.String DIRECTORY_MOVIES
  /// Standard directory in which to place movies that are available to
  /// the user.  Note that this is primarily a convention for the top-level
  /// public directory, as the media scanner will find and collect movies
  /// in any directory.
  static final _getDIRECTORY_MOVIES =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Environment_DIRECTORY_MOVIES")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get DIRECTORY_MOVIES =>
      jni.JlString.fromRef(_getDIRECTORY_MOVIES());
  static final _setDIRECTORY_MOVIES =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "set_android_os_Environment_DIRECTORY_MOVIES")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();
  static set DIRECTORY_MOVIES(jni.JlString value) =>
      _setDIRECTORY_MOVIES(value.reference);

  /// from: static public java.lang.String DIRECTORY_MUSIC
  /// Standard directory in which to place any audio files that should be
  /// in the regular list of music for the user.
  /// This may be combined with
  /// \#DIRECTORY_PODCASTS, \#DIRECTORY_NOTIFICATIONS,
  /// \#DIRECTORY_ALARMS, and \#DIRECTORY_RINGTONES as a series
  /// of directories to categories a particular audio file as more than one
  /// type.
  static final _getDIRECTORY_MUSIC =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Environment_DIRECTORY_MUSIC")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get DIRECTORY_MUSIC =>
      jni.JlString.fromRef(_getDIRECTORY_MUSIC());
  static final _setDIRECTORY_MUSIC =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "set_android_os_Environment_DIRECTORY_MUSIC")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();
  static set DIRECTORY_MUSIC(jni.JlString value) =>
      _setDIRECTORY_MUSIC(value.reference);

  /// from: static public java.lang.String DIRECTORY_NOTIFICATIONS
  /// Standard directory in which to place any audio files that should be
  /// in the list of notifications that the user can select (not as regular
  /// music).
  /// This may be combined with \#DIRECTORY_MUSIC,
  /// \#DIRECTORY_PODCASTS,
  /// \#DIRECTORY_ALARMS, and \#DIRECTORY_RINGTONES as a series
  /// of directories to categories a particular audio file as more than one
  /// type.
  static final _getDIRECTORY_NOTIFICATIONS =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Environment_DIRECTORY_NOTIFICATIONS")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get DIRECTORY_NOTIFICATIONS =>
      jni.JlString.fromRef(_getDIRECTORY_NOTIFICATIONS());
  static final _setDIRECTORY_NOTIFICATIONS =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "set_android_os_Environment_DIRECTORY_NOTIFICATIONS")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();
  static set DIRECTORY_NOTIFICATIONS(jni.JlString value) =>
      _setDIRECTORY_NOTIFICATIONS(value.reference);

  /// from: static public java.lang.String DIRECTORY_PICTURES
  /// Standard directory in which to place pictures that are available to
  /// the user.  Note that this is primarily a convention for the top-level
  /// public directory, as the media scanner will find and collect pictures
  /// in any directory.
  static final _getDIRECTORY_PICTURES =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Environment_DIRECTORY_PICTURES")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get DIRECTORY_PICTURES =>
      jni.JlString.fromRef(_getDIRECTORY_PICTURES());
  static final _setDIRECTORY_PICTURES =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "set_android_os_Environment_DIRECTORY_PICTURES")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();
  static set DIRECTORY_PICTURES(jni.JlString value) =>
      _setDIRECTORY_PICTURES(value.reference);

  /// from: static public java.lang.String DIRECTORY_PODCASTS
  /// Standard directory in which to place any audio files that should be
  /// in the list of podcasts that the user can select (not as regular
  /// music).
  /// This may be combined with \#DIRECTORY_MUSIC,
  /// \#DIRECTORY_NOTIFICATIONS,
  /// \#DIRECTORY_ALARMS, and \#DIRECTORY_RINGTONES as a series
  /// of directories to categories a particular audio file as more than one
  /// type.
  static final _getDIRECTORY_PODCASTS =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Environment_DIRECTORY_PODCASTS")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get DIRECTORY_PODCASTS =>
      jni.JlString.fromRef(_getDIRECTORY_PODCASTS());
  static final _setDIRECTORY_PODCASTS =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "set_android_os_Environment_DIRECTORY_PODCASTS")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();
  static set DIRECTORY_PODCASTS(jni.JlString value) =>
      _setDIRECTORY_PODCASTS(value.reference);

  /// from: static public java.lang.String DIRECTORY_RINGTONES
  /// Standard directory in which to place any audio files that should be
  /// in the list of ringtones that the user can select (not as regular
  /// music).
  /// This may be combined with \#DIRECTORY_MUSIC,
  /// \#DIRECTORY_PODCASTS, \#DIRECTORY_NOTIFICATIONS, and
  /// \#DIRECTORY_ALARMS as a series
  /// of directories to categories a particular audio file as more than one
  /// type.
  static final _getDIRECTORY_RINGTONES =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_Environment_DIRECTORY_RINGTONES")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static jni.JlString get DIRECTORY_RINGTONES =>
      jni.JlString.fromRef(_getDIRECTORY_RINGTONES());
  static final _setDIRECTORY_RINGTONES =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "set_android_os_Environment_DIRECTORY_RINGTONES")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();
  static set DIRECTORY_RINGTONES(jni.JlString value) =>
      _setDIRECTORY_RINGTONES(value.reference);

  /// from: static public final java.lang.String MEDIA_BAD_REMOVAL
  /// Storage state if the media was removed before it was unmounted.
  ///@see \#getExternalStorageState(File)
  static const MEDIA_BAD_REMOVAL = "bad_removal";

  /// from: static public final java.lang.String MEDIA_CHECKING
  /// Storage state if the media is present and being disk-checked.
  ///@see \#getExternalStorageState(File)
  static const MEDIA_CHECKING = "checking";

  /// from: static public final java.lang.String MEDIA_EJECTING
  /// Storage state if the media is in the process of being ejected.
  ///@see \#getExternalStorageState(File)
  static const MEDIA_EJECTING = "ejecting";

  /// from: static public final java.lang.String MEDIA_MOUNTED
  /// Storage state if the media is present and mounted at its mount point with
  /// read/write access.
  ///@see \#getExternalStorageState(File)
  static const MEDIA_MOUNTED = "mounted";

  /// from: static public final java.lang.String MEDIA_MOUNTED_READ_ONLY
  /// Storage state if the media is present and mounted at its mount point with
  /// read-only access.
  ///@see \#getExternalStorageState(File)
  static const MEDIA_MOUNTED_READ_ONLY = "mounted_ro";

  /// from: static public final java.lang.String MEDIA_NOFS
  /// Storage state if the media is present but is blank or is using an
  /// unsupported filesystem.
  ///@see \#getExternalStorageState(File)
  static const MEDIA_NOFS = "nofs";

  /// from: static public final java.lang.String MEDIA_REMOVED
  /// Storage state if the media is not present.
  ///@see \#getExternalStorageState(File)
  static const MEDIA_REMOVED = "removed";

  /// from: static public final java.lang.String MEDIA_SHARED
  /// Storage state if the media is present not mounted, and shared via USB
  /// mass storage.
  ///@see \#getExternalStorageState(File)
  static const MEDIA_SHARED = "shared";

  /// from: static public final java.lang.String MEDIA_UNKNOWN
  /// Unknown storage state, such as when a path isn't backed by known storage
  /// media.
  ///@see \#getExternalStorageState(File)
  static const MEDIA_UNKNOWN = "unknown";

  /// from: static public final java.lang.String MEDIA_UNMOUNTABLE
  /// Storage state if the media is present but cannot be mounted. Typically
  /// this happens if the file system on the media is corrupted.
  ///@see \#getExternalStorageState(File)
  static const MEDIA_UNMOUNTABLE = "unmountable";

  /// from: static public final java.lang.String MEDIA_UNMOUNTED
  /// Storage state if the media is present but not mounted.
  ///@see \#getExternalStorageState(File)
  static const MEDIA_UNMOUNTED = "unmounted";

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Environment_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Environment() : super.fromRef(_ctor());

  static final _getRootDirectory =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Environment_getRootDirectory")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public java.io.File getRootDirectory()
  /// Return root of the "system" partition holding the core Android OS.
  /// Always present and mounted read-only.
  static jni.JlObject getRootDirectory() =>
      jni.JlObject.fromRef(_getRootDirectory());

  static final _getDataDirectory =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Environment_getDataDirectory")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public java.io.File getDataDirectory()
  /// Return the user data directory.
  static jni.JlObject getDataDirectory() =>
      jni.JlObject.fromRef(_getDataDirectory());

  static final _getExternalStorageDirectory =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Environment_getExternalStorageDirectory")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public java.io.File getExternalStorageDirectory()
  /// Return the primary shared/external storage directory. This directory may
  /// not currently be accessible if it has been mounted by the user on their
  /// computer, has been removed from the device, or some other problem has
  /// happened. You can determine its current state with
  /// \#getExternalStorageState().
  ///
  /// _Note: don't be confused by the word "external" here. This directory
  /// can better be thought as media/shared storage. It is a filesystem that
  /// can hold a relatively large amount of data and that is shared across all
  /// applications (does not enforce permissions). Traditionally this is an SD
  /// card, but it may also be implemented as built-in storage in a device that
  /// is distinct from the protected internal storage and can be mounted as a
  /// filesystem on a computer._
  ///
  /// On devices with multiple users (as described by UserManager),
  /// each user has their own isolated shared storage. Applications only have
  /// access to the shared storage for the user they're running as.
  ///
  /// In devices with multiple shared/external storage directories, this
  /// directory represents the primary storage that the user will interact
  /// with. Access to secondary storage is available through
  /// Context\#getExternalFilesDirs(String),
  /// Context\#getExternalCacheDirs(), and
  /// Context\#getExternalMediaDirs().
  ///
  /// Applications should not directly use this top-level directory, in order
  /// to avoid polluting the user's root namespace. Any files that are private
  /// to the application should be placed in a directory returned by
  /// android.content.Context\#getExternalFilesDir Context.getExternalFilesDir, which the system will take care of deleting
  /// if the application is uninstalled. Other shared files should be placed in
  /// one of the directories returned by
  /// \#getExternalStoragePublicDirectory.
  ///
  /// Writing to this path requires the
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE permission,
  /// and starting in android.os.Build.VERSION_CODES\#KITKAT, read access requires the
  /// android.Manifest.permission\#READ_EXTERNAL_STORAGE permission,
  /// which is automatically granted if you hold the write permission.
  ///
  /// Starting in android.os.Build.VERSION_CODES\#KITKAT, if your
  /// application only needs to store internal data, consider using
  /// Context\#getExternalFilesDir(String),
  /// Context\#getExternalCacheDir(), or
  /// Context\#getExternalMediaDirs(), which require no permissions to
  /// read or write.
  ///
  /// This path may change between platform versions, so applications should
  /// only persist relative paths.
  ///
  /// Here is an example of typical code to monitor the state of external
  /// storage:
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
  /// monitor_storage}
  ///@see \#getExternalStorageState()
  ///@see \#isExternalStorageRemovable()
  static jni.JlObject getExternalStorageDirectory() =>
      jni.JlObject.fromRef(_getExternalStorageDirectory());

  static final _getExternalStoragePublicDirectory = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_Environment_getExternalStoragePublicDirectory")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.io.File getExternalStoragePublicDirectory(java.lang.String type)
  /// Get a top-level shared/external storage directory for placing files of a
  /// particular type. This is where the user will typically place and manage
  /// their own files, so you should be careful about what you put here to
  /// ensure you don't erase their files or get in the way of their own
  /// organization.
  ///
  /// On devices with multiple users (as described by UserManager),
  /// each user has their own isolated shared storage. Applications only have
  /// access to the shared storage for the user they're running as.
  ///
  ///
  ///
  /// Here is an example of typical code to manipulate a picture on the public
  /// shared storage:
  ///
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
  /// public_picture}
  ///@param type The type of storage directory to return. Should be one of
  ///            \#DIRECTORY_MUSIC, \#DIRECTORY_PODCASTS,
  ///            \#DIRECTORY_RINGTONES, \#DIRECTORY_ALARMS,
  ///            \#DIRECTORY_NOTIFICATIONS, \#DIRECTORY_PICTURES,
  ///            \#DIRECTORY_MOVIES, \#DIRECTORY_DOWNLOADS,
  ///            \#DIRECTORY_DCIM, or \#DIRECTORY_DOCUMENTS. May not be null.
  ///@return Returns the File path for the directory. Note that this directory
  ///         may not yet exist, so you must make sure it exists before using
  ///         it such as with File\#mkdirs File.mkdirs().
  static jni.JlObject getExternalStoragePublicDirectory(jni.JlString type) =>
      jni.JlObject.fromRef(_getExternalStoragePublicDirectory(type.reference));

  static final _getDownloadCacheDirectory =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Environment_getDownloadCacheDirectory")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public java.io.File getDownloadCacheDirectory()
  /// Return the download/cache content directory.
  static jni.JlObject getDownloadCacheDirectory() =>
      jni.JlObject.fromRef(_getDownloadCacheDirectory());

  static final _getExternalStorageState =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Environment_getExternalStorageState")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public java.lang.String getExternalStorageState()
  /// Returns the current state of the primary shared/external storage media.
  ///@see \#getExternalStorageDirectory()
  ///@return one of \#MEDIA_UNKNOWN, \#MEDIA_REMOVED,
  ///         \#MEDIA_UNMOUNTED, \#MEDIA_CHECKING,
  ///         \#MEDIA_NOFS, \#MEDIA_MOUNTED,
  ///         \#MEDIA_MOUNTED_READ_ONLY, \#MEDIA_SHARED,
  ///         \#MEDIA_BAD_REMOVAL, or \#MEDIA_UNMOUNTABLE.
  static jni.JlString getExternalStorageState() =>
      jni.JlString.fromRef(_getExternalStorageState());

  static final _getStorageState = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_Environment_getStorageState")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String getStorageState(java.io.File path)
  /// @deprecated use \#getExternalStorageState(File)
  static jni.JlString getStorageState(jni.JlObject path) =>
      jni.JlString.fromRef(_getStorageState(path.reference));

  static final _getExternalStorageState_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_Environment_getExternalStorageState_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String getExternalStorageState(java.io.File path)
  /// Returns the current state of the shared/external storage media at the
  /// given path.
  ///@return one of \#MEDIA_UNKNOWN, \#MEDIA_REMOVED,
  ///         \#MEDIA_UNMOUNTED, \#MEDIA_CHECKING,
  ///         \#MEDIA_NOFS, \#MEDIA_MOUNTED,
  ///         \#MEDIA_MOUNTED_READ_ONLY, \#MEDIA_SHARED,
  ///         \#MEDIA_BAD_REMOVAL, or \#MEDIA_UNMOUNTABLE.
  static jni.JlString getExternalStorageState_1(jni.JlObject path) =>
      jni.JlString.fromRef(_getExternalStorageState_1(path.reference));

  static final _isExternalStorageRemovable =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function()>>(
              "android_os_Environment_isExternalStorageRemovable")
          .asFunction<int Function()>();

  /// from: static public boolean isExternalStorageRemovable()
  /// Returns whether the primary shared/external storage media is physically
  /// removable.
  ///@return true if the storage device can be removed (such as an SD card),
  ///         or false if the storage device is built in and cannot be
  ///         physically removed.
  static bool isExternalStorageRemovable() =>
      _isExternalStorageRemovable() != 0;

  static final _isExternalStorageRemovable_1 =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Environment_isExternalStorageRemovable_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean isExternalStorageRemovable(java.io.File path)
  /// Returns whether the shared/external storage media at the given path is
  /// physically removable.
  ///@return true if the storage device can be removed (such as an SD card),
  ///         or false if the storage device is built in and cannot be
  ///         physically removed.
  ///@throws IllegalArgumentException if the path is not a valid storage
  ///             device.
  static bool isExternalStorageRemovable_1(jni.JlObject path) =>
      _isExternalStorageRemovable_1(path.reference) != 0;

  static final _isExternalStorageEmulated =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function()>>(
              "android_os_Environment_isExternalStorageEmulated")
          .asFunction<int Function()>();

  /// from: static public boolean isExternalStorageEmulated()
  /// Returns whether the primary shared/external storage media is emulated.
  ///
  /// The contents of emulated storage devices are backed by a private user
  /// data partition, which means there is little benefit to apps storing data
  /// here instead of the private directories returned by
  /// Context\#getFilesDir(), etc.
  ///
  /// This returns true when emulated storage is backed by either internal
  /// storage or an adopted storage device.
  ///@see DevicePolicyManager\#setStorageEncryption(android.content.ComponentName,
  ///      boolean)
  static bool isExternalStorageEmulated() => _isExternalStorageEmulated() != 0;

  static final _isExternalStorageEmulated_1 =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Environment_isExternalStorageEmulated_1")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean isExternalStorageEmulated(java.io.File path)
  /// Returns whether the shared/external storage media at the given path is
  /// emulated.
  ///
  /// The contents of emulated storage devices are backed by a private user
  /// data partition, which means there is little benefit to apps storing data
  /// here instead of the private directories returned by
  /// Context\#getFilesDir(), etc.
  ///
  /// This returns true when emulated storage is backed by either internal
  /// storage or an adopted storage device.
  ///@throws IllegalArgumentException if the path is not a valid storage
  ///             device.
  static bool isExternalStorageEmulated_1(jni.JlObject path) =>
      _isExternalStorageEmulated_1(path.reference) != 0;
}

/// Manages users and user details on a multi-user system. There are two major categories of
/// users: fully customizable users with their own login, and managed profiles that share a workspace
/// with a related user.
///
/// Users are different from accounts, which are managed by
/// AccountManager. Each user can have their own set of accounts.
///
/// See DevicePolicyManager\#ACTION_PROVISION_MANAGED_PROFILE for more on managed profiles.
class UserManager extends jni.JlObject {
  UserManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ALLOW_PARENT_PROFILE_APP_LINKING
  /// Allows apps in the parent profile to handle web links from the managed profile.
  ///
  /// This user restriction has an effect only in a managed profile.
  /// If set:
  /// Intent filters of activities in the parent profile with action
  /// android.content.Intent\#ACTION_VIEW,
  /// category android.content.Intent\#CATEGORY_BROWSABLE, scheme http or https, and which
  /// define a host can handle intents from the managed profile.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const ALLOW_PARENT_PROFILE_APP_LINKING =
      "allow_parent_profile_app_linking";

  /// from: static public final java.lang.String DISALLOW_ADD_MANAGED_PROFILE
  /// Specifies if a user is disallowed from adding managed profiles.
  /// The default value for an unmanaged user is <code>false</code>.
  /// For users with a device owner set, the default is <code>true</code>.
  /// This restriction has no effect on managed profiles.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_ADD_MANAGED_PROFILE = "no_add_managed_profile";

  /// from: static public final java.lang.String DISALLOW_ADD_USER
  /// Specifies if a user is disallowed from adding new users. This can only be set by device
  /// owners and profile owners on the primary user.
  /// The default value is <code>false</code>.
  /// This restriction has no effect on secondary users and managed profiles since only the
  /// primary user can add other users.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_ADD_USER = "no_add_user";

  /// from: static public final java.lang.String DISALLOW_ADJUST_VOLUME
  /// Specifies if a user is disallowed from adjusting the master volume. If set, the master volume
  /// will be muted. This can be set by device owners from API 21 and profile owners from API 24.
  /// The default value is <code>false</code>.
  ///
  /// When the restriction is set by profile owners, then it only applies to relevant
  /// profiles.
  ///
  /// This restriction has no effect on managed profiles.
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_ADJUST_VOLUME = "no_adjust_volume";

  /// from: static public final java.lang.String DISALLOW_AIRPLANE_MODE
  /// Specifies if airplane mode is disallowed on the device.
  ///
  ///  This restriction can only be set by the device owner and the profile owner on the
  /// primary user and it applies globally - i.e. it disables airplane mode on the entire device.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_AIRPLANE_MODE = "no_airplane_mode";

  /// from: static public final java.lang.String DISALLOW_AMBIENT_DISPLAY
  /// Specifies if ambient display is disallowed for the user.
  ///
  /// The default value is <code>false</code>.
  ///
  /// This user restriction has no effect on managed profiles.
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_AMBIENT_DISPLAY = "no_ambient_display";

  /// from: static public final java.lang.String DISALLOW_APPS_CONTROL
  /// Specifies if a user is disallowed from modifying
  /// applications in Settings or launchers. The following actions will not be allowed when this
  /// restriction is enabled:
  /// <li>uninstalling apps</li>
  /// <li>disabling apps</li>
  /// <li>clearing app caches</li>
  /// <li>clearing app data</li>
  /// <li>force stopping apps</li>
  /// <li>clearing app defaults</li>
  ///
  /// The default value is <code>false</code>.
  ///
  /// <strong>Note:</strong> The user will still be able to perform those actions via other
  /// means (such as adb). Third party apps will also be able to uninstall apps via the
  /// android.content.pm.PackageInstaller. \#DISALLOW_UNINSTALL_APPS or
  /// DevicePolicyManager\#setUninstallBlocked(ComponentName, String, boolean) should be
  /// used to prevent the user from uninstalling apps completely, and
  /// DevicePolicyManager\#addPersistentPreferredActivity(ComponentName, IntentFilter, ComponentName)
  /// to add a default intent handler for a given intent filter.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_APPS_CONTROL = "no_control_apps";

  /// from: static public final java.lang.String DISALLOW_AUTOFILL
  /// Specifies if a user is not allowed to use Autofill Services.
  ///
  /// Device owner and profile owner can set this restriction. When it is set by device owner,
  /// only the target user will be affected.
  ///
  /// The default value is <code>false</code>.
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_AUTOFILL = "no_autofill";

  /// from: static public final java.lang.String DISALLOW_BLUETOOTH
  /// Specifies if bluetooth is disallowed on the device.
  ///
  ///  This restriction can only be set by the device owner and the profile owner on the
  /// primary user and it applies globally - i.e. it disables bluetooth on the entire device.
  /// The default value is <code>false</code>.
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_BLUETOOTH = "no_bluetooth";

  /// from: static public final java.lang.String DISALLOW_BLUETOOTH_SHARING
  /// Specifies if outgoing bluetooth sharing is disallowed on the device. Device owner and profile
  /// owner can set this restriction. When it is set by device owner, all users on this device will
  /// be affected.
  ///
  /// Default is <code>true</code> for managed profiles and false for otherwise. When a device
  /// upgrades to android.os.Build.VERSION_CODES\#O, the system sets it for all existing
  /// managed profiles.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_BLUETOOTH_SHARING = "no_bluetooth_sharing";

  /// from: static public final java.lang.String DISALLOW_CONFIG_BLUETOOTH
  /// Specifies if a user is disallowed from configuring bluetooth.
  /// This does _not_ restrict the user from turning bluetooth on or off.
  /// The default value is <code>false</code>.
  /// This restriction doesn't prevent the user from using bluetooth. For disallowing usage of
  /// bluetooth completely on the device, use \#DISALLOW_BLUETOOTH.
  /// This restriction has no effect in a managed profile.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_BLUETOOTH = "no_config_bluetooth";

  /// from: static public final java.lang.String DISALLOW_CONFIG_BRIGHTNESS
  /// Specifies if a user is disallowed from configuring brightness. When device owner sets it,
  /// it'll only be applied on the target(system) user.
  ///
  /// The default value is <code>false</code>.
  ///
  /// This user restriction has no effect on managed profiles.
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_BRIGHTNESS = "no_config_brightness";

  /// from: static public final java.lang.String DISALLOW_CONFIG_CELL_BROADCASTS
  /// Specifies if a user is disallowed from configuring cell
  /// broadcasts. This can only be set by device owners and profile owners on the primary user.
  /// The default value is <code>false</code>.
  /// This restriction has no effect on secondary users and managed profiles since only the
  /// primary user can configure cell broadcasts.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_CELL_BROADCASTS = "no_config_cell_broadcasts";

  /// from: static public final java.lang.String DISALLOW_CONFIG_CREDENTIALS
  /// Specifies if a user is disallowed from configuring user
  /// credentials. The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_CREDENTIALS = "no_config_credentials";

  /// from: static public final java.lang.String DISALLOW_CONFIG_DATE_TIME
  /// Specifies if date, time and timezone configuring is disallowed.
  ///
  /// When restriction is set by device owners, it applies globally - i.e., it disables date,
  /// time and timezone setting on the entire device and all users will be affected. When it's set
  /// by profile owners, it's only applied to the managed user.
  /// The default value is <code>false</code>.
  ///
  /// This user restriction has no effect on managed profiles.
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_DATE_TIME = "no_config_date_time";

  /// from: static public final java.lang.String DISALLOW_CONFIG_LOCALE
  /// Specifies if a user is disallowed from changing the device
  /// language. The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_LOCALE = "no_config_locale";

  /// from: static public final java.lang.String DISALLOW_CONFIG_LOCATION
  /// Specifies if a user is disallowed from enabling or disabling location providers. As a
  /// result, user is disallowed from turning on or off location. Device owner and profile owners
  /// can set this restriction and it only applies on the managed user.
  ///
  /// In a managed profile, location sharing is forced off when it's off on primary user, so
  /// user can still turn off location sharing on managed profile when the restriction is set by
  /// profile owner on managed profile.
  ///
  /// This user restriction is different from \#DISALLOW_SHARE_LOCATION,
  /// as the device owner or profile owner can still enable or disable location mode via
  /// DevicePolicyManager\#setSecureSetting when this restriction is on.
  ///
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see android.location.LocationManager\#isProviderEnabled(String)
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_LOCATION = "no_config_location";

  /// from: static public final java.lang.String DISALLOW_CONFIG_MOBILE_NETWORKS
  /// Specifies if a user is disallowed from configuring mobile
  /// networks. This can only be set by device owners and profile owners on the primary user.
  /// The default value is <code>false</code>.
  /// This restriction has no effect on secondary users and managed profiles since only the
  /// primary user can configure mobile networks.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_MOBILE_NETWORKS = "no_config_mobile_networks";

  /// from: static public final java.lang.String DISALLOW_CONFIG_SCREEN_TIMEOUT
  /// Specifies if a user is disallowed from changing screen off timeout.
  ///
  /// The default value is <code>false</code>.
  ///
  /// This user restriction has no effect on managed profiles.
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_SCREEN_TIMEOUT = "no_config_screen_timeout";

  /// from: static public final java.lang.String DISALLOW_CONFIG_TETHERING
  /// Specifies if a user is disallowed from configuring Tethering
  /// & portable hotspots. This can only be set by device owners and profile owners on the
  /// primary user. The default value is <code>false</code>.
  /// In Android 9.0 or higher, if tethering is enabled when this restriction is set,
  /// tethering will be automatically turned off.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_TETHERING = "no_config_tethering";

  /// from: static public final java.lang.String DISALLOW_CONFIG_VPN
  /// Specifies if a user is disallowed from configuring a VPN. The default value is
  /// <code>false</code>. This restriction has an effect when set by device owners and, in Android
  /// 6.0 ({@linkplain android.os.Build.VERSION_CODES\#M API level 23}) or higher, profile owners.
  /// This restriction also prevents VPNs from starting. However, in Android 7.0
  /// ({@linkplain android.os.Build.VERSION_CODES\#N API level 24}) or higher, the system does
  /// start always-on VPNs created by the device or profile owner.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_VPN = "no_config_vpn";

  /// from: static public final java.lang.String DISALLOW_CONFIG_WIFI
  /// Specifies if a user is disallowed from changing Wi-Fi
  /// access points. The default value is <code>false</code>.
  /// This restriction has no effect in a managed profile.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CONFIG_WIFI = "no_config_wifi";

  /// from: static public final java.lang.String DISALLOW_CREATE_WINDOWS
  /// Specifies that windows besides app windows should not be
  /// created. This will block the creation of the following types of windows.
  /// <li>LayoutParams\#TYPE_TOAST</li>
  /// <li>LayoutParams\#TYPE_PHONE</li>
  /// <li>LayoutParams\#TYPE_PRIORITY_PHONE</li>
  /// <li>LayoutParams\#TYPE_SYSTEM_ALERT</li>
  /// <li>LayoutParams\#TYPE_SYSTEM_ERROR</li>
  /// <li>LayoutParams\#TYPE_SYSTEM_OVERLAY</li>
  /// <li>LayoutParams\#TYPE_APPLICATION_OVERLAY</li>
  ///
  /// This can only be set by device owners and profile owners on the primary user.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CREATE_WINDOWS = "no_create_windows";

  /// from: static public final java.lang.String DISALLOW_CROSS_PROFILE_COPY_PASTE
  /// Specifies if what is copied in the clipboard of this profile can
  /// be pasted in related profiles. Does not restrict if the clipboard of related profiles can be
  /// pasted in this profile.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_CROSS_PROFILE_COPY_PASTE =
      "no_cross_profile_copy_paste";

  /// from: static public final java.lang.String DISALLOW_DATA_ROAMING
  /// Specifies if a user is not allowed to use cellular data when roaming. This can only be set by
  /// device owners. The default value is <code>false</code>.
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_DATA_ROAMING = "no_data_roaming";

  /// from: static public final java.lang.String DISALLOW_DEBUGGING_FEATURES
  /// Specifies if a user is disallowed from enabling or
  /// accessing debugging features. The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_DEBUGGING_FEATURES = "no_debugging_features";

  /// from: static public final java.lang.String DISALLOW_FACTORY_RESET
  /// Specifies if a user is disallowed from factory resetting
  /// from Settings. This can only be set by device owners and profile owners on the primary user.
  /// The default value is <code>false</code>.
  /// This restriction has no effect on secondary users and managed profiles since only the
  /// primary user can factory reset the device.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_FACTORY_RESET = "no_factory_reset";

  /// from: static public final java.lang.String DISALLOW_FUN
  /// Specifies if the user is not allowed to have fun. In some cases, the
  /// device owner may wish to prevent the user from experiencing amusement or
  /// joy while using the device. The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_FUN = "no_fun";

  /// from: static public final java.lang.String DISALLOW_INSTALL_APPS
  /// Specifies if a user is disallowed from installing applications. This user restriction also
  /// prevents device owners and profile owners installing apps. The default value is
  /// {@code false}.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_INSTALL_APPS = "no_install_apps";

  /// from: static public final java.lang.String DISALLOW_INSTALL_UNKNOWN_SOURCES
  /// Specifies if a user is disallowed from enabling the
  /// "Unknown Sources" setting, that allows installation of apps from unknown sources.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_INSTALL_UNKNOWN_SOURCES = "no_install_unknown_sources";

  /// from: static public final java.lang.String DISALLOW_MODIFY_ACCOUNTS
  /// Specifies if a user is disallowed from adding and removing accounts, unless they are
  /// android.accounts.AccountManager\#addAccountExplicitly programmatically added by
  /// Authenticator.
  /// The default value is <code>false</code>.
  ///
  /// From android.os.Build.VERSION_CODES\#N a profile or device owner app can still
  /// use android.accounts.AccountManager APIs to add or remove accounts when account
  /// management is disallowed.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_MODIFY_ACCOUNTS = "no_modify_accounts";

  /// from: static public final java.lang.String DISALLOW_MOUNT_PHYSICAL_MEDIA
  /// Specifies if a user is disallowed from mounting
  /// physical external media. This can only be set by device owners and profile owners on the
  /// primary user. The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_MOUNT_PHYSICAL_MEDIA = "no_physical_media";

  /// from: static public final java.lang.String DISALLOW_NETWORK_RESET
  /// Specifies if a user is disallowed from resetting network settings
  /// from Settings. This can only be set by device owners and profile owners on the primary user.
  /// The default value is <code>false</code>.
  /// This restriction has no effect on secondary users and managed profiles since only the
  /// primary user can reset the network settings of the device.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_NETWORK_RESET = "no_network_reset";

  /// from: static public final java.lang.String DISALLOW_OUTGOING_BEAM
  /// Specifies if the user is not allowed to use NFC to beam out data from apps.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_OUTGOING_BEAM = "no_outgoing_beam";

  /// from: static public final java.lang.String DISALLOW_OUTGOING_CALLS
  /// Specifies that the user is not allowed to make outgoing
  /// phone calls. Emergency calls are still permitted.
  /// The default value is <code>false</code>.
  /// This restriction has no effect on managed profiles.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_OUTGOING_CALLS = "no_outgoing_calls";

  /// from: static public final java.lang.String DISALLOW_PRINTING
  /// Specifies whether the user is allowed to print.
  ///
  /// This restriction can be set by device or profile owner.
  ///
  /// The default value is {@code false}.
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_PRINTING = "no_printing";

  /// from: static public final java.lang.String DISALLOW_REMOVE_MANAGED_PROFILE
  /// Specifies if managed profiles of this user can be removed, other than by its profile owner.
  /// The default value is <code>false</code>.
  ///
  /// This restriction has no effect on managed profiles.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_REMOVE_MANAGED_PROFILE = "no_remove_managed_profile";

  /// from: static public final java.lang.String DISALLOW_REMOVE_USER
  /// When set on the primary user this specifies if the user can remove other users.
  /// When set on a secondary user, this specifies if the user can remove itself.
  /// This restriction has no effect on managed profiles.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_REMOVE_USER = "no_remove_user";

  /// from: static public final java.lang.String DISALLOW_SAFE_BOOT
  /// Specifies if the user is not allowed to reboot the device into safe boot mode.
  /// This can only be set by device owners and profile owners on the primary user.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_SAFE_BOOT = "no_safe_boot";

  /// from: static public final java.lang.String DISALLOW_SET_USER_ICON
  /// Specifies if a user is not allowed to change their icon. Device owner and profile owner
  /// can set this restriction. When it is set by device owner, only the target user will be
  /// affected. The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_SET_USER_ICON = "no_set_user_icon";

  /// from: static public final java.lang.String DISALLOW_SET_WALLPAPER
  /// User restriction to disallow setting a wallpaper. Profile owner and device owner
  /// are able to set wallpaper regardless of this restriction.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_SET_WALLPAPER = "no_set_wallpaper";

  /// from: static public final java.lang.String DISALLOW_SHARE_INTO_MANAGED_PROFILE
  /// Specifies whether the user can share file / picture / data from the primary user into the
  /// managed profile, either by sending them from the primary side, or by picking up data within
  /// an app in the managed profile.
  ///
  /// When a managed profile is created, the system allows the user to send data from the primary
  /// side to the profile by setting up certain default cross profile intent filters. If
  /// this is undesired, this restriction can be set to disallow it. Note that this restriction
  /// will not block any sharing allowed by explicit
  /// DevicePolicyManager\#addCrossProfileIntentFilter calls by the profile owner.
  ///
  /// This restriction is only meaningful when set by profile owner. When it is set by device
  /// owner, it does not have any effect.
  ///
  /// The default value is <code>false</code>.
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_SHARE_INTO_MANAGED_PROFILE = "no_sharing_into_profile";

  /// from: static public final java.lang.String DISALLOW_SHARE_LOCATION
  /// Specifies if a user is disallowed from turning on location sharing.
  /// The default value is <code>false</code>.
  /// In a managed profile, location sharing always reflects the primary user's setting, but
  /// can be overridden and forced off by setting this restriction to true in the managed profile.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_SHARE_LOCATION = "no_share_location";

  /// from: static public final java.lang.String DISALLOW_SMS
  /// Specifies that the user is not allowed to send or receive
  /// SMS messages. The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_SMS = "no_sms";

  /// from: static public final java.lang.String DISALLOW_SYSTEM_ERROR_DIALOGS
  /// Specifies that system error dialogs for crashed or unresponsive apps should not be shown.
  /// In this case, the system will force-stop the app as if the user chooses the "close app"
  /// option on the UI. A feedback report isn't collected as there is no way for the user to
  /// provide explicit consent. The default value is <code>false</code>.
  ///
  /// When this user restriction is set by device owners, it's applied to all users. When set by
  /// the profile owner of the primary user or a secondary user, the restriction affects only the
  /// calling user. This user restriction has no effect on managed profiles.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_SYSTEM_ERROR_DIALOGS = "no_system_error_dialogs";

  /// from: static public final java.lang.String DISALLOW_UNIFIED_PASSWORD
  /// Specifies that the managed profile is not allowed to have unified lock screen challenge with
  /// the primary user.
  ///
  /// <strong>Note:</strong> Setting this restriction alone doesn't automatically set a
  /// separate challenge. Profile owner can ask the user to set a new password using
  /// DevicePolicyManager\#ACTION_SET_NEW_PASSWORD and verify it using
  /// DevicePolicyManager\#isUsingUnifiedPassword(ComponentName).
  ///
  /// Can be set by profile owners. It only has effect on managed profiles when set by managed
  /// profile owner. Has no effect on non-managed profiles or users.
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_UNIFIED_PASSWORD = "no_unified_password";

  /// from: static public final java.lang.String DISALLOW_UNINSTALL_APPS
  /// Specifies if a user is disallowed from uninstalling applications.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_UNINSTALL_APPS = "no_uninstall_apps";

  /// from: static public final java.lang.String DISALLOW_UNMUTE_MICROPHONE
  /// Specifies if a user is disallowed from adjusting microphone volume. If set, the microphone
  /// will be muted. This can be set by device owners and profile owners. The default value is
  /// <code>false</code>.
  ///
  /// This restriction has no effect on managed profiles.
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_UNMUTE_MICROPHONE = "no_unmute_microphone";

  /// from: static public final java.lang.String DISALLOW_USB_FILE_TRANSFER
  /// Specifies if a user is disallowed from transferring files over
  /// USB. This can only be set by device owners and profile owners on the primary user.
  /// The default value is <code>false</code>.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_USB_FILE_TRANSFER = "no_usb_file_transfer";

  /// from: static public final java.lang.String DISALLOW_USER_SWITCH
  /// Specifies if user switching is blocked on the current user.
  ///
  ///  This restriction can only be set by the device owner, it will be applied to all users.
  /// Device owner can still switch user via
  /// DevicePolicyManager\#switchUser(ComponentName, UserHandle) when this restriction is
  /// set.
  ///
  /// The default value is <code>false</code>.
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const DISALLOW_USER_SWITCH = "no_user_switch";

  /// from: static public final java.lang.String ENSURE_VERIFY_APPS
  /// Specifies if a user is disallowed from disabling application verification. The default
  /// value is <code>false</code>.
  ///
  /// In Android 8.0 ({@linkplain android.os.Build.VERSION_CODES\#O API level 26}) and higher,
  /// this is a global user restriction. If a device owner or profile owner sets this restriction,
  /// the system enforces app verification across all users on the device. Running in earlier
  /// Android versions, this restriction affects only the profile that sets it.
  ///
  /// Key for user restrictions.
  /// Type: Boolean
  ///@see DevicePolicyManager\#addUserRestriction(ComponentName, String)
  ///@see DevicePolicyManager\#clearUserRestriction(ComponentName, String)
  ///@see \#getUserRestrictions()
  static const ENSURE_VERIFY_APPS = "ensure_verify_apps";

  /// from: static public final java.lang.String KEY_RESTRICTIONS_PENDING
  /// Application restriction key that is used to indicate the pending arrival
  /// of real restrictions for the app.
  ///
  ///
  /// Applications that support restrictions should check for the presence of this key.
  /// A <code>true</code> value indicates that restrictions may be applied in the near
  /// future but are not available yet. It is the responsibility of any
  /// management application that sets this flag to update it when the final
  /// restrictions are enforced.
  ///
  /// Key for application restrictions.
  /// Type: Boolean
  ///@see android.app.admin.DevicePolicyManager\#setApplicationRestrictions(
  ///      android.content.ComponentName, String, Bundle)
  ///@see android.app.admin.DevicePolicyManager\#getApplicationRestrictions(
  ///      android.content.ComponentName, String)
  static const KEY_RESTRICTIONS_PENDING = "restrictions_pending";

  /// from: static public final int USER_CREATION_FAILED_NOT_PERMITTED
  /// Error result indicating that this user is not allowed to add other users on this device.
  /// This is a result code returned from the activity created by the intent
  /// \#createUserCreationIntent(String, String, String, PersistableBundle).
  static const USER_CREATION_FAILED_NOT_PERMITTED = 1;

  /// from: static public final int USER_CREATION_FAILED_NO_MORE_USERS
  /// Error result indicating that no more users can be created on this device.
  /// This is a result code returned from the activity created by the intent
  /// \#createUserCreationIntent(String, String, String, PersistableBundle).
  static const USER_CREATION_FAILED_NO_MORE_USERS = 2;

  /// from: static public final int USER_OPERATION_ERROR_CURRENT_USER
  /// Indicates user operation failed because the target user is in the foreground.
  static const USER_OPERATION_ERROR_CURRENT_USER = 4;

  /// from: static public final int USER_OPERATION_ERROR_LOW_STORAGE
  /// Indicates user operation failed because device has low data storage.
  static const USER_OPERATION_ERROR_LOW_STORAGE = 5;

  /// from: static public final int USER_OPERATION_ERROR_MANAGED_PROFILE
  /// Indicates user operation failed because target user is a managed profile.
  static const USER_OPERATION_ERROR_MANAGED_PROFILE = 2;

  /// from: static public final int USER_OPERATION_ERROR_MAX_RUNNING_USERS
  /// Indicates user operation failed because maximum running user limit has been reached.
  static const USER_OPERATION_ERROR_MAX_RUNNING_USERS = 3;

  /// from: static public final int USER_OPERATION_ERROR_MAX_USERS
  /// Indicates user operation failed because maximum user limit has been reached.
  static const USER_OPERATION_ERROR_MAX_USERS = 6;

  /// from: static public final int USER_OPERATION_ERROR_UNKNOWN
  /// Indicates user operation failed for unknown reason.
  static const USER_OPERATION_ERROR_UNKNOWN = 1;

  /// from: static public final int USER_OPERATION_SUCCESS
  /// Indicates user operation is successful.
  static const USER_OPERATION_SUCCESS = 0;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_UserManager_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  UserManager() : super.fromRef(_ctor());

  static final _supportsMultipleUsers =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function()>>(
              "android_os_UserManager_supportsMultipleUsers")
          .asFunction<int Function()>();

  /// from: static public boolean supportsMultipleUsers()
  /// Returns whether this device supports multiple users with their own login and customizable
  /// space.
  ///@return whether the device supports multiple users.
  static bool supportsMultipleUsers() => _supportsMultipleUsers() != 0;

  static final _getUserName = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_UserManager_getUserName")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getUserName()
  /// Returns the user name of the user making this call.  This call is only
  /// available to applications on the system image; it requires the
  /// MANAGE_USERS permission.
  ///@return the user name
  jni.JlString getUserName() => jni.JlString.fromRef(_getUserName(reference));

  static final _isUserAGoat =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_UserManager_isUserAGoat")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isUserAGoat()
  /// Used to determine whether the user making this call is subject to
  /// teleportations.
  ///
  /// As of android.os.Build.VERSION_CODES\#LOLLIPOP, this method can
  /// now automatically identify goats using advanced goat recognition technology.
  ///
  ///@return Returns true if the user making this call is a goat.
  bool isUserAGoat() => _isUserAGoat(reference) != 0;

  static final _isSystemUser =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_UserManager_isSystemUser")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isSystemUser()
  /// Used to check if this process is running under the system user. The system user
  /// is the initial user that is implicitly created on first boot and hosts most of the
  /// system services.
  ///@return whether this process is running under the system user.
  bool isSystemUser() => _isSystemUser(reference) != 0;

  static final _isDemoUser =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_UserManager_isDemoUser")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isDemoUser()
  /// Checks if the calling app is running in a demo user. When running in a demo user,
  /// apps can be more helpful to the user, or explain their features in more detail.
  ///@return whether the caller is a demo user.
  bool isDemoUser() => _isDemoUser(reference) != 0;

  static final _isUserRunning = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_UserManager_isUserRunning")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isUserRunning(android.os.UserHandle user)
  /// Return whether the given user is actively running.  This means that
  /// the user is in the "started" state, not "stopped" -- it is currently
  /// allowed to run code through scheduled alarms, receiving broadcasts,
  /// etc.  A started user may be either the current foreground user or a
  /// background user; the result here does not distinguish between the two.
  ///
  /// Note prior to Android Nougat MR1 (SDK version <= 24;
  /// {@link android.os.Build.VERSION_CODES\#N), this API required a system permission
  /// in order to check other profile's status.
  /// Since Android Nougat MR1 (SDK version >= 25;
  /// {@link android.os.Build.VERSION_CODES\#N_MR1)), the restriction has been relaxed, and now
  /// it'll accept any UserHandle within the same profile group as the caller.
  ///@param user The user to retrieve the running state for.
  bool isUserRunning(UserHandle user) =>
      _isUserRunning(reference, user.reference) != 0;

  static final _isUserRunningOrStopping = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_UserManager_isUserRunningOrStopping")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isUserRunningOrStopping(android.os.UserHandle user)
  /// Return whether the given user is actively running _or_ stopping.
  /// This is like \#isUserRunning(UserHandle), but will also return
  /// true if the user had been running but is in the process of being stopped
  /// (but is not yet fully stopped, and still running some code).
  ///
  /// Note prior to Android Nougat MR1 (SDK version <= 24;
  /// {@link android.os.Build.VERSION_CODES\#N), this API required a system permission
  /// in order to check other profile's status.
  /// Since Android Nougat MR1 (SDK version >= 25;
  /// {@link android.os.Build.VERSION_CODES\#N_MR1)), the restriction has been relaxed, and now
  /// it'll accept any UserHandle within the same profile group as the caller.
  ///@param user The user to retrieve the running state for.
  bool isUserRunningOrStopping(UserHandle user) =>
      _isUserRunningOrStopping(reference, user.reference) != 0;

  static final _isUserUnlocked =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_UserManager_isUserUnlocked")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isUserUnlocked()
  /// Return whether the calling user is running in an "unlocked" state.
  ///
  /// On devices with direct boot, a user is unlocked only after they've
  /// entered their credentials (such as a lock pattern or PIN). On devices
  /// without direct boot, a user is unlocked as soon as it starts.
  ///
  /// When a user is locked, only device-protected data storage is available.
  /// When a user is unlocked, both device-protected and credential-protected
  /// private app data storage is available.
  ///@see Intent\#ACTION_USER_UNLOCKED
  ///@see Context\#createDeviceProtectedStorageContext()
  bool isUserUnlocked() => _isUserUnlocked(reference) != 0;

  static final _isUserUnlocked_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_UserManager_isUserUnlocked_1")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isUserUnlocked(android.os.UserHandle user)
  /// Return whether the given user is running in an "unlocked" state.
  ///
  /// On devices with direct boot, a user is unlocked only after they've
  /// entered their credentials (such as a lock pattern or PIN). On devices
  /// without direct boot, a user is unlocked as soon as it starts.
  ///
  /// When a user is locked, only device-protected data storage is available.
  /// When a user is unlocked, both device-protected and credential-protected
  /// private app data storage is available.
  /// Requires {@code android.permission.MANAGE_USERS} or
  /// {@code android.permission.INTERACT_ACROSS_USERS}, otherwise specified UserHandle user
  /// must be the calling user or a managed profile associated with it.
  ///@param user to retrieve the unlocked state for.
  ///@see Intent\#ACTION_USER_UNLOCKED
  ///@see Context\#createDeviceProtectedStorageContext()
  bool isUserUnlocked_1(UserHandle user) =>
      _isUserUnlocked_1(reference, user.reference) != 0;

  static final _getUserRestrictions = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_UserManager_getUserRestrictions")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getUserRestrictions()
  /// Returns the user-wide restrictions imposed on this user.
  ///@return a Bundle containing all the restrictions.
  Bundle getUserRestrictions() =>
      Bundle.fromRef(_getUserRestrictions(reference));

  static final _getUserRestrictions_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_UserManager_getUserRestrictions_1")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getUserRestrictions(android.os.UserHandle userHandle)
  /// Returns the user-wide restrictions imposed on the user specified by <code>userHandle</code>.
  ///@param userHandle the UserHandle of the user for whom to retrieve the restrictions.
  ///@return a Bundle containing all the restrictions.
  Bundle getUserRestrictions_1(UserHandle userHandle) =>
      Bundle.fromRef(_getUserRestrictions_1(reference, userHandle.reference));

  static final _setUserRestrictions = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_UserManager_setUserRestrictions")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setUserRestrictions(android.os.Bundle restrictions)
  /// This will no longer work.  Device owners and profile owners should use
  /// DevicePolicyManager\#addUserRestriction(ComponentName, String) instead.
  void setUserRestrictions(Bundle restrictions) =>
      _setUserRestrictions(reference, restrictions.reference);

  static final _setUserRestrictions_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_UserManager_setUserRestrictions_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setUserRestrictions(android.os.Bundle restrictions, android.os.UserHandle userHandle)
  /// This will no longer work.  Device owners and profile owners should use
  /// DevicePolicyManager\#addUserRestriction(ComponentName, String) instead.
  void setUserRestrictions_1(Bundle restrictions, UserHandle userHandle) =>
      _setUserRestrictions_1(
          reference, restrictions.reference, userHandle.reference);

  static final _setUserRestriction = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("android_os_UserManager_setUserRestriction")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setUserRestriction(java.lang.String key, boolean value)
  /// Sets the value of a specific restriction.
  /// Requires the MANAGE_USERS permission.
  ///@param key the key of the restriction
  ///@param value the value for the restriction
  ///@deprecated use android.app.admin.DevicePolicyManager\#addUserRestriction(
  /// android.content.ComponentName, String) or
  /// android.app.admin.DevicePolicyManager\#clearUserRestriction(
  /// android.content.ComponentName, String) instead.
  void setUserRestriction(jni.JlString key, bool value) =>
      _setUserRestriction(reference, key.reference, value ? 1 : 0);

  static final _hasUserRestriction = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_UserManager_hasUserRestriction")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasUserRestriction(java.lang.String restrictionKey)
  /// Returns whether the current user has been disallowed from performing certain actions
  /// or setting certain settings.
  ///@param restrictionKey The string key representing the restriction.
  ///@return {@code true} if the current user has the given restriction, {@code false} otherwise.
  bool hasUserRestriction(jni.JlString restrictionKey) =>
      _hasUserRestriction(reference, restrictionKey.reference) != 0;

  static final _getSerialNumberForUser = jlookup<
              ffi.NativeFunction<
                  ffi.Int64 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_UserManager_getSerialNumberForUser")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public long getSerialNumberForUser(android.os.UserHandle user)
  /// Return the serial number for a user.  This is a device-unique
  /// number assigned to that user; if the user is deleted and then a new
  /// user created, the new users will not be given the same serial number.
  ///@param user The user whose serial number is to be retrieved.
  ///@return The serial number of the given user; returns -1 if the
  /// given UserHandle does not exist.
  ///@see \#getUserForSerialNumber(long)
  int getSerialNumberForUser(UserHandle user) =>
      _getSerialNumberForUser(reference, user.reference);

  static final _getUserForSerialNumber = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_os_UserManager_getUserForSerialNumber")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.os.UserHandle getUserForSerialNumber(long serialNumber)
  /// Return the user associated with a serial number previously
  /// returned by \#getSerialNumberForUser(UserHandle).
  ///@param serialNumber The serial number of the user that is being
  /// retrieved.
  ///@return Return the user associated with the serial number, or null
  /// if there is not one.
  ///@see \#getSerialNumberForUser(UserHandle)
  UserHandle getUserForSerialNumber(int serialNumber) =>
      UserHandle.fromRef(_getUserForSerialNumber(reference, serialNumber));

  static final _createUserCreationIntent = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "android_os_UserManager_createUserCreationIntent")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.Intent createUserCreationIntent(java.lang.String userName, java.lang.String accountName, java.lang.String accountType, android.os.PersistableBundle accountOptions)
  /// Returns an intent to create a user for the provided name and account name. The name
  /// and account name will be used when the setup process for the new user is started.
  ///
  /// The intent should be launched using startActivityForResult and the return result will
  /// indicate if the user consented to adding a new user and if the operation succeeded. Any
  /// errors in creating the user will be returned in the result code. If the user cancels the
  /// request, the return result will be Activity\#RESULT_CANCELED. On success, the
  /// result code will be Activity\#RESULT_OK.
  ///
  /// Use \#supportsMultipleUsers() to first check if the device supports this operation
  /// at all.
  ///
  /// The new user is created but not initialized. After switching into the user for the first
  /// time, the preferred user name and account information are used by the setup process for that
  /// user.
  ///@param userName Optional name to assign to the user.
  /// This value may be {@code null}.
  ///@param accountName Optional account name that will be used by the setup wizard to initialize
  ///                    the user.
  /// This value may be {@code null}.
  ///@param accountType Optional account type for the account to be created. This is required
  ///                    if the account name is specified.
  /// This value may be {@code null}.
  ///@param accountOptions Optional bundle of data to be passed in during account creation in the
  ///                       new user via AccountManager\#addAccount(String, String, String[],
  ///                       Bundle, android.app.Activity, android.accounts.AccountManagerCallback,
  ///                       Handler).
  /// This value may be {@code null}.
  ///@return An Intent that can be launched from an Activity.
  ///@see \#USER_CREATION_FAILED_NOT_PERMITTED
  ///@see \#USER_CREATION_FAILED_NO_MORE_USERS
  ///@see \#supportsMultipleUsers
  static content.Intent createUserCreationIntent(
          jni.JlString userName,
          jni.JlString accountName,
          jni.JlString accountType,
          PersistableBundle accountOptions) =>
      content.Intent.fromRef(_createUserCreationIntent(
          userName.reference,
          accountName.reference,
          accountType.reference,
          accountOptions.reference));

  static final _getUserCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_UserManager_getUserCount")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getUserCount()
  /// Return the number of users currently created on the device.
  int getUserCount() => _getUserCount(reference);

  static final _getUserProfiles = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_UserManager_getUserProfiles")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.os.UserHandle> getUserProfiles()
  /// Returns a list of UserHandles for profiles associated with the user that the calling process
  /// is running on, including the user itself.
  ///@return A non-empty list of UserHandles associated with the calling user.
  jni.JlObject getUserProfiles() =>
      jni.JlObject.fromRef(_getUserProfiles(reference));

  static final _requestQuietModeEnabled = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                      ffi.Pointer<ffi.Void>)>>(
          "android_os_UserManager_requestQuietModeEnabled")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean requestQuietModeEnabled(boolean enableQuietMode, android.os.UserHandle userHandle)
  /// Enables or disables quiet mode for a managed profile. If quiet mode is enabled, apps in a
  /// managed profile don't run, generate notifications, or consume data or battery.
  ///
  /// If a user's credential is needed to turn off quiet mode, a confirm credential screen will be
  /// shown to the user.
  ///
  /// The change may not happen instantly, however apps can listen for
  /// Intent\#ACTION_MANAGED_PROFILE_AVAILABLE and
  /// Intent\#ACTION_MANAGED_PROFILE_UNAVAILABLE broadcasts in order to be notified of
  /// the change of the quiet mode. Apps can also check the current state of quiet mode by
  /// calling \#isQuietModeEnabled(UserHandle).
  ///
  /// The caller must either be the foreground default launcher or have one of these permissions:
  /// {@code MANAGE_USERS} or {@code MODIFY_QUIET_MODE}.
  ///@param enableQuietMode whether quiet mode should be enabled or disabled
  ///@param userHandle user handle of the profile
  /// This value must never be {@code null}.
  ///@return {@code false} if user's credential is needed in order to turn off quiet mode,
  ///         {@code true} otherwise
  ///@throws SecurityException if the caller is invalid
  ///@throws IllegalArgumentException if {@code userHandle} is not a managed profile
  ///@see \#isQuietModeEnabled(UserHandle)
  bool requestQuietModeEnabled(bool enableQuietMode, UserHandle userHandle) =>
      _requestQuietModeEnabled(
          reference, enableQuietMode ? 1 : 0, userHandle.reference) !=
      0;

  static final _isQuietModeEnabled = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_UserManager_isQuietModeEnabled")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isQuietModeEnabled(android.os.UserHandle userHandle)
  /// Returns whether the given profile is in quiet mode or not.
  /// Notes: Quiet mode is only supported for managed profiles.
  ///@param userHandle The user handle of the profile to be queried.
  ///@return true if the profile is in quiet mode, false otherwise.
  bool isQuietModeEnabled(UserHandle userHandle) =>
      _isQuietModeEnabled(reference, userHandle.reference) != 0;

  static final _getApplicationRestrictions = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_UserManager_getApplicationRestrictions")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getApplicationRestrictions(java.lang.String packageName)
  /// Returns a Bundle containing any saved application restrictions for this user, for the
  /// given package name. Only an application with this package name can call this method.
  ///
  /// The returned Bundle consists of key-value pairs, as defined by the application,
  /// where the types of values may be:
  /// <ul>
  /// <li>{@code boolean}
  /// <li>{@code int}
  /// <li>{@code String} or {@code String[]}
  /// <li>From android.os.Build.VERSION_CODES\#M, {@code Bundle} or {@code Bundle[]}
  /// </ul>
  ///
  /// NOTE: The method performs disk I/O and shouldn't be called on the main thread
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param packageName the package name of the calling application
  ///@return a Bundle with the restrictions for that package, or an empty Bundle
  /// if there are no saved restrictions.
  ///@see \#KEY_RESTRICTIONS_PENDING
  Bundle getApplicationRestrictions(jni.JlString packageName) => Bundle.fromRef(
      _getApplicationRestrictions(reference, packageName.reference));

  static final _setRestrictionsChallenge = jlookup<
              ffi.NativeFunction<
                  ffi.Uint8 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_UserManager_setRestrictionsChallenge")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean setRestrictionsChallenge(java.lang.String newPin)
  /// Sets a new challenge PIN for restrictions. This is only for use by pre-installed
  /// apps and requires the MANAGE_USERS permission.
  ///@param newPin the PIN to use for challenge dialogs.
  ///@return Returns true if the challenge PIN was set successfully.
  ///@deprecated The restrictions PIN functionality is no longer provided by the system.
  /// This method is preserved for backwards compatibility reasons and always returns false.
  bool setRestrictionsChallenge(jni.JlString newPin) =>
      _setRestrictionsChallenge(reference, newPin.reference) != 0;

  static final _getUserCreationTime = jlookup<
              ffi.NativeFunction<
                  ffi.Int64 Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_UserManager_getUserCreationTime")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public long getUserCreationTime(android.os.UserHandle userHandle)
  /// Returns creation time of the user or of a managed profile associated with the calling user.
  ///@param userHandle user handle of the user or a managed profile associated with the
  ///                   calling user.
  ///@return creation time in milliseconds since Epoch time.
  int getUserCreationTime(UserHandle userHandle) =>
      _getUserCreationTime(reference, userHandle.reference);
}

/// Thrown to indicate user operation failed.
class UserManager_UserOperationException extends jni.JlObject {
  UserManager_UserOperationException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_os_UserManager__UserOperationException_new")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: void <init>(java.lang.String message, int userOperationResult)
  /// Constructs a UserOperationException with specific result code.
  ///@param message the detail message
  ///@param userOperationResult the result code
  ///@hide
  UserManager_UserOperationException(
      jni.JlString message, int userOperationResult)
      : super.fromRef(_ctor(message.reference, userOperationResult));

  static final _getUserOperationResult = jlookup<
              ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_UserManager__UserOperationException_getUserOperationResult")
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getUserOperationResult()
  /// Returns the operation result code.
  ///@return Value is android.os.UserManager\#USER_OPERATION_SUCCESS, android.os.UserManager\#USER_OPERATION_ERROR_UNKNOWN, android.os.UserManager\#USER_OPERATION_ERROR_MANAGED_PROFILE, android.os.UserManager\#USER_OPERATION_ERROR_MAX_RUNNING_USERS, android.os.UserManager\#USER_OPERATION_ERROR_CURRENT_USER, android.os.UserManager\#USER_OPERATION_ERROR_LOW_STORAGE, or android.os.UserManager\#USER_OPERATION_ERROR_MAX_USERS
  int getUserOperationResult() => _getUserOperationResult(reference);
}

/// Callback that handles file system requests from ProxyFileDescriptor.
///
/// All callback methods except for onRelease should throw android.system.ErrnoException
/// with proper errno on errors. See
/// <a href="http://man7.org/linux/man-pages/man3/errno.3.html">errno(3)</a> and
/// android.system.OsConstants.
///
/// Typical errnos are
///
/// <ul>
/// <li>android.system.OsConstants\#EIO for general I/O issues
/// <li>android.system.OsConstants\#ENOENT when the file is not found
/// <li>android.system.OsConstants\#EBADF if the file doesn't allow read/write operations
///     based on how it was opened.  (For example, trying to write a file that was opened read-only.)
/// <li>android.system.OsConstants\#ENOSPC if you cannot handle a write operation to
///     space/quota limitations.
/// </ul>
///@see android.os.storage.StorageManager\#openProxyFileDescriptor(int, ProxyFileDescriptorCallback,
///     Handler)
class ProxyFileDescriptorCallback extends jni.JlObject {
  ProxyFileDescriptorCallback.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_ProxyFileDescriptorCallback_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  ProxyFileDescriptorCallback() : super.fromRef(_ctor());

  static final _onGetSize =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ProxyFileDescriptorCallback_onGetSize")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long onGetSize()
  /// Returns size of bytes provided by the file descriptor.
  ///@return Size of bytes.
  ///@throws ErrnoException ErrnoException containing E constants in OsConstants.
  int onGetSize() => _onGetSize(reference);

  static final _onRead = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_os_ProxyFileDescriptorCallback_onRead")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public int onRead(long offset, int size, byte[] data)
  /// Provides bytes read from file descriptor.
  /// It needs to return exact requested size of bytes unless it reaches file end.
  ///@param offset Offset in bytes from the file head specifying where to read bytes. If a seek
  ///     operation is conducted on the file descriptor, then a read operation is requested, the
  ///     offset refrects the proper position of requested bytes.
  ///@param size Size for read bytes.
  ///@param data Byte array to store read bytes.
  ///@return Size of bytes returned by the function.
  ///@throws ErrnoException ErrnoException containing E constants in OsConstants.
  int onRead(int offset, int size, jni.JlObject data) =>
      _onRead(reference, offset, size, data.reference);

  static final _onWrite = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "android_os_ProxyFileDescriptorCallback_onWrite")
      .asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public int onWrite(long offset, int size, byte[] data)
  /// Handles bytes written to file descriptor.
  ///@param offset Offset in bytes from the file head specifying where to write bytes. If a seek
  ///     operation is conducted on the file descriptor, then a write operation is requested, the
  ///     offset refrects the proper position of requested bytes.
  ///@param size Size for write bytes.
  ///@param data Byte array to be written to somewhere.
  ///@return Size of bytes processed by the function.
  ///@throws ErrnoException ErrnoException containing E constants in OsConstants.
  int onWrite(int offset, int size, jni.JlObject data) =>
      _onWrite(reference, offset, size, data.reference);

  static final _onFsync =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ProxyFileDescriptorCallback_onFsync")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onFsync()
  /// Ensures all the written data are stored in permanent storage device.
  /// For example, if it has data stored in on memory cache, it needs to flush data to storage
  /// device.
  ///@throws ErrnoException ErrnoException containing E constants in OsConstants.
  void onFsync() => _onFsync(reference);

  static final _onRelease =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_ProxyFileDescriptorCallback_onRelease")
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onRelease()
  /// Invoked after the file is closed.
  void onRelease() => _onRelease(reference);
}

/// A mapping from String keys to values of various types. The set of types
/// supported by this class is purposefully restricted to simple objects that can
/// safely be persisted to and restored from disk.
///@see Bundle
class PersistableBundle extends BaseBundle {
  PersistableBundle.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.os.PersistableBundle> CREATOR
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_PersistableBundle_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static Parcelable_Creator get CREATOR =>
      Parcelable_Creator.fromRef(_getCREATOR());

  /// from: static public final android.os.PersistableBundle EMPTY
  static final _getEMPTY =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_PersistableBundle_EMPTY")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static PersistableBundle get EMPTY => PersistableBundle.fromRef(_getEMPTY());

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_PersistableBundle_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Constructs a new, empty PersistableBundle.
  PersistableBundle() : super.fromRef(_ctor());

  static final _ctor_1 =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int32)>>(
              "android_os_PersistableBundle_new_1")
          .asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// from: public void <init>(int capacity)
  /// Constructs a new, empty PersistableBundle sized to hold the given number of
  /// elements. The PersistableBundle will grow as needed.
  ///@param capacity the initial capacity of the PersistableBundle
  PersistableBundle.ctor_1(int capacity) : super.fromRef(_ctor_1(capacity));

  static final _ctor_2 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_PersistableBundle_new_2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.PersistableBundle b)
  /// Constructs a PersistableBundle containing a copy of the mappings from the given
  /// PersistableBundle.  Does only a shallow copy of the original PersistableBundle -- see
  /// \#deepCopy() if that is not what you want.
  ///@param b a PersistableBundle to be copied.
  ///@see \#deepCopy()
  PersistableBundle.ctor_2(PersistableBundle b)
      : super.fromRef(_ctor_2(b.reference));

  static final _clone = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_PersistableBundle_clone")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object clone()
  /// Clones the current PersistableBundle. The internal map is cloned, but the keys and
  /// values to which it refers are copied by reference.
  jni.JlObject clone() => jni.JlObject.fromRef(_clone(reference));

  static final _deepCopy = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_PersistableBundle_deepCopy")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.PersistableBundle deepCopy()
  /// Make a deep copy of the given bundle.  Traverses into inner containers and copies
  /// them as well, so they are not shared across bundles.  Will traverse in to
  /// Bundle, PersistableBundle, ArrayList, and all types of
  /// primitive arrays.  Other types of objects (such as Parcelable or Serializable)
  /// are referenced as-is and not copied in any way.
  PersistableBundle deepCopy() =>
      PersistableBundle.fromRef(_deepCopy(reference));

  static final _putPersistableBundle = jlookup<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_PersistableBundle_putPersistableBundle")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void putPersistableBundle(java.lang.String key, android.os.PersistableBundle value)
  /// Inserts a PersistableBundle value into the mapping of this Bundle, replacing
  /// any existing value for the given key.  Either key or value may be null.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@param value a Bundle object, or null
  ///
  /// This value may be {@code null}.
  void putPersistableBundle(jni.JlString key, PersistableBundle value) =>
      _putPersistableBundle(reference, key.reference, value.reference);

  static final _getPersistableBundle = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_PersistableBundle_getPersistableBundle")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.PersistableBundle getPersistableBundle(java.lang.String key)
  /// Returns the value associated with the given key, or null if
  /// no mapping of the desired type exists for the given key or a null
  /// value is explicitly associated with the key.
  ///@param key a String, or null
  /// This value may be {@code null}.
  ///@return a Bundle value, or null
  PersistableBundle getPersistableBundle(jni.JlString key) =>
      PersistableBundle.fromRef(
          _getPersistableBundle(reference, key.reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_PersistableBundle_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  /// Report the nature of this Parcelable's contents
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_PersistableBundle_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  /// Writes the PersistableBundle contents to a Parcel, typically in order for
  /// it to be passed through an IBinder connection.
  ///@param parcel The parcel to copy this bundle to.
  void writeToParcel(Parcel parcel, int flags) =>
      _writeToParcel(reference, parcel.reference, flags);

  static final _toString_1 = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_PersistableBundle_toString_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: synchronized public java.lang.String toString()
  jni.JlString toString_1() => jni.JlString.fromRef(_toString_1(reference));
}

/// Tools for managing OS processes.
class Process extends jni.JlObject {
  Process.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int FIRST_APPLICATION_UID
  /// Defines the start of a range of UIDs (and GIDs), going from this
  /// number to \#LAST_APPLICATION_UID that are reserved for assigning
  /// to applications.
  static const FIRST_APPLICATION_UID = 10000;

  /// from: static public final int LAST_APPLICATION_UID
  /// Last of application-specific UIDs starting at
  /// \#FIRST_APPLICATION_UID.
  static const LAST_APPLICATION_UID = 19999;

  /// from: static public final int PHONE_UID
  /// Defines the UID/GID under which the telephony code runs.
  static const PHONE_UID = 1001;

  /// from: static public final int SIGNAL_KILL
  static const SIGNAL_KILL = 9;

  /// from: static public final int SIGNAL_QUIT
  static const SIGNAL_QUIT = 3;

  /// from: static public final int SIGNAL_USR1
  static const SIGNAL_USR1 = 10;

  /// from: static public final int SYSTEM_UID
  /// Defines the UID/GID under which system code runs.
  static const SYSTEM_UID = 1000;

  /// from: static public final int THREAD_PRIORITY_AUDIO
  /// Standard priority of audio threads.  Applications can not normally
  /// change to this priority.
  /// Use with \#setThreadPriority(int) and
  /// \#setThreadPriority(int, int), __not__ with the normal
  /// java.lang.Thread class.
  static const THREAD_PRIORITY_AUDIO = -16;

  /// from: static public final int THREAD_PRIORITY_BACKGROUND
  /// Standard priority background threads.  This gives your thread a slightly
  /// lower than normal priority, so that it will have less chance of impacting
  /// the responsiveness of the user interface.
  /// Use with \#setThreadPriority(int) and
  /// \#setThreadPriority(int, int), __not__ with the normal
  /// java.lang.Thread class.
  static const THREAD_PRIORITY_BACKGROUND = 10;

  /// from: static public final int THREAD_PRIORITY_DEFAULT
  /// Standard priority of application threads.
  /// Use with \#setThreadPriority(int) and
  /// \#setThreadPriority(int, int), __not__ with the normal
  /// java.lang.Thread class.
  static const THREAD_PRIORITY_DEFAULT = 0;

  /// from: static public final int THREAD_PRIORITY_DISPLAY
  /// Standard priority of system display threads, involved in updating
  /// the user interface.  Applications can not
  /// normally change to this priority.
  /// Use with \#setThreadPriority(int) and
  /// \#setThreadPriority(int, int), __not__ with the normal
  /// java.lang.Thread class.
  static const THREAD_PRIORITY_DISPLAY = -4;

  /// from: static public final int THREAD_PRIORITY_FOREGROUND
  /// Standard priority of threads that are currently running a user interface
  /// that the user is interacting with.  Applications can not normally
  /// change to this priority; the system will automatically adjust your
  /// application threads as the user moves through the UI.
  /// Use with \#setThreadPriority(int) and
  /// \#setThreadPriority(int, int), __not__ with the normal
  /// java.lang.Thread class.
  static const THREAD_PRIORITY_FOREGROUND = -2;

  /// from: static public final int THREAD_PRIORITY_LESS_FAVORABLE
  /// Minimum increment to make a priority less favorable.
  static const THREAD_PRIORITY_LESS_FAVORABLE = 1;

  /// from: static public final int THREAD_PRIORITY_LOWEST
  /// Lowest available thread priority.  Only for those who really, really
  /// don't want to run if anything else is happening.
  /// Use with \#setThreadPriority(int) and
  /// \#setThreadPriority(int, int), __not__ with the normal
  /// java.lang.Thread class.
  static const THREAD_PRIORITY_LOWEST = 19;

  /// from: static public final int THREAD_PRIORITY_MORE_FAVORABLE
  /// Minimum increment to make a priority more favorable.
  static const THREAD_PRIORITY_MORE_FAVORABLE = -1;

  /// from: static public final int THREAD_PRIORITY_URGENT_AUDIO
  /// Standard priority of the most important audio threads.
  /// Applications can not normally change to this priority.
  /// Use with \#setThreadPriority(int) and
  /// \#setThreadPriority(int, int), __not__ with the normal
  /// java.lang.Thread class.
  static const THREAD_PRIORITY_URGENT_AUDIO = -19;

  /// from: static public final int THREAD_PRIORITY_URGENT_DISPLAY
  /// Standard priority of the most important display threads, for compositing
  /// the screen and retrieving input events.  Applications can not normally
  /// change to this priority.
  /// Use with \#setThreadPriority(int) and
  /// \#setThreadPriority(int, int), __not__ with the normal
  /// java.lang.Thread class.
  static const THREAD_PRIORITY_URGENT_DISPLAY = -8;

  /// from: static public final int THREAD_PRIORITY_VIDEO
  /// Standard priority of video threads.  Applications can not normally
  /// change to this priority.
  /// Use with \#setThreadPriority(int) and
  /// \#setThreadPriority(int, int), __not__ with the normal
  /// java.lang.Thread class.
  static const THREAD_PRIORITY_VIDEO = -10;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Process_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  Process() : super.fromRef(_ctor());

  static final _getElapsedCpuTime =
      jlookup<ffi.NativeFunction<ffi.Int64 Function()>>(
              "android_os_Process_getElapsedCpuTime")
          .asFunction<int Function()>();

  /// from: static public native final long getElapsedCpuTime()
  /// Returns elapsed milliseconds of the time this process has run.
  ///@return Returns the number of milliseconds this process has return.
  static int getElapsedCpuTime() => _getElapsedCpuTime();

  static final _getStartElapsedRealtime =
      jlookup<ffi.NativeFunction<ffi.Int64 Function()>>(
              "android_os_Process_getStartElapsedRealtime")
          .asFunction<int Function()>();

  /// from: static public final long getStartElapsedRealtime()
  /// Return the SystemClock\#elapsedRealtime() at which this process was started.
  static int getStartElapsedRealtime() => _getStartElapsedRealtime();

  static final _getStartUptimeMillis =
      jlookup<ffi.NativeFunction<ffi.Int64 Function()>>(
              "android_os_Process_getStartUptimeMillis")
          .asFunction<int Function()>();

  /// from: static public final long getStartUptimeMillis()
  /// Return the SystemClock\#uptimeMillis() at which this process was started.
  static int getStartUptimeMillis() => _getStartUptimeMillis();

  static final _is64Bit = jlookup<ffi.NativeFunction<ffi.Uint8 Function()>>(
          "android_os_Process_is64Bit")
      .asFunction<int Function()>();

  /// from: static public final boolean is64Bit()
  /// Returns true if the current process is a 64-bit runtime.
  static bool is64Bit() => _is64Bit() != 0;

  static final _myPid = jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          "android_os_Process_myPid")
      .asFunction<int Function()>();

  /// from: static public final int myPid()
  /// Returns the identifier of this process, which can be used with
  /// \#killProcess and \#sendSignal.
  static int myPid() => _myPid();

  static final _myTid = jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          "android_os_Process_myTid")
      .asFunction<int Function()>();

  /// from: static public final int myTid()
  /// Returns the identifier of the calling thread, which be used with
  /// \#setThreadPriority(int, int).
  static int myTid() => _myTid();

  static final _myUid = jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          "android_os_Process_myUid")
      .asFunction<int Function()>();

  /// from: static public final int myUid()
  /// Returns the identifier of this process's uid.  This is the kernel uid
  /// that the process is running under, which is the identity of its
  /// app-specific sandbox.  It is different from \#myUserHandle in that
  /// a uid identifies a specific app sandbox in a specific user.
  static int myUid() => _myUid();

  static final _myUserHandle =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Process_myUserHandle")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public android.os.UserHandle myUserHandle()
  /// Returns this process's user handle.  This is the
  /// user the process is running under.  It is distinct from
  /// \#myUid() in that a particular user will have multiple
  /// distinct apps running under it each with their own uid.
  static UserHandle myUserHandle() => UserHandle.fromRef(_myUserHandle());

  static final _isApplicationUid =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Int32)>>(
              "android_os_Process_isApplicationUid")
          .asFunction<int Function(int)>();

  /// from: static public boolean isApplicationUid(int uid)
  /// Returns whether the given uid belongs to an application.
  ///@param uid A kernel uid.
  ///@return Whether the uid corresponds to an application sandbox running in
  ///     a specific user.
  static bool isApplicationUid(int uid) => _isApplicationUid(uid) != 0;

  static final _isIsolated = jlookup<ffi.NativeFunction<ffi.Uint8 Function()>>(
          "android_os_Process_isIsolated")
      .asFunction<int Function()>();

  /// from: static public final boolean isIsolated()
  /// Returns whether the current process is in an isolated sandbox.
  static bool isIsolated() => _isIsolated() != 0;

  static final _getUidForName =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Process_getUidForName")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public native final int getUidForName(java.lang.String name)
  /// Returns the UID assigned to a particular user name, or -1 if there is
  /// none.  If the given string consists of only numbers, it is converted
  /// directly to a uid.
  static int getUidForName(jni.JlString name) => _getUidForName(name.reference);

  static final _getGidForName =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Process_getGidForName")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public native final int getGidForName(java.lang.String name)
  /// Returns the GID assigned to a particular user name, or -1 if there is
  /// none.  If the given string consists of only numbers, it is converted
  /// directly to a gid.
  static int getGidForName(jni.JlString name) => _getGidForName(name.reference);

  static final _setThreadPriority =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32, ffi.Int32)>>(
              "android_os_Process_setThreadPriority")
          .asFunction<void Function(int, int)>();

  /// from: static public native final void setThreadPriority(int tid, int priority)
  /// Set the priority of a thread, based on Linux priorities.
  ///@param tid The identifier of the thread/process to change.
  ///@param priority A Linux priority level, from -20 for highest scheduling
  /// priority to 19 for lowest scheduling priority.
  ///@throws IllegalArgumentException Throws IllegalArgumentException if
  /// <var>tid</var> does not exist.
  ///@throws SecurityException Throws SecurityException if your process does
  /// not have permission to modify the given thread, or to use the given
  /// priority.
  static void setThreadPriority(int tid, int priority) =>
      _setThreadPriority(tid, priority);

  static final _getExclusiveCores =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Process_getExclusiveCores")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public native final int[] getExclusiveCores()
  /// On some devices, the foreground process may have one or more CPU
  /// cores exclusively reserved for it. This method can be used to
  /// retrieve which cores that are (if any), so the calling process
  /// can then use sched_setaffinity() to lock a thread to these cores.
  /// Note that the calling process must currently be running in the
  /// foreground for this method to return any cores.
  ///
  /// The CPU core(s) exclusively reserved for the foreground process will
  /// stay reserved for as long as the process stays in the foreground.
  ///
  /// As soon as a process leaves the foreground, those CPU cores will
  /// no longer be reserved for it, and will most likely be reserved for
  /// the new foreground process. It's not necessary to change the affinity
  /// of your process when it leaves the foreground (if you had previously
  /// set it to use a reserved core); the OS will automatically take care
  /// of resetting the affinity at that point.
  ///@return an array of integers, indicating the CPU cores exclusively
  /// reserved for this process. The array will have length zero if no
  /// CPU cores are exclusively reserved for this process at this point
  /// in time.
  static jni.JlObject getExclusiveCores() =>
      jni.JlObject.fromRef(_getExclusiveCores());

  static final _setThreadPriority_1 =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
              "android_os_Process_setThreadPriority_1")
          .asFunction<void Function(int)>();

  /// from: static public native final void setThreadPriority(int priority)
  /// Set the priority of the calling thread, based on Linux priorities.  See
  /// \#setThreadPriority(int, int) for more information.
  ///@param priority A Linux priority level, from -20 for highest scheduling
  /// priority to 19 for lowest scheduling priority.
  ///@throws IllegalArgumentException Throws IllegalArgumentException if
  /// <var>tid</var> does not exist.
  ///@throws SecurityException Throws SecurityException if your process does
  /// not have permission to modify the given thread, or to use the given
  /// priority.
  ///@see \#setThreadPriority(int, int)
  static void setThreadPriority_1(int priority) =>
      _setThreadPriority_1(priority);

  static final _getThreadPriority =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
              "android_os_Process_getThreadPriority")
          .asFunction<int Function(int)>();

  /// from: static public native final int getThreadPriority(int tid)
  /// Return the current priority of a thread, based on Linux priorities.
  ///@param tid The identifier of the thread/process. If tid equals zero, the priority of the
  /// calling process/thread will be returned.
  ///@return Returns the current priority, as a Linux priority level,
  /// from -20 for highest scheduling priority to 19 for lowest scheduling
  /// priority.
  ///@throws IllegalArgumentException Throws IllegalArgumentException if
  /// <var>tid</var> does not exist.
  static int getThreadPriority(int tid) => _getThreadPriority(tid);

  static final _supportsProcesses =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function()>>(
              "android_os_Process_supportsProcesses")
          .asFunction<int Function()>();

  /// from: static public final boolean supportsProcesses()
  /// Determine whether the current environment supports multiple processes.
  ///@return Returns true if the system can run in multiple processes, else
  /// false if everything is running in a single process.
  ///@deprecated This method always returns true.  Do not use.
  static bool supportsProcesses() => _supportsProcesses() != 0;

  static final _killProcess =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>(
              "android_os_Process_killProcess")
          .asFunction<void Function(int)>();

  /// from: static public final void killProcess(int pid)
  /// Kill the process with the given PID.
  /// Note that, though this API allows us to request to
  /// kill any process based on its PID, the kernel will
  /// still impose standard restrictions on which PIDs you
  /// are actually able to kill.  Typically this means only
  /// the process running the caller's packages/application
  /// and any additional processes created by that app; packages
  /// sharing a common UID will also be able to kill each
  /// other's processes.
  static void killProcess(int pid) => _killProcess(pid);

  static final _sendSignal =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Int32, ffi.Int32)>>(
              "android_os_Process_sendSignal")
          .asFunction<void Function(int, int)>();

  /// from: static public native final void sendSignal(int pid, int signal)
  /// Send a signal to the given process.
  ///@param pid The pid of the target process.
  ///@param signal The signal to send.
  static void sendSignal(int pid, int signal) => _sendSignal(pid, signal);
}

/// Core timekeeping facilities.
///
///  Three different clocks are available, and they should not be confused:
///
/// <ul>
///     <li>  System\#currentTimeMillis System.currentTimeMillis()
///     is the standard "wall" clock (time and date) expressing milliseconds
///     since the epoch.  The wall clock can be set by the user or the phone
///     network (see \#setCurrentTimeMillis), so the time may jump
///     backwards or forwards unpredictably.  This clock should only be used
///     when correspondence with real-world dates and times is important, such
///     as in a calendar or alarm clock application.  Interval or elapsed
///     time measurements should use a different clock.  If you are using
///     System.currentTimeMillis(), consider listening to the
///     android.content.Intent\#ACTION_TIME_TICK ACTION_TIME_TICK,
///     android.content.Intent\#ACTION_TIME_CHANGED ACTION_TIME_CHANGED
///     and android.content.Intent\#ACTION_TIMEZONE_CHANGED ACTION_TIMEZONE_CHANGED android.content.Intent Intent
///     broadcasts to find out when the time changes.
///
///     <li>  \#uptimeMillis is counted in milliseconds since the
///     system was booted.  This clock stops when the system enters deep
///     sleep (CPU off, display dark, device waiting for external input),
///     but is not affected by clock scaling, idle, or other power saving
///     mechanisms.  This is the basis for most interval timing
///     such as Thread\#sleep(long) Thread.sleep(millls),
///     Object\#wait(long) Object.wait(millis), and
///     System\#nanoTime System.nanoTime().  This clock is guaranteed
///     to be monotonic, and is suitable for interval timing when the
///     interval does not span device sleep.  Most methods that accept a
///     timestamp value currently expect the \#uptimeMillis clock.
///
///     <li>  \#elapsedRealtime and \#elapsedRealtimeNanos
///     return the time since the system was booted, and include deep sleep.
///     This clock is guaranteed to be monotonic, and continues to tick even
///     when the CPU is in power saving modes, so is the recommend basis
///     for general purpose interval timing.
///
/// </ul>
///
/// There are several mechanisms for controlling the timing of events:
///
/// <ul>
///     <li>  Standard functions like Thread\#sleep(long) Thread.sleep(millis) and Object\#wait(long) Object.wait(millis)
///     are always available.  These functions use the \#uptimeMillis
///     clock; if the device enters sleep, the remainder of the time will be
///     postponed until the device wakes up.  These synchronous functions may
///     be interrupted with Thread\#interrupt Thread.interrupt(), and
///     you must handle InterruptedException.
///
///     <li>  \#sleep SystemClock.sleep(millis) is a utility function
///     very similar to Thread\#sleep(long) Thread.sleep(millis), but it
///     ignores InterruptedException.  Use this function for delays if
///     you do not use Thread\#interrupt Thread.interrupt(), as it will
///     preserve the interrupted state of the thread.
///
///     <li>  The android.os.Handler class can schedule asynchronous
///     callbacks at an absolute or relative time.  Handler objects also use the
///     \#uptimeMillis clock, and require an android.os.Looper event loop (normally present in any GUI application).
///
///     <li>  The android.app.AlarmManager can trigger one-time or
///     recurring events which occur even when the device is in deep sleep
///     or your application is not running.  Events may be scheduled with your
///     choice of java.lang.System\#currentTimeMillis (RTC) or
///     \#elapsedRealtime (ELAPSED_REALTIME), and cause an
///     android.content.Intent broadcast when they occur.
/// </ul>
class SystemClock extends jni.JlObject {
  SystemClock.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_SystemClock_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  /// This class is uninstantiable.
  SystemClock() : super.fromRef(_ctor());

  static final _sleep =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64)>>(
              "android_os_SystemClock_sleep")
          .asFunction<void Function(int)>();

  /// from: static public void sleep(long ms)
  /// Waits a given number of milliseconds (of uptimeMillis) before returning.
  /// Similar to java.lang.Thread\#sleep(long), but does not throw
  /// InterruptedException; Thread\#interrupt() events are
  /// deferred until the next interruptible operation.  Does not return until
  /// at least the specified number of milliseconds has elapsed.
  ///@param ms to sleep before returning, in milliseconds of uptime.
  static void sleep(int ms) => _sleep(ms);

  static final _setCurrentTimeMillis =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Int64)>>(
              "android_os_SystemClock_setCurrentTimeMillis")
          .asFunction<int Function(int)>();

  /// from: static public boolean setCurrentTimeMillis(long millis)
  /// Sets the current wall time, in milliseconds.  Requires the calling
  /// process to have appropriate permissions.
  ///@return if the clock was successfully set to the specified time.
  static bool setCurrentTimeMillis(int millis) =>
      _setCurrentTimeMillis(millis) != 0;

  static final _uptimeMillis =
      jlookup<ffi.NativeFunction<ffi.Int64 Function()>>(
              "android_os_SystemClock_uptimeMillis")
          .asFunction<int Function()>();

  /// from: static public native long uptimeMillis()
  /// Returns milliseconds since boot, not counting time spent in deep sleep.
  ///@return milliseconds of non-sleep uptime since boot.
  static int uptimeMillis() => _uptimeMillis();

  static final _elapsedRealtime =
      jlookup<ffi.NativeFunction<ffi.Int64 Function()>>(
              "android_os_SystemClock_elapsedRealtime")
          .asFunction<int Function()>();

  /// from: static public native long elapsedRealtime()
  /// Returns milliseconds since boot, including time spent in sleep.
  ///@return elapsed milliseconds since boot.
  static int elapsedRealtime() => _elapsedRealtime();

  static final _elapsedRealtimeNanos =
      jlookup<ffi.NativeFunction<ffi.Int64 Function()>>(
              "android_os_SystemClock_elapsedRealtimeNanos")
          .asFunction<int Function()>();

  /// from: static public native long elapsedRealtimeNanos()
  /// Returns nanoseconds since boot, including time spent in sleep.
  ///@return elapsed nanoseconds since boot.
  static int elapsedRealtimeNanos() => _elapsedRealtimeNanos();

  static final _currentThreadTimeMillis =
      jlookup<ffi.NativeFunction<ffi.Int64 Function()>>(
              "android_os_SystemClock_currentThreadTimeMillis")
          .asFunction<int Function()>();

  /// from: static public native long currentThreadTimeMillis()
  /// Returns milliseconds running in the current thread.
  ///@return elapsed milliseconds in the thread
  static int currentThreadTimeMillis() => _currentThreadTimeMillis();
}

/// Base class for a remotable object, the core part of a lightweight
/// remote procedure call mechanism defined by IBinder.
/// This class is an implementation of IBinder that provides
/// standard local implementation of such an object.
///
/// Most developers will not implement this class directly, instead using the
/// <a href="{@docRoot}guide/components/aidl.html">aidl</a> tool to describe the desired
/// interface, having it generate the appropriate Binder subclass.  You can,
/// however, derive directly from Binder to implement your own custom RPC
/// protocol or simply instantiate a raw Binder object directly to use as a
/// token that can be shared across processes.
///
/// This class is just a basic IPC primitive; it has no impact on an application's
/// lifecycle, and is valid only as long as the process that created it continues to run.
/// To use this correctly, you must be doing so within the context of a top-level
/// application component (a android.app.Service, android.app.Activity,
/// or android.content.ContentProvider) that lets the system know your process
/// should remain running.
///
///
/// You must keep in mind the situations in which your process
/// could go away, and thus require that you later re-create a new Binder and re-attach
/// it when the process starts again.  For example, if you are using this within an
/// android.app.Activity, your activity's process may be killed any time the
/// activity is not started; if the activity is later re-created you will need to
/// create a new Binder and hand it back to the correct place again; you need to be
/// aware that your process may be started for another reason (for example to receive
/// a broadcast) that will not involve re-creating the activity and thus run its code
/// to create a new Binder.
///
///@see IBinder
class Binder extends jni.JlObject {
  Binder.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Binder_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Default constructor initializes the object.
  Binder() : super.fromRef(_ctor());

  static final _getCallingPid =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Binder_getCallingPid")
          .asFunction<int Function()>();

  /// from: static public native final int getCallingPid()
  /// Return the ID of the process that sent you the current transaction
  /// that is being processed.  This pid can be used with higher-level
  /// system services to determine its identity and check permissions.
  /// If the current thread is not currently executing an incoming transaction,
  /// then its own pid is returned.
  static int getCallingPid() => _getCallingPid();

  static final _getCallingUid =
      jlookup<ffi.NativeFunction<ffi.Int32 Function()>>(
              "android_os_Binder_getCallingUid")
          .asFunction<int Function()>();

  /// from: static public native final int getCallingUid()
  /// Return the Linux uid assigned to the process that sent you the
  /// current transaction that is being processed.  This uid can be used with
  /// higher-level system services to determine its identity and check
  /// permissions.  If the current thread is not currently executing an
  /// incoming transaction, then its own uid is returned.
  static int getCallingUid() => _getCallingUid();

  static final _getCallingUserHandle =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_Binder_getCallingUserHandle")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: static public final android.os.UserHandle getCallingUserHandle()
  /// Return the UserHandle assigned to the process that sent you the
  /// current transaction that is being processed.  This is the user
  /// of the caller.  It is distinct from \#getCallingUid() in that a
  /// particular user will have multiple distinct apps running under it each
  /// with their own uid.  If the current thread is not currently executing an
  /// incoming transaction, then its own UserHandle is returned.
  ///@return This value will never be {@code null}.
  static UserHandle getCallingUserHandle() =>
      UserHandle.fromRef(_getCallingUserHandle());

  static final _clearCallingIdentity =
      jlookup<ffi.NativeFunction<ffi.Int64 Function()>>(
              "android_os_Binder_clearCallingIdentity")
          .asFunction<int Function()>();

  /// from: static public native final long clearCallingIdentity()
  /// Reset the identity of the incoming IPC on the current thread.  This can
  /// be useful if, while handling an incoming call, you will be calling
  /// on interfaces of other objects that may be local to your process and
  /// need to do permission checks on the calls coming into them (so they
  /// will check the permission of your own local process, and not whatever
  /// process originally called you).
  ///@return Returns an opaque token that can be used to restore the
  /// original calling identity by passing it to
  /// \#restoreCallingIdentity(long).
  ///@see \#getCallingPid()
  ///@see \#getCallingUid()
  ///@see \#restoreCallingIdentity(long)
  static int clearCallingIdentity() => _clearCallingIdentity();

  static final _restoreCallingIdentity =
      jlookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64)>>(
              "android_os_Binder_restoreCallingIdentity")
          .asFunction<void Function(int)>();

  /// from: static public native final void restoreCallingIdentity(long token)
  /// Restore the identity of the incoming IPC on the current thread
  /// back to a previously identity that was returned by \#clearCallingIdentity.
  ///@param token The opaque token that was previously returned by
  /// \#clearCallingIdentity.
  ///@see \#clearCallingIdentity
  static void restoreCallingIdentity(int token) =>
      _restoreCallingIdentity(token);

  static final _flushPendingCommands =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Binder_flushPendingCommands")
          .asFunction<void Function()>();

  /// from: static public native final void flushPendingCommands()
  /// Flush any Binder commands pending in the current thread to the kernel
  /// driver.  This can be
  /// useful to call before performing an operation that may block for a long
  /// time, to ensure that any pending object references have been released
  /// in order to prevent the process from holding on to objects longer than
  /// it needs to.
  static void flushPendingCommands() => _flushPendingCommands();

  static final _joinThreadPool =
      jlookup<ffi.NativeFunction<ffi.Void Function()>>(
              "android_os_Binder_joinThreadPool")
          .asFunction<void Function()>();

  /// from: static public final void joinThreadPool()
  /// Add the calling thread to the IPC thread pool.  This function does
  /// not return until the current process is exiting.
  static void joinThreadPool() => _joinThreadPool();

  static final _attachInterface = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Binder_attachInterface")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void attachInterface(android.os.IInterface owner, java.lang.String descriptor)
  /// Convenience method for associating a specific interface with the Binder.
  /// After calling, queryLocalInterface() will be implemented for you
  /// to return the given owner IInterface when the corresponding
  /// descriptor is requested.
  ///@param owner This value may be {@code null}.
  ///@param descriptor This value may be {@code null}.
  void attachInterface(IInterface owner, jni.JlString descriptor) =>
      _attachInterface(reference, owner.reference, descriptor.reference);

  static final _getInterfaceDescriptor = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_Binder_getInterfaceDescriptor")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getInterfaceDescriptor()
  /// Default implementation returns an empty interface name.
  ///@return This value may be {@code null}.
  jni.JlString getInterfaceDescriptor() =>
      jni.JlString.fromRef(_getInterfaceDescriptor(reference));

  static final _pingBinder =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Binder_pingBinder")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean pingBinder()
  /// Default implementation always returns true -- if you got here,
  /// the object is alive.
  bool pingBinder() => _pingBinder(reference) != 0;

  static final _isBinderAlive =
      jlookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_Binder_isBinderAlive")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isBinderAlive()
  /// {@inheritDoc}
  ///
  /// Note that if you're calling on a local binder, this always returns true
  /// because your process is alive if you're calling it.
  bool isBinderAlive() => _isBinderAlive(reference) != 0;

  static final _queryLocalInterface = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_Binder_queryLocalInterface")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.IInterface queryLocalInterface(java.lang.String descriptor)
  /// Use information supplied to attachInterface() to return the
  /// associated IInterface if it matches the requested
  /// descriptor.
  ///@param descriptor This value must never be {@code null}.
  ///@return This value may be {@code null}.
  IInterface queryLocalInterface(jni.JlString descriptor) =>
      IInterface.fromRef(_queryLocalInterface(reference, descriptor.reference));

  static final _onTransact = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Binder_onTransact")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: protected boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)
  /// Default implementation is a stub that returns false.  You will want
  /// to override this to do the appropriate unmarshalling of transactions.
  ///
  /// If you want to call this, call transact().
  ///
  /// Implementations that are returning a result should generally use
  /// Parcel\#writeNoException() Parcel.writeNoException and
  /// Parcel\#writeException(Exception) Parcel.writeException to propagate
  /// exceptions back to the caller.
  ///
  ///@param code The action to perform.  This should
  /// be a number between \#FIRST_CALL_TRANSACTION and
  /// \#LAST_CALL_TRANSACTION.
  ///@param data Marshalled data being received from the caller.
  /// This value must never be {@code null}.
  ///@param reply If the caller is expecting a result back, it should be marshalled
  /// in to here.
  /// This value may be {@code null}.
  ///@param flags Additional operation flags.  Either 0 for a normal
  /// RPC, or \#FLAG_ONEWAY for a one-way RPC.
  ///@return Return true on a successful call; returning false is generally used to
  /// indicate that you did not understand the transaction code.
  bool onTransact(int code, Parcel data, Parcel reply, int flags) =>
      _onTransact(reference, code, data.reference, reply.reference, flags) != 0;

  static final _dump = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Binder_dump")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(java.io.FileDescriptor fd, java.lang.String[] args)
  /// Implemented to call the more convenient version
  /// \#dump(FileDescriptor, PrintWriter, String[]).
  ///@param fd This value must never be {@code null}.
  ///@param args This value may be {@code null}.
  void dump(jni.JlObject fd, jni.JlObject args) =>
      _dump(reference, fd.reference, args.reference);

  static final _dumpAsync = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Binder_dumpAsync")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dumpAsync(java.io.FileDescriptor fd, java.lang.String[] args)
  /// Like \#dump(FileDescriptor, String[]), but ensures the target
  /// executes asynchronously.
  ///@param fd This value must never be {@code null}.
  ///@param args This value may be {@code null}.
  void dumpAsync(jni.JlObject fd, jni.JlObject args) =>
      _dumpAsync(reference, fd.reference, args.reference);

  static final _dump_1 = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("android_os_Binder_dump_1")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void dump(java.io.FileDescriptor fd, java.io.PrintWriter fout, java.lang.String[] args)
  /// Print the object's state into the given stream.
  ///@param fd The raw file descriptor that the dump is being sent to.
  /// This value must never be {@code null}.
  ///@param fout The file to which you should dump your state.  This will be
  /// closed for you after you return.
  /// This value must never be {@code null}.
  ///@param args additional arguments to the dump request.
  ///
  /// This value may be {@code null}.
  void dump_1(jni.JlObject fd, jni.JlObject fout, jni.JlObject args) =>
      _dump_1(reference, fd.reference, fout.reference, args.reference);

  static final _transact = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Binder_transact")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public final boolean transact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)
  /// Default implementation rewinds the parcels and calls onTransact.  On
  /// the remote side, transact calls into the binder to do the IPC.
  ///@param data This value must never be {@code null}.
  ///@param reply This value may be {@code null}.
  bool transact(int code, Parcel data, Parcel reply, int flags) =>
      _transact(reference, code, data.reference, reply.reference, flags) != 0;

  static final _linkToDeath = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Binder_linkToDeath")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void linkToDeath(android.os.IBinder.DeathRecipient recipient, int flags)
  /// Local implementation is a no-op.
  ///@param recipient This value must never be {@code null}.
  void linkToDeath(IBinder_DeathRecipient recipient, int flags) =>
      _linkToDeath(reference, recipient.reference, flags);

  static final _unlinkToDeath = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_Binder_unlinkToDeath")
      .asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean unlinkToDeath(android.os.IBinder.DeathRecipient recipient, int flags)
  /// Local implementation is a no-op.
  ///@param recipient This value must never be {@code null}.
  bool unlinkToDeath(IBinder_DeathRecipient recipient, int flags) =>
      _unlinkToDeath(reference, recipient.reference, flags) != 0;
}
