// Autogenerated by jni_gen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_element

import "dart:ffi" as ffi;

import "package:jni/jni.dart" as jni;

import "package:content_plugin/android/os.dart" as os;
import "../../init.dart" show jlookup;

/// Keys for HealthStats returned from
/// HealthStats\#getStats(int) HealthStats.getStats(int) with the
/// UidHealthStats\#STATS_PROCESSES UidHealthStats.STATS_PROCESSES key.
class ProcessHealthStats extends jni.JlObject {
  ProcessHealthStats.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int MEASUREMENT_ANR_COUNT
  /// Key for a measurement of the number of ANRs that happened in this process.
  static const MEASUREMENT_ANR_COUNT = 30005;

  /// from: static public final int MEASUREMENT_CRASHES_COUNT
  /// Key for a measurement of the number of crashes that happened in this process.
  static const MEASUREMENT_CRASHES_COUNT = 30004;

  /// from: static public final int MEASUREMENT_FOREGROUND_MS
  /// Key for a measurement of the number of milliseconds this process spent with
  /// an activity in the foreground.
  static const MEASUREMENT_FOREGROUND_MS = 30006;

  /// from: static public final int MEASUREMENT_STARTS_COUNT
  /// Key for a measurement of the number of times this process was started for any reason.
  static const MEASUREMENT_STARTS_COUNT = 30003;

  /// from: static public final int MEASUREMENT_SYSTEM_TIME_MS
  /// Key for a measurement of number of millseconds the CPU spent running in kernel space
  /// for this process.
  static const MEASUREMENT_SYSTEM_TIME_MS = 30002;

  /// from: static public final int MEASUREMENT_USER_TIME_MS
  /// Key for a measurement of number of millseconds the CPU spent running in user space
  /// for this process.
  static const MEASUREMENT_USER_TIME_MS = 30001;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_health_ProcessHealthStats_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  ProcessHealthStats() : super.fromRef(_ctor());
}

/// Keys for HealthStats returned from
/// HealthStats\#getStats(int) HealthStats.getStats(int) with the
/// UidHealthStats\#STATS_PIDS UidHealthStats.STATS_PIDS key.
///
/// The values coming from PidHealthStats are a little bit different from
/// the other HealthStats values.  These values are not aggregate or historical
/// values, but instead live values from when the snapshot is taken.  These
/// tend to be more useful in debugging rogue processes than in gathering
/// aggregate metrics across the fleet of devices.
class PidHealthStats extends jni.JlObject {
  PidHealthStats.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int MEASUREMENT_WAKE_NESTING_COUNT
  /// Key for a measurement of the current nesting depth of wakelocks for this process.
  /// That is to say, the number of times a nested wakelock has been started but not
  /// stopped.  A high number here indicates an improperly paired wakelock acquire/release
  /// combination.
  ///
  /// More details on the individual wake locks is available
  /// by getting the UidHealthStats\#TIMERS_WAKELOCKS_FULL,
  /// UidHealthStats\#TIMERS_WAKELOCKS_PARTIAL,
  /// UidHealthStats\#TIMERS_WAKELOCKS_WINDOW
  /// and UidHealthStats\#TIMERS_WAKELOCKS_DRAW keys.
  static const MEASUREMENT_WAKE_NESTING_COUNT = 20001;

  /// from: static public final int MEASUREMENT_WAKE_START_MS
  /// Key for a measurement of the time in the android.os.SystemClock\#elapsedRealtime
  /// timebase that a wakelock was first acquired in this process.
  ///
  /// More details on the individual wake locks is available
  /// by getting the UidHealthStats\#TIMERS_WAKELOCKS_FULL,
  /// UidHealthStats\#TIMERS_WAKELOCKS_PARTIAL,
  /// UidHealthStats\#TIMERS_WAKELOCKS_WINDOW
  /// and UidHealthStats\#TIMERS_WAKELOCKS_DRAW keys.
  static const MEASUREMENT_WAKE_START_MS = 20003;

  /// from: static public final int MEASUREMENT_WAKE_SUM_MS
  /// Key for a measurement of the total number of milleseconds that this process
  /// has held a wake lock.
  ///
  /// More details on the individual wake locks is available
  /// by getting the UidHealthStats\#TIMERS_WAKELOCKS_FULL,
  /// UidHealthStats\#TIMERS_WAKELOCKS_PARTIAL,
  /// UidHealthStats\#TIMERS_WAKELOCKS_WINDOW
  /// and UidHealthStats\#TIMERS_WAKELOCKS_DRAW keys.
  static const MEASUREMENT_WAKE_SUM_MS = 20002;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_health_PidHealthStats_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  PidHealthStats() : super.fromRef(_ctor());
}

/// A HealthStats object contains system health data about an application.
///
///
/// __Data Types__<br>
/// Each of the keys references data in one of five data types:
///
///
/// A __measurement__ metric contains a sinlge {@code long} value. That value may
/// be a count, a time, or some other type of value. The unit for a measurement
/// (COUNT, MS, etc) will always be in the name of the constant for the key to
/// retrieve it. For example, the
/// android.os.health.UidHealthStats\#MEASUREMENT_WIFI_TX_MS UidHealthStats.MEASUREMENT_WIFI_TX_MS
/// value is the number of milliseconds (ms) that were spent transmitting on wifi by an
/// application.  The
/// android.os.health.UidHealthStats\#MEASUREMENT_MOBILE_RX_PACKETS UidHealthStats.MEASUREMENT_MOBILE_RX_PACKETS
/// measurement is the number of packets received on behalf of an application.
/// The android.os.health.UidHealthStats\#MEASUREMENT_TOUCH_USER_ACTIVITY_COUNT UidHealthStats.MEASUREMENT_TOUCH_USER_ACTIVITY_COUNT
/// measurement is the number of times the user touched the screen, causing the
/// screen to stay awake.
///
///
///
/// A __timer__ metric contains an {@code int} count and a {@code long} time,
/// measured in milliseconds. Timers track how many times a resource was used, and
/// the total duration for that usage. For example, the
/// android.os.health.UidHealthStats\#TIMER_FLASHLIGHT
/// timer tracks how many times the application turned on the flashlight, and for
/// how many milliseconds total it kept it on.
///
///
/// A __measurement map__ metric is a mapping of java.lang.String names to
/// java.lang.Long values.  The names typically are application provided names. For
/// example, the
/// android.os.health.PackageHealthStats\#MEASUREMENTS_WAKEUP_ALARMS_COUNT PackageHealthStats.MEASUREMENTS_WAKEUP_ALARMS_COUNT
/// measurement map is a mapping of the tag provided to the
/// android.app.AlarmManager when the alarm is scheduled.
///
///
/// A __timer map__ metric is a mapping of java.lang.String names to
/// android.os.health.TimerStat objects. The names are typically application
/// provided names.  For example, the
/// android.os.health.UidHealthStats\#TIMERS_WAKELOCKS_PARTIAL UidHealthStats.TIMERS_WAKELOCKS_PARTIAL
/// is a mapping of tag provided to the android.os.PowerManager when the
/// wakelock is created to the number of times and for how long each wakelock was
/// active.
///
///
/// Lastly, a __health stats__ metric is a mapping of java.lang.String
/// names to a recursive android.os.health.HealthStats object containing
/// more detailed information. For example, the
/// android.os.health.UidHealthStats\#STATS_PACKAGES UidHealthStats.STATS_PACKAGES
/// metric is a mapping of the package names for each of the APKs sharing a uid to
/// the information recorded for that apk.  The returned HealthStats objects will
/// each be associated with a different set of constants.  For the HealthStats
/// returned for UidHealthStats.STATS_PACKAGES, the keys come from the
/// android.os.health.PackageHealthStats  class.
///
///
/// The keys that are available are subject to change, depending on what a particular
/// device or software version is capable of recording. Applications must handle the absence of
/// data without crashing.
class HealthStats extends jni.JlObject {
  HealthStats.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_health_HealthStats_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  /// HealthStats empty constructor not implemented because this
  /// class is read-only.
  HealthStats() : super.fromRef(_ctor());

  static final _getDataType = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_health_HealthStats_getDataType")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getDataType()
  /// Get a name representing the contents of this object.
  ///@see UidHealthStats
  ///@see PackageHealthStats
  ///@see PidHealthStats
  ///@see ProcessHealthStats
  ///@see ServiceHealthStats
  jni.JlString getDataType() => jni.JlString.fromRef(_getDataType(reference));

  static final _hasTimer = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_health_HealthStats_hasTimer")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean hasTimer(int key)
  /// Return whether this object contains a TimerStat for the supplied key.
  bool hasTimer(int key) => _hasTimer(reference, key) != 0;

  static final _getTimer = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_health_HealthStats_getTimer")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.os.health.TimerStat getTimer(int key)
  /// Return a TimerStat object for the given key.
  ///
  /// This will allocate a new TimerStat object, which may be wasteful. Instead, use
  /// \#getTimerCount and \#getTimerTime.
  ///@throws IndexOutOfBoundsException When the key is not present in this object.
  ///@see \#hasTimer hasTimer(int) To check if a value for the given key is present.
  TimerStat getTimer(int key) => TimerStat.fromRef(_getTimer(reference, key));

  static final _getTimerCount = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_health_HealthStats_getTimerCount")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getTimerCount(int key)
  /// Get the count for the timer for the given key.
  ///@throws IndexOutOfBoundsException When the key is not present in this object.
  ///@see \#hasTimer hasTimer(int) To check if a value for the given key is present.
  int getTimerCount(int key) => _getTimerCount(reference, key);

  static final _getTimerTime = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_health_HealthStats_getTimerTime")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public long getTimerTime(int key)
  /// Get the time for the timer for the given key, in milliseconds.
  ///@throws IndexOutOfBoundsException When the key is not present in this object.
  ///@see \#hasTimer hasTimer(int) To check if a value for the given key is present.
  int getTimerTime(int key) => _getTimerTime(reference, key);

  static final _getTimerKeyCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_health_HealthStats_getTimerKeyCount")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getTimerKeyCount()
  /// Get the number of timer values in this object. Can be used to iterate through
  /// the available timers.
  ///@see \#getTimerKeyAt
  int getTimerKeyCount() => _getTimerKeyCount(reference);

  static final _getTimerKeyAt = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_health_HealthStats_getTimerKeyAt")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getTimerKeyAt(int index)
  /// Get the key for the timer at the given index.  Index must be between 0 and the result
  /// of \#getTimerKeyCount getTimerKeyCount().
  ///@see \#getTimerKeyCount
  int getTimerKeyAt(int index) => _getTimerKeyAt(reference, index);

  static final _hasMeasurement = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_health_HealthStats_hasMeasurement")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean hasMeasurement(int key)
  /// Return whether this object contains a measurement for the supplied key.
  bool hasMeasurement(int key) => _hasMeasurement(reference, key) != 0;

  static final _getMeasurement = jlookup<
          ffi.NativeFunction<
              ffi.Int64 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_health_HealthStats_getMeasurement")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public long getMeasurement(int key)
  /// Get the measurement for the given key.
  ///@throws IndexOutOfBoundsException When the key is not present in this object.
  ///@see \#hasMeasurement hasMeasurement(int) To check if a value for the given key is present.
  int getMeasurement(int key) => _getMeasurement(reference, key);

  static final _getMeasurementKeyCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_health_HealthStats_getMeasurementKeyCount")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getMeasurementKeyCount()
  /// Get the number of measurement values in this object. Can be used to iterate through
  /// the available measurements.
  ///@see \#getMeasurementKeyAt
  int getMeasurementKeyCount() => _getMeasurementKeyCount(reference);

  static final _getMeasurementKeyAt = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_os_health_HealthStats_getMeasurementKeyAt")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getMeasurementKeyAt(int index)
  /// Get the key for the measurement at the given index.  Index must be between 0 and the result
  /// of \#getMeasurementKeyCount getMeasurementKeyCount().
  ///@see \#getMeasurementKeyCount
  int getMeasurementKeyAt(int index) => _getMeasurementKeyAt(reference, index);

  static final _hasStats = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_health_HealthStats_hasStats")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean hasStats(int key)
  /// Return whether this object contains a HealthStats map for the supplied key.
  bool hasStats(int key) => _hasStats(reference, key) != 0;

  static final _getStats = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_health_HealthStats_getStats")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.util.Map<java.lang.String,android.os.health.HealthStats> getStats(int key)
  /// Get the HealthStats map for the given key.
  ///@throws IndexOutOfBoundsException When the key is not present in this object.
  ///@see \#hasStats hasStats(int) To check if a value for the given key is present.
  jni.JlObject getStats(int key) =>
      jni.JlObject.fromRef(_getStats(reference, key));

  static final _getStatsKeyCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_health_HealthStats_getStatsKeyCount")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getStatsKeyCount()
  /// Get the number of HealthStat map values in this object. Can be used to iterate through
  /// the available measurements.
  ///@see \#getMeasurementKeyAt
  int getStatsKeyCount() => _getStatsKeyCount(reference);

  static final _getStatsKeyAt = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_health_HealthStats_getStatsKeyAt")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getStatsKeyAt(int index)
  /// Get the key for the timer at the given index.  Index must be between 0 and the result
  /// of \#getStatsKeyCount getStatsKeyCount().
  ///@see \#getStatsKeyCount
  int getStatsKeyAt(int index) => _getStatsKeyAt(reference, index);

  static final _hasTimers = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_health_HealthStats_hasTimers")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean hasTimers(int key)
  /// Return whether this object contains a timers map for the supplied key.
  bool hasTimers(int key) => _hasTimers(reference, key) != 0;

  static final _getTimers = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_health_HealthStats_getTimers")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.util.Map<java.lang.String,android.os.health.TimerStat> getTimers(int key)
  /// Get the TimerStat map for the given key.
  ///@throws IndexOutOfBoundsException When the key is not present in this object.
  ///@see \#hasTimers hasTimers(int) To check if a value for the given key is present.
  jni.JlObject getTimers(int key) =>
      jni.JlObject.fromRef(_getTimers(reference, key));

  static final _getTimersKeyCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_health_HealthStats_getTimersKeyCount")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getTimersKeyCount()
  /// Get the number of timer map values in this object. Can be used to iterate through
  /// the available timer maps.
  ///@see \#getTimersKeyAt
  int getTimersKeyCount() => _getTimersKeyCount(reference);

  static final _getTimersKeyAt = jlookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_health_HealthStats_getTimersKeyAt")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getTimersKeyAt(int index)
  /// Get the key for the timer map at the given index.  Index must be between 0 and the result
  /// of \#getTimersKeyCount getTimersKeyCount().
  ///@see \#getTimersKeyCount
  int getTimersKeyAt(int index) => _getTimersKeyAt(reference, index);

  static final _hasMeasurements = jlookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_health_HealthStats_hasMeasurements")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean hasMeasurements(int key)
  /// Return whether this object contains a measurements map for the supplied key.
  bool hasMeasurements(int key) => _hasMeasurements(reference, key) != 0;

  static final _getMeasurements = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_health_HealthStats_getMeasurements")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.util.Map<java.lang.String,java.lang.Long> getMeasurements(int key)
  /// Get the measurements map for the given key.
  ///@throws IndexOutOfBoundsException When the key is not present in this object.
  ///@see \#hasMeasurements To check if a value for the given key is present.
  jni.JlObject getMeasurements(int key) =>
      jni.JlObject.fromRef(_getMeasurements(reference, key));

  static final _getMeasurementsKeyCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_health_HealthStats_getMeasurementsKeyCount")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getMeasurementsKeyCount()
  /// Get the number of measurement map values in this object. Can be used to iterate through
  /// the available measurement maps.
  ///@see \#getMeasurementsKeyAt
  int getMeasurementsKeyCount() => _getMeasurementsKeyCount(reference);

  static final _getMeasurementsKeyAt = jlookup<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_os_health_HealthStats_getMeasurementsKeyAt")
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getMeasurementsKeyAt(int index)
  /// Get the key for the measurement map at the given index.
  /// Index must be between 0 and the result
  /// of \#getMeasurementsKeyCount getMeasurementsKeyCount().
  ///@see \#getMeasurementsKeyCount
  int getMeasurementsKeyAt(int index) =>
      _getMeasurementsKeyAt(reference, index);
}

/// Keys for HealthStats returned from
/// SystemHealthManager\#takeUidSnapshot(int) SystemHealthManager.takeUidSnapshot(int),
/// SystemHealthManager\#takeMyUidSnapshot() SystemHealthManager.takeMyUidSnapshot(), and
/// SystemHealthManager\#takeUidSnapshots(int[]) SystemHealthManager.takeUidSnapshots(int[]).
class UidHealthStats extends jni.JlObject {
  UidHealthStats.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int MEASUREMENT_BLUETOOTH_IDLE_MS
  /// Key for a measurement of number of millseconds the bluetooth controller was
  /// idle but turned on on behalf of this uid.
  static const MEASUREMENT_BLUETOOTH_IDLE_MS = 10020;

  /// from: static public final int MEASUREMENT_BLUETOOTH_POWER_MAMS
  /// Key for a measurement of the estimated number of mA*ms used by this uid
  /// for bluetooth, that is to say the number of milliseconds of activity
  /// times the mA current during that period.
  static const MEASUREMENT_BLUETOOTH_POWER_MAMS = 10023;

  /// from: static public final int MEASUREMENT_BLUETOOTH_RX_BYTES
  /// Key for a measurement of number of bytes received for this uid by the bluetooth radio.
  static const MEASUREMENT_BLUETOOTH_RX_BYTES = 10052;

  /// from: static public final int MEASUREMENT_BLUETOOTH_RX_MS
  /// Key for a measurement of number of millseconds the bluetooth transmitter was
  /// receiving data for this uid.
  static const MEASUREMENT_BLUETOOTH_RX_MS = 10021;

  /// from: static public final int MEASUREMENT_BLUETOOTH_RX_PACKETS
  /// Key for a measurement of number of packets received for this uid by the bluetooth radio.
  static const MEASUREMENT_BLUETOOTH_RX_PACKETS = 10058;

  /// from: static public final int MEASUREMENT_BLUETOOTH_TX_BYTES
  /// Key for a measurement of number of bytes transmitted for this uid by the bluetooth radio.
  static const MEASUREMENT_BLUETOOTH_TX_BYTES = 10053;

  /// from: static public final int MEASUREMENT_BLUETOOTH_TX_MS
  /// Key for a measurement of number of millseconds the bluetooth transmitter was
  /// transmitting data for this uid.
  static const MEASUREMENT_BLUETOOTH_TX_MS = 10022;

  /// from: static public final int MEASUREMENT_BLUETOOTH_TX_PACKETS
  /// Key for a measurement of number of packets transmitted for this uid by the bluetooth radio.
  static const MEASUREMENT_BLUETOOTH_TX_PACKETS = 10059;

  /// from: static public final int MEASUREMENT_BUTTON_USER_ACTIVITY_COUNT
  /// Key for a measurement of number of user activity events due to physical button presses caused
  /// by the UID.  Calls to userActivity() reset the user activity countdown timer and
  /// keep the screen on for the user's preferred screen-on setting.
  static const MEASUREMENT_BUTTON_USER_ACTIVITY_COUNT = 10046;

  /// from: static public final int MEASUREMENT_CPU_POWER_MAMS
  /// An estimate of the number of milliamp-microsends used by this uid.
  ///@deprecated this measurement is vendor-dependent and not reliable.
  static const MEASUREMENT_CPU_POWER_MAMS = 10064;

  /// from: static public final int MEASUREMENT_MOBILE_IDLE_MS
  /// Key for a measurement of number of millseconds the mobile radio controller was
  /// idle but turned on on behalf of this uid.
  static const MEASUREMENT_MOBILE_IDLE_MS = 10024;

  /// from: static public final int MEASUREMENT_MOBILE_POWER_MAMS
  /// Key for a measurement of the estimated number of mA*ms used by this uid
  /// for mobile data, that is to say the number of milliseconds of activity
  /// times the mA current during that period.
  static const MEASUREMENT_MOBILE_POWER_MAMS = 10027;

  /// from: static public final int MEASUREMENT_MOBILE_RX_BYTES
  /// Key for a measurement of number of bytes received for this uid by the mobile radio.
  static const MEASUREMENT_MOBILE_RX_BYTES = 10048;

  /// from: static public final int MEASUREMENT_MOBILE_RX_MS
  /// Key for a measurement of number of millseconds the mobile radio transmitter was
  /// receiving data for this uid.
  static const MEASUREMENT_MOBILE_RX_MS = 10025;

  /// from: static public final int MEASUREMENT_MOBILE_RX_PACKETS
  /// Key for a measurement of number of packets received for this uid by the mobile radio.
  static const MEASUREMENT_MOBILE_RX_PACKETS = 10054;

  /// from: static public final int MEASUREMENT_MOBILE_TX_BYTES
  /// Key for a measurement of number of bytes transmitted for this uid by the mobile radio.
  static const MEASUREMENT_MOBILE_TX_BYTES = 10049;

  /// from: static public final int MEASUREMENT_MOBILE_TX_MS
  /// Key for a measurement of number of millseconds the mobile radio transmitter was
  /// transmitting data for this uid.
  static const MEASUREMENT_MOBILE_TX_MS = 10026;

  /// from: static public final int MEASUREMENT_MOBILE_TX_PACKETS
  /// Key for a measurement of number of packets transmitted for this uid by the mobile radio.
  static const MEASUREMENT_MOBILE_TX_PACKETS = 10055;

  /// from: static public final int MEASUREMENT_OTHER_USER_ACTIVITY_COUNT
  /// Key for a measurement of number of software-generated user activity events caused
  /// by the UID.  Calls to userActivity() reset the user activity countdown timer and
  /// keep the screen on for the user's preferred screen-on setting.
  static const MEASUREMENT_OTHER_USER_ACTIVITY_COUNT = 10045;

  /// from: static public final int MEASUREMENT_REALTIME_BATTERY_MS
  /// How many milliseconds this statistics report covers in wall-clock time while the
  /// device was on battery including both screen-on and screen-off time.
  static const MEASUREMENT_REALTIME_BATTERY_MS = 10001;

  /// from: static public final int MEASUREMENT_REALTIME_SCREEN_OFF_BATTERY_MS
  /// How many milliseconds this statistics report covers in wall-clock time while the
  /// device was on battery including both screen-on and screen-off time.
  static const MEASUREMENT_REALTIME_SCREEN_OFF_BATTERY_MS = 10003;

  /// from: static public final int MEASUREMENT_SYSTEM_CPU_TIME_MS
  /// Key for a measurement of the number of milliseconds spent by the CPU running kernel
  /// code for this uid.
  static const MEASUREMENT_SYSTEM_CPU_TIME_MS = 10063;

  /// from: static public final int MEASUREMENT_TOUCH_USER_ACTIVITY_COUNT
  /// Key for a measurement of number of user activity events due to touch events caused
  /// by the UID.  Calls to userActivity() reset the user activity countdown timer and
  /// keep the screen on for the user's preferred screen-on setting.
  static const MEASUREMENT_TOUCH_USER_ACTIVITY_COUNT = 10047;

  /// from: static public final int MEASUREMENT_UPTIME_BATTERY_MS
  /// How many milliseconds this statistics report covers that the CPU was running while the
  /// device was on battery including both screen-on and screen-off time.
  static const MEASUREMENT_UPTIME_BATTERY_MS = 10002;

  /// from: static public final int MEASUREMENT_UPTIME_SCREEN_OFF_BATTERY_MS
  /// How many milliseconds this statistics report covers that the CPU was running while the
  /// device was on battery including both screen-on and screen-off time.
  static const MEASUREMENT_UPTIME_SCREEN_OFF_BATTERY_MS = 10004;

  /// from: static public final int MEASUREMENT_USER_CPU_TIME_MS
  /// Key for a measurement of the number of milliseconds spent by the CPU running user space
  /// code for this uid.
  static const MEASUREMENT_USER_CPU_TIME_MS = 10062;

  /// from: static public final int MEASUREMENT_WIFI_FULL_LOCK_MS
  /// Key for a measurement of number of millseconds that this uid held a full wifi lock.
  static const MEASUREMENT_WIFI_FULL_LOCK_MS = 10029;

  /// from: static public final int MEASUREMENT_WIFI_IDLE_MS
  /// Key for a measurement of number of millseconds the wifi controller was
  /// idle but turned on on behalf of this uid.
  static const MEASUREMENT_WIFI_IDLE_MS = 10016;

  /// from: static public final int MEASUREMENT_WIFI_MULTICAST_MS
  /// Key for a measurement of number of millseconds that this uid was performing
  /// multicast wifi traffic.
  static const MEASUREMENT_WIFI_MULTICAST_MS = 10031;

  /// from: static public final int MEASUREMENT_WIFI_POWER_MAMS
  /// Key for a measurement of the estimated number of mA*ms used by this uid
  /// for wifi, that is to say the number of milliseconds of wifi activity
  /// times the mA current during that period.
  static const MEASUREMENT_WIFI_POWER_MAMS = 10019;

  /// from: static public final int MEASUREMENT_WIFI_RUNNING_MS
  /// Key for a measurement of number of millseconds the wifi controller was
  /// active on behalf of this uid.
  static const MEASUREMENT_WIFI_RUNNING_MS = 10028;

  /// from: static public final int MEASUREMENT_WIFI_RX_BYTES
  /// Key for a measurement of number of bytes received for this uid by the wifi radio.
  static const MEASUREMENT_WIFI_RX_BYTES = 10050;

  /// from: static public final int MEASUREMENT_WIFI_RX_MS
  /// Key for a measurement of number of millseconds the wifi transmitter was
  /// receiving data for this uid.
  static const MEASUREMENT_WIFI_RX_MS = 10017;

  /// from: static public final int MEASUREMENT_WIFI_RX_PACKETS
  /// Key for a measurement of number of packets received for this uid by the wifi radio.
  static const MEASUREMENT_WIFI_RX_PACKETS = 10056;

  /// from: static public final int MEASUREMENT_WIFI_TX_BYTES
  /// Key for a measurement of number of bytes transmitted for this uid by the wifi radio.
  static const MEASUREMENT_WIFI_TX_BYTES = 10051;

  /// from: static public final int MEASUREMENT_WIFI_TX_MS
  /// Key for a measurement of number of millseconds the wifi transmitter was
  /// transmitting data for this uid.
  static const MEASUREMENT_WIFI_TX_MS = 10018;

  /// from: static public final int MEASUREMENT_WIFI_TX_PACKETS
  /// Key for a measurement of number of packets transmitted for this uid by the wifi radio.
  static const MEASUREMENT_WIFI_TX_PACKETS = 10057;

  /// from: static public final int STATS_PACKAGES
  /// Key for a HealthStats with PackageHealthStats keys for each of the
  /// APKs that share this uid.
  static const STATS_PACKAGES = 10015;

  /// from: static public final int STATS_PIDS
  /// Key for a HealthStats with PidHealthStats keys for each of the
  /// currently running processes for this uid.
  static const STATS_PIDS = 10013;

  /// from: static public final int STATS_PROCESSES
  /// Key for a HealthStats with ProcessHealthStats keys for each of the
  /// named processes for this uid.
  static const STATS_PROCESSES = 10014;

  /// from: static public final int TIMERS_JOBS
  /// Key for a map of Timers for the android.app.job.JobScheduler jobs for
  /// this uid.
  static const TIMERS_JOBS = 10010;

  /// from: static public final int TIMERS_SENSORS
  /// Key for a map of the sensor usage for this uid. The keys are a
  /// string representation of the handle for the sensor.
  static const TIMERS_SENSORS = 10012;

  /// from: static public final int TIMERS_SYNCS
  /// Key for a map of Timers for the sync adapter syncs that were done for
  /// this uid.
  static const TIMERS_SYNCS = 10009;

  /// from: static public final int TIMERS_WAKELOCKS_DRAW
  /// Key for a TimerStat for the times a system-defined wakelock was acquired
  /// to allow the application to draw when it otherwise would not be able to
  /// (e.g.&nbsp;on the lock screen or doze screen).
  static const TIMERS_WAKELOCKS_DRAW = 10008;

  /// from: static public final int TIMERS_WAKELOCKS_FULL
  /// Key for a TimerStat for the times a
  /// android.os.PowerManager\#FULL_WAKE_LOCK full wake lock
  /// was acquired for this uid.
  static const TIMERS_WAKELOCKS_FULL = 10005;

  /// from: static public final int TIMERS_WAKELOCKS_PARTIAL
  /// Key for a TimerStat for the times a
  /// android.os.PowerManager\#PARTIAL_WAKE_LOCK full wake lock
  /// was acquired for this uid.
  static const TIMERS_WAKELOCKS_PARTIAL = 10006;

  /// from: static public final int TIMERS_WAKELOCKS_WINDOW
  static const TIMERS_WAKELOCKS_WINDOW = 10007;

  /// from: static public final int TIMER_AUDIO
  /// Key for a timer for the count and duration of audio playback done by this uid.
  static const TIMER_AUDIO = 10032;

  /// from: static public final int TIMER_BLUETOOTH_SCAN
  /// Key for a timer for the count and duration of when this uid was doing bluetooth scans.
  static const TIMER_BLUETOOTH_SCAN = 10037;

  /// from: static public final int TIMER_CAMERA
  /// Key for a timer for the count and duration this uid had the camera turned on.
  static const TIMER_CAMERA = 10035;

  /// from: static public final int TIMER_FLASHLIGHT
  /// Key for a timer for the count and duration this uid had the flashlight turned on.
  static const TIMER_FLASHLIGHT = 10034;

  /// from: static public final int TIMER_FOREGROUND_ACTIVITY
  /// Key for a timer for the count and duration of when an activity from this uid
  /// was the foreground activitiy.
  static const TIMER_FOREGROUND_ACTIVITY = 10036;

  /// from: static public final int TIMER_GPS_SENSOR
  /// Key for a timer for the applications use of the GPS sensor.
  static const TIMER_GPS_SENSOR = 10011;

  /// from: static public final int TIMER_MOBILE_RADIO_ACTIVE
  /// Key for a timer for the count and duration the mobile radio was turned on for this uid.
  static const TIMER_MOBILE_RADIO_ACTIVE = 10061;

  /// from: static public final int TIMER_PROCESS_STATE_BACKGROUND_MS
  /// Key for a timer for the count and duration of when this uid was in the "background"
  /// process state.
  static const TIMER_PROCESS_STATE_BACKGROUND_MS = 10042;

  /// from: static public final int TIMER_PROCESS_STATE_CACHED_MS
  /// Key for a timer for the count and duration of when this uid was in the "cached" process
  /// state.
  static const TIMER_PROCESS_STATE_CACHED_MS = 10043;

  /// from: static public final int TIMER_PROCESS_STATE_FOREGROUND_MS
  /// Key for a timer for the count and duration of when this uid was in the "foreground"
  /// process state.
  static const TIMER_PROCESS_STATE_FOREGROUND_MS = 10041;

  /// from: static public final int TIMER_PROCESS_STATE_FOREGROUND_SERVICE_MS
  /// Key for a timer for the count and duration of when this uid was in the "foreground service"
  /// process state.
  static const TIMER_PROCESS_STATE_FOREGROUND_SERVICE_MS = 10039;

  /// from: static public final int TIMER_PROCESS_STATE_TOP_MS
  /// Key for a timer for the count and duration of when this uid was in the "top" process state.
  static const TIMER_PROCESS_STATE_TOP_MS = 10038;

  /// from: static public final int TIMER_PROCESS_STATE_TOP_SLEEPING_MS
  /// Key for a timer for the count and duration of when this uid was in the "top sleeping"
  /// process state.
  static const TIMER_PROCESS_STATE_TOP_SLEEPING_MS = 10040;

  /// from: static public final int TIMER_VIBRATOR
  /// Key for a timer for the count and duration this uid had the vibrator turned on.
  static const TIMER_VIBRATOR = 10044;

  /// from: static public final int TIMER_VIDEO
  /// Key for a timer for the count and duration of video playback done by this uid.
  static const TIMER_VIDEO = 10033;

  /// from: static public final int TIMER_WIFI_SCAN
  /// Key for a timer for the count and duration of wifi scans done by this uid.
  static const TIMER_WIFI_SCAN = 10030;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_health_UidHealthStats_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  UidHealthStats() : super.fromRef(_ctor());
}

/// Provides access to data about how various system resources are used by applications.
///@more
/// If you are going to be using this class to log your application's resource usage,
/// please consider the amount of resources (battery, network, etc) that will be used
/// by the logging itself.  It can be substantial.
///
/// __Battery Usage__<br>
/// The statistics related to power (battery) usage are recorded since the device
/// was last unplugged. It is expected that applications schedule more work to do
/// while the device is plugged in (e.g. using android.app.job.JobScheduler JobScheduler), and while that can affect charging rates, it is still preferable
/// to actually draining the battery.
class SystemHealthManager extends jni.JlObject {
  SystemHealthManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_health_SystemHealthManager_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  /// Construct a new SystemHealthManager object.
  ///@hide
  SystemHealthManager() : super.fromRef(_ctor());

  static final _takeUidSnapshot = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "android_os_health_SystemHealthManager_takeUidSnapshot")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.os.health.HealthStats takeUidSnapshot(int uid)
  /// Return a HealthStats object containing a snapshot of system health
  /// metrics for the given uid (user-id, which in usually corresponds to application).
  ///@more An application must hold the android.Manifest.permission\#BATTERY_STATS android.permission.BATTERY_STATS permission in order to retrieve any HealthStats
  /// other than its own.
  ///@param uid User ID for a given application.
  ///@return A HealthStats object containing the metrics for the requested
  /// application. The keys for this HealthStats object will be from the UidHealthStats
  /// class.
  ///@see Process\#myUid() Process.myUid()
  HealthStats takeUidSnapshot(int uid) =>
      HealthStats.fromRef(_takeUidSnapshot(reference, uid));

  static final _takeMyUidSnapshot = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>(
          "android_os_health_SystemHealthManager_takeMyUidSnapshot")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.health.HealthStats takeMyUidSnapshot()
  /// Return a HealthStats object containing a snapshot of system health
  /// metrics for the application calling this API. This method is the same as calling
  /// {@code takeUidSnapshot(Process.myUid())}.
  ///@return A HealthStats object containing the metrics for this application. The keys
  /// for this HealthStats object will be from the UidHealthStats class.
  HealthStats takeMyUidSnapshot() =>
      HealthStats.fromRef(_takeMyUidSnapshot(reference));

  static final _takeUidSnapshots = jlookup<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "android_os_health_SystemHealthManager_takeUidSnapshots")
      .asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.health.HealthStats[] takeUidSnapshots(int[] uids)
  /// Return a HealthStats object containing a snapshot of system health
  /// metrics for the given uids (user-id, which in usually corresponds to application).
  ///@more An application must hold the android.Manifest.permission\#BATTERY_STATS android.permission.BATTERY_STATS permission in order to retrieve any HealthStats
  /// other than its own.
  ///@param uids An array of User IDs to retrieve.
  ///@return An array of HealthStats objects containing the metrics for each of
  /// the requested uids. The keys for this HealthStats object will be from the
  /// UidHealthStats class.
  jni.JlObject takeUidSnapshots(jni.JlObject uids) =>
      jni.JlObject.fromRef(_takeUidSnapshots(reference, uids.reference));
}

/// Keys for HealthStats returned from
/// HealthStats\#getStats(int) HealthStats.getStats(int) with the
/// UidHealthStats\#STATS_PACKAGES UidHealthStats.STATS_PACKAGES key.
class PackageHealthStats extends jni.JlObject {
  PackageHealthStats.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int MEASUREMENTS_WAKEUP_ALARMS_COUNT
  /// Key for a map of the number of times that a package's wakeup alarms have fired
  /// while the device was on battery.
  ///@see android.app.AlarmManager
  static const MEASUREMENTS_WAKEUP_ALARMS_COUNT = 40002;

  /// from: static public final int STATS_SERVICES
  /// Key for a HealthStats with ServiceHealthStats keys for each of the
  /// services defined in this apk.
  static const STATS_SERVICES = 40001;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_health_PackageHealthStats_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  PackageHealthStats() : super.fromRef(_ctor());
}

/// Keys for HealthStats returned from
/// HealthStats\#getStats(int) HealthStats.getStats(int) with the
/// PackageHealthStats\#STATS_SERVICES PackageHealthStats.STATS_SERVICES key.
class ServiceHealthStats extends jni.JlObject {
  ServiceHealthStats.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int MEASUREMENT_LAUNCH_COUNT
  /// Key for a measurement of the total number of times this service was started
  /// due to calls to android.content.Context\#startService startService()
  /// or android.content.Context\#bindService bindService() including re-launches
  /// after crashes.
  static const MEASUREMENT_LAUNCH_COUNT = 50002;

  /// from: static public final int MEASUREMENT_START_SERVICE_COUNT
  /// Key for a measurement of the number of times this service was started due to calls to
  /// android.content.Context\#startService startService(), including re-launches
  /// after crashes.
  static const MEASUREMENT_START_SERVICE_COUNT = 50001;

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_health_ServiceHealthStats_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: void <init>()
  ServiceHealthStats() : super.fromRef(_ctor());
}

/// A TimerStat object stores a count and a time.
///@more When possible, the other APIs in this package avoid requiring a TimerStat
/// object to be constructed, even internally, but the getTimers method on
/// android.os.health.HealthStats does require TimerStat objects.
class TimerStat extends jni.JlObject {
  TimerStat.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final android.os.Parcelable.Creator<android.os.health.TimerStat> CREATOR
  /// The CREATOR instance for use by aidl Binder interfaces.
  static final _getCREATOR =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "get_android_os_health_TimerStat_CREATOR")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();
  static os.Parcelable_Creator get CREATOR =>
      os.Parcelable_Creator.fromRef(_getCREATOR());

  static final _ctor =
      jlookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
              "android_os_health_TimerStat_new")
          .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// from: public void <init>()
  /// Construct an empty TimerStat object with the count and time set to 0.
  TimerStat() : super.fromRef(_ctor());

  static final _ctor_1 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Int32, ffi.Int64)>>("android_os_health_TimerStat_new_1")
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  /// from: public void <init>(int count, long time)
  /// Construct a TimerStat object with the supplied count and time fields.
  ///@param count The count
  ///@param time The time
  TimerStat.ctor_1(int count, int time) : super.fromRef(_ctor_1(count, time));

  static final _ctor_2 = jlookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void>)>>("android_os_health_TimerStat_new_2")
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel in)
  /// Construct a TimerStat object reading the values from a android.os.Parcel Parcel
  /// object.
  TimerStat.ctor_2(os.Parcel in_) : super.fromRef(_ctor_2(in_.reference));

  static final _describeContents =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_health_TimerStat_describeContents")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  /// @inheritDoc
  int describeContents() => _describeContents(reference);

  static final _writeToParcel = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_health_TimerStat_writeToParcel")
      .asFunction<
          void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  /// Write this TimerStat object to a parcel.
  void writeToParcel(os.Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags);

  static final _setCount = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("android_os_health_TimerStat_setCount")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setCount(int count)
  /// Set the count for this timer.
  void setCount(int count) => _setCount(reference, count);

  static final _getCount =
      jlookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_health_TimerStat_getCount")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getCount()
  /// Get the count for this timer.
  int getCount() => _getCount(reference);

  static final _setTime = jlookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("android_os_health_TimerStat_setTime")
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setTime(long time)
  /// Set the time for this timer in milliseconds.
  void setTime(int time) => _setTime(reference, time);

  static final _getTime =
      jlookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<ffi.Void>)>>(
              "android_os_health_TimerStat_getTime")
          .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTime()
  /// Get the time for this timer in milliseconds.
  int getTime() => _getTime(reference);
}
