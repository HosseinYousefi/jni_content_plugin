// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_element

import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "../os.dart" as os_;

import "../content.dart" as content_;
import "../../_init.dart" show jniLookup;

/// from: android.os.storage.OnObbStateChangeListener
///
/// Used for receiving notifications from StorageManager about OBB file
/// states.
class OnObbStateChangeListener extends jni.JniObject {
  OnObbStateChangeListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final int ERROR_ALREADY_MOUNTED
  ///
  /// The OBB has already been mounted. Returned in status messages from calls
  /// made via StorageManager
  static const ERROR_ALREADY_MOUNTED = 24;

  /// from: static public final int ERROR_COULD_NOT_MOUNT
  ///
  /// The OBB could not be mounted by the system. Returned in status messages
  /// from calls made via StorageManager
  static const ERROR_COULD_NOT_MOUNT = 21;

  /// from: static public final int ERROR_COULD_NOT_UNMOUNT
  ///
  /// The OBB could not be unmounted. This most likely indicates that a file is
  /// in use on the OBB. Returned in status messages from calls made via
  /// StorageManager
  static const ERROR_COULD_NOT_UNMOUNT = 22;

  /// from: static public final int ERROR_INTERNAL
  ///
  /// There was an internal system error encountered while trying to mount the
  /// OBB. Returned in status messages from calls made via
  /// StorageManager
  static const ERROR_INTERNAL = 20;

  /// from: static public final int ERROR_NOT_MOUNTED
  ///
  /// A call was made to unmount the OBB when it was not mounted. Returned in
  /// status messages from calls made via StorageManager
  static const ERROR_NOT_MOUNTED = 23;

  /// from: static public final int ERROR_PERMISSION_DENIED
  ///
  /// The current application does not have permission to use this OBB. This
  /// could be because the OBB indicates it's owned by a different package or
  /// some other error. Returned in status messages from calls made via
  /// StorageManager
  static const ERROR_PERMISSION_DENIED = 25;

  /// from: static public final int MOUNTED
  ///
  /// The OBB container is now mounted and ready for use. Returned in status
  /// messages from calls made via StorageManager
  static const MOUNTED = 1;

  /// from: static public final int UNMOUNTED
  ///
  /// The OBB container is now unmounted and not usable. Returned in status
  /// messages from calls made via StorageManager
  static const UNMOUNTED = 2;

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "OnObbStateChangeListener__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  OnObbStateChangeListener() : super.fromRef(_ctor().object);

  static final _onObbStateChange = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("OnObbStateChangeListener__onObbStateChange")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onObbStateChange(java.lang.String path, int state)
  ///
  /// Called when an OBB has changed states.
  ///@param path path to the OBB file the state change has happened on
  ///@param state the current state of the OBB
  void onObbStateChange(jni.JniString path, int state) =>
      _onObbStateChange(reference, path.reference, state).check();
}

/// from: android.os.storage.StorageManager
///
/// StorageManager is the interface to the systems storage service. The storage
/// manager handles storage-related items such as Opaque Binary Blobs (OBBs).
///
/// OBBs contain a filesystem that maybe be encrypted on disk and mounted
/// on-demand from an application. OBBs are a good way of providing large amounts
/// of binary assets without packaging them into APKs as they may be multiple
/// gigabytes in size. However, due to their size, they're most likely stored in
/// a shared storage pool accessible from all programs. The system does not
/// guarantee the security of the OBB file itself: if any program modifies the
/// OBB, there is no guarantee that a read from that OBB will produce the
/// expected output.
class StorageManager extends jni.JniObject {
  StorageManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_MANAGE_STORAGE
  ///
  /// Activity Action: Allows the user to manage their storage. This activity
  /// provides the ability to free up space on the device by deleting data such
  /// as apps.
  ///
  /// If the sending application has a specific storage device or allocation
  /// size in mind, they can optionally define \#EXTRA_UUID or
  /// \#EXTRA_REQUESTED_BYTES, respectively.
  ///
  /// This intent should be launched using
  /// Activity\#startActivityForResult(Intent, int) so that the user
  /// knows which app is requesting the storage space. The returned result will
  /// be Activity\#RESULT_OK if the requested space was made available,
  /// or Activity\#RESULT_CANCELED otherwise.
  static const ACTION_MANAGE_STORAGE =
      "android.os.storage.action.MANAGE_STORAGE";

  /// from: static public final java.lang.String EXTRA_REQUESTED_BYTES
  ///
  /// Extra used to indicate the total size (in bytes) that an application is
  /// interested in allocating.
  ///
  /// When defined, the management UI will help guide the user to free up
  /// enough disk space to reach this requested value.
  ///@see \#ACTION_MANAGE_STORAGE
  static const EXTRA_REQUESTED_BYTES =
      "android.os.storage.extra.REQUESTED_BYTES";

  /// from: static public final java.lang.String EXTRA_UUID
  ///
  /// Extra UUID used to indicate the storage volume where an
  /// application is interested in allocating or managing disk space.
  ///@see \#ACTION_MANAGE_STORAGE
  ///@see \#UUID_DEFAULT
  ///@see \#getUuidForPath(File)
  ///@see Intent\#putExtra(String, java.io.Serializable)
  static const EXTRA_UUID = "android.os.storage.extra.UUID";

  static final _get_UUID_DEFAULT =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_StorageManager__UUID_DEFAULT")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.util.UUID UUID_DEFAULT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// UUID representing the default internal storage of this device which
  /// provides Environment\#getDataDirectory().
  ///
  /// This value is constant across all devices and it will never change, and
  /// thus it cannot be used to uniquely identify a particular physical device.
  ///@see \#getUuidForPath(File)
  ///@see ApplicationInfo\#storageUuid
  static jni.JniObject get UUID_DEFAULT =>
      jni.JniObject.fromRef(_get_UUID_DEFAULT().object);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "StorageManager__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  StorageManager() : super.fromRef(_ctor().object);

  static final _mountObb = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("StorageManager__mountObb")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean mountObb(java.lang.String rawPath, java.lang.String key, android.os.storage.OnObbStateChangeListener listener)
  ///
  /// Mount an Opaque Binary Blob (OBB) file. If a <code>key</code> is
  /// specified, it is supplied to the mounting process to be used in any
  /// encryption used in the OBB.
  ///
  /// The OBB will remain mounted for as long as the StorageManager reference
  /// is held by the application. As soon as this reference is lost, the OBBs
  /// in use will be unmounted. The OnObbStateChangeListener registered
  /// with this call will receive the success or failure of this operation.
  ///
  /// _Note:_ you can only mount OBB files for which the OBB tag on the
  /// file matches a package ID that is owned by the calling program's UID.
  /// That is, shared UID applications can attempt to mount any other
  /// application's OBB that shares its UID.
  ///@param rawPath the path to the OBB file
  ///@param key secret used to encrypt the OBB; may be <code>null</code> if no
  ///            encryption was used on the OBB.
  ///@param listener will receive the success or failure of the operation
  ///@return whether the mount call was successfully queued or not
  bool mountObb(jni.JniString rawPath, jni.JniString key,
          OnObbStateChangeListener listener) =>
      _mountObb(reference, rawPath.reference, key.reference, listener.reference)
          .boolean;

  static final _unmountObb = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Pointer<ffi.Void>)>>("StorageManager__unmountObb")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean unmountObb(java.lang.String rawPath, boolean force, android.os.storage.OnObbStateChangeListener listener)
  ///
  /// Unmount an Opaque Binary Blob (OBB) file asynchronously. If the
  /// <code>force</code> flag is true, it will kill any application needed to
  /// unmount the given OBB (even the calling application).
  ///
  /// The OnObbStateChangeListener registered with this call will
  /// receive the success or failure of this operation.
  ///
  /// _Note:_ you can only mount OBB files for which the OBB tag on the
  /// file matches a package ID that is owned by the calling program's UID.
  /// That is, shared UID applications can obtain access to any other
  /// application's OBB that shares its UID.
  ///
  ///@param rawPath path to the OBB file
  ///@param force whether to kill any programs using this in order to unmount
  ///            it
  ///@param listener will receive the success or failure of the operation
  ///@return whether the unmount call was successfully queued or not
  bool unmountObb(jni.JniString rawPath, bool force,
          OnObbStateChangeListener listener) =>
      _unmountObb(
              reference, rawPath.reference, force ? 1 : 0, listener.reference)
          .boolean;

  static final _isObbMounted = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("StorageManager__isObbMounted")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isObbMounted(java.lang.String rawPath)
  ///
  /// Check whether an Opaque Binary Blob (OBB) is mounted or not.
  ///@param rawPath path to OBB image
  ///@return true if OBB is mounted; false if not mounted or on error
  bool isObbMounted(jni.JniString rawPath) =>
      _isObbMounted(reference, rawPath.reference).boolean;

  static final _getMountedObbPath = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("StorageManager__getMountedObbPath")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getMountedObbPath(java.lang.String rawPath)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Check the mounted path of an Opaque Binary Blob (OBB) file. This will
  /// give you the path to where you can obtain access to the internals of the
  /// OBB.
  ///@param rawPath path to OBB image
  ///@return absolute path to mounted OBB image data or <code>null</code> if
  ///         not mounted or exception encountered trying to read status
  jni.JniString getMountedObbPath(jni.JniString rawPath) =>
      jni.JniString.fromRef(
          _getMountedObbPath(reference, rawPath.reference).object);

  static final _getUuidForPath = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("StorageManager__getUuidForPath")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.UUID getUuidForPath(java.io.File path)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a UUID identifying the storage volume that hosts the given
  /// filesystem path.
  ///
  /// If this path is hosted by the default internal storage of the device at
  /// Environment\#getDataDirectory(), the returned value will be
  /// \#UUID_DEFAULT.
  ///@throws IOException when the storage device hosting the given path isn't
  ///             present, or when it doesn't have a valid UUID.
  ///@param path This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  jni.JniObject getUuidForPath(jni.JniObject path) =>
      jni.JniObject.fromRef(_getUuidForPath(reference, path.reference).object);

  static final _isAllocationSupported = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "StorageManager__isAllocationSupported")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isAllocationSupported(java.io.FileDescriptor fd)
  ///
  /// Test if the given file descriptor supports allocation of disk space using
  /// \#allocateBytes(FileDescriptor, long).
  ///@param fd This value must never be {@code null}.
  bool isAllocationSupported(jni.JniObject fd) =>
      _isAllocationSupported(reference, fd.reference).boolean;

  static final _getStorageVolume = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("StorageManager__getStorageVolume")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.storage.StorageVolume getStorageVolume(java.io.File file)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the StorageVolume that contains the given file, or {@code null} if none.
  StorageVolume getStorageVolume(jni.JniObject file) => StorageVolume.fromRef(
      _getStorageVolume(reference, file.reference).object);

  static final _getStorageVolumes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("StorageManager__getStorageVolumes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.os.storage.StorageVolume> getStorageVolumes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the list of shared/external storage volumes available to the
  /// current user. This includes both the primary shared storage device and
  /// any attached external volumes including SD cards and USB drives.
  ///@see Environment\#getExternalStorageDirectory()
  ///@see StorageVolume\#createAccessIntent(String)
  ///@return This value will never be {@code null}.
  jni.JniObject getStorageVolumes() =>
      jni.JniObject.fromRef(_getStorageVolumes(reference).object);

  static final _getPrimaryStorageVolume = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "StorageManager__getPrimaryStorageVolume")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.storage.StorageVolume getPrimaryStorageVolume()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the primary shared/external storage volume available to the
  /// current user. This volume is the same storage device returned by
  /// Environment\#getExternalStorageDirectory() and
  /// Context\#getExternalFilesDir(String).
  ///@return This value will never be {@code null}.
  StorageVolume getPrimaryStorageVolume() =>
      StorageVolume.fromRef(_getPrimaryStorageVolume(reference).object);

  static final _isEncrypted = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("StorageManager__isEncrypted")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isEncrypted(java.io.File file)
  ///
  /// Return if data stored at or under the given path will be encrypted while
  /// at rest. This can help apps avoid the overhead of double-encrypting data.
  bool isEncrypted(jni.JniObject file) =>
      _isEncrypted(reference, file.reference).boolean;

  static final _openProxyFileDescriptor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "StorageManager__openProxyFileDescriptor")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.ParcelFileDescriptor openProxyFileDescriptor(int mode, android.os.ProxyFileDescriptorCallback callback, android.os.Handler handler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Opens a seekable ParcelFileDescriptor that proxies all low-level
  /// I/O requests back to the given ProxyFileDescriptorCallback.
  ///
  /// This can be useful when you want to provide quick access to a large file
  /// that isn't backed by a real file on disk, such as a file on a network
  /// share, cloud storage service, etc. As an example, you could respond to a
  /// ContentResolver\#openFileDescriptor(android.net.Uri, String)
  /// request by returning a ParcelFileDescriptor created with this
  /// method, and then stream the content on-demand as requested.
  ///
  /// Another useful example might be where you have an encrypted file that
  /// you're willing to decrypt on-demand, but where you want to avoid
  /// persisting the cleartext version.
  ///@param mode The desired access mode, must be one of
  ///            ParcelFileDescriptor\#MODE_READ_ONLY,
  ///            ParcelFileDescriptor\#MODE_WRITE_ONLY, or
  ///            ParcelFileDescriptor\#MODE_READ_WRITE
  ///@param callback Callback to process file operation requests issued on
  ///            returned file descriptor.
  ///@param handler Handler that invokes callback methods.
  ///@return Seekable ParcelFileDescriptor.
  /// This value will never be {@code null}.
  ///@throws IOException
  os_.ParcelFileDescriptor openProxyFileDescriptor(int mode,
          os_.ProxyFileDescriptorCallback callback, os_.Handler handler) =>
      os_.ParcelFileDescriptor.fromRef(_openProxyFileDescriptor(
              reference, mode, callback.reference, handler.reference)
          .object);

  static final _getCacheQuotaBytes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("StorageManager__getCacheQuotaBytes")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public long getCacheQuotaBytes(java.util.UUID storageUuid)
  ///
  /// Return quota size in bytes for all cached data belonging to the calling
  /// app on the given storage volume.
  ///
  /// If your app goes above this quota, your cached files will be some of the
  /// first to be deleted when additional disk space is needed. Conversely, if
  /// your app stays under this quota, your cached files will be some of the
  /// last to be deleted when additional disk space is needed.
  ///
  /// This quota will change over time depending on how frequently the user
  /// interacts with your app, and depending on how much system-wide disk space
  /// is used.
  /// <p class="note">
  /// Note: if your app uses the {@code android:sharedUserId} manifest feature,
  /// then cached data for all packages in your shared UID is tracked together
  /// as a single unit.
  ///
  ///
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  /// Value is a non-negative number of bytes.
  ///@param storageUuid the UUID of the storage volume that you're interested
  ///            in. The UUID for a specific path can be obtained using
  ///            \#getUuidForPath(File).
  /// This value must never be {@code null}.
  ///@throws IOException when the storage device isn't present, or when it
  ///             doesn't support cache quotas.
  ///@see \#getCacheSizeBytes(UUID)
  ///@return Value is a non-negative number of bytes.
  int getCacheQuotaBytes(jni.JniObject storageUuid) =>
      _getCacheQuotaBytes(reference, storageUuid.reference).long;

  static final _getCacheSizeBytes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("StorageManager__getCacheSizeBytes")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public long getCacheSizeBytes(java.util.UUID storageUuid)
  ///
  /// Return total size in bytes of all cached data belonging to the calling
  /// app on the given storage volume.
  ///
  /// Cached data tracked by this method always includes
  /// Context\#getCacheDir() and Context\#getCodeCacheDir(), and
  /// it also includes Context\#getExternalCacheDir() if the primary
  /// shared/external storage is hosted on the same storage device as your
  /// private data.
  /// <p class="note">
  /// Note: if your app uses the {@code android:sharedUserId} manifest feature,
  /// then cached data for all packages in your shared UID is tracked together
  /// as a single unit.
  ///
  ///
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  /// Value is a non-negative number of bytes.
  ///@param storageUuid the UUID of the storage volume that you're interested
  ///            in. The UUID for a specific path can be obtained using
  ///            \#getUuidForPath(File).
  /// This value must never be {@code null}.
  ///@throws IOException when the storage device isn't present, or when it
  ///             doesn't support cache quotas.
  ///@see \#getCacheQuotaBytes(UUID)
  ///@return Value is a non-negative number of bytes.
  int getCacheSizeBytes(jni.JniObject storageUuid) =>
      _getCacheSizeBytes(reference, storageUuid.reference).long;

  static final _getAllocatableBytes = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "StorageManager__getAllocatableBytes")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public long getAllocatableBytes(java.util.UUID storageUuid)
  ///
  /// Return the maximum number of new bytes that your app can allocate for
  /// itself on the given storage volume. This value is typically larger than
  /// File\#getUsableSpace(), since the system may be willing to delete
  /// cached files to satisfy an allocation request. You can then allocate
  /// space for yourself using \#allocateBytes(UUID, long) or
  /// \#allocateBytes(FileDescriptor, long).
  ///
  /// This method is best used as a pre-flight check, such as deciding if there
  /// is enough space to store an entire music album before you allocate space
  /// for each audio file in the album. Attempts to allocate disk space beyond
  /// the returned value will fail.
  ///
  /// If the returned value is not large enough for the data you'd like to
  /// persist, you can launch \#ACTION_MANAGE_STORAGE with the
  /// \#EXTRA_UUID and \#EXTRA_REQUESTED_BYTES options to help
  /// involve the user in freeing up disk space.
  ///
  /// If you're progressively allocating an unbounded amount of storage space
  /// (such as when recording a video) you should avoid calling this method
  /// more than once every 30 seconds.
  /// <p class="note">
  /// Note: if your app uses the {@code android:sharedUserId} manifest feature,
  /// then allocatable space for all packages in your shared UID is tracked
  /// together as a single unit.
  ///
  ///
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  /// Value is a non-negative number of bytes.
  ///@param storageUuid the UUID of the storage volume where you're
  ///            considering allocating disk space, since allocatable space can
  ///            vary widely depending on the underlying storage device. The
  ///            UUID for a specific path can be obtained using
  ///            \#getUuidForPath(File).
  /// This value must never be {@code null}.
  ///@return the maximum number of new bytes that the calling app can allocate
  ///         using \#allocateBytes(UUID, long) or
  ///         \#allocateBytes(FileDescriptor, long).
  /// Value is a non-negative number of bytes.
  ///@throws IOException when the storage device isn't present, or when it
  ///             doesn't support allocating space.
  int getAllocatableBytes(jni.JniObject storageUuid) =>
      _getAllocatableBytes(reference, storageUuid.reference).long;

  static final _allocateBytes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("StorageManager__allocateBytes")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void allocateBytes(java.util.UUID storageUuid, long bytes)
  ///
  /// Allocate the requested number of bytes for your application to use on the
  /// given storage volume. This will cause the system to delete any cached
  /// files necessary to satisfy your request.
  ///
  /// Attempts to allocate disk space beyond the value returned by
  /// \#getAllocatableBytes(UUID) will fail.
  ///
  /// Since multiple apps can be running simultaneously, this method may be
  /// subject to race conditions. If possible, consider using
  /// \#allocateBytes(FileDescriptor, long) which will guarantee
  /// that bytes are allocated to an opened file.
  ///
  /// If you're progressively allocating an unbounded amount of storage space
  /// (such as when recording a video) you should avoid calling this method
  /// more than once every 60 seconds.
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param storageUuid the UUID of the storage volume where you'd like to
  ///            allocate disk space. The UUID for a specific path can be
  ///            obtained using \#getUuidForPath(File).
  /// This value must never be {@code null}.
  ///@param bytes the number of bytes to allocate.
  /// Value is a non-negative number of bytes.
  ///@throws IOException when the storage device isn't present, or when it
  ///             doesn't support allocating space, or if the device had
  ///             trouble allocating the requested space.
  ///@see \#getAllocatableBytes(UUID)
  void allocateBytes(jni.JniObject storageUuid, int bytes) =>
      _allocateBytes(reference, storageUuid.reference, bytes).check();

  static final _allocateBytes1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("StorageManager__allocateBytes1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void allocateBytes(java.io.FileDescriptor fd, long bytes)
  ///
  /// Allocate the requested number of bytes for your application to use in the
  /// given open file. This will cause the system to delete any cached files
  /// necessary to satisfy your request.
  ///
  /// Attempts to allocate disk space beyond the value returned by
  /// \#getAllocatableBytes(UUID) will fail.
  ///
  /// This method guarantees that bytes have been allocated to the opened file,
  /// otherwise it will throw if fast allocation is not possible. Fast
  /// allocation is typically only supported in private app data directories,
  /// and on shared/external storage devices which are emulated.
  ///
  /// If you're progressively allocating an unbounded amount of storage space
  /// (such as when recording a video) you should avoid calling this method
  /// more than once every 60 seconds.
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param fd the open file that you'd like to allocate disk space for.
  ///@param bytes the number of bytes to allocate. This is the desired final
  ///            size of the open file. If the open file is smaller than this
  ///            requested size, it will be extended without modifying any
  ///            existing contents. If the open file is larger than this
  ///            requested size, it will be truncated.
  /// Value is a non-negative number of bytes.
  ///@throws IOException when the storage device isn't present, or when it
  ///             doesn't support allocating space, or if the device had
  ///             trouble allocating the requested space.
  ///@see \#getAllocatableBytes(UUID, int)
  ///@see \#isAllocationSupported(FileDescriptor)
  ///@see Environment\#isExternalStorageEmulated(File)
  void allocateBytes1(jni.JniObject fd, int bytes) =>
      _allocateBytes1(reference, fd.reference, bytes).check();

  static final _setCacheBehaviorGroup = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("StorageManager__setCacheBehaviorGroup")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setCacheBehaviorGroup(java.io.File path, boolean group)
  ///
  /// Enable or disable special cache behavior that treats this directory and
  /// its contents as an entire group.
  ///
  /// When enabled and this directory is considered for automatic deletion by
  /// the OS, all contained files will either be deleted together, or not at
  /// all. This is useful when you have a directory that contains several
  /// related metadata files that depend on each other, such as movie file and
  /// a subtitle file.
  ///
  /// When enabled, the _newest_ File\#lastModified() value of
  /// any contained files is considered the modified time of the entire
  /// directory.
  ///
  /// This behavior can only be set on a directory, and it applies recursively
  /// to all contained files and directories.
  void setCacheBehaviorGroup(jni.JniObject path, bool group) =>
      _setCacheBehaviorGroup(reference, path.reference, group ? 1 : 0).check();

  static final _isCacheBehaviorGroup = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "StorageManager__isCacheBehaviorGroup")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isCacheBehaviorGroup(java.io.File path)
  ///
  /// Read the current value set by
  /// \#setCacheBehaviorGroup(File, boolean).
  bool isCacheBehaviorGroup(jni.JniObject path) =>
      _isCacheBehaviorGroup(reference, path.reference).boolean;

  static final _setCacheBehaviorTombstone = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("StorageManager__setCacheBehaviorTombstone")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setCacheBehaviorTombstone(java.io.File path, boolean tombstone)
  ///
  /// Enable or disable special cache behavior that leaves deleted cache files
  /// intact as tombstones.
  ///
  /// When enabled and a file contained in this directory is automatically
  /// deleted by the OS, the file will be truncated to have a length of 0 bytes
  /// instead of being fully deleted. This is useful if you need to distinguish
  /// between a file that was deleted versus one that never existed.
  ///
  /// This behavior can only be set on a directory, and it applies recursively
  /// to all contained files and directories.
  /// <p class="note">
  /// Note: this behavior is ignored completely if the user explicitly requests
  /// that all cached data be cleared.
  ///
  ///
  void setCacheBehaviorTombstone(jni.JniObject path, bool tombstone) =>
      _setCacheBehaviorTombstone(reference, path.reference, tombstone ? 1 : 0)
          .check();

  static final _isCacheBehaviorTombstone = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "StorageManager__isCacheBehaviorTombstone")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isCacheBehaviorTombstone(java.io.File path)
  ///
  /// Read the current value set by
  /// \#setCacheBehaviorTombstone(File, boolean).
  bool isCacheBehaviorTombstone(jni.JniObject path) =>
      _isCacheBehaviorTombstone(reference, path.reference).boolean;
}

/// from: android.os.storage.StorageVolume
///
/// Information about a shared/external storage volume for a specific user.
///
///
/// A device always has one (and one only) primary storage volume, but it could have extra volumes,
/// like SD cards and USB drives. This object represents the logical view of a storage
/// volume for a specific user: different users might have different views for the same physical
/// volume (for example, if the volume is a built-in emulated storage).
///
///
/// The storage volume is not necessarily mounted, applications should use \#getState() to
/// verify its state.
///
///
/// Applications willing to read or write to this storage volume needs to get a permission from the
/// user first, which can be achieved in the following ways:
///
/// <ul>
/// <li>To get access to standard directories (like the Environment\#DIRECTORY_PICTURES), they
/// can use the \#createAccessIntent(String). This is the recommend way, since it provides a
/// simpler API and narrows the access to the given directory (and its descendants).
/// <li>To get access to any directory (and its descendants), they can use the Storage Acess
/// Framework APIs (such as Intent\#ACTION_OPEN_DOCUMENT and
/// Intent\#ACTION_OPEN_DOCUMENT_TREE, although these APIs do not guarantee the user will
/// select this specific volume.
/// <li>To get read and write access to the primary storage volume, applications can declare the
/// android.Manifest.permission\#READ_EXTERNAL_STORAGE and
/// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE permissions respectively, with the
/// latter including the former. This approach is discouraged, since users may be hesitant to grant
/// broad access to all files contained on a storage device.
/// </ul>
///
/// It can be obtained through StorageManager\#getStorageVolumes() and
/// StorageManager\#getPrimaryStorageVolume() and also as an extra in some broadcasts
/// (see \#EXTRA_STORAGE_VOLUME).
///
///
/// See Environment\#getExternalStorageDirectory() for more info about shared/external
/// storage semantics.
class StorageVolume extends jni.JniObject {
  StorageVolume.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_StorageVolume__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.os.storage.StorageVolume> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  /// from: static public final java.lang.String EXTRA_STORAGE_VOLUME
  ///
  /// Name of the Parcelable extra in the Intent\#ACTION_MEDIA_REMOVED,
  /// Intent\#ACTION_MEDIA_UNMOUNTED, Intent\#ACTION_MEDIA_CHECKING,
  /// Intent\#ACTION_MEDIA_NOFS, Intent\#ACTION_MEDIA_MOUNTED,
  /// Intent\#ACTION_MEDIA_SHARED, Intent\#ACTION_MEDIA_BAD_REMOVAL,
  /// Intent\#ACTION_MEDIA_UNMOUNTABLE, and Intent\#ACTION_MEDIA_EJECT broadcast that
  /// contains a StorageVolume.
  static const EXTRA_STORAGE_VOLUME = "android.os.storage.extra.STORAGE_VOLUME";

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("StorageVolume__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Parcel in)
  StorageVolume(os_.Parcel in0) : super.fromRef(_ctor(in0.reference).object);

  static final _getDescription = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("StorageVolume__getDescription")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getDescription(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a user-visible description of the volume.
  ///@return the volume description
  jni.JniString getDescription(content_.Context context) =>
      jni.JniString.fromRef(
          _getDescription(reference, context.reference).object);

  static final _isPrimary = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("StorageVolume__isPrimary")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isPrimary()
  ///
  /// Returns true if the volume is the primary shared/external storage, which is the volume
  /// backed by Environment\#getExternalStorageDirectory().
  bool isPrimary() => _isPrimary(reference).boolean;

  static final _isRemovable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("StorageVolume__isRemovable")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isRemovable()
  ///
  /// Returns true if the volume is removable.
  ///@return is removable
  bool isRemovable() => _isRemovable(reference).boolean;

  static final _isEmulated = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("StorageVolume__isEmulated")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isEmulated()
  ///
  /// Returns true if the volume is emulated.
  ///@return is removable
  bool isEmulated() => _isEmulated(reference).boolean;

  static final _getUuid = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("StorageVolume__getUuid")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getUuid()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the volume UUID, if any.
  ///@return This value may be {@code null}.
  jni.JniString getUuid() => jni.JniString.fromRef(_getUuid(reference).object);

  static final _getState = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("StorageVolume__getState")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current state of the volume.
  ///@return one of Environment\#MEDIA_UNKNOWN, Environment\#MEDIA_REMOVED,
  ///         Environment\#MEDIA_UNMOUNTED, Environment\#MEDIA_CHECKING,
  ///         Environment\#MEDIA_NOFS, Environment\#MEDIA_MOUNTED,
  ///         Environment\#MEDIA_MOUNTED_READ_ONLY, Environment\#MEDIA_SHARED,
  ///         Environment\#MEDIA_BAD_REMOVAL, or Environment\#MEDIA_UNMOUNTABLE.
  jni.JniString getState() =>
      jni.JniString.fromRef(_getState(reference).object);

  static final _createAccessIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("StorageVolume__createAccessIntent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent createAccessIntent(java.lang.String directoryName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Builds an intent to give access to a standard storage directory or entire volume after
  /// obtaining the user's approval.
  ///
  /// When invoked, the system will ask the user to grant access to the requested directory (and
  /// its descendants). The result of the request will be returned to the activity through the
  /// {@code onActivityResult} method.
  ///
  /// To gain access to descendants (child, grandchild, etc) documents, use
  /// DocumentsContract\#buildDocumentUriUsingTree(Uri, String), or
  /// DocumentsContract\#buildChildDocumentsUriUsingTree(Uri, String) with the returned URI.
  ///
  /// If your application only needs to store internal data, consider using
  /// Context\#getExternalFilesDirs(String) Context.getExternalFilesDirs,
  /// Context\#getExternalCacheDirs(), or Context\#getExternalMediaDirs(), which
  /// require no permissions to read or write.
  ///
  /// Access to the entire volume is only available for non-primary volumes (for the primary
  /// volume, apps can use the android.Manifest.permission\#READ_EXTERNAL_STORAGE and
  /// android.Manifest.permission\#WRITE_EXTERNAL_STORAGE permissions) and should be used
  /// with caution, since users are more likely to deny access when asked for entire volume access
  /// rather than specific directories.
  ///@param directoryName must be one of Environment\#DIRECTORY_MUSIC,
  ///            Environment\#DIRECTORY_PODCASTS, Environment\#DIRECTORY_RINGTONES,
  ///            Environment\#DIRECTORY_ALARMS, Environment\#DIRECTORY_NOTIFICATIONS,
  ///            Environment\#DIRECTORY_PICTURES, Environment\#DIRECTORY_MOVIES,
  ///            Environment\#DIRECTORY_DOWNLOADS, Environment\#DIRECTORY_DCIM, or
  ///            Environment\#DIRECTORY_DOCUMENTS, or {@code null} to request access to the
  ///            entire volume.
  ///@return intent to request access, or {@code null} if the requested directory is invalid for
  ///         that volume.
  ///@see DocumentsContract
  content_.Intent createAccessIntent(jni.JniString directoryName) =>
      content_.Intent.fromRef(
          _createAccessIntent(reference, directoryName.reference).object);

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("StorageVolume__equals1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object obj)
  bool equals1(jni.JniObject obj) => _equals1(reference, obj.reference).boolean;

  static final _hashCode1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("StorageVolume__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() => _hashCode1(reference).integer;

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("StorageVolume__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("StorageVolume__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("StorageVolume__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  void writeToParcel(os_.Parcel parcel, int flags) =>
      _writeToParcel(reference, parcel.reference, flags).check();
}
