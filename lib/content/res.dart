// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_element

import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "../os.dart" as os_;
import "../_init.dart" show jniLookup;

/// from: android.content.res.AssetFileDescriptor
///
/// File descriptor of an entry in the AssetManager.  This provides your own
/// opened FileDescriptor that can be used to read the data, as well as the
/// offset and length of that entry's data in the file.
class AssetFileDescriptor extends jni.JniObject {
  AssetFileDescriptor.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_AssetFileDescriptor__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.res.AssetFileDescriptor> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  /// from: static public final long UNKNOWN_LENGTH
  ///
  /// Length used with \#AssetFileDescriptor(ParcelFileDescriptor, long, long)
  /// and \#getDeclaredLength when a length has not been declared.  This means
  /// the data extends to the end of the file.
  static const UNKNOWN_LENGTH = -1;

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Int64)>>("AssetFileDescriptor__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void <init>(android.os.ParcelFileDescriptor fd, long startOffset, long length)
  ///
  /// Create a new AssetFileDescriptor from the given values.
  ///@param fd The underlying file descriptor.
  ///@param startOffset The location within the file that the asset starts.
  ///            This must be 0 if length is UNKNOWN_LENGTH.
  ///@param length The number of bytes of the asset, or
  ///            \#UNKNOWN_LENGTH if it extends to the end of the file.
  AssetFileDescriptor(os_.ParcelFileDescriptor fd, int startOffset, int length)
      : super.fromRef(_ctor(fd.reference, startOffset, length).object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("AssetFileDescriptor__ctor1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.ParcelFileDescriptor fd, long startOffset, long length, android.os.Bundle extras)
  ///
  /// Create a new AssetFileDescriptor from the given values.
  ///@param fd The underlying file descriptor.
  ///@param startOffset The location within the file that the asset starts.
  ///            This must be 0 if length is UNKNOWN_LENGTH.
  ///@param length The number of bytes of the asset, or
  ///            \#UNKNOWN_LENGTH if it extends to the end of the file.
  ///@param extras additional details that can be used to interpret the
  ///            underlying file descriptor. May be null.
  AssetFileDescriptor.ctor1(os_.ParcelFileDescriptor fd, int startOffset,
      int length, os_.Bundle extras)
      : super.fromRef(
            _ctor1(fd.reference, startOffset, length, extras.reference).object);

  static final _getParcelFileDescriptor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetFileDescriptor__getParcelFileDescriptor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.ParcelFileDescriptor getParcelFileDescriptor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The AssetFileDescriptor contains its own ParcelFileDescriptor, which
  /// in addition to the normal FileDescriptor object also allows you to close
  /// the descriptor when you are done with it.
  os_.ParcelFileDescriptor getParcelFileDescriptor() =>
      os_.ParcelFileDescriptor.fromRef(
          _getParcelFileDescriptor(reference).object);

  static final _getFileDescriptor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetFileDescriptor__getFileDescriptor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.FileDescriptor getFileDescriptor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the FileDescriptor that can be used to read the data in the
  /// file.
  jni.JniObject getFileDescriptor() =>
      jni.JniObject.fromRef(_getFileDescriptor(reference).object);

  static final _getStartOffset = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetFileDescriptor__getStartOffset")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getStartOffset()
  ///
  /// Returns the byte offset where this asset entry's data starts.
  int getStartOffset() => _getStartOffset(reference).long;

  static final _getExtras = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AssetFileDescriptor__getExtras")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns any additional details that can be used to interpret the
  /// underlying file descriptor. May be null.
  os_.Bundle getExtras() => os_.Bundle.fromRef(_getExtras(reference).object);

  static final _getLength = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AssetFileDescriptor__getLength")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getLength()
  ///
  /// Returns the total number of bytes of this asset entry's data.  May be
  /// \#UNKNOWN_LENGTH if the asset extends to the end of the file.
  /// If the AssetFileDescriptor was constructed with \#UNKNOWN_LENGTH,
  /// this will use ParcelFileDescriptor\#getStatSize() ParcelFileDescriptor.getStatSize() to find the total size of the file,
  /// returning that number if found or \#UNKNOWN_LENGTH if it could
  /// not be determined.
  ///@see \#getDeclaredLength()
  int getLength() => _getLength(reference).long;

  static final _getDeclaredLength = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetFileDescriptor__getDeclaredLength")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getDeclaredLength()
  ///
  /// Return the actual number of bytes that were declared when the
  /// AssetFileDescriptor was constructed.  Will be
  /// \#UNKNOWN_LENGTH if the length was not declared, meaning data
  /// should be read to the end of the file.
  ///@see \#getDeclaredLength()
  int getDeclaredLength() => _getDeclaredLength(reference).long;

  static final _close = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AssetFileDescriptor__close")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void close()
  ///
  /// Convenience for calling <code>getParcelFileDescriptor().close()</code>.
  void close() => _close(reference).check();

  static final _createInputStream = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetFileDescriptor__createInputStream")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.FileInputStream createInputStream()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create and return a new auto-close input stream for this asset.  This
  /// will either return a full asset AutoCloseInputStream, or
  /// an underlying ParcelFileDescriptor.AutoCloseInputStream ParcelFileDescriptor.AutoCloseInputStream depending on whether the
  /// the object represents a complete file or sub-section of a file.  You
  /// should only call this once for a particular asset.
  jni.JniObject createInputStream() =>
      jni.JniObject.fromRef(_createInputStream(reference).object);

  static final _createOutputStream = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetFileDescriptor__createOutputStream")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.FileOutputStream createOutputStream()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create and return a new auto-close output stream for this asset.  This
  /// will either return a full asset AutoCloseOutputStream, or
  /// an underlying ParcelFileDescriptor.AutoCloseOutputStream ParcelFileDescriptor.AutoCloseOutputStream depending on whether the
  /// the object represents a complete file or sub-section of a file.  You
  /// should only call this once for a particular asset.
  jni.JniObject createOutputStream() =>
      jni.JniObject.fromRef(_createOutputStream(reference).object);

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AssetFileDescriptor__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetFileDescriptor__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("AssetFileDescriptor__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os_.Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags).check();
}

/// from: android.content.res.AssetFileDescriptor$AutoCloseOutputStream
///
/// An OutputStream you can create on a ParcelFileDescriptor, which will
/// take care of calling ParcelFileDescriptor\#close ParcelFileDescriptor.close() for you when the stream is closed.
class AssetFileDescriptor_AutoCloseOutputStream
    extends os_.ParcelFileDescriptor_AutoCloseOutputStream {
  AssetFileDescriptor_AutoCloseOutputStream.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetFileDescriptor_AutoCloseOutputStream__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.res.AssetFileDescriptor fd)
  AssetFileDescriptor_AutoCloseOutputStream.ctor1(AssetFileDescriptor fd)
      : super.fromRef(_ctor1(fd.reference).object);

  static final _write = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "AssetFileDescriptor_AutoCloseOutputStream__write")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void write(byte[] buffer, int offset, int count)
  void write(jni.JniObject buffer, int offset, int count) =>
      _write(reference, buffer.reference, offset, count).check();

  static final _write1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "AssetFileDescriptor_AutoCloseOutputStream__write1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void write(byte[] buffer)
  void write1(jni.JniObject buffer) =>
      _write1(reference, buffer.reference).check();

  static final _write2 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "AssetFileDescriptor_AutoCloseOutputStream__write2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void write(int oneByte)
  void write2(int oneByte) => _write2(reference, oneByte).check();
}

/// from: android.content.res.AssetFileDescriptor$AutoCloseInputStream
///
/// An InputStream you can create on a ParcelFileDescriptor, which will
/// take care of calling ParcelFileDescriptor\#close ParcelFileDescriptor.close() for you when the stream is closed.
class AssetFileDescriptor_AutoCloseInputStream
    extends os_.ParcelFileDescriptor_AutoCloseInputStream {
  AssetFileDescriptor_AutoCloseInputStream.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetFileDescriptor_AutoCloseInputStream__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.res.AssetFileDescriptor fd)
  AssetFileDescriptor_AutoCloseInputStream.ctor1(AssetFileDescriptor fd)
      : super.fromRef(_ctor1(fd.reference).object);

  static final _available = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetFileDescriptor_AutoCloseInputStream__available")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int available()
  int available() => _available(reference).integer;

  static final _read = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetFileDescriptor_AutoCloseInputStream__read")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int read()
  int read() => _read(reference).integer;

  static final _read2 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>(
          "AssetFileDescriptor_AutoCloseInputStream__read2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int read(byte[] buffer, int offset, int count)
  int read2(jni.JniObject buffer, int offset, int count) =>
      _read2(reference, buffer.reference, offset, count).integer;

  static final _read1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "AssetFileDescriptor_AutoCloseInputStream__read1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int read(byte[] buffer)
  int read1(jni.JniObject buffer) =>
      _read1(reference, buffer.reference).integer;

  static final _skip = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("AssetFileDescriptor_AutoCloseInputStream__skip")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public long skip(long count)
  int skip(int count) => _skip(reference, count).long;

  static final _mark = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("AssetFileDescriptor_AutoCloseInputStream__mark")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void mark(int readlimit)
  void mark(int readlimit) => _mark(reference, readlimit).check();

  static final _markSupported = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetFileDescriptor_AutoCloseInputStream__markSupported")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean markSupported()
  bool markSupported() => _markSupported(reference).boolean;

  static final _reset = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetFileDescriptor_AutoCloseInputStream__reset")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: synchronized public void reset()
  void reset() => _reset(reference).check();
}

/// from: android.content.res.AssetManager
///
/// Provides access to an application's raw asset files; see Resources
/// for the way most applications will want to retrieve their resource data.
/// This class presents a lower-level API that allows you to open and read raw
/// files that have been bundled with the application as a simple stream of
/// bytes.
class AssetManager extends jni.JniObject {
  AssetManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int ACCESS_BUFFER
  ///
  /// Mode for \#open(String, int): Attempt to load contents into
  /// memory, for fast small reads.
  static const ACCESS_BUFFER = 3;

  /// from: static public final int ACCESS_RANDOM
  ///
  /// Mode for \#open(String, int): Read chunks, and seek forward and
  /// backward.
  static const ACCESS_RANDOM = 1;

  /// from: static public final int ACCESS_STREAMING
  ///
  /// Mode for \#open(String, int): Read sequentially, with an
  /// occasional forward seek.
  static const ACCESS_STREAMING = 2;

  /// from: static public final int ACCESS_UNKNOWN
  ///
  /// Mode for \#open(String, int): no specific information about how
  /// data will be accessed.
  static const ACCESS_UNKNOWN = 0;

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "AssetManager__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  ///
  /// Create a new AssetManager containing only the basic system assets.
  /// Applications will not generally use this method, instead retrieving the
  /// appropriate asset manager with Resources\#getAssets.    Not for
  /// use by applications.
  ///@hide
  AssetManager() : super.fromRef(_ctor().object);

  static final _close = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AssetManager__close")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void close()
  ///
  /// Close this asset manager.
  void close() => _close(reference).check();

  static final _open = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AssetManager__open")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.InputStream open(java.lang.String fileName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open an asset using ACCESS_STREAMING mode.  This provides access to
  /// files that have been bundled with an application as assets -- that is,
  /// files placed in to the "assets" directory.
  ///@param fileName The name of the asset to open.  This name can be hierarchical.
  ///
  /// This value must never be {@code null}.
  ///@see \#open(String, int)
  ///@see \#list
  ///@return This value will never be {@code null}.
  jni.JniObject open(jni.JniString fileName) =>
      jni.JniObject.fromRef(_open(reference, fileName.reference).object);

  static final _open1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("AssetManager__open1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.io.InputStream open(java.lang.String fileName, int accessMode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open an asset using an explicit access mode, returning an InputStream to
  /// read its contents.  This provides access to files that have been bundled
  /// with an application as assets -- that is, files placed in to the
  /// "assets" directory.
  ///@param fileName The name of the asset to open.  This name can be hierarchical.
  /// This value must never be {@code null}.
  ///@param accessMode Desired access mode for retrieving the data.
  ///@see \#ACCESS_UNKNOWN
  ///@see \#ACCESS_STREAMING
  ///@see \#ACCESS_RANDOM
  ///@see \#ACCESS_BUFFER
  ///@see \#open(String)
  ///@see \#list
  ///@return This value will never be {@code null}.
  jni.JniObject open1(jni.JniString fileName, int accessMode) =>
      jni.JniObject.fromRef(
          _open1(reference, fileName.reference, accessMode).object);

  static final _openFd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AssetManager__openFd")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.AssetFileDescriptor openFd(java.lang.String fileName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open an uncompressed asset by mmapping it and returning an AssetFileDescriptor.
  /// This provides access to files that have been bundled with an application as assets -- that
  /// is, files placed in to the "assets" directory.
  ///
  /// The asset must be uncompressed, or an exception will be thrown.
  ///@param fileName The name of the asset to open.  This name can be hierarchical.
  /// This value must never be {@code null}.
  ///@return An open AssetFileDescriptor.
  ///
  /// This value will never be {@code null}.
  AssetFileDescriptor openFd(jni.JniString fileName) =>
      AssetFileDescriptor.fromRef(
          _openFd(reference, fileName.reference).object);

  static final _list = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AssetManager__list")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] list(java.lang.String path)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a String array of all the assets at the given path.
  ///@param path A relative path within the assets, i.e., "docs/home.html".
  ///
  /// This value must never be {@code null}.
  ///@return String[] Array of strings, one for each asset.  These file
  ///         names are relative to 'path'.  You can open the file by
  ///         concatenating 'path' and a name in the returned string (via
  ///         File) and passing that to open().
  ///
  /// This value may be {@code null}.
  ///@see \#open
  jni.JniObject list(jni.JniString path) =>
      jni.JniObject.fromRef(_list(reference, path.reference).object);

  static final _openNonAssetFd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AssetManager__openNonAssetFd")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.AssetFileDescriptor openNonAssetFd(java.lang.String fileName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a non-asset as an asset by mmapping it and returning an AssetFileDescriptor.
  /// This provides direct access to all of the files included in an application
  /// package (not only its assets).  Applications should not normally use this.
  ///
  /// The asset must not be compressed, or an exception will be thrown.
  ///@param fileName Name of the asset to retrieve.
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  AssetFileDescriptor openNonAssetFd(jni.JniString fileName) =>
      AssetFileDescriptor.fromRef(
          _openNonAssetFd(reference, fileName.reference).object);

  static final _openNonAssetFd1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("AssetManager__openNonAssetFd1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.AssetFileDescriptor openNonAssetFd(int cookie, java.lang.String fileName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a non-asset as an asset by mmapping it and returning an AssetFileDescriptor.
  /// This provides direct access to all of the files included in an application
  /// package (not only its assets).  Applications should not normally use this.
  ///
  /// The asset must not be compressed, or an exception will be thrown.
  ///@param cookie Identifier of the package to be opened.
  ///@param fileName Name of the asset to retrieve.
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  AssetFileDescriptor openNonAssetFd1(int cookie, jni.JniString fileName) =>
      AssetFileDescriptor.fromRef(
          _openNonAssetFd1(reference, cookie, fileName.reference).object);

  static final _openXmlResourceParser = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "AssetManager__openXmlResourceParser")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.XmlResourceParser openXmlResourceParser(java.lang.String fileName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a parser for a compiled XML file.
  ///@param fileName The name of the file to retrieve.
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  XmlResourceParser openXmlResourceParser(jni.JniString fileName) =>
      XmlResourceParser.fromRef(
          _openXmlResourceParser(reference, fileName.reference).object);

  static final _openXmlResourceParser1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "AssetManager__openXmlResourceParser1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.XmlResourceParser openXmlResourceParser(int cookie, java.lang.String fileName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a parser for a compiled XML file.
  ///@param cookie Identifier of the package to be opened.
  ///@param fileName The name of the file to retrieve.
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  XmlResourceParser openXmlResourceParser1(
          int cookie, jni.JniString fileName) =>
      XmlResourceParser.fromRef(
          _openXmlResourceParser1(reference, cookie, fileName.reference)
              .object);

  static final _finalize = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AssetManager__finalize")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void finalize()
  void finalize() => _finalize(reference).check();

  static final _getLocales = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AssetManager__getLocales")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getLocales()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the locales that this asset manager contains data for.
  ///
  /// On SDK 21 (Android 5.0: Lollipop) and above, Locale strings are valid
  /// <a href="https://tools.ietf.org/html/bcp47">BCP-47</a> language tags and can be
  /// parsed using java.util.Locale\#forLanguageTag(String).
  ///
  /// On SDK 20 (Android 4.4W: KitKat for watches) and below, locale strings
  /// are of the form {@code ll_CC} where {@code ll} is a two letter language code,
  /// and {@code CC} is a two letter country code.
  jni.JniObject getLocales() =>
      jni.JniObject.fromRef(_getLocales(reference).object);
}

/// from: android.content.res.AssetManager$AssetInputStream
class AssetManager_AssetInputStream extends jni.JniObject {
  AssetManager_AssetInputStream.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int64)>>(
              "AssetManager_AssetInputStream__ctor")
          .asFunction<jni.JniResult Function(int)>();

  /// from: void <init>(long assetNativePtr)
  AssetManager_AssetInputStream(int assetNativePtr)
      : super.fromRef(_ctor(assetNativePtr).object);

  static final _read = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetManager_AssetInputStream__read")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int read()
  int read() => _read(reference).integer;

  static final _read1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "AssetManager_AssetInputStream__read1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int read(byte[] b)
  ///
  /// @param b This value must never be {@code null}.
  int read1(jni.JniObject b) => _read1(reference, b.reference).integer;

  static final _read2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32)>>("AssetManager_AssetInputStream__read2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int read(byte[] b, int off, int len)
  ///
  /// @param b This value must never be {@code null}.
  int read2(jni.JniObject b, int off, int len) =>
      _read2(reference, b.reference, off, len).integer;

  static final _skip = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("AssetManager_AssetInputStream__skip")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public long skip(long n)
  int skip(int n) => _skip(reference, n).long;

  static final _available = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetManager_AssetInputStream__available")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int available()
  int available() => _available(reference).integer;

  static final _markSupported = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetManager_AssetInputStream__markSupported")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean markSupported()
  bool markSupported() => _markSupported(reference).boolean;

  static final _mark = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("AssetManager_AssetInputStream__mark")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void mark(int readlimit)
  void mark(int readlimit) => _mark(reference, readlimit).check();

  static final _reset = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetManager_AssetInputStream__reset")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void reset()
  void reset() => _reset(reference).check();

  static final _close = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetManager_AssetInputStream__close")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void close()
  void close() => _close(reference).check();

  static final _finalize = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AssetManager_AssetInputStream__finalize")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void finalize()
  void finalize() => _finalize(reference).check();
}

/// from: android.content.res.ColorStateList
///
/// Lets you map android.view.View state sets to colors.
///
/// android.content.res.ColorStateLists are created from XML resource files defined in the
/// "color" subdirectory directory of an application's resource directory. The XML file contains
/// a single "selector" element with a number of "item" elements inside. For example:
/// <pre>
/// &lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt;
///   &lt;item android:state_focused="true"
///           android:color="@color/sample_focused" /&gt;
///   &lt;item android:state_pressed="true"
///           android:state_enabled="false"
///           android:color="@color/sample_disabled_pressed" /&gt;
///   &lt;item android:state_enabled="false"
///           android:color="@color/sample_disabled_not_pressed" /&gt;
///   &lt;item android:color="@color/sample_default" /&gt;
/// &lt;/selector&gt;
/// </pre>
///
/// This defines a set of state spec / color pairs where each state spec specifies a set of
/// states that a view must either be in or not be in and the color specifies the color associated
/// with that spec.
///
/// <a name="StateSpec"></a>
/// <h3>State specs</h3>
///
/// Each item defines a set of state spec and color pairs, where the state spec is a series of
/// attributes set to either {@code true} or {@code false} to represent inclusion or exclusion. If
/// an attribute is not specified for an item, it may be any value.
///
/// For example, the following item will be matched whenever the focused state is set; any other
/// states may be set or unset:
/// <pre>
/// &lt;item android:state_focused="true"
///         android:color="@color/sample_focused" /&gt;
/// </pre>
///
/// Typically, a color state list will reference framework-defined state attributes such as
/// android.R.attr\#state_focused android:state_focused or
/// android.R.attr\#state_enabled android:state_enabled; however, app-defined attributes may
/// also be used.
///
/// <strong>Note:</strong> The list of state specs will be matched against in the order that they
/// appear in the XML file. For this reason, more-specific items should be placed earlier in the
/// file. An item with no state spec is considered to match any set of states and is generally
/// useful as a final item to be used as a default.
///
/// If an item with no state spec is placed before other items, those items
/// will be ignored.
///
/// <a name="ItemAttributes"></a>
/// <h3>Item attributes</h3>
///
/// Each item must define an android.R.attr\#color android:color attribute, which may be
/// an HTML-style hex color, a reference to a color resource, or -- in API 23 and above -- a theme
/// attribute that resolves to a color.
///
/// Starting with API 23, items may optionally define an android.R.attr\#alpha android:alpha
/// attribute to modify the base color's opacity. This attribute takes a either floating-point value
/// between 0 and 1 or a theme attribute that resolves as such. The item's overall color is
/// calculated by multiplying by the base color's alpha channel by the {@code alpha} value. For
/// example, the following item represents the theme's accent color at 50% opacity:
/// <pre>
/// &lt;item android:state_enabled="false"
///         android:color="?android:attr/colorAccent"
///         android:alpha="0.5" /&gt;
/// </pre>
///
/// <a name="DeveloperGuide"></a>
/// <h3>Developer guide</h3>
///
/// For more information, see the guide to
/// <a href="{@docRoot}guide/topics/resources/color-list-resource.html">Color State
/// List Resource</a>.
///@attr ref android.R.styleable\#ColorStateListItem_alpha
///@attr ref android.R.styleable\#ColorStateListItem_color
class ColorStateList extends jni.JniObject {
  ColorStateList.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_ColorStateList__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.res.ColorStateList> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ColorStateList__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int[][] states, int[] colors)
  ///
  /// Creates a ColorStateList that returns the specified mapping from
  /// states to colors.
  ColorStateList(jni.JniObject states, jni.JniObject colors)
      : super.fromRef(_ctor(states.reference, colors.reference).object);

  static final _valueOf =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "ColorStateList__valueOf")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public android.content.res.ColorStateList valueOf(int color)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return A ColorStateList containing a single color.
  ///
  /// This value will never be {@code null}.
  static ColorStateList valueOf(int color) =>
      ColorStateList.fromRef(_valueOf(color).object);

  static final _createFromXml = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ColorStateList__createFromXml")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.res.ColorStateList createFromXml(android.content.res.Resources r, org.xmlpull.v1.XmlPullParser parser)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a ColorStateList from an XML document.
  ///@param r Resources against which the ColorStateList should be inflated.
  ///@param parser Parser for the XML document defining the ColorStateList.
  ///@return A new color state list.
  ///
  /// This value will never be {@code null}.
  ///@deprecated Use \#createFromXml(Resources, XmlPullParser parser, Theme)
  static ColorStateList createFromXml(Resources r, jni.JniObject parser) =>
      ColorStateList.fromRef(
          _createFromXml(r.reference, parser.reference).object);

  static final _createFromXml1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ColorStateList__createFromXml1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.res.ColorStateList createFromXml(android.content.res.Resources r, org.xmlpull.v1.XmlPullParser parser, android.content.res.Resources.Theme theme)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a ColorStateList from an XML document using given a set of
  /// Resources and a Theme.
  ///@param r Resources against which the ColorStateList should be inflated.
  /// This value must never be {@code null}.
  ///@param parser Parser for the XML document defining the ColorStateList.
  /// This value must never be {@code null}.
  ///@param theme Optional theme to apply to the color state list, may be
  ///              {@code null}.
  /// This value may be {@code null}.
  ///@return A new color state list.
  static ColorStateList createFromXml1(
          Resources r, jni.JniObject parser, Resources_Theme theme) =>
      ColorStateList.fromRef(
          _createFromXml1(r.reference, parser.reference, theme.reference)
              .object);

  static final _withAlpha = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ColorStateList__withAlpha")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.res.ColorStateList withAlpha(int alpha)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new ColorStateList that has the same states and colors as this
  /// one but where each color has the specified alpha value (0-255).
  ///@param alpha The new alpha channel value (0-255).
  ///@return A new color state list.
  ///
  /// This value will never be {@code null}.
  ColorStateList withAlpha(int alpha) =>
      ColorStateList.fromRef(_withAlpha(reference, alpha).object);

  static final _getChangingConfigurations = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ColorStateList__getChangingConfigurations")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getChangingConfigurations()
  ///
  /// Returns a mask of the configuration parameters for which this color
  /// state list may change, requiring that it be re-created.
  ///@return a mask of the changing configuration parameters, as defined by
  ///         android.content.pm.ActivityInfo
  ///
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  ///@see android.content.pm.ActivityInfo
  int getChangingConfigurations() =>
      _getChangingConfigurations(reference).integer;

  static final _isStateful = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ColorStateList__isStateful")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isStateful()
  ///
  /// Indicates whether this color state list contains at least one state spec
  /// and the first spec is not empty (e.g.&nbsp;match-all).
  ///@return True if this color state list changes color based on state, false
  ///         otherwise.
  ///@see \#getColorForState(int[], int)
  bool isStateful() => _isStateful(reference).boolean;

  static final _isOpaque = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ColorStateList__isOpaque")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isOpaque()
  ///
  /// Indicates whether this color state list is opaque, which means that every
  /// color returned from \#getColorForState(int[], int) has an alpha
  /// value of 255.
  ///@return True if this color state list is opaque.
  bool isOpaque() => _isOpaque(reference).boolean;

  static final _getColorForState = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ColorStateList__getColorForState")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getColorForState(int[] stateSet, int defaultColor)
  ///
  /// Return the color associated with the given set of
  /// android.view.View states.
  ///@param stateSet an array of android.view.View states
  /// This value may be {@code null}.
  ///@param defaultColor the color to return if there's no matching state
  ///                     spec in this ColorStateList that matches the
  ///                     stateSet.
  ///@return the color associated with that set of states in this ColorStateList.
  int getColorForState(jni.JniObject stateSet, int defaultColor) =>
      _getColorForState(reference, stateSet.reference, defaultColor).integer;

  static final _getDefaultColor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ColorStateList__getDefaultColor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getDefaultColor()
  ///
  /// Return the default color in this ColorStateList.
  ///@return the default color in this ColorStateList.
  int getDefaultColor() => _getDefaultColor(reference).integer;

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ColorStateList__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ColorStateList__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ColorStateList__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();
}

/// from: android.content.res.Configuration
///
/// This class describes all device configuration information that can
/// impact the resources the application retrieves.  This includes both
/// user-specified configuration options (locale list and scaling) as well
/// as device configurations (such as input modes, screen size and screen orientation).
/// You can acquire this object from Resources, using Resources\#getConfiguration. Thus, from an activity, you can get it by chaining the request
/// with android.app.Activity\#getResources:
///
/// <pre>Configuration config = getResources().getConfiguration();</pre>
class Configuration extends jni.JniObject {
  Configuration.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int COLOR_MODE_HDR_MASK
  ///
  /// Constant for \#colorMode: bits that encode the dynamic range of the screen.
  static const COLOR_MODE_HDR_MASK = 12;

  /// from: static public final int COLOR_MODE_HDR_NO
  ///
  /// Constant for \#colorMode: a \#COLOR_MODE_HDR_MASK value
  /// indicating that the screen is not HDR (low/standard dynamic range).
  /// Corresponds to the <code>-lowdr</code> resource qualifier.
  ///
  static const COLOR_MODE_HDR_NO = 4;

  /// from: static public final int COLOR_MODE_HDR_SHIFT
  ///
  /// Constant for \#colorMode: bits shift to get the screen dynamic range.
  static const COLOR_MODE_HDR_SHIFT = 2;

  /// from: static public final int COLOR_MODE_HDR_UNDEFINED
  ///
  /// Constant for \#colorMode: a \#COLOR_MODE_HDR_MASK value
  /// indicating that it is unknown whether or not the screen is HDR.
  static const COLOR_MODE_HDR_UNDEFINED = 0;

  /// from: static public final int COLOR_MODE_HDR_YES
  ///
  /// Constant for \#colorMode: a \#COLOR_MODE_HDR_MASK value
  /// indicating that the screen is HDR (dynamic range).
  /// Corresponds to the <code>-highdr</code> resource qualifier.
  ///
  static const COLOR_MODE_HDR_YES = 8;

  /// from: static public final int COLOR_MODE_UNDEFINED
  ///
  /// Constant for \#colorMode: a value indicating that the color mode is undefined
  static const COLOR_MODE_UNDEFINED = 0;

  /// from: static public final int COLOR_MODE_WIDE_COLOR_GAMUT_MASK
  ///
  /// Constant for \#colorMode: bits that encode whether the screen is wide gamut.
  static const COLOR_MODE_WIDE_COLOR_GAMUT_MASK = 3;

  /// from: static public final int COLOR_MODE_WIDE_COLOR_GAMUT_NO
  ///
  /// Constant for \#colorMode: a \#COLOR_MODE_WIDE_COLOR_GAMUT_MASK value
  /// indicating that the screen is not wide gamut.
  /// Corresponds to the <code>-nowidecg</code> resource qualifier.
  ///
  static const COLOR_MODE_WIDE_COLOR_GAMUT_NO = 1;

  /// from: static public final int COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED
  ///
  /// Constant for \#colorMode: a \#COLOR_MODE_WIDE_COLOR_GAMUT_MASK value
  /// indicating that it is unknown whether or not the screen is wide gamut.
  static const COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED = 0;

  /// from: static public final int COLOR_MODE_WIDE_COLOR_GAMUT_YES
  ///
  /// Constant for \#colorMode: a \#COLOR_MODE_WIDE_COLOR_GAMUT_MASK value
  /// indicating that the screen is wide gamut.
  /// Corresponds to the <code>-widecg</code> resource qualifier.
  ///
  static const COLOR_MODE_WIDE_COLOR_GAMUT_YES = 2;

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Configuration__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.res.Configuration> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  /// from: static public final int DENSITY_DPI_UNDEFINED
  ///
  /// Default value for \#densityDpi indicating that no width
  /// has been specified.
  static const DENSITY_DPI_UNDEFINED = 0;

  /// from: static public final int HARDKEYBOARDHIDDEN_NO
  ///
  /// Constant for \#hardKeyboardHidden, value corresponding to the
  /// physical keyboard being exposed.
  static const HARDKEYBOARDHIDDEN_NO = 1;

  /// from: static public final int HARDKEYBOARDHIDDEN_UNDEFINED
  ///
  /// Constant for \#hardKeyboardHidden: a value indicating that no value has been set.
  static const HARDKEYBOARDHIDDEN_UNDEFINED = 0;

  /// from: static public final int HARDKEYBOARDHIDDEN_YES
  ///
  /// Constant for \#hardKeyboardHidden, value corresponding to the
  /// physical keyboard being hidden.
  static const HARDKEYBOARDHIDDEN_YES = 2;

  /// from: static public final int KEYBOARDHIDDEN_NO
  ///
  /// Constant for \#keyboardHidden, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#KeyboardAvailQualifier">keysexposed</a>
  /// resource qualifier.
  static const KEYBOARDHIDDEN_NO = 1;

  /// from: static public final int KEYBOARDHIDDEN_UNDEFINED
  ///
  /// Constant for \#keyboardHidden: a value indicating that no value has been set.
  static const KEYBOARDHIDDEN_UNDEFINED = 0;

  /// from: static public final int KEYBOARDHIDDEN_YES
  ///
  /// Constant for \#keyboardHidden, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#KeyboardAvailQualifier">keyshidden</a>
  /// resource qualifier.
  static const KEYBOARDHIDDEN_YES = 2;

  /// from: static public final int KEYBOARD_12KEY
  ///
  /// Constant for \#keyboard, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ImeQualifier">12key</a>
  /// resource qualifier.
  static const KEYBOARD_12KEY = 3;

  /// from: static public final int KEYBOARD_NOKEYS
  ///
  /// Constant for \#keyboard, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ImeQualifier">nokeys</a>
  /// resource qualifier.
  static const KEYBOARD_NOKEYS = 1;

  /// from: static public final int KEYBOARD_QWERTY
  ///
  /// Constant for \#keyboard, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ImeQualifier">qwerty</a>
  /// resource qualifier.
  static const KEYBOARD_QWERTY = 2;

  /// from: static public final int KEYBOARD_UNDEFINED
  ///
  /// Constant for \#keyboard: a value indicating that no value has been set.
  static const KEYBOARD_UNDEFINED = 0;

  /// from: static public final int MNC_ZERO
  ///
  /// Constant used to to represent MNC (Mobile Network Code) zero.
  /// 0 cannot be used, since it is used to represent an undefined MNC.
  static const MNC_ZERO = 65535;

  /// from: static public final int NAVIGATIONHIDDEN_NO
  ///
  /// Constant for \#navigationHidden, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NavAvailQualifier">navexposed</a>
  /// resource qualifier.
  static const NAVIGATIONHIDDEN_NO = 1;

  /// from: static public final int NAVIGATIONHIDDEN_UNDEFINED
  ///
  /// Constant for \#navigationHidden: a value indicating that no value has been set.
  static const NAVIGATIONHIDDEN_UNDEFINED = 0;

  /// from: static public final int NAVIGATIONHIDDEN_YES
  ///
  /// Constant for \#navigationHidden, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NavAvailQualifier">navhidden</a>
  /// resource qualifier.
  static const NAVIGATIONHIDDEN_YES = 2;

  /// from: static public final int NAVIGATION_DPAD
  ///
  /// Constant for \#navigation, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NavigationQualifier">dpad</a>
  /// resource qualifier.
  static const NAVIGATION_DPAD = 2;

  /// from: static public final int NAVIGATION_NONAV
  ///
  /// Constant for \#navigation, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NavigationQualifier">nonav</a>
  /// resource qualifier.
  static const NAVIGATION_NONAV = 1;

  /// from: static public final int NAVIGATION_TRACKBALL
  ///
  /// Constant for \#navigation, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NavigationQualifier">trackball</a>
  /// resource qualifier.
  static const NAVIGATION_TRACKBALL = 3;

  /// from: static public final int NAVIGATION_UNDEFINED
  ///
  /// Constant for \#navigation: a value indicating that no value has been set.
  static const NAVIGATION_UNDEFINED = 0;

  /// from: static public final int NAVIGATION_WHEEL
  ///
  /// Constant for \#navigation, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NavigationQualifier">wheel</a>
  /// resource qualifier.
  static const NAVIGATION_WHEEL = 4;

  /// from: static public final int ORIENTATION_LANDSCAPE
  ///
  /// Constant for \#orientation, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#OrientationQualifier">land</a>
  /// resource qualifier.
  static const ORIENTATION_LANDSCAPE = 2;

  /// from: static public final int ORIENTATION_PORTRAIT
  ///
  /// Constant for \#orientation, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#OrientationQualifier">port</a>
  /// resource qualifier.
  static const ORIENTATION_PORTRAIT = 1;

  /// from: static public final int ORIENTATION_SQUARE
  ///
  /// @deprecated Not currently supported or used.
  static const ORIENTATION_SQUARE = 3;

  /// from: static public final int ORIENTATION_UNDEFINED
  ///
  /// Constant for \#orientation: a value indicating that no value has been set.
  static const ORIENTATION_UNDEFINED = 0;

  /// from: static public final int SCREENLAYOUT_LAYOUTDIR_LTR
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_LAYOUTDIR_MASK
  /// value indicating that a layout dir has been set to LTR.
  static const SCREENLAYOUT_LAYOUTDIR_LTR = 64;

  /// from: static public final int SCREENLAYOUT_LAYOUTDIR_MASK
  ///
  /// Constant for \#screenLayout: bits that encode the layout direction.
  static const SCREENLAYOUT_LAYOUTDIR_MASK = 192;

  /// from: static public final int SCREENLAYOUT_LAYOUTDIR_RTL
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_LAYOUTDIR_MASK
  /// value indicating that a layout dir has been set to RTL.
  static const SCREENLAYOUT_LAYOUTDIR_RTL = 128;

  /// from: static public final int SCREENLAYOUT_LAYOUTDIR_SHIFT
  ///
  /// Constant for \#screenLayout: bits shift to get the layout direction.
  static const SCREENLAYOUT_LAYOUTDIR_SHIFT = 6;

  /// from: static public final int SCREENLAYOUT_LAYOUTDIR_UNDEFINED
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_LAYOUTDIR_MASK
  /// value indicating that no layout dir has been set.
  static const SCREENLAYOUT_LAYOUTDIR_UNDEFINED = 0;

  /// from: static public final int SCREENLAYOUT_LONG_MASK
  ///
  /// Constant for \#screenLayout: bits that encode the aspect ratio.
  static const SCREENLAYOUT_LONG_MASK = 48;

  /// from: static public final int SCREENLAYOUT_LONG_NO
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_LONG_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenAspectQualifier">notlong</a>
  /// resource qualifier.
  static const SCREENLAYOUT_LONG_NO = 16;

  /// from: static public final int SCREENLAYOUT_LONG_UNDEFINED
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_LONG_MASK
  /// value indicating that no size has been set.
  static const SCREENLAYOUT_LONG_UNDEFINED = 0;

  /// from: static public final int SCREENLAYOUT_LONG_YES
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_LONG_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenAspectQualifier">long</a>
  /// resource qualifier.
  static const SCREENLAYOUT_LONG_YES = 32;

  /// from: static public final int SCREENLAYOUT_ROUND_MASK
  ///
  /// Constant for \#screenLayout: bits that encode roundness of the screen.
  static const SCREENLAYOUT_ROUND_MASK = 768;

  /// from: static public final int SCREENLAYOUT_ROUND_NO
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_ROUND_MASK value indicating
  /// that the screen does not have a rounded shape.
  static const SCREENLAYOUT_ROUND_NO = 256;

  /// from: static public final int SCREENLAYOUT_ROUND_UNDEFINED
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_ROUND_MASK value indicating
  /// that it is unknown whether or not the screen has a round shape.
  static const SCREENLAYOUT_ROUND_UNDEFINED = 0;

  /// from: static public final int SCREENLAYOUT_ROUND_YES
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_ROUND_MASK value indicating
  /// that the screen has a rounded shape. Corners may not be visible to the user;
  /// developers should pay special attention to the android.view.WindowInsets delivered
  /// to views for more information about ensuring content is not obscured.
  ///
  /// Corresponds to the <code>-round</code> resource qualifier.
  ///
  static const SCREENLAYOUT_ROUND_YES = 512;

  /// from: static public final int SCREENLAYOUT_SIZE_LARGE
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_SIZE_MASK
  /// value indicating the screen is at least approximately 480x640 dp units,
  /// corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenSizeQualifier">large</a>
  /// resource qualifier.
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  static const SCREENLAYOUT_SIZE_LARGE = 3;

  /// from: static public final int SCREENLAYOUT_SIZE_MASK
  ///
  /// Constant for \#screenLayout: bits that encode the size.
  static const SCREENLAYOUT_SIZE_MASK = 15;

  /// from: static public final int SCREENLAYOUT_SIZE_NORMAL
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_SIZE_MASK
  /// value indicating the screen is at least approximately 320x470 dp units,
  /// corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenSizeQualifier">normal</a>
  /// resource qualifier.
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  static const SCREENLAYOUT_SIZE_NORMAL = 2;

  /// from: static public final int SCREENLAYOUT_SIZE_SMALL
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_SIZE_MASK
  /// value indicating the screen is at least approximately 320x426 dp units,
  /// corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenSizeQualifier">small</a>
  /// resource qualifier.
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  static const SCREENLAYOUT_SIZE_SMALL = 1;

  /// from: static public final int SCREENLAYOUT_SIZE_UNDEFINED
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_SIZE_MASK
  /// value indicating that no size has been set.
  static const SCREENLAYOUT_SIZE_UNDEFINED = 0;

  /// from: static public final int SCREENLAYOUT_SIZE_XLARGE
  ///
  /// Constant for \#screenLayout: a \#SCREENLAYOUT_SIZE_MASK
  /// value indicating the screen is at least approximately 720x960 dp units,
  /// corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenSizeQualifier">xlarge</a>
  /// resource qualifier.
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  static const SCREENLAYOUT_SIZE_XLARGE = 4;

  /// from: static public final int SCREENLAYOUT_UNDEFINED
  ///
  /// Constant for \#screenLayout: a value indicating that screenLayout is undefined
  static const SCREENLAYOUT_UNDEFINED = 0;

  /// from: static public final int SCREEN_HEIGHT_DP_UNDEFINED
  ///
  /// Default value for \#screenHeightDp indicating that no width
  /// has been specified.
  static const SCREEN_HEIGHT_DP_UNDEFINED = 0;

  /// from: static public final int SCREEN_WIDTH_DP_UNDEFINED
  ///
  /// Default value for \#screenWidthDp indicating that no width
  /// has been specified.
  static const SCREEN_WIDTH_DP_UNDEFINED = 0;

  /// from: static public final int SMALLEST_SCREEN_WIDTH_DP_UNDEFINED
  ///
  /// Default value for \#smallestScreenWidthDp indicating that no width
  /// has been specified.
  static const SMALLEST_SCREEN_WIDTH_DP_UNDEFINED = 0;

  /// from: static public final int TOUCHSCREEN_FINGER
  ///
  /// Constant for \#touchscreen, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#TouchscreenQualifier">finger</a>
  /// resource qualifier.
  static const TOUCHSCREEN_FINGER = 3;

  /// from: static public final int TOUCHSCREEN_NOTOUCH
  ///
  /// Constant for \#touchscreen, value corresponding to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#TouchscreenQualifier">notouch</a>
  /// resource qualifier.
  static const TOUCHSCREEN_NOTOUCH = 1;

  /// from: static public final int TOUCHSCREEN_STYLUS
  ///
  /// @deprecated Not currently supported or used.
  static const TOUCHSCREEN_STYLUS = 2;

  /// from: static public final int TOUCHSCREEN_UNDEFINED
  ///
  /// Constant for \#touchscreen: a value indicating that no value has been set.
  static const TOUCHSCREEN_UNDEFINED = 0;

  /// from: static public final int UI_MODE_NIGHT_MASK
  ///
  /// Constant for \#uiMode: bits that encode the night mode.
  static const UI_MODE_NIGHT_MASK = 48;

  /// from: static public final int UI_MODE_NIGHT_NO
  ///
  /// Constant for \#uiMode: a \#UI_MODE_NIGHT_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NightQualifier">notnight</a>
  /// resource qualifier.
  static const UI_MODE_NIGHT_NO = 16;

  /// from: static public final int UI_MODE_NIGHT_UNDEFINED
  ///
  /// Constant for \#uiMode: a \#UI_MODE_NIGHT_MASK
  /// value indicating that no mode type has been set.
  static const UI_MODE_NIGHT_UNDEFINED = 0;

  /// from: static public final int UI_MODE_NIGHT_YES
  ///
  /// Constant for \#uiMode: a \#UI_MODE_NIGHT_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#NightQualifier">night</a>
  /// resource qualifier.
  static const UI_MODE_NIGHT_YES = 32;

  /// from: static public final int UI_MODE_TYPE_APPLIANCE
  ///
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">appliance</a>
  /// resource qualifier.
  static const UI_MODE_TYPE_APPLIANCE = 5;

  /// from: static public final int UI_MODE_TYPE_CAR
  ///
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">car</a>
  /// resource qualifier.
  static const UI_MODE_TYPE_CAR = 3;

  /// from: static public final int UI_MODE_TYPE_DESK
  ///
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">desk</a>
  /// resource qualifier.
  static const UI_MODE_TYPE_DESK = 2;

  /// from: static public final int UI_MODE_TYPE_MASK
  ///
  /// Constant for \#uiMode: bits that encode the mode type.
  static const UI_MODE_TYPE_MASK = 15;

  /// from: static public final int UI_MODE_TYPE_NORMAL
  ///
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">no
  /// UI mode</a> resource qualifier specified.
  static const UI_MODE_TYPE_NORMAL = 1;

  /// from: static public final int UI_MODE_TYPE_TELEVISION
  ///
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">television</a>
  /// resource qualifier.
  static const UI_MODE_TYPE_TELEVISION = 4;

  /// from: static public final int UI_MODE_TYPE_UNDEFINED
  ///
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value indicating that no mode type has been set.
  static const UI_MODE_TYPE_UNDEFINED = 0;

  /// from: static public final int UI_MODE_TYPE_VR_HEADSET
  ///
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">vrheadset</a>
  /// resource qualifier.
  static const UI_MODE_TYPE_VR_HEADSET = 7;

  /// from: static public final int UI_MODE_TYPE_WATCH
  ///
  /// Constant for \#uiMode: a \#UI_MODE_TYPE_MASK
  /// value that corresponds to the
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#UiModeQualifier">watch</a>
  /// resource qualifier.
  static const UI_MODE_TYPE_WATCH = 6;

  static final _get_colorMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Configuration__colorMode")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int colorMode
  ///
  /// Bit mask of color capabilities of the screen. Currently there are two fields:
  /// The \#COLOR_MODE_WIDE_COLOR_GAMUT_MASK bits define the color gamut of
  /// the screen. They may be one of
  /// \#COLOR_MODE_WIDE_COLOR_GAMUT_NO or \#COLOR_MODE_WIDE_COLOR_GAMUT_YES.
  ///
  ///
  /// The \#COLOR_MODE_HDR_MASK defines the dynamic range of the screen. They may be
  /// one of \#COLOR_MODE_HDR_NO or \#COLOR_MODE_HDR_YES.
  ///
  ///
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  ///
  int get colorMode => _get_colorMode(reference).integer;
  static final _set_colorMode = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Configuration__colorMode")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int colorMode
  ///
  /// Bit mask of color capabilities of the screen. Currently there are two fields:
  /// The \#COLOR_MODE_WIDE_COLOR_GAMUT_MASK bits define the color gamut of
  /// the screen. They may be one of
  /// \#COLOR_MODE_WIDE_COLOR_GAMUT_NO or \#COLOR_MODE_WIDE_COLOR_GAMUT_YES.
  ///
  ///
  /// The \#COLOR_MODE_HDR_MASK defines the dynamic range of the screen. They may be
  /// one of \#COLOR_MODE_HDR_NO or \#COLOR_MODE_HDR_YES.
  ///
  ///
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  ///
  set colorMode(int value) => _set_colorMode(reference, value);

  static final _get_densityDpi = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Configuration__densityDpi")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int densityDpi
  ///
  /// The target screen density being rendered to,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#DensityQualifier">density</a>
  /// resource qualifier.  Set to
  /// \#DENSITY_DPI_UNDEFINED if no density is specified.
  int get densityDpi => _get_densityDpi(reference).integer;
  static final _set_densityDpi = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Configuration__densityDpi")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int densityDpi
  ///
  /// The target screen density being rendered to,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#DensityQualifier">density</a>
  /// resource qualifier.  Set to
  /// \#DENSITY_DPI_UNDEFINED if no density is specified.
  set densityDpi(int value) => _set_densityDpi(reference, value);

  static final _get_fontScale = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Configuration__fontScale")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public float fontScale
  ///
  /// Current user preference for the scaling factor for fonts, relative
  /// to the base density scaling.
  double get fontScale => _get_fontScale(reference).float;
  static final _set_fontScale = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Float)>>("set_Configuration__fontScale")
      .asFunction<jni.JThrowable Function(jni.JObject, double)>();

  /// from: public float fontScale
  ///
  /// Current user preference for the scaling factor for fonts, relative
  /// to the base density scaling.
  set fontScale(double value) => _set_fontScale(reference, value);

  static final _get_hardKeyboardHidden = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Configuration__hardKeyboardHidden")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int hardKeyboardHidden
  ///
  /// A flag indicating whether the hard keyboard has been hidden.  This will
  /// be set on a device with a mechanism to hide the keyboard from the
  /// user, when that mechanism is closed.  One of:
  /// \#HARDKEYBOARDHIDDEN_NO, \#HARDKEYBOARDHIDDEN_YES.
  int get hardKeyboardHidden => _get_hardKeyboardHidden(reference).integer;
  static final _set_hardKeyboardHidden = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int32)>>("set_Configuration__hardKeyboardHidden")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int hardKeyboardHidden
  ///
  /// A flag indicating whether the hard keyboard has been hidden.  This will
  /// be set on a device with a mechanism to hide the keyboard from the
  /// user, when that mechanism is closed.  One of:
  /// \#HARDKEYBOARDHIDDEN_NO, \#HARDKEYBOARDHIDDEN_YES.
  set hardKeyboardHidden(int value) =>
      _set_hardKeyboardHidden(reference, value);

  static final _get_keyboard = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Configuration__keyboard")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int keyboard
  ///
  /// The kind of keyboard attached to the device.
  /// One of: \#KEYBOARD_NOKEYS, \#KEYBOARD_QWERTY,
  /// \#KEYBOARD_12KEY.
  int get keyboard => _get_keyboard(reference).integer;
  static final _set_keyboard = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Configuration__keyboard")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int keyboard
  ///
  /// The kind of keyboard attached to the device.
  /// One of: \#KEYBOARD_NOKEYS, \#KEYBOARD_QWERTY,
  /// \#KEYBOARD_12KEY.
  set keyboard(int value) => _set_keyboard(reference, value);

  static final _get_keyboardHidden = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Configuration__keyboardHidden")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int keyboardHidden
  ///
  /// A flag indicating whether any keyboard is available.  Unlike
  /// \#hardKeyboardHidden, this also takes into account a soft
  /// keyboard, so if the hard keyboard is hidden but there is soft
  /// keyboard available, it will be set to NO.  Value is one of:
  /// \#KEYBOARDHIDDEN_NO, \#KEYBOARDHIDDEN_YES.
  int get keyboardHidden => _get_keyboardHidden(reference).integer;
  static final _set_keyboardHidden = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Configuration__keyboardHidden")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int keyboardHidden
  ///
  /// A flag indicating whether any keyboard is available.  Unlike
  /// \#hardKeyboardHidden, this also takes into account a soft
  /// keyboard, so if the hard keyboard is hidden but there is soft
  /// keyboard available, it will be set to NO.  Value is one of:
  /// \#KEYBOARDHIDDEN_NO, \#KEYBOARDHIDDEN_YES.
  set keyboardHidden(int value) => _set_keyboardHidden(reference, value);

  static final _get_locale = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Configuration__locale")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.util.Locale locale
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Current user preference for the locale, corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#LocaleQualifier">locale</a>
  /// resource qualifier.
  ///@deprecated Do not set or read this directly. Use \#getLocales() and
  /// \#setLocales(LocaleList). If only the primary locale is needed,
  /// <code>getLocales().get(0)</code> is now the preferred accessor.
  jni.JniObject get locale =>
      jni.JniObject.fromRef(_get_locale(reference).object);
  static final _set_locale = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_Configuration__locale")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Locale locale
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Current user preference for the locale, corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#LocaleQualifier">locale</a>
  /// resource qualifier.
  ///@deprecated Do not set or read this directly. Use \#getLocales() and
  /// \#setLocales(LocaleList). If only the primary locale is needed,
  /// <code>getLocales().get(0)</code> is now the preferred accessor.
  set locale(jni.JniObject value) => _set_locale(reference, value.reference);

  static final _get_mcc = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Configuration__mcc")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int mcc
  ///
  /// IMSI MCC (Mobile Country Code), corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#MccQualifier">mcc</a>
  /// resource qualifier.  0 if undefined.
  int get mcc => _get_mcc(reference).integer;
  static final _set_mcc = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Configuration__mcc")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int mcc
  ///
  /// IMSI MCC (Mobile Country Code), corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#MccQualifier">mcc</a>
  /// resource qualifier.  0 if undefined.
  set mcc(int value) => _set_mcc(reference, value);

  static final _get_mnc = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Configuration__mnc")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int mnc
  ///
  /// IMSI MNC (Mobile Network Code), corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#MccQualifier">mnc</a>
  /// resource qualifier.  0 if undefined. Note that the actual MNC may be 0; in order to check
  /// for this use the \#MNC_ZERO symbol.
  int get mnc => _get_mnc(reference).integer;
  static final _set_mnc = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Configuration__mnc")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int mnc
  ///
  /// IMSI MNC (Mobile Network Code), corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#MccQualifier">mnc</a>
  /// resource qualifier.  0 if undefined. Note that the actual MNC may be 0; in order to check
  /// for this use the \#MNC_ZERO symbol.
  set mnc(int value) => _set_mnc(reference, value);

  static final _get_navigation = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Configuration__navigation")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int navigation
  ///
  /// The kind of navigation method available on the device.
  /// One of: \#NAVIGATION_NONAV, \#NAVIGATION_DPAD,
  /// \#NAVIGATION_TRACKBALL, \#NAVIGATION_WHEEL.
  int get navigation => _get_navigation(reference).integer;
  static final _set_navigation = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Configuration__navigation")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int navigation
  ///
  /// The kind of navigation method available on the device.
  /// One of: \#NAVIGATION_NONAV, \#NAVIGATION_DPAD,
  /// \#NAVIGATION_TRACKBALL, \#NAVIGATION_WHEEL.
  set navigation(int value) => _set_navigation(reference, value);

  static final _get_navigationHidden = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Configuration__navigationHidden")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int navigationHidden
  ///
  /// A flag indicating whether any 5-way or DPAD navigation available.
  /// This will be set on a device with a mechanism to hide the navigation
  /// controls from the user, when that mechanism is closed.  One of:
  /// \#NAVIGATIONHIDDEN_NO, \#NAVIGATIONHIDDEN_YES.
  int get navigationHidden => _get_navigationHidden(reference).integer;
  static final _set_navigationHidden = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int32)>>("set_Configuration__navigationHidden")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int navigationHidden
  ///
  /// A flag indicating whether any 5-way or DPAD navigation available.
  /// This will be set on a device with a mechanism to hide the navigation
  /// controls from the user, when that mechanism is closed.  One of:
  /// \#NAVIGATIONHIDDEN_NO, \#NAVIGATIONHIDDEN_YES.
  set navigationHidden(int value) => _set_navigationHidden(reference, value);

  static final _get_orientation = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Configuration__orientation")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int orientation
  ///
  /// Overall orientation of the screen.  May be one of
  /// \#ORIENTATION_LANDSCAPE, \#ORIENTATION_PORTRAIT.
  int get orientation => _get_orientation(reference).integer;
  static final _set_orientation = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Configuration__orientation")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int orientation
  ///
  /// Overall orientation of the screen.  May be one of
  /// \#ORIENTATION_LANDSCAPE, \#ORIENTATION_PORTRAIT.
  set orientation(int value) => _set_orientation(reference, value);

  static final _get_screenHeightDp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Configuration__screenHeightDp")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int screenHeightDp
  ///
  /// The current height of the available screen space, in dp units,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenHeightQualifier">screen
  /// height</a> resource qualifier.  Set to
  /// \#SCREEN_HEIGHT_DP_UNDEFINED if no height is specified.
  int get screenHeightDp => _get_screenHeightDp(reference).integer;
  static final _set_screenHeightDp = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Configuration__screenHeightDp")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int screenHeightDp
  ///
  /// The current height of the available screen space, in dp units,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenHeightQualifier">screen
  /// height</a> resource qualifier.  Set to
  /// \#SCREEN_HEIGHT_DP_UNDEFINED if no height is specified.
  set screenHeightDp(int value) => _set_screenHeightDp(reference, value);

  static final _get_screenLayout = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Configuration__screenLayout")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int screenLayout
  ///
  /// Bit mask of overall layout of the screen.  Currently there are four
  /// fields:
  /// The \#SCREENLAYOUT_SIZE_MASK bits define the overall size
  /// of the screen.  They may be one of
  /// \#SCREENLAYOUT_SIZE_SMALL, \#SCREENLAYOUT_SIZE_NORMAL,
  /// \#SCREENLAYOUT_SIZE_LARGE, or \#SCREENLAYOUT_SIZE_XLARGE.
  ///
  ///
  /// The \#SCREENLAYOUT_LONG_MASK defines whether the screen
  /// is wider/taller than normal.  They may be one of
  /// \#SCREENLAYOUT_LONG_NO or \#SCREENLAYOUT_LONG_YES.
  ///
  ///
  /// The \#SCREENLAYOUT_LAYOUTDIR_MASK defines whether the screen layout
  /// is either LTR or RTL.  They may be one of
  /// \#SCREENLAYOUT_LAYOUTDIR_LTR or \#SCREENLAYOUT_LAYOUTDIR_RTL.
  ///
  ///
  /// The \#SCREENLAYOUT_ROUND_MASK defines whether the screen has a rounded
  /// shape. They may be one of \#SCREENLAYOUT_ROUND_NO or \#SCREENLAYOUT_ROUND_YES.
  ///
  ///
  ///
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  ///
  int get screenLayout => _get_screenLayout(reference).integer;
  static final _set_screenLayout = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Configuration__screenLayout")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int screenLayout
  ///
  /// Bit mask of overall layout of the screen.  Currently there are four
  /// fields:
  /// The \#SCREENLAYOUT_SIZE_MASK bits define the overall size
  /// of the screen.  They may be one of
  /// \#SCREENLAYOUT_SIZE_SMALL, \#SCREENLAYOUT_SIZE_NORMAL,
  /// \#SCREENLAYOUT_SIZE_LARGE, or \#SCREENLAYOUT_SIZE_XLARGE.
  ///
  ///
  /// The \#SCREENLAYOUT_LONG_MASK defines whether the screen
  /// is wider/taller than normal.  They may be one of
  /// \#SCREENLAYOUT_LONG_NO or \#SCREENLAYOUT_LONG_YES.
  ///
  ///
  /// The \#SCREENLAYOUT_LAYOUTDIR_MASK defines whether the screen layout
  /// is either LTR or RTL.  They may be one of
  /// \#SCREENLAYOUT_LAYOUTDIR_LTR or \#SCREENLAYOUT_LAYOUTDIR_RTL.
  ///
  ///
  /// The \#SCREENLAYOUT_ROUND_MASK defines whether the screen has a rounded
  /// shape. They may be one of \#SCREENLAYOUT_ROUND_NO or \#SCREENLAYOUT_ROUND_YES.
  ///
  ///
  ///
  /// See <a href="{@docRoot}guide/practices/screens_support.html">Supporting
  /// Multiple Screens</a> for more information.
  ///
  set screenLayout(int value) => _set_screenLayout(reference, value);

  static final _get_screenWidthDp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Configuration__screenWidthDp")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int screenWidthDp
  ///
  /// The current width of the available screen space, in dp units,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenWidthQualifier">screen
  /// width</a> resource qualifier.  Set to
  /// \#SCREEN_WIDTH_DP_UNDEFINED if no width is specified.
  int get screenWidthDp => _get_screenWidthDp(reference).integer;
  static final _set_screenWidthDp = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Configuration__screenWidthDp")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int screenWidthDp
  ///
  /// The current width of the available screen space, in dp units,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#ScreenWidthQualifier">screen
  /// width</a> resource qualifier.  Set to
  /// \#SCREEN_WIDTH_DP_UNDEFINED if no width is specified.
  set screenWidthDp(int value) => _set_screenWidthDp(reference, value);

  static final _get_smallestScreenWidthDp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Configuration__smallestScreenWidthDp")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int smallestScreenWidthDp
  ///
  /// The smallest screen size an application will see in normal operation,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#SmallestScreenWidthQualifier">smallest
  /// screen width</a> resource qualifier.
  /// This is the smallest value of both screenWidthDp and screenHeightDp
  /// in both portrait and landscape.  Set to
  /// \#SMALLEST_SCREEN_WIDTH_DP_UNDEFINED if no width is specified.
  int get smallestScreenWidthDp =>
      _get_smallestScreenWidthDp(reference).integer;
  static final _set_smallestScreenWidthDp = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int32)>>("set_Configuration__smallestScreenWidthDp")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int smallestScreenWidthDp
  ///
  /// The smallest screen size an application will see in normal operation,
  /// corresponding to
  /// <a href="{@docRoot}guide/topics/resources/providing-resources.html\#SmallestScreenWidthQualifier">smallest
  /// screen width</a> resource qualifier.
  /// This is the smallest value of both screenWidthDp and screenHeightDp
  /// in both portrait and landscape.  Set to
  /// \#SMALLEST_SCREEN_WIDTH_DP_UNDEFINED if no width is specified.
  set smallestScreenWidthDp(int value) =>
      _set_smallestScreenWidthDp(reference, value);

  static final _get_touchscreen = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Configuration__touchscreen")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int touchscreen
  ///
  /// The kind of touch screen attached to the device.
  /// One of: \#TOUCHSCREEN_NOTOUCH, \#TOUCHSCREEN_FINGER.
  int get touchscreen => _get_touchscreen(reference).integer;
  static final _set_touchscreen = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Configuration__touchscreen")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int touchscreen
  ///
  /// The kind of touch screen attached to the device.
  /// One of: \#TOUCHSCREEN_NOTOUCH, \#TOUCHSCREEN_FINGER.
  set touchscreen(int value) => _set_touchscreen(reference, value);

  static final _get_uiMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Configuration__uiMode")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int uiMode
  ///
  /// Bit mask of the ui mode.  Currently there are two fields:
  /// The \#UI_MODE_TYPE_MASK bits define the overall ui mode of the
  /// device. They may be one of \#UI_MODE_TYPE_UNDEFINED,
  /// \#UI_MODE_TYPE_NORMAL, \#UI_MODE_TYPE_DESK,
  /// \#UI_MODE_TYPE_CAR, \#UI_MODE_TYPE_TELEVISION,
  /// \#UI_MODE_TYPE_APPLIANCE, \#UI_MODE_TYPE_WATCH,
  /// or \#UI_MODE_TYPE_VR_HEADSET.
  ///
  /// The \#UI_MODE_NIGHT_MASK defines whether the screen
  /// is in a special mode. They may be one of \#UI_MODE_NIGHT_UNDEFINED,
  /// \#UI_MODE_NIGHT_NO or \#UI_MODE_NIGHT_YES.
  int get uiMode => _get_uiMode(reference).integer;
  static final _set_uiMode = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Configuration__uiMode")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int uiMode
  ///
  /// Bit mask of the ui mode.  Currently there are two fields:
  /// The \#UI_MODE_TYPE_MASK bits define the overall ui mode of the
  /// device. They may be one of \#UI_MODE_TYPE_UNDEFINED,
  /// \#UI_MODE_TYPE_NORMAL, \#UI_MODE_TYPE_DESK,
  /// \#UI_MODE_TYPE_CAR, \#UI_MODE_TYPE_TELEVISION,
  /// \#UI_MODE_TYPE_APPLIANCE, \#UI_MODE_TYPE_WATCH,
  /// or \#UI_MODE_TYPE_VR_HEADSET.
  ///
  /// The \#UI_MODE_NIGHT_MASK defines whether the screen
  /// is in a special mode. They may be one of \#UI_MODE_NIGHT_UNDEFINED,
  /// \#UI_MODE_NIGHT_NO or \#UI_MODE_NIGHT_YES.
  set uiMode(int value) => _set_uiMode(reference, value);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Configuration__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ///
  /// Construct an invalid Configuration. This state is only suitable for constructing a
  /// Configuration delta that will be applied to some valid Configuration object. In order to
  /// create a valid standalone Configuration, you must call \#setToDefaults.
  ///
  ///
  /// Example:
  ///
  /// <pre class="prettyprint">
  ///     Configuration validConfig = new Configuration();
  ///     validConfig.setToDefaults();
  ///
  ///     Configuration deltaOnlyConfig = new Configuration();
  ///     deltaOnlyConfig.orientation = Configuration.ORIENTATION_LANDSCAPE;
  ///
  ///     validConfig.updateFrom(deltaOnlyConfig);
  /// </pre>
  Configuration() : super.fromRef(_ctor().object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Configuration__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.res.Configuration o)
  ///
  /// Makes a deep copy suitable for modification.
  Configuration.ctor1(Configuration o)
      : super.fromRef(_ctor1(o.reference).object);

  static final _isLayoutSizeAtLeast = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Configuration__isLayoutSizeAtLeast")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean isLayoutSizeAtLeast(int size)
  ///
  /// Check if the Configuration's current \#screenLayout is at
  /// least the given size.
  ///@param size The desired size, either \#SCREENLAYOUT_SIZE_SMALL,
  /// \#SCREENLAYOUT_SIZE_NORMAL, \#SCREENLAYOUT_SIZE_LARGE, or
  /// \#SCREENLAYOUT_SIZE_XLARGE.
  ///@return Returns true if the current screen layout size is at least
  /// the given size.
  bool isLayoutSizeAtLeast(int size) =>
      _isLayoutSizeAtLeast(reference, size).boolean;

  static final _setTo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Configuration__setTo")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTo(android.content.res.Configuration o)
  ///
  /// Sets the fields in this object to those in the given Configuration.
  ///@param o The Configuration object used to set the values of this Configuration's fields.
  void setTo(Configuration o) => _setTo(reference, o.reference).check();

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Configuration__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);

  static final _setToDefaults = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Configuration__setToDefaults")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void setToDefaults()
  ///
  /// Set this object to the system defaults.
  void setToDefaults() => _setToDefaults(reference).check();

  static final _updateFrom = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Configuration__updateFrom")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int updateFrom(android.content.res.Configuration delta)
  ///
  /// Copies the fields from delta into this Configuration object, keeping
  /// track of which ones have changed. Any undefined fields in {@code delta}
  /// are ignored and not copied in to the current Configuration.
  ///@param delta This value must never be {@code null}.
  ///@return a bit mask of the changed fields, as per \#diff
  ///
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  int updateFrom(Configuration delta) =>
      _updateFrom(reference, delta.reference).integer;

  static final _diff = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Configuration__diff")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int diff(android.content.res.Configuration delta)
  ///
  /// Return a bit mask of the differences between this Configuration
  /// object and the given one.  Does not change the values of either.  Any
  /// undefined fields in <var>delta</var> are ignored.
  ///@return Returns a bit mask indicating which configuration
  /// values has changed, containing any combination of
  /// android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE PackageManager.ActivityInfo.CONFIG_FONT_SCALE,
  /// android.content.pm.ActivityInfo\#CONFIG_MCC PackageManager.ActivityInfo.CONFIG_MCC,
  /// android.content.pm.ActivityInfo\#CONFIG_MNC PackageManager.ActivityInfo.CONFIG_MNC,
  /// android.content.pm.ActivityInfo\#CONFIG_LOCALE PackageManager.ActivityInfo.CONFIG_LOCALE,
  /// android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN PackageManager.ActivityInfo.CONFIG_TOUCHSCREEN,
  /// android.content.pm.ActivityInfo\#CONFIG_KEYBOARD PackageManager.ActivityInfo.CONFIG_KEYBOARD,
  /// android.content.pm.ActivityInfo\#CONFIG_NAVIGATION PackageManager.ActivityInfo.CONFIG_NAVIGATION,
  /// android.content.pm.ActivityInfo\#CONFIG_ORIENTATION PackageManager.ActivityInfo.CONFIG_ORIENTATION,
  /// android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT PackageManager.ActivityInfo.CONFIG_SCREEN_LAYOUT, or
  /// android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE PackageManager.ActivityInfo.CONFIG_SCREEN_SIZE, or
  /// android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE PackageManager.ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE.
  /// android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION PackageManager.ActivityInfo.CONFIG_LAYOUT_DIRECTION.
  int diff(Configuration delta) => _diff(reference, delta.reference).integer;

  static final _needNewResources = jniLookup<
              ffi.NativeFunction<jni.JniResult Function(ffi.Int32, ffi.Int32)>>(
          "Configuration__needNewResources")
      .asFunction<jni.JniResult Function(int, int)>();

  /// from: static public boolean needNewResources(int configChanges, int interestingChanges)
  ///
  /// Determines if a new resource needs to be loaded from the bit set of
  /// configuration changes returned by \#updateFrom(Configuration).
  ///@param configChanges the mask of changes configurations as returned by
  ///                      \#updateFrom(Configuration)
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  ///@param interestingChanges the configuration changes that the resource
  ///                           can handle as given in
  ///                           android.util.TypedValue\#changingConfigurations
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  ///@return {@code true} if the resource needs to be loaded, {@code false}
  ///         otherwise
  static bool needNewResources(int configChanges, int interestingChanges) =>
      _needNewResources(configChanges, interestingChanges).boolean;

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Configuration__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  ///
  /// Parcelable methods
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Configuration__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _readFromParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Configuration__readFromParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(os_.Parcel source) =>
      _readFromParcel(reference, source.reference).check();

  static final _compareTo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Configuration__compareTo")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int compareTo(android.content.res.Configuration that)
  int compareTo(Configuration that) =>
      _compareTo(reference, that.reference).integer;

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Configuration__equals1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(android.content.res.Configuration that)
  bool equals1(Configuration that) =>
      _equals1(reference, that.reference).boolean;

  static final _equals2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Configuration__equals2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object that)
  bool equals2(jni.JniObject that) =>
      _equals2(reference, that.reference).boolean;

  static final _hashCode1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Configuration__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() => _hashCode1(reference).integer;

  static final _getLocales = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Configuration__getLocales")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.LocaleList getLocales()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the locale list. This is the preferred way for getting the locales (instead of using
  /// the direct accessor to \#locale, which would only provide the primary locale).
  ///@return The locale list.
  ///
  /// This value will never be {@code null}.
  os_.LocaleList getLocales() =>
      os_.LocaleList.fromRef(_getLocales(reference).object);

  static final _setLocales = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Configuration__setLocales")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setLocales(android.os.LocaleList locales)
  ///
  /// Set the locale list. This is the preferred way for setting up the locales (instead of using
  /// the direct accessor or \#setLocale(Locale)). This will also set the layout direction
  /// according to the first locale in the list.
  ///
  /// Note that the layout direction will always come from the first locale in the locale list,
  /// even if the locale is not supported by the resources (the resources may only support
  /// another locale further down the list which has a different direction).
  ///@param locales The locale list. If null, an empty LocaleList will be assigned.
  ///
  /// This value may be {@code null}.
  void setLocales(os_.LocaleList locales) =>
      _setLocales(reference, locales.reference).check();

  static final _setLocale = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Configuration__setLocale")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setLocale(java.util.Locale loc)
  ///
  /// Set the locale list to a list of just one locale. This will also set the layout direction
  /// according to the locale.
  ///
  /// Note that after this is run, calling <code>.equals()</code> on the input locale and the
  /// \#locale attribute would return <code>true</code> if they are not null, but there is
  /// no guarantee that they would be the same object.
  ///
  /// See also the note about layout direction in \#setLocales(LocaleList).
  ///@param loc The locale. Can be null.
  ///
  /// This value may be {@code null}.
  void setLocale(jni.JniObject loc) =>
      _setLocale(reference, loc.reference).check();

  static final _getLayoutDirection = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Configuration__getLayoutDirection")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLayoutDirection()
  ///
  /// Return the layout direction. Will be either View\#LAYOUT_DIRECTION_LTR or
  /// View\#LAYOUT_DIRECTION_RTL.
  ///@return Returns View\#LAYOUT_DIRECTION_RTL if the configuration
  /// is \#SCREENLAYOUT_LAYOUTDIR_RTL, otherwise View\#LAYOUT_DIRECTION_LTR.
  int getLayoutDirection() => _getLayoutDirection(reference).integer;

  static final _setLayoutDirection = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Configuration__setLayoutDirection")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setLayoutDirection(java.util.Locale loc)
  ///
  /// Set the layout direction from a Locale.
  ///@param loc The Locale. If null will set the layout direction to
  /// View\#LAYOUT_DIRECTION_LTR. If not null will set it to the layout direction
  /// corresponding to the Locale.
  ///@see View\#LAYOUT_DIRECTION_LTR
  ///@see View\#LAYOUT_DIRECTION_RTL
  void setLayoutDirection(jni.JniObject loc) =>
      _setLayoutDirection(reference, loc.reference).check();

  static final _isScreenRound = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Configuration__isScreenRound")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isScreenRound()
  ///
  /// Return whether the screen has a round shape. Apps may choose to change styling based
  /// on this property, such as the alignment or layout of text or informational icons.
  ///@return true if the screen is rounded, false otherwise
  bool isScreenRound() => _isScreenRound(reference).boolean;

  static final _isScreenWideColorGamut = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Configuration__isScreenWideColorGamut")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isScreenWideColorGamut()
  ///
  /// Return whether the screen has a wide color gamut and wide color gamut rendering
  /// is supported by this device.
  ///
  /// When true, it implies the screen is colorspace aware but not
  /// necessarily color-managed. The final colors may still be changed by the
  /// screen depending on user settings.
  ///@return true if the screen has a wide color gamut and wide color gamut rendering
  /// is supported, false otherwise
  bool isScreenWideColorGamut() => _isScreenWideColorGamut(reference).boolean;

  static final _isScreenHdr = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Configuration__isScreenHdr")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isScreenHdr()
  ///
  /// Return whether the screen has a high dynamic range.
  ///@return true if the screen has a high dynamic range, false otherwise
  bool isScreenHdr() => _isScreenHdr(reference).boolean;
}

/// from: android.content.res.ObbInfo
///
/// Basic information about a Opaque Binary Blob (OBB) that reflects the info
/// from the footer on the OBB file. This information may be manipulated by a
/// developer with the <code>obbtool</code> program in the Android SDK.
class ObbInfo extends jni.JniObject {
  ObbInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_ObbInfo__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.content.res.ObbInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  /// from: static public final int OBB_OVERLAY
  ///
  /// Flag noting that this OBB is an overlay patch for a base OBB.
  static const OBB_OVERLAY = 1;

  static final _get_filename = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ObbInfo__filename")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String filename
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The canonical filename of the OBB.
  jni.JniString get filename =>
      jni.JniString.fromRef(_get_filename(reference).object);
  static final _set_filename = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Pointer<ffi.Void>)>>("set_ObbInfo__filename")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String filename
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The canonical filename of the OBB.
  set filename(jni.JniString value) =>
      _set_filename(reference, value.reference);

  static final _get_flags = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ObbInfo__flags")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int flags
  ///
  /// The flags relating to the OBB.
  int get flags => _get_flags(reference).integer;
  static final _set_flags = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_ObbInfo__flags")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int flags
  ///
  /// The flags relating to the OBB.
  set flags(int value) => _set_flags(reference, value);

  static final _get_packageName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ObbInfo__packageName")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String packageName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The name of the package to which the OBB file belongs.
  jni.JniString get packageName =>
      jni.JniString.fromRef(_get_packageName(reference).object);
  static final _set_packageName = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_ObbInfo__packageName")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String packageName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The name of the package to which the OBB file belongs.
  set packageName(jni.JniString value) =>
      _set_packageName(reference, value.reference);

  static final _get_version = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ObbInfo__version")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int version
  ///
  /// The version of the package to which the OBB file belongs.
  int get version => _get_version(reference).integer;
  static final _set_version = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_ObbInfo__version")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int version
  ///
  /// The version of the package to which the OBB file belongs.
  set version(int value) => _set_version(reference, value);

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("ObbInfo__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  ObbInfo() : super.fromRef(_ctor().object);

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ObbInfo__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ObbInfo__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("ObbInfo__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int parcelableFlags)
  void writeToParcel(os_.Parcel dest, int parcelableFlags) =>
      _writeToParcel(reference, dest.reference, parcelableFlags).check();
}

/// from: android.content.res.ObbScanner
///
/// Class to scan Opaque Binary Blob (OBB) files. Use this to get information
/// about an OBB file for use in a program via ObbInfo.
class ObbScanner extends jni.JniObject {
  ObbScanner.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ObbScanner__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  ObbScanner() : super.fromRef(_ctor().object);

  static final _getObbInfo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ObbScanner__getObbInfo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.res.ObbInfo getObbInfo(java.lang.String filePath)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Scan a file for OBB information.
  ///@param filePath path to the OBB file to be scanned.
  ///@return ObbInfo object information corresponding to the file path
  ///@throws IllegalArgumentException if the OBB file couldn't be found
  ///@throws IOException if the OBB file couldn't be read
  static ObbInfo getObbInfo(jni.JniString filePath) =>
      ObbInfo.fromRef(_getObbInfo(filePath.reference).object);
}

/// from: android.content.res.Resources
///
/// Class for accessing an application's resources.  This sits on top of the
/// asset manager of the application (accessible through \#getAssets) and
/// provides a high-level API for getting typed data from the assets.
///
/// The Android resource system keeps track of all non-code assets associated with an
/// application. You can use this class to access your application's resources. You can generally
/// acquire the android.content.res.Resources instance associated with your application
/// with android.content.Context\#getResources getResources().
///
///
/// The Android SDK tools compile your application's resources into the application binary
/// at build time.  To use a resource, you must install it correctly in the source tree (inside
/// your project's {@code res/} directory) and build your application.  As part of the build
/// process, the SDK tools generate symbols for each resource, which you can use in your application
/// code to access the resources.
///
///
/// Using application resources makes it easy to update various characteristics of your
/// application without modifying code, and&mdash;by providing sets of alternative
/// resources&mdash;enables you to optimize your application for a variety of device configurations
/// (such as for different languages and screen sizes). This is an important aspect of developing
/// Android applications that are compatible on different types of devices.
///
///
/// For more information about using resources, see the documentation about <a href="{@docRoot}guide/topics/resources/index.html">Application Resources</a>.
///
class Resources extends jni.JniObject {
  Resources.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Resources__ctor")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.res.AssetManager assets, android.util.DisplayMetrics metrics, android.content.res.Configuration config)
  ///
  /// Create a new Resources object on top of an existing set of assets in an
  /// AssetManager.
  ///@deprecated Resources should not be constructed by apps.
  /// See android.content.Context\#createConfigurationContext(Configuration).
  ///@param assets Previously created AssetManager.
  ///@param metrics Current display metrics to consider when
  ///                selecting/computing resource values.
  ///@param config Desired device configuration to consider when
  ///               selecting/computing resource values (optional).
  Resources(AssetManager assets, jni.JniObject metrics, Configuration config)
      : super.fromRef(
            _ctor(assets.reference, metrics.reference, config.reference)
                .object);

  static final _getSystem =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Resources__getSystem")
          .asFunction<jni.JniResult Function()>();

  /// from: static public android.content.res.Resources getSystem()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a global shared Resources object that provides access to only
  /// system resources (no application resources), and is not configured for
  /// the current screen (can not use dimension units, does not change based
  /// on orientation, etc).
  static Resources getSystem() => Resources.fromRef(_getSystem().object);

  static final _getText = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Resources__getText")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.CharSequence getText(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the string value associated with a particular resource ID.  The
  /// returned object will be a String if this is a plain string; it will be
  /// some other type of CharSequence if it is styled.
  /// {@more }
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return CharSequence The string data associated with the resource, plus
  ///         possibly styled text information.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getText(int id) =>
      jni.JniObject.fromRef(_getText(reference, id).object);

  static final _getFont = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Resources__getFont")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.Typeface getFont(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Typeface value associated with a particular resource ID.
  /// {@more }
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return Typeface The Typeface data associated with the resource.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getFont(int id) =>
      jni.JniObject.fromRef(_getFont(reference, id).object);

  static final _getQuantityText = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Resources__getQuantityText")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public java.lang.CharSequence getQuantityText(int id, int quantity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the character sequence necessary for grammatically correct pluralization
  /// of the given resource ID for the given quantity.
  /// Note that the character sequence is selected based solely on grammatical necessity,
  /// and that such rules differ between languages. Do not assume you know which string
  /// will be returned for a given quantity. See
  /// <a href="{@docRoot}guide/topics/resources/string-resource.html\#Plurals">String Resources</a>
  /// for more detail.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@param quantity The number used to get the correct string for the current language's
  ///           plural rules.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return CharSequence The string data associated with the resource, plus
  ///         possibly styled text information.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getQuantityText(int id, int quantity) =>
      jni.JniObject.fromRef(_getQuantityText(reference, id, quantity).object);

  static final _getString = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Resources__getString")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getString(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the string value associated with a particular resource ID.  It
  /// will be stripped of any styled text information.
  /// {@more }
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return String The string data associated with the resource,
  ///         stripped of styled text information.
  ///
  /// This value will never be {@code null}.
  jni.JniString getString(int id) =>
      jni.JniString.fromRef(_getString(reference, id).object);

  static final _getString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Resources__getString1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getString(int id, java.lang.Object[] formatArgs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the string value associated with a particular resource ID,
  /// substituting the format arguments as defined in java.util.Formatter
  /// and java.lang.String\#format. It will be stripped of any styled text
  /// information.
  /// {@more }
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@param formatArgs The format arguments that will be used for substitution.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return String The string data associated with the resource,
  ///         stripped of styled text information.
  ///
  /// This value will never be {@code null}.
  jni.JniString getString1(int id, jni.JniObject formatArgs) =>
      jni.JniString.fromRef(
          _getString1(reference, id, formatArgs.reference).object);

  static final _getQuantityString = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Resources__getQuantityString")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getQuantityString(int id, int quantity, java.lang.Object[] formatArgs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formats the string necessary for grammatically correct pluralization
  /// of the given resource ID for the given quantity, using the given arguments.
  /// Note that the string is selected based solely on grammatical necessity,
  /// and that such rules differ between languages. Do not assume you know which string
  /// will be returned for a given quantity. See
  /// <a href="{@docRoot}guide/topics/resources/string-resource.html\#Plurals">String Resources</a>
  /// for more detail.
  ///
  /// Substitution of format arguments works as if using
  /// java.util.Formatter and java.lang.String\#format.
  /// The resulting string will be stripped of any styled text information.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@param quantity The number used to get the correct string for the current language's
  ///           plural rules.
  ///@param formatArgs The format arguments that will be used for substitution.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return String The string data associated with the resource,
  /// stripped of styled text information.
  ///
  /// This value will never be {@code null}.
  jni.JniString getQuantityString(
          int id, int quantity, jni.JniObject formatArgs) =>
      jni.JniString.fromRef(
          _getQuantityString(reference, id, quantity, formatArgs.reference)
              .object);

  static final _getQuantityString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Resources__getQuantityString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public java.lang.String getQuantityString(int id, int quantity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the string necessary for grammatically correct pluralization
  /// of the given resource ID for the given quantity.
  /// Note that the string is selected based solely on grammatical necessity,
  /// and that such rules differ between languages. Do not assume you know which string
  /// will be returned for a given quantity. See
  /// <a href="{@docRoot}guide/topics/resources/string-resource.html\#Plurals">String Resources</a>
  /// for more detail.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@param quantity The number used to get the correct string for the current language's
  ///           plural rules.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return String The string data associated with the resource,
  /// stripped of styled text information.
  ///
  /// This value will never be {@code null}.
  jni.JniString getQuantityString1(int id, int quantity) =>
      jni.JniString.fromRef(
          _getQuantityString1(reference, id, quantity).object);

  static final _getText1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Resources__getText1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getText(int id, java.lang.CharSequence def)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the string value associated with a particular resource ID.  The
  /// returned object will be a String if this is a plain string; it will be
  /// some other type of CharSequence if it is styled.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@param def The default CharSequence to return.
  ///@return CharSequence The string data associated with the resource, plus
  ///         possibly styled text information, or def if id is 0 or not found.
  jni.JniObject getText1(int id, jni.JniObject def) =>
      jni.JniObject.fromRef(_getText1(reference, id, def.reference).object);

  static final _getTextArray = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Resources__getTextArray")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.CharSequence[] getTextArray(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the styled text array associated with a particular resource ID.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return The styled text array associated with the resource.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getTextArray(int id) =>
      jni.JniObject.fromRef(_getTextArray(reference, id).object);

  static final _getStringArray = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Resources__getStringArray")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String[] getStringArray(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the string array associated with a particular resource ID.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return The string array associated with the resource.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getStringArray(int id) =>
      jni.JniObject.fromRef(_getStringArray(reference, id).object);

  static final _getIntArray = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Resources__getIntArray")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int[] getIntArray(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the int array associated with a particular resource ID.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return The int array associated with the resource.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getIntArray(int id) =>
      jni.JniObject.fromRef(_getIntArray(reference, id).object);

  static final _obtainTypedArray = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Resources__obtainTypedArray")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.res.TypedArray obtainTypedArray(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an array of heterogeneous values.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return Returns a TypedArray holding an array of the array values.
  /// Be sure to call TypedArray\#recycle() TypedArray.recycle()
  /// when done with it.
  ///
  /// This value will never be {@code null}.
  TypedArray obtainTypedArray(int id) =>
      TypedArray.fromRef(_obtainTypedArray(reference, id).object);

  static final _getDimension = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Resources__getDimension")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public float getDimension(int id)
  ///
  /// Retrieve a dimensional for a particular resource ID.  Unit
  /// conversions are based on the current DisplayMetrics associated
  /// with the resources.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@return Resource dimension value multiplied by the appropriate
  /// metric.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@see \#getDimensionPixelOffset
  ///@see \#getDimensionPixelSize
  double getDimension(int id) => _getDimension(reference, id).float;

  static final _getDimensionPixelOffset = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Resources__getDimensionPixelOffset")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getDimensionPixelOffset(int id)
  ///
  /// Retrieve a dimensional for a particular resource ID for use
  /// as an offset in raw pixels.  This is the same as
  /// \#getDimension, except the returned value is converted to
  /// integer pixels for you.  An offset conversion involves simply
  /// truncating the base value to an integer.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@return Resource dimension value multiplied by the appropriate
  /// metric and truncated to integer pixels.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@see \#getDimension
  ///@see \#getDimensionPixelSize
  int getDimensionPixelOffset(int id) =>
      _getDimensionPixelOffset(reference, id).integer;

  static final _getDimensionPixelSize = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Resources__getDimensionPixelSize")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getDimensionPixelSize(int id)
  ///
  /// Retrieve a dimensional for a particular resource ID for use
  /// as a size in raw pixels.  This is the same as
  /// \#getDimension, except the returned value is converted to
  /// integer pixels for use as a size.  A size conversion involves
  /// rounding the base value, and ensuring that a non-zero base value
  /// is at least one pixel in size.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@return Resource dimension value multiplied by the appropriate
  /// metric and truncated to integer pixels.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@see \#getDimension
  ///@see \#getDimensionPixelOffset
  int getDimensionPixelSize(int id) =>
      _getDimensionPixelSize(reference, id).integer;

  static final _getFraction = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32)>>("Resources__getFraction")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public float getFraction(int id, int base, int pbase)
  ///
  /// Retrieve a fractional unit for a particular resource ID.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@param base The base value of this fraction.  In other words, a
  ///             standard fraction is multiplied by this value.
  ///@param pbase The parent base value of this fraction.  In other
  ///             words, a parent fraction (nn%p) is multiplied by this
  ///             value.
  ///@return Attribute fractional value multiplied by the appropriate
  /// base value.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  double getFraction(int id, int base, int pbase) =>
      _getFraction(reference, id, base, pbase).float;

  static final _getDrawable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Resources__getDrawable")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.drawable.Drawable getDrawable(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a drawable object associated with a particular resource ID.
  /// Various types of objects will be returned depending on the underlying
  /// resource -- for example, a solid color, PNG image, scalable image, etc.
  /// The Drawable API hides these implementation details.
  ///
  /// <p class="note"><strong>Note:</strong> Prior to
  /// android.os.Build.VERSION_CODES\#JELLY_BEAN, this function
  /// would not correctly retrieve the final configuration density when
  /// the resource ID passed here is an alias to another Drawable resource.
  /// This means that if the density configuration of the alias resource
  /// is different than the actual resource, the density of the returned
  /// Drawable would be incorrect, resulting in bad scaling. To work
  /// around this, you can instead manually resolve the aliased reference
  /// by using \#getValue(int, TypedValue, boolean) and passing
  /// {@code true} for {@code resolveRefs}. The resulting
  /// TypedValue\#resourceId value may be passed to this method.
  ///
  ///
  /// <p class="note"><strong>Note:</strong> To obtain a themed drawable, use
  /// android.content.Context\#getDrawable(int) Context.getDrawable(int)
  /// or \#getDrawable(int, Theme) passing the desired theme.
  ///
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@return Drawable An object that can be used to draw this resource.
  ///@throws NotFoundException Throws NotFoundException if the given ID does
  ///         not exist.
  ///@see \#getDrawable(int, Theme)
  ///@deprecated Use \#getDrawable(int, Theme) instead.
  jni.JniObject getDrawable(int id) =>
      jni.JniObject.fromRef(_getDrawable(reference, id).object);

  static final _getDrawable1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Resources__getDrawable1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable getDrawable(int id, android.content.res.Resources.Theme theme)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a drawable object associated with a particular resource ID and
  /// styled for the specified theme. Various types of objects will be
  /// returned depending on the underlying resource -- for example, a solid
  /// color, PNG image, scalable image, etc.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@param theme The theme used to style the drawable attributes, may be {@code null}.
  /// This value may be {@code null}.
  ///@return Drawable An object that can be used to draw this resource.
  ///@throws NotFoundException Throws NotFoundException if the given ID does
  ///         not exist.
  jni.JniObject getDrawable1(int id, Resources_Theme theme) =>
      jni.JniObject.fromRef(
          _getDrawable1(reference, id, theme.reference).object);

  static final _getDrawableForDensity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Resources__getDrawableForDensity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.graphics.drawable.Drawable getDrawableForDensity(int id, int density)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a drawable object associated with a particular resource ID for the
  /// given screen density in DPI. This will set the drawable's density to be
  /// the device's density multiplied by the ratio of actual drawable density
  /// to requested density. This allows the drawable to be scaled up to the
  /// correct size if needed. Various types of objects will be returned
  /// depending on the underlying resource -- for example, a solid color, PNG
  /// image, scalable image, etc. The Drawable API hides these implementation
  /// details.
  ///
  /// <p class="note"><strong>Note:</strong> To obtain a themed drawable, use
  /// android.content.Context\#getDrawable(int) Context.getDrawable(int)
  /// or \#getDrawableForDensity(int, int, Theme) passing the desired
  /// theme.
  ///
  ///@param id The desired resource identifier, as generated by the aapt tool.
  ///            This integer encodes the package, type, and resource entry.
  ///            The value 0 is an invalid identifier.
  ///@param density the desired screen density indicated by the resource as
  ///            found in DisplayMetrics. A value of 0 means to use the
  ///            density returned from \#getConfiguration().
  ///            This is equivalent to calling \#getDrawable(int).
  ///@return Drawable An object that can be used to draw this resource.
  /// This value may be {@code null}.
  ///@throws NotFoundException Throws NotFoundException if the given ID does
  ///             not exist.
  ///@see \#getDrawableForDensity(int, int, Theme)
  ///@deprecated Use \#getDrawableForDensity(int, int, Theme) instead.
  jni.JniObject getDrawableForDensity(int id, int density) =>
      jni.JniObject.fromRef(
          _getDrawableForDensity(reference, id, density).object);

  static final _getDrawableForDensity1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Resources__getDrawableForDensity1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable getDrawableForDensity(int id, int density, android.content.res.Resources.Theme theme)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a drawable object associated with a particular resource ID for the
  /// given screen density in DPI and styled for the specified theme.
  ///@param id The desired resource identifier, as generated by the aapt tool.
  ///            This integer encodes the package, type, and resource entry.
  ///            The value 0 is an invalid identifier.
  ///@param density The desired screen density indicated by the resource as
  ///            found in DisplayMetrics. A value of 0 means to use the
  ///            density returned from \#getConfiguration().
  ///            This is equivalent to calling \#getDrawable(int, Theme).
  ///@param theme The theme used to style the drawable attributes, may be {@code null} if the
  ///              drawable cannot be decoded.
  /// This value may be {@code null}.
  ///@return Drawable An object that can be used to draw this resource.
  ///@throws NotFoundException Throws NotFoundException if the given ID does
  ///             not exist.
  jni.JniObject getDrawableForDensity1(
          int id, int density, Resources_Theme theme) =>
      jni.JniObject.fromRef(
          _getDrawableForDensity1(reference, id, density, theme.reference)
              .object);

  static final _getMovie = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Resources__getMovie")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.Movie getMovie(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a movie object associated with the particular resource ID.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  jni.JniObject getMovie(int id) =>
      jni.JniObject.fromRef(_getMovie(reference, id).object);

  static final _getColor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Resources__getColor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getColor(int id)
  ///
  /// Returns a color integer associated with a particular resource ID. If the
  /// resource holds a complex ColorStateList, then the default color
  /// from the set is returned.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does
  ///         not exist.
  ///@return A single color value in the form 0xAARRGGBB.
  ///@deprecated Use \#getColor(int, Theme) instead.
  int getColor(int id) => _getColor(reference, id).integer;

  static final _getColor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Resources__getColor1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public int getColor(int id, android.content.res.Resources.Theme theme)
  ///
  /// Returns a themed color integer associated with a particular resource ID.
  /// If the resource holds a complex ColorStateList, then the default
  /// color from the set is returned.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@param theme The theme used to style the color attributes, may be
  ///              {@code null}.
  ///
  /// This value may be {@code null}.
  ///@throws NotFoundException Throws NotFoundException if the given ID does
  ///         not exist.
  ///@return A single color value in the form 0xAARRGGBB.
  int getColor1(int id, Resources_Theme theme) =>
      _getColor1(reference, id, theme.reference).integer;

  static final _getColorStateList = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Resources__getColorStateList")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.res.ColorStateList getColorStateList(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a color state list associated with a particular resource ID. The
  /// resource may contain either a single raw color value or a complex
  /// ColorStateList holding multiple possible colors.
  ///@param id The desired resource identifier of a ColorStateList,
  ///           as generated by the aapt tool. This integer encodes the
  ///           package, type, and resource entry. The value 0 is an invalid
  ///           identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does
  ///         not exist.
  ///@return A ColorStateList object containing either a single solid color
  ///         or multiple colors that can be selected based on a state.
  /// This value will never be {@code null}.
  ///@deprecated Use \#getColorStateList(int, Theme) instead.
  ColorStateList getColorStateList(int id) =>
      ColorStateList.fromRef(_getColorStateList(reference, id).object);

  static final _getColorStateList1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Resources__getColorStateList1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.ColorStateList getColorStateList(int id, android.content.res.Resources.Theme theme)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a themed color state list associated with a particular resource
  /// ID. The resource may contain either a single raw color value or a
  /// complex ColorStateList holding multiple possible colors.
  ///@param id The desired resource identifier of a ColorStateList,
  ///           as generated by the aapt tool. This integer encodes the
  ///           package, type, and resource entry. The value 0 is an invalid
  ///           identifier.
  ///@param theme The theme used to style the color attributes, may be
  ///              {@code null}.
  ///
  /// This value may be {@code null}.
  ///@throws NotFoundException Throws NotFoundException if the given ID does
  ///         not exist.
  ///@return A themed ColorStateList object containing either a single solid
  ///         color or multiple colors that can be selected based on a state.
  ColorStateList getColorStateList1(int id, Resources_Theme theme) =>
      ColorStateList.fromRef(
          _getColorStateList1(reference, id, theme.reference).object);

  static final _getBoolean = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Resources__getBoolean")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean getBoolean(int id)
  ///
  /// Return a boolean associated with a particular resource ID.  This can be
  /// used with any integral resource value, and will return true if it is
  /// non-zero.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return Returns the boolean value contained in the resource.
  bool getBoolean(int id) => _getBoolean(reference, id).boolean;

  static final _getInteger = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Resources__getInteger")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getInteger(int id)
  ///
  /// Return an integer associated with a particular resource ID.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return Returns the integer value contained in the resource.
  int getInteger(int id) => _getInteger(reference, id).integer;

  static final _getLayout = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Resources__getLayout")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.res.XmlResourceParser getLayout(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an XmlResourceParser through which you can read a view layout
  /// description for the given resource ID.  This parser has limited
  /// functionality -- in particular, you can't change its input, and only
  /// the high-level events are available.
  ///
  /// This function is really a simple wrapper for calling
  /// \#getXml with a layout resource.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return A new parser object through which you can read
  ///         the XML data.
  ///
  /// This value will never be {@code null}.
  ///@see \#getXml
  XmlResourceParser getLayout(int id) =>
      XmlResourceParser.fromRef(_getLayout(reference, id).object);

  static final _getAnimation = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Resources__getAnimation")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.res.XmlResourceParser getAnimation(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an XmlResourceParser through which you can read an animation
  /// description for the given resource ID.  This parser has limited
  /// functionality -- in particular, you can't change its input, and only
  /// the high-level events are available.
  ///
  /// This function is really a simple wrapper for calling
  /// \#getXml with an animation resource.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return A new parser object through which you can read
  ///         the XML data.
  ///
  /// This value will never be {@code null}.
  ///@see \#getXml
  XmlResourceParser getAnimation(int id) =>
      XmlResourceParser.fromRef(_getAnimation(reference, id).object);

  static final _getXml = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Resources__getXml")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.res.XmlResourceParser getXml(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an XmlResourceParser through which you can read a generic XML
  /// resource for the given resource ID.
  ///
  /// The XmlPullParser implementation returned here has some limited
  /// functionality.  In particular, you can't change its input, and only
  /// high-level parsing events are available (since the document was
  /// pre-parsed for you at build time, which involved merging text and
  /// stripping comments).
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return A new parser object through which you can read
  ///         the XML data.
  ///
  /// This value will never be {@code null}.
  ///@see android.util.AttributeSet
  XmlResourceParser getXml(int id) =>
      XmlResourceParser.fromRef(_getXml(reference, id).object);

  static final _openRawResource = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Resources__openRawResource")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.io.InputStream openRawResource(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a data stream for reading a raw resource.  This can only be used
  /// with resources whose value is the name of an asset files -- that is, it can be
  /// used to open drawable, sound, and raw resources; it will fail on string
  /// and color resources.
  ///@param id The resource identifier to open, as generated by the aapt tool.
  ///@return InputStream Access to the resource data.
  ///
  /// This value will never be {@code null}.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  jni.JniObject openRawResource(int id) =>
      jni.JniObject.fromRef(_openRawResource(reference, id).object);

  static final _openRawResource1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Resources__openRawResource1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public java.io.InputStream openRawResource(int id, android.util.TypedValue value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a data stream for reading a raw resource.  This can only be used
  /// with resources whose value is the name of an asset file -- that is, it can be
  /// used to open drawable, sound, and raw resources; it will fail on string
  /// and color resources.
  ///@param id The resource identifier to open, as generated by the aapt tool.
  ///@param value The TypedValue object to hold the resource information.
  ///@return InputStream Access to the resource data.
  ///
  /// This value will never be {@code null}.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  jni.JniObject openRawResource1(int id, jni.JniObject value) =>
      jni.JniObject.fromRef(
          _openRawResource1(reference, id, value.reference).object);

  static final _openRawResourceFd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Resources__openRawResourceFd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.res.AssetFileDescriptor openRawResourceFd(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a file descriptor for reading a raw resource.  This can only be used
  /// with resources whose value is the name of an asset files -- that is, it can be
  /// used to open drawable, sound, and raw resources; it will fail on string
  /// and color resources.
  ///
  /// This function only works for resources that are stored in the package
  /// as uncompressed data, which typically includes things like mp3 files
  /// and png images.
  ///@param id The resource identifier to open, as generated by the aapt tool.
  ///@return AssetFileDescriptor A new file descriptor you can use to read
  /// the resource.  This includes the file descriptor itself, as well as the
  /// offset and length of data where the resource appears in the file.  A
  /// null is returned if the file exists but is compressed.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  AssetFileDescriptor openRawResourceFd(int id) =>
      AssetFileDescriptor.fromRef(_openRawResourceFd(reference, id).object);

  static final _getValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Resources__getValue")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void getValue(int id, android.util.TypedValue outValue, boolean resolveRefs)
  ///
  /// Return the raw data associated with a particular resource ID.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@param outValue Object in which to place the resource data.
  ///@param resolveRefs If true, a resource that is a reference to another
  ///                    resource will be followed so that you receive the
  ///                    actual final resource data.  If false, the TypedValue
  ///                    will be filled in with the reference itself.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  void getValue(int id, jni.JniObject outValue, bool resolveRefs) =>
      _getValue(reference, id, outValue.reference, resolveRefs ? 1 : 0).check();

  static final _getValueForDensity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Resources__getValueForDensity")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void getValueForDensity(int id, int density, android.util.TypedValue outValue, boolean resolveRefs)
  ///
  /// Get the raw value associated with a resource with associated density.
  ///@param id resource identifier
  ///@param density density in DPI
  ///@param resolveRefs If true, a resource that is a reference to another
  ///            resource will be followed so that you receive the actual final
  ///            resource data. If false, the TypedValue will be filled in with
  ///            the reference itself.
  ///@throws NotFoundException Throws NotFoundException if the given ID does
  ///             not exist.
  ///@see \#getValue(String, TypedValue, boolean)
  void getValueForDensity(
          int id, int density, jni.JniObject outValue, bool resolveRefs) =>
      _getValueForDensity(
              reference, id, density, outValue.reference, resolveRefs ? 1 : 0)
          .check();

  static final _getValue1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Resources__getValue1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void getValue(java.lang.String name, android.util.TypedValue outValue, boolean resolveRefs)
  ///
  /// Return the raw data associated with a particular resource ID.
  /// See getIdentifier() for information on how names are mapped to resource
  /// IDs, and getString(int) for information on how string resources are
  /// retrieved.
  ///
  /// Note: use of this function is discouraged.  It is much more
  /// efficient to retrieve resources by identifier than by name.
  ///@param name The name of the desired resource.  This is passed to
  ///             getIdentifier() with a default type of "string".
  ///@param outValue Object in which to place the resource data.
  ///@param resolveRefs If true, a resource that is a reference to another
  ///                    resource will be followed so that you receive the
  ///                    actual final resource data.  If false, the TypedValue
  ///                    will be filled in with the reference itself.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  void getValue1(
          jni.JniString name, jni.JniObject outValue, bool resolveRefs) =>
      _getValue1(reference, name.reference, outValue.reference,
              resolveRefs ? 1 : 0)
          .check();

  static final _newTheme = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Resources__newTheme")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.Resources.Theme newTheme()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Generate a new Theme object for this set of Resources.  It initially
  /// starts out empty.
  ///@return Theme The newly created Theme container.
  Resources_Theme newTheme() =>
      Resources_Theme.fromRef(_newTheme(reference).object);

  static final _obtainAttributes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Resources__obtainAttributes")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.TypedArray obtainAttributes(android.util.AttributeSet set, int[] attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a set of basic attribute values from an AttributeSet, not
  /// performing styling of them using a theme and/or style resources.
  ///@param set The current attribute values to retrieve.
  ///@param attrs The specific attributes to be retrieved. These attribute IDs must be sorted in
  ///              ascending order.
  ///@return Returns a TypedArray holding an array of the attribute values.
  /// Be sure to call TypedArray\#recycle() TypedArray.recycle()
  /// when done with it.
  ///@see Theme\#obtainStyledAttributes(AttributeSet, int[], int, int)
  TypedArray obtainAttributes(jni.JniObject set0, jni.JniObject attrs) =>
      TypedArray.fromRef(
          _obtainAttributes(reference, set0.reference, attrs.reference).object);

  static final _updateConfiguration = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Resources__updateConfiguration")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void updateConfiguration(android.content.res.Configuration config, android.util.DisplayMetrics metrics)
  ///
  /// Store the newly updated configuration.
  ///@deprecated See android.content.Context\#createConfigurationContext(Configuration).
  void updateConfiguration(Configuration config, jni.JniObject metrics) =>
      _updateConfiguration(reference, config.reference, metrics.reference)
          .check();

  static final _getDisplayMetrics = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Resources__getDisplayMetrics")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.util.DisplayMetrics getDisplayMetrics()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the current display metrics that are in effect for this resource
  /// object.  The returned object should be treated as read-only.
  ///@return The resource's current display metrics.
  jni.JniObject getDisplayMetrics() =>
      jni.JniObject.fromRef(_getDisplayMetrics(reference).object);

  static final _getConfiguration = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Resources__getConfiguration")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.Configuration getConfiguration()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the current configuration that is in effect for this resource
  /// object.  The returned object should be treated as read-only.
  ///@return The resource's current configuration.
  Configuration getConfiguration() =>
      Configuration.fromRef(_getConfiguration(reference).object);

  static final _getIdentifier = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Resources__getIdentifier")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getIdentifier(java.lang.String name, java.lang.String defType, java.lang.String defPackage)
  ///
  /// Return a resource identifier for the given resource name.  A fully
  /// qualified resource name is of the form "package:type/entry".  The first
  /// two components (package and type) are optional if defType and
  /// defPackage, respectively, are specified here.
  ///
  /// Note: use of this function is discouraged.  It is much more
  /// efficient to retrieve resources by identifier than by name.
  ///@param name The name of the desired resource.
  ///@param defType Optional default resource type to find, if "type/" is
  ///                not included in the name.  Can be null to require an
  ///                explicit type.
  ///@param defPackage Optional default package to find, if "package:" is
  ///                   not included in the name.  Can be null to require an
  ///                   explicit package.
  ///@return int The associated resource identifier.  Returns 0 if no such
  ///         resource was found.  (0 is not a valid resource ID.)
  int getIdentifier(jni.JniString name, jni.JniString defType,
          jni.JniString defPackage) =>
      _getIdentifier(reference, name.reference, defType.reference,
              defPackage.reference)
          .integer;

  static final _getResourceName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Resources__getResourceName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getResourceName(int resid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the full name for a given resource identifier.  This name is
  /// a single string of the form "package:type/entry".
  ///@param resid The resource identifier whose name is to be retrieved.
  ///@return A string holding the name of the resource.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@see \#getResourcePackageName
  ///@see \#getResourceTypeName
  ///@see \#getResourceEntryName
  jni.JniString getResourceName(int resid) =>
      jni.JniString.fromRef(_getResourceName(reference, resid).object);

  static final _getResourcePackageName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Resources__getResourcePackageName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getResourcePackageName(int resid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the package name for a given resource identifier.
  ///@param resid The resource identifier whose package name is to be
  /// retrieved.
  ///@return A string holding the package name of the resource.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@see \#getResourceName
  jni.JniString getResourcePackageName(int resid) =>
      jni.JniString.fromRef(_getResourcePackageName(reference, resid).object);

  static final _getResourceTypeName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Resources__getResourceTypeName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getResourceTypeName(int resid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the type name for a given resource identifier.
  ///@param resid The resource identifier whose type name is to be
  /// retrieved.
  ///@return A string holding the type name of the resource.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@see \#getResourceName
  jni.JniString getResourceTypeName(int resid) =>
      jni.JniString.fromRef(_getResourceTypeName(reference, resid).object);

  static final _getResourceEntryName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Resources__getResourceEntryName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getResourceEntryName(int resid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the entry name for a given resource identifier.
  ///@param resid The resource identifier whose entry name is to be
  /// retrieved.
  ///@return A string holding the entry name of the resource.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@see \#getResourceName
  jni.JniString getResourceEntryName(int resid) =>
      jni.JniString.fromRef(_getResourceEntryName(reference, resid).object);

  static final _parseBundleExtras = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Resources__parseBundleExtras")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void parseBundleExtras(android.content.res.XmlResourceParser parser, android.os.Bundle outBundle)
  ///
  /// Parse a series of android.R.styleable\#Extra &lt;extra&gt; tags from
  /// an XML file.  You call this when you are at the parent tag of the
  /// extra tags, and it will return once all of the child tags have been parsed.
  /// This will call \#parseBundleExtra for each extra tag encountered.
  ///@param parser The parser from which to retrieve the extras.
  ///@param outBundle A Bundle in which to place all parsed extras.
  ///@throws XmlPullParserException
  ///@throws IOException
  void parseBundleExtras(XmlResourceParser parser, os_.Bundle outBundle) =>
      _parseBundleExtras(reference, parser.reference, outBundle.reference)
          .check();

  static final _parseBundleExtra = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Resources__parseBundleExtra")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void parseBundleExtra(java.lang.String tagName, android.util.AttributeSet attrs, android.os.Bundle outBundle)
  ///
  /// Parse a name/value pair out of an XML tag holding that data.  The
  /// AttributeSet must be holding the data defined by
  /// android.R.styleable\#Extra.  The following value types are supported:
  /// <ul>
  /// <li> TypedValue\#TYPE_STRING:
  /// Bundle\#putCharSequence Bundle.putCharSequence()
  /// <li> TypedValue\#TYPE_INT_BOOLEAN:
  /// Bundle\#putCharSequence Bundle.putBoolean()
  /// <li> TypedValue\#TYPE_FIRST_INT-TypedValue\#TYPE_LAST_INT:
  /// Bundle\#putCharSequence Bundle.putBoolean()
  /// <li> TypedValue\#TYPE_FLOAT:
  /// Bundle\#putCharSequence Bundle.putFloat()
  /// </ul>
  ///@param tagName The name of the tag these attributes come from; this is
  /// only used for reporting error messages.
  ///@param attrs The attributes from which to retrieve the name/value pair.
  ///@param outBundle The Bundle in which to place the parsed value.
  ///@throws XmlPullParserException If the attributes are not valid.
  void parseBundleExtra(
          jni.JniString tagName, jni.JniObject attrs, os_.Bundle outBundle) =>
      _parseBundleExtra(reference, tagName.reference, attrs.reference,
              outBundle.reference)
          .check();

  static final _getAssets = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Resources__getAssets")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.AssetManager getAssets()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve underlying AssetManager storage for these resources.
  AssetManager getAssets() =>
      AssetManager.fromRef(_getAssets(reference).object);

  static final _flushLayoutCache = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Resources__flushLayoutCache")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final void flushLayoutCache()
  ///
  /// Call this to remove all cached loaded layout resources from the
  /// Resources object.  Only intended for use with performance testing
  /// tools.
  void flushLayoutCache() => _flushLayoutCache(reference).check();

  static final _finishPreloading = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Resources__finishPreloading")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final void finishPreloading()
  ///
  /// Called by zygote when it is done preloading resources, to change back
  /// to normal Resources operation.
  void finishPreloading() => _finishPreloading(reference).check();
}

/// from: android.content.res.Resources$Theme
///
/// This class holds the current attribute values for a particular theme.
/// In other words, a Theme is a set of values for resource attributes;
/// these are used in conjunction with TypedArray
/// to resolve the final value for an attribute.
///
/// The Theme's attributes come into play in two ways: (1) a styled
/// attribute can explicit reference a value in the theme through the
/// "?themeAttribute" syntax; (2) if no value has been defined for a
/// particular styled attribute, as a last resort we will try to find that
/// attribute's value in the Theme.
///
/// You will normally use the \#obtainStyledAttributes APIs to
/// retrieve XML attributes with style and theme information applied.
class Resources_Theme extends jni.JniObject {
  Resources_Theme.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Resources_Theme__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  Resources_Theme() : super.fromRef(_ctor().object);

  static final _applyStyle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Uint8)>>("Resources_Theme__applyStyle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void applyStyle(int resId, boolean force)
  ///
  /// Place new attribute values into the theme.  The style resource
  /// specified by <var>resid</var> will be retrieved from this Theme's
  /// resources, its values placed into the Theme object.
  ///
  /// The semantics of this function depends on the <var>force</var>
  /// argument:  If false, only values that are not already defined in
  /// the theme will be copied from the system resource; otherwise, if
  /// any of the style's attributes are already defined in the theme, the
  /// current values in the theme will be overwritten.
  ///@param resId The resource ID of a style resource from which to
  ///              obtain attribute values.
  ///@param force If true, values in the style resource will always be
  ///              used in the theme; otherwise, they will only be used
  ///              if not already defined in the theme.
  void applyStyle(int resId, bool force) =>
      _applyStyle(reference, resId, force ? 1 : 0).check();

  static final _setTo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Resources_Theme__setTo")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTo(android.content.res.Resources.Theme other)
  ///
  /// Set this theme to hold the same contents as the theme
  /// <var>other</var>.  If both of these themes are from the same
  /// Resources object, they will be identical after this function
  /// returns.  If they are from different Resources, only the resources
  /// they have in common will be set in this theme.
  ///@param other The existing Theme to copy from.
  void setTo(Resources_Theme other) =>
      _setTo(reference, other.reference).check();

  static final _obtainStyledAttributes = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Resources_Theme__obtainStyledAttributes")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.TypedArray obtainStyledAttributes(int[] attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a TypedArray holding the values defined by
  /// <var>Theme</var> which are listed in <var>attrs</var>.
  ///
  /// Be sure to call TypedArray\#recycle() TypedArray.recycle() when you are done
  /// with the array.
  ///@param attrs The desired attributes. These attribute IDs must be sorted in ascending
  ///              order.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return Returns a TypedArray holding an array of the attribute values.
  /// Be sure to call TypedArray\#recycle() TypedArray.recycle()
  /// when done with it.
  ///@see Resources\#obtainAttributes
  ///@see \#obtainStyledAttributes(int, int[])
  ///@see \#obtainStyledAttributes(AttributeSet, int[], int, int)
  TypedArray obtainStyledAttributes(jni.JniObject attrs) => TypedArray.fromRef(
      _obtainStyledAttributes(reference, attrs.reference).object);

  static final _obtainStyledAttributes1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "Resources_Theme__obtainStyledAttributes1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.TypedArray obtainStyledAttributes(int resId, int[] attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a TypedArray holding the values defined by the style
  /// resource <var>resid</var> which are listed in <var>attrs</var>.
  ///
  /// Be sure to call TypedArray\#recycle() TypedArray.recycle() when you are done
  /// with the array.
  ///@param resId The desired style resource.
  ///@param attrs The desired attributes in the style. These attribute IDs must be sorted in
  ///              ascending order.
  ///@throws NotFoundException Throws NotFoundException if the given ID does not exist.
  ///@return Returns a TypedArray holding an array of the attribute values.
  /// Be sure to call TypedArray\#recycle() TypedArray.recycle()
  /// when done with it.
  ///@see Resources\#obtainAttributes
  ///@see \#obtainStyledAttributes(int[])
  ///@see \#obtainStyledAttributes(AttributeSet, int[], int, int)
  TypedArray obtainStyledAttributes1(int resId, jni.JniObject attrs) =>
      TypedArray.fromRef(
          _obtainStyledAttributes1(reference, resId, attrs.reference).object);

  static final _obtainStyledAttributes2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32)>>("Resources_Theme__obtainStyledAttributes2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.content.res.TypedArray obtainStyledAttributes(android.util.AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a TypedArray holding the attribute values in
  /// <var>set</var>
  /// that are listed in <var>attrs</var>.  In addition, if the given
  /// AttributeSet specifies a style class (through the "style" attribute),
  /// that style will be applied on top of the base attributes it defines.
  ///
  /// Be sure to call TypedArray\#recycle() TypedArray.recycle() when you are done
  /// with the array.
  ///
  /// When determining the final value of a particular attribute, there
  /// are four inputs that come into play:
  ///
  ///
  /// <ol>
  ///     <li> Any attribute values in the given AttributeSet.
  ///     <li> The style resource specified in the AttributeSet (named
  ///     "style").
  ///     <li> The default style specified by <var>defStyleAttr</var> and
  ///     <var>defStyleRes</var>
  ///     <li> The base values in this theme.
  /// </ol>
  ///
  /// Each of these inputs is considered in-order, with the first listed
  /// taking precedence over the following ones.  In other words, if in the
  /// AttributeSet you have supplied <code>&lt;Button
  /// textColor="\#ff000000"&gt;</code>, then the button's text will
  /// _always_ be black, regardless of what is specified in any of
  /// the styles.
  ///@param set The base set of attribute values.  May be null.
  ///@param attrs The desired attributes to be retrieved. These attribute IDs must be sorted
  ///              in ascending order.
  ///@param defStyleAttr An attribute in the current theme that contains a
  ///                     reference to a style resource that supplies
  ///                     defaults values for the TypedArray.  Can be
  ///                     0 to not look for defaults.
  ///@param defStyleRes A resource identifier of a style resource that
  ///                    supplies default values for the TypedArray,
  ///                    used only if defStyleAttr is 0 or can not be found
  ///                    in the theme.  Can be 0 to not look for defaults.
  ///@return Returns a TypedArray holding an array of the attribute values.
  /// Be sure to call TypedArray\#recycle() TypedArray.recycle()
  /// when done with it.
  ///@see Resources\#obtainAttributes
  ///@see \#obtainStyledAttributes(int[])
  ///@see \#obtainStyledAttributes(int, int[])
  TypedArray obtainStyledAttributes2(jni.JniObject set0, jni.JniObject attrs,
          int defStyleAttr, int defStyleRes) =>
      TypedArray.fromRef(_obtainStyledAttributes2(reference, set0.reference,
              attrs.reference, defStyleAttr, defStyleRes)
          .object);

  static final _resolveAttribute = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Resources_Theme__resolveAttribute")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean resolveAttribute(int resid, android.util.TypedValue outValue, boolean resolveRefs)
  ///
  /// Retrieve the value of an attribute in the Theme.  The contents of
  /// <var>outValue</var> are ultimately filled in by
  /// Resources\#getValue.
  ///@param resid The resource identifier of the desired theme
  ///              attribute.
  ///@param outValue Filled in with the ultimate resource value supplied
  ///                 by the attribute.
  ///@param resolveRefs If true, resource references will be walked; if
  ///                    false, <var>outValue</var> may be a
  ///                    TYPE_REFERENCE.  In either case, it will never
  ///                    be a TYPE_ATTRIBUTE.
  ///@return boolean Returns true if the attribute was found and
  ///         <var>outValue</var> is valid, else false.
  bool resolveAttribute(int resid, jni.JniObject outValue, bool resolveRefs) =>
      _resolveAttribute(
              reference, resid, outValue.reference, resolveRefs ? 1 : 0)
          .boolean;

  static final _getResources = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Resources_Theme__getResources")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.Resources getResources()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the resources to which this theme belongs.
  ///@return Resources to which this theme belongs.
  Resources getResources() =>
      Resources.fromRef(_getResources(reference).object);

  static final _getDrawable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Resources_Theme__getDrawable")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.drawable.Drawable getDrawable(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a drawable object associated with a particular resource ID
  /// and styled for the Theme.
  ///@param id The desired resource identifier, as generated by the aapt
  ///           tool. This integer encodes the package, type, and resource
  ///           entry. The value 0 is an invalid identifier.
  ///@return Drawable An object that can be used to draw this resource.
  ///@throws NotFoundException Throws NotFoundException if the given ID
  ///         does not exist.
  jni.JniObject getDrawable(int id) =>
      jni.JniObject.fromRef(_getDrawable(reference, id).object);

  static final _getChangingConfigurations = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Resources_Theme__getChangingConfigurations")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getChangingConfigurations()
  ///
  /// Returns a bit mask of configuration changes that will impact this
  /// theme (and thus require completely reloading it).
  ///@return a bit mask of configuration changes, as defined by
  ///         ActivityInfo
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  ///@see ActivityInfo
  int getChangingConfigurations() =>
      _getChangingConfigurations(reference).integer;

  static final _dump = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Resources_Theme__dump")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(int priority, java.lang.String tag, java.lang.String prefix)
  ///
  /// Print contents of this theme out to the log.  For debugging only.
  ///@param priority The log priority to use.
  ///@param tag The log tag to use.
  ///@param prefix Text to prefix each line printed.
  void dump(int priority, jni.JniString tag, jni.JniString prefix) =>
      _dump(reference, priority, tag.reference, prefix.reference).check();
}

/// from: android.content.res.Resources$NotFoundException
///
/// This exception is thrown by the resource APIs when a requested resource
/// can not be found.
class Resources_NotFoundException extends jni.JniObject {
  Resources_NotFoundException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Resources_NotFoundException__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  Resources_NotFoundException() : super.fromRef(_ctor().object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Resources_NotFoundException__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String name)
  Resources_NotFoundException.ctor1(jni.JniString name)
      : super.fromRef(_ctor1(name.reference).object);

  static final _ctor2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Resources_NotFoundException__ctor2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String name, java.lang.Exception cause)
  Resources_NotFoundException.ctor2(jni.JniString name, jni.JniObject cause)
      : super.fromRef(_ctor2(name.reference, cause.reference).object);
}

/// from: android.content.res.TypedArray
///
/// Container for an array of values that were retrieved with
/// Resources.Theme\#obtainStyledAttributes(AttributeSet, int[], int, int)
/// or Resources\#obtainAttributes.  Be
/// sure to call \#recycle when done with them.
///
/// The indices used to retrieve values from this structure correspond to
/// the positions of the attributes given to obtainStyledAttributes.
class TypedArray extends jni.JniObject {
  TypedArray.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("TypedArray__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.content.res.Resources resources)
  ///
  /// @hide
  TypedArray(Resources resources)
      : super.fromRef(_ctor(resources.reference).object);

  static final _length = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("TypedArray__length")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int length()
  ///
  /// Returns the number of values in this array.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  int length() => _length(reference).integer;

  static final _getIndexCount = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("TypedArray__getIndexCount")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getIndexCount()
  ///
  /// Returns the number of indices in the array that actually have data. Attributes with a value
  /// of @empty are included, as this is an explicit indicator.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  int getIndexCount() => _getIndexCount(reference).integer;

  static final _getIndex = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("TypedArray__getIndex")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getIndex(int at)
  ///
  /// Returns an index in the array that has data. Attributes with a value of @empty are included,
  /// as this is an explicit indicator.
  ///@param at The index you would like to returned, ranging from 0 to
  ///           \#getIndexCount().
  ///@return The index at the given offset, which can be used with
  ///         \#getValue and related APIs.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  int getIndex(int at) => _getIndex(reference, at).integer;

  static final _getResources = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("TypedArray__getResources")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.Resources getResources()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Resources object this array was loaded from.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  Resources getResources() =>
      Resources.fromRef(_getResources(reference).object);

  static final _getText = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("TypedArray__getText")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.CharSequence getText(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the styled string value for the attribute at <var>index</var>.
  ///
  /// If the attribute is not a string, this method will attempt to coerce
  /// it to a string.
  ///@param index Index of attribute to retrieve.
  ///@return CharSequence holding string data. May be styled. Returns
  ///         {@code null} if the attribute is not defined or could not be
  ///         coerced to a string.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  jni.JniObject getText(int index) =>
      jni.JniObject.fromRef(_getText(reference, index).object);

  static final _getString = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("TypedArray__getString")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getString(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the string value for the attribute at <var>index</var>.
  ///
  /// If the attribute is not a string, this method will attempt to coerce
  /// it to a string.
  ///@param index Index of attribute to retrieve.
  ///@return String holding string data. Any styling information is removed.
  ///         Returns {@code null} if the attribute is not defined or could
  ///         not be coerced to a string.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  jni.JniString getString(int index) =>
      jni.JniString.fromRef(_getString(reference, index).object);

  static final _getNonResourceString = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("TypedArray__getNonResourceString")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getNonResourceString(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves the string value for the attribute at <var>index</var>, but
  /// only if that string comes from an immediate value in an XML file.  That
  /// is, this does not allow references to string resources, string
  /// attributes, or conversions from other types.  As such, this method
  /// will only return strings for TypedArray objects that come from
  /// attributes in an XML file.
  ///@param index Index of attribute to retrieve.
  ///@return String holding string data. Any styling information is removed.
  ///         Returns {@code null} if the attribute is not defined or is not
  ///         an immediate string value.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  jni.JniString getNonResourceString(int index) =>
      jni.JniString.fromRef(_getNonResourceString(reference, index).object);

  static final _getBoolean = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Uint8)>>("TypedArray__getBoolean")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public boolean getBoolean(int index, boolean defValue)
  ///
  /// Retrieve the boolean value for the attribute at <var>index</var>.
  ///
  /// If the attribute is an integer value, this method will return whether
  /// it is equal to zero. If the attribute is not a boolean or integer value,
  /// this method will attempt to coerce it to an integer using
  /// Integer\#decode(String) and return whether it is equal to zero.
  ///@param index Index of attribute to retrieve.
  ///@param defValue Value to return if the attribute is not defined or
  ///                 cannot be coerced to an integer.
  ///@return Boolean value of the attribute, or defValue if the attribute was
  ///         not defined or could not be coerced to an integer.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  bool getBoolean(int index, bool defValue) =>
      _getBoolean(reference, index, defValue ? 1 : 0).boolean;

  static final _getInt = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("TypedArray__getInt")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int getInt(int index, int defValue)
  ///
  /// Retrieve the integer value for the attribute at <var>index</var>.
  ///
  /// If the attribute is not an integer, this method will attempt to coerce
  /// it to an integer using Integer\#decode(String).
  ///@param index Index of attribute to retrieve.
  ///@param defValue Value to return if the attribute is not defined or
  ///                 cannot be coerced to an integer.
  ///@return Integer value of the attribute, or defValue if the attribute was
  ///         not defined or could not be coerced to an integer.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  int getInt(int index, int defValue) =>
      _getInt(reference, index, defValue).integer;

  static final _getFloat = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Float)>>("TypedArray__getFloat")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, double)>();

  /// from: public float getFloat(int index, float defValue)
  ///
  /// Retrieve the float value for the attribute at <var>index</var>.
  ///
  /// If the attribute is not a float or an integer, this method will attempt
  /// to coerce it to a float using Float\#parseFloat(String).
  ///@param index Index of attribute to retrieve.
  ///@return Attribute float value, or defValue if the attribute was
  ///         not defined or could not be coerced to a float.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  double getFloat(int index, double defValue) =>
      _getFloat(reference, index, defValue).float;

  static final _getColor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("TypedArray__getColor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int getColor(int index, int defValue)
  ///
  /// Retrieve the color value for the attribute at <var>index</var>.  If
  /// the attribute references a color resource holding a complex
  /// android.content.res.ColorStateList, then the default color from
  /// the set is returned.
  ///
  /// This method will throw an exception if the attribute is defined but is
  /// not an integer color or color state list.
  ///@param index Index of attribute to retrieve.
  ///@param defValue Value to return if the attribute is not defined or
  ///                 not a resource.
  ///@return Attribute color value, or defValue if not defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not an integer color or color state list.
  int getColor(int index, int defValue) =>
      _getColor(reference, index, defValue).integer;

  static final _getColorStateList = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("TypedArray__getColorStateList")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.res.ColorStateList getColorStateList(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the ColorStateList for the attribute at <var>index</var>.
  /// The value may be either a single solid color or a reference to
  /// a color or complex android.content.res.ColorStateList
  /// description.
  ///
  /// This method will return {@code null} if the attribute is not defined or
  /// is not an integer color or color state list.
  ///@param index Index of attribute to retrieve.
  ///@return ColorStateList for the attribute, or {@code null} if not
  ///         defined.
  ///@throws RuntimeException if the attribute if the TypedArray has already
  ///         been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not an integer color or color state list.
  ColorStateList getColorStateList(int index) =>
      ColorStateList.fromRef(_getColorStateList(reference, index).object);

  static final _getInteger = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("TypedArray__getInteger")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int getInteger(int index, int defValue)
  ///
  /// Retrieve the integer value for the attribute at <var>index</var>.
  ///
  /// Unlike \#getInt(int, int), this method will throw an exception if
  /// the attribute is defined but is not an integer.
  ///@param index Index of attribute to retrieve.
  ///@param defValue Value to return if the attribute is not defined or
  ///                 not a resource.
  ///@return Attribute integer value, or defValue if not defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not an integer.
  int getInteger(int index, int defValue) =>
      _getInteger(reference, index, defValue).integer;

  static final _getDimension = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Float)>>("TypedArray__getDimension")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, double)>();

  /// from: public float getDimension(int index, float defValue)
  ///
  /// Retrieve a dimensional unit attribute at <var>index</var>. Unit
  /// conversions are based on the current DisplayMetrics
  /// associated with the resources this TypedArray object
  /// came from.
  ///
  /// This method will throw an exception if the attribute is defined but is
  /// not a dimension.
  ///@param index Index of attribute to retrieve.
  ///@param defValue Value to return if the attribute is not defined or
  ///                 not a resource.
  ///@return Attribute dimension value multiplied by the appropriate
  ///         metric, or defValue if not defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not an integer.
  ///@see \#getDimensionPixelOffset
  ///@see \#getDimensionPixelSize
  double getDimension(int index, double defValue) =>
      _getDimension(reference, index, defValue).float;

  static final _getDimensionPixelOffset = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("TypedArray__getDimensionPixelOffset")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int getDimensionPixelOffset(int index, int defValue)
  ///
  /// Retrieve a dimensional unit attribute at <var>index</var> for use
  /// as an offset in raw pixels.  This is the same as
  /// \#getDimension, except the returned value is converted to
  /// integer pixels for you.  An offset conversion involves simply
  /// truncating the base value to an integer.
  ///
  /// This method will throw an exception if the attribute is defined but is
  /// not a dimension.
  ///@param index Index of attribute to retrieve.
  ///@param defValue Value to return if the attribute is not defined or
  ///                 not a resource.
  ///@return Attribute dimension value multiplied by the appropriate
  ///         metric and truncated to integer pixels, or defValue if not defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not an integer.
  ///@see \#getDimension
  ///@see \#getDimensionPixelSize
  int getDimensionPixelOffset(int index, int defValue) =>
      _getDimensionPixelOffset(reference, index, defValue).integer;

  static final _getDimensionPixelSize = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("TypedArray__getDimensionPixelSize")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int getDimensionPixelSize(int index, int defValue)
  ///
  /// Retrieve a dimensional unit attribute at <var>index</var> for use
  /// as a size in raw pixels.  This is the same as
  /// \#getDimension, except the returned value is converted to
  /// integer pixels for use as a size.  A size conversion involves
  /// rounding the base value, and ensuring that a non-zero base value
  /// is at least one pixel in size.
  ///
  /// This method will throw an exception if the attribute is defined but is
  /// not a dimension.
  ///@param index Index of attribute to retrieve.
  ///@param defValue Value to return if the attribute is not defined or
  ///                 not a resource.
  ///@return Attribute dimension value multiplied by the appropriate
  ///         metric and truncated to integer pixels, or defValue if not defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not a dimension.
  ///@see \#getDimension
  ///@see \#getDimensionPixelOffset
  int getDimensionPixelSize(int index, int defValue) =>
      _getDimensionPixelSize(reference, index, defValue).integer;

  static final _getLayoutDimension = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("TypedArray__getLayoutDimension")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public int getLayoutDimension(int index, java.lang.String name)
  ///
  /// Special version of \#getDimensionPixelSize for retrieving
  /// android.view.ViewGroup's layout_width and layout_height
  /// attributes.  This is only here for performance reasons; applications
  /// should use \#getDimensionPixelSize.
  ///
  /// This method will throw an exception if the attribute is defined but is
  /// not a dimension or integer (enum).
  ///@param index Index of the attribute to retrieve.
  ///@param name Textual name of attribute for error reporting.
  ///@return Attribute dimension value multiplied by the appropriate
  ///         metric and truncated to integer pixels.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not a dimension or integer (enum).
  int getLayoutDimension(int index, jni.JniString name) =>
      _getLayoutDimension(reference, index, name.reference).integer;

  static final _getLayoutDimension1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("TypedArray__getLayoutDimension1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int getLayoutDimension(int index, int defValue)
  ///
  /// Special version of \#getDimensionPixelSize for retrieving
  /// android.view.ViewGroup's layout_width and layout_height
  /// attributes.  This is only here for performance reasons; applications
  /// should use \#getDimensionPixelSize.
  ///@param index Index of the attribute to retrieve.
  ///@param defValue The default value to return if this attribute is not
  ///                 default or contains the wrong type of data.
  ///@return Attribute dimension value multiplied by the appropriate
  ///         metric and truncated to integer pixels.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  int getLayoutDimension1(int index, int defValue) =>
      _getLayoutDimension1(reference, index, defValue).integer;

  static final _getFraction = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32, ffi.Float)>>("TypedArray__getFraction")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, int, double)>();

  /// from: public float getFraction(int index, int base, int pbase, float defValue)
  ///
  /// Retrieves a fractional unit attribute at <var>index</var>.
  ///@param index Index of attribute to retrieve.
  ///@param base The base value of this fraction.  In other words, a
  ///             standard fraction is multiplied by this value.
  ///@param pbase The parent base value of this fraction.  In other
  ///             words, a parent fraction (nn%p) is multiplied by this
  ///             value.
  ///@param defValue Value to return if the attribute is not defined or
  ///                 not a resource.
  ///@return Attribute fractional value multiplied by the appropriate
  ///         base value, or defValue if not defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not a fraction.
  double getFraction(int index, int base, int pbase, double defValue) =>
      _getFraction(reference, index, base, pbase, defValue).float;

  static final _getResourceId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("TypedArray__getResourceId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int getResourceId(int index, int defValue)
  ///
  /// Retrieves the resource identifier for the attribute at
  /// <var>index</var>.  Note that attribute resource as resolved when
  /// the overall TypedArray object is retrieved.  As a
  /// result, this function will return the resource identifier of the
  /// final resource value that was found, _not_ necessarily the
  /// original resource that was specified by the attribute.
  ///@param index Index of attribute to retrieve.
  ///@param defValue Value to return if the attribute is not defined or
  ///                 not a resource.
  ///@return Attribute resource identifier, or defValue if not defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  int getResourceId(int index, int defValue) =>
      _getResourceId(reference, index, defValue).integer;

  static final _getDrawable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("TypedArray__getDrawable")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.drawable.Drawable getDrawable(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the Drawable for the attribute at <var>index</var>.
  ///
  /// This method will throw an exception if the attribute is defined but is
  /// not a color or drawable resource.
  ///@param index Index of attribute to retrieve.
  ///@return Drawable for the attribute, or {@code null} if not defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not a color or drawable resource.
  jni.JniObject getDrawable(int index) =>
      jni.JniObject.fromRef(_getDrawable(reference, index).object);

  static final _getFont = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("TypedArray__getFont")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.Typeface getFont(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the Typeface for the attribute at <var>index</var>.
  ///
  /// This method will throw an exception if the attribute is defined but is
  /// not a font.
  ///@param index Index of attribute to retrieve.
  ///@return Typeface for the attribute, or {@code null} if not defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@throws UnsupportedOperationException if the attribute is defined but is
  ///         not a font resource.
  jni.JniObject getFont(int index) =>
      jni.JniObject.fromRef(_getFont(reference, index).object);

  static final _getTextArray = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("TypedArray__getTextArray")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.CharSequence[] getTextArray(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the CharSequence[] for the attribute at <var>index</var>.
  /// This gets the resource ID of the selected attribute, and uses
  /// Resources\#getTextArray Resources.getTextArray of the owning
  /// Resources object to retrieve its String[].
  ///
  /// This method will throw an exception if the attribute is defined but is
  /// not a text array resource.
  ///@param index Index of attribute to retrieve.
  ///@return CharSequence[] for the attribute, or {@code null} if not
  ///         defined.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  jni.JniObject getTextArray(int index) =>
      jni.JniObject.fromRef(_getTextArray(reference, index).object);

  static final _getValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("TypedArray__getValue")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getValue(int index, android.util.TypedValue outValue)
  ///
  /// Retrieve the raw TypedValue for the attribute at <var>index</var>.
  ///@param index Index of attribute to retrieve.
  ///@param outValue TypedValue object in which to place the attribute's
  ///                 data.
  ///@return {@code true} if the value was retrieved and not @empty, {@code false} otherwise.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  bool getValue(int index, jni.JniObject outValue) =>
      _getValue(reference, index, outValue.reference).boolean;

  static final _getType = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("TypedArray__getType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getType(int index)
  ///
  /// Returns the type of attribute at the specified index.
  ///@param index Index of attribute whose type to retrieve.
  ///@return Attribute type.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  int getType(int index) => _getType(reference, index).integer;

  static final _hasValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("TypedArray__hasValue")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean hasValue(int index)
  ///
  /// Determines whether there is an attribute at <var>index</var>.
  ///
  /// <strong>Note:</strong> If the attribute was set to {@code @empty} or
  /// {@code @undefined}, this method returns {@code false}.
  ///@param index Index of attribute to retrieve.
  ///@return True if the attribute has a value, false otherwise.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  bool hasValue(int index) => _hasValue(reference, index).boolean;

  static final _hasValueOrEmpty = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("TypedArray__hasValueOrEmpty")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean hasValueOrEmpty(int index)
  ///
  /// Determines whether there is an attribute at <var>index</var>, returning
  /// {@code true} if the attribute was explicitly set to {@code @empty} and
  /// {@code false} only if the attribute was undefined.
  ///@param index Index of attribute to retrieve.
  ///@return True if the attribute has a value or is empty, false otherwise.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  bool hasValueOrEmpty(int index) => _hasValueOrEmpty(reference, index).boolean;

  static final _peekValue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("TypedArray__peekValue")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.util.TypedValue peekValue(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the raw TypedValue for the attribute at <var>index</var>
  /// and return a temporary object holding its data.  This object is only
  /// valid until the next call on to TypedArray.
  ///@param index Index of attribute to retrieve.
  ///@return Returns a TypedValue object if the attribute is defined,
  ///         containing its data; otherwise returns null.  (You will not
  ///         receive a TypedValue whose type is TYPE_NULL.)
  ///@throws RuntimeException if the TypedArray has already been recycled.
  jni.JniObject peekValue(int index) =>
      jni.JniObject.fromRef(_peekValue(reference, index).object);

  static final _getPositionDescription = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("TypedArray__getPositionDescription")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPositionDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a message about the parser state suitable for printing error messages.
  ///@return Human-readable description of current parser state.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  jni.JniString getPositionDescription() =>
      jni.JniString.fromRef(_getPositionDescription(reference).object);

  static final _recycle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("TypedArray__recycle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void recycle()
  ///
  /// Recycles the TypedArray, to be re-used by a later caller. After calling
  /// this function you must not ever touch the typed array again.
  ///@throws RuntimeException if the TypedArray has already been recycled.
  void recycle() => _recycle(reference).check();

  static final _getChangingConfigurations = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "TypedArray__getChangingConfigurations")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getChangingConfigurations()
  ///
  /// Return a mask of the configuration parameters for which the values in
  /// this typed array may change.
  ///@return Returns a mask of the changing configuration parameters, as
  ///         defined by android.content.pm.ActivityInfo.
  /// Value is either <code>0</code> or a combination of android.content.pm.ActivityInfo\#CONFIG_MCC, android.content.pm.ActivityInfo\#CONFIG_MNC, android.content.pm.ActivityInfo\#CONFIG_LOCALE, android.content.pm.ActivityInfo\#CONFIG_TOUCHSCREEN, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD, android.content.pm.ActivityInfo\#CONFIG_KEYBOARD_HIDDEN, android.content.pm.ActivityInfo\#CONFIG_NAVIGATION, android.content.pm.ActivityInfo\#CONFIG_ORIENTATION, android.content.pm.ActivityInfo\#CONFIG_SCREEN_LAYOUT, android.content.pm.ActivityInfo\#CONFIG_UI_MODE, android.content.pm.ActivityInfo\#CONFIG_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_SMALLEST_SCREEN_SIZE, android.content.pm.ActivityInfo\#CONFIG_DENSITY, android.content.pm.ActivityInfo\#CONFIG_LAYOUT_DIRECTION, android.content.pm.ActivityInfo\#CONFIG_COLOR_MODE, and android.content.pm.ActivityInfo\#CONFIG_FONT_SCALE
  ///@throws RuntimeException if the TypedArray has already been recycled.
  ///@see android.content.pm.ActivityInfo
  int getChangingConfigurations() =>
      _getChangingConfigurations(reference).integer;

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("TypedArray__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);
}

/// from: android.content.res.XmlResourceParser
///
/// The XML parsing interface returned for an XML resource.  This is a standard
/// XmlPullParser interface but also extends AttributeSet and
/// adds an additional \#close() method for the client to indicate when
/// it is done reading the resource.
class XmlResourceParser extends jni.JniObject {
  XmlResourceParser.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _getAttributeNamespace = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("XmlResourceParser__getAttributeNamespace")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract java.lang.String getAttributeNamespace(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getAttributeNamespace(int index) =>
      jni.JniString.fromRef(_getAttributeNamespace(reference, index).object);

  static final _close = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("XmlResourceParser__close")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void close()
  ///
  /// Close this parser. Calls on the interface are no longer valid after this call.
  void close() => _close(reference).check();
}
