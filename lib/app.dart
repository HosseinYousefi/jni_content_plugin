// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_element

import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "content.dart" as content_;

import "os.dart" as os_;

import "app/assist.dart" as assist_;

import "content/res.dart" as res_;

import "content/pm.dart" as pm_;
import "_init.dart" show jniLookup;

/// from: android.app.ActionBar
///
/// A primary toolbar within the activity that may display the activity title, application-level
/// navigation affordances, and other interactive items.
///
/// Beginning with Android 3.0 (API level 11), the action bar appears at the top of an
/// activity's window when the activity uses the system's android.R.style\#Theme_Holo Holo theme (or one of its descendant themes), which is the default.
/// You may otherwise add the action bar by calling android.view.Window\#requestFeature requestFeature(FEATURE_ACTION_BAR) or by declaring it in a
/// custom theme with the android.R.styleable\#Theme_windowActionBar windowActionBar property.
///
///
///
/// Beginning with Android L (API level 21), the action bar may be represented by any
/// Toolbar widget within the application layout. The application may signal to the Activity
/// which Toolbar should be treated as the Activity's action bar. Activities that use this
/// feature should use one of the supplied <code>.NoActionBar</code> themes, set the
/// android.R.styleable\#Theme_windowActionBar windowActionBar attribute to <code>false</code>
/// or otherwise not request the window feature.
///
///
/// By adjusting the window features requested by the theme and the layouts used for
/// an Activity's content view, an app can use the standard system action bar on older platform
/// releases and the newer inline toolbars on newer platform releases. The <code>ActionBar</code>
/// object obtained from the Activity can be used to control either configuration transparently.
///
///
/// When using the Holo themes the action bar shows the application icon on
/// the left, followed by the activity title. If your activity has an options menu, you can make
/// select items accessible directly from the action bar as "action items". You can also
/// modify various characteristics of the action bar or remove it completely.
///
///
/// When using the Material themes (default in API 21 or newer) the navigation button
/// (formerly "Home") takes over the space previously occupied by the application icon.
/// Apps wishing to express a stronger branding should use their brand colors heavily
/// in the action bar and other application chrome or use a \#setLogo(int) logo
/// in place of their standard title text.
///
///
/// From your activity, you can retrieve an instance of ActionBar by calling android.app.Activity\#getActionBar getActionBar().
///
///
/// In some cases, the action bar may be overlayed by another bar that enables contextual actions,
/// using an android.view.ActionMode. For example, when the user selects one or more items in
/// your activity, you can enable an action mode that offers actions specific to the selected
/// items, with a UI that temporarily replaces the action bar. Although the UI may occupy the
/// same space, the android.view.ActionMode APIs are distinct and independent from those for
/// ActionBar.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For information about how to use the action bar, including how to add action items, navigation
/// modes and more, read the <a href="{@docRoot}guide/topics/ui/actionbar.html">Action
/// Bar</a> developer guide.
///
/// </div>
class ActionBar extends jni.JniObject {
  ActionBar.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int DISPLAY_HOME_AS_UP
  ///
  /// Display the 'home' element such that it appears as an 'up' affordance.
  /// e.g. show an arrow to the left indicating the action that will be taken.
  ///
  /// Set this flag if selecting the 'home' button in the action bar to return
  /// up by a single level in your UI rather than back to the top level or front page.
  ///
  /// Setting this option will implicitly enable interaction with the home/up
  /// button. See \#setHomeButtonEnabled(boolean).
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  static const DISPLAY_HOME_AS_UP = 4;

  /// from: static public final int DISPLAY_SHOW_CUSTOM
  ///
  /// Show the custom view if one has been set.
  ///@see \#setCustomView(View)
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  static const DISPLAY_SHOW_CUSTOM = 16;

  /// from: static public final int DISPLAY_SHOW_HOME
  ///
  /// Show 'home' elements in this action bar, leaving more space for other
  /// navigation elements. This includes logo and icon.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  static const DISPLAY_SHOW_HOME = 2;

  /// from: static public final int DISPLAY_SHOW_TITLE
  ///
  /// Show the activity title and subtitle, if present.
  ///@see \#setTitle(CharSequence)
  ///@see \#setTitle(int)
  ///@see \#setSubtitle(CharSequence)
  ///@see \#setSubtitle(int)
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  static const DISPLAY_SHOW_TITLE = 8;

  /// from: static public final int DISPLAY_USE_LOGO
  ///
  /// Use logo instead of icon if available. This flag will cause appropriate
  /// navigation modes to use a wider logo in place of the standard icon.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  static const DISPLAY_USE_LOGO = 1;

  /// from: static public final int NAVIGATION_MODE_LIST
  ///
  /// List navigation mode. Instead of static title text this mode
  /// presents a list menu for navigation within the activity.
  /// e.g. this might be presented to the user as a dropdown list.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  static const NAVIGATION_MODE_LIST = 1;

  /// from: static public final int NAVIGATION_MODE_STANDARD
  ///
  /// Standard navigation mode. Consists of either a logo or icon
  /// and title text with an optional subtitle. Clicking any of these elements
  /// will dispatch onOptionsItemSelected to the host Activity with
  /// a MenuItem with item ID android.R.id.home.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  static const NAVIGATION_MODE_STANDARD = 0;

  /// from: static public final int NAVIGATION_MODE_TABS
  ///
  /// Tab navigation mode. Instead of static title text this mode
  /// presents a series of tabs for navigation within the activity.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  static const NAVIGATION_MODE_TABS = 2;

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("ActionBar__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ActionBar() : super.fromRef(_ctor().object);

  static final _setCustomView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActionBar__setCustomView")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setCustomView(android.view.View view)
  ///
  /// Set the action bar into custom navigation mode, supplying a view
  /// for custom navigation.
  ///
  /// Custom navigation views appear between the application icon and
  /// any action buttons and may use any space available there. Common
  /// use cases for custom navigation views might include an auto-suggesting
  /// address bar for a browser or other navigation mechanisms that do not
  /// translate well to provided navigation modes.
  ///@param view Custom navigation view to place in the ActionBar.
  void setCustomView(jni.JniObject view) =>
      _setCustomView(reference, view.reference).check();

  static final _setCustomView1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActionBar__setCustomView1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setCustomView(android.view.View view, android.app.ActionBar.LayoutParams layoutParams)
  ///
  /// Set the action bar into custom navigation mode, supplying a view
  /// for custom navigation.
  ///
  /// Custom navigation views appear between the application icon and
  /// any action buttons and may use any space available there. Common
  /// use cases for custom navigation views might include an auto-suggesting
  /// address bar for a browser or other navigation mechanisms that do not
  /// translate well to provided navigation modes.
  ///
  ///
  /// The display option \#DISPLAY_SHOW_CUSTOM must be set for
  /// the custom view to be displayed.
  ///
  ///@param view Custom navigation view to place in the ActionBar.
  ///@param layoutParams How this custom view should layout in the bar.
  ///@see \#setDisplayOptions(int, int)
  void setCustomView1(
          jni.JniObject view, ActionBar_LayoutParams layoutParams) =>
      _setCustomView1(reference, view.reference, layoutParams.reference)
          .check();

  static final _setCustomView2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ActionBar__setCustomView2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setCustomView(int resId)
  ///
  /// Set the action bar into custom navigation mode, supplying a view
  /// for custom navigation.
  ///
  /// Custom navigation views appear between the application icon and
  /// any action buttons and may use any space available there. Common
  /// use cases for custom navigation views might include an auto-suggesting
  /// address bar for a browser or other navigation mechanisms that do not
  /// translate well to provided navigation modes.
  ///
  ///
  /// The display option \#DISPLAY_SHOW_CUSTOM must be set for
  /// the custom view to be displayed.
  ///
  ///@param resId Resource ID of a layout to inflate into the ActionBar.
  ///@see \#setDisplayOptions(int, int)
  void setCustomView2(int resId) => _setCustomView2(reference, resId).check();

  static final _setIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("ActionBar__setIcon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setIcon(int resId)
  ///
  /// Set the icon to display in the 'home' section of the action bar.
  /// The action bar will use an icon specified by its style or the
  /// activity icon by default.
  ///
  /// Whether the home section shows an icon or logo is controlled
  /// by the display option \#DISPLAY_USE_LOGO.
  ///@param resId Resource ID of a drawable to show as an icon.
  ///@see \#setDisplayUseLogoEnabled(boolean)
  ///@see \#setDisplayShowHomeEnabled(boolean)
  void setIcon(int resId) => _setIcon(reference, resId).check();

  static final _setIcon1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActionBar__setIcon1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setIcon(android.graphics.drawable.Drawable icon)
  ///
  /// Set the icon to display in the 'home' section of the action bar.
  /// The action bar will use an icon specified by its style or the
  /// activity icon by default.
  ///
  /// Whether the home section shows an icon or logo is controlled
  /// by the display option \#DISPLAY_USE_LOGO.
  ///@param icon Drawable to show as an icon.
  ///@see \#setDisplayUseLogoEnabled(boolean)
  ///@see \#setDisplayShowHomeEnabled(boolean)
  void setIcon1(jni.JniObject icon) =>
      _setIcon1(reference, icon.reference).check();

  static final _setLogo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("ActionBar__setLogo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setLogo(int resId)
  ///
  /// Set the logo to display in the 'home' section of the action bar.
  /// The action bar will use a logo specified by its style or the
  /// activity logo by default.
  ///
  /// Whether the home section shows an icon or logo is controlled
  /// by the display option \#DISPLAY_USE_LOGO.
  ///@param resId Resource ID of a drawable to show as a logo.
  ///@see \#setDisplayUseLogoEnabled(boolean)
  ///@see \#setDisplayShowHomeEnabled(boolean)
  void setLogo(int resId) => _setLogo(reference, resId).check();

  static final _setLogo1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActionBar__setLogo1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setLogo(android.graphics.drawable.Drawable logo)
  ///
  /// Set the logo to display in the 'home' section of the action bar.
  /// The action bar will use a logo specified by its style or the
  /// activity logo by default.
  ///
  /// Whether the home section shows an icon or logo is controlled
  /// by the display option \#DISPLAY_USE_LOGO.
  ///@param logo Drawable to show as a logo.
  ///@see \#setDisplayUseLogoEnabled(boolean)
  ///@see \#setDisplayShowHomeEnabled(boolean)
  void setLogo1(jni.JniObject logo) =>
      _setLogo1(reference, logo.reference).check();

  static final _setListNavigationCallbacks = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActionBar__setListNavigationCallbacks")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setListNavigationCallbacks(android.widget.SpinnerAdapter adapter, android.app.ActionBar.OnNavigationListener callback)
  ///
  /// Set the adapter and navigation callback for list navigation mode.
  ///
  /// The supplied adapter will provide views for the expanded list as well as
  /// the currently selected item. (These may be displayed differently.)
  ///
  /// The supplied OnNavigationListener will alert the application when the user
  /// changes the current list selection.
  ///@param adapter An adapter that will provide views both to display
  ///                the current navigation selection and populate views
  ///                within the dropdown navigation menu.
  ///@param callback An OnNavigationListener that will receive events when the user
  ///                 selects a navigation item.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void setListNavigationCallbacks(
          jni.JniObject adapter, ActionBar_OnNavigationListener callback) =>
      _setListNavigationCallbacks(
              reference, adapter.reference, callback.reference)
          .check();

  static final _setSelectedNavigationItem = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ActionBar__setSelectedNavigationItem")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setSelectedNavigationItem(int position)
  ///
  /// Set the selected navigation item in list or tabbed navigation modes.
  ///@param position Position of the item to select.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void setSelectedNavigationItem(int position) =>
      _setSelectedNavigationItem(reference, position).check();

  static final _getSelectedNavigationIndex = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActionBar__getSelectedNavigationIndex")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getSelectedNavigationIndex()
  ///
  /// Get the position of the selected navigation item in list or tabbed navigation modes.
  ///@return Position of the selected item.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  int getSelectedNavigationIndex() =>
      _getSelectedNavigationIndex(reference).integer;

  static final _getNavigationItemCount = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar__getNavigationItemCount")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getNavigationItemCount()
  ///
  /// Get the number of navigation items present in the current navigation mode.
  ///@return Number of navigation items.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  int getNavigationItemCount() => _getNavigationItemCount(reference).integer;

  static final _setTitle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActionBar__setTitle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setTitle(java.lang.CharSequence title)
  ///
  /// Set the action bar's title. This will only be displayed if
  /// \#DISPLAY_SHOW_TITLE is set.
  ///@param title Title to set
  ///@see \#setTitle(int)
  ///@see \#setDisplayOptions(int, int)
  void setTitle(jni.JniObject title) =>
      _setTitle(reference, title.reference).check();

  static final _setTitle1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("ActionBar__setTitle1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setTitle(int resId)
  ///
  /// Set the action bar's title. This will only be displayed if
  /// \#DISPLAY_SHOW_TITLE is set.
  ///@param resId Resource ID of title string to set
  ///@see \#setTitle(CharSequence)
  ///@see \#setDisplayOptions(int, int)
  void setTitle1(int resId) => _setTitle1(reference, resId).check();

  static final _setSubtitle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActionBar__setSubtitle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setSubtitle(java.lang.CharSequence subtitle)
  ///
  /// Set the action bar's subtitle. This will only be displayed if
  /// \#DISPLAY_SHOW_TITLE is set. Set to null to disable the
  /// subtitle entirely.
  ///@param subtitle Subtitle to set
  ///@see \#setSubtitle(int)
  ///@see \#setDisplayOptions(int, int)
  void setSubtitle(jni.JniObject subtitle) =>
      _setSubtitle(reference, subtitle.reference).check();

  static final _setSubtitle1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("ActionBar__setSubtitle1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setSubtitle(int resId)
  ///
  /// Set the action bar's subtitle. This will only be displayed if
  /// \#DISPLAY_SHOW_TITLE is set.
  ///@param resId Resource ID of subtitle string to set
  ///@see \#setSubtitle(CharSequence)
  ///@see \#setDisplayOptions(int, int)
  void setSubtitle1(int resId) => _setSubtitle1(reference, resId).check();

  static final _setDisplayOptions = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ActionBar__setDisplayOptions")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setDisplayOptions(int options)
  ///
  /// Set display options. This changes all display option bits at once. To change
  /// a limited subset of display options, see \#setDisplayOptions(int, int).
  ///@param options A combination of the bits defined by the DISPLAY_ constants
  ///                defined in ActionBar.
  ///
  /// Value is either <code>0</code> or a combination of android.app.ActionBar\#DISPLAY_USE_LOGO, android.app.ActionBar\#DISPLAY_SHOW_HOME, android.app.ActionBar\#DISPLAY_HOME_AS_UP, android.app.ActionBar\#DISPLAY_SHOW_TITLE, android.app.ActionBar\#DISPLAY_SHOW_CUSTOM, and android.app.ActionBar.DISPLAY_TITLE_MULTIPLE_LINES
  void setDisplayOptions(int options) =>
      _setDisplayOptions(reference, options).check();

  static final _setDisplayOptions1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("ActionBar__setDisplayOptions1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void setDisplayOptions(int options, int mask)
  ///
  /// Set selected display options. Only the options specified by mask will be changed.
  /// To change all display option bits at once, see \#setDisplayOptions(int).
  ///
  /// Example: setDisplayOptions(0, DISPLAY_SHOW_HOME) will disable the
  /// \#DISPLAY_SHOW_HOME option.
  /// setDisplayOptions(DISPLAY_SHOW_HOME, DISPLAY_SHOW_HOME | DISPLAY_USE_LOGO)
  /// will enable \#DISPLAY_SHOW_HOME and disable \#DISPLAY_USE_LOGO.
  ///@param options A combination of the bits defined by the DISPLAY_ constants
  ///                defined in ActionBar.
  /// Value is either <code>0</code> or a combination of android.app.ActionBar\#DISPLAY_USE_LOGO, android.app.ActionBar\#DISPLAY_SHOW_HOME, android.app.ActionBar\#DISPLAY_HOME_AS_UP, android.app.ActionBar\#DISPLAY_SHOW_TITLE, android.app.ActionBar\#DISPLAY_SHOW_CUSTOM, and android.app.ActionBar.DISPLAY_TITLE_MULTIPLE_LINES
  ///@param mask A bit mask declaring which display options should be changed.
  ///
  /// Value is either <code>0</code> or a combination of android.app.ActionBar\#DISPLAY_USE_LOGO, android.app.ActionBar\#DISPLAY_SHOW_HOME, android.app.ActionBar\#DISPLAY_HOME_AS_UP, android.app.ActionBar\#DISPLAY_SHOW_TITLE, android.app.ActionBar\#DISPLAY_SHOW_CUSTOM, and android.app.ActionBar.DISPLAY_TITLE_MULTIPLE_LINES
  void setDisplayOptions1(int options, int mask) =>
      _setDisplayOptions1(reference, options, mask).check();

  static final _setDisplayUseLogoEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("ActionBar__setDisplayUseLogoEnabled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setDisplayUseLogoEnabled(boolean useLogo)
  ///
  /// Set whether to display the activity logo rather than the activity icon.
  /// A logo is often a wider, more detailed image.
  ///
  /// To set several display options at once, see the setDisplayOptions methods.
  ///@param useLogo true to use the activity logo, false to use the activity icon.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  void setDisplayUseLogoEnabled(bool useLogo) =>
      _setDisplayUseLogoEnabled(reference, useLogo ? 1 : 0).check();

  static final _setDisplayShowHomeEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("ActionBar__setDisplayShowHomeEnabled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setDisplayShowHomeEnabled(boolean showHome)
  ///
  /// Set whether to include the application home affordance in the action bar.
  /// Home is presented as either an activity icon or logo.
  ///
  /// To set several display options at once, see the setDisplayOptions methods.
  ///@param showHome true to show home, false otherwise.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  void setDisplayShowHomeEnabled(bool showHome) =>
      _setDisplayShowHomeEnabled(reference, showHome ? 1 : 0).check();

  static final _setDisplayHomeAsUpEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("ActionBar__setDisplayHomeAsUpEnabled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setDisplayHomeAsUpEnabled(boolean showHomeAsUp)
  ///
  /// Set whether home should be displayed as an "up" affordance.
  /// Set this to true if selecting "home" returns up by a single level in your UI
  /// rather than back to the top level or front page.
  ///
  /// To set several display options at once, see the setDisplayOptions methods.
  ///@param showHomeAsUp true to show the user that selecting home will return one
  ///                     level up rather than to the top level of the app.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  void setDisplayHomeAsUpEnabled(bool showHomeAsUp) =>
      _setDisplayHomeAsUpEnabled(reference, showHomeAsUp ? 1 : 0).check();

  static final _setDisplayShowTitleEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("ActionBar__setDisplayShowTitleEnabled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setDisplayShowTitleEnabled(boolean showTitle)
  ///
  /// Set whether an activity title/subtitle should be displayed.
  ///
  /// To set several display options at once, see the setDisplayOptions methods.
  ///@param showTitle true to display a title/subtitle if present.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  void setDisplayShowTitleEnabled(bool showTitle) =>
      _setDisplayShowTitleEnabled(reference, showTitle ? 1 : 0).check();

  static final _setDisplayShowCustomEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("ActionBar__setDisplayShowCustomEnabled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setDisplayShowCustomEnabled(boolean showCustom)
  ///
  /// Set whether a custom view should be displayed, if set.
  ///
  /// To set several display options at once, see the setDisplayOptions methods.
  ///@param showCustom true if the currently set custom view should be displayed, false otherwise.
  ///@see \#setDisplayOptions(int)
  ///@see \#setDisplayOptions(int, int)
  void setDisplayShowCustomEnabled(bool showCustom) =>
      _setDisplayShowCustomEnabled(reference, showCustom ? 1 : 0).check();

  static final _setBackgroundDrawable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActionBar__setBackgroundDrawable")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void setBackgroundDrawable(android.graphics.drawable.Drawable d)
  ///
  /// Set the ActionBar's background. This will be used for the primary
  /// action bar.
  ///@param d Background drawable
  /// This value may be {@code null}.
  ///@see \#setStackedBackgroundDrawable(Drawable)
  ///@see \#setSplitBackgroundDrawable(Drawable)
  void setBackgroundDrawable(jni.JniObject d) =>
      _setBackgroundDrawable(reference, d.reference).check();

  static final _setStackedBackgroundDrawable = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActionBar__setStackedBackgroundDrawable")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setStackedBackgroundDrawable(android.graphics.drawable.Drawable d)
  ///
  /// Set the ActionBar's stacked background. This will appear
  /// in the second row/stacked bar on some devices and configurations.
  ///@param d Background drawable for the stacked row
  void setStackedBackgroundDrawable(jni.JniObject d) =>
      _setStackedBackgroundDrawable(reference, d.reference).check();

  static final _setSplitBackgroundDrawable = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActionBar__setSplitBackgroundDrawable")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setSplitBackgroundDrawable(android.graphics.drawable.Drawable d)
  ///
  /// Set the ActionBar's split background. This will appear in
  /// the split action bar containing menu-provided action buttons
  /// on some devices and configurations.
  /// You can enable split action bar with android.R.attr\#uiOptions
  ///@param d Background drawable for the split bar
  void setSplitBackgroundDrawable(jni.JniObject d) =>
      _setSplitBackgroundDrawable(reference, d.reference).check();

  static final _getCustomView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar__getCustomView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.view.View getCustomView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The current custom view.
  jni.JniObject getCustomView() =>
      jni.JniObject.fromRef(_getCustomView(reference).object);

  static final _getTitle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar__getTitle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.CharSequence getTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current ActionBar title in standard mode.
  /// Returns null if \#getNavigationMode() would not return
  /// \#NAVIGATION_MODE_STANDARD.
  ///@return The current ActionBar title or null.
  jni.JniObject getTitle() =>
      jni.JniObject.fromRef(_getTitle(reference).object);

  static final _getSubtitle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar__getSubtitle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.CharSequence getSubtitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the current ActionBar subtitle in standard mode.
  /// Returns null if \#getNavigationMode() would not return
  /// \#NAVIGATION_MODE_STANDARD.
  ///@return The current ActionBar subtitle or null.
  jni.JniObject getSubtitle() =>
      jni.JniObject.fromRef(_getSubtitle(reference).object);

  static final _getNavigationMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar__getNavigationMode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getNavigationMode()
  ///
  /// Returns the current navigation mode. The result will be one of:
  /// <ul>
  /// <li>\#NAVIGATION_MODE_STANDARD</li>
  /// <li>\#NAVIGATION_MODE_LIST</li>
  /// <li>\#NAVIGATION_MODE_TABS</li>
  /// </ul>
  ///@return The current navigation mode.
  ///
  /// Value is android.app.ActionBar\#NAVIGATION_MODE_STANDARD, android.app.ActionBar\#NAVIGATION_MODE_LIST, or android.app.ActionBar\#NAVIGATION_MODE_TABS
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  int getNavigationMode() => _getNavigationMode(reference).integer;

  static final _setNavigationMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ActionBar__setNavigationMode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void setNavigationMode(int mode)
  ///
  /// Set the current navigation mode.
  ///@param mode The new mode to set.
  /// Value is android.app.ActionBar\#NAVIGATION_MODE_STANDARD, android.app.ActionBar\#NAVIGATION_MODE_LIST, or android.app.ActionBar\#NAVIGATION_MODE_TABS
  ///@see \#NAVIGATION_MODE_STANDARD
  ///@see \#NAVIGATION_MODE_LIST
  ///@see \#NAVIGATION_MODE_TABS
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void setNavigationMode(int mode) =>
      _setNavigationMode(reference, mode).check();

  static final _getDisplayOptions = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar__getDisplayOptions")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getDisplayOptions()
  ///
  /// @return The current set of display options.
  int getDisplayOptions() => _getDisplayOptions(reference).integer;

  static final _newTab = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar__newTab")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.ActionBar.Tab newTab()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create and return a new Tab.
  /// This tab will not be included in the action bar until it is added.
  ///
  /// Very often tabs will be used to switch between Fragment
  /// objects.  Here is a typical implementation of such tabs:
  ///
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentTabs.java
  ///      complete}
  ///@return A new Tab
  ///@see \#addTab(Tab)
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  ActionBar_Tab newTab() => ActionBar_Tab.fromRef(_newTab(reference).object);

  static final _addTab = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActionBar__addTab")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void addTab(android.app.ActionBar.Tab tab)
  ///
  /// Add a tab for use in tabbed navigation mode. The tab will be added at the end of the list.
  /// If this is the first tab to be added it will become the selected tab.
  ///@param tab Tab to add
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void addTab(ActionBar_Tab tab) => _addTab(reference, tab.reference).check();

  static final _addTab1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("ActionBar__addTab1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void addTab(android.app.ActionBar.Tab tab, boolean setSelected)
  ///
  /// Add a tab for use in tabbed navigation mode. The tab will be added at the end of the list.
  ///@param tab Tab to add
  ///@param setSelected True if the added tab should become the selected tab.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void addTab1(ActionBar_Tab tab, bool setSelected) =>
      _addTab1(reference, tab.reference, setSelected ? 1 : 0).check();

  static final _addTab2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("ActionBar__addTab2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void addTab(android.app.ActionBar.Tab tab, int position)
  ///
  /// Add a tab for use in tabbed navigation mode. The tab will be inserted at
  /// <code>position</code>. If this is the first tab to be added it will become
  /// the selected tab.
  ///@param tab The tab to add
  ///@param position The new position of the tab
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void addTab2(ActionBar_Tab tab, int position) =>
      _addTab2(reference, tab.reference, position).check();

  static final _addTab3 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Uint8)>>("ActionBar__addTab3")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void addTab(android.app.ActionBar.Tab tab, int position, boolean setSelected)
  ///
  /// Add a tab for use in tabbed navigation mode. The tab will be insterted at
  /// <code>position</code>.
  ///@param tab The tab to add
  ///@param position The new position of the tab
  ///@param setSelected True if the added tab should become the selected tab.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void addTab3(ActionBar_Tab tab, int position, bool setSelected) =>
      _addTab3(reference, tab.reference, position, setSelected ? 1 : 0).check();

  static final _removeTab = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActionBar__removeTab")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void removeTab(android.app.ActionBar.Tab tab)
  ///
  /// Remove a tab from the action bar. If the removed tab was selected it will be deselected
  /// and another tab will be selected if present.
  ///@param tab The tab to remove
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void removeTab(ActionBar_Tab tab) =>
      _removeTab(reference, tab.reference).check();

  static final _removeTabAt = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("ActionBar__removeTabAt")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void removeTabAt(int position)
  ///
  /// Remove a tab from the action bar. If the removed tab was selected it will be deselected
  /// and another tab will be selected if present.
  ///@param position Position of the tab to remove
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void removeTabAt(int position) => _removeTabAt(reference, position).check();

  static final _removeAllTabs = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar__removeAllTabs")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void removeAllTabs()
  ///
  /// Remove all tabs from the action bar and deselect the current tab.
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void removeAllTabs() => _removeAllTabs(reference).check();

  static final _selectTab = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActionBar__selectTab")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void selectTab(android.app.ActionBar.Tab tab)
  ///
  /// Select the specified tab. If it is not a child of this action bar it will be added.
  ///
  /// Note: If you want to select by index, use \#setSelectedNavigationItem(int).
  ///
  ///@param tab Tab to select
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  void selectTab(ActionBar_Tab tab) =>
      _selectTab(reference, tab.reference).check();

  static final _getSelectedTab = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar__getSelectedTab")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.ActionBar.Tab getSelectedTab()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the currently selected tab if in tabbed navigation mode and there is at least
  /// one tab present.
  ///@return The currently selected tab or null
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  ActionBar_Tab getSelectedTab() =>
      ActionBar_Tab.fromRef(_getSelectedTab(reference).object);

  static final _getTabAt = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("ActionBar__getTabAt")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.ActionBar.Tab getTabAt(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the tab at the specified index.
  ///@param index Index value in the range 0-get
  ///@return
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  ActionBar_Tab getTabAt(int index) =>
      ActionBar_Tab.fromRef(_getTabAt(reference, index).object);

  static final _getTabCount = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar__getTabCount")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getTabCount()
  ///
  /// Returns the number of tabs currently registered with the action bar.
  ///@return Tab count
  ///@deprecated Action bar navigation modes are deprecated and not supported by inline
  /// toolbar action bars. Consider using other
  /// <a href="http://developer.android.com/design/patterns/navigation.html">common
  /// navigation patterns</a> instead.
  int getTabCount() => _getTabCount(reference).integer;

  static final _getHeight = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar__getHeight")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getHeight()
  ///
  /// Retrieve the current height of the ActionBar.
  ///@return The ActionBar's height
  int getHeight() => _getHeight(reference).integer;

  static final _show0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar__show0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void show()
  ///
  /// Show the ActionBar if it is not currently showing.
  /// If the window hosting the ActionBar does not have the feature
  /// Window\#FEATURE_ACTION_BAR_OVERLAY it will resize application
  /// content to fit the new space available.
  ///
  /// If you are hiding the ActionBar through
  /// View\#SYSTEM_UI_FLAG_FULLSCREEN View.SYSTEM_UI_FLAG_FULLSCREEN,
  /// you should not call this function directly.
  void show0() => _show0(reference).check();

  static final _hide0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar__hide0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void hide()
  ///
  /// Hide the ActionBar if it is currently showing.
  /// If the window hosting the ActionBar does not have the feature
  /// Window\#FEATURE_ACTION_BAR_OVERLAY it will resize application
  /// content to fit the new space available.
  ///
  /// Instead of calling this function directly, you can also cause an
  /// ActionBar using the overlay feature to hide through
  /// View\#SYSTEM_UI_FLAG_FULLSCREEN View.SYSTEM_UI_FLAG_FULLSCREEN.
  /// Hiding the ActionBar through this system UI flag allows you to more
  /// seamlessly hide it in conjunction with other screen decorations.
  void hide0() => _hide0(reference).check();

  static final _isShowing = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar__isShowing")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isShowing()
  ///
  /// @return <code>true</code> if the ActionBar is showing, <code>false</code> otherwise.
  bool isShowing() => _isShowing(reference).boolean;

  static final _addOnMenuVisibilityListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActionBar__addOnMenuVisibilityListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void addOnMenuVisibilityListener(android.app.ActionBar.OnMenuVisibilityListener listener)
  ///
  /// Add a listener that will respond to menu visibility change events.
  ///@param listener The new listener to add
  void addOnMenuVisibilityListener(
          ActionBar_OnMenuVisibilityListener listener) =>
      _addOnMenuVisibilityListener(reference, listener.reference).check();

  static final _removeOnMenuVisibilityListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActionBar__removeOnMenuVisibilityListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void removeOnMenuVisibilityListener(android.app.ActionBar.OnMenuVisibilityListener listener)
  ///
  /// Remove a menu visibility listener. This listener will no longer receive menu
  /// visibility change events.
  ///@param listener A listener to remove that was previously added
  void removeOnMenuVisibilityListener(
          ActionBar_OnMenuVisibilityListener listener) =>
      _removeOnMenuVisibilityListener(reference, listener.reference).check();

  static final _setHomeButtonEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("ActionBar__setHomeButtonEnabled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setHomeButtonEnabled(boolean enabled)
  ///
  /// Enable or disable the "home" button in the corner of the action bar. (Note that this
  /// is the application home/up affordance on the action bar, not the systemwide home
  /// button.)
  ///
  /// This defaults to true for packages targeting &lt; API 14. For packages targeting
  /// API 14 or greater, the application should call this method to enable interaction
  /// with the home/up affordance.
  ///
  /// Setting the \#DISPLAY_HOME_AS_UP display option will automatically enable
  /// the home button.
  ///@param enabled true to enable the home button, false to disable the home button.
  void setHomeButtonEnabled(bool enabled) =>
      _setHomeButtonEnabled(reference, enabled ? 1 : 0).check();

  static final _getThemedContext = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar__getThemedContext")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context getThemedContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Context with an appropriate theme for creating views that
  /// will appear in the action bar. If you are inflating or instantiating custom views
  /// that will appear in an action bar, you should use the Context returned by this method.
  /// (This includes adapters used for list navigation mode.)
  /// This will ensure that views contrast properly against the action bar.
  ///@return A themed Context for creating views
  content_.Context getThemedContext() =>
      content_.Context.fromRef(_getThemedContext(reference).object);

  static final _setHomeAsUpIndicator = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActionBar__setHomeAsUpIndicator")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setHomeAsUpIndicator(android.graphics.drawable.Drawable indicator)
  ///
  /// Set an alternate drawable to display next to the icon/logo/title
  /// when \#DISPLAY_HOME_AS_UP is enabled. This can be useful if you are using
  /// this mode to display an alternate selection for up navigation, such as a sliding drawer.
  ///
  /// If you pass <code>null</code> to this method, the default drawable from the theme
  /// will be used.
  ///
  ///
  /// If you implement alternate or intermediate behavior around Up, you should also
  /// call \#setHomeActionContentDescription(int) setHomeActionContentDescription()
  /// to provide a correct description of the action for accessibility support.
  ///
  ///@param indicator A drawable to use for the up indicator, or null to use the theme's default
  ///@see \#setDisplayOptions(int, int)
  ///@see \#setDisplayHomeAsUpEnabled(boolean)
  ///@see \#setHomeActionContentDescription(int)
  void setHomeAsUpIndicator(jni.JniObject indicator) =>
      _setHomeAsUpIndicator(reference, indicator.reference).check();

  static final _setHomeAsUpIndicator1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ActionBar__setHomeAsUpIndicator1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setHomeAsUpIndicator(int resId)
  ///
  /// Set an alternate drawable to display next to the icon/logo/title
  /// when \#DISPLAY_HOME_AS_UP is enabled. This can be useful if you are using
  /// this mode to display an alternate selection for up navigation, such as a sliding drawer.
  ///
  /// If you pass <code>0</code> to this method, the default drawable from the theme
  /// will be used.
  ///
  ///
  /// If you implement alternate or intermediate behavior around Up, you should also
  /// call \#setHomeActionContentDescription(int) setHomeActionContentDescription()
  /// to provide a correct description of the action for accessibility support.
  ///
  ///@param resId Resource ID of a drawable to use for the up indicator, or null
  ///              to use the theme's default
  ///@see \#setDisplayOptions(int, int)
  ///@see \#setDisplayHomeAsUpEnabled(boolean)
  ///@see \#setHomeActionContentDescription(int)
  void setHomeAsUpIndicator1(int resId) =>
      _setHomeAsUpIndicator1(reference, resId).check();

  static final _setHomeActionContentDescription = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActionBar__setHomeActionContentDescription")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setHomeActionContentDescription(java.lang.CharSequence description)
  ///
  /// Set an alternate description for the Home/Up action, when enabled.
  ///
  /// This description is commonly used for accessibility/screen readers when
  /// the Home action is enabled. (See \#setDisplayHomeAsUpEnabled(boolean).)
  /// Examples of this are, "Navigate Home" or "Navigate Up" depending on the
  /// \#DISPLAY_HOME_AS_UP display option. If you have changed the home-as-up
  /// indicator using \#setHomeAsUpIndicator(int) to indicate more specific
  /// functionality such as a sliding drawer, you should also set this to accurately
  /// describe the action.
  ///
  ///
  /// Setting this to <code>null</code> will use the system default description.
  ///
  ///@param description New description for the Home action when enabled
  ///@see \#setHomeAsUpIndicator(int)
  ///@see \#setHomeAsUpIndicator(android.graphics.drawable.Drawable)
  void setHomeActionContentDescription(jni.JniObject description) =>
      _setHomeActionContentDescription(reference, description.reference)
          .check();

  static final _setHomeActionContentDescription1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ActionBar__setHomeActionContentDescription1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setHomeActionContentDescription(int resId)
  ///
  /// Set an alternate description for the Home/Up action, when enabled.
  ///
  /// This description is commonly used for accessibility/screen readers when
  /// the Home action is enabled. (See \#setDisplayHomeAsUpEnabled(boolean).)
  /// Examples of this are, "Navigate Home" or "Navigate Up" depending on the
  /// \#DISPLAY_HOME_AS_UP display option. If you have changed the home-as-up
  /// indicator using \#setHomeAsUpIndicator(int) to indicate more specific
  /// functionality such as a sliding drawer, you should also set this to accurately
  /// describe the action.
  ///
  ///
  /// Setting this to <code>0</code> will use the system default description.
  ///
  ///@param resId Resource ID of a string to use as the new description
  ///              for the Home action when enabled
  ///@see \#setHomeAsUpIndicator(int)
  ///@see \#setHomeAsUpIndicator(android.graphics.drawable.Drawable)
  void setHomeActionContentDescription1(int resId) =>
      _setHomeActionContentDescription1(reference, resId).check();

  static final _setHideOnContentScrollEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("ActionBar__setHideOnContentScrollEnabled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setHideOnContentScrollEnabled(boolean hideOnContentScroll)
  ///
  /// Enable hiding the action bar on content scroll.
  ///
  /// If enabled, the action bar will scroll out of sight along with a
  /// View\#setNestedScrollingEnabled(boolean) nested scrolling child view's content.
  /// The action bar must be in Window\#FEATURE_ACTION_BAR_OVERLAY overlay mode
  /// to enable hiding on content scroll.
  ///
  ///
  /// When partially scrolled off screen the action bar is considered
  /// \#hide() hidden. A call to \#show() show will cause it to return to full view.
  ///
  ///
  ///@param hideOnContentScroll true to enable hiding on content scroll.
  void setHideOnContentScrollEnabled(bool hideOnContentScroll) =>
      _setHideOnContentScrollEnabled(reference, hideOnContentScroll ? 1 : 0)
          .check();

  static final _isHideOnContentScrollEnabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActionBar__isHideOnContentScrollEnabled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isHideOnContentScrollEnabled()
  ///
  /// Return whether the action bar is configured to scroll out of sight along with
  /// a View\#setNestedScrollingEnabled(boolean) nested scrolling child.
  ///@return true if hide-on-content-scroll is enabled
  ///@see \#setHideOnContentScrollEnabled(boolean)
  bool isHideOnContentScrollEnabled() =>
      _isHideOnContentScrollEnabled(reference).boolean;

  static final _getHideOffset = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar__getHideOffset")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getHideOffset()
  ///
  /// Return the current vertical offset of the action bar.
  ///
  /// The action bar's current hide offset is the distance that the action bar is currently
  /// scrolled offscreen in pixels. The valid range is 0 (fully visible) to the action bar's
  /// current measured \#getHeight() height (fully invisible).
  ///
  ///@return The action bar's offset toward its fully hidden state in pixels
  int getHideOffset() => _getHideOffset(reference).integer;

  static final _setHideOffset = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ActionBar__setHideOffset")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setHideOffset(int offset)
  ///
  /// Set the current hide offset of the action bar.
  ///
  /// The action bar's current hide offset is the distance that the action bar is currently
  /// scrolled offscreen in pixels. The valid range is 0 (fully visible) to the action bar's
  /// current measured \#getHeight() height (fully invisible).
  ///
  ///@param offset The action bar's offset toward its fully hidden state in pixels.
  void setHideOffset(int offset) => _setHideOffset(reference, offset).check();

  static final _setElevation = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Float)>>("ActionBar__setElevation")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public void setElevation(float elevation)
  ///
  /// Set the Z-axis elevation of the action bar in pixels.
  ///
  /// The action bar's elevation is the distance it is placed from its parent surface. Higher
  /// values are closer to the user.
  ///
  ///@param elevation Elevation value in pixels
  void setElevation(double elevation) =>
      _setElevation(reference, elevation).check();

  static final _getElevation = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar__getElevation")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float getElevation()
  ///
  /// Get the Z-axis elevation of the action bar in pixels.
  ///
  /// The action bar's elevation is the distance it is placed from its parent surface. Higher
  /// values are closer to the user.
  ///
  ///@return Elevation value in pixels
  double getElevation() => _getElevation(reference).float;
}

/// from: android.app.ActionBar$TabListener
///
/// Callback interface invoked when a tab is focused, unfocused, added, or removed.
///@deprecated Action bar navigation modes are deprecated and not supported by inline
/// toolbar action bars. Consider using other
/// <a href="http://developer.android.com/design/patterns/navigation.html">common
/// navigation patterns</a> instead.
class ActionBar_TabListener extends jni.JniObject {
  ActionBar_TabListener.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _onTabSelected = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActionBar_TabListener__onTabSelected")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onTabSelected(android.app.ActionBar.Tab tab, android.app.FragmentTransaction ft)
  ///
  /// Called when a tab enters the selected state.
  ///@param tab The tab that was selected
  ///@param ft A FragmentTransaction for queuing fragment operations to execute
  ///        during a tab switch. The previous tab's unselect and this tab's select will be
  ///        executed in a single transaction. This FragmentTransaction does not support
  ///        being added to the back stack.
  void onTabSelected(ActionBar_Tab tab, FragmentTransaction ft) =>
      _onTabSelected(reference, tab.reference, ft.reference).check();

  static final _onTabUnselected = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActionBar_TabListener__onTabUnselected")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onTabUnselected(android.app.ActionBar.Tab tab, android.app.FragmentTransaction ft)
  ///
  /// Called when a tab exits the selected state.
  ///@param tab The tab that was unselected
  ///@param ft A FragmentTransaction for queuing fragment operations to execute
  ///        during a tab switch. This tab's unselect and the newly selected tab's select
  ///        will be executed in a single transaction. This FragmentTransaction does not
  ///        support being added to the back stack.
  void onTabUnselected(ActionBar_Tab tab, FragmentTransaction ft) =>
      _onTabUnselected(reference, tab.reference, ft.reference).check();

  static final _onTabReselected = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActionBar_TabListener__onTabReselected")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onTabReselected(android.app.ActionBar.Tab tab, android.app.FragmentTransaction ft)
  ///
  /// Called when a tab that is already selected is chosen again by the user.
  /// Some applications may use this action to return to the top level of a category.
  ///@param tab The tab that was reselected.
  ///@param ft A FragmentTransaction for queuing fragment operations to execute
  ///        once this method returns. This FragmentTransaction does not support
  ///        being added to the back stack.
  void onTabReselected(ActionBar_Tab tab, FragmentTransaction ft) =>
      _onTabReselected(reference, tab.reference, ft.reference).check();
}

/// from: android.app.ActionBar$Tab
///
/// A tab in the action bar.
///
/// Tabs manage the hiding and showing of Fragments.
///@deprecated Action bar navigation modes are deprecated and not supported by inline
/// toolbar action bars. Consider using other
/// <a href="http://developer.android.com/design/patterns/navigation.html">common
/// navigation patterns</a> instead.
class ActionBar_Tab extends jni.JniObject {
  ActionBar_Tab.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int INVALID_POSITION
  ///
  /// An invalid position for a tab.
  ///@see \#getPosition()
  static const INVALID_POSITION = -1;

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ActionBar_Tab__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ActionBar_Tab() : super.fromRef(_ctor().object);

  static final _getPosition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar_Tab__getPosition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getPosition()
  ///
  /// Return the current position of this tab in the action bar.
  ///@return Current position, or \#INVALID_POSITION if this tab is not currently in
  ///         the action bar.
  int getPosition() => _getPosition(reference).integer;

  static final _getIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar_Tab__getIcon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.graphics.drawable.Drawable getIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the icon associated with this tab.
  ///@return The tab's icon
  jni.JniObject getIcon() => jni.JniObject.fromRef(_getIcon(reference).object);

  static final _getText = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar_Tab__getText")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.CharSequence getText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the text of this tab.
  ///@return The tab's text
  jni.JniObject getText() => jni.JniObject.fromRef(_getText(reference).object);

  static final _setIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActionBar_Tab__setIcon")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.ActionBar.Tab setIcon(android.graphics.drawable.Drawable icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the icon displayed on this tab.
  ///@param icon The drawable to use as an icon
  ///@return The current instance for call chaining
  ActionBar_Tab setIcon(jni.JniObject icon) =>
      ActionBar_Tab.fromRef(_setIcon(reference, icon.reference).object);

  static final _setIcon1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("ActionBar_Tab__setIcon1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.ActionBar.Tab setIcon(int resId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the icon displayed on this tab.
  ///@param resId Resource ID referring to the drawable to use as an icon
  ///@return The current instance for call chaining
  ActionBar_Tab setIcon1(int resId) =>
      ActionBar_Tab.fromRef(_setIcon1(reference, resId).object);

  static final _setText = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActionBar_Tab__setText")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.ActionBar.Tab setText(java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the text displayed on this tab. Text may be truncated if there is not
  /// room to display the entire string.
  ///@param text The text to display
  ///@return The current instance for call chaining
  ActionBar_Tab setText(jni.JniObject text) =>
      ActionBar_Tab.fromRef(_setText(reference, text.reference).object);

  static final _setText1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("ActionBar_Tab__setText1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.ActionBar.Tab setText(int resId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the text displayed on this tab. Text may be truncated if there is not
  /// room to display the entire string.
  ///@param resId A resource ID referring to the text that should be displayed
  ///@return The current instance for call chaining
  ActionBar_Tab setText1(int resId) =>
      ActionBar_Tab.fromRef(_setText1(reference, resId).object);

  static final _setCustomView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActionBar_Tab__setCustomView")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.ActionBar.Tab setCustomView(android.view.View view)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a custom view to be used for this tab. This overrides values set by
  /// \#setText(CharSequence) and \#setIcon(Drawable).
  ///@param view Custom view to be used as a tab.
  ///@return The current instance for call chaining
  ActionBar_Tab setCustomView(jni.JniObject view) =>
      ActionBar_Tab.fromRef(_setCustomView(reference, view.reference).object);

  static final _setCustomView1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ActionBar_Tab__setCustomView1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.ActionBar.Tab setCustomView(int layoutResId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a custom view to be used for this tab. This overrides values set by
  /// \#setText(CharSequence) and \#setIcon(Drawable).
  ///@param layoutResId A layout resource to inflate and use as a custom tab view
  ///@return The current instance for call chaining
  ActionBar_Tab setCustomView1(int layoutResId) =>
      ActionBar_Tab.fromRef(_setCustomView1(reference, layoutResId).object);

  static final _getCustomView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar_Tab__getCustomView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.view.View getCustomView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a previously set custom view for this tab.
  ///@return The custom view set by \#setCustomView(View).
  jni.JniObject getCustomView() =>
      jni.JniObject.fromRef(_getCustomView(reference).object);

  static final _setTag = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActionBar_Tab__setTag")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.ActionBar.Tab setTag(java.lang.Object obj)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Give this Tab an arbitrary object to hold for later use.
  ///@param obj Object to store
  ///@return The current instance for call chaining
  ActionBar_Tab setTag(jni.JniObject obj) =>
      ActionBar_Tab.fromRef(_setTag(reference, obj.reference).object);

  static final _getTag = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar_Tab__getTag")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.Object getTag()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return This Tab's tag object.
  jni.JniObject getTag() => jni.JniObject.fromRef(_getTag(reference).object);

  static final _setTabListener = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActionBar_Tab__setTabListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.ActionBar.Tab setTabListener(android.app.ActionBar.TabListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the TabListener that will handle switching to and from this tab.
  /// All tabs must have a TabListener set before being added to the ActionBar.
  ///@param listener Listener to handle tab selection events
  ///@return The current instance for call chaining
  ActionBar_Tab setTabListener(ActionBar_TabListener listener) =>
      ActionBar_Tab.fromRef(
          _setTabListener(reference, listener.reference).object);

  static final _select = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar_Tab__select")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void select()
  ///
  /// Select this tab. Only valid if the tab has been added to the action bar.
  void select() => _select(reference).check();

  static final _setContentDescription = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ActionBar_Tab__setContentDescription")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.ActionBar.Tab setContentDescription(int resId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a description of this tab's content for use in accessibility support.
  /// If no content description is provided the title will be used.
  ///@param resId A resource ID referring to the description text
  ///@return The current instance for call chaining
  ///@see \#setContentDescription(CharSequence)
  ///@see \#getContentDescription()
  ActionBar_Tab setContentDescription(int resId) =>
      ActionBar_Tab.fromRef(_setContentDescription(reference, resId).object);

  static final _setContentDescription1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActionBar_Tab__setContentDescription1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.ActionBar.Tab setContentDescription(java.lang.CharSequence contentDesc)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a description of this tab's content for use in accessibility support.
  /// If no content description is provided the title will be used.
  ///@param contentDesc Description of this tab's content
  ///@return The current instance for call chaining
  ///@see \#setContentDescription(int)
  ///@see \#getContentDescription()
  ActionBar_Tab setContentDescription1(jni.JniObject contentDesc) =>
      ActionBar_Tab.fromRef(
          _setContentDescription1(reference, contentDesc.reference).object);

  static final _getContentDescription = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActionBar_Tab__getContentDescription")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.CharSequence getContentDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets a brief description of this tab's content for use in accessibility support.
  ///@return Description of this tab's content
  ///@see \#setContentDescription(CharSequence)
  ///@see \#setContentDescription(int)
  jni.JniObject getContentDescription() =>
      jni.JniObject.fromRef(_getContentDescription(reference).object);
}

/// from: android.app.ActionBar$OnNavigationListener
///
/// Listener interface for ActionBar navigation events.
///@deprecated Action bar navigation modes are deprecated and not supported by inline
/// toolbar action bars. Consider using other
/// <a href="http://developer.android.com/design/patterns/navigation.html">common
/// navigation patterns</a> instead.
class ActionBar_OnNavigationListener extends jni.JniObject {
  ActionBar_OnNavigationListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onNavigationItemSelected = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int64)>>(
          "ActionBar_OnNavigationListener__onNavigationItemSelected")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract boolean onNavigationItemSelected(int itemPosition, long itemId)
  ///
  /// This method is called whenever a navigation item in your action bar
  /// is selected.
  ///@param itemPosition Position of the item clicked.
  ///@param itemId ID of the item clicked.
  ///@return True if the event was handled, false otherwise.
  bool onNavigationItemSelected(int itemPosition, int itemId) =>
      _onNavigationItemSelected(reference, itemPosition, itemId).boolean;
}

/// from: android.app.ActionBar$OnMenuVisibilityListener
///
/// Listener for receiving events when action bar menus are shown or hidden.
class ActionBar_OnMenuVisibilityListener extends jni.JniObject {
  ActionBar_OnMenuVisibilityListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onMenuVisibilityChanged = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "ActionBar_OnMenuVisibilityListener__onMenuVisibilityChanged")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void onMenuVisibilityChanged(boolean isVisible)
  ///
  /// Called when an action bar menu is shown or hidden. Applications may want to use
  /// this to tune auto-hiding behavior for the action bar or pause/resume video playback,
  /// gameplay, or other activity within the main content area.
  ///@param isVisible True if an action bar menu is now visible, false if no action bar
  ///                  menus are visible.
  void onMenuVisibilityChanged(bool isVisible) =>
      _onMenuVisibilityChanged(reference, isVisible ? 1 : 0).check();
}

/// from: android.app.ActionBar$LayoutParams
///
/// Per-child layout information associated with action bar custom views.
///@attr ref android.R.styleable\#ActionBar_LayoutParams_layout_gravity
class ActionBar_LayoutParams extends jni.JniObject {
  ActionBar_LayoutParams.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_gravity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActionBar_LayoutParams__gravity")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int gravity
  ///
  /// Gravity for the view associated with these LayoutParams.
  ///@see android.view.Gravity
  int get gravity => _get_gravity(reference).integer;
  static final _set_gravity = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int32)>>("set_ActionBar_LayoutParams__gravity")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int gravity
  ///
  /// Gravity for the view associated with these LayoutParams.
  ///@see android.view.Gravity
  set gravity(int value) => _set_gravity(reference, value);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActionBar_LayoutParams__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context c, android.util.AttributeSet attrs)
  ///
  /// @param c This value must never be {@code null}.
  ActionBar_LayoutParams(content_.Context c, jni.JniObject attrs)
      : super.fromRef(_ctor(c.reference, attrs.reference).object);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<jni.JniResult Function(ffi.Int32, ffi.Int32)>>(
          "ActionBar_LayoutParams__ctor1")
      .asFunction<jni.JniResult Function(int, int)>();

  /// from: public void <init>(int width, int height)
  ActionBar_LayoutParams.ctor1(int width, int height)
      : super.fromRef(_ctor1(width, height).object);

  static final _ctor2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Int32, ffi.Int32,
                  ffi.Int32)>>("ActionBar_LayoutParams__ctor2")
      .asFunction<jni.JniResult Function(int, int, int)>();

  /// from: public void <init>(int width, int height, int gravity)
  ActionBar_LayoutParams.ctor2(int width, int height, int gravity)
      : super.fromRef(_ctor2(width, height, gravity).object);

  static final _ctor3 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "ActionBar_LayoutParams__ctor3")
          .asFunction<jni.JniResult Function(int)>();

  /// from: public void <init>(int gravity)
  ActionBar_LayoutParams.ctor3(int gravity)
      : super.fromRef(_ctor3(gravity).object);

  static final _ctor4 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar_LayoutParams__ctor4")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.ActionBar.LayoutParams source)
  ActionBar_LayoutParams.ctor4(ActionBar_LayoutParams source)
      : super.fromRef(_ctor4(source.reference).object);

  static final _ctor5 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActionBar_LayoutParams__ctor5")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.view.ViewGroup.LayoutParams source)
  ActionBar_LayoutParams.ctor5(jni.JniObject source)
      : super.fromRef(_ctor5(source.reference).object);
}

/// from: android.app.Activity
///
/// An activity is a single, focused thing that the user can do.  Almost all
/// activities interact with the user, so the Activity class takes care of
/// creating a window for you in which you can place your UI with
/// \#setContentView.  While activities are often presented to the user
/// as full-screen windows, they can also be used in other ways: as floating
/// windows (via a theme with android.R.attr\#windowIsFloating set)
/// or embedded inside of another activity (using ActivityGroup).
///
/// There are two methods almost all subclasses of Activity will implement:
///
/// <ul>
///     <li> \#onCreate is where you initialize your activity.  Most
///     importantly, here you will usually call \#setContentView(int)
///     with a layout resource defining your UI, and using \#findViewById
///     to retrieve the widgets in that UI that you need to interact with
///     programmatically.
///
///     <li> \#onPause is where you deal with the user leaving your
///     activity.  Most importantly, any changes made by the user should at this
///     point be committed (usually to the
///     android.content.ContentProvider holding the data).
/// </ul>
///
/// To be of use with android.content.Context\#startActivity Context.startActivity(), all
/// activity classes must have a corresponding
/// android.R.styleable\#AndroidManifestActivity &lt;activity&gt;
/// declaration in their package's <code>AndroidManifest.xml</code>.
///
///
/// Topics covered here:
/// <ol>
/// <li><a href="\#Fragments">Fragments</a>
/// <li><a href="\#ActivityLifecycle">Activity Lifecycle</a>
/// <li><a href="\#ConfigurationChanges">Configuration Changes</a>
/// <li><a href="\#StartingActivities">Starting Activities and Getting Results</a>
/// <li><a href="\#SavingPersistentState">Saving Persistent State</a>
/// <li><a href="\#Permissions">Permissions</a>
/// <li><a href="\#ProcessLifecycle">Process Lifecycle</a>
/// </ol>
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// The Activity class is an important part of an application's overall lifecycle,
/// and the way activities are launched and put together is a fundamental
/// part of the platform's application model. For a detailed perspective on the structure of an
/// Android application and how activities behave, please read the
/// <a href="{@docRoot}guide/topics/fundamentals.html">Application Fundamentals</a> and
/// <a href="{@docRoot}guide/components/tasks-and-back-stack.html">Tasks and Back Stack</a>
/// developer guides.
///
///
/// You can also find a detailed discussion about how to create activities in the
/// <a href="{@docRoot}guide/components/activities.html">Activities</a>
/// developer guide.
///
/// </div>
///
/// <a name="Fragments"></a>
/// <h3>Fragments</h3>
///
/// The android.support.v4.app.FragmentActivity subclass
/// can make use of the android.support.v4.app.Fragment class to better
/// modularize their code, build more sophisticated user interfaces for larger
/// screens, and help scale their application between small and large screens.
///
///
/// For more information about using fragments, read the
/// <a href="{@docRoot}guide/components/fragments.html">Fragments</a> developer guide.
///
///
/// <a name="ActivityLifecycle"></a>
/// <h3>Activity Lifecycle</h3>
///
/// Activities in the system are managed as an _activity stack_.
/// When a new activity is started, it is placed on the top of the stack
/// and becomes the running activity -- the previous activity always remains
/// below it in the stack, and will not come to the foreground again until
/// the new activity exits.
///
///
/// An activity has essentially four states:
///
/// <ul>
///     <li> If an activity is in the foreground of the screen (at the top of
///         the stack),
///         it is _active_ or  _running_. </li>
///     <li>If an activity has lost focus but is still visible (that is, a new non-full-sized
///         or transparent activity has focus on top of your activity), it
///         is _paused_. A paused activity is completely alive (it
///         maintains all state and member information and remains attached to
///         the window manager), but can be killed by the system in extreme
///         low memory situations.
///     <li>If an activity is completely obscured by another activity,
///         it is _stopped_. It still retains all state and member information,
///         however, it is no longer visible to the user so its window is hidden
///         and it will often be killed by the system when memory is needed
///         elsewhere.</li>
///     <li>If an activity is paused or stopped, the system can drop the activity
///         from memory by either asking it to finish, or simply killing its
///         process.  When it is displayed again to the user, it must be
///         completely restarted and restored to its previous state.</li>
/// </ul>
///
/// The following diagram shows the important state paths of an Activity.
/// The square rectangles represent callback methods you can implement to
/// perform operations when the Activity moves between states.  The colored
/// ovals are major states the Activity can be in.
///
///
/// <img src="../../../images/activity_lifecycle.png"alt="State diagram for an Android Activity Lifecycle."border="0"/>
///
///
/// There are three key loops you may be interested in monitoring within your
/// activity:
///
/// <ul>
/// <li>The __entire lifetime__ of an activity happens between the first call
/// to android.app.Activity\#onCreate through to a single final call
/// to android.app.Activity\#onDestroy.  An activity will do all setup
/// of "global" state in onCreate(), and release all remaining resources in
/// onDestroy().  For example, if it has a thread running in the background
/// to download data from the network, it may create that thread in onCreate()
/// and then stop the thread in onDestroy().
///
/// <li>The __visible lifetime__ of an activity happens between a call to
/// android.app.Activity\#onStart until a corresponding call to
/// android.app.Activity\#onStop.  During this time the user can see the
/// activity on-screen, though it may not be in the foreground and interacting
/// with the user.  Between these two methods you can maintain resources that
/// are needed to show the activity to the user.  For example, you can register
/// a android.content.BroadcastReceiver in onStart() to monitor for changes
/// that impact your UI, and unregister it in onStop() when the user no
/// longer sees what you are displaying.  The onStart() and onStop() methods
/// can be called multiple times, as the activity becomes visible and hidden
/// to the user.
///
/// <li>The __foreground lifetime__ of an activity happens between a call to
/// android.app.Activity\#onResume until a corresponding call to
/// android.app.Activity\#onPause.  During this time the activity is
/// in front of all other activities and interacting with the user.  An activity
/// can frequently go between the resumed and paused states -- for example when
/// the device goes to sleep, when an activity result is delivered, when a new
/// intent is delivered -- so the code in these methods should be fairly
/// lightweight.
/// </ul>
///
/// The entire lifecycle of an activity is defined by the following
/// Activity methods.  All of these are hooks that you can override
/// to do appropriate work when the activity changes state.  All
/// activities will implement android.app.Activity\#onCreate
/// to do their initial setup; many will also implement
/// android.app.Activity\#onPause to commit changes to data and
/// otherwise prepare to stop interacting with the user.  You should always
/// call up to your superclass when implementing these methods.
///
///
///
///
/// <pre class="prettyprint">
/// public class Activity extends ApplicationContext {
///     protected void onCreate(Bundle savedInstanceState);
///
///     protected void onStart();
///
///     protected void onRestart();
///
///     protected void onResume();
///
///     protected void onPause();
///
///     protected void onStop();
///
///     protected void onDestroy();
/// }
/// </pre>
///
/// In general the movement through an activity's lifecycle looks like
/// this:
///
///
/// <table border="2"width="85%"align="center"frame="hsides"rules="rows">
///     <colgroup align="left"span="3"/>
///     <colgroup align="left"/>
///     <colgroup align="center"/>
///     <colgroup align="center"/>
///
///     <thead>
///     <tr><th colspan="3">Method</th> <th>Description</th> <th>Killable?</th> <th>Next</th></tr>
///     </thead>
///
///     <tbody>
///     <tr><td colspan="3"align="left"border="0">android.app.Activity\#onCreate onCreate()</td>
///         <td>Called when the activity is first created.
///             This is where you should do all of your normal static set up:
///             create views, bind data to lists, etc.  This method also
///             provides you with a Bundle containing the activity's previously
///             frozen state, if there was one.
///             Always followed by <code>onStart()</code>.</td>
///         <td align="center">No</td>
///         <td align="center"><code>onStart()</code></td>
///     </tr>
///
///     <tr><td rowspan="5"style="border-left: none; border-right: none;">&nbsp;&nbsp;&nbsp;&nbsp;</td>
///         <td colspan="2"align="left"border="0">android.app.Activity\#onRestart onRestart()</td>
///         <td>Called after your activity has been stopped, prior to it being
///             started again.
///             Always followed by <code>onStart()</code></td>
///         <td align="center">No</td>
///         <td align="center"><code>onStart()</code></td>
///     </tr>
///
///     <tr><td colspan="2"align="left"border="0">android.app.Activity\#onStart onStart()</td>
///         <td>Called when the activity is becoming visible to the user.
///             Followed by <code>onResume()</code> if the activity comes
///             to the foreground, or <code>onStop()</code> if it becomes hidden.</td>
///         <td align="center">No</td>
///         <td align="center"><code>onResume()</code> or <code>onStop()</code></td>
///     </tr>
///
///     <tr><td rowspan="2"style="border-left: none;">&nbsp;&nbsp;&nbsp;&nbsp;</td>
///         <td align="left"border="0">android.app.Activity\#onResume onResume()</td>
///         <td>Called when the activity will start
///             interacting with the user.  At this point your activity is at
///             the top of the activity stack, with user input going to it.
///             Always followed by <code>onPause()</code>.</td>
///         <td align="center">No</td>
///         <td align="center"><code>onPause()</code></td>
///     </tr>
///
///     <tr><td align="left"border="0">android.app.Activity\#onPause onPause()</td>
///         <td>Called when the system is about to start resuming a previous
///             activity.  This is typically used to commit unsaved changes to
///             persistent data, stop animations and other things that may be consuming
///             CPU, etc.  Implementations of this method must be very quick because
///             the next activity will not be resumed until this method returns.
///             Followed by either <code>onResume()</code> if the activity
///             returns back to the front, or <code>onStop()</code> if it becomes
///             invisible to the user.</td>
///         <td align="center"><font color="\#800000"><strong>Pre-android.os.Build.VERSION_CODES\#HONEYCOMB</strong></font></td>
///         <td align="center"><code>onResume()</code> or<br>
///                 <code>onStop()</code></td>
///     </tr>
///
///     <tr><td colspan="2"align="left"border="0">android.app.Activity\#onStop onStop()</td>
///         <td>Called when the activity is no longer visible to the user, because
///             another activity has been resumed and is covering this one.  This
///             may happen either because a new activity is being started, an existing
///             one is being brought in front of this one, or this one is being
///             destroyed.
///             Followed by either <code>onRestart()</code> if
///             this activity is coming back to interact with the user, or
///             <code>onDestroy()</code> if this activity is going away.</td>
///         <td align="center"><font color="\#800000"><strong>Yes</strong></font></td>
///         <td align="center"><code>onRestart()</code> or<br>
///                 <code>onDestroy()</code></td>
///     </tr>
///
///     <tr><td colspan="3"align="left"border="0">android.app.Activity\#onDestroy onDestroy()</td>
///         <td>The final call you receive before your
///             activity is destroyed.  This can happen either because the
///             activity is finishing (someone called Activity\#finish on
///             it, or because the system is temporarily destroying this
///             instance of the activity to save space.  You can distinguish
///             between these two scenarios with the Activity\#isFinishing method.</td>
///         <td align="center"><font color="\#800000"><strong>Yes</strong></font></td>
///         <td align="center">_nothing_</td>
///     </tr>
///     </tbody>
/// </table>
///
/// Note the "Killable" column in the above table -- for those methods that
/// are marked as being killable, after that method returns the process hosting the
/// activity may be killed by the system _at any time_ without another line
/// of its code being executed.  Because of this, you should use the
/// \#onPause method to write any persistent data (such as user edits)
/// to storage.  In addition, the method
/// \#onSaveInstanceState(Bundle) is called before placing the activity
/// in such a background state, allowing you to save away any dynamic instance
/// state in your activity into the given Bundle, to be later received in
/// \#onCreate if the activity needs to be re-created.
/// See the <a href="\#ProcessLifecycle">Process Lifecycle</a>
/// section for more information on how the lifecycle of a process is tied
/// to the activities it is hosting.  Note that it is important to save
/// persistent data in \#onPause instead of \#onSaveInstanceState
/// because the latter is not part of the lifecycle callbacks, so will not
/// be called in every situation as described in its documentation.
///
///
/// <p class="note">Be aware that these semantics will change slightly between
/// applications targeting platforms starting with android.os.Build.VERSION_CODES\#HONEYCOMB
/// vs. those targeting prior platforms.  Starting with Honeycomb, an application
/// is not in the killable state until its \#onStop has returned.  This
/// impacts when \#onSaveInstanceState(Bundle) may be called (it may be
/// safely called after \#onPause()) and allows an application to safely
/// wait until \#onStop() to save persistent state.
///
///
/// <p class="note">For applications targeting platforms starting with
/// android.os.Build.VERSION_CODES\#P \#onSaveInstanceState(Bundle)
/// will always be called after \#onStop, so an application may safely
/// perform fragment transactions in \#onStop and will be able to save
/// persistent state later.
///
///
/// For those methods that are not marked as being killable, the activity's
/// process will not be killed by the system starting from the time the method
/// is called and continuing after it returns.  Thus an activity is in the killable
/// state, for example, between after <code>onPause()</code> to the start of
/// <code>onResume()</code>.
///
///
/// <a name="ConfigurationChanges"></a>
/// <h3>Configuration Changes</h3>
///
/// If the configuration of the device (as defined by the
/// Configuration Resources.Configuration class) changes,
/// then anything displaying a user interface will need to update to match that
/// configuration.  Because Activity is the primary mechanism for interacting
/// with the user, it includes special support for handling configuration
/// changes.
///
///
/// Unless you specify otherwise, a configuration change (such as a change
/// in screen orientation, language, input devices, etc) will cause your
/// current activity to be _destroyed_, going through the normal activity
/// lifecycle process of \#onPause,
/// \#onStop, and \#onDestroy as appropriate.  If the activity
/// had been in the foreground or visible to the user, once \#onDestroy is
/// called in that instance then a new instance of the activity will be
/// created, with whatever savedInstanceState the previous instance had generated
/// from \#onSaveInstanceState.
///
///
/// This is done because any application resource,
/// including layout files, can change based on any configuration value.  Thus
/// the only safe way to handle a configuration change is to re-retrieve all
/// resources, including layouts, drawables, and strings.  Because activities
/// must already know how to save their state and re-create themselves from
/// that state, this is a convenient way to have an activity restart itself
/// with a new configuration.
///
///
/// In some special cases, you may want to bypass restarting of your
/// activity based on one or more types of configuration changes.  This is
/// done with the android.R.attr\#configChanges android:configChanges
/// attribute in its manifest.  For any types of configuration changes you say
/// that you handle there, you will receive a call to your current activity's
/// \#onConfigurationChanged method instead of being restarted.  If
/// a configuration change involves any that you do not handle, however, the
/// activity will still be restarted and \#onConfigurationChanged
/// will not be called.
///
///
/// <a name="StartingActivities"></a>
/// <h3>Starting Activities and Getting Results</h3>
///
/// The android.app.Activity\#startActivity
/// method is used to start a
/// new activity, which will be placed at the top of the activity stack.  It
/// takes a single argument, an android.content.Intent Intent,
/// which describes the activity
/// to be executed.
///
///
/// Sometimes you want to get a result back from an activity when it
/// ends.  For example, you may start an activity that lets the user pick
/// a person in a list of contacts; when it ends, it returns the person
/// that was selected.  To do this, you call the
/// android.app.Activity\#startActivityForResult(Intent, int)
/// version with a second integer parameter identifying the call.  The result
/// will come back through your android.app.Activity\#onActivityResult
/// method.
///
///
/// When an activity exits, it can call
/// android.app.Activity\#setResult(int)
/// to return data back to its parent.  It must always supply a result code,
/// which can be the standard results RESULT_CANCELED, RESULT_OK, or any
/// custom values starting at RESULT_FIRST_USER.  In addition, it can optionally
/// return back an Intent containing any additional data it wants.  All of this
/// information appears back on the
/// parent's <code>Activity.onActivityResult()</code>, along with the integer
/// identifier it originally supplied.
///
///
/// If a child activity fails for any reason (such as crashing), the parent
/// activity will receive a result with the code RESULT_CANCELED.
///
///
/// <pre class="prettyprint">
/// public class MyActivity extends Activity {
///     ...
///
///     static final int PICK_CONTACT_REQUEST = 0;
///
///     public boolean onKeyDown(int keyCode, KeyEvent event) {
///         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
///             // When the user center presses, let them pick a contact.
///             startActivityForResult(
///                 new Intent(Intent.ACTION_PICK,
///                 new Uri("content://contacts")),
///                 PICK_CONTACT_REQUEST);
///            return true;
///         }
///         return false;
///     }
///
///     protected void onActivityResult(int requestCode, int resultCode,
///             Intent data) {
///         if (requestCode == PICK_CONTACT_REQUEST) {
///             if (resultCode == RESULT_OK) {
///                 // A contact was picked.  Here we will just display it
///                 // to the user.
///                 startActivity(new Intent(Intent.ACTION_VIEW, data));
///             }
///         }
///     }
/// }
/// </pre>
///
/// <a name="SavingPersistentState"></a>
/// <h3>Saving Persistent State</h3>
///
/// There are generally two kinds of persistent state than an activity
/// will deal with: shared document-like data (typically stored in a SQLite
/// database using a {@linkplain android.content.ContentProvider content provider})
/// and internal state such as user preferences.
///
///
/// For content provider data, we suggest that activities use a
/// "edit in place" user model.  That is, any edits a user makes are effectively
/// made immediately without requiring an additional confirmation step.
/// Supporting this model is generally a simple matter of following two rules:
///
///
/// <ul>
///     <li> When creating a new document, the backing database entry or file for
///             it is created immediately.  For example, if the user chooses to write
///             a new email, a new entry for that email is created as soon as they
///             start entering data, so that if they go to any other activity after
///             that point this email will now appear in the list of drafts.
///
///     <li> When an activity's <code>onPause()</code> method is called, it should
///             commit to the backing content provider or file any changes the user
///             has made.  This ensures that those changes will be seen by any other
///             activity that is about to run.  You will probably want to commit
///             your data even more aggressively at key times during your
///             activity's lifecycle: for example before starting a new
///             activity, before finishing your own activity, when the user
///             switches between input fields, etc.
///
/// </ul>
///
/// This model is designed to prevent data loss when a user is navigating
/// between activities, and allows the system to safely kill an activity (because
/// system resources are needed somewhere else) at any time after it has been
/// paused.  Note this implies
/// that the user pressing BACK from your activity does _not_
/// mean "cancel" -- it means to leave the activity with its current contents
/// saved away.  Canceling edits in an activity must be provided through
/// some other mechanism, such as an explicit "revert" or "undo" option.
///
///
/// See the {@linkplain android.content.ContentProvider content package} for
/// more information about content providers.  These are a key aspect of how
/// different activities invoke and propagate data between themselves.
///
///
/// The Activity class also provides an API for managing internal persistent state
/// associated with an activity.  This can be used, for example, to remember
/// the user's preferred initial display in a calendar (day view or week view)
/// or the user's default home page in a web browser.
///
///
/// Activity persistent state is managed
/// with the method \#getPreferences,
/// allowing you to retrieve and
/// modify a set of name/value pairs associated with the activity.  To use
/// preferences that are shared across multiple application components
/// (activities, receivers, services, providers), you can use the underlying
/// Context\#getSharedPreferences Context.getSharedPreferences() method
/// to retrieve a preferences
/// object stored under a specific name.
/// (Note that it is not possible to share settings data across application
/// packages -- for that you will need a content provider.)
///
///
/// Here is an excerpt from a calendar activity that stores the user's
/// preferred view mode in its persistent settings:
///
///
/// <pre class="prettyprint">
/// public class CalendarActivity extends Activity {
///     ...
///
///     static final int DAY_VIEW_MODE = 0;
///     static final int WEEK_VIEW_MODE = 1;
///
///     private SharedPreferences mPrefs;
///     private int mCurViewMode;
///
///     protected void onCreate(Bundle savedInstanceState) {
///         super.onCreate(savedInstanceState);
///
///         SharedPreferences mPrefs = getSharedPreferences();
///         mCurViewMode = mPrefs.getInt("view_mode", DAY_VIEW_MODE);
///     }
///
///     protected void onPause() {
///         super.onPause();
///
///         SharedPreferences.Editor ed = mPrefs.edit();
///         ed.putInt("view_mode", mCurViewMode);
///         ed.commit();
///     }
/// }
/// </pre>
///
/// <a name="Permissions"></a>
/// <h3>Permissions</h3>
///
/// The ability to start a particular Activity can be enforced when it is
/// declared in its
/// manifest's android.R.styleable\#AndroidManifestActivity &lt;activity&gt;
/// tag.  By doing so, other applications will need to declare a corresponding
/// android.R.styleable\#AndroidManifestUsesPermission &lt;uses-permission&gt;
/// element in their own manifest to be able to start that activity.
///
/// When starting an Activity you can set Intent\#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION and/or Intent\#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION on the Intent.  This will grant the
/// Activity access to the specific URIs in the Intent.  Access will remain
/// until the Activity has finished (it will remain across the hosting
/// process being killed and other temporary destruction).  As of
/// android.os.Build.VERSION_CODES\#GINGERBREAD, if the Activity
/// was already created and a new Intent is being delivered to
/// \#onNewIntent(Intent), any newly granted URI permissions will be added
/// to the existing ones it holds.
///
/// See the <a href="{@docRoot}guide/topics/security/security.html">Security and Permissions</a>
/// document for more information on permissions and security in general.
///
/// <a name="ProcessLifecycle"></a>
/// <h3>Process Lifecycle</h3>
///
/// The Android system attempts to keep an application process around for as
/// long as possible, but eventually will need to remove old processes when
/// memory runs low. As described in <a href="\#ActivityLifecycle">Activity
/// Lifecycle</a>, the decision about which process to remove is intimately
/// tied to the state of the user's interaction with it. In general, there
/// are four states a process can be in based on the activities running in it,
/// listed here in order of importance. The system will kill less important
/// processes (the last ones) before it resorts to killing more important
/// processes (the first ones).
///
/// <ol>
/// <li> The __foreground activity__ (the activity at the top of the screen
/// that the user is currently interacting with) is considered the most important.
/// Its process will only be killed as a last resort, if it uses more memory
/// than is available on the device.  Generally at this point the device has
/// reached a memory paging state, so this is required in order to keep the user
/// interface responsive.
/// <li> A __visible activity__ (an activity that is visible to the user
/// but not in the foreground, such as one sitting behind a foreground dialog)
/// is considered extremely important and will not be killed unless that is
/// required to keep the foreground activity running.
/// <li> A __background activity__ (an activity that is not visible to
/// the user and has been paused) is no longer critical, so the system may
/// safely kill its process to reclaim memory for other foreground or
/// visible processes.  If its process needs to be killed, when the user navigates
/// back to the activity (making it visible on the screen again), its
/// \#onCreate method will be called with the savedInstanceState it had previously
/// supplied in \#onSaveInstanceState so that it can restart itself in the same
/// state as the user last left it.
/// <li> An __empty process__ is one hosting no activities or other
/// application components (such as Service or
/// android.content.BroadcastReceiver classes).  These are killed very
/// quickly by the system as memory becomes low.  For this reason, any
/// background operation you do outside of an activity must be executed in the
/// context of an activity BroadcastReceiver or Service to ensure that the system
/// knows it needs to keep your process around.
/// </ol>
///
/// Sometimes an Activity may need to do a long-running operation that exists
/// independently of the activity lifecycle itself.  An example may be a camera
/// application that allows you to upload a picture to a web site.  The upload
/// may take a long time, and the application should allow the user to leave
/// the application while it is executing.  To accomplish this, your Activity
/// should start a Service in which the upload takes place.  This allows
/// the system to properly prioritize your process (considering it to be more
/// important than other non-visible applications) for the duration of the
/// upload, independent of whether the original activity is paused, stopped,
/// or finished.
class Activity extends jni.JniObject {
  Activity.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int DEFAULT_KEYS_DIALER
  ///
  /// Use with \#setDefaultKeyMode to launch the dialer during default
  /// key handling.
  ///@see \#setDefaultKeyMode
  static const DEFAULT_KEYS_DIALER = 1;

  /// from: static public final int DEFAULT_KEYS_DISABLE
  ///
  /// Use with \#setDefaultKeyMode to turn off default handling of
  /// keys.
  ///@see \#setDefaultKeyMode
  static const DEFAULT_KEYS_DISABLE = 0;

  /// from: static public final int DEFAULT_KEYS_SEARCH_GLOBAL
  ///
  /// Use with \#setDefaultKeyMode to specify that unhandled keystrokes
  /// will start a global search (typically web search, but some platforms may define alternate
  /// methods for global search)
  ///
  /// See android.app.SearchManager android.app.SearchManager for more details.
  ///@see \#setDefaultKeyMode
  static const DEFAULT_KEYS_SEARCH_GLOBAL = 4;

  /// from: static public final int DEFAULT_KEYS_SEARCH_LOCAL
  ///
  /// Use with \#setDefaultKeyMode to specify that unhandled keystrokes
  /// will start an application-defined search.  (If the application or activity does not
  /// actually define a search, the the keys will be ignored.)
  ///
  /// See android.app.SearchManager android.app.SearchManager for more details.
  ///@see \#setDefaultKeyMode
  static const DEFAULT_KEYS_SEARCH_LOCAL = 3;

  /// from: static public final int DEFAULT_KEYS_SHORTCUT
  ///
  /// Use with \#setDefaultKeyMode to execute a menu shortcut in
  /// default key handling.
  ///
  /// That is, the user does not need to hold down the menu key to execute menu shortcuts.
  ///@see \#setDefaultKeyMode
  static const DEFAULT_KEYS_SHORTCUT = 2;

  static final _get_FOCUSED_STATE_SET =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Activity__FOCUSED_STATE_SET")
          .asFunction<jni.JniResult Function()>();

  /// from: static protected final int[] FOCUSED_STATE_SET
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniObject get FOCUSED_STATE_SET =>
      jni.JniObject.fromRef(_get_FOCUSED_STATE_SET().object);

  /// from: static public final int RESULT_CANCELED
  ///
  /// Standard activity result: operation canceled.
  static const RESULT_CANCELED = 0;

  /// from: static public final int RESULT_FIRST_USER
  ///
  /// Start of user-defined activity results.
  static const RESULT_FIRST_USER = 1;

  /// from: static public final int RESULT_OK
  ///
  /// Standard activity result: operation succeeded.
  static const RESULT_OK = -1;

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Activity__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  Activity() : super.fromRef(_ctor().object);

  static final _getIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getIntent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent getIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the intent that started this activity.
  content_.Intent getIntent() =>
      content_.Intent.fromRef(_getIntent(reference).object);

  static final _setIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__setIntent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setIntent(android.content.Intent newIntent)
  ///
  /// Change the intent returned by \#getIntent.  This holds a
  /// reference to the given intent; it does not copy it.  Often used in
  /// conjunction with \#onNewIntent.
  ///@param newIntent The new Intent object to return from getIntent
  ///@see \#getIntent
  ///@see \#onNewIntent
  void setIntent(content_.Intent newIntent) =>
      _setIntent(reference, newIntent.reference).check();

  static final _getApplication = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getApplication")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Application getApplication()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the application that owns this activity.
  Application getApplication() =>
      Application.fromRef(_getApplication(reference).object);

  static final _isChild = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__isChild")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isChild()
  ///
  /// Is this activity embedded inside of another activity?
  bool isChild() => _isChild(reference).boolean;

  static final _getParent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getParent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Activity getParent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the parent activity if this view is an embedded child.
  Activity getParent() => Activity.fromRef(_getParent(reference).object);

  static final _getWindowManager = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getWindowManager")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.WindowManager getWindowManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the window manager for showing custom windows.
  jni.JniObject getWindowManager() =>
      jni.JniObject.fromRef(_getWindowManager(reference).object);

  static final _getWindow = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getWindow")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.Window getWindow()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the current android.view.Window for the activity.
  /// This can be used to directly access parts of the Window API that
  /// are not available through Activity/Screen.
  ///@return Window The current window, or null if the activity is not
  ///         visual.
  jni.JniObject getWindow() =>
      jni.JniObject.fromRef(_getWindow(reference).object);

  static final _getLoaderManager = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getLoaderManager")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.LoaderManager getLoaderManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the LoaderManager for this activity, creating it if needed.
  ///@deprecated Use android.support.v4.app.FragmentActivity\#getSupportLoaderManager()
  LoaderManager getLoaderManager() =>
      LoaderManager.fromRef(_getLoaderManager(reference).object);

  static final _getCurrentFocus = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getCurrentFocus")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View getCurrentFocus()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Calls android.view.Window\#getCurrentFocus on the
  /// Window of this Activity to return the currently focused view.
  ///@return View The current View with focus or null.
  ///@see \#getWindow
  ///@see android.view.Window\#getCurrentFocus
  jni.JniObject getCurrentFocus() =>
      jni.JniObject.fromRef(_getCurrentFocus(reference).object);

  static final _attachBaseContext = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__attachBaseContext")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void attachBaseContext(android.content.Context newBase)
  void attachBaseContext(content_.Context newBase) =>
      _attachBaseContext(reference, newBase.reference).check();

  static final _onCreate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onCreate")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onCreate(android.os.Bundle savedInstanceState)
  ///
  /// Called when the activity is starting.  This is where most initialization
  /// should go: calling \#setContentView(int) to inflate the
  /// activity's UI, using \#findViewById to programmatically interact
  /// with widgets in the UI, calling
  /// \#managedQuery(android.net.Uri , String[], String, String[], String) to retrieve
  /// cursors for data being displayed, etc.
  ///
  /// You can call \#finish from within this function, in
  /// which case onDestroy() will be immediately called after \#onCreate without any of the
  /// rest of the activity lifecycle (\#onStart, \#onResume, \#onPause, etc)
  /// executing.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// This method must be called from the
  ///  *            {@linkplain Looper\#getMainLooper() main thread} of your app.
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param savedInstanceState If the activity is being re-initialized after
  ///     previously being shut down then this Bundle contains the data it most
  ///     recently supplied in \#onSaveInstanceState.  __<i>Note: Otherwise it is null.</i>__
  ///
  /// This value may be {@code null}.
  ///@see \#onStart
  ///@see \#onSaveInstanceState
  ///@see \#onRestoreInstanceState
  ///@see \#onPostCreate
  void onCreate(os_.Bundle savedInstanceState) =>
      _onCreate(reference, savedInstanceState.reference).check();

  static final _onCreate1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onCreate1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreate(android.os.Bundle savedInstanceState, android.os.PersistableBundle persistentState)
  ///
  /// Same as \#onCreate(android.os.Bundle) but called for those activities created with
  /// the attribute android.R.attr\#persistableMode set to
  /// <code>persistAcrossReboots</code>.
  ///@param savedInstanceState if the activity is being re-initialized after
  ///     previously being shut down then this Bundle contains the data it most
  ///     recently supplied in \#onSaveInstanceState.
  ///     __<i>Note: Otherwise it is null.</i>__
  /// This value may be {@code null}.
  ///@param persistentState if the activity is being re-initialized after
  ///     previously being shut down or powered off then this Bundle contains the data it most
  ///     recently supplied to outPersistentState in \#onSaveInstanceState.
  ///     __<i>Note: Otherwise it is null.</i>__
  ///
  /// This value may be {@code null}.
  ///@see \#onCreate(android.os.Bundle)
  ///@see \#onStart
  ///@see \#onSaveInstanceState
  ///@see \#onRestoreInstanceState
  ///@see \#onPostCreate
  void onCreate1(os_.Bundle savedInstanceState,
          os_.PersistableBundle persistentState) =>
      _onCreate1(reference, savedInstanceState.reference,
              persistentState.reference)
          .check();

  static final _onRestoreInstanceState = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onRestoreInstanceState")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onRestoreInstanceState(android.os.Bundle savedInstanceState)
  ///
  /// This method is called after \#onStart when the activity is
  /// being re-initialized from a previously saved state, given here in
  /// <var>savedInstanceState</var>.  Most implementations will simply use \#onCreate
  /// to restore their state, but it is sometimes convenient to do it here
  /// after all of the initialization has been done or to allow subclasses to
  /// decide whether to use your default implementation.  The default
  /// implementation of this method performs a restore of any view state that
  /// had previously been frozen by \#onSaveInstanceState.
  ///
  /// This method is called between \#onStart and
  /// \#onPostCreate.
  ///@param savedInstanceState the data most recently supplied in \#onSaveInstanceState.
  ///@see \#onCreate
  ///@see \#onPostCreate
  ///@see \#onResume
  ///@see \#onSaveInstanceState
  void onRestoreInstanceState(os_.Bundle savedInstanceState) =>
      _onRestoreInstanceState(reference, savedInstanceState.reference).check();

  static final _onRestoreInstanceState1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onRestoreInstanceState1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onRestoreInstanceState(android.os.Bundle savedInstanceState, android.os.PersistableBundle persistentState)
  ///
  /// This is the same as \#onRestoreInstanceState(Bundle) but is called for activities
  /// created with the attribute android.R.attr\#persistableMode set to
  /// <code>persistAcrossReboots</code>. The android.os.PersistableBundle passed
  /// came from the restored PersistableBundle first
  /// saved in \#onSaveInstanceState(Bundle, PersistableBundle).
  ///
  /// This method is called between \#onStart and
  /// \#onPostCreate.
  ///
  /// If this method is called \#onRestoreInstanceState(Bundle) will not be called.
  ///@param savedInstanceState the data most recently supplied in \#onSaveInstanceState.
  ///@param persistentState the data most recently supplied in \#onSaveInstanceState.
  ///@see \#onRestoreInstanceState(Bundle)
  ///@see \#onCreate
  ///@see \#onPostCreate
  ///@see \#onResume
  ///@see \#onSaveInstanceState
  void onRestoreInstanceState1(os_.Bundle savedInstanceState,
          os_.PersistableBundle persistentState) =>
      _onRestoreInstanceState1(reference, savedInstanceState.reference,
              persistentState.reference)
          .check();

  static final _onPostCreate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onPostCreate")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPostCreate(android.os.Bundle savedInstanceState)
  ///
  /// Called when activity start-up is complete (after \#onStart
  /// and \#onRestoreInstanceState have been called).  Applications will
  /// generally not implement this method; it is intended for system
  /// classes to do final initialization after application code has run.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param savedInstanceState If the activity is being re-initialized after
  ///     previously being shut down then this Bundle contains the data it most
  ///     recently supplied in \#onSaveInstanceState.  __<i>Note: Otherwise it is null.</i>__
  /// This value may be {@code null}.
  ///@see \#onCreate
  void onPostCreate(os_.Bundle savedInstanceState) =>
      _onPostCreate(reference, savedInstanceState.reference).check();

  static final _onPostCreate1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onPostCreate1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onPostCreate(android.os.Bundle savedInstanceState, android.os.PersistableBundle persistentState)
  ///
  /// This is the same as \#onPostCreate(Bundle) but is called for activities
  /// created with the attribute android.R.attr\#persistableMode set to
  /// <code>persistAcrossReboots</code>.
  ///@param savedInstanceState The data most recently supplied in \#onSaveInstanceState
  /// This value may be {@code null}.
  ///@param persistentState The data caming from the PersistableBundle first
  /// saved in \#onSaveInstanceState(Bundle, PersistableBundle).
  ///
  /// This value may be {@code null}.
  ///@see \#onCreate
  void onPostCreate1(os_.Bundle savedInstanceState,
          os_.PersistableBundle persistentState) =>
      _onPostCreate1(reference, savedInstanceState.reference,
              persistentState.reference)
          .check();

  static final _onStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStart()
  ///
  /// Called after \#onCreate &mdash; or after \#onRestart when
  /// the activity had been stopped, but is now again being displayed to the
  /// user.  It will be followed by \#onResume.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onCreate
  ///@see \#onStop
  ///@see \#onResume
  void onStart() => _onStart(reference).check();

  static final _onRestart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onRestart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onRestart()
  ///
  /// Called after \#onStop when the current activity is being
  /// re-displayed to the user (the user has navigated back to it).  It will
  /// be followed by \#onStart and then \#onResume.
  ///
  /// For activities that are using raw Cursor objects (instead of
  /// creating them through
  /// \#managedQuery(android.net.Uri , String[], String, String[], String),
  /// this is usually the place
  /// where the cursor should be requeried (because you had deactivated it in
  /// \#onStop.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onStop
  ///@see \#onStart
  ///@see \#onResume
  void onRestart() => _onRestart(reference).check();

  static final _onStateNotSaved = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onStateNotSaved")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onStateNotSaved()
  ///
  /// Called when an \#onResume is coming up, prior to other pre-resume callbacks
  /// such as \#onNewIntent and \#onActivityResult.  This is primarily intended
  /// to give the activity a hint that its state is no longer saved -- it will generally
  /// be called after \#onSaveInstanceState and prior to the activity being
  /// resumed/started again.
  void onStateNotSaved() => _onStateNotSaved(reference).check();

  static final _onResume = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onResume")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onResume()
  ///
  /// Called after \#onRestoreInstanceState, \#onRestart, or
  /// \#onPause, for your activity to start interacting with the user.
  /// This is a good place to begin animations, open exclusive-access devices
  /// (such as the camera), etc.
  ///
  /// Keep in mind that onResume is not the best indicator that your activity
  /// is visible to the user; a system window such as the keyguard may be in
  /// front.  Use \#onWindowFocusChanged to know for certain that your
  /// activity is visible to the user (for example, to resume a game).
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onRestoreInstanceState
  ///@see \#onRestart
  ///@see \#onPostResume
  ///@see \#onPause
  void onResume() => _onResume(reference).check();

  static final _onPostResume = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onPostResume")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPostResume()
  ///
  /// Called when activity resume is complete (after \#onResume has
  /// been called). Applications will generally not implement this method;
  /// it is intended for system classes to do final setup after application
  /// resume code has run.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onResume
  void onPostResume() => _onPostResume(reference).check();

  static final _isVoiceInteraction = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__isVoiceInteraction")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isVoiceInteraction()
  ///
  /// Check whether this activity is running as part of a voice interaction with the user.
  /// If true, it should perform its interaction with the user through the
  /// VoiceInteractor returned by \#getVoiceInteractor.
  bool isVoiceInteraction() => _isVoiceInteraction(reference).boolean;

  static final _isVoiceInteractionRoot = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__isVoiceInteractionRoot")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isVoiceInteractionRoot()
  ///
  /// Like \#isVoiceInteraction, but only returns true if this is also the root
  /// of a voice interaction.  That is, returns true if this activity was directly
  /// started by the voice interaction service as the initiation of a voice interaction.
  /// Otherwise, for example if it was started by another activity while under voice
  /// interaction, returns false.
  bool isVoiceInteractionRoot() => _isVoiceInteractionRoot(reference).boolean;

  static final _getVoiceInteractor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getVoiceInteractor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.VoiceInteractor getVoiceInteractor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the active VoiceInteractor that the user is going through to
  /// interact with this activity.
  VoiceInteractor getVoiceInteractor() =>
      VoiceInteractor.fromRef(_getVoiceInteractor(reference).object);

  static final _isLocalVoiceInteractionSupported = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Activity__isLocalVoiceInteractionSupported")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isLocalVoiceInteractionSupported()
  ///
  /// Queries whether the currently enabled voice interaction service supports returning
  /// a voice interactor for use by the activity. This is valid only for the duration of the
  /// activity.
  ///@return whether the current voice interaction service supports local voice interaction
  bool isLocalVoiceInteractionSupported() =>
      _isLocalVoiceInteractionSupported(reference).boolean;

  static final _startLocalVoiceInteraction = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Activity__startLocalVoiceInteraction")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startLocalVoiceInteraction(android.os.Bundle privateOptions)
  ///
  /// Starts a local voice interaction session. When ready,
  /// \#onLocalVoiceInteractionStarted() is called. You can pass a bundle of private options
  /// to the registered voice interaction service.
  ///@param privateOptions a Bundle of private arguments to the current voice interaction service
  void startLocalVoiceInteraction(os_.Bundle privateOptions) =>
      _startLocalVoiceInteraction(reference, privateOptions.reference).check();

  static final _onLocalVoiceInteractionStarted = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Activity__onLocalVoiceInteractionStarted")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onLocalVoiceInteractionStarted()
  ///
  /// Callback to indicate that \#startLocalVoiceInteraction(Bundle) has resulted in a
  /// voice interaction session being started. You can now retrieve a voice interactor using
  /// \#getVoiceInteractor().
  void onLocalVoiceInteractionStarted() =>
      _onLocalVoiceInteractionStarted(reference).check();

  static final _onLocalVoiceInteractionStopped = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Activity__onLocalVoiceInteractionStopped")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onLocalVoiceInteractionStopped()
  ///
  /// Callback to indicate that the local voice interaction has stopped either
  /// because it was requested through a call to \#stopLocalVoiceInteraction()
  /// or because it was canceled by the user. The previously acquired VoiceInteractor
  /// is no longer valid after this.
  void onLocalVoiceInteractionStopped() =>
      _onLocalVoiceInteractionStopped(reference).check();

  static final _stopLocalVoiceInteraction = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Activity__stopLocalVoiceInteraction")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void stopLocalVoiceInteraction()
  ///
  /// Request to terminate the current voice interaction that was previously started
  /// using \#startLocalVoiceInteraction(Bundle). When the interaction is
  /// terminated, \#onLocalVoiceInteractionStopped() will be called.
  void stopLocalVoiceInteraction() =>
      _stopLocalVoiceInteraction(reference).check();

  static final _onNewIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onNewIntent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onNewIntent(android.content.Intent intent)
  ///
  /// This is called for activities that set launchMode to "singleTop" in
  /// their package, or if a client used the Intent\#FLAG_ACTIVITY_SINGLE_TOP
  /// flag when calling \#startActivity.  In either case, when the
  /// activity is re-launched while at the top of the activity stack instead
  /// of a new instance of the activity being started, onNewIntent() will be
  /// called on the existing instance with the Intent that was used to
  /// re-launch it.
  ///
  /// An activity will always be paused before receiving a new intent, so
  /// you can count on \#onResume being called after this method.
  ///
  /// Note that \#getIntent still returns the original Intent.  You
  /// can use \#setIntent to update it to this new Intent.
  ///@param intent The new intent that was started for the activity.
  ///@see \#getIntent
  ///@see \#setIntent
  ///@see \#onResume
  void onNewIntent(content_.Intent intent) =>
      _onNewIntent(reference, intent.reference).check();

  static final _onSaveInstanceState = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onSaveInstanceState")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onSaveInstanceState(android.os.Bundle outState)
  ///
  /// Called to retrieve per-instance state from an activity before being killed
  /// so that the state can be restored in \#onCreate or
  /// \#onRestoreInstanceState (the Bundle populated by this method
  /// will be passed to both).
  ///
  /// This method is called before an activity may be killed so that when it
  /// comes back some time in the future it can restore its state.  For example,
  /// if activity B is launched in front of activity A, and at some point activity
  /// A is killed to reclaim resources, activity A will have a chance to save the
  /// current state of its user interface via this method so that when the user
  /// returns to activity A, the state of the user interface can be restored
  /// via \#onCreate or \#onRestoreInstanceState.
  ///
  /// Do not confuse this method with activity lifecycle callbacks such as
  /// \#onPause, which is always called when an activity is being placed
  /// in the background or on its way to destruction, or \#onStop which
  /// is called before destruction.  One example of when \#onPause and
  /// \#onStop is called and not this method is when a user navigates back
  /// from activity B to activity A: there is no need to call \#onSaveInstanceState
  /// on B because that particular instance will never be restored, so the
  /// system avoids calling it.  An example when \#onPause is called and
  /// not \#onSaveInstanceState is when activity B is launched in front of activity A:
  /// the system may avoid calling \#onSaveInstanceState on activity A if it isn't
  /// killed during the lifetime of B since the state of the user interface of
  /// A will stay intact.
  ///
  /// The default implementation takes care of most of the UI per-instance
  /// state for you by calling android.view.View\#onSaveInstanceState() on each
  /// view in the hierarchy that has an id, and by saving the id of the currently
  /// focused view (all of which is restored by the default implementation of
  /// \#onRestoreInstanceState).  If you override this method to save additional
  /// information not captured by each individual view, you will likely want to
  /// call through to the default implementation, otherwise be prepared to save
  /// all of the state of each view yourself.
  ///
  /// If called, this method will occur after \#onStop for applications
  /// targeting platforms starting with android.os.Build.VERSION_CODES\#P.
  /// For applications targeting earlier platform versions this method will occur
  /// before \#onStop and there are no guarantees about whether it will
  /// occur before or after \#onPause.
  ///@param outState Bundle in which to place your saved state.
  ///@see \#onCreate
  ///@see \#onRestoreInstanceState
  ///@see \#onPause
  void onSaveInstanceState(os_.Bundle outState) =>
      _onSaveInstanceState(reference, outState.reference).check();

  static final _onSaveInstanceState1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onSaveInstanceState1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onSaveInstanceState(android.os.Bundle outState, android.os.PersistableBundle outPersistentState)
  ///
  /// This is the same as \#onSaveInstanceState but is called for activities
  /// created with the attribute android.R.attr\#persistableMode set to
  /// <code>persistAcrossReboots</code>. The android.os.PersistableBundle passed
  /// in will be saved and presented in \#onCreate(Bundle, PersistableBundle)
  /// the first time that this activity is restarted following the next device reboot.
  ///@param outState Bundle in which to place your saved state.
  ///@param outPersistentState State which will be saved across reboots.
  ///@see \#onSaveInstanceState(Bundle)
  ///@see \#onCreate
  ///@see \#onRestoreInstanceState(Bundle, PersistableBundle)
  ///@see \#onPause
  void onSaveInstanceState1(
          os_.Bundle outState, os_.PersistableBundle outPersistentState) =>
      _onSaveInstanceState1(
              reference, outState.reference, outPersistentState.reference)
          .check();

  static final _onPause = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onPause")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPause()
  ///
  /// Called as part of the activity lifecycle when an activity is going into
  /// the background, but has not (yet) been killed.  The counterpart to
  /// \#onResume.
  ///
  /// When activity B is launched in front of activity A, this callback will
  /// be invoked on A.  B will not be created until A's \#onPause returns,
  /// so be sure to not do anything lengthy here.
  ///
  /// This callback is mostly used for saving any persistent state the
  /// activity is editing, to present a "edit in place" model to the user and
  /// making sure nothing is lost if there are not enough resources to start
  /// the new activity without first killing this one.  This is also a good
  /// place to do things like stop animations and other things that consume a
  /// noticeable amount of CPU in order to make the switch to the next activity
  /// as fast as possible, or to close resources that are exclusive access
  /// such as the camera.
  ///
  /// In situations where the system needs more memory it may kill paused
  /// processes to reclaim resources.  Because of this, you should be sure
  /// that all of your state is saved by the time you return from
  /// this function.  In general \#onSaveInstanceState is used to save
  /// per-instance state in the activity and this method is used to store
  /// global persistent data (in content providers, files, etc.)
  ///
  /// After receiving this call you will usually receive a following call
  /// to \#onStop (after the next activity has been resumed and
  /// displayed), however in some cases there will be a direct call back to
  /// \#onResume without going through the stopped state.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onResume
  ///@see \#onSaveInstanceState
  ///@see \#onStop
  void onPause() => _onPause(reference).check();

  static final _onUserLeaveHint = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onUserLeaveHint")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onUserLeaveHint()
  ///
  /// Called as part of the activity lifecycle when an activity is about to go
  /// into the background as the result of user choice.  For example, when the
  /// user presses the Home key, \#onUserLeaveHint will be called, but
  /// when an incoming phone call causes the in-call Activity to be automatically
  /// brought to the foreground, \#onUserLeaveHint will not be called on
  /// the activity being interrupted.  In cases when it is invoked, this method
  /// is called right before the activity's \#onPause callback.
  ///
  /// This callback and \#onUserInteraction are intended to help
  /// activities manage status bar notifications intelligently; specifically,
  /// for helping activities determine the proper time to cancel a notification.
  ///@see \#onUserInteraction()
  void onUserLeaveHint() => _onUserLeaveHint(reference).check();

  static final _onCreateThumbnail = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onCreateThumbnail")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onCreateThumbnail(android.graphics.Bitmap outBitmap, android.graphics.Canvas canvas)
  ///
  /// @deprecated Method doesn't do anything and will be removed in the future.
  bool onCreateThumbnail(jni.JniObject outBitmap, jni.JniObject canvas) =>
      _onCreateThumbnail(reference, outBitmap.reference, canvas.reference)
          .boolean;

  static final _onCreateDescription = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onCreateDescription")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence onCreateDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Generate a new description for this activity.  This method is called
  /// before stopping the activity and can, if desired, return some textual
  /// description of its current state to be displayed to the user.
  ///
  /// The default implementation returns null, which will cause you to
  /// inherit the description from the previous activity.  If all activities
  /// return null, generally the label of the top activity will be used as the
  /// description.
  ///@return A description of what the user is doing.  It should be short and
  ///         sweet (only a few words).
  ///@see \#onSaveInstanceState
  ///@see \#onStop
  jni.JniObject onCreateDescription() =>
      jni.JniObject.fromRef(_onCreateDescription(reference).object);

  static final _onProvideAssistData = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onProvideAssistData")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onProvideAssistData(android.os.Bundle data)
  ///
  /// This is called when the user is requesting an assist, to build a full
  /// Intent\#ACTION_ASSIST Intent with all of the context of the current
  /// application.  You can override this method to place into the bundle anything
  /// you would like to appear in the Intent\#EXTRA_ASSIST_CONTEXT part
  /// of the assist Intent.
  ///
  /// This function will be called after any global assist callbacks that had
  /// been registered with Application\#registerOnProvideAssistDataListener Application.registerOnProvideAssistDataListener.
  void onProvideAssistData(os_.Bundle data) =>
      _onProvideAssistData(reference, data.reference).check();

  static final _onProvideAssistContent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onProvideAssistContent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onProvideAssistContent(android.app.assist.AssistContent outContent)
  ///
  /// This is called when the user is requesting an assist, to provide references
  /// to content related to the current activity.  Before being called, the
  /// {@code outContent} Intent is filled with the base Intent of the activity (the Intent
  /// returned by \#getIntent()).  The Intent's extras are stripped of any types
  /// that are not valid for PersistableBundle or non-framework Parcelables, and
  /// the flags Intent\#FLAG_GRANT_WRITE_URI_PERMISSION and
  /// Intent\#FLAG_GRANT_PERSISTABLE_URI_PERMISSION are cleared from the Intent.
  ///
  /// Custom implementation may adjust the content intent to better reflect the top-level
  /// context of the activity, and fill in its ClipData with additional content of
  /// interest that the user is currently viewing.  For example, an image gallery application
  /// that has launched in to an activity allowing the user to swipe through pictures should
  /// modify the intent to reference the current image they are looking it; such an
  /// application when showing a list of pictures should add a ClipData that has
  /// references to all of the pictures currently visible on screen.
  ///
  ///@param outContent The assist content to return.
  void onProvideAssistContent(assist_.AssistContent outContent) =>
      _onProvideAssistContent(reference, outContent.reference).check();

  static final _requestShowKeyboardShortcuts = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Activity__requestShowKeyboardShortcuts")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final void requestShowKeyboardShortcuts()
  ///
  /// Request the Keyboard Shortcuts screen to show up. This will trigger
  /// \#onProvideKeyboardShortcuts to retrieve the shortcuts for the foreground activity.
  void requestShowKeyboardShortcuts() =>
      _requestShowKeyboardShortcuts(reference).check();

  static final _dismissKeyboardShortcutsHelper = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Activity__dismissKeyboardShortcutsHelper")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final void dismissKeyboardShortcutsHelper()
  ///
  /// Dismiss the Keyboard Shortcuts screen.
  void dismissKeyboardShortcutsHelper() =>
      _dismissKeyboardShortcutsHelper(reference).check();

  static final _onProvideKeyboardShortcuts = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__onProvideKeyboardShortcuts")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onProvideKeyboardShortcuts(java.util.List<android.view.KeyboardShortcutGroup> data, android.view.Menu menu, int deviceId)
  void onProvideKeyboardShortcuts(
          jni.JniObject data, jni.JniObject menu, int deviceId) =>
      _onProvideKeyboardShortcuts(
              reference, data.reference, menu.reference, deviceId)
          .check();

  static final _showAssist = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__showAssist")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean showAssist(android.os.Bundle args)
  ///
  /// Ask to have the current assistant shown to the user.  This only works if the calling
  /// activity is the current foreground activity.  It is the same as calling
  /// android.service.voice.VoiceInteractionService\#showSession VoiceInteractionService.showSession and requesting all of the possible context.
  /// The receiver will always see
  /// android.service.voice.VoiceInteractionSession\#SHOW_SOURCE_APPLICATION set.
  ///@return Returns true if the assistant was successfully invoked, else false.  For example
  /// false will be returned if the caller is not the current top activity.
  bool showAssist(os_.Bundle args) =>
      _showAssist(reference, args.reference).boolean;

  static final _onStop = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onStop")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStop()
  ///
  /// Called when you are no longer visible to the user.  You will next
  /// receive either \#onRestart, \#onDestroy, or nothing,
  /// depending on later user activity.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onRestart
  ///@see \#onResume
  ///@see \#onSaveInstanceState
  ///@see \#onDestroy
  void onStop() => _onStop(reference).check();

  static final _onDestroy = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onDestroy")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onDestroy()
  ///
  /// Perform any final cleanup before an activity is destroyed.  This can
  /// happen either because the activity is finishing (someone called
  /// \#finish on it, or because the system is temporarily destroying
  /// this instance of the activity to save space.  You can distinguish
  /// between these two scenarios with the \#isFinishing method.
  ///
  /// _Note: do not count on this method being called as a place for
  /// saving data! For example, if an activity is editing data in a content
  /// provider, those edits should be committed in either \#onPause or
  /// \#onSaveInstanceState, not here._ This method is usually implemented to
  /// free resources like threads that are associated with an activity, so
  /// that a destroyed activity does not leave such things around while the
  /// rest of its application is still running.  There are situations where
  /// the system will simply kill the activity's hosting process without
  /// calling this method (or any others) in it, so it should not be used to
  /// do things that are intended to remain around after the process goes
  /// away.
  ///
  /// _Derived classes must call through to the super class's
  /// implementation of this method.  If they do not, an exception will be
  /// thrown._
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#onPause
  ///@see \#onStop
  ///@see \#finish
  ///@see \#isFinishing
  void onDestroy() => _onDestroy(reference).check();

  static final _reportFullyDrawn = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__reportFullyDrawn")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void reportFullyDrawn()
  ///
  /// Report to the system that your app is now fully drawn, purely for diagnostic
  /// purposes (calling it does not impact the visible behavior of the activity).
  /// This is only used to help instrument application launch times, so that the
  /// app can report when it is fully in a usable state; without this, the only thing
  /// the system itself can determine is the point at which the activity's window
  /// is _first_ drawn and displayed.  To participate in app launch time
  /// measurement, you should always call this method after first launch (when
  /// \#onCreate(android.os.Bundle) is called), at the point where you have
  /// entirely drawn your UI and populated with all of the significant data.  You
  /// can safely call this method any time after first launch as well, in which case
  /// it will simply be ignored.
  void reportFullyDrawn() => _reportFullyDrawn(reference).check();

  static final _onMultiWindowModeChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                  ffi.Pointer<ffi.Void>)>>("Activity__onMultiWindowModeChanged")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onMultiWindowModeChanged(boolean isInMultiWindowMode, android.content.res.Configuration newConfig)
  ///
  /// Called by the system when the activity changes from fullscreen mode to multi-window mode and
  /// visa-versa. This method provides the same configuration that will be sent in the following
  /// \#onConfigurationChanged(Configuration) call after the activity enters this mode.
  ///@see android.R.attr\#resizeableActivity
  ///@param isInMultiWindowMode True if the activity is in multi-window mode.
  ///@param newConfig The new configuration of the activity with the state
  ///                  {@param isInMultiWindowMode}.
  void onMultiWindowModeChanged(
          bool isInMultiWindowMode, res_.Configuration newConfig) =>
      _onMultiWindowModeChanged(
              reference, isInMultiWindowMode ? 1 : 0, newConfig.reference)
          .check();

  static final _onMultiWindowModeChanged1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Activity__onMultiWindowModeChanged1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onMultiWindowModeChanged(boolean isInMultiWindowMode)
  ///
  /// Called by the system when the activity changes from fullscreen mode to multi-window mode and
  /// visa-versa.
  ///@see android.R.attr\#resizeableActivity
  ///@param isInMultiWindowMode True if the activity is in multi-window mode.
  ///@deprecated Use \#onMultiWindowModeChanged(boolean, Configuration) instead.
  void onMultiWindowModeChanged1(bool isInMultiWindowMode) =>
      _onMultiWindowModeChanged1(reference, isInMultiWindowMode ? 1 : 0)
          .check();

  static final _isInMultiWindowMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__isInMultiWindowMode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isInMultiWindowMode()
  ///
  /// Returns true if the activity is currently in multi-window mode.
  ///@see android.R.attr\#resizeableActivity
  ///@return True if the activity is in multi-window mode.
  bool isInMultiWindowMode() => _isInMultiWindowMode(reference).boolean;

  static final _onPictureInPictureModeChanged = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                      ffi.Pointer<ffi.Void>)>>(
          "Activity__onPictureInPictureModeChanged")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode, android.content.res.Configuration newConfig)
  ///
  /// Called by the system when the activity changes to and from picture-in-picture mode. This
  /// method provides the same configuration that will be sent in the following
  /// \#onConfigurationChanged(Configuration) call after the activity enters this mode.
  ///@see android.R.attr\#supportsPictureInPicture
  ///@param isInPictureInPictureMode True if the activity is in picture-in-picture mode.
  ///@param newConfig The new configuration of the activity with the state
  ///                  {@param isInPictureInPictureMode}.
  void onPictureInPictureModeChanged(
          bool isInPictureInPictureMode, res_.Configuration newConfig) =>
      _onPictureInPictureModeChanged(
              reference, isInPictureInPictureMode ? 1 : 0, newConfig.reference)
          .check();

  static final _onPictureInPictureModeChanged1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Activity__onPictureInPictureModeChanged1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode)
  ///
  /// Called by the system when the activity changes to and from picture-in-picture mode.
  ///@see android.R.attr\#supportsPictureInPicture
  ///@param isInPictureInPictureMode True if the activity is in picture-in-picture mode.
  ///@deprecated Use \#onPictureInPictureModeChanged(boolean, Configuration) instead.
  void onPictureInPictureModeChanged1(bool isInPictureInPictureMode) =>
      _onPictureInPictureModeChanged1(
              reference, isInPictureInPictureMode ? 1 : 0)
          .check();

  static final _isInPictureInPictureMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__isInPictureInPictureMode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isInPictureInPictureMode()
  ///
  /// Returns true if the activity is currently in picture-in-picture mode.
  ///@see android.R.attr\#supportsPictureInPicture
  ///@return True if the activity is in picture-in-picture mode.
  bool isInPictureInPictureMode() =>
      _isInPictureInPictureMode(reference).boolean;

  static final _enterPictureInPictureMode = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Activity__enterPictureInPictureMode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void enterPictureInPictureMode()
  ///
  /// Puts the activity in picture-in-picture mode if possible in the current system state. Any
  /// prior calls to \#setPictureInPictureParams(PictureInPictureParams) will still apply
  /// when entering picture-in-picture through this call.
  ///@see \#enterPictureInPictureMode(PictureInPictureParams)
  ///@see android.R.attr\#supportsPictureInPicture
  void enterPictureInPictureMode() =>
      _enterPictureInPictureMode(reference).check();

  static final _enterPictureInPictureMode1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Activity__enterPictureInPictureMode1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean enterPictureInPictureMode(android.app.PictureInPictureParams params)
  ///
  /// Puts the activity in picture-in-picture mode if possible in the current system state. The
  /// set parameters in {@param params} will be combined with the parameters from prior calls to
  /// \#setPictureInPictureParams(PictureInPictureParams).
  ///
  /// The system may disallow entering picture-in-picture in various cases, including when the
  /// activity is not visible, if the screen is locked or if the user has an activity pinned.
  ///@see android.R.attr\#supportsPictureInPicture
  ///@see PictureInPictureParams
  ///@param params non-null parameters to be combined with previously set parameters when entering
  /// picture-in-picture.
  ///
  /// This value must never be {@code null}.
  ///@return true if the system successfully put this activity into picture-in-picture mode or was
  /// already in picture-in-picture mode (@see {@link \#isInPictureInPictureMode()). If the device
  /// does not support picture-in-picture, return false.
  bool enterPictureInPictureMode1(PictureInPictureParams params) =>
      _enterPictureInPictureMode1(reference, params.reference).boolean;

  static final _setPictureInPictureParams = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Activity__setPictureInPictureParams")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setPictureInPictureParams(android.app.PictureInPictureParams params)
  ///
  /// Updates the properties of the picture-in-picture activity, or sets it to be used later when
  /// \#enterPictureInPictureMode() is called.
  ///@param params the new parameters for the picture-in-picture.
  ///
  /// This value must never be {@code null}.
  void setPictureInPictureParams(PictureInPictureParams params) =>
      _setPictureInPictureParams(reference, params.reference).check();

  static final _getMaxNumPictureInPictureActions = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Activity__getMaxNumPictureInPictureActions")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getMaxNumPictureInPictureActions()
  ///
  /// Return the number of actions that will be displayed in the picture-in-picture UI when the
  /// user interacts with the activity currently in picture-in-picture mode. This number may change
  /// if the global configuration changes (ie. if the device is plugged into an external display),
  /// but will always be larger than three.
  int getMaxNumPictureInPictureActions() =>
      _getMaxNumPictureInPictureActions(reference).integer;

  static final _onConfigurationChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onConfigurationChanged")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onConfigurationChanged(android.content.res.Configuration newConfig)
  ///
  /// Called by the system when the device configuration changes while your
  /// activity is running.  Note that this will _only_ be called if
  /// you have selected configurations you would like to handle with the
  /// android.R.attr\#configChanges attribute in your manifest.  If
  /// any configuration change occurs that is not selected to be reported
  /// by that attribute, then instead of reporting it the system will stop
  /// and restart the activity (to have it launched with the new
  /// configuration).
  ///
  /// At the time that this function has been called, your Resources
  /// object will have been updated to return resource values matching the
  /// new configuration.
  ///@param newConfig The new device configuration.
  void onConfigurationChanged(res_.Configuration newConfig) =>
      _onConfigurationChanged(reference, newConfig.reference).check();

  static final _getChangingConfigurations = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Activity__getChangingConfigurations")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getChangingConfigurations()
  ///
  /// If this activity is being destroyed because it can not handle a
  /// configuration parameter being changed (and thus its
  /// \#onConfigurationChanged(Configuration) method is
  /// _not_ being called), then you can use this method to discover
  /// the set of changes that have occurred while in the process of being
  /// destroyed.  Note that there is no guarantee that these will be
  /// accurate (other changes could have happened at any time), so you should
  /// only use this as an optimization hint.
  ///@return Returns a bit field of the configuration parameters that are
  /// changing, as defined by the android.content.res.Configuration
  /// class.
  int getChangingConfigurations() =>
      _getChangingConfigurations(reference).integer;

  static final _getLastNonConfigurationInstance = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Activity__getLastNonConfigurationInstance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object getLastNonConfigurationInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the non-configuration instance data that was previously
  /// returned by \#onRetainNonConfigurationInstance().  This will
  /// be available from the initial \#onCreate and
  /// \#onStart calls to the new instance, allowing you to extract
  /// any useful dynamic state from the previous instance.
  ///
  /// Note that the data you retrieve here should _only_ be used
  /// as an optimization for handling configuration changes.  You should always
  /// be able to handle getting a null pointer back, and an activity must
  /// still be able to restore itself to its previous state (through the
  /// normal \#onSaveInstanceState(Bundle) mechanism) even if this
  /// function returns null.
  ///
  /// <strong>Note:</strong> For most cases you should use the Fragment API
  /// Fragment\#setRetainInstance(boolean) instead; this is also
  /// available on older platforms through the Android support libraries.
  ///@return the object previously returned by \#onRetainNonConfigurationInstance()
  jni.JniObject getLastNonConfigurationInstance() =>
      jni.JniObject.fromRef(_getLastNonConfigurationInstance(reference).object);

  static final _onRetainNonConfigurationInstance = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Activity__onRetainNonConfigurationInstance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object onRetainNonConfigurationInstance()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called by the system, as part of destroying an
  /// activity due to a configuration change, when it is known that a new
  /// instance will immediately be created for the new configuration.  You
  /// can return any object you like here, including the activity instance
  /// itself, which can later be retrieved by calling
  /// \#getLastNonConfigurationInstance() in the new activity
  /// instance.
  ///
  /// _If you are targeting android.os.Build.VERSION_CODES\#HONEYCOMB
  /// or later, consider instead using a Fragment with
  /// Fragment\#setRetainInstance(boolean) Fragment.setRetainInstance(boolean._
  ///
  /// This function is called purely as an optimization, and you must
  /// not rely on it being called.  When it is called, a number of guarantees
  /// will be made to help optimize configuration switching:
  /// <ul>
  /// <li> The function will be called between \#onStop and
  /// \#onDestroy.
  /// <li> A new instance of the activity will _always_ be immediately
  /// created after this one's \#onDestroy() is called.  In particular,
  /// _no_ messages will be dispatched during this time (when the returned
  /// object does not have an activity to be associated with).
  /// <li> The object you return here will _always_ be available from
  /// the \#getLastNonConfigurationInstance() method of the following
  /// activity instance as described there.
  /// </ul>
  ///
  /// These guarantees are designed so that an activity can use this API
  /// to propagate extensive state from the old to new activity instance, from
  /// loaded bitmaps, to network connections, to evenly actively running
  /// threads.  Note that you should _not_ propagate any data that
  /// may change based on the configuration, including any data loaded from
  /// resources such as strings, layouts, or drawables.
  ///
  /// The guarantee of no message handling during the switch to the next
  /// activity simplifies use with active objects.  For example if your retained
  /// state is an android.os.AsyncTask you are guaranteed that its
  /// call back functions (like android.os.AsyncTask\#onPostExecute) will
  /// not be called from the call here until you execute the next instance's
  /// \#onCreate(Bundle).  (Note however that there is of course no such
  /// guarantee for android.os.AsyncTask\#doInBackground since that is
  /// running in a separate thread.)
  ///
  /// <strong>Note:</strong> For most cases you should use the Fragment API
  /// Fragment\#setRetainInstance(boolean) instead; this is also
  /// available on older platforms through the Android support libraries.
  ///@return any Object holding the desired state to propagate to the
  ///         next activity instance
  jni.JniObject onRetainNonConfigurationInstance() => jni.JniObject.fromRef(
      _onRetainNonConfigurationInstance(reference).object);

  static final _onLowMemory = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onLowMemory")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onLowMemory()
  void onLowMemory() => _onLowMemory(reference).check();

  static final _onTrimMemory = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Activity__onTrimMemory")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onTrimMemory(int level)
  void onTrimMemory(int level) => _onTrimMemory(reference, level).check();

  static final _getFragmentManager = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getFragmentManager")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.FragmentManager getFragmentManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the FragmentManager for interacting with fragments associated
  /// with this activity.
  ///@deprecated Use android.support.v4.app.FragmentActivity\#getSupportFragmentManager()
  FragmentManager getFragmentManager() =>
      FragmentManager.fromRef(_getFragmentManager(reference).object);

  static final _onAttachFragment = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onAttachFragment")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttachFragment(android.app.Fragment fragment)
  ///
  /// Called when a Fragment is being attached to this activity, immediately
  /// after the call to its Fragment\#onAttach Fragment.onAttach()
  /// method and before Fragment\#onCreate Fragment.onCreate().
  ///@deprecated Use android.support.v4.app.FragmentActivity\#onAttachFragment(android.support.v4.app.Fragment)
  void onAttachFragment(Fragment fragment) =>
      _onAttachFragment(reference, fragment.reference).check();

  static final _managedQuery = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__managedQuery")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final android.database.Cursor managedQuery(android.net.Uri uri, java.lang.String[] projection, java.lang.String selection, java.lang.String[] selectionArgs, java.lang.String sortOrder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Wrapper around
  /// ContentResolver\#query(android.net.Uri , String[], String, String[], String)
  /// that gives the resulting Cursor to call
  /// \#startManagingCursor so that the activity will manage its
  /// lifecycle for you.
  ///
  /// _If you are targeting android.os.Build.VERSION_CODES\#HONEYCOMB
  /// or later, consider instead using LoaderManager instead, available
  /// via \#getLoaderManager()._
  ///
  /// <strong>Warning:</strong> Do not call Cursor\#close() on a cursor obtained using
  /// this method, because the activity will do that for you at the appropriate time. However, if
  /// you call \#stopManagingCursor on a cursor from a managed query, the system _will
  /// not_ automatically close the cursor and, in that case, you must call
  /// Cursor\#close().
  ///
  ///@param uri The URI of the content provider to query.
  ///@param projection List of columns to return.
  ///@param selection SQL WHERE clause.
  ///@param selectionArgs The arguments to selection, if any ?s are pesent
  ///@param sortOrder SQL ORDER BY clause.
  ///@return The Cursor that was returned by query().
  ///@see ContentResolver\#query(android.net.Uri , String[], String, String[], String)
  ///@see \#startManagingCursor
  ///@deprecated Use CursorLoader instead.
  jni.JniObject managedQuery(
          jni.JniObject uri,
          jni.JniObject projection,
          jni.JniString selection,
          jni.JniObject selectionArgs,
          jni.JniString sortOrder) =>
      jni.JniObject.fromRef(_managedQuery(
              reference,
              uri.reference,
              projection.reference,
              selection.reference,
              selectionArgs.reference,
              sortOrder.reference)
          .object);

  static final _startManagingCursor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__startManagingCursor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startManagingCursor(android.database.Cursor c)
  ///
  /// This method allows the activity to take care of managing the given
  /// Cursor's lifecycle for you based on the activity's lifecycle.
  /// That is, when the activity is stopped it will automatically call
  /// Cursor\#deactivate on the given Cursor, and when it is later restarted
  /// it will call Cursor\#requery for you.  When the activity is
  /// destroyed, all managed Cursors will be closed automatically.
  ///
  /// _If you are targeting android.os.Build.VERSION_CODES\#HONEYCOMB
  /// or later, consider instead using LoaderManager instead, available
  /// via \#getLoaderManager()._
  ///
  /// <strong>Warning:</strong> Do not call Cursor\#close() on cursor obtained from
  /// \#managedQuery, because the activity will do that for you at the appropriate time.
  /// However, if you call \#stopManagingCursor on a cursor from a managed query, the system
  /// _will not_ automatically close the cursor and, in that case, you must call
  /// Cursor\#close().
  ///
  ///@param c The Cursor to be managed.
  ///@see \#managedQuery(android.net.Uri , String[], String, String[], String)
  ///@see \#stopManagingCursor
  ///@deprecated Use the new android.content.CursorLoader class with
  /// LoaderManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  void startManagingCursor(jni.JniObject c) =>
      _startManagingCursor(reference, c.reference).check();

  static final _stopManagingCursor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__stopManagingCursor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void stopManagingCursor(android.database.Cursor c)
  ///
  /// Given a Cursor that was previously given to
  /// \#startManagingCursor, stop the activity's management of that
  /// cursor.
  ///
  /// <strong>Warning:</strong> After calling this method on a cursor from a managed query,
  /// the system _will not_ automatically close the cursor and you must call
  /// Cursor\#close().
  ///
  ///@param c The Cursor that was being managed.
  ///@see \#startManagingCursor
  ///@deprecated Use the new android.content.CursorLoader class with
  /// LoaderManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  void stopManagingCursor(jni.JniObject c) =>
      _stopManagingCursor(reference, c.reference).check();

  static final _getActionBar = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getActionBar")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.ActionBar getActionBar()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a reference to this activity's ActionBar.
  ///@return The Activity's ActionBar, or null if it does not have one.
  ActionBar getActionBar() =>
      ActionBar.fromRef(_getActionBar(reference).object);

  static final _setActionBar = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__setActionBar")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setActionBar(android.widget.Toolbar toolbar)
  ///
  /// Set a android.widget.Toolbar Toolbar to act as the ActionBar for this
  /// Activity window.
  ///
  /// When set to a non-null value the \#getActionBar() method will return
  /// an ActionBar object that can be used to control the given toolbar as if it were
  /// a traditional window decor action bar. The toolbar's menu will be populated with the
  /// Activity's options menu and the navigation button will be wired through the standard
  /// android.R.id\#home home menu select action.
  ///
  ///
  /// In order to use a Toolbar within the Activity's window content the application
  /// must not request the window feature Window\#FEATURE_ACTION_BAR FEATURE_ACTION_BAR.
  ///
  ///@param toolbar Toolbar to set as the Activity's action bar, or {@code null} to clear it
  ///
  /// This value may be {@code null}.
  void setActionBar(jni.JniObject toolbar) =>
      _setActionBar(reference, toolbar.reference).check();

  static final _setContentView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__setContentView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setContentView(int layoutResID)
  ///
  /// Set the activity content from a layout resource.  The resource will be
  /// inflated, adding all top-level views to the activity.
  ///@param layoutResID Resource ID to be inflated.
  ///@see \#setContentView(android.view.View)
  ///@see \#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
  void setContentView(int layoutResID) =>
      _setContentView(reference, layoutResID).check();

  static final _setContentView1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__setContentView1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setContentView(android.view.View view)
  ///
  /// Set the activity content to an explicit view.  This view is placed
  /// directly into the activity's view hierarchy.  It can itself be a complex
  /// view hierarchy.  When calling this method, the layout parameters of the
  /// specified view are ignored.  Both the width and the height of the view are
  /// set by default to ViewGroup.LayoutParams\#MATCH_PARENT. To use
  /// your own layout parameters, invoke
  /// \#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
  /// instead.
  ///@param view The desired content to display.
  ///@see \#setContentView(int)
  ///@see \#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
  void setContentView1(jni.JniObject view) =>
      _setContentView1(reference, view.reference).check();

  static final _setContentView2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__setContentView2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setContentView(android.view.View view, android.view.ViewGroup.LayoutParams params)
  ///
  /// Set the activity content to an explicit view.  This view is placed
  /// directly into the activity's view hierarchy.  It can itself be a complex
  /// view hierarchy.
  ///@param view The desired content to display.
  ///@param params Layout parameters for the view.
  ///@see \#setContentView(android.view.View)
  ///@see \#setContentView(int)
  void setContentView2(jni.JniObject view, jni.JniObject params) =>
      _setContentView2(reference, view.reference, params.reference).check();

  static final _addContentView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__addContentView")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void addContentView(android.view.View view, android.view.ViewGroup.LayoutParams params)
  ///
  /// Add an additional content view to the activity.  Added after any existing
  /// ones in the activity -- existing views are NOT removed.
  ///@param view The desired content to display.
  ///@param params Layout parameters for the view.
  void addContentView(jni.JniObject view, jni.JniObject params) =>
      _addContentView(reference, view.reference, params.reference).check();

  static final _getContentTransitionManager = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Activity__getContentTransitionManager")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.transition.TransitionManager getContentTransitionManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the TransitionManager responsible for default transitions in this window.
  /// Requires Window\#FEATURE_CONTENT_TRANSITIONS.
  ///
  /// This method will return non-null after content has been initialized (e.g. by using
  /// \#setContentView) if Window\#FEATURE_CONTENT_TRANSITIONS has been granted.
  ///
  ///@return This window's content TransitionManager or null if none is set.
  jni.JniObject getContentTransitionManager() =>
      jni.JniObject.fromRef(_getContentTransitionManager(reference).object);

  static final _setContentTransitionManager = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Activity__setContentTransitionManager")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setContentTransitionManager(android.transition.TransitionManager tm)
  ///
  /// Set the TransitionManager to use for default transitions in this window.
  /// Requires Window\#FEATURE_CONTENT_TRANSITIONS.
  ///@param tm The TransitionManager to use for scene changes.
  void setContentTransitionManager(jni.JniObject tm) =>
      _setContentTransitionManager(reference, tm.reference).check();

  static final _getContentScene = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getContentScene")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.transition.Scene getContentScene()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the Scene representing this window's current content.
  /// Requires Window\#FEATURE_CONTENT_TRANSITIONS.
  ///
  /// This method will return null if the current content is not represented by a Scene.
  ///
  ///@return Current Scene being shown or null
  jni.JniObject getContentScene() =>
      jni.JniObject.fromRef(_getContentScene(reference).object);

  static final _setFinishOnTouchOutside = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Activity__setFinishOnTouchOutside")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setFinishOnTouchOutside(boolean finish)
  ///
  /// Sets whether this activity is finished when touched outside its window's
  /// bounds.
  void setFinishOnTouchOutside(bool finish) =>
      _setFinishOnTouchOutside(reference, finish ? 1 : 0).check();

  static final _setDefaultKeyMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__setDefaultKeyMode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setDefaultKeyMode(int mode)
  ///
  /// Select the default key handling for this activity.  This controls what
  /// will happen to key events that are not otherwise handled.  The default
  /// mode (\#DEFAULT_KEYS_DISABLE) will simply drop them on the
  /// floor. Other modes allow you to launch the dialer
  /// (\#DEFAULT_KEYS_DIALER), execute a shortcut in your options
  /// menu without requiring the menu key be held down
  /// (\#DEFAULT_KEYS_SHORTCUT), or launch a search (\#DEFAULT_KEYS_SEARCH_LOCAL
  /// and \#DEFAULT_KEYS_SEARCH_GLOBAL).
  ///
  /// Note that the mode selected here does not impact the default
  /// handling of system keys, such as the "back" and "menu" keys, and your
  /// activity and its views always get a first chance to receive and handle
  /// all application keys.
  ///@param mode The desired default key mode constant.
  ///
  /// Value is android.app.Activity\#DEFAULT_KEYS_DISABLE, android.app.Activity\#DEFAULT_KEYS_DIALER, android.app.Activity\#DEFAULT_KEYS_SHORTCUT, android.app.Activity\#DEFAULT_KEYS_SEARCH_LOCAL, or android.app.Activity\#DEFAULT_KEYS_SEARCH_GLOBAL
  ///@see \#onKeyDown
  void setDefaultKeyMode(int mode) =>
      _setDefaultKeyMode(reference, mode).check();

  static final _onKeyDown = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__onKeyDown")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyDown(int keyCode, android.view.KeyEvent event)
  ///
  /// Called when a key was pressed down and not handled by any of the views
  /// inside of the activity. So, for example, key presses while the cursor
  /// is inside a TextView will not trigger the event (unless it is a navigation
  /// to another object) because TextView handles its own key presses.
  ///
  /// If the focused view didn't want this event, this method is called.
  ///
  /// The default implementation takes care of KeyEvent\#KEYCODE_BACK
  /// by calling \#onBackPressed(), though the behavior varies based
  /// on the application compatibility mode: for
  /// android.os.Build.VERSION_CODES\#ECLAIR or later applications,
  /// it will set up the dispatch to call \#onKeyUp where the action
  /// will be performed; for earlier applications, it will perform the
  /// action immediately in on-down, as those versions of the platform
  /// behaved.
  ///
  /// Other additional default key handling may be performed
  /// if configured with \#setDefaultKeyMode.
  ///@return Return <code>true</code> to prevent this event from being propagated
  /// further, or <code>false</code> to indicate that you have not handled
  /// this event and it should continue to be propagated.
  ///@see \#onKeyUp
  ///@see android.view.KeyEvent
  bool onKeyDown(int keyCode, jni.JniObject event) =>
      _onKeyDown(reference, keyCode, event.reference).boolean;

  static final _onKeyLongPress = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__onKeyLongPress")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyLongPress(int keyCode, android.view.KeyEvent event)
  ///
  /// Default implementation of KeyEvent.Callback\#onKeyLongPress(int, KeyEvent) KeyEvent.Callback.onKeyLongPress(): always returns false (doesn't handle
  /// the event).
  bool onKeyLongPress(int keyCode, jni.JniObject event) =>
      _onKeyLongPress(reference, keyCode, event.reference).boolean;

  static final _onKeyUp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__onKeyUp")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyUp(int keyCode, android.view.KeyEvent event)
  ///
  /// Called when a key was released and not handled by any of the views
  /// inside of the activity. So, for example, key presses while the cursor
  /// is inside a TextView will not trigger the event (unless it is a navigation
  /// to another object) because TextView handles its own key presses.
  ///
  /// The default implementation handles KEYCODE_BACK to stop the activity
  /// and go back.
  ///@return Return <code>true</code> to prevent this event from being propagated
  /// further, or <code>false</code> to indicate that you have not handled
  /// this event and it should continue to be propagated.
  ///@see \#onKeyDown
  ///@see KeyEvent
  bool onKeyUp(int keyCode, jni.JniObject event) =>
      _onKeyUp(reference, keyCode, event.reference).boolean;

  static final _onKeyMultiple = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Pointer<ffi.Void>)>>("Activity__onKeyMultiple")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyMultiple(int keyCode, int repeatCount, android.view.KeyEvent event)
  ///
  /// Default implementation of KeyEvent.Callback\#onKeyMultiple(int, int, KeyEvent) KeyEvent.Callback.onKeyMultiple(): always returns false (doesn't handle
  /// the event).
  bool onKeyMultiple(int keyCode, int repeatCount, jni.JniObject event) =>
      _onKeyMultiple(reference, keyCode, repeatCount, event.reference).boolean;

  static final _onBackPressed = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onBackPressed")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onBackPressed()
  ///
  /// Called when the activity has detected the user's press of the back
  /// key.  The default implementation simply finishes the current activity,
  /// but you can override this to do whatever you want.
  void onBackPressed() => _onBackPressed(reference).check();

  static final _onKeyShortcut = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__onKeyShortcut")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyShortcut(int keyCode, android.view.KeyEvent event)
  ///
  /// Called when a key shortcut event is not handled by any of the views in the Activity.
  /// Override this method to implement global key shortcuts for the Activity.
  /// Key shortcuts can also be implemented by setting the
  /// MenuItem\#setShortcut(char, char) shortcut property of menu items.
  ///@param keyCode The value in event.getKeyCode().
  ///@param event Description of the key event.
  ///@return True if the key shortcut was handled.
  bool onKeyShortcut(int keyCode, jni.JniObject event) =>
      _onKeyShortcut(reference, keyCode, event.reference).boolean;

  static final _onTouchEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onTouchEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onTouchEvent(android.view.MotionEvent event)
  ///
  /// Called when a touch screen event was not handled by any of the views
  /// under it.  This is most useful to process touch events that happen
  /// outside of your window bounds, where there is no view to receive it.
  ///@param event The touch screen event being processed.
  ///@return Return true if you have consumed the event, false if you haven't.
  /// The default implementation always returns false.
  bool onTouchEvent(jni.JniObject event) =>
      _onTouchEvent(reference, event.reference).boolean;

  static final _onTrackballEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onTrackballEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onTrackballEvent(android.view.MotionEvent event)
  ///
  /// Called when the trackball was moved and not handled by any of the
  /// views inside of the activity.  So, for example, if the trackball moves
  /// while focus is on a button, you will receive a call here because
  /// buttons do not normally do anything with trackball events.  The call
  /// here happens _before_ trackball movements are converted to
  /// DPAD key events, which then get sent back to the view hierarchy, and
  /// will be processed at the point for things like focus navigation.
  ///@param event The trackball event being processed.
  ///@return Return true if you have consumed the event, false if you haven't.
  /// The default implementation always returns false.
  bool onTrackballEvent(jni.JniObject event) =>
      _onTrackballEvent(reference, event.reference).boolean;

  static final _onGenericMotionEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onGenericMotionEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onGenericMotionEvent(android.view.MotionEvent event)
  ///
  /// Called when a generic motion event was not handled by any of the
  /// views inside of the activity.
  ///
  /// Generic motion events describe joystick movements, mouse hovers, track pad
  /// touches, scroll wheel movements and other input events.  The
  /// MotionEvent\#getSource() source of the motion event specifies
  /// the class of input that was received.  Implementations of this method
  /// must examine the bits in the source before processing the event.
  /// The following code example shows how this is done.
  ///
  ///
  /// Generic motion events with source class
  /// android.view.InputDevice\#SOURCE_CLASS_POINTER
  /// are delivered to the view under the pointer.  All other generic motion events are
  /// delivered to the focused view.
  ///
  ///
  /// See View\#onGenericMotionEvent(MotionEvent) for an example of how to
  /// handle this event.
  ///
  ///
  ///@param event The generic motion event being processed.
  ///@return Return true if you have consumed the event, false if you haven't.
  /// The default implementation always returns false.
  bool onGenericMotionEvent(jni.JniObject event) =>
      _onGenericMotionEvent(reference, event.reference).boolean;

  static final _onUserInteraction = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onUserInteraction")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onUserInteraction()
  ///
  /// Called whenever a key, touch, or trackball event is dispatched to the
  /// activity.  Implement this method if you wish to know that the user has
  /// interacted with the device in some way while your activity is running.
  /// This callback and \#onUserLeaveHint are intended to help
  /// activities manage status bar notifications intelligently; specifically,
  /// for helping activities determine the proper time to cancel a notfication.
  ///
  /// All calls to your activity's \#onUserLeaveHint callback will
  /// be accompanied by calls to \#onUserInteraction.  This
  /// ensures that your activity will be told of relevant user activity such
  /// as pulling down the notification pane and touching an item there.
  ///
  /// Note that this callback will be invoked for the touch down action
  /// that begins a touch gesture, but may not be invoked for the touch-moved
  /// and touch-up actions that follow.
  ///@see \#onUserLeaveHint()
  void onUserInteraction() => _onUserInteraction(reference).check();

  static final _onWindowAttributesChanged = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Activity__onWindowAttributesChanged")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onWindowAttributesChanged(android.view.WindowManager.LayoutParams params)
  void onWindowAttributesChanged(jni.JniObject params) =>
      _onWindowAttributesChanged(reference, params.reference).check();

  static final _onContentChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onContentChanged")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onContentChanged()
  void onContentChanged() => _onContentChanged(reference).check();

  static final _onWindowFocusChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Activity__onWindowFocusChanged")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onWindowFocusChanged(boolean hasFocus)
  ///
  /// Called when the current Window of the activity gains or loses
  /// focus.  This is the best indicator of whether this activity is visible
  /// to the user.  The default implementation clears the key tracking
  /// state, so should always be called.
  ///
  /// Note that this provides information about global focus state, which
  /// is managed independently of activity lifecycles.  As such, while focus
  /// changes will generally have some relation to lifecycle changes (an
  /// activity that is stopped will not generally get window focus), you
  /// should not rely on any particular order between the callbacks here and
  /// those in the other lifecycle methods such as \#onResume.
  ///
  /// As a general rule, however, a resumed activity will have window
  /// focus...  unless it has displayed other dialogs or popups that take
  /// input focus, in which case the activity itself will not have focus
  /// when the other windows have it.  Likewise, the system may display
  /// system-level windows (such as the status bar notification panel or
  /// a system alert) which will temporarily take window input focus without
  /// pausing the foreground activity.
  ///@param hasFocus Whether the window of this activity has focus.
  ///@see \#hasWindowFocus()
  ///@see \#onResume
  ///@see View\#onWindowFocusChanged(boolean)
  void onWindowFocusChanged(bool hasFocus) =>
      _onWindowFocusChanged(reference, hasFocus ? 1 : 0).check();

  static final _onAttachedToWindow = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onAttachedToWindow")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttachedToWindow()
  ///
  /// Called when the main window associated with the activity has been
  /// attached to the window manager.
  /// See View\#onAttachedToWindow() View.onAttachedToWindow()
  /// for more information.
  ///@see View\#onAttachedToWindow
  void onAttachedToWindow() => _onAttachedToWindow(reference).check();

  static final _onDetachedFromWindow = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onDetachedFromWindow")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDetachedFromWindow()
  ///
  /// Called when the main window associated with the activity has been
  /// detached from the window manager.
  /// See View\#onDetachedFromWindow() View.onDetachedFromWindow()
  /// for more information.
  ///@see View\#onDetachedFromWindow
  void onDetachedFromWindow() => _onDetachedFromWindow(reference).check();

  static final _hasWindowFocus = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__hasWindowFocus")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasWindowFocus()
  ///
  /// Returns true if this activity's _main_ window currently has window focus.
  /// Note that this is not the same as the view itself having focus.
  ///@return True if this activity's main window currently has window focus.
  ///@see \#onWindowAttributesChanged(android.view.WindowManager.LayoutParams)
  bool hasWindowFocus() => _hasWindowFocus(reference).boolean;

  static final _dispatchKeyEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__dispatchKeyEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchKeyEvent(android.view.KeyEvent event)
  ///
  /// Called to process key events.  You can override this to intercept all
  /// key events before they are dispatched to the window.  Be sure to call
  /// this implementation for key events that should be handled normally.
  ///@param event The key event.
  ///@return boolean Return true if this event was consumed.
  bool dispatchKeyEvent(jni.JniObject event) =>
      _dispatchKeyEvent(reference, event.reference).boolean;

  static final _dispatchKeyShortcutEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__dispatchKeyShortcutEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchKeyShortcutEvent(android.view.KeyEvent event)
  ///
  /// Called to process a key shortcut event.
  /// You can override this to intercept all key shortcut events before they are
  /// dispatched to the window.  Be sure to call this implementation for key shortcut
  /// events that should be handled normally.
  ///@param event The key shortcut event.
  ///@return True if this event was consumed.
  bool dispatchKeyShortcutEvent(jni.JniObject event) =>
      _dispatchKeyShortcutEvent(reference, event.reference).boolean;

  static final _dispatchTouchEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__dispatchTouchEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchTouchEvent(android.view.MotionEvent ev)
  ///
  /// Called to process touch screen events.  You can override this to
  /// intercept all touch screen events before they are dispatched to the
  /// window.  Be sure to call this implementation for touch screen events
  /// that should be handled normally.
  ///@param ev The touch screen event.
  ///@return boolean Return true if this event was consumed.
  bool dispatchTouchEvent(jni.JniObject ev) =>
      _dispatchTouchEvent(reference, ev.reference).boolean;

  static final _dispatchTrackballEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__dispatchTrackballEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchTrackballEvent(android.view.MotionEvent ev)
  ///
  /// Called to process trackball events.  You can override this to
  /// intercept all trackball events before they are dispatched to the
  /// window.  Be sure to call this implementation for trackball events
  /// that should be handled normally.
  ///@param ev The trackball event.
  ///@return boolean Return true if this event was consumed.
  bool dispatchTrackballEvent(jni.JniObject ev) =>
      _dispatchTrackballEvent(reference, ev.reference).boolean;

  static final _dispatchGenericMotionEvent = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Activity__dispatchGenericMotionEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchGenericMotionEvent(android.view.MotionEvent ev)
  ///
  /// Called to process generic motion events.  You can override this to
  /// intercept all generic motion events before they are dispatched to the
  /// window.  Be sure to call this implementation for generic motion events
  /// that should be handled normally.
  ///@param ev The generic motion event.
  ///@return boolean Return true if this event was consumed.
  bool dispatchGenericMotionEvent(jni.JniObject ev) =>
      _dispatchGenericMotionEvent(reference, ev.reference).boolean;

  static final _dispatchPopulateAccessibilityEvent = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Activity__dispatchPopulateAccessibilityEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)
  bool dispatchPopulateAccessibilityEvent(jni.JniObject event) =>
      _dispatchPopulateAccessibilityEvent(reference, event.reference).boolean;

  static final _onCreatePanelView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__onCreatePanelView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.View onCreatePanelView(int featureId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Default implementation of
  /// android.view.Window.Callback\#onCreatePanelView
  /// for activities. This
  /// simply returns null so that all panel sub-windows will have the default
  /// menu behavior.
  jni.JniObject onCreatePanelView(int featureId) =>
      jni.JniObject.fromRef(_onCreatePanelView(reference, featureId).object);

  static final _onCreatePanelMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__onCreatePanelMenu")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onCreatePanelMenu(int featureId, android.view.Menu menu)
  ///
  /// Default implementation of
  /// android.view.Window.Callback\#onCreatePanelMenu
  /// for activities.  This calls through to the new
  /// \#onCreateOptionsMenu method for the
  /// android.view.Window\#FEATURE_OPTIONS_PANEL panel,
  /// so that subclasses of Activity don't need to deal with feature codes.
  bool onCreatePanelMenu(int featureId, jni.JniObject menu) =>
      _onCreatePanelMenu(reference, featureId, menu.reference).boolean;

  static final _onPreparePanel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onPreparePanel")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onPreparePanel(int featureId, android.view.View view, android.view.Menu menu)
  ///
  /// Default implementation of
  /// android.view.Window.Callback\#onPreparePanel
  /// for activities.  This
  /// calls through to the new \#onPrepareOptionsMenu method for the
  /// android.view.Window\#FEATURE_OPTIONS_PANEL
  /// panel, so that subclasses of
  /// Activity don't need to deal with feature codes.
  bool onPreparePanel(int featureId, jni.JniObject view, jni.JniObject menu) =>
      _onPreparePanel(reference, featureId, view.reference, menu.reference)
          .boolean;

  static final _onMenuOpened = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__onMenuOpened")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onMenuOpened(int featureId, android.view.Menu menu)
  ///
  /// {@inheritDoc}
  ///@return The default implementation returns true.
  bool onMenuOpened(int featureId, jni.JniObject menu) =>
      _onMenuOpened(reference, featureId, menu.reference).boolean;

  static final _onMenuItemSelected = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__onMenuItemSelected")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onMenuItemSelected(int featureId, android.view.MenuItem item)
  ///
  /// Default implementation of
  /// android.view.Window.Callback\#onMenuItemSelected
  /// for activities.  This calls through to the new
  /// \#onOptionsItemSelected method for the
  /// android.view.Window\#FEATURE_OPTIONS_PANEL
  /// panel, so that subclasses of
  /// Activity don't need to deal with feature codes.
  bool onMenuItemSelected(int featureId, jni.JniObject item) =>
      _onMenuItemSelected(reference, featureId, item.reference).boolean;

  static final _onPanelClosed = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__onPanelClosed")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPanelClosed(int featureId, android.view.Menu menu)
  ///
  /// Default implementation of
  /// android.view.Window.Callback\#onPanelClosed(int, Menu) for
  /// activities. This calls through to \#onOptionsMenuClosed(Menu)
  /// method for the android.view.Window\#FEATURE_OPTIONS_PANEL panel,
  /// so that subclasses of Activity don't need to deal with feature codes.
  /// For context menus (Window\#FEATURE_CONTEXT_MENU), the
  /// \#onContextMenuClosed(Menu) will be called.
  void onPanelClosed(int featureId, jni.JniObject menu) =>
      _onPanelClosed(reference, featureId, menu.reference).check();

  static final _invalidateOptionsMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__invalidateOptionsMenu")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void invalidateOptionsMenu()
  ///
  /// Declare that the options menu has changed, so should be recreated.
  /// The \#onCreateOptionsMenu(Menu) method will be called the next
  /// time it needs to be displayed.
  void invalidateOptionsMenu() => _invalidateOptionsMenu(reference).check();

  static final _onCreateOptionsMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onCreateOptionsMenu")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onCreateOptionsMenu(android.view.Menu menu)
  ///
  /// Initialize the contents of the Activity's standard options menu.  You
  /// should place your menu items in to <var>menu</var>.
  ///
  /// This is only called once, the first time the options menu is
  /// displayed.  To update the menu every time it is displayed, see
  /// \#onPrepareOptionsMenu.
  ///
  /// The default implementation populates the menu with standard system
  /// menu items.  These are placed in the Menu\#CATEGORY_SYSTEM group so that
  /// they will be correctly ordered with application-defined menu items.
  /// Deriving classes should always call through to the base implementation.
  ///
  /// You can safely hold on to <var>menu</var> (and any items created
  /// from it), making modifications to it as desired, until the next
  /// time onCreateOptionsMenu() is called.
  ///
  /// When you add items to the menu, you can implement the Activity's
  /// \#onOptionsItemSelected method to handle them there.
  ///@param menu The options menu in which you place your items.
  ///@return You must return true for the menu to be displayed;
  ///         if you return false it will not be shown.
  ///@see \#onPrepareOptionsMenu
  ///@see \#onOptionsItemSelected
  bool onCreateOptionsMenu(jni.JniObject menu) =>
      _onCreateOptionsMenu(reference, menu.reference).boolean;

  static final _onPrepareOptionsMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onPrepareOptionsMenu")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onPrepareOptionsMenu(android.view.Menu menu)
  ///
  /// Prepare the Screen's standard options menu to be displayed.  This is
  /// called right before the menu is shown, every time it is shown.  You can
  /// use this method to efficiently enable/disable items or otherwise
  /// dynamically modify the contents.
  ///
  /// The default implementation updates the system menu items based on the
  /// activity's state.  Deriving classes should always call through to the
  /// base class implementation.
  ///@param menu The options menu as last shown or first initialized by
  ///             onCreateOptionsMenu().
  ///@return You must return true for the menu to be displayed;
  ///         if you return false it will not be shown.
  ///@see \#onCreateOptionsMenu
  bool onPrepareOptionsMenu(jni.JniObject menu) =>
      _onPrepareOptionsMenu(reference, menu.reference).boolean;

  static final _onOptionsItemSelected = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onOptionsItemSelected")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onOptionsItemSelected(android.view.MenuItem item)
  ///
  /// This hook is called whenever an item in your options menu is selected.
  /// The default implementation simply returns false to have the normal
  /// processing happen (calling the item's Runnable or sending a message to
  /// its Handler as appropriate).  You can use this method for any items
  /// for which you would like to do processing without those other
  /// facilities.
  ///
  /// Derived classes should call through to the base class for it to
  /// perform the default menu handling.
  ///
  ///@param item The menu item that was selected.
  ///@return boolean Return false to allow normal menu processing to
  ///         proceed, true to consume it here.
  ///@see \#onCreateOptionsMenu
  bool onOptionsItemSelected(jni.JniObject item) =>
      _onOptionsItemSelected(reference, item.reference).boolean;

  static final _onNavigateUp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onNavigateUp")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onNavigateUp()
  ///
  /// This method is called whenever the user chooses to navigate Up within your application's
  /// activity hierarchy from the action bar.
  ///
  /// If the attribute android.R.attr\#parentActivityName parentActivityName
  /// was specified in the manifest for this activity or an activity-alias to it,
  /// default Up navigation will be handled automatically. If any activity
  /// along the parent chain requires extra Intent arguments, the Activity subclass
  /// should override the method \#onPrepareNavigateUpTaskStack(TaskStackBuilder)
  /// to supply those arguments.
  ///
  ///
  /// See <a href="{@docRoot}guide/components/tasks-and-back-stack.html">Tasks and Back Stack</a>
  /// from the developer guide and <a href="{@docRoot}design/patterns/navigation.html">Navigation</a>
  /// from the design guide for more information about navigating within your app.
  ///
  ///
  /// See the TaskStackBuilder class and the Activity methods
  /// \#getParentActivityIntent(), \#shouldUpRecreateTask(Intent), and
  /// \#navigateUpTo(Intent) for help implementing custom Up navigation.
  /// The AppNavigation sample application in the Android SDK is also available for reference.
  ///
  ///@return true if Up navigation completed successfully and this Activity was finished,
  ///         false otherwise.
  bool onNavigateUp() => _onNavigateUp(reference).boolean;

  static final _onNavigateUpFromChild = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onNavigateUpFromChild")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onNavigateUpFromChild(android.app.Activity child)
  ///
  /// This is called when a child activity of this one attempts to navigate up.
  /// The default implementation simply calls onNavigateUp() on this activity (the parent).
  ///@param child The activity making the call.
  bool onNavigateUpFromChild(Activity child) =>
      _onNavigateUpFromChild(reference, child.reference).boolean;

  static final _onCreateNavigateUpTaskStack = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Activity__onCreateNavigateUpTaskStack")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreateNavigateUpTaskStack(android.app.TaskStackBuilder builder)
  ///
  /// Define the synthetic task stack that will be generated during Up navigation from
  /// a different task.
  ///
  /// The default implementation of this method adds the parent chain of this activity
  /// as specified in the manifest to the supplied TaskStackBuilder. Applications
  /// may choose to override this method to construct the desired task stack in a different
  /// way.
  ///
  ///
  /// This method will be invoked by the default implementation of \#onNavigateUp()
  /// if \#shouldUpRecreateTask(Intent) returns true when supplied with the intent
  /// returned by \#getParentActivityIntent().
  ///
  ///
  /// Applications that wish to supply extra Intent parameters to the parent stack defined
  /// by the manifest should override \#onPrepareNavigateUpTaskStack(TaskStackBuilder).
  ///
  ///@param builder An empty TaskStackBuilder - the application should add intents representing
  ///                the desired task stack
  void onCreateNavigateUpTaskStack(TaskStackBuilder builder) =>
      _onCreateNavigateUpTaskStack(reference, builder.reference).check();

  static final _onPrepareNavigateUpTaskStack = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Activity__onPrepareNavigateUpTaskStack")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPrepareNavigateUpTaskStack(android.app.TaskStackBuilder builder)
  ///
  /// Prepare the synthetic task stack that will be generated during Up navigation
  /// from a different task.
  ///
  /// This method receives the TaskStackBuilder with the constructed series of
  /// Intents as generated by \#onCreateNavigateUpTaskStack(TaskStackBuilder).
  /// If any extra data should be added to these intents before launching the new task,
  /// the application should override this method and add that data here.
  ///
  ///@param builder A TaskStackBuilder that has been populated with Intents by
  ///                onCreateNavigateUpTaskStack.
  void onPrepareNavigateUpTaskStack(TaskStackBuilder builder) =>
      _onPrepareNavigateUpTaskStack(reference, builder.reference).check();

  static final _onOptionsMenuClosed = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onOptionsMenuClosed")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onOptionsMenuClosed(android.view.Menu menu)
  ///
  /// This hook is called whenever the options menu is being closed (either by the user canceling
  /// the menu with the back/menu button, or when an item is selected).
  ///@param menu The options menu as last shown or first initialized by
  ///             onCreateOptionsMenu().
  void onOptionsMenuClosed(jni.JniObject menu) =>
      _onOptionsMenuClosed(reference, menu.reference).check();

  static final _openOptionsMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__openOptionsMenu")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void openOptionsMenu()
  ///
  /// Programmatically opens the options menu. If the options menu is already
  /// open, this method does nothing.
  void openOptionsMenu() => _openOptionsMenu(reference).check();

  static final _closeOptionsMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__closeOptionsMenu")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void closeOptionsMenu()
  ///
  /// Progammatically closes the options menu. If the options menu is already
  /// closed, this method does nothing.
  void closeOptionsMenu() => _closeOptionsMenu(reference).check();

  static final _onCreateContextMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onCreateContextMenu")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreateContextMenu(android.view.ContextMenu menu, android.view.View v, android.view.ContextMenu.ContextMenuInfo menuInfo)
  ///
  /// Called when a context menu for the {@code view} is about to be shown.
  /// Unlike \#onCreateOptionsMenu(Menu), this will be called every
  /// time the context menu is about to be shown and should be populated for
  /// the view (or item inside the view for AdapterView subclasses,
  /// this can be found in the {@code menuInfo})).
  ///
  /// Use \#onContextItemSelected(android.view.MenuItem) to know when an
  /// item has been selected.
  ///
  /// It is not safe to hold onto the context menu after this method returns.
  void onCreateContextMenu(
          jni.JniObject menu, jni.JniObject v, jni.JniObject menuInfo) =>
      _onCreateContextMenu(
              reference, menu.reference, v.reference, menuInfo.reference)
          .check();

  static final _registerForContextMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__registerForContextMenu")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerForContextMenu(android.view.View view)
  ///
  /// Registers a context menu to be shown for the given view (multiple views
  /// can show the context menu). This method will set the
  /// OnCreateContextMenuListener on the view to this activity, so
  /// \#onCreateContextMenu(ContextMenu, View, ContextMenuInfo) will be
  /// called when it is time to show the context menu.
  ///@see \#unregisterForContextMenu(View)
  ///@param view The view that should show a context menu.
  void registerForContextMenu(jni.JniObject view) =>
      _registerForContextMenu(reference, view.reference).check();

  static final _unregisterForContextMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__unregisterForContextMenu")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterForContextMenu(android.view.View view)
  ///
  /// Prevents a context menu to be shown for the given view. This method will remove the
  /// OnCreateContextMenuListener on the view.
  ///@see \#registerForContextMenu(View)
  ///@param view The view that should stop showing a context menu.
  void unregisterForContextMenu(jni.JniObject view) =>
      _unregisterForContextMenu(reference, view.reference).check();

  static final _openContextMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__openContextMenu")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void openContextMenu(android.view.View view)
  ///
  /// Programmatically opens the context menu for a particular {@code view}.
  /// The {@code view} should have been added via
  /// \#registerForContextMenu(View).
  ///@param view The view to show the context menu for.
  void openContextMenu(jni.JniObject view) =>
      _openContextMenu(reference, view.reference).check();

  static final _closeContextMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__closeContextMenu")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void closeContextMenu()
  ///
  /// Programmatically closes the most recently opened context menu, if showing.
  void closeContextMenu() => _closeContextMenu(reference).check();

  static final _onContextItemSelected = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onContextItemSelected")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onContextItemSelected(android.view.MenuItem item)
  ///
  /// This hook is called whenever an item in a context menu is selected. The
  /// default implementation simply returns false to have the normal processing
  /// happen (calling the item's Runnable or sending a message to its Handler
  /// as appropriate). You can use this method for any items for which you
  /// would like to do processing without those other facilities.
  ///
  /// Use MenuItem\#getMenuInfo() to get extra information set by the
  /// View that added this menu item.
  ///
  /// Derived classes should call through to the base class for it to perform
  /// the default menu handling.
  ///@param item The context menu item that was selected.
  ///@return boolean Return false to allow normal context menu processing to
  ///         proceed, true to consume it here.
  bool onContextItemSelected(jni.JniObject item) =>
      _onContextItemSelected(reference, item.reference).boolean;

  static final _onContextMenuClosed = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onContextMenuClosed")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onContextMenuClosed(android.view.Menu menu)
  ///
  /// This hook is called whenever the context menu is being closed (either by
  /// the user canceling the menu with the back/menu button, or when an item is
  /// selected).
  ///@param menu The context menu that is being closed.
  void onContextMenuClosed(jni.JniObject menu) =>
      _onContextMenuClosed(reference, menu.reference).check();

  static final _onCreateDialog = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__onCreateDialog")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: protected android.app.Dialog onCreateDialog(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Old no-arguments version of \#onCreateDialog(int, Bundle).
  Dialog onCreateDialog(int id) =>
      Dialog.fromRef(_onCreateDialog(reference, id).object);

  static final _onCreateDialog1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__onCreateDialog1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: protected android.app.Dialog onCreateDialog(int id, android.os.Bundle args)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Callback for creating dialogs that are managed (saved and restored) for you
  /// by the activity.  The default implementation calls through to
  /// \#onCreateDialog(int) for compatibility.
  ///
  /// _If you are targeting android.os.Build.VERSION_CODES\#HONEYCOMB
  /// or later, consider instead using a DialogFragment instead._
  ///
  /// If you use \#showDialog(int), the activity will call through to
  /// this method the first time, and hang onto it thereafter.  Any dialog
  /// that is created by this method will automatically be saved and restored
  /// for you, including whether it is showing.
  ///
  /// If you would like the activity to manage saving and restoring dialogs
  /// for you, you should override this method and handle any ids that are
  /// passed to \#showDialog.
  ///
  /// If you would like an opportunity to prepare your dialog before it is shown,
  /// override \#onPrepareDialog(int, Dialog, Bundle).
  ///@param id The id of the dialog.
  ///@param args The dialog arguments provided to \#showDialog(int, Bundle).
  ///@return The dialog.  If you return null, the dialog will not be created.
  ///@see \#onPrepareDialog(int, Dialog, Bundle)
  ///@see \#showDialog(int, Bundle)
  ///@see \#dismissDialog(int)
  ///@see \#removeDialog(int)
  ///@deprecated Use the new DialogFragment class with
  /// FragmentManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  Dialog onCreateDialog1(int id, os_.Bundle args) =>
      Dialog.fromRef(_onCreateDialog1(reference, id, args.reference).object);

  static final _onPrepareDialog = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__onPrepareDialog")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPrepareDialog(int id, android.app.Dialog dialog)
  ///
  /// @deprecated Old no-arguments version of
  /// \#onPrepareDialog(int, Dialog, Bundle).
  void onPrepareDialog(int id, Dialog dialog) =>
      _onPrepareDialog(reference, id, dialog.reference).check();

  static final _onPrepareDialog1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onPrepareDialog1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPrepareDialog(int id, android.app.Dialog dialog, android.os.Bundle args)
  ///
  /// Provides an opportunity to prepare a managed dialog before it is being
  /// shown.  The default implementation calls through to
  /// \#onPrepareDialog(int, Dialog) for compatibility.
  ///
  ///
  /// Override this if you need to update a managed dialog based on the state
  /// of the application each time it is shown. For example, a time picker
  /// dialog might want to be updated with the current time. You should call
  /// through to the superclass's implementation. The default implementation
  /// will set this Activity as the owner activity on the Dialog.
  ///@param id The id of the managed dialog.
  ///@param dialog The dialog.
  ///@param args The dialog arguments provided to \#showDialog(int, Bundle).
  ///@see \#onCreateDialog(int, Bundle)
  ///@see \#showDialog(int)
  ///@see \#dismissDialog(int)
  ///@see \#removeDialog(int)
  ///@deprecated Use the new DialogFragment class with
  /// FragmentManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  void onPrepareDialog1(int id, Dialog dialog, os_.Bundle args) =>
      _onPrepareDialog1(reference, id, dialog.reference, args.reference)
          .check();

  static final _showDialog = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Activity__showDialog")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void showDialog(int id)
  ///
  /// Simple version of \#showDialog(int, Bundle) that does not
  /// take any arguments.  Simply calls \#showDialog(int, Bundle)
  /// with null arguments.
  ///@deprecated Use the new DialogFragment class with
  /// FragmentManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  void showDialog(int id) => _showDialog(reference, id).check();

  static final _showDialog1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__showDialog1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean showDialog(int id, android.os.Bundle args)
  ///
  /// Show a dialog managed by this activity.  A call to \#onCreateDialog(int, Bundle)
  /// will be made with the same id the first time this is called for a given
  /// id.  From thereafter, the dialog will be automatically saved and restored.
  ///
  /// _If you are targeting android.os.Build.VERSION_CODES\#HONEYCOMB
  /// or later, consider instead using a DialogFragment instead._
  ///
  /// Each time a dialog is shown, \#onPrepareDialog(int, Dialog, Bundle) will
  /// be made to provide an opportunity to do any timely preparation.
  ///@param id The id of the managed dialog.
  ///@param args Arguments to pass through to the dialog.  These will be saved
  /// and restored for you.  Note that if the dialog is already created,
  /// \#onCreateDialog(int, Bundle) will not be called with the new
  /// arguments but \#onPrepareDialog(int, Dialog, Bundle) will be.
  /// If you need to rebuild the dialog, call \#removeDialog(int) first.
  ///@return Returns true if the Dialog was created; false is returned if
  /// it is not created because \#onCreateDialog(int, Bundle) returns false.
  ///@see Dialog
  ///@see \#onCreateDialog(int, Bundle)
  ///@see \#onPrepareDialog(int, Dialog, Bundle)
  ///@see \#dismissDialog(int)
  ///@see \#removeDialog(int)
  ///@deprecated Use the new DialogFragment class with
  /// FragmentManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  bool showDialog1(int id, os_.Bundle args) =>
      _showDialog1(reference, id, args.reference).boolean;

  static final _dismissDialog = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Activity__dismissDialog")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void dismissDialog(int id)
  ///
  /// Dismiss a dialog that was previously shown via \#showDialog(int).
  ///@param id The id of the managed dialog.
  ///@throws IllegalArgumentException if the id was not previously shown via
  ///   \#showDialog(int).
  ///@see \#onCreateDialog(int, Bundle)
  ///@see \#onPrepareDialog(int, Dialog, Bundle)
  ///@see \#showDialog(int)
  ///@see \#removeDialog(int)
  ///@deprecated Use the new DialogFragment class with
  /// FragmentManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  void dismissDialog(int id) => _dismissDialog(reference, id).check();

  static final _removeDialog = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Activity__removeDialog")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void removeDialog(int id)
  ///
  /// Removes any internal references to a dialog managed by this Activity.
  /// If the dialog is showing, it will dismiss it as part of the clean up.
  ///
  /// This can be useful if you know that you will never show a dialog again and
  /// want to avoid the overhead of saving and restoring it in the future.
  ///
  /// As of android.os.Build.VERSION_CODES\#GINGERBREAD, this function
  /// will not throw an exception if you try to remove an ID that does not
  /// currently have an associated dialog.
  ///
  ///@param id The id of the managed dialog.
  ///@see \#onCreateDialog(int, Bundle)
  ///@see \#onPrepareDialog(int, Dialog, Bundle)
  ///@see \#showDialog(int)
  ///@see \#dismissDialog(int)
  ///@deprecated Use the new DialogFragment class with
  /// FragmentManager instead; this is also
  /// available on older platforms through the Android compatibility package.
  void removeDialog(int id) => _removeDialog(reference, id).check();

  static final _onSearchRequested = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onSearchRequested")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onSearchRequested(android.view.SearchEvent searchEvent)
  ///
  /// This hook is called when the user signals the desire to start a search.
  ///
  /// You can use this function as a simple way to launch the search UI, in response to a
  /// menu item, search button, or other widgets within your activity. Unless overidden,
  /// calling this function is the same as calling
  /// \#startSearch startSearch(null, false, null, false), which launches
  /// search for the current activity as specified in its manifest, see SearchManager.
  ///
  /// You can override this function to force global search, e.g. in response to a dedicated
  /// search key, or to block search entirely (by simply returning false).
  ///
  /// Note: when running in a Configuration\#UI_MODE_TYPE_TELEVISION or
  /// Configuration\#UI_MODE_TYPE_WATCH, the default implementation changes to simply
  /// return false and you must supply your own custom implementation if you want to support
  /// search.
  ///@param searchEvent The SearchEvent that signaled this search.
  /// This value may be {@code null}.
  ///@return Returns {@code true} if search launched, and {@code false} if the activity does
  /// not respond to search.  The default implementation always returns {@code true}, except
  /// when in Configuration\#UI_MODE_TYPE_TELEVISION mode where it returns false.
  ///@see android.app.SearchManager
  bool onSearchRequested(jni.JniObject searchEvent) =>
      _onSearchRequested(reference, searchEvent.reference).boolean;

  static final _onSearchRequested1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onSearchRequested1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onSearchRequested()
  ///
  /// @see \#onSearchRequested(SearchEvent)
  bool onSearchRequested1() => _onSearchRequested1(reference).boolean;

  static final _getSearchEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getSearchEvent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.view.SearchEvent getSearchEvent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// During the onSearchRequested() callbacks, this function will return the
  /// SearchEvent that triggered the callback, if it exists.
  ///@return SearchEvent The SearchEvent that triggered the \#onSearchRequested callback.
  jni.JniObject getSearchEvent() =>
      jni.JniObject.fromRef(_getSearchEvent(reference).object);

  static final _startSearch = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Activity__startSearch")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void startSearch(java.lang.String initialQuery, boolean selectInitialQuery, android.os.Bundle appSearchData, boolean globalSearch)
  ///
  /// This hook is called to launch the search UI.
  ///
  /// It is typically called from onSearchRequested(), either directly from
  /// Activity.onSearchRequested() or from an overridden version in any given
  /// Activity.  If your goal is simply to activate search, it is preferred to call
  /// onSearchRequested(), which may have been overridden elsewhere in your Activity.  If your goal
  /// is to inject specific data such as context data, it is preferred to <i>override</i>
  /// onSearchRequested(), so that any callers to it will benefit from the override.
  ///
  /// Note: when running in a Configuration\#UI_MODE_TYPE_WATCH, use of this API is
  /// not supported.
  ///@param initialQuery Any non-null non-empty string will be inserted as
  /// pre-entered text in the search query box.
  /// This value may be {@code null}.
  ///@param selectInitialQuery If true, the initial query will be preselected, which means that
  /// any further typing will replace it.  This is useful for cases where an entire pre-formed
  /// query is being inserted.  If false, the selection point will be placed at the end of the
  /// inserted query.  This is useful when the inserted query is text that the user entered,
  /// and the user would expect to be able to keep typing.  <i>This parameter is only meaningful
  /// if initialQuery is a non-empty string.</i>
  ///@param appSearchData An application can insert application-specific
  /// context here, in order to improve quality or specificity of its own
  /// searches.  This data will be returned with SEARCH intent(s).  Null if
  /// no extra data is required.
  /// This value may be {@code null}.
  ///@param globalSearch If false, this will only launch the search that has been specifically
  /// defined by the application (which is usually defined as a local search).  If no default
  /// search is defined in the current application or activity, global search will be launched.
  /// If true, this will always launch a platform-global (e.g. web-based) search instead.
  ///@see android.app.SearchManager
  ///@see \#onSearchRequested
  void startSearch(jni.JniString initialQuery, bool selectInitialQuery,
          os_.Bundle appSearchData, bool globalSearch) =>
      _startSearch(
              reference,
              initialQuery.reference,
              selectInitialQuery ? 1 : 0,
              appSearchData.reference,
              globalSearch ? 1 : 0)
          .check();

  static final _triggerSearch = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__triggerSearch")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void triggerSearch(java.lang.String query, android.os.Bundle appSearchData)
  ///
  /// Similar to \#startSearch, but actually fires off the search query after invoking
  /// the search dialog.  Made available for testing purposes.
  ///@param query The query to trigger.  If empty, the request will be ignored.
  ///@param appSearchData An application can insert application-specific
  /// context here, in order to improve quality or specificity of its own
  /// searches.  This data will be returned with SEARCH intent(s).  Null if
  /// no extra data is required.
  ///
  /// This value may be {@code null}.
  void triggerSearch(jni.JniString query, os_.Bundle appSearchData) =>
      _triggerSearch(reference, query.reference, appSearchData.reference)
          .check();

  static final _takeKeyEvents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Activity__takeKeyEvents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void takeKeyEvents(boolean get)
  ///
  /// Request that key events come to this activity. Use this if your
  /// activity has no views with focus, but the activity still wants
  /// a chance to process key events.
  ///@see android.view.Window\#takeKeyEvents
  void takeKeyEvents(bool get0) =>
      _takeKeyEvents(reference, get0 ? 1 : 0).check();

  static final _requestWindowFeature = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__requestWindowFeature")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final boolean requestWindowFeature(int featureId)
  ///
  /// Enable extended window features.  This is a convenience for calling
  /// android.view.Window\#requestFeature getWindow().requestFeature().
  ///@param featureId The desired feature as defined in
  ///                  android.view.Window.
  ///@return Returns true if the requested feature is supported and now
  ///         enabled.
  ///@see android.view.Window\#requestFeature
  bool requestWindowFeature(int featureId) =>
      _requestWindowFeature(reference, featureId).boolean;

  static final _setFeatureDrawableResource = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Activity__setFeatureDrawableResource")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final void setFeatureDrawableResource(int featureId, int resId)
  ///
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawableResource.
  void setFeatureDrawableResource(int featureId, int resId) =>
      _setFeatureDrawableResource(reference, featureId, resId).check();

  static final _setFeatureDrawableUri = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__setFeatureDrawableUri")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setFeatureDrawableUri(int featureId, android.net.Uri uri)
  ///
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawableUri.
  void setFeatureDrawableUri(int featureId, jni.JniObject uri) =>
      _setFeatureDrawableUri(reference, featureId, uri.reference).check();

  static final _setFeatureDrawable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__setFeatureDrawable")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setFeatureDrawable(int featureId, android.graphics.drawable.Drawable drawable)
  ///
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawable(int, Drawable).
  void setFeatureDrawable(int featureId, jni.JniObject drawable) =>
      _setFeatureDrawable(reference, featureId, drawable.reference).check();

  static final _setFeatureDrawableAlpha = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Activity__setFeatureDrawableAlpha")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final void setFeatureDrawableAlpha(int featureId, int alpha)
  ///
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawableAlpha.
  void setFeatureDrawableAlpha(int featureId, int alpha) =>
      _setFeatureDrawableAlpha(reference, featureId, alpha).check();

  static final _getLayoutInflater = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getLayoutInflater")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.LayoutInflater getLayoutInflater()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience for calling
  /// android.view.Window\#getLayoutInflater.
  ///@return This value will never be {@code null}.
  jni.JniObject getLayoutInflater() =>
      jni.JniObject.fromRef(_getLayoutInflater(reference).object);

  static final _getMenuInflater = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getMenuInflater")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.MenuInflater getMenuInflater()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a MenuInflater with this context.
  ///@return This value will never be {@code null}.
  jni.JniObject getMenuInflater() =>
      jni.JniObject.fromRef(_getMenuInflater(reference).object);

  static final _setTheme = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Activity__setTheme")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setTheme(int resid)
  void setTheme(int resid) => _setTheme(reference, resid).check();

  static final _onApplyThemeResource = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Uint8)>>("Activity__onApplyThemeResource")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: protected void onApplyThemeResource(android.content.res.Resources.Theme theme, int resid, boolean first)
  void onApplyThemeResource(
          res_.Resources_Theme theme, int resid, bool first) =>
      _onApplyThemeResource(reference, theme.reference, resid, first ? 1 : 0)
          .check();

  static final _requestPermissions = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__requestPermissions")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void requestPermissions(java.lang.String[] permissions, int requestCode)
  ///
  /// Requests permissions to be granted to this application. These permissions
  /// must be requested in your manifest, they should not be granted to your app,
  /// and they should have protection level android.content.pm.PermissionInfo \#PROTECTION_DANGEROUS dangerous, regardless whether they are declared by
  /// the platform or a third-party app.
  ///
  /// Normal permissions android.content.pm.PermissionInfo\#PROTECTION_NORMAL
  /// are granted at install time if requested in the manifest. Signature permissions
  /// android.content.pm.PermissionInfo\#PROTECTION_SIGNATURE are granted at
  /// install time if requested in the manifest and the signature of your app matches
  /// the signature of the app declaring the permissions.
  ///
  ///
  ///
  /// If your app does not have the requested permissions the user will be presented
  /// with UI for accepting them. After the user has accepted or rejected the
  /// requested permissions you will receive a callback on \#onRequestPermissionsResult(int, String[], int[]) reporting whether the
  /// permissions were granted or not.
  ///
  ///
  ///
  /// Note that requesting a permission does not guarantee it will be granted and
  /// your app should be able to run without having this permission.
  ///
  ///
  ///
  /// This method may start an activity allowing the user to choose which permissions
  /// to grant and which to reject. Hence, you should be prepared that your activity
  /// may be paused and resumed. Further, granting some permissions may require
  /// a restart of you application. In such a case, the system will recreate the
  /// activity stack before delivering the result to \#onRequestPermissionsResult(int, String[], int[]).
  ///
  ///
  ///
  /// When checking whether you have a permission you should use \#checkSelfPermission(String).
  ///
  ///
  ///
  /// Calling this API for permissions already granted to your app would show UI
  /// to the user to decide whether the app can still hold these permissions. This
  /// can be useful if the way your app uses data guarded by the permissions
  /// changes significantly.
  ///
  ///
  ///
  /// You cannot request a permission if your activity sets android.R.styleable\#AndroidManifestActivity_noHistory noHistory to
  /// <code>true</code> because in this case the activity would not receive
  /// result callbacks including \#onRequestPermissionsResult(int, String[], int[]).
  ///
  ///
  ///
  /// The <a href="http://developer.android.com/samples/RuntimePermissions/index.html">
  /// RuntimePermissions</a> sample app demonstrates how to use this method to
  /// request permissions at run time.
  ///
  ///
  ///@param permissions The requested permissions. Must me non-null and not empty.
  /// This value must never be {@code null}.
  ///@param requestCode Application specific request code to match with a result
  ///    reported to \#onRequestPermissionsResult(int, String[], int[]).
  ///    Should be >= 0.
  ///@throws IllegalArgumentException if requestCode is negative.
  ///@see \#onRequestPermissionsResult(int, String[], int[])
  ///@see \#checkSelfPermission(String)
  ///@see \#shouldShowRequestPermissionRationale(String)
  void requestPermissions(jni.JniObject permissions, int requestCode) =>
      _requestPermissions(reference, permissions.reference, requestCode)
          .check();

  static final _onRequestPermissionsResult = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Activity__onRequestPermissionsResult")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onRequestPermissionsResult(int requestCode, java.lang.String[] permissions, int[] grantResults)
  ///
  /// Callback for the result from requesting permissions. This method
  /// is invoked for every call on \#requestPermissions(String[], int).
  ///
  /// <strong>Note:</strong> It is possible that the permissions request interaction
  /// with the user is interrupted. In this case you will receive empty permissions
  /// and results arrays which should be treated as a cancellation.
  ///
  ///
  ///@param requestCode The request code passed in \#requestPermissions(String[], int).
  ///@param permissions The requested permissions. Never null.
  /// This value must never be {@code null}.
  ///@param grantResults The grant results for the corresponding permissions
  ///     which is either android.content.pm.PackageManager\#PERMISSION_GRANTED
  ///     or android.content.pm.PackageManager\#PERMISSION_DENIED. Never null.
  ///
  /// This value must never be {@code null}.
  ///@see \#requestPermissions(String[], int)
  void onRequestPermissionsResult(int requestCode, jni.JniObject permissions,
          jni.JniObject grantResults) =>
      _onRequestPermissionsResult(reference, requestCode, permissions.reference,
              grantResults.reference)
          .check();

  static final _shouldShowRequestPermissionRationale = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Activity__shouldShowRequestPermissionRationale")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldShowRequestPermissionRationale(java.lang.String permission)
  ///
  /// Gets whether you should show UI with rationale for requesting a permission.
  /// You should do this only if you do not have the permission and the context in
  /// which the permission is requested does not clearly communicate to the user
  /// what would be the benefit from granting this permission.
  ///
  /// For example, if you write a camera app, requesting the camera permission
  /// would be expected by the user and no rationale for why it is requested is
  /// needed. If however, the app needs location for tagging photos then a non-tech
  /// savvy user may wonder how location is related to taking photos. In this case
  /// you may choose to show UI with rationale of requesting this permission.
  ///
  ///
  ///@param permission A permission your app wants to request.
  /// This value must never be {@code null}.
  ///@return Whether you can show permission rationale UI.
  ///@see \#checkSelfPermission(String)
  ///@see \#requestPermissions(String[], int)
  ///@see \#onRequestPermissionsResult(int, String[], int[])
  bool shouldShowRequestPermissionRationale(jni.JniString permission) =>
      _shouldShowRequestPermissionRationale(reference, permission.reference)
          .boolean;

  static final _startActivityForResult = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__startActivityForResult")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void startActivityForResult(android.content.Intent intent, int requestCode)
  ///
  /// Same as calling \#startActivityForResult(Intent, int, Bundle)
  /// with no options.
  ///@param intent The intent to start.
  ///@param requestCode If >= 0, this code will be returned in
  ///                    onActivityResult() when the activity exits.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivity
  void startActivityForResult(content_.Intent intent, int requestCode) =>
      _startActivityForResult(reference, intent.reference, requestCode).check();

  static final _startActivityForResult1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__startActivityForResult1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivityForResult(android.content.Intent intent, int requestCode, android.os.Bundle options)
  ///
  /// Launch an activity for which you would like a result when it finished.
  /// When this activity exits, your
  /// onActivityResult() method will be called with the given requestCode.
  /// Using a negative requestCode is the same as calling
  /// \#startActivity (the activity is not launched as a sub-activity).
  ///
  /// Note that this method should only be used with Intent protocols
  /// that are defined to return a result.  In other protocols (such as
  /// Intent\#ACTION_MAIN or Intent\#ACTION_VIEW), you may
  /// not get the result when you expect.  For example, if the activity you
  /// are launching uses Intent\#FLAG_ACTIVITY_NEW_TASK, it will not
  /// run in your task and thus you will immediately receive a cancel result.
  ///
  /// As a special case, if you call startActivityForResult() with a requestCode
  /// >= 0 during the initial onCreate(Bundle savedInstanceState)/onResume() of your
  /// activity, then your window will not be displayed until a result is
  /// returned back from the started activity.  This is to avoid visible
  /// flickering when redirecting to another activity.
  ///
  /// This method throws android.content.ActivityNotFoundException
  /// if there was no Activity found to run the given Intent.
  ///@param intent The intent to start.
  ///@param requestCode If >= 0, this code will be returned in
  ///                    onActivityResult() when the activity exits.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivity
  void startActivityForResult1(
          content_.Intent intent, int requestCode, os_.Bundle options) =>
      _startActivityForResult1(
              reference, intent.reference, requestCode, options.reference)
          .check();

  static final _isActivityTransitionRunning = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Activity__isActivityTransitionRunning")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isActivityTransitionRunning()
  ///
  /// Returns whether there are any activity transitions currently running on this
  /// activity. A return value of {@code true} can mean that either an enter or
  /// exit transition is running, including whether the background of the activity
  /// is animating as a part of that transition.
  ///@return true if a transition is currently running on this activity, false otherwise.
  bool isActivityTransitionRunning() =>
      _isActivityTransitionRunning(reference).boolean;

  static final _startIntentSenderForResult = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("Activity__startIntentSenderForResult")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void startIntentSenderForResult(android.content.IntentSender intent, int requestCode, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)
  ///
  /// Same as calling \#startIntentSenderForResult(IntentSender, int,
  /// Intent, int, int, int, Bundle) with no options.
  ///@param intent The IntentSender to launch.
  ///@param requestCode If >= 0, this code will be returned in
  ///                    onActivityResult() when the activity exits.
  ///@param fillInIntent If non-null, this will be provided as the
  /// intent parameter to IntentSender\#sendIntent.
  /// This value may be {@code null}.
  ///@param flagsMask Intent flags in the original IntentSender that you
  /// would like to change.
  ///@param flagsValues Desired values for any bits set in
  /// <var>flagsMask</var>
  ///@param extraFlags Always set to 0.
  void startIntentSenderForResult(
          content_.IntentSender intent,
          int requestCode,
          content_.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags) =>
      _startIntentSenderForResult(reference, intent.reference, requestCode,
              fillInIntent.reference, flagsMask, flagsValues, extraFlags)
          .check();

  static final _startIntentSenderForResult1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "Activity__startIntentSenderForResult1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startIntentSenderForResult(android.content.IntentSender intent, int requestCode, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, android.os.Bundle options)
  ///
  /// Like \#startActivityForResult(Intent, int), but allowing you
  /// to use a IntentSender to describe the activity to be started.  If
  /// the IntentSender is for an activity, that activity will be started
  /// as if you had called the regular \#startActivityForResult(Intent, int)
  /// here; otherwise, its associated action will be executed (such as
  /// sending a broadcast) as if you had called
  /// IntentSender\#sendIntent IntentSender.sendIntent on it.
  ///@param intent The IntentSender to launch.
  ///@param requestCode If >= 0, this code will be returned in
  ///                    onActivityResult() when the activity exits.
  ///@param fillInIntent If non-null, this will be provided as the
  /// intent parameter to IntentSender\#sendIntent.
  /// This value may be {@code null}.
  ///@param flagsMask Intent flags in the original IntentSender that you
  /// would like to change.
  ///@param flagsValues Desired values for any bits set in
  /// <var>flagsMask</var>
  ///@param extraFlags Always set to 0.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.  If options
  /// have also been supplied by the IntentSender, options given here will
  /// override any that conflict with those given by the IntentSender.
  void startIntentSenderForResult1(
          content_.IntentSender intent,
          int requestCode,
          content_.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags,
          os_.Bundle options) =>
      _startIntentSenderForResult1(
              reference,
              intent.reference,
              requestCode,
              fillInIntent.reference,
              flagsMask,
              flagsValues,
              extraFlags,
              options.reference)
          .check();

  static final _startActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__startActivity")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivity(android.content.Intent intent)
  ///
  /// Same as \#startActivity(Intent, Bundle) with no options
  /// specified.
  ///@param intent The intent to start.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivity(Intent, Bundle)
  ///@see \#startActivityForResult
  void startActivity(content_.Intent intent) =>
      _startActivity(reference, intent.reference).check();

  static final _startActivity1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__startActivity1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivity(android.content.Intent intent, android.os.Bundle options)
  ///
  /// Launch a new activity.  You will not receive any information about when
  /// the activity exits.  This implementation overrides the base version,
  /// providing information about
  /// the activity performing the launch.  Because of this additional
  /// information, the Intent\#FLAG_ACTIVITY_NEW_TASK launch flag is not
  /// required; if not specified, the new activity will be added to the
  /// task of the caller.
  ///
  /// This method throws android.content.ActivityNotFoundException
  /// if there was no Activity found to run the given Intent.
  ///@param intent The intent to start.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivity(Intent)
  ///@see \#startActivityForResult
  void startActivity1(content_.Intent intent, os_.Bundle options) =>
      _startActivity1(reference, intent.reference, options.reference).check();

  static final _startActivities = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__startActivities")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivities(android.content.Intent[] intents)
  ///
  /// Same as \#startActivities(Intent[], Bundle) with no options
  /// specified.
  ///@param intents The intents to start.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivities(Intent[], Bundle)
  ///@see \#startActivityForResult
  void startActivities(jni.JniObject intents) =>
      _startActivities(reference, intents.reference).check();

  static final _startActivities1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__startActivities1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivities(android.content.Intent[] intents, android.os.Bundle options)
  ///
  /// Launch a new activity.  You will not receive any information about when
  /// the activity exits.  This implementation overrides the base version,
  /// providing information about
  /// the activity performing the launch.  Because of this additional
  /// information, the Intent\#FLAG_ACTIVITY_NEW_TASK launch flag is not
  /// required; if not specified, the new activity will be added to the
  /// task of the caller.
  ///
  /// This method throws android.content.ActivityNotFoundException
  /// if there was no Activity found to run the given Intent.
  ///@param intents The intents to start.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivities(Intent[])
  ///@see \#startActivityForResult
  void startActivities1(jni.JniObject intents, os_.Bundle options) =>
      _startActivities1(reference, intents.reference, options.reference)
          .check();

  static final _startIntentSender = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("Activity__startIntentSender")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void startIntentSender(android.content.IntentSender intent, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)
  ///
  /// Same as calling \#startIntentSender(IntentSender, Intent, int, int, int, Bundle)
  /// with no options.
  ///@param intent The IntentSender to launch.
  ///@param fillInIntent If non-null, this will be provided as the
  /// intent parameter to IntentSender\#sendIntent.
  /// This value may be {@code null}.
  ///@param flagsMask Intent flags in the original IntentSender that you
  /// would like to change.
  ///@param flagsValues Desired values for any bits set in
  /// <var>flagsMask</var>
  ///@param extraFlags Always set to 0.
  void startIntentSender(
          content_.IntentSender intent,
          content_.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags) =>
      _startIntentSender(reference, intent.reference, fillInIntent.reference,
              flagsMask, flagsValues, extraFlags)
          .check();

  static final _startIntentSender1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__startIntentSender1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void startIntentSender(android.content.IntentSender intent, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, android.os.Bundle options)
  ///
  /// Like \#startActivity(Intent, Bundle), but taking a IntentSender
  /// to start; see
  /// \#startIntentSenderForResult(IntentSender, int, Intent, int, int, int, Bundle)
  /// for more information.
  ///@param intent The IntentSender to launch.
  ///@param fillInIntent If non-null, this will be provided as the
  /// intent parameter to IntentSender\#sendIntent.
  /// This value may be {@code null}.
  ///@param flagsMask Intent flags in the original IntentSender that you
  /// would like to change.
  ///@param flagsValues Desired values for any bits set in
  /// <var>flagsMask</var>
  ///@param extraFlags Always set to 0.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.  If options
  /// have also been supplied by the IntentSender, options given here will
  /// override any that conflict with those given by the IntentSender.
  void startIntentSender1(
          content_.IntentSender intent,
          content_.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags,
          os_.Bundle options) =>
      _startIntentSender1(reference, intent.reference, fillInIntent.reference,
              flagsMask, flagsValues, extraFlags, options.reference)
          .check();

  static final _startActivityIfNeeded = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__startActivityIfNeeded")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean startActivityIfNeeded(android.content.Intent intent, int requestCode)
  ///
  /// Same as calling \#startActivityIfNeeded(Intent, int, Bundle)
  /// with no options.
  ///@param intent The intent to start.
  /// This value must never be {@code null}.
  ///@param requestCode If >= 0, this code will be returned in
  ///         onActivityResult() when the activity exits, as described in
  ///         \#startActivityForResult.
  ///@return If a new activity was launched then true is returned; otherwise
  ///         false is returned and you must handle the Intent yourself.
  ///@see \#startActivity
  ///@see \#startActivityForResult
  bool startActivityIfNeeded(content_.Intent intent, int requestCode) =>
      _startActivityIfNeeded(reference, intent.reference, requestCode).boolean;

  static final _startActivityIfNeeded1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__startActivityIfNeeded1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean startActivityIfNeeded(android.content.Intent intent, int requestCode, android.os.Bundle options)
  ///
  /// A special variation to launch an activity only if a new activity
  /// instance is needed to handle the given Intent.  In other words, this is
  /// just like \#startActivityForResult(Intent, int) except: if you are
  /// using the Intent\#FLAG_ACTIVITY_SINGLE_TOP flag, or
  /// singleTask or singleTop
  /// android.R.styleable\#AndroidManifestActivity_launchMode launchMode,
  /// and the activity
  /// that handles <var>intent</var> is the same as your currently running
  /// activity, then a new instance is not needed.  In this case, instead of
  /// the normal behavior of calling \#onNewIntent this function will
  /// return and you can handle the Intent yourself.
  ///
  /// This function can only be called from a top-level activity; if it is
  /// called from a child activity, a runtime exception will be thrown.
  ///@param intent The intent to start.
  /// This value must never be {@code null}.
  ///@param requestCode If >= 0, this code will be returned in
  ///         onActivityResult() when the activity exits, as described in
  ///         \#startActivityForResult.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@return If a new activity was launched then true is returned; otherwise
  ///         false is returned and you must handle the Intent yourself.
  ///@see \#startActivity
  ///@see \#startActivityForResult
  bool startActivityIfNeeded1(
          content_.Intent intent, int requestCode, os_.Bundle options) =>
      _startActivityIfNeeded1(
              reference, intent.reference, requestCode, options.reference)
          .boolean;

  static final _startNextMatchingActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Activity__startNextMatchingActivity")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean startNextMatchingActivity(android.content.Intent intent)
  ///
  /// Same as calling \#startNextMatchingActivity(Intent, Bundle) with
  /// no options.
  ///@param intent The intent to dispatch to the next activity.  For
  /// correct behavior, this must be the same as the Intent that started
  /// your own activity; the only changes you can make are to the extras
  /// inside of it.
  ///
  /// This value must never be {@code null}.
  ///@return Returns a boolean indicating whether there was another Activity
  /// to start: true if there was a next activity to start, false if there
  /// wasn't.  In general, if true is returned you will then want to call
  /// finish() on yourself.
  bool startNextMatchingActivity(content_.Intent intent) =>
      _startNextMatchingActivity(reference, intent.reference).boolean;

  static final _startNextMatchingActivity1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Activity__startNextMatchingActivity1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean startNextMatchingActivity(android.content.Intent intent, android.os.Bundle options)
  ///
  /// Special version of starting an activity, for use when you are replacing
  /// other activity components.  You can use this to hand the Intent off
  /// to the next Activity that can handle it.  You typically call this in
  /// \#onCreate with the Intent returned by \#getIntent.
  ///@param intent The intent to dispatch to the next activity.  For
  /// correct behavior, this must be the same as the Intent that started
  /// your own activity; the only changes you can make are to the extras
  /// inside of it.
  /// This value must never be {@code null}.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@return Returns a boolean indicating whether there was another Activity
  /// to start: true if there was a next activity to start, false if there
  /// wasn't.  In general, if true is returned you will then want to call
  /// finish() on yourself.
  bool startNextMatchingActivity1(content_.Intent intent, os_.Bundle options) =>
      _startNextMatchingActivity1(
              reference, intent.reference, options.reference)
          .boolean;

  static final _startActivityFromChild = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__startActivityFromChild")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void startActivityFromChild(android.app.Activity child, android.content.Intent intent, int requestCode)
  ///
  /// Same as calling \#startActivityFromChild(Activity, Intent, int, Bundle)
  /// with no options.
  ///@param child The activity making the call.
  /// This value must never be {@code null}.
  ///@param intent The intent to start.
  ///@param requestCode Reply request code.  < 0 if reply is not requested.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivity
  ///@see \#startActivityForResult
  void startActivityFromChild(
          Activity child, content_.Intent intent, int requestCode) =>
      _startActivityFromChild(
              reference, child.reference, intent.reference, requestCode)
          .check();

  static final _startActivityFromChild1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__startActivityFromChild1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivityFromChild(android.app.Activity child, android.content.Intent intent, int requestCode, android.os.Bundle options)
  ///
  /// This is called when a child activity of this one calls its
  /// \#startActivity or \#startActivityForResult method.
  ///
  /// This method throws android.content.ActivityNotFoundException
  /// if there was no Activity found to run the given Intent.
  ///@param child The activity making the call.
  /// This value must never be {@code null}.
  ///@param intent The intent to start.
  ///@param requestCode Reply request code.  < 0 if reply is not requested.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@throws android.content.ActivityNotFoundException
  ///@see \#startActivity
  ///@see \#startActivityForResult
  void startActivityFromChild1(Activity child, content_.Intent intent,
          int requestCode, os_.Bundle options) =>
      _startActivityFromChild1(reference, child.reference, intent.reference,
              requestCode, options.reference)
          .check();

  static final _startActivityFromFragment = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__startActivityFromFragment")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void startActivityFromFragment(android.app.Fragment fragment, android.content.Intent intent, int requestCode)
  ///
  /// Same as calling \#startActivityFromFragment(Fragment, Intent, int, Bundle)
  /// with no options.
  ///@param fragment The fragment making the call.
  /// This value must never be {@code null}.
  ///@param intent The intent to start.
  ///@param requestCode Reply request code.  < 0 if reply is not requested.
  ///@throws android.content.ActivityNotFoundException
  ///@see Fragment\#startActivity
  ///@see Fragment\#startActivityForResult
  ///@deprecated Use android.support.v4.app.FragmentActivity\#startActivityFromFragment(
  /// android.support.v4.app.Fragment,Intent,int)
  void startActivityFromFragment(
          Fragment fragment, content_.Intent intent, int requestCode) =>
      _startActivityFromFragment(
              reference, fragment.reference, intent.reference, requestCode)
          .check();

  static final _startActivityFromFragment1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "Activity__startActivityFromFragment1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivityFromFragment(android.app.Fragment fragment, android.content.Intent intent, int requestCode, android.os.Bundle options)
  ///
  /// This is called when a Fragment in this activity calls its
  /// Fragment\#startActivity or Fragment\#startActivityForResult
  /// method.
  ///
  /// This method throws android.content.ActivityNotFoundException
  /// if there was no Activity found to run the given Intent.
  ///@param fragment The fragment making the call.
  /// This value must never be {@code null}.
  ///@param intent The intent to start.
  ///@param requestCode Reply request code.  < 0 if reply is not requested.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///
  /// This value may be {@code null}.
  ///@throws android.content.ActivityNotFoundException
  ///@see Fragment\#startActivity
  ///@see Fragment\#startActivityForResult
  ///@deprecated Use android.support.v4.app.FragmentActivity\#startActivityFromFragment(
  /// android.support.v4.app.Fragment,Intent,int,Bundle)
  void startActivityFromFragment1(Fragment fragment, content_.Intent intent,
          int requestCode, os_.Bundle options) =>
      _startActivityFromFragment1(reference, fragment.reference,
              intent.reference, requestCode, options.reference)
          .check();

  static final _startIntentSenderFromChild = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("Activity__startIntentSenderFromChild")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int)>();

  /// from: public void startIntentSenderFromChild(android.app.Activity child, android.content.IntentSender intent, int requestCode, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)
  ///
  /// Same as calling \#startIntentSenderFromChild(Activity, IntentSender,
  /// int, Intent, int, int, int, Bundle) with no options.
  void startIntentSenderFromChild(
          Activity child,
          content_.IntentSender intent,
          int requestCode,
          content_.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags) =>
      _startIntentSenderFromChild(
              reference,
              child.reference,
              intent.reference,
              requestCode,
              fillInIntent.reference,
              flagsMask,
              flagsValues,
              extraFlags)
          .check();

  static final _startIntentSenderFromChild1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "Activity__startIntentSenderFromChild1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startIntentSenderFromChild(android.app.Activity child, android.content.IntentSender intent, int requestCode, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, android.os.Bundle options)
  ///
  /// Like \#startActivityFromChild(Activity, Intent, int), but
  /// taking a IntentSender; see
  /// \#startIntentSenderForResult(IntentSender, int, Intent, int, int, int)
  /// for more information.
  ///@param options This value may be {@code null}.
  void startIntentSenderFromChild1(
          Activity child,
          content_.IntentSender intent,
          int requestCode,
          content_.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags,
          os_.Bundle options) =>
      _startIntentSenderFromChild1(
              reference,
              child.reference,
              intent.reference,
              requestCode,
              fillInIntent.reference,
              flagsMask,
              flagsValues,
              extraFlags,
              options.reference)
          .check();

  static final _overridePendingTransition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Activity__overridePendingTransition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void overridePendingTransition(int enterAnim, int exitAnim)
  ///
  /// Call immediately after one of the flavors of \#startActivity(Intent)
  /// or \#finish to specify an explicit transition animation to
  /// perform next.
  ///
  /// As of android.os.Build.VERSION_CODES\#JELLY_BEAN an alternative
  /// to using this with starting activities is to supply the desired animation
  /// information through a ActivityOptions bundle to
  /// \#startActivity(Intent, Bundle) or a related function.  This allows
  /// you to specify a custom animation even when starting an activity from
  /// outside the context of the current top activity.
  ///@param enterAnim A resource ID of the animation resource to use for
  /// the incoming activity.  Use 0 for no animation.
  ///@param exitAnim A resource ID of the animation resource to use for
  /// the outgoing activity.  Use 0 for no animation.
  void overridePendingTransition(int enterAnim, int exitAnim) =>
      _overridePendingTransition(reference, enterAnim, exitAnim).check();

  static final _setResult = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Activity__setResult")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setResult(int resultCode)
  ///
  /// Call this to set the result that your activity will return to its
  /// caller.
  ///@param resultCode The result code to propagate back to the originating
  ///                   activity, often RESULT_CANCELED or RESULT_OK
  ///@see \#RESULT_CANCELED
  ///@see \#RESULT_OK
  ///@see \#RESULT_FIRST_USER
  ///@see \#setResult(int, Intent)
  void setResult(int resultCode) => _setResult(reference, resultCode).check();

  static final _setResult1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__setResult1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setResult(int resultCode, android.content.Intent data)
  ///
  /// Call this to set the result that your activity will return to its
  /// caller.
  ///
  /// As of android.os.Build.VERSION_CODES\#GINGERBREAD, the Intent
  /// you supply here can have Intent\#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION and/or Intent\#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION set.  This will grant the
  /// Activity receiving the result access to the specific URIs in the Intent.
  /// Access will remain until the Activity has finished (it will remain across the hosting
  /// process being killed and other temporary destruction) and will be added
  /// to any existing set of URI permissions it already holds.
  ///@param resultCode The result code to propagate back to the originating
  ///                   activity, often RESULT_CANCELED or RESULT_OK
  ///@param data The data to propagate back to the originating activity.
  ///@see \#RESULT_CANCELED
  ///@see \#RESULT_OK
  ///@see \#RESULT_FIRST_USER
  ///@see \#setResult(int)
  void setResult1(int resultCode, content_.Intent data) =>
      _setResult1(reference, resultCode, data.reference).check();

  static final _getReferrer = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getReferrer")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri getReferrer()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return information about who launched this activity.  If the launching Intent
  /// contains an android.content.Intent\#EXTRA_REFERRER Intent.EXTRA_REFERRER,
  /// that will be returned as-is; otherwise, if known, an
  /// Intent\#URI_ANDROID_APP_SCHEME android-app: referrer URI containing the
  /// package name that started the Intent will be returned.  This may return null if no
  /// referrer can be identified -- it is neither explicitly specified, nor is it known which
  /// application package was involved.
  ///
  /// If called while inside the handling of \#onNewIntent, this function will
  /// return the referrer that submitted that new intent to the activity.  Otherwise, it
  /// always returns the referrer of the original Intent.
  ///
  ///
  /// Note that this is _not_ a security feature -- you can not trust the
  /// referrer information, applications can spoof it.
  ///
  jni.JniObject getReferrer() =>
      jni.JniObject.fromRef(_getReferrer(reference).object);

  static final _onProvideReferrer = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onProvideReferrer")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri onProvideReferrer()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Override to generate the desired referrer for the content currently being shown
  /// by the app.  The default implementation returns null, meaning the referrer will simply
  /// be the android-app: of the package name of this activity.  Return a non-null Uri to
  /// have that supplied as the Intent\#EXTRA_REFERRER of any activities started from it.
  jni.JniObject onProvideReferrer() =>
      jni.JniObject.fromRef(_onProvideReferrer(reference).object);

  static final _getCallingPackage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getCallingPackage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getCallingPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the name of the package that invoked this activity.  This is who
  /// the data in \#setResult setResult() will be sent to.  You can
  /// use this information to validate that the recipient is allowed to
  /// receive the data.
  ///
  /// <p class="note">Note: if the calling activity is not expecting a result (that is it
  /// did not use the \#startActivityForResult
  /// form that includes a request code), then the calling package will be
  /// null.
  ///
  ///
  /// <p class="note">Note: prior to android.os.Build.VERSION_CODES\#JELLY_BEAN_MR2,
  /// the result from this method was unstable.  If the process hosting the calling
  /// package was no longer running, it would return null instead of the proper package
  /// name.  You can use \#getCallingActivity() and retrieve the package name
  /// from that instead.
  ///
  ///@return The package of the activity that will receive your
  ///         reply, or null if none.
  jni.JniString getCallingPackage() =>
      jni.JniString.fromRef(_getCallingPackage(reference).object);

  static final _getCallingActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getCallingActivity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getCallingActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the name of the activity that invoked this activity.  This is
  /// who the data in \#setResult setResult() will be sent to.  You
  /// can use this information to validate that the recipient is allowed to
  /// receive the data.
  ///
  /// <p class="note">Note: if the calling activity is not expecting a result (that is it
  /// did not use the \#startActivityForResult
  /// form that includes a request code), then the calling package will be
  /// null.
  ///@return The ComponentName of the activity that will receive your
  ///         reply, or null if none.
  content_.ComponentName getCallingActivity() =>
      content_.ComponentName.fromRef(_getCallingActivity(reference).object);

  static final _setVisible = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Activity__setVisible")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setVisible(boolean visible)
  ///
  /// Control whether this activity's main window is visible.  This is intended
  /// only for the special case of an activity that is not going to show a
  /// UI itself, but can't just finish prior to onResume() because it needs
  /// to wait for a service binding or such.  Setting this to false allows
  /// you to prevent your UI from being shown during that time.
  ///
  /// The default value for this is taken from the
  /// android.R.attr\#windowNoDisplay attribute of the activity's theme.
  void setVisible(bool visible) =>
      _setVisible(reference, visible ? 1 : 0).check();

  static final _isFinishing = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__isFinishing")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isFinishing()
  ///
  /// Check to see whether this activity is in the process of finishing,
  /// either because you called \#finish on it or someone else
  /// has requested that it finished.  This is often used in
  /// \#onPause to determine whether the activity is simply pausing or
  /// completely finishing.
  ///@return If the activity is finishing, returns true; else returns false.
  ///@see \#finish
  bool isFinishing() => _isFinishing(reference).boolean;

  static final _isDestroyed = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__isDestroyed")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isDestroyed()
  ///
  /// Returns true if the final \#onDestroy() call has been made
  /// on the Activity, so this instance is now dead.
  bool isDestroyed() => _isDestroyed(reference).boolean;

  static final _isChangingConfigurations = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__isChangingConfigurations")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isChangingConfigurations()
  ///
  /// Check to see whether this activity is in the process of being destroyed in order to be
  /// recreated with a new configuration. This is often used in
  /// \#onStop to determine whether the state needs to be cleaned up or will be passed
  /// on to the next instance of the activity via \#onRetainNonConfigurationInstance().
  ///@return If the activity is being torn down in order to be recreated with a new configuration,
  /// returns true; else returns false.
  bool isChangingConfigurations() =>
      _isChangingConfigurations(reference).boolean;

  static final _recreate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__recreate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void recreate()
  ///
  /// Cause this Activity to be recreated with a new instance.  This results
  /// in essentially the same flow as when the Activity is created due to
  /// a configuration change -- the current instance will go through its
  /// lifecycle to \#onDestroy and a new instance then created after it.
  void recreate() => _recreate(reference).check();

  static final _finish = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__finish")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void finish()
  ///
  /// Call this when your activity is done and should be closed.  The
  /// ActivityResult is propagated back to whoever launched you via
  /// onActivityResult().
  void finish() => _finish(reference).check();

  static final _finishAffinity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__finishAffinity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void finishAffinity()
  ///
  /// Finish this activity as well as all activities immediately below it
  /// in the current task that have the same affinity.  This is typically
  /// used when an application can be launched on to another task (such as
  /// from an ACTION_VIEW of a content type it understands) and the user
  /// has used the up navigation to switch out of the current task and in
  /// to its own task.  In this case, if the user has navigated down into
  /// any other activities of the second application, all of those should
  /// be removed from the original task as part of the task switch.
  ///
  /// Note that this finish does _not_ allow you to deliver results
  /// to the previous activity, and an exception will be thrown if you are trying
  /// to do so.
  ///
  void finishAffinity() => _finishAffinity(reference).check();

  static final _finishFromChild = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__finishFromChild")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void finishFromChild(android.app.Activity child)
  ///
  /// This is called when a child activity of this one calls its
  /// \#finish method.  The default implementation simply calls
  /// finish() on this activity (the parent), finishing the entire group.
  ///@param child The activity making the call.
  ///@see \#finish
  void finishFromChild(Activity child) =>
      _finishFromChild(reference, child.reference).check();

  static final _finishAfterTransition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__finishAfterTransition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void finishAfterTransition()
  ///
  /// Reverses the Activity Scene entry Transition and triggers the calling Activity
  /// to reverse its exit Transition. When the exit Transition completes,
  /// \#finish() is called. If no entry Transition was used, finish() is called
  /// immediately and the Activity exit Transition is run.
  ///@see android.app.ActivityOptions\#makeSceneTransitionAnimation(Activity, android.util.Pair[])
  void finishAfterTransition() => _finishAfterTransition(reference).check();

  static final _finishActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__finishActivity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void finishActivity(int requestCode)
  ///
  /// Force finish another activity that you had previously started with
  /// \#startActivityForResult.
  ///@param requestCode The request code of the activity that you had
  ///                    given to startActivityForResult().  If there are multiple
  ///                    activities started with this request code, they
  ///                    will all be finished.
  void finishActivity(int requestCode) =>
      _finishActivity(reference, requestCode).check();

  static final _finishActivityFromChild = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__finishActivityFromChild")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void finishActivityFromChild(android.app.Activity child, int requestCode)
  ///
  /// This is called when a child activity of this one calls its
  /// finishActivity().
  ///@param child The activity making the call.
  /// This value must never be {@code null}.
  ///@param requestCode Request code that had been used to start the
  ///                    activity.
  void finishActivityFromChild(Activity child, int requestCode) =>
      _finishActivityFromChild(reference, child.reference, requestCode).check();

  static final _finishAndRemoveTask = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__finishAndRemoveTask")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void finishAndRemoveTask()
  ///
  /// Call this when your activity is done and should be closed and the task should be completely
  /// removed as a part of finishing the root activity of the task.
  void finishAndRemoveTask() => _finishAndRemoveTask(reference).check();

  static final _releaseInstance = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__releaseInstance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean releaseInstance()
  ///
  /// Ask that the local app instance of this activity be released to free up its memory.
  /// This is asking for the activity to be destroyed, but does __not__ finish the activity --
  /// a new instance of the activity will later be re-created if needed due to the user
  /// navigating back to it.
  ///@return Returns true if the activity was in a state that it has started the process
  /// of destroying its current instance; returns false if for any reason this could not
  /// be done: it is currently visible to the user, it is already being destroyed, it is
  /// being finished, it hasn't yet saved its state, etc.
  bool releaseInstance() => _releaseInstance(reference).boolean;

  static final _onActivityResult = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__onActivityResult")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onActivityResult(int requestCode, int resultCode, android.content.Intent data)
  ///
  /// Called when an activity you launched exits, giving you the requestCode
  /// you started it with, the resultCode it returned, and any additional
  /// data from it.  The <var>resultCode</var> will be
  /// \#RESULT_CANCELED if the activity explicitly returned that,
  /// didn't return any result, or crashed during its operation.
  ///
  /// You will receive this call immediately before onResume() when your
  /// activity is re-starting.
  ///
  /// This method is never invoked if your activity sets
  /// android.R.styleable\#AndroidManifestActivity_noHistory noHistory to
  /// <code>true</code>.
  ///@param requestCode The integer request code originally supplied to
  ///                    startActivityForResult(), allowing you to identify who this
  ///                    result came from.
  ///@param resultCode The integer result code returned by the child activity
  ///                   through its setResult().
  ///@param data An Intent, which can return result data to the caller
  ///               (various data can be attached to Intent "extras").
  ///@see \#startActivityForResult
  ///@see \#createPendingResult
  ///@see \#setResult(int)
  void onActivityResult(
          int requestCode, int resultCode, content_.Intent data) =>
      _onActivityResult(reference, requestCode, resultCode, data.reference)
          .check();

  static final _onActivityReenter = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Activity__onActivityReenter")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onActivityReenter(int resultCode, android.content.Intent data)
  ///
  /// Called when an activity you launched with an activity transition exposes this
  /// Activity through a returning activity transition, giving you the resultCode
  /// and any additional data from it. This method will only be called if the activity
  /// set a result code other than \#RESULT_CANCELED and it supports activity
  /// transitions with Window\#FEATURE_ACTIVITY_TRANSITIONS.
  ///
  /// The purpose of this function is to let the called Activity send a hint about
  /// its state so that this underlying Activity can prepare to be exposed. A call to
  /// this method does not guarantee that the called Activity has or will be exiting soon.
  /// It only indicates that it will expose this Activity's Window and it has
  /// some data to pass to prepare it.
  ///
  ///@param resultCode The integer result code returned by the child activity
  ///                   through its setResult().
  ///@param data An Intent, which can return result data to the caller
  ///               (various data can be attached to Intent "extras").
  void onActivityReenter(int resultCode, content_.Intent data) =>
      _onActivityReenter(reference, resultCode, data.reference).check();

  static final _createPendingResult = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__createPendingResult")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.PendingIntent createPendingResult(int requestCode, android.content.Intent data, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new PendingIntent object which you can hand to others
  /// for them to use to send result data back to your
  /// \#onActivityResult callback.  The created object will be either
  /// one-shot (becoming invalid after a result is sent back) or multiple
  /// (allowing any number of results to be sent through it).
  ///@param requestCode Private request code for the sender that will be
  /// associated with the result data when it is returned.  The sender can not
  /// modify this value, allowing you to identify incoming results.
  ///@param data Default data to supply in the result, which may be modified
  /// by the sender.
  /// This value must never be {@code null}.
  ///@param flags May be PendingIntent\#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT,
  /// PendingIntent\#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE,
  /// PendingIntent\#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT,
  /// PendingIntent\#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT,
  /// or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if
  /// PendingIntent\#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE has been
  /// supplied.
  ///@see PendingIntent
  PendingIntent createPendingResult(
          int requestCode, content_.Intent data, int flags) =>
      PendingIntent.fromRef(
          _createPendingResult(reference, requestCode, data.reference, flags)
              .object);

  static final _setRequestedOrientation = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__setRequestedOrientation")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setRequestedOrientation(int requestedOrientation)
  ///
  /// Change the desired orientation of this activity.  If the activity
  /// is currently in the foreground or otherwise impacting the screen
  /// orientation, the screen will immediately be changed (possibly causing
  /// the activity to be restarted). Otherwise, this will be used the next
  /// time the activity is visible.
  ///@param requestedOrientation An orientation constant as used in
  /// ActivityInfo\#screenOrientation ActivityInfo.screenOrientation.
  ///
  /// Value is android.content.pm.ActivityInfo.SCREEN_ORIENTATION_UNSET, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_UNSPECIFIED, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_BEHIND, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_NOSENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_REVERSE_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_REVERSE_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_FULL_SENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_FULL_USER, or android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_LOCKED
  void setRequestedOrientation(int requestedOrientation) =>
      _setRequestedOrientation(reference, requestedOrientation).check();

  static final _getRequestedOrientation = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getRequestedOrientation")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getRequestedOrientation()
  ///
  /// Return the current requested orientation of the activity.  This will
  /// either be the orientation requested in its component's manifest, or
  /// the last requested orientation given to
  /// \#setRequestedOrientation(int).
  ///@return Returns an orientation constant as used in
  /// ActivityInfo\#screenOrientation ActivityInfo.screenOrientation.
  ///
  /// Value is android.content.pm.ActivityInfo.SCREEN_ORIENTATION_UNSET, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_UNSPECIFIED, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_BEHIND, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_NOSENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_SENSOR_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_REVERSE_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_REVERSE_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_FULL_SENSOR, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER_LANDSCAPE, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_USER_PORTRAIT, android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_FULL_USER, or android.content.pm.ActivityInfo\#SCREEN_ORIENTATION_LOCKED
  int getRequestedOrientation() => _getRequestedOrientation(reference).integer;

  static final _getTaskId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getTaskId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getTaskId()
  ///
  /// Return the identifier of the task this activity is in.  This identifier
  /// will remain the same for the lifetime of the activity.
  ///@return Task identifier, an opaque integer.
  int getTaskId() => _getTaskId(reference).integer;

  static final _isTaskRoot = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__isTaskRoot")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isTaskRoot()
  ///
  /// Return whether this activity is the root of a task.  The root is the
  /// first activity in a task.
  ///@return True if this is the root activity, else false.
  bool isTaskRoot() => _isTaskRoot(reference).boolean;

  static final _moveTaskToBack = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Activity__moveTaskToBack")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean moveTaskToBack(boolean nonRoot)
  ///
  /// Move the task containing this activity to the back of the activity
  /// stack.  The activity's order within the task is unchanged.
  ///@param nonRoot If false then this only works if the activity is the root
  ///                of a task; if true it will work for any activity in
  ///                a task.
  ///@return If the task was moved (or it was already at the
  ///         back) true is returned, else false.
  bool moveTaskToBack(bool nonRoot) =>
      _moveTaskToBack(reference, nonRoot ? 1 : 0).boolean;

  static final _getLocalClassName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getLocalClassName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getLocalClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns class name for this activity with the package prefix removed.
  /// This is the default name used to read and write settings.
  ///@return The local class name.
  ///
  /// This value will never be {@code null}.
  jni.JniString getLocalClassName() =>
      jni.JniString.fromRef(_getLocalClassName(reference).object);

  static final _getComponentName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getComponentName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getComponentName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the complete component name of this activity.
  ///@return Returns the complete component name for this activity
  content_.ComponentName getComponentName() =>
      content_.ComponentName.fromRef(_getComponentName(reference).object);

  static final _getPreferences = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__getPreferences")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.SharedPreferences getPreferences(int mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a SharedPreferences object for accessing preferences
  /// that are private to this activity.  This simply calls the underlying
  /// \#getSharedPreferences(String, int) method by passing in this activity's
  /// class name as the preferences name.
  ///@param mode Operating mode.  Use \#MODE_PRIVATE for the default
  ///             operation.
  ///
  /// Value is either <code>0</code> or a combination of android.content.Context\#MODE_PRIVATE, android.content.Context\#MODE_WORLD_READABLE, android.content.Context\#MODE_WORLD_WRITEABLE, and android.content.Context\#MODE_MULTI_PROCESS
  ///@return Returns the single SharedPreferences instance that can be used
  ///         to retrieve and modify the preference values.
  content_.SharedPreferences getPreferences(int mode) =>
      content_.SharedPreferences.fromRef(
          _getPreferences(reference, mode).object);

  static final _getSystemService = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__getSystemService")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.Object getSystemService(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @param name Value is android.content.Context\#POWER_SERVICE, android.content.Context\#WINDOW_SERVICE, android.content.Context\#LAYOUT_INFLATER_SERVICE, android.content.Context\#ACCOUNT_SERVICE, android.content.Context\#ACTIVITY_SERVICE, android.content.Context\#ALARM_SERVICE, android.content.Context\#NOTIFICATION_SERVICE, android.content.Context\#ACCESSIBILITY_SERVICE, android.content.Context\#CAPTIONING_SERVICE, android.content.Context\#KEYGUARD_SERVICE, android.content.Context\#LOCATION_SERVICE, android.content.Context\#SEARCH_SERVICE, android.content.Context\#SENSOR_SERVICE, android.content.Context\#STORAGE_SERVICE, android.content.Context\#STORAGE_STATS_SERVICE, android.content.Context\#WALLPAPER_SERVICE, android.content.Context.TIME_ZONE_RULES_MANAGER_SERVICE, android.content.Context\#VIBRATOR_SERVICE, android.content.Context\#CONNECTIVITY_SERVICE, android.content.Context\#IPSEC_SERVICE, android.content.Context\#NETWORK_STATS_SERVICE, android.content.Context\#WIFI_SERVICE, android.content.Context\#WIFI_AWARE_SERVICE, android.content.Context\#WIFI_P2P_SERVICE, android.content.Context.WIFI_SCANNING_SERVICE, android.content.Context\#WIFI_RTT_RANGING_SERVICE, android.content.Context\#NSD_SERVICE, android.content.Context\#AUDIO_SERVICE, android.content.Context\#FINGERPRINT_SERVICE, android.content.Context\#MEDIA_ROUTER_SERVICE, android.content.Context\#TELEPHONY_SERVICE, android.content.Context\#TELEPHONY_SUBSCRIPTION_SERVICE, android.content.Context\#CARRIER_CONFIG_SERVICE, android.content.Context\#TELECOM_SERVICE, android.content.Context\#CLIPBOARD_SERVICE, android.content.Context\#INPUT_METHOD_SERVICE, android.content.Context\#TEXT_SERVICES_MANAGER_SERVICE, android.content.Context\#TEXT_CLASSIFICATION_SERVICE, android.content.Context\#APPWIDGET_SERVICE, android.content.Context\#DROPBOX_SERVICE, android.content.Context\#DEVICE_POLICY_SERVICE, android.content.Context\#UI_MODE_SERVICE, android.content.Context\#DOWNLOAD_SERVICE, android.content.Context\#NFC_SERVICE, android.content.Context\#BLUETOOTH_SERVICE, android.content.Context\#USB_SERVICE, android.content.Context\#LAUNCHER_APPS_SERVICE, android.content.Context\#INPUT_SERVICE, android.content.Context\#DISPLAY_SERVICE, android.content.Context\#USER_SERVICE, android.content.Context\#RESTRICTIONS_SERVICE, android.content.Context\#APP_OPS_SERVICE, android.content.Context\#CAMERA_SERVICE, android.content.Context\#PRINT_SERVICE, android.content.Context\#CONSUMER_IR_SERVICE, android.content.Context\#TV_INPUT_SERVICE, android.content.Context\#USAGE_STATS_SERVICE, android.content.Context\#MEDIA_SESSION_SERVICE, android.content.Context\#BATTERY_SERVICE, android.content.Context\#JOB_SCHEDULER_SERVICE, android.content.Context\#MEDIA_PROJECTION_SERVICE, android.content.Context\#MIDI_SERVICE, android.content.Context.RADIO_SERVICE, android.content.Context\#HARDWARE_PROPERTIES_SERVICE, android.content.Context\#SHORTCUT_SERVICE, android.content.Context\#SYSTEM_HEALTH_SERVICE, android.content.Context\#COMPANION_DEVICE_SERVICE, or android.content.Context\#CROSS_PROFILE_APPS_SERVICE
  ///
  /// This value must never be {@code null}.
  jni.JniObject getSystemService(jni.JniString name) => jni.JniObject.fromRef(
      _getSystemService(reference, name.reference).object);

  static final _setTitle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__setTitle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTitle(java.lang.CharSequence title)
  ///
  /// Change the title associated with this activity.  If this is a
  /// top-level activity, the title for its window will change.  If it
  /// is an embedded activity, the parent can do whatever it wants
  /// with it.
  void setTitle(jni.JniObject title) =>
      _setTitle(reference, title.reference).check();

  static final _setTitle1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Activity__setTitle1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setTitle(int titleId)
  ///
  /// Change the title associated with this activity.  If this is a
  /// top-level activity, the title for its window will change.  If it
  /// is an embedded activity, the parent can do whatever it wants
  /// with it.
  void setTitle1(int titleId) => _setTitle1(reference, titleId).check();

  static final _setTitleColor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Activity__setTitleColor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setTitleColor(int textColor)
  ///
  /// Change the color of the title associated with this activity.
  ///
  /// This method is deprecated starting in API Level 11 and replaced by action
  /// bar styles. For information on styling the Action Bar, read the <a href="{@docRoot} guide/topics/ui/actionbar.html">Action Bar</a> developer
  /// guide.
  ///@deprecated Use action bar styles instead.
  void setTitleColor(int textColor) =>
      _setTitleColor(reference, textColor).check();

  static final _getTitle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getTitle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.CharSequence getTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getTitle() =>
      jni.JniObject.fromRef(_getTitle(reference).object);

  static final _getTitleColor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getTitleColor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getTitleColor()
  int getTitleColor() => _getTitleColor(reference).integer;

  static final _onTitleChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__onTitleChanged")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: protected void onTitleChanged(java.lang.CharSequence title, int color)
  void onTitleChanged(jni.JniObject title, int color) =>
      _onTitleChanged(reference, title.reference, color).check();

  static final _onChildTitleChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onChildTitleChanged")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void onChildTitleChanged(android.app.Activity childActivity, java.lang.CharSequence title)
  void onChildTitleChanged(Activity childActivity, jni.JniObject title) =>
      _onChildTitleChanged(reference, childActivity.reference, title.reference)
          .check();

  static final _setTaskDescription = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__setTaskDescription")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTaskDescription(android.app.ActivityManager.TaskDescription taskDescription)
  ///
  /// Sets information describing the task with this activity for presentation inside the Recents
  /// System UI. When ActivityManager\#getRecentTasks is called, the activities of each task
  /// are traversed in order from the topmost activity to the bottommost. The traversal continues
  /// for each property until a suitable value is found. For each task the taskDescription will be
  /// returned in android.app.ActivityManager.TaskDescription.
  ///@see ActivityManager\#getRecentTasks
  ///@see android.app.ActivityManager.TaskDescription
  ///@param taskDescription The TaskDescription properties that describe the task with this activity
  void setTaskDescription(ActivityManager_TaskDescription taskDescription) =>
      _setTaskDescription(reference, taskDescription.reference).check();

  static final _setProgressBarVisibility = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Activity__setProgressBarVisibility")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setProgressBarVisibility(boolean visible)
  ///
  /// Sets the visibility of the progress bar in the title.
  ///
  /// In order for the progress bar to be shown, the feature must be requested
  /// via \#requestWindowFeature(int).
  ///@param visible Whether to show the progress bars in the title.
  ///@deprecated No longer supported starting in API 21.
  void setProgressBarVisibility(bool visible) =>
      _setProgressBarVisibility(reference, visible ? 1 : 0).check();

  static final _setProgressBarIndeterminateVisibility = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "Activity__setProgressBarIndeterminateVisibility")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setProgressBarIndeterminateVisibility(boolean visible)
  ///
  /// Sets the visibility of the indeterminate progress bar in the title.
  ///
  /// In order for the progress bar to be shown, the feature must be requested
  /// via \#requestWindowFeature(int).
  ///@param visible Whether to show the progress bars in the title.
  ///@deprecated No longer supported starting in API 21.
  void setProgressBarIndeterminateVisibility(bool visible) =>
      _setProgressBarIndeterminateVisibility(reference, visible ? 1 : 0)
          .check();

  static final _setProgressBarIndeterminate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Activity__setProgressBarIndeterminate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setProgressBarIndeterminate(boolean indeterminate)
  ///
  /// Sets whether the horizontal progress bar in the title should be indeterminate (the circular
  /// is always indeterminate).
  ///
  /// In order for the progress bar to be shown, the feature must be requested
  /// via \#requestWindowFeature(int).
  ///@param indeterminate Whether the horizontal progress bar should be indeterminate.
  ///@deprecated No longer supported starting in API 21.
  void setProgressBarIndeterminate(bool indeterminate) =>
      _setProgressBarIndeterminate(reference, indeterminate ? 1 : 0).check();

  static final _setProgress = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Activity__setProgress")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setProgress(int progress)
  ///
  /// Sets the progress for the progress bars in the title.
  ///
  /// In order for the progress bar to be shown, the feature must be requested
  /// via \#requestWindowFeature(int).
  ///@param progress The progress for the progress bar. Valid ranges are from
  ///            0 to 10000 (both inclusive). If 10000 is given, the progress
  ///            bar will be completely filled and will fade out.
  ///@deprecated No longer supported starting in API 21.
  void setProgress(int progress) => _setProgress(reference, progress).check();

  static final _setSecondaryProgress = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__setSecondaryProgress")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setSecondaryProgress(int secondaryProgress)
  ///
  /// Sets the secondary progress for the progress bar in the title. This
  /// progress is drawn between the primary progress (set via
  /// \#setProgress(int) and the background. It can be ideal for media
  /// scenarios such as showing the buffering progress while the default
  /// progress shows the play progress.
  ///
  /// In order for the progress bar to be shown, the feature must be requested
  /// via \#requestWindowFeature(int).
  ///@param secondaryProgress The secondary progress for the progress bar. Valid ranges are from
  ///            0 to 10000 (both inclusive).
  ///@deprecated No longer supported starting in API 21.
  void setSecondaryProgress(int secondaryProgress) =>
      _setSecondaryProgress(reference, secondaryProgress).check();

  static final _setVolumeControlStream = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__setVolumeControlStream")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setVolumeControlStream(int streamType)
  ///
  /// Suggests an audio stream whose volume should be changed by the hardware
  /// volume controls.
  ///
  /// The suggested audio stream will be tied to the window of this Activity.
  /// Volume requests which are received while the Activity is in the
  /// foreground will affect this stream.
  ///
  /// It is not guaranteed that the hardware volume controls will always change
  /// this stream's volume (for example, if a call is in progress, its stream's
  /// volume may be changed instead). To reset back to the default, use
  /// AudioManager\#USE_DEFAULT_STREAM_TYPE.
  ///@param streamType The type of the audio stream whose volume should be
  ///            changed by the hardware volume controls.
  void setVolumeControlStream(int streamType) =>
      _setVolumeControlStream(reference, streamType).check();

  static final _getVolumeControlStream = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getVolumeControlStream")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getVolumeControlStream()
  ///
  /// Gets the suggested audio stream whose volume should be changed by the
  /// hardware volume controls.
  ///@return The suggested audio stream type whose volume should be changed by
  ///         the hardware volume controls.
  ///@see \#setVolumeControlStream(int)
  int getVolumeControlStream() => _getVolumeControlStream(reference).integer;

  static final _setMediaController = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__setMediaController")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setMediaController(android.media.session.MediaController controller)
  ///
  /// Sets a MediaController to send media keys and volume changes to.
  ///
  /// The controller will be tied to the window of this Activity. Media key and
  /// volume events which are received while the Activity is in the foreground
  /// will be forwarded to the controller and used to invoke transport controls
  /// or adjust the volume. This may be used instead of or in addition to
  /// \#setVolumeControlStream to affect a specific session instead of a
  /// specific stream.
  ///
  /// It is not guaranteed that the hardware volume controls will always change
  /// this session's volume (for example, if a call is in progress, its
  /// stream's volume may be changed instead). To reset back to the default use
  /// null as the controller.
  ///@param controller The controller for the session which should receive
  ///            media keys and volume changes.
  void setMediaController(jni.JniObject controller) =>
      _setMediaController(reference, controller.reference).check();

  static final _getMediaController = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getMediaController")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.media.session.MediaController getMediaController()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the controller which should be receiving media key and volume events
  /// while this activity is in the foreground.
  ///@return The controller which should receive events.
  ///@see \#setMediaController(android.media.session.MediaController)
  jni.JniObject getMediaController() =>
      jni.JniObject.fromRef(_getMediaController(reference).object);

  static final _runOnUiThread = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__runOnUiThread")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void runOnUiThread(java.lang.Runnable action)
  ///
  /// Runs the specified action on the UI thread. If the current thread is the UI
  /// thread, then the action is executed immediately. If the current thread is
  /// not the UI thread, the action is posted to the event queue of the UI thread.
  ///@param action the action to run on the UI thread
  void runOnUiThread(jni.JniObject action) =>
      _runOnUiThread(reference, action.reference).check();

  static final _onCreateView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onCreateView")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View onCreateView(java.lang.String name, android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Standard implementation of
  /// android.view.LayoutInflater.Factory\#onCreateView used when
  /// inflating with the LayoutInflater returned by \#getSystemService.
  /// This implementation does nothing and is for
  /// pre-android.os.Build.VERSION_CODES\#HONEYCOMB apps.  Newer apps
  /// should use \#onCreateView(View, String, Context, AttributeSet).
  ///@see android.view.LayoutInflater\#createView
  ///@see android.view.Window\#getLayoutInflater
  ///@return This value may be {@code null}.
  jni.JniObject onCreateView(
          jni.JniString name, content_.Context context, jni.JniObject attrs) =>
      jni.JniObject.fromRef(_onCreateView(
              reference, name.reference, context.reference, attrs.reference)
          .object);

  static final _onCreateView1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onCreateView1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View onCreateView(android.view.View parent, java.lang.String name, android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Standard implementation of
  /// android.view.LayoutInflater.Factory2\#onCreateView(View, String, Context, AttributeSet)
  /// used when inflating with the LayoutInflater returned by \#getSystemService.
  /// This implementation handles <fragment> tags to embed fragments inside
  /// of the activity.
  ///@see android.view.LayoutInflater\#createView
  ///@see android.view.Window\#getLayoutInflater
  jni.JniObject onCreateView1(jni.JniObject parent, jni.JniString name,
          content_.Context context, jni.JniObject attrs) =>
      jni.JniObject.fromRef(_onCreateView1(reference, parent.reference,
              name.reference, context.reference, attrs.reference)
          .object);

  static final _dump = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__dump")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  ///
  /// Print the Activity's state into the given stream.  This gets invoked if
  /// you run "adb shell dumpsys activity &lt;activity_component_name&gt;".
  ///@param prefix Desired prefix to prepend at each line of output.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer The PrintWriter to which you should dump your state.  This will be
  /// closed for you after you return.
  ///@param args additional arguments to the dump request.
  void dump(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
          jni.JniObject args) =>
      _dump(reference, prefix.reference, fd.reference, writer.reference,
              args.reference)
          .check();

  static final _isImmersive = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__isImmersive")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isImmersive()
  ///
  /// Bit indicating that this activity is "immersive" and should not be
  /// interrupted by notifications if possible.
  ///
  /// This value is initially set by the manifest property
  /// <code>android:immersive</code> but may be changed at runtime by
  /// \#setImmersive.
  ///@see \#setImmersive(boolean)
  ///@see android.content.pm.ActivityInfo\#FLAG_IMMERSIVE
  bool isImmersive() => _isImmersive(reference).boolean;

  static final _requestVisibleBehind = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Activity__requestVisibleBehind")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean requestVisibleBehind(boolean visible)
  ///
  /// Activities that want to remain visible behind a translucent activity above them must call
  /// this method anytime between the start of \#onResume() and the return from
  /// \#onPause(). If this call is successful then the activity will remain visible after
  /// \#onPause() is called, and is allowed to continue playing media in the background.
  ///
  /// The actions of this call are reset each time that this activity is brought to the
  /// front. That is, every time \#onResume() is called the activity will be assumed
  /// to not have requested visible behind. Therefore, if you want this activity to continue to
  /// be visible in the background you must call this method again.
  ///
  /// Only fullscreen opaque activities may make this call. I.e. this call is a nop
  /// for dialog and translucent activities.
  ///
  /// Under all circumstances, the activity must stop playing and release resources prior to or
  /// within a call to \#onVisibleBehindCanceled() or if this call returns false.
  ///
  /// False will be returned any time this method is called between the return of onPause and
  ///      the next call to onResume.
  ///@deprecated This method's functionality is no longer supported as of
  ///             android.os.Build.VERSION_CODES\#O and will be removed in a future release.
  ///@param visible true to notify the system that the activity wishes to be visible behind other
  ///                translucent activities, false to indicate otherwise. Resources must be
  ///                released when passing false to this method.
  ///@return the resulting visibiity state. If true the activity will remain visible beyond
  ///      \#onPause() if the next activity is translucent or not fullscreen. If false
  ///      then the activity may not count on being visible behind other translucent activities,
  ///      and must stop any media playback and release resources.
  ///      Returning false may occur in lieu of a call to \#onVisibleBehindCanceled() so
  ///      the return value must be checked.
  ///@see \#onVisibleBehindCanceled()
  bool requestVisibleBehind(bool visible) =>
      _requestVisibleBehind(reference, visible ? 1 : 0).boolean;

  static final _onVisibleBehindCanceled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onVisibleBehindCanceled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onVisibleBehindCanceled()
  ///
  /// Called when a translucent activity over this activity is becoming opaque or another
  /// activity is being launched. Activities that override this method must call
  /// <code>super.onVisibleBehindCanceled()</code> or a SuperNotCalledException will be thrown.
  ///
  /// When this method is called the activity has 500 msec to release any resources it may be
  /// using while visible in the background.
  /// If the activity has not returned from this method in 500 msec the system will destroy
  /// the activity and kill the process in order to recover the resources for another
  /// process. Otherwise \#onStop() will be called following return.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@see \#requestVisibleBehind(boolean)
  ///@deprecated This method's functionality is no longer supported as of
  /// android.os.Build.VERSION_CODES\#O and will be removed in a future release.
  void onVisibleBehindCanceled() => _onVisibleBehindCanceled(reference).check();

  static final _onEnterAnimationComplete = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__onEnterAnimationComplete")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onEnterAnimationComplete()
  ///
  /// Activities cannot draw during the period that their windows are animating in. In order
  /// to know when it is safe to begin drawing they can override this method which will be
  /// called when the entering animation has completed.
  void onEnterAnimationComplete() =>
      _onEnterAnimationComplete(reference).check();

  static final _setImmersive = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Activity__setImmersive")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setImmersive(boolean i)
  ///
  /// Adjust the current immersive mode setting.
  ///
  /// Note that changing this value will have no effect on the activity's
  /// android.content.pm.ActivityInfo structure; that is, if
  /// <code>android:immersive</code> is set to <code>true</code>
  /// in the application's manifest entry for this activity, the android.content.pm.ActivityInfo\#flags ActivityInfo.flags member will
  /// always have its android.content.pm.ActivityInfo\#FLAG_IMMERSIVE FLAG_IMMERSIVE bit set.
  ///@see \#isImmersive()
  ///@see android.content.pm.ActivityInfo\#FLAG_IMMERSIVE
  void setImmersive(bool i) => _setImmersive(reference, i ? 1 : 0).check();

  static final _setVrModeEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                  ffi.Pointer<ffi.Void>)>>("Activity__setVrModeEnabled")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void setVrModeEnabled(boolean enabled, android.content.ComponentName requestedComponent)
  ///
  /// Enable or disable virtual reality (VR) mode for this Activity.
  ///
  /// VR mode is a hint to Android system to switch to a mode optimized for VR applications
  /// while this Activity has user focus.
  ///
  ///
  /// It is recommended that applications additionally declare
  /// android.R.attr\#enableVrMode in their manifest to allow for smooth activity
  /// transitions when switching between VR activities.
  ///
  ///
  /// If the requested android.service.vr.VrListenerService component is not available,
  /// VR mode will not be started.  Developers can handle this case as follows:
  ///
  ///
  /// <pre>
  /// String servicePackage = "com.whatever.app";
  /// String serviceClass = "com.whatever.app.MyVrListenerService";
  ///
  /// // Name of the component of the VrListenerService to start.
  /// ComponentName serviceComponent = new ComponentName(servicePackage, serviceClass);
  ///
  /// try {
  ///    setVrModeEnabled(true, myComponentName);
  /// } catch (PackageManager.NameNotFoundException e) {
  ///        List&lt;ApplicationInfo> installed = getPackageManager().getInstalledApplications(0);
  ///        boolean isInstalled = false;
  ///        for (ApplicationInfo app : installed) {
  ///            if (app.packageName.equals(servicePackage)) {
  ///                isInstalled = true;
  ///                break;
  ///            }
  ///        }
  ///        if (isInstalled) {
  ///            // Package is installed, but not enabled in Settings.  Let user enable it.
  ///            startActivity(new Intent(Settings.ACTION_VR_LISTENER_SETTINGS));
  ///        } else {
  ///            // Package is not installed.  Send an intent to download this.
  ///            sentIntentToLaunchAppStore(servicePackage);
  ///        }
  /// }
  /// </pre>
  ///@param enabled {@code true} to enable this mode.
  ///@param requestedComponent the name of the component to use as a
  ///        android.service.vr.VrListenerService while VR mode is enabled.
  ///
  /// This value must never be {@code null}.
  ///@throws android.content.pm.PackageManager.NameNotFoundException if the given component
  ///    to run as a android.service.vr.VrListenerService is not installed, or has
  ///    not been enabled in user settings.
  ///@see android.content.pm.PackageManager\#FEATURE_VR_MODE_HIGH_PERFORMANCE
  ///@see android.service.vr.VrListenerService
  ///@see android.provider.Settings\#ACTION_VR_LISTENER_SETTINGS
  ///@see android.R.attr\#enableVrMode
  void setVrModeEnabled(
          bool enabled, content_.ComponentName requestedComponent) =>
      _setVrModeEnabled(
              reference, enabled ? 1 : 0, requestedComponent.reference)
          .check();

  static final _startActionMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__startActionMode")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.ActionMode startActionMode(android.view.ActionMode.Callback callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start an action mode of the default type ActionMode\#TYPE_PRIMARY.
  ///@param callback Callback that will manage lifecycle events for this action mode
  ///@return The ActionMode that was started, or null if it was canceled
  ///@see ActionMode
  jni.JniObject startActionMode(jni.JniObject callback) =>
      jni.JniObject.fromRef(
          _startActionMode(reference, callback.reference).object);

  static final _startActionMode1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__startActionMode1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.ActionMode startActionMode(android.view.ActionMode.Callback callback, int type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start an action mode of the given type.
  ///@param callback Callback that will manage lifecycle events for this action mode
  ///@param type One of ActionMode\#TYPE_PRIMARY or ActionMode\#TYPE_FLOATING.
  ///@return The ActionMode that was started, or null if it was canceled
  ///@see ActionMode
  jni.JniObject startActionMode1(jni.JniObject callback, int type) =>
      jni.JniObject.fromRef(
          _startActionMode1(reference, callback.reference, type).object);

  static final _onWindowStartingActionMode = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Activity__onWindowStartingActionMode")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Give the Activity a chance to control the UI for an action mode requested
  /// by the system.
  ///
  /// Note: If you are looking for a notification callback that an action mode
  /// has been started for this activity, see \#onActionModeStarted(ActionMode).
  ///
  ///@param callback The callback that should control the new action mode
  ///@return The new action mode, or <code>null</code> if the activity does not want to
  ///         provide special handling for this action mode. (It will be handled by the system.)
  jni.JniObject onWindowStartingActionMode(jni.JniObject callback) =>
      jni.JniObject.fromRef(
          _onWindowStartingActionMode(reference, callback.reference).object);

  static final _onWindowStartingActionMode1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Activity__onWindowStartingActionMode1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback, int type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// {@inheritDoc}
  ///@return This value may be {@code null}.
  jni.JniObject onWindowStartingActionMode1(jni.JniObject callback, int type) =>
      jni.JniObject.fromRef(
          _onWindowStartingActionMode1(reference, callback.reference, type)
              .object);

  static final _onActionModeStarted = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onActionModeStarted")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onActionModeStarted(android.view.ActionMode mode)
  ///
  /// Notifies the Activity that an action mode has been started.
  /// Activity subclasses overriding this method should call the superclass implementation.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param mode The new action mode.
  void onActionModeStarted(jni.JniObject mode) =>
      _onActionModeStarted(reference, mode.reference).check();

  static final _onActionModeFinished = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__onActionModeFinished")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onActionModeFinished(android.view.ActionMode mode)
  ///
  /// Notifies the activity that an action mode has finished.
  /// Activity subclasses overriding this method should call the superclass implementation.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param mode The action mode that just finished.
  void onActionModeFinished(jni.JniObject mode) =>
      _onActionModeFinished(reference, mode.reference).check();

  static final _shouldUpRecreateTask = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__shouldUpRecreateTask")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldUpRecreateTask(android.content.Intent targetIntent)
  ///
  /// Returns true if the app should recreate the task when navigating 'up' from this activity
  /// by using targetIntent.
  ///
  /// If this method returns false the app can trivially call
  /// \#navigateUpTo(Intent) using the same parameters to correctly perform
  /// up navigation. If this method returns false, the app should synthesize a new task stack
  /// by using TaskStackBuilder or another similar mechanism to perform up navigation.
  ///
  ///@param targetIntent An intent representing the target destination for up navigation
  ///@return true if navigating up should recreate a new task stack, false if the same task
  ///         should be used for the destination
  bool shouldUpRecreateTask(content_.Intent targetIntent) =>
      _shouldUpRecreateTask(reference, targetIntent.reference).boolean;

  static final _navigateUpTo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__navigateUpTo")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean navigateUpTo(android.content.Intent upIntent)
  ///
  /// Navigate from this activity to the activity specified by upIntent, finishing this activity
  /// in the process. If the activity indicated by upIntent already exists in the task's history,
  /// this activity and all others before the indicated activity in the history stack will be
  /// finished.
  ///
  /// If the indicated activity does not appear in the history stack, this will finish
  /// each activity in this task until the root activity of the task is reached, resulting in
  /// an "in-app home" behavior. This can be useful in apps with a complex navigation hierarchy
  /// when an activity may be reached by a path not passing through a canonical parent
  /// activity.
  ///
  ///
  /// This method should be used when performing up navigation from within the same task
  /// as the destination. If up navigation should cross tasks in some cases, see
  /// \#shouldUpRecreateTask(Intent).
  ///
  ///@param upIntent An intent representing the target destination for up navigation
  ///@return true if up navigation successfully reached the activity indicated by upIntent and
  ///         upIntent was delivered to it. false if an instance of the indicated activity could
  ///         not be found and this activity was simply finished normally.
  bool navigateUpTo(content_.Intent upIntent) =>
      _navigateUpTo(reference, upIntent.reference).boolean;

  static final _navigateUpToFromChild = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Activity__navigateUpToFromChild")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean navigateUpToFromChild(android.app.Activity child, android.content.Intent upIntent)
  ///
  /// This is called when a child activity of this one calls its
  /// \#navigateUpTo method.  The default implementation simply calls
  /// navigateUpTo(upIntent) on this activity (the parent).
  ///@param child The activity making the call.
  ///@param upIntent An intent representing the target destination for up navigation
  ///@return true if up navigation successfully reached the activity indicated by upIntent and
  ///         upIntent was delivered to it. false if an instance of the indicated activity could
  ///         not be found and this activity was simply finished normally.
  bool navigateUpToFromChild(Activity child, content_.Intent upIntent) =>
      _navigateUpToFromChild(reference, child.reference, upIntent.reference)
          .boolean;

  static final _getParentActivityIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__getParentActivityIntent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent getParentActivityIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtain an Intent that will launch an explicit target activity specified by
  /// this activity's logical parent. The logical parent is named in the application's manifest
  /// by the android.R.attr\#parentActivityName parentActivityName attribute.
  /// Activity subclasses may override this method to modify the Intent returned by
  /// super.getParentActivityIntent() or to implement a different mechanism of retrieving
  /// the parent intent entirely.
  ///@return a new Intent targeting the defined parent of this activity or null if
  ///         there is no valid parent.
  content_.Intent getParentActivityIntent() =>
      content_.Intent.fromRef(_getParentActivityIntent(reference).object);

  static final _setEnterSharedElementCallback = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Activity__setEnterSharedElementCallback")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setEnterSharedElementCallback(android.app.SharedElementCallback callback)
  ///
  /// When android.app.ActivityOptions\#makeSceneTransitionAnimation(Activity,
  /// android.view.View, String) was used to start an Activity, <var>callback</var>
  /// will be called to handle shared elements on the <i>launched</i> Activity. This requires
  /// Window\#FEATURE_ACTIVITY_TRANSITIONS.
  ///@param callback Used to manipulate shared element transitions on the launched Activity.
  void setEnterSharedElementCallback(SharedElementCallback callback) =>
      _setEnterSharedElementCallback(reference, callback.reference).check();

  static final _setExitSharedElementCallback = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Activity__setExitSharedElementCallback")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExitSharedElementCallback(android.app.SharedElementCallback callback)
  ///
  /// When android.app.ActivityOptions\#makeSceneTransitionAnimation(Activity,
  /// android.view.View, String) was used to start an Activity, <var>callback</var>
  /// will be called to handle shared elements on the <i>launching</i> Activity. Most
  /// calls will only come when returning from the started Activity.
  /// This requires Window\#FEATURE_ACTIVITY_TRANSITIONS.
  ///@param callback Used to manipulate shared element transitions on the launching Activity.
  void setExitSharedElementCallback(SharedElementCallback callback) =>
      _setExitSharedElementCallback(reference, callback.reference).check();

  static final _postponeEnterTransition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__postponeEnterTransition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void postponeEnterTransition()
  ///
  /// Postpone the entering activity transition when Activity was started with
  /// android.app.ActivityOptions\#makeSceneTransitionAnimation(Activity,
  /// android.util.Pair[]).
  /// This method gives the Activity the ability to delay starting the entering and
  /// shared element transitions until all data is loaded. Until then, the Activity won't
  /// draw into its window, leaving the window transparent. This may also cause the
  /// returning animation to be delayed until data is ready. This method should be
  /// called in \#onCreate(android.os.Bundle) or in
  /// \#onActivityReenter(int, android.content.Intent).
  /// \#startPostponedEnterTransition() must be called to allow the Activity to
  /// start the transitions. If the Activity did not use
  /// android.app.ActivityOptions\#makeSceneTransitionAnimation(Activity,
  /// android.util.Pair[]), then this method does nothing.
  ///
  void postponeEnterTransition() => _postponeEnterTransition(reference).check();

  static final _startPostponedEnterTransition = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Activity__startPostponedEnterTransition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void startPostponedEnterTransition()
  ///
  /// Begin postponed transitions after \#postponeEnterTransition() was called.
  /// If postponeEnterTransition() was called, you must call startPostponedEnterTransition()
  /// to have your Activity start drawing.
  void startPostponedEnterTransition() =>
      _startPostponedEnterTransition(reference).check();

  static final _requestDragAndDropPermissions = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Activity__requestDragAndDropPermissions")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.DragAndDropPermissions requestDragAndDropPermissions(android.view.DragEvent event)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create DragAndDropPermissions object bound to this activity and controlling the
  /// access permissions for content URIs associated with the DragEvent.
  ///@param event Drag event
  ///@return The DragAndDropPermissions object used to control access to the content URIs.
  /// Null if no content URIs are associated with the event or if permissions could not be granted.
  jni.JniObject requestDragAndDropPermissions(jni.JniObject event) =>
      jni.JniObject.fromRef(
          _requestDragAndDropPermissions(reference, event.reference).object);

  static final _startLockTask = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__startLockTask")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void startLockTask()
  ///
  /// Request to put this activity in a mode where the user is locked to a restricted set of
  /// applications.
  ///
  /// If DevicePolicyManager\#isLockTaskPermitted(String) returns {@code true}
  /// for this component, the current task will be launched directly into LockTask mode. Only apps
  /// whitelisted by DevicePolicyManager\#setLockTaskPackages(ComponentName, String[]) can
  /// be launched while LockTask mode is active. The user will not be able to leave this mode
  /// until this activity calls \#stopLockTask(). Calling this method while the device is
  /// already in LockTask mode has no effect.
  ///
  /// Otherwise, the current task will be launched into screen pinning mode. In this case, the
  /// system will prompt the user with a dialog requesting permission to use this mode.
  /// The user can exit at any time through instructions shown on the request dialog. Calling
  /// \#stopLockTask() will also terminate this mode.
  ///
  /// <strong>Note:</strong> this method can only be called when the activity is foreground.
  /// That is, between \#onResume() and \#onPause().
  ///@see \#stopLockTask()
  ///@see android.R.attr\#lockTaskMode
  void startLockTask() => _startLockTask(reference).check();

  static final _stopLockTask = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Activity__stopLockTask")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void stopLockTask()
  ///
  /// Stop the current task from being locked.
  ///
  /// Called to end the LockTask or screen pinning mode started by \#startLockTask().
  /// This can only be called by activities that have called \#startLockTask() previously.
  ///
  /// <strong>Note:</strong> If the device is in LockTask mode that is not initially started
  /// by this activity, then calling this method will not terminate the LockTask mode, but only
  /// finish its own task. The device will remain in LockTask mode, until the activity which
  /// started the LockTask mode calls this method, or until its whitelist authorization is revoked
  /// by DevicePolicyManager\#setLockTaskPackages(ComponentName, String[]).
  ///@see \#startLockTask()
  ///@see android.R.attr\#lockTaskMode
  ///@see ActivityManager\#getLockTaskModeState()
  void stopLockTask() => _stopLockTask(reference).check();

  static final _showLockTaskEscapeMessage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Activity__showLockTaskEscapeMessage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void showLockTaskEscapeMessage()
  ///
  /// Shows the user the system defined message for telling the user how to exit
  /// lock task mode. The task containing this activity must be in lock task mode at the time
  /// of this call for the message to be displayed.
  void showLockTaskEscapeMessage() =>
      _showLockTaskEscapeMessage(reference).check();

  static final _setShowWhenLocked = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Activity__setShowWhenLocked")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setShowWhenLocked(boolean showWhenLocked)
  ///
  /// Specifies whether an Activity should be shown on top of the the lock screen whenever
  /// the lockscreen is up and the activity is resumed. Normally an activity will be transitioned
  /// to the stopped state if it is started while the lockscreen is up, but with this flag set the
  /// activity will remain in the resumed state visible on-top of the lock screen. This value can
  /// be set as a manifest attribute using android.R.attr\#showWhenLocked.
  ///@param showWhenLocked {@code true} to show the Activity on top of the lock screen;
  ///                                   {@code false} otherwise.
  ///@see \#setTurnScreenOn(boolean)
  ///@see android.R.attr\#turnScreenOn
  ///@see android.R.attr\#showWhenLocked
  void setShowWhenLocked(bool showWhenLocked) =>
      _setShowWhenLocked(reference, showWhenLocked ? 1 : 0).check();

  static final _setTurnScreenOn = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Activity__setTurnScreenOn")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setTurnScreenOn(boolean turnScreenOn)
  ///
  /// Specifies whether the screen should be turned on when the Activity is resumed.
  /// Normally an activity will be transitioned to the stopped state if it is started while the
  /// screen if off, but with this flag set the activity will cause the screen to turn on if the
  /// activity will be visible and resumed due to the screen coming on. The screen will not be
  /// turned on if the activity won't be visible after the screen is turned on. This flag is
  /// normally used in conjunction with the android.R.attr\#showWhenLocked flag to make sure
  /// the activity is visible after the screen is turned on when the lockscreen is up. In addition,
  /// if this flag is set and the activity calls KeyguardManager\#requestDismissKeyguard(Activity, KeyguardManager.KeyguardDismissCallback)
  /// the screen will turn on.
  ///@param turnScreenOn {@code true} to turn on the screen; {@code false} otherwise.
  ///@see \#setShowWhenLocked(boolean)
  ///@see android.R.attr\#turnScreenOn
  ///@see android.R.attr\#showWhenLocked
  void setTurnScreenOn(bool turnScreenOn) =>
      _setTurnScreenOn(reference, turnScreenOn ? 1 : 0).check();
}

/// from: android.app.ActivityGroup
///
/// A screen that contains and runs multiple embedded activities.
///@deprecated Use the new Fragment and FragmentManager APIs
/// instead; these are also
/// available on older platforms through the Android compatibility package.
class ActivityGroup extends Activity {
  ActivityGroup.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ActivityGroup__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ActivityGroup() : super.fromRef(_ctor().object);

  static final _ctor1 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Uint8)>>(
              "ActivityGroup__ctor1")
          .asFunction<jni.JniResult Function(int)>();

  /// from: public void <init>(boolean singleActivityMode)
  ActivityGroup.ctor1(bool singleActivityMode)
      : super.fromRef(_ctor1(singleActivityMode ? 1 : 0).object);

  static final _onCreate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActivityGroup__onCreate")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onCreate(android.os.Bundle savedInstanceState)
  void onCreate(os_.Bundle savedInstanceState) =>
      _onCreate(reference, savedInstanceState.reference).check();

  static final _onResume = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActivityGroup__onResume")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onResume()
  void onResume() => _onResume(reference).check();

  static final _onSaveInstanceState = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActivityGroup__onSaveInstanceState")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onSaveInstanceState(android.os.Bundle outState)
  void onSaveInstanceState(os_.Bundle outState) =>
      _onSaveInstanceState(reference, outState.reference).check();

  static final _onPause = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActivityGroup__onPause")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPause()
  void onPause() => _onPause(reference).check();

  static final _onStop = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActivityGroup__onStop")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStop()
  void onStop() => _onStop(reference).check();

  static final _onDestroy = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActivityGroup__onDestroy")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onDestroy()
  void onDestroy() => _onDestroy(reference).check();

  static final _getCurrentActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActivityGroup__getCurrentActivity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity getCurrentActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Activity getCurrentActivity() =>
      Activity.fromRef(_getCurrentActivity(reference).object);

  static final _getLocalActivityManager = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityGroup__getLocalActivityManager")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.LocalActivityManager getLocalActivityManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  LocalActivityManager getLocalActivityManager() =>
      LocalActivityManager.fromRef(_getLocalActivityManager(reference).object);
}

/// from: android.app.ActivityManager
///
///
/// This class gives information about, and interacts
/// with, activities, services, and the containing
/// process.
///
///
///
///
/// A number of the methods in this class are for
/// debugging or informational purposes and they should
/// not be used to affect any runtime behavior of
/// your app. These methods are called out as such in
/// the method level documentation.
///
///
///
///
/// Most application developers should not have the need to
/// use this class, most of whose methods are for specialized
/// use cases. However, a few methods are more broadly applicable.
/// For instance, android.app.ActivityManager\#isLowRamDevice() isLowRamDevice()
/// enables your app to detect whether it is running on a low-memory device,
/// and behave accordingly.
/// android.app.ActivityManager\#clearApplicationUserData() clearApplicationUserData()
/// is for apps with reset-data functionality.
///
///
///
///
/// In some special use cases, where an app interacts with
/// its Task stack, the app may use the
/// android.app.ActivityManager.AppTask and
/// android.app.ActivityManager.RecentTaskInfo inner
/// classes. However, in general, the methods in this class should
/// be used for testing and debugging purposes only.
///
///
class ActivityManager extends jni.JniObject {
  ActivityManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_REPORT_HEAP_LIMIT
  ///
  /// Action an app can implement to handle reports from \#setWatchHeapLimit(long).
  /// If your package has an activity handling this action, it will be launched with the
  /// heap data provided to it the same way as Intent\#ACTION_SEND.  Note that to
  /// match the activty must support this action and a MIME type of "*&\#47;*".
  static const ACTION_REPORT_HEAP_LIMIT =
      "android.app.action.REPORT_HEAP_LIMIT";

  /// from: static public final int LOCK_TASK_MODE_LOCKED
  ///
  /// Full lock task mode is active.
  static const LOCK_TASK_MODE_LOCKED = 1;

  /// from: static public final int LOCK_TASK_MODE_NONE
  ///
  /// Lock task mode is not active.
  static const LOCK_TASK_MODE_NONE = 0;

  /// from: static public final int LOCK_TASK_MODE_PINNED
  ///
  /// App pinning mode is active.
  static const LOCK_TASK_MODE_PINNED = 2;

  /// from: static public final java.lang.String META_HOME_ALTERNATE
  ///
  /// <a href="{@docRoot}guide/topics/manifest/meta-data-element.html">{@code
  /// <meta-data>}</a> name for a 'home' Activity that declares a package that is to be
  /// uninstalled in lieu of the declaring one.  The package named here must be
  /// signed with the same certificate as the one declaring the {@code <meta-data>}.
  static const META_HOME_ALTERNATE = "android.app.home.alternate";

  /// from: static public final int MOVE_TASK_NO_USER_ACTION
  ///
  /// Flag for \#moveTaskToFront(int, int): don't count this as a
  /// user-instigated action, so the current activity will not receive a
  /// hint that the user is leaving.
  static const MOVE_TASK_NO_USER_ACTION = 2;

  /// from: static public final int MOVE_TASK_WITH_HOME
  ///
  /// Flag for \#moveTaskToFront(int, int): also move the "home"
  /// activity along with the task, so it is positioned immediately behind
  /// the task.
  static const MOVE_TASK_WITH_HOME = 1;

  /// from: static public final int RECENT_IGNORE_UNAVAILABLE
  ///
  /// Provides a list that does not contain any
  /// recent tasks that currently are not available to the user.
  static const RECENT_IGNORE_UNAVAILABLE = 2;

  /// from: static public final int RECENT_WITH_EXCLUDED
  ///
  /// Flag for use with \#getRecentTasks: return all tasks, even those
  /// that have set their
  /// android.content.Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS flag.
  static const RECENT_WITH_EXCLUDED = 1;

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActivityManager__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.content.Context context, android.os.Handler handler)
  ActivityManager(content_.Context context, os_.Handler handler)
      : super.fromRef(_ctor(context.reference, handler.reference).object);

  static final _getMemoryClass = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActivityManager__getMemoryClass")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getMemoryClass()
  ///
  /// Return the approximate per-application memory class of the current
  /// device.  This gives you an idea of how hard a memory limit you should
  /// impose on your application to let the overall system work best.  The
  /// returned value is in megabytes; the baseline Android memory class is
  /// 16 (which happens to be the Java heap limit of those devices); some
  /// devices with more memory may return 24 or even higher numbers.
  int getMemoryClass() => _getMemoryClass(reference).integer;

  static final _getLargeMemoryClass = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager__getLargeMemoryClass")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLargeMemoryClass()
  ///
  /// Return the approximate per-application memory class of the current
  /// device when an application is running with a large heap.  This is the
  /// space available for memory-intensive applications; most applications
  /// should not need this amount of memory, and should instead stay with the
  /// \#getMemoryClass() limit.  The returned value is in megabytes.
  /// This may be the same size as \#getMemoryClass() on memory
  /// constrained devices, or it may be significantly larger on devices with
  /// a large amount of available RAM.
  ///
  /// This is the size of the application's Dalvik heap if it has
  /// specified <code>android:largeHeap="true"</code> in its manifest.
  int getLargeMemoryClass() => _getLargeMemoryClass(reference).integer;

  static final _isLowRamDevice = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActivityManager__isLowRamDevice")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isLowRamDevice()
  ///
  /// Returns true if this is a low-RAM device.  Exactly whether a device is low-RAM
  /// is ultimately up to the device configuration, but currently it generally means
  /// something with 1GB or less of RAM.  This is mostly intended to be used by apps
  /// to determine whether they should turn off certain features that require more RAM.
  bool isLowRamDevice() => _isLowRamDevice(reference).boolean;

  static final _getRecentTasks = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("ActivityManager__getRecentTasks")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public java.util.List<android.app.ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  ///
  ///Return a list of the tasks that the user has recently launched, with
  /// the most recent being first and older ones after in order.
  ///
  /// __Note: this method is only intended for debugging and presenting
  /// task management user interfaces__.  This should never be used for
  /// core logic in an application, such as deciding between different
  /// behaviors based on the information found here.  Such uses are
  /// _not_ supported, and will likely break in the future.  For
  /// example, if multiple applications can be actively running at the
  /// same time, assumptions made about the meaning of the data here for
  /// purposes of control flow will be incorrect.
  ///
  ///@deprecated As of android.os.Build.VERSION_CODES\#LOLLIPOP, this method is
  /// no longer available to third party applications: the introduction of
  /// document-centric recents means
  /// it can leak personal information to the caller.  For backwards compatibility,
  /// it will still return a small subset of its data: at least the caller's
  /// own tasks (though see \#getAppTasks() for the correct supported
  /// way to retrieve that information), and possibly some other tasks
  /// such as home that are known to not be sensitive.
  ///@param maxNum The maximum number of entries to return in the list.  The
  /// actual number returned may be smaller, depending on how many tasks the
  /// user has started and the maximum number the system can remember.
  ///@param flags Information about what to return.  May be any combination
  /// of \#RECENT_WITH_EXCLUDED and \#RECENT_IGNORE_UNAVAILABLE.
  ///@return Returns a list of RecentTaskInfo records describing each of
  /// the recent tasks.
  jni.JniObject getRecentTasks(int maxNum, int flags) =>
      jni.JniObject.fromRef(_getRecentTasks(reference, maxNum, flags).object);

  static final _getAppTasks = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActivityManager__getAppTasks")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.ActivityManager.AppTask> getAppTasks()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the list of tasks associated with the calling application.
  ///@return The list of tasks associated with the application making this call.
  ///@throws SecurityException
  jni.JniObject getAppTasks() =>
      jni.JniObject.fromRef(_getAppTasks(reference).object);

  static final _getAppTaskThumbnailSize = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager__getAppTaskThumbnailSize")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.util.Size getAppTaskThumbnailSize()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the current design dimensions for AppTask thumbnails, for use
  /// with \#addAppTask.
  jni.JniObject getAppTaskThumbnailSize() =>
      jni.JniObject.fromRef(_getAppTaskThumbnailSize(reference).object);

  static final _addAppTask = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActivityManager__addAppTask")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int addAppTask(android.app.Activity activity, android.content.Intent intent, android.app.ActivityManager.TaskDescription description, android.graphics.Bitmap thumbnail)
  ///
  /// Add a new AppTask for the calling application.  This will create a new
  /// recents entry that is added to the __end__ of all existing recents.
  ///@param activity The activity that is adding the entry.   This is used to help determine
  /// the context that the new recents entry will be in.
  /// This value must never be {@code null}.
  ///@param intent The Intent that describes the recents entry.  This is the same Intent that
  /// you would have used to launch the activity for it.  In generally you will want to set
  /// both Intent\#FLAG_ACTIVITY_NEW_DOCUMENT and
  /// Intent\#FLAG_ACTIVITY_RETAIN_IN_RECENTS; the latter is required since this recents
  /// entry will exist without an activity, so it doesn't make sense to not retain it when
  /// its activity disappears.  The given Intent here also must have an explicit ComponentName
  /// set on it.
  /// This value must never be {@code null}.
  ///@param description Optional additional description information.
  /// This value may be {@code null}.
  ///@param thumbnail Thumbnail to use for the recents entry.  Should be the size given by
  /// \#getAppTaskThumbnailSize().  If the bitmap is not that exact size, it will be
  /// recreated in your process, probably in a way you don't like, before the recents entry
  /// is added.
  ///
  /// This value must never be {@code null}.
  ///@return Returns the task id of the newly added app task, or -1 if the add failed.  The
  /// most likely cause of failure is that there is no more room for more tasks for your app.
  int addAppTask(
          Activity activity,
          content_.Intent intent,
          ActivityManager_TaskDescription description,
          jni.JniObject thumbnail) =>
      _addAppTask(reference, activity.reference, intent.reference,
              description.reference, thumbnail.reference)
          .integer;

  static final _getRunningTasks = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ActivityManager__getRunningTasks")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.util.List<android.app.ActivityManager.RunningTaskInfo> getRunningTasks(int maxNum)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a list of the tasks that are currently running, with
  /// the most recent being first and older ones after in order.  Note that
  /// "running" does not mean any of the task's code is currently loaded or
  /// activity -- the task may have been frozen by the system, so that it
  /// can be restarted in its previous state when next brought to the
  /// foreground.
  ///
  /// __Note: this method is only intended for debugging and presenting
  /// task management user interfaces__.  This should never be used for
  /// core logic in an application, such as deciding between different
  /// behaviors based on the information found here.  Such uses are
  /// _not_ supported, and will likely break in the future.  For
  /// example, if multiple applications can be actively running at the
  /// same time, assumptions made about the meaning of the data here for
  /// purposes of control flow will be incorrect.
  ///
  ///@deprecated As of android.os.Build.VERSION_CODES\#LOLLIPOP, this method
  /// is no longer available to third party
  /// applications: the introduction of document-centric recents means
  /// it can leak person information to the caller.  For backwards compatibility,
  /// it will still return a small subset of its data: at least the caller's
  /// own tasks, and possibly some other tasks
  /// such as home that are known to not be sensitive.
  ///@param maxNum The maximum number of entries to return in the list.  The
  /// actual number returned may be smaller, depending on how many tasks the
  /// user has started.
  ///@return Returns a list of RunningTaskInfo records describing each of
  /// the running tasks.
  jni.JniObject getRunningTasks(int maxNum) =>
      jni.JniObject.fromRef(_getRunningTasks(reference, maxNum).object);

  static final _moveTaskToFront = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("ActivityManager__moveTaskToFront")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void moveTaskToFront(int taskId, int flags)
  ///
  /// Equivalent to calling \#moveTaskToFront(int, int, Bundle)
  /// with a null options argument.
  ///
  /// Requires android.Manifest.permission\#REORDER_TASKS
  ///@param taskId The identifier of the task to be moved, as found in
  /// RunningTaskInfo or RecentTaskInfo.
  ///@param flags Additional operational flags.
  ///
  /// Value is either <code>0</code> or a combination of android.app.ActivityManager\#MOVE_TASK_WITH_HOME, and android.app.ActivityManager\#MOVE_TASK_NO_USER_ACTION
  void moveTaskToFront(int taskId, int flags) =>
      _moveTaskToFront(reference, taskId, flags).check();

  static final _moveTaskToFront1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("ActivityManager__moveTaskToFront1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void moveTaskToFront(int taskId, int flags, android.os.Bundle options)
  ///
  /// Ask that the task associated with a given task ID be moved to the
  /// front of the stack, so it is now visible to the user.
  ///
  /// Requires android.Manifest.permission\#REORDER_TASKS
  ///@param taskId The identifier of the task to be moved, as found in
  /// RunningTaskInfo or RecentTaskInfo.
  ///@param flags Additional operational flags.
  /// Value is either <code>0</code> or a combination of android.app.ActivityManager\#MOVE_TASK_WITH_HOME, and android.app.ActivityManager\#MOVE_TASK_NO_USER_ACTION
  ///@param options Additional options for the operation, either null or
  /// as per Context\#startActivity(Intent, android.os.Bundle) Context.startActivity(Intent, Bundle).
  void moveTaskToFront1(int taskId, int flags, os_.Bundle options) =>
      _moveTaskToFront1(reference, taskId, flags, options.reference).check();

  static final _getRunningServices = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ActivityManager__getRunningServices")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.util.List<android.app.ActivityManager.RunningServiceInfo> getRunningServices(int maxNum)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a list of the services that are currently running.
  ///
  /// __Note: this method is only intended for debugging or implementing
  /// service management type user interfaces.__
  ///
  ///@deprecated As of android.os.Build.VERSION_CODES\#O, this method
  /// is no longer available to third party applications.  For backwards compatibility,
  /// it will still return the caller's own services.
  ///@param maxNum The maximum number of entries to return in the list.  The
  /// actual number returned may be smaller, depending on how many services
  /// are running.
  ///@return Returns a list of RunningServiceInfo records describing each of
  /// the running tasks.
  jni.JniObject getRunningServices(int maxNum) =>
      jni.JniObject.fromRef(_getRunningServices(reference, maxNum).object);

  static final _getRunningServiceControlPanel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActivityManager__getRunningServiceControlPanel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent getRunningServiceControlPanel(android.content.ComponentName service)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a PendingIntent you can start to show a control panel for the
  /// given running service.  If the service does not have a control panel,
  /// null is returned.
  PendingIntent getRunningServiceControlPanel(content_.ComponentName service) =>
      PendingIntent.fromRef(
          _getRunningServiceControlPanel(reference, service.reference).object);

  static final _getMemoryInfo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActivityManager__getMemoryInfo")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void getMemoryInfo(android.app.ActivityManager.MemoryInfo outInfo)
  ///
  /// Return general information about the memory state of the system.  This
  /// can be used to help decide how to manage your own memory, though note
  /// that polling is not recommended and
  /// android.content.ComponentCallbacks2\#onTrimMemory(int) ComponentCallbacks2.onTrimMemory(int) is the preferred way to do this.
  /// Also see \#getMyMemoryState for how to retrieve the current trim
  /// level of your process as needed, which gives a better hint for how to
  /// manage its memory.
  void getMemoryInfo(ActivityManager_MemoryInfo outInfo) =>
      _getMemoryInfo(reference, outInfo.reference).check();

  static final _clearApplicationUserData = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager__clearApplicationUserData")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean clearApplicationUserData()
  ///
  /// Permits an application to erase its own data from disk.  This is equivalent to
  /// the user choosing to clear the app's data from within the device settings UI.  It
  /// erases all dynamic data associated with the app -- its private data and data in its
  /// private area on external storage -- but does not remove the installed application
  /// itself, nor any OBB files. It also revokes all runtime permissions that the app has acquired,
  /// clears all notifications and removes all Uri grants related to this application.
  ///@return {@code true} if the application successfully requested that the application's
  ///     data be erased; {@code false} otherwise.
  bool clearApplicationUserData() =>
      _clearApplicationUserData(reference).boolean;

  static final _getProcessesInErrorState = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager__getProcessesInErrorState")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.ActivityManager.ProcessErrorStateInfo> getProcessesInErrorState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of any processes that are currently in an error condition.  The result
  /// will be null if all processes are running properly at this time.
  ///@return Returns a list of ProcessErrorStateInfo records, or null if there are no
  /// current error conditions (it will not return an empty list).  This list ordering is not
  /// specified.
  jni.JniObject getProcessesInErrorState() =>
      jni.JniObject.fromRef(_getProcessesInErrorState(reference).object);

  static final _isBackgroundRestricted = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager__isBackgroundRestricted")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isBackgroundRestricted()
  ///
  /// Query whether the user has enabled background restrictions for this app.
  ///
  ///  The user may chose to do this, if they see that an app is consuming an unreasonable
  /// amount of battery while in the background.
  ///
  ///
  ///  If true, any work that the app tries to do will be aggressively restricted while it is in
  /// the background. At a minimum, jobs and alarms will not execute and foreground services
  /// cannot be started unless an app activity is in the foreground.
  ///
  ///
  /// __ Note that these restrictions stay in effect even when the device is charging.__
  ///
  ///@return true if user has enforced background restrictions for this app, false otherwise.
  bool isBackgroundRestricted() => _isBackgroundRestricted(reference).boolean;

  static final _getRunningAppProcesses = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager__getRunningAppProcesses")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.ActivityManager.RunningAppProcessInfo> getRunningAppProcesses()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of application processes that are running on the device.
  ///
  /// __Note: this method is only intended for debugging or building
  /// a user-facing process management UI.__
  ///
  ///@return Returns a list of RunningAppProcessInfo records, or null if there are no
  /// running processes (it will not return an empty list).  This list ordering is not
  /// specified.
  jni.JniObject getRunningAppProcesses() =>
      jni.JniObject.fromRef(_getRunningAppProcesses(reference).object);

  static final _getMyMemoryState = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActivityManager__getMyMemoryState")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void getMyMemoryState(android.app.ActivityManager.RunningAppProcessInfo outState)
  ///
  /// Return global memory state information for the calling process.  This
  /// does not fill in all fields of the RunningAppProcessInfo.  The
  /// only fields that will be filled in are
  /// RunningAppProcessInfo\#pid,
  /// RunningAppProcessInfo\#uid,
  /// RunningAppProcessInfo\#lastTrimLevel,
  /// RunningAppProcessInfo\#importance,
  /// RunningAppProcessInfo\#lru, and
  /// RunningAppProcessInfo\#importanceReasonCode.
  static void getMyMemoryState(
          ActivityManager_RunningAppProcessInfo outState) =>
      _getMyMemoryState(outState.reference).check();

  static final _getProcessMemoryInfo = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActivityManager__getProcessMemoryInfo")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Debug.MemoryInfo[] getProcessMemoryInfo(int[] pids)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return information about the memory usage of one or more processes.
  ///
  /// __Note: this method is only intended for debugging or building
  /// a user-facing process management UI.__
  ///
  ///@param pids The pids of the processes whose memory usage is to be
  /// retrieved.
  ///@return Returns an array of memory information, one for each
  /// requested pid.
  jni.JniObject getProcessMemoryInfo(jni.JniObject pids) =>
      jni.JniObject.fromRef(
          _getProcessMemoryInfo(reference, pids.reference).object);

  static final _restartPackage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActivityManager__restartPackage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void restartPackage(java.lang.String packageName)
  ///
  /// @deprecated This is now just a wrapper for
  /// \#killBackgroundProcesses(String); the previous behavior here
  /// is no longer available to applications because it allows them to
  /// break other applications by removing their alarms, stopping their
  /// services, etc.
  void restartPackage(jni.JniString packageName) =>
      _restartPackage(reference, packageName.reference).check();

  static final _killBackgroundProcesses = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActivityManager__killBackgroundProcesses")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void killBackgroundProcesses(java.lang.String packageName)
  ///
  /// Have the system immediately kill all background processes associated
  /// with the given package.  This is the same as the kernel killing those
  /// processes to reclaim memory; the system will take care of restarting
  /// these processes in the future as needed.
  ///
  /// Requires android.Manifest.permission\#KILL_BACKGROUND_PROCESSES
  ///@param packageName The name of the package whose processes are to
  /// be killed.
  void killBackgroundProcesses(jni.JniString packageName) =>
      _killBackgroundProcesses(reference, packageName.reference).check();

  static final _getDeviceConfigurationInfo = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager__getDeviceConfigurationInfo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ConfigurationInfo getDeviceConfigurationInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the device configuration attributes.
  pm_.ConfigurationInfo getDeviceConfigurationInfo() =>
      pm_.ConfigurationInfo.fromRef(
          _getDeviceConfigurationInfo(reference).object);

  static final _getLauncherLargeIconDensity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager__getLauncherLargeIconDensity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLauncherLargeIconDensity()
  ///
  /// Get the preferred density of icons for the launcher. This is used when
  /// custom drawables are created (e.g., for shortcuts).
  ///@return density in terms of DPI
  int getLauncherLargeIconDensity() =>
      _getLauncherLargeIconDensity(reference).integer;

  static final _getLauncherLargeIconSize = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager__getLauncherLargeIconSize")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLauncherLargeIconSize()
  ///
  /// Get the preferred launcher icon size. This is used when custom drawables
  /// are created (e.g., for shortcuts).
  ///@return dimensions of square icons in terms of pixels
  int getLauncherLargeIconSize() =>
      _getLauncherLargeIconSize(reference).integer;

  static final _isUserAMonkey =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "ActivityManager__isUserAMonkey")
          .asFunction<jni.JniResult Function()>();

  /// from: static public boolean isUserAMonkey()
  ///
  /// Returns "true" if the user interface is currently being messed with
  /// by a monkey.
  static bool isUserAMonkey() => _isUserAMonkey().boolean;

  static final _isRunningInTestHarness =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "ActivityManager__isRunningInTestHarness")
          .asFunction<jni.JniResult Function()>();

  /// from: static public boolean isRunningInTestHarness()
  ///
  /// Returns "true" if device is running in a test harness.
  static bool isRunningInTestHarness() => _isRunningInTestHarness().boolean;

  static final _dumpPackageState = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActivityManager__dumpPackageState")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dumpPackageState(java.io.FileDescriptor fd, java.lang.String packageName)
  ///
  /// Perform a system dump of various state associated with the given application
  /// package name.  This call blocks while the dump is being performed, so should
  /// not be done on a UI thread.  The data will be written to the given file
  /// descriptor as text.
  /// Requires android.Manifest.permission\#DUMP
  ///@param fd The file descriptor that the dump should be written to.  The file
  /// descriptor is _not_ closed by this function; the caller continues to
  /// own it.
  ///@param packageName The name of the package that is to be dumped.
  void dumpPackageState(jni.JniObject fd, jni.JniString packageName) =>
      _dumpPackageState(reference, fd.reference, packageName.reference).check();

  static final _setWatchHeapLimit = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("ActivityManager__setWatchHeapLimit")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setWatchHeapLimit(long pssSize)
  ///
  /// Request that the system start watching for the calling process to exceed a pss
  /// size as given here.  Once called, the system will look for any occasions where it
  /// sees the associated process with a larger pss size and, when this happens, automatically
  /// pull a heap dump from it and allow the user to share the data.  Note that this request
  /// continues running even if the process is killed and restarted.  To remove the watch,
  /// use \#clearWatchHeapLimit().
  ///
  /// This API only work if the calling process has been marked as
  /// ApplicationInfo\#FLAG_DEBUGGABLE or this is running on a debuggable
  /// (userdebug or eng) build.
  ///
  ///
  /// Callers can optionally implement \#ACTION_REPORT_HEAP_LIMIT to directly
  /// handle heap limit reports themselves.
  ///
  ///@param pssSize The size in bytes to set the limit at.
  void setWatchHeapLimit(int pssSize) =>
      _setWatchHeapLimit(reference, pssSize).check();

  static final _clearWatchHeapLimit = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager__clearWatchHeapLimit")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void clearWatchHeapLimit()
  ///
  /// Clear a heap watch limit previously set by \#setWatchHeapLimit(long).
  void clearWatchHeapLimit() => _clearWatchHeapLimit(reference).check();

  static final _isInLockTaskMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActivityManager__isInLockTaskMode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isInLockTaskMode()
  ///
  /// Return whether currently in lock task mode.  When in this mode
  /// no new tasks can be created or switched to.
  ///@see Activity\#startLockTask()
  ///@deprecated Use \#getLockTaskModeState instead.
  bool isInLockTaskMode() => _isInLockTaskMode(reference).boolean;

  static final _getLockTaskModeState = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager__getLockTaskModeState")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLockTaskModeState()
  ///
  /// Return the current state of task locking. The three possible outcomes
  /// are \#LOCK_TASK_MODE_NONE, \#LOCK_TASK_MODE_LOCKED
  /// and \#LOCK_TASK_MODE_PINNED.
  ///@see Activity\#startLockTask()
  int getLockTaskModeState() => _getLockTaskModeState(reference).integer;

  static final _setVrThread =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "ActivityManager__setVrThread")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public void setVrThread(int tid)
  ///
  /// Enable more aggressive scheduling for latency-sensitive low-runtime VR threads. Only one
  /// thread can be a VR thread in a process at a time, and that thread may be subject to
  /// restrictions on the amount of time it can run.
  ///
  /// If persistent VR mode is set, whatever thread has been granted aggressive scheduling via this
  /// method will return to normal operation, and calling this method will do nothing while
  /// persistent VR mode is enabled.
  ///
  /// To reset the VR thread for an application, a tid of 0 can be passed.
  ///@see android.os.Process\#myTid()
  ///@param tid tid of the VR thread
  static void setVrThread(int tid) => _setVrThread(tid).check();
}

/// from: android.app.ActivityManager$TaskDescription
///
/// Information you can set and retrieve about the current activity within the recent task list.
class ActivityManager_TaskDescription extends jni.JniObject {
  ActivityManager_TaskDescription.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_ActivityManager_TaskDescription__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.TaskDescription> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ActivityManager_TaskDescription__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String label, android.graphics.Bitmap icon, int colorPrimary)
  ///
  /// Creates the TaskDescription to the specified values.
  ///@param label A label and description of the current state of this task.
  ///@param icon An icon that represents the current state of this task.
  ///@param colorPrimary A color to override the theme's primary color.  This color must be
  ///                     opaque.
  ///@deprecated use TaskDescription constructor with icon resource instead
  ActivityManager_TaskDescription(
      jni.JniString label, jni.JniObject icon, int colorPrimary)
      : super.fromRef(
            _ctor(label.reference, icon.reference, colorPrimary).object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("ActivityManager_TaskDescription__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void <init>(java.lang.String label, int iconRes, int colorPrimary)
  ///
  /// Creates the TaskDescription to the specified values.
  ///@param label A label and description of the current state of this task.
  ///@param iconRes A drawable resource of an icon that represents the current state of this
  ///                activity.
  ///@param colorPrimary A color to override the theme's primary color.  This color must be
  ///                     opaque.
  ActivityManager_TaskDescription.ctor1(
      jni.JniString label, int iconRes, int colorPrimary)
      : super.fromRef(_ctor1(label.reference, iconRes, colorPrimary).object);

  static final _ctor2 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_TaskDescription__ctor2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String label, android.graphics.Bitmap icon)
  ///
  /// Creates the TaskDescription to the specified values.
  ///@param label A label and description of the current state of this activity.
  ///@param icon An icon that represents the current state of this activity.
  ///@deprecated use TaskDescription constructor with icon resource instead
  ActivityManager_TaskDescription.ctor2(jni.JniString label, jni.JniObject icon)
      : super.fromRef(_ctor2(label.reference, icon.reference).object);

  static final _ctor3 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ActivityManager_TaskDescription__ctor3")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String label, int iconRes)
  ///
  /// Creates the TaskDescription to the specified values.
  ///@param label A label and description of the current state of this activity.
  ///@param iconRes A drawable resource of an icon that represents the current state of this
  ///                activity.
  ActivityManager_TaskDescription.ctor3(jni.JniString label, int iconRes)
      : super.fromRef(_ctor3(label.reference, iconRes).object);

  static final _ctor4 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_TaskDescription__ctor4")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String label)
  ///
  /// Creates the TaskDescription to the specified values.
  ///@param label A label and description of the current state of this activity.
  ActivityManager_TaskDescription.ctor4(jni.JniString label)
      : super.fromRef(_ctor4(label.reference).object);

  static final _ctor5 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ActivityManager_TaskDescription__ctor5")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ///
  /// Creates an empty TaskDescription.
  ActivityManager_TaskDescription.ctor5() : super.fromRef(_ctor5().object);

  static final _ctor6 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_TaskDescription__ctor6")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.ActivityManager.TaskDescription td)
  ///
  /// Creates a copy of another TaskDescription.
  ActivityManager_TaskDescription.ctor6(ActivityManager_TaskDescription td)
      : super.fromRef(_ctor6(td.reference).object);

  static final _getLabel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_TaskDescription__getLabel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getLabel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The label and description of the current state of this task.
  jni.JniString getLabel() =>
      jni.JniString.fromRef(_getLabel(reference).object);

  static final _getIcon = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_TaskDescription__getIcon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap getIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return The icon that represents the current state of this task.
  jni.JniObject getIcon() => jni.JniObject.fromRef(_getIcon(reference).object);

  static final _getPrimaryColor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_TaskDescription__getPrimaryColor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getPrimaryColor()
  ///
  /// @return The color override on the theme's primary color.
  int getPrimaryColor() => _getPrimaryColor(reference).integer;

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_TaskDescription__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ActivityManager_TaskDescription__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _readFromParcel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_TaskDescription__readFromParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(os_.Parcel source) =>
      _readFromParcel(reference, source.reference).check();

  static final _toString1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_TaskDescription__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);
}

/// from: android.app.ActivityManager$RunningTaskInfo
///
/// Information you can retrieve about a particular task that is currently
/// "running" in the system.  Note that a running task does not mean the
/// given task actually has a process it is actively running in; it simply
/// means that the user has gone to it and never closed it, but currently
/// the system may have killed its process and is only holding on to its
/// last state in order to restart it when the user returns.
class ActivityManager_RunningTaskInfo extends jni.JniObject {
  ActivityManager_RunningTaskInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_ActivityManager_RunningTaskInfo__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.RunningTaskInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _get_baseActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningTaskInfo__baseActivity")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.content.ComponentName baseActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The component launched as the first activity in the task.  This can
  /// be considered the "application" of this task.
  content_.ComponentName get baseActivity =>
      content_.ComponentName.fromRef(_get_baseActivity(reference).object);
  static final _set_baseActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_RunningTaskInfo__baseActivity")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName baseActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The component launched as the first activity in the task.  This can
  /// be considered the "application" of this task.
  set baseActivity(content_.ComponentName value) =>
      _set_baseActivity(reference, value.reference);

  static final _get_description = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningTaskInfo__description")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.CharSequence description
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Description of the task's current state.
  jni.JniObject get description =>
      jni.JniObject.fromRef(_get_description(reference).object);
  static final _set_description = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_RunningTaskInfo__description")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence description
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Description of the task's current state.
  set description(jni.JniObject value) =>
      _set_description(reference, value.reference);

  static final _get_id = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningTaskInfo__id")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int id
  ///
  /// A unique identifier for this task.
  int get id => _get_id(reference).integer;
  static final _set_id = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int32)>>("set_ActivityManager_RunningTaskInfo__id")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int id
  ///
  /// A unique identifier for this task.
  set id(int value) => _set_id(reference, value);

  static final _get_numActivities = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningTaskInfo__numActivities")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int numActivities
  ///
  /// Number of activities in this task.
  int get numActivities => _get_numActivities(reference).integer;
  static final _set_numActivities = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int32)>>(
          "set_ActivityManager_RunningTaskInfo__numActivities")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int numActivities
  ///
  /// Number of activities in this task.
  set numActivities(int value) => _set_numActivities(reference, value);

  static final _get_numRunning = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningTaskInfo__numRunning")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int numRunning
  ///
  /// Number of activities that are currently running (not stopped
  /// and persisted) in this task.
  int get numRunning => _get_numRunning(reference).integer;
  static final _set_numRunning = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int32)>>(
          "set_ActivityManager_RunningTaskInfo__numRunning")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int numRunning
  ///
  /// Number of activities that are currently running (not stopped
  /// and persisted) in this task.
  set numRunning(int value) => _set_numRunning(reference, value);

  static final _get_thumbnail = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningTaskInfo__thumbnail")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.graphics.Bitmap thumbnail
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Thumbnail representation of the task's current state.  Currently
  /// always null.
  jni.JniObject get thumbnail =>
      jni.JniObject.fromRef(_get_thumbnail(reference).object);
  static final _set_thumbnail = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_RunningTaskInfo__thumbnail")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap thumbnail
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Thumbnail representation of the task's current state.  Currently
  /// always null.
  set thumbnail(jni.JniObject value) =>
      _set_thumbnail(reference, value.reference);

  static final _get_topActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningTaskInfo__topActivity")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.content.ComponentName topActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The activity component at the top of the history stack of the task.
  /// This is what the user is currently doing.
  content_.ComponentName get topActivity =>
      content_.ComponentName.fromRef(_get_topActivity(reference).object);
  static final _set_topActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_RunningTaskInfo__topActivity")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName topActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The activity component at the top of the history stack of the task.
  /// This is what the user is currently doing.
  set topActivity(content_.ComponentName value) =>
      _set_topActivity(reference, value.reference);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ActivityManager_RunningTaskInfo__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ActivityManager_RunningTaskInfo() : super.fromRef(_ctor().object);

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_RunningTaskInfo__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ActivityManager_RunningTaskInfo__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _readFromParcel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_RunningTaskInfo__readFromParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(os_.Parcel source) =>
      _readFromParcel(reference, source.reference).check();
}

/// from: android.app.ActivityManager$RunningServiceInfo
///
/// Information you can retrieve about a particular Service that is
/// currently running in the system.
class ActivityManager_RunningServiceInfo extends jni.JniObject {
  ActivityManager_RunningServiceInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_ActivityManager_RunningServiceInfo__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.RunningServiceInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  /// from: static public final int FLAG_FOREGROUND
  ///
  /// Bit for \#flags: set if the service has asked to
  /// run as a foreground process.
  static const FLAG_FOREGROUND = 2;

  /// from: static public final int FLAG_PERSISTENT_PROCESS
  ///
  /// Bit for \#flags: set if the service is running in a
  /// persistent process.
  static const FLAG_PERSISTENT_PROCESS = 8;

  /// from: static public final int FLAG_STARTED
  ///
  /// Bit for \#flags: set if this service has been
  /// explicitly started.
  static const FLAG_STARTED = 1;

  /// from: static public final int FLAG_SYSTEM_PROCESS
  ///
  /// Bit for \#flags: set if the service is running in a
  /// core system process.
  static const FLAG_SYSTEM_PROCESS = 4;

  static final _get_activeSince = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningServiceInfo__activeSince")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public long activeSince
  ///
  /// The time when the service was first made active, either by someone
  /// starting or binding to it.  This
  /// is in units of android.os.SystemClock\#elapsedRealtime().
  int get activeSince => _get_activeSince(reference).long;
  static final _set_activeSince = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int64)>>(
          "set_ActivityManager_RunningServiceInfo__activeSince")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public long activeSince
  ///
  /// The time when the service was first made active, either by someone
  /// starting or binding to it.  This
  /// is in units of android.os.SystemClock\#elapsedRealtime().
  set activeSince(int value) => _set_activeSince(reference, value);

  static final _get_clientCount = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningServiceInfo__clientCount")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int clientCount
  ///
  /// Number of clients connected to the service.
  int get clientCount => _get_clientCount(reference).integer;
  static final _set_clientCount = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int32)>>(
          "set_ActivityManager_RunningServiceInfo__clientCount")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int clientCount
  ///
  /// Number of clients connected to the service.
  set clientCount(int value) => _set_clientCount(reference, value);

  static final _get_clientLabel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningServiceInfo__clientLabel")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int clientLabel
  ///
  /// For special services that are bound to by system code, this is
  /// a string resource providing a user-visible label for who the
  /// client is.
  int get clientLabel => _get_clientLabel(reference).integer;
  static final _set_clientLabel = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int32)>>(
          "set_ActivityManager_RunningServiceInfo__clientLabel")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int clientLabel
  ///
  /// For special services that are bound to by system code, this is
  /// a string resource providing a user-visible label for who the
  /// client is.
  set clientLabel(int value) => _set_clientLabel(reference, value);

  static final _get_clientPackage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningServiceInfo__clientPackage")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String clientPackage
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// For special services that are bound to by system code, this is
  /// the package that holds the binding.
  jni.JniString get clientPackage =>
      jni.JniString.fromRef(_get_clientPackage(reference).object);
  static final _set_clientPackage = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_RunningServiceInfo__clientPackage")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String clientPackage
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// For special services that are bound to by system code, this is
  /// the package that holds the binding.
  set clientPackage(jni.JniString value) =>
      _set_clientPackage(reference, value.reference);

  static final _get_crashCount = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningServiceInfo__crashCount")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int crashCount
  ///
  /// Number of times the service's process has crashed while the service
  /// is running.
  int get crashCount => _get_crashCount(reference).integer;
  static final _set_crashCount = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int32)>>(
          "set_ActivityManager_RunningServiceInfo__crashCount")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int crashCount
  ///
  /// Number of times the service's process has crashed while the service
  /// is running.
  set crashCount(int value) => _set_crashCount(reference, value);

  static final _get_flags = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningServiceInfo__flags")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int flags
  ///
  /// Running flags.
  int get flags => _get_flags(reference).integer;
  static final _set_flags = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int32)>>("set_ActivityManager_RunningServiceInfo__flags")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int flags
  ///
  /// Running flags.
  set flags(int value) => _set_flags(reference, value);

  static final _get_foreground = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningServiceInfo__foreground")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public boolean foreground
  ///
  /// Set to true if the service has asked to run as a foreground process.
  bool get foreground => _get_foreground(reference).boolean;
  static final _set_foreground = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Uint8)>>(
          "set_ActivityManager_RunningServiceInfo__foreground")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public boolean foreground
  ///
  /// Set to true if the service has asked to run as a foreground process.
  set foreground(bool value) => _set_foreground(reference, value ? 1 : 0);

  static final _get_lastActivityTime = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningServiceInfo__lastActivityTime")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public long lastActivityTime
  ///
  /// The time when there was last activity in the service (either
  /// explicit requests to start it or clients binding to it).  This
  /// is in units of android.os.SystemClock\#uptimeMillis().
  int get lastActivityTime => _get_lastActivityTime(reference).long;
  static final _set_lastActivityTime = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int64)>>(
          "set_ActivityManager_RunningServiceInfo__lastActivityTime")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public long lastActivityTime
  ///
  /// The time when there was last activity in the service (either
  /// explicit requests to start it or clients binding to it).  This
  /// is in units of android.os.SystemClock\#uptimeMillis().
  set lastActivityTime(int value) => _set_lastActivityTime(reference, value);

  static final _get_pid = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningServiceInfo__pid")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int pid
  ///
  /// If non-zero, this is the process the service is running in.
  int get pid => _get_pid(reference).integer;
  static final _set_pid = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int32)>>("set_ActivityManager_RunningServiceInfo__pid")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int pid
  ///
  /// If non-zero, this is the process the service is running in.
  set pid(int value) => _set_pid(reference, value);

  static final _get_process = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningServiceInfo__process")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String process
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The name of the process this service runs in.
  jni.JniString get process =>
      jni.JniString.fromRef(_get_process(reference).object);
  static final _set_process = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_RunningServiceInfo__process")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String process
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The name of the process this service runs in.
  set process(jni.JniString value) => _set_process(reference, value.reference);

  static final _get_restarting = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningServiceInfo__restarting")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public long restarting
  ///
  /// If non-zero, this service is not currently running, but scheduled to
  /// restart at the given time.
  int get restarting => _get_restarting(reference).long;
  static final _set_restarting = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int64)>>(
          "set_ActivityManager_RunningServiceInfo__restarting")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public long restarting
  ///
  /// If non-zero, this service is not currently running, but scheduled to
  /// restart at the given time.
  set restarting(int value) => _set_restarting(reference, value);

  static final _get_service = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningServiceInfo__service")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.content.ComponentName service
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The service component.
  content_.ComponentName get service =>
      content_.ComponentName.fromRef(_get_service(reference).object);
  static final _set_service = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_RunningServiceInfo__service")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName service
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The service component.
  set service(content_.ComponentName value) =>
      _set_service(reference, value.reference);

  static final _get_started = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningServiceInfo__started")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public boolean started
  ///
  /// Set to true if this service has been explicitly started.
  bool get started => _get_started(reference).boolean;
  static final _set_started = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Uint8)>>(
          "set_ActivityManager_RunningServiceInfo__started")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public boolean started
  ///
  /// Set to true if this service has been explicitly started.
  set started(bool value) => _set_started(reference, value ? 1 : 0);

  static final _get_uid = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningServiceInfo__uid")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int uid
  ///
  /// The UID that owns this service.
  int get uid => _get_uid(reference).integer;
  static final _set_uid = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int32)>>("set_ActivityManager_RunningServiceInfo__uid")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int uid
  ///
  /// The UID that owns this service.
  set uid(int value) => _set_uid(reference, value);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ActivityManager_RunningServiceInfo__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ActivityManager_RunningServiceInfo() : super.fromRef(_ctor().object);

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_RunningServiceInfo__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "ActivityManager_RunningServiceInfo__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _readFromParcel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_RunningServiceInfo__readFromParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(os_.Parcel source) =>
      _readFromParcel(reference, source.reference).check();
}

/// from: android.app.ActivityManager$RunningAppProcessInfo
///
/// Information you can retrieve about a running process.
class ActivityManager_RunningAppProcessInfo extends jni.JniObject {
  ActivityManager_RunningAppProcessInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_ActivityManager_RunningAppProcessInfo__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.RunningAppProcessInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  /// from: static public final int IMPORTANCE_BACKGROUND
  ///
  /// @deprecated Renamed to \#IMPORTANCE_CACHED.
  static const IMPORTANCE_BACKGROUND = 400;

  /// from: static public final int IMPORTANCE_CACHED
  ///
  /// Constant for \#importance: This process process contains
  /// cached code that is expendable, not actively running any app components
  /// we care about.
  static const IMPORTANCE_CACHED = 400;

  /// from: static public final int IMPORTANCE_CANT_SAVE_STATE
  ///
  /// Constant for \#importance: This process is running an
  /// application that can not save its state, and thus can't be killed
  /// while in the background.  This will be used with apps that have
  /// android.R.attr\#cantSaveState set on their application tag.
  static const IMPORTANCE_CANT_SAVE_STATE = 350;

  /// from: static public final int IMPORTANCE_EMPTY
  ///
  /// Constant for \#importance: This process is empty of any
  /// actively running code.
  ///@deprecated This value is no longer reported, use \#IMPORTANCE_CACHED instead.
  static const IMPORTANCE_EMPTY = 500;

  /// from: static public final int IMPORTANCE_FOREGROUND
  ///
  /// Constant for \#importance: This process is running the
  /// foreground UI; that is, it is the thing currently at the top of the screen
  /// that the user is interacting with.
  static const IMPORTANCE_FOREGROUND = 100;

  /// from: static public final int IMPORTANCE_FOREGROUND_SERVICE
  ///
  /// Constant for \#importance: This process is running a foreground
  /// service, for example to perform music playback even while the user is
  /// not immediately in the app.  This generally indicates that the process
  /// is doing something the user actively cares about.
  static const IMPORTANCE_FOREGROUND_SERVICE = 125;

  /// from: static public final int IMPORTANCE_GONE
  ///
  /// Constant for \#importance: This process does not exist.
  static const IMPORTANCE_GONE = 1000;

  /// from: static public final int IMPORTANCE_PERCEPTIBLE
  ///
  /// Constant for \#importance: This process is not something the user
  /// is directly aware of, but is otherwise perceptible to them to some degree.
  static const IMPORTANCE_PERCEPTIBLE = 230;

  /// from: static public final int IMPORTANCE_PERCEPTIBLE_PRE_26
  ///
  /// Constant for \#importance: \#IMPORTANCE_PERCEPTIBLE had this wrong value
  /// before Build.VERSION_CODES\#O.  Since the Build.VERSION_CODES\#O SDK,
  /// the value of \#IMPORTANCE_PERCEPTIBLE has been fixed.
  ///
  /// The system will return this value instead of \#IMPORTANCE_PERCEPTIBLE
  /// on Android versions below Build.VERSION_CODES\#O.
  ///
  /// On Android version Build.VERSION_CODES\#O and later, this value will still be
  /// returned for apps with the target API level below Build.VERSION_CODES\#O.
  /// For apps targeting version Build.VERSION_CODES\#O and later,
  /// the correct value \#IMPORTANCE_PERCEPTIBLE will be returned.
  static const IMPORTANCE_PERCEPTIBLE_PRE_26 = 130;

  /// from: static public final int IMPORTANCE_SERVICE
  ///
  /// Constant for \#importance: This process is contains services
  /// that should remain running.  These are background services apps have
  /// started, not something the user is aware of, so they may be killed by
  /// the system relatively freely (though it is generally desired that they
  /// stay running as long as they want to).
  static const IMPORTANCE_SERVICE = 300;

  /// from: static public final int IMPORTANCE_TOP_SLEEPING
  ///
  /// Constant for \#importance: This process is running the foreground
  /// UI, but the device is asleep so it is not visible to the user.  Though the
  /// system will try hard to keep its process from being killed, in all other
  /// ways we consider it a kind of cached process, with the limitations that go
  /// along with that state: network access, running background services, etc.
  static const IMPORTANCE_TOP_SLEEPING = 325;

  /// from: static public final int IMPORTANCE_TOP_SLEEPING_PRE_28
  ///
  /// @deprecated Pre-android.os.Build.VERSION_CODES\#P version of
  /// \#IMPORTANCE_TOP_SLEEPING.  As of Android
  /// android.os.Build.VERSION_CODES\#P, this is considered much less
  /// important since we want to reduce what apps can do when the screen is off.
  static const IMPORTANCE_TOP_SLEEPING_PRE_28 = 150;

  /// from: static public final int IMPORTANCE_VISIBLE
  ///
  /// Constant for \#importance: This process is running something
  /// that is actively visible to the user, though not in the immediate
  /// foreground.  This may be running a window that is behind the current
  /// foreground (so paused and with its state saved, not interacting with
  /// the user, but visible to them to some degree); it may also be running
  /// other services under the system's control that it inconsiders important.
  static const IMPORTANCE_VISIBLE = 200;

  /// from: static public final int REASON_PROVIDER_IN_USE
  ///
  /// Constant for \#importanceReasonCode: one of the application's
  /// content providers is being used by another process.  The pid of
  /// the client process is in \#importanceReasonPid and the
  /// target provider in this process is in
  /// \#importanceReasonComponent.
  static const REASON_PROVIDER_IN_USE = 1;

  /// from: static public final int REASON_SERVICE_IN_USE
  ///
  /// Constant for \#importanceReasonCode: one of the application's
  /// content providers is being used by another process.  The pid of
  /// the client process is in \#importanceReasonPid and the
  /// target provider in this process is in
  /// \#importanceReasonComponent.
  static const REASON_SERVICE_IN_USE = 2;

  /// from: static public final int REASON_UNKNOWN
  ///
  /// Constant for \#importanceReasonCode: nothing special has
  /// been specified for the reason for this level.
  static const REASON_UNKNOWN = 0;

  static final _get_importance = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningAppProcessInfo__importance")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int importance
  ///
  /// The relative importance level that the system places on this process.
  /// These constants are numbered so that "more important" values are
  /// always smaller than "less important" values.
  ///
  /// Value is android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_FOREGROUND, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_FOREGROUND_SERVICE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_TOP_SLEEPING, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_VISIBLE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_PERCEPTIBLE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_CANT_SAVE_STATE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_SERVICE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_CACHED, or android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_GONE
  int get importance => _get_importance(reference).integer;
  static final _set_importance = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int32)>>(
          "set_ActivityManager_RunningAppProcessInfo__importance")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int importance
  ///
  /// The relative importance level that the system places on this process.
  /// These constants are numbered so that "more important" values are
  /// always smaller than "less important" values.
  ///
  /// Value is android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_FOREGROUND, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_FOREGROUND_SERVICE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_TOP_SLEEPING, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_VISIBLE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_PERCEPTIBLE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_CANT_SAVE_STATE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_SERVICE, android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_CACHED, or android.app.ActivityManager.RunningAppProcessInfo\#IMPORTANCE_GONE
  set importance(int value) => _set_importance(reference, value);

  static final _get_importanceReasonCode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningAppProcessInfo__importanceReasonCode")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int importanceReasonCode
  ///
  /// The reason for \#importance, if any.
  int get importanceReasonCode => _get_importanceReasonCode(reference).integer;
  static final _set_importanceReasonCode = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int32)>>(
          "set_ActivityManager_RunningAppProcessInfo__importanceReasonCode")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int importanceReasonCode
  ///
  /// The reason for \#importance, if any.
  set importanceReasonCode(int value) =>
      _set_importanceReasonCode(reference, value);

  static final _get_importanceReasonComponent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningAppProcessInfo__importanceReasonComponent")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.content.ComponentName importanceReasonComponent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// For the specified values of \#importanceReasonCode, this
  /// is the name of the component that is being used in this process.
  content_.ComponentName get importanceReasonComponent =>
      content_.ComponentName.fromRef(
          _get_importanceReasonComponent(reference).object);
  static final _set_importanceReasonComponent = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_RunningAppProcessInfo__importanceReasonComponent")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName importanceReasonComponent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// For the specified values of \#importanceReasonCode, this
  /// is the name of the component that is being used in this process.
  set importanceReasonComponent(content_.ComponentName value) =>
      _set_importanceReasonComponent(reference, value.reference);

  static final _get_importanceReasonPid = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningAppProcessInfo__importanceReasonPid")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int importanceReasonPid
  ///
  /// For the specified values of \#importanceReasonCode, this
  /// is the process ID of the other process that is a client of this
  /// process.  This will be 0 if no other process is using this one.
  int get importanceReasonPid => _get_importanceReasonPid(reference).integer;
  static final _set_importanceReasonPid = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int32)>>(
          "set_ActivityManager_RunningAppProcessInfo__importanceReasonPid")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int importanceReasonPid
  ///
  /// For the specified values of \#importanceReasonCode, this
  /// is the process ID of the other process that is a client of this
  /// process.  This will be 0 if no other process is using this one.
  set importanceReasonPid(int value) =>
      _set_importanceReasonPid(reference, value);

  static final _get_lastTrimLevel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningAppProcessInfo__lastTrimLevel")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int lastTrimLevel
  ///
  /// Last memory trim level reported to the process: corresponds to
  /// the values supplied to android.content.ComponentCallbacks2\#onTrimMemory(int) ComponentCallbacks2.onTrimMemory(int).
  int get lastTrimLevel => _get_lastTrimLevel(reference).integer;
  static final _set_lastTrimLevel = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int32)>>(
          "set_ActivityManager_RunningAppProcessInfo__lastTrimLevel")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int lastTrimLevel
  ///
  /// Last memory trim level reported to the process: corresponds to
  /// the values supplied to android.content.ComponentCallbacks2\#onTrimMemory(int) ComponentCallbacks2.onTrimMemory(int).
  set lastTrimLevel(int value) => _set_lastTrimLevel(reference, value);

  static final _get_lru = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningAppProcessInfo__lru")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int lru
  ///
  /// An additional ordering within a particular \#importance
  /// category, providing finer-grained information about the relative
  /// utility of processes within a category.  This number means nothing
  /// except that a smaller values are more recently used (and thus
  /// more important).  Currently an LRU value is only maintained for
  /// the \#IMPORTANCE_CACHED category, though others may
  /// be maintained in the future.
  int get lru => _get_lru(reference).integer;
  static final _set_lru = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int32)>>("set_ActivityManager_RunningAppProcessInfo__lru")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int lru
  ///
  /// An additional ordering within a particular \#importance
  /// category, providing finer-grained information about the relative
  /// utility of processes within a category.  This number means nothing
  /// except that a smaller values are more recently used (and thus
  /// more important).  Currently an LRU value is only maintained for
  /// the \#IMPORTANCE_CACHED category, though others may
  /// be maintained in the future.
  set lru(int value) => _set_lru(reference, value);

  static final _get_pid = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningAppProcessInfo__pid")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int pid
  ///
  /// The pid of this process; 0 if none
  int get pid => _get_pid(reference).integer;
  static final _set_pid = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int32)>>("set_ActivityManager_RunningAppProcessInfo__pid")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int pid
  ///
  /// The pid of this process; 0 if none
  set pid(int value) => _set_pid(reference, value);

  static final _get_pkgList = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningAppProcessInfo__pkgList")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String[] pkgList
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// All packages that have been loaded into the process.
  jni.JniObject get pkgList =>
      jni.JniObject.fromRef(_get_pkgList(reference).object);
  static final _set_pkgList = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_RunningAppProcessInfo__pkgList")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] pkgList
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// All packages that have been loaded into the process.
  set pkgList(jni.JniObject value) => _set_pkgList(reference, value.reference);

  static final _get_processName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningAppProcessInfo__processName")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String processName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The name of the process that this object is associated with
  jni.JniString get processName =>
      jni.JniString.fromRef(_get_processName(reference).object);
  static final _set_processName = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_RunningAppProcessInfo__processName")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String processName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The name of the process that this object is associated with
  set processName(jni.JniString value) =>
      _set_processName(reference, value.reference);

  static final _get_uid = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RunningAppProcessInfo__uid")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int uid
  ///
  /// The user id of this process.
  int get uid => _get_uid(reference).integer;
  static final _set_uid = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int32)>>("set_ActivityManager_RunningAppProcessInfo__uid")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int uid
  ///
  /// The user id of this process.
  set uid(int value) => _set_uid(reference, value);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ActivityManager_RunningAppProcessInfo__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ActivityManager_RunningAppProcessInfo() : super.fromRef(_ctor().object);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_RunningAppProcessInfo__ctor1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String pProcessName, int pPid, java.lang.String[] pArr)
  ActivityManager_RunningAppProcessInfo.ctor1(
      jni.JniString pProcessName, int pPid, jni.JniObject pArr)
      : super.fromRef(
            _ctor1(pProcessName.reference, pPid, pArr.reference).object);

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_RunningAppProcessInfo__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "ActivityManager_RunningAppProcessInfo__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _readFromParcel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_RunningAppProcessInfo__readFromParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(os_.Parcel source) =>
      _readFromParcel(reference, source.reference).check();
}

/// from: android.app.ActivityManager$RecentTaskInfo
///
/// Information you can retrieve about tasks that the user has most recently
/// started or visited.
class ActivityManager_RecentTaskInfo extends jni.JniObject {
  ActivityManager_RecentTaskInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_ActivityManager_RecentTaskInfo__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.RecentTaskInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _get_affiliatedTaskId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RecentTaskInfo__affiliatedTaskId")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int affiliatedTaskId
  ///
  /// Task affiliation for grouping with other tasks.
  int get affiliatedTaskId => _get_affiliatedTaskId(reference).integer;
  static final _set_affiliatedTaskId = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int32)>>(
          "set_ActivityManager_RecentTaskInfo__affiliatedTaskId")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int affiliatedTaskId
  ///
  /// Task affiliation for grouping with other tasks.
  set affiliatedTaskId(int value) => _set_affiliatedTaskId(reference, value);

  static final _get_baseActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RecentTaskInfo__baseActivity")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.content.ComponentName baseActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The component launched as the first activity in the task.
  /// This can be considered the "application" of this task.
  content_.ComponentName get baseActivity =>
      content_.ComponentName.fromRef(_get_baseActivity(reference).object);
  static final _set_baseActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_RecentTaskInfo__baseActivity")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName baseActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The component launched as the first activity in the task.
  /// This can be considered the "application" of this task.
  set baseActivity(content_.ComponentName value) =>
      _set_baseActivity(reference, value.reference);

  static final _get_baseIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RecentTaskInfo__baseIntent")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.content.Intent baseIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The original Intent used to launch the task.  You can use this
  /// Intent to re-launch the task (if it is no longer running) or bring
  /// the current task to the front.
  content_.Intent get baseIntent =>
      content_.Intent.fromRef(_get_baseIntent(reference).object);
  static final _set_baseIntent = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_RecentTaskInfo__baseIntent")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent baseIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The original Intent used to launch the task.  You can use this
  /// Intent to re-launch the task (if it is no longer running) or bring
  /// the current task to the front.
  set baseIntent(content_.Intent value) =>
      _set_baseIntent(reference, value.reference);

  static final _get_description = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RecentTaskInfo__description")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.CharSequence description
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Description of the task's last state.
  jni.JniObject get description =>
      jni.JniObject.fromRef(_get_description(reference).object);
  static final _set_description = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_RecentTaskInfo__description")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence description
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Description of the task's last state.
  set description(jni.JniObject value) =>
      _set_description(reference, value.reference);

  static final _get_id = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RecentTaskInfo__id")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int id
  ///
  /// If this task is currently running, this is the identifier for it.
  /// If it is not running, this will be -1.
  int get id => _get_id(reference).integer;
  static final _set_id = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int32)>>("set_ActivityManager_RecentTaskInfo__id")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int id
  ///
  /// If this task is currently running, this is the identifier for it.
  /// If it is not running, this will be -1.
  set id(int value) => _set_id(reference, value);

  static final _get_numActivities = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RecentTaskInfo__numActivities")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int numActivities
  ///
  /// Number of activities in this task.
  int get numActivities => _get_numActivities(reference).integer;
  static final _set_numActivities = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int32)>>(
          "set_ActivityManager_RecentTaskInfo__numActivities")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int numActivities
  ///
  /// Number of activities in this task.
  set numActivities(int value) => _set_numActivities(reference, value);

  static final _get_origActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RecentTaskInfo__origActivity")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.content.ComponentName origActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this task was started from an alias, this is the actual
  /// activity component that was initially started; the component of
  /// the baseIntent in this case is the name of the actual activity
  /// implementation that the alias referred to.  Otherwise, this is null.
  content_.ComponentName get origActivity =>
      content_.ComponentName.fromRef(_get_origActivity(reference).object);
  static final _set_origActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_RecentTaskInfo__origActivity")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName origActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this task was started from an alias, this is the actual
  /// activity component that was initially started; the component of
  /// the baseIntent in this case is the name of the actual activity
  /// implementation that the alias referred to.  Otherwise, this is null.
  set origActivity(content_.ComponentName value) =>
      _set_origActivity(reference, value.reference);

  static final _get_persistentId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RecentTaskInfo__persistentId")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int persistentId
  ///
  /// The true identifier of this task, valid even if it is not running.
  int get persistentId => _get_persistentId(reference).integer;
  static final _set_persistentId = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int32)>>(
          "set_ActivityManager_RecentTaskInfo__persistentId")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int persistentId
  ///
  /// The true identifier of this task, valid even if it is not running.
  set persistentId(int value) => _set_persistentId(reference, value);

  static final _get_taskDescription = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RecentTaskInfo__taskDescription")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.app.ActivityManager.TaskDescription taskDescription
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The recent activity values for the highest activity in the stack to have set the values.
  /// Activity\#setTaskDescription(android.app.ActivityManager.TaskDescription).
  ActivityManager_TaskDescription get taskDescription =>
      ActivityManager_TaskDescription.fromRef(
          _get_taskDescription(reference).object);
  static final _set_taskDescription = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_RecentTaskInfo__taskDescription")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.ActivityManager.TaskDescription taskDescription
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The recent activity values for the highest activity in the stack to have set the values.
  /// Activity\#setTaskDescription(android.app.ActivityManager.TaskDescription).
  set taskDescription(ActivityManager_TaskDescription value) =>
      _set_taskDescription(reference, value.reference);

  static final _get_topActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_RecentTaskInfo__topActivity")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.content.ComponentName topActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The activity component at the top of the history stack of the task.
  /// This is what the user is currently doing.
  content_.ComponentName get topActivity =>
      content_.ComponentName.fromRef(_get_topActivity(reference).object);
  static final _set_topActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_RecentTaskInfo__topActivity")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName topActivity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The activity component at the top of the history stack of the task.
  /// This is what the user is currently doing.
  set topActivity(content_.ComponentName value) =>
      _set_topActivity(reference, value.reference);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ActivityManager_RecentTaskInfo__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ActivityManager_RecentTaskInfo() : super.fromRef(_ctor().object);

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_RecentTaskInfo__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ActivityManager_RecentTaskInfo__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _readFromParcel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_RecentTaskInfo__readFromParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(os_.Parcel source) =>
      _readFromParcel(reference, source.reference).check();
}

/// from: android.app.ActivityManager$ProcessErrorStateInfo
///
/// Information you can retrieve about any processes that are in an error condition.
class ActivityManager_ProcessErrorStateInfo extends jni.JniObject {
  ActivityManager_ProcessErrorStateInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final int CRASHED
  static const CRASHED = 1;

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_ActivityManager_ProcessErrorStateInfo__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.ProcessErrorStateInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  /// from: static public final int NOT_RESPONDING
  static const NOT_RESPONDING = 2;

  /// from: static public final int NO_ERROR
  ///
  /// Condition codes
  static const NO_ERROR = 0;

  static final _get_condition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_ProcessErrorStateInfo__condition")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int condition
  ///
  /// The condition that the process is in.
  int get condition => _get_condition(reference).integer;
  static final _set_condition = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int32)>>(
          "set_ActivityManager_ProcessErrorStateInfo__condition")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int condition
  ///
  /// The condition that the process is in.
  set condition(int value) => _set_condition(reference, value);

  static final _get_crashData = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_ProcessErrorStateInfo__crashData")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public byte[] crashData
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// to be deprecated: This value will always be null.
  jni.JniObject get crashData =>
      jni.JniObject.fromRef(_get_crashData(reference).object);
  static final _set_crashData = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_ProcessErrorStateInfo__crashData")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public byte[] crashData
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// to be deprecated: This value will always be null.
  set crashData(jni.JniObject value) =>
      _set_crashData(reference, value.reference);

  static final _get_longMsg = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_ProcessErrorStateInfo__longMsg")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String longMsg
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A long message describing the error condition.
  jni.JniString get longMsg =>
      jni.JniString.fromRef(_get_longMsg(reference).object);
  static final _set_longMsg = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_ProcessErrorStateInfo__longMsg")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String longMsg
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A long message describing the error condition.
  set longMsg(jni.JniString value) => _set_longMsg(reference, value.reference);

  static final _get_pid = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_ProcessErrorStateInfo__pid")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int pid
  ///
  /// The pid of this process; 0 if none
  int get pid => _get_pid(reference).integer;
  static final _set_pid = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int32)>>("set_ActivityManager_ProcessErrorStateInfo__pid")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int pid
  ///
  /// The pid of this process; 0 if none
  set pid(int value) => _set_pid(reference, value);

  static final _get_processName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_ProcessErrorStateInfo__processName")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String processName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The process name in which the crash or error occurred.
  jni.JniString get processName =>
      jni.JniString.fromRef(_get_processName(reference).object);
  static final _set_processName = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_ProcessErrorStateInfo__processName")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String processName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The process name in which the crash or error occurred.
  set processName(jni.JniString value) =>
      _set_processName(reference, value.reference);

  static final _get_shortMsg = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_ProcessErrorStateInfo__shortMsg")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String shortMsg
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A short message describing the error condition.
  jni.JniString get shortMsg =>
      jni.JniString.fromRef(_get_shortMsg(reference).object);
  static final _set_shortMsg = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_ProcessErrorStateInfo__shortMsg")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String shortMsg
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A short message describing the error condition.
  set shortMsg(jni.JniString value) =>
      _set_shortMsg(reference, value.reference);

  static final _get_stackTrace = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_ProcessErrorStateInfo__stackTrace")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String stackTrace
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The stack trace where the error originated.  May be null.
  jni.JniString get stackTrace =>
      jni.JniString.fromRef(_get_stackTrace(reference).object);
  static final _set_stackTrace = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_ProcessErrorStateInfo__stackTrace")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String stackTrace
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The stack trace where the error originated.  May be null.
  set stackTrace(jni.JniString value) =>
      _set_stackTrace(reference, value.reference);

  static final _get_tag = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_ProcessErrorStateInfo__tag")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String tag
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The activity name associated with the error, if known.  May be null.
  jni.JniString get tag => jni.JniString.fromRef(_get_tag(reference).object);
  static final _set_tag = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ActivityManager_ProcessErrorStateInfo__tag")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String tag
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The activity name associated with the error, if known.  May be null.
  set tag(jni.JniString value) => _set_tag(reference, value.reference);

  static final _get_uid = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_ProcessErrorStateInfo__uid")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int uid
  ///
  /// The kernel user-ID that has been assigned to this process;
  /// currently this is not a unique ID (multiple applications can have
  /// the same uid).
  int get uid => _get_uid(reference).integer;
  static final _set_uid = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int32)>>("set_ActivityManager_ProcessErrorStateInfo__uid")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int uid
  ///
  /// The kernel user-ID that has been assigned to this process;
  /// currently this is not a unique ID (multiple applications can have
  /// the same uid).
  set uid(int value) => _set_uid(reference, value);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ActivityManager_ProcessErrorStateInfo__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ActivityManager_ProcessErrorStateInfo() : super.fromRef(_ctor().object);

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_ProcessErrorStateInfo__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "ActivityManager_ProcessErrorStateInfo__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _readFromParcel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_ProcessErrorStateInfo__readFromParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(os_.Parcel source) =>
      _readFromParcel(reference, source.reference).check();
}

/// from: android.app.ActivityManager$MemoryInfo
///
/// Information you can retrieve about the available memory through
/// ActivityManager\#getMemoryInfo.
class ActivityManager_MemoryInfo extends jni.JniObject {
  ActivityManager_MemoryInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_ActivityManager_MemoryInfo__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.ActivityManager.MemoryInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _get_availMem = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_MemoryInfo__availMem")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public long availMem
  ///
  /// The available memory on the system.  This number should not
  /// be considered absolute: due to the nature of the kernel, a significant
  /// portion of this memory is actually in use and needed for the overall
  /// system to run well.
  int get availMem => _get_availMem(reference).long;
  static final _set_availMem = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int64)>>("set_ActivityManager_MemoryInfo__availMem")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public long availMem
  ///
  /// The available memory on the system.  This number should not
  /// be considered absolute: due to the nature of the kernel, a significant
  /// portion of this memory is actually in use and needed for the overall
  /// system to run well.
  set availMem(int value) => _set_availMem(reference, value);

  static final _get_lowMemory = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_MemoryInfo__lowMemory")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public boolean lowMemory
  ///
  /// Set to true if the system considers itself to currently be in a low
  /// memory situation.
  bool get lowMemory => _get_lowMemory(reference).boolean;
  static final _set_lowMemory = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Uint8)>>("set_ActivityManager_MemoryInfo__lowMemory")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public boolean lowMemory
  ///
  /// Set to true if the system considers itself to currently be in a low
  /// memory situation.
  set lowMemory(bool value) => _set_lowMemory(reference, value ? 1 : 0);

  static final _get_threshold = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_MemoryInfo__threshold")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public long threshold
  ///
  /// The threshold of \#availMem at which we consider memory to be
  /// low and start killing background services and other non-extraneous
  /// processes.
  int get threshold => _get_threshold(reference).long;
  static final _set_threshold = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int64)>>("set_ActivityManager_MemoryInfo__threshold")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public long threshold
  ///
  /// The threshold of \#availMem at which we consider memory to be
  /// low and start killing background services and other non-extraneous
  /// processes.
  set threshold(int value) => _set_threshold(reference, value);

  static final _get_totalMem = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ActivityManager_MemoryInfo__totalMem")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public long totalMem
  ///
  /// The total memory accessible by the kernel.  This is basically the
  /// RAM size of the device, not including below-kernel fixed allocations
  /// like DMA buffers, RAM for the baseband CPU, etc.
  int get totalMem => _get_totalMem(reference).long;
  static final _set_totalMem = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Int64)>>("set_ActivityManager_MemoryInfo__totalMem")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public long totalMem
  ///
  /// The total memory accessible by the kernel.  This is basically the
  /// RAM size of the device, not including below-kernel fixed allocations
  /// like DMA buffers, RAM for the baseband CPU, etc.
  set totalMem(int value) => _set_totalMem(reference, value);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ActivityManager_MemoryInfo__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ActivityManager_MemoryInfo() : super.fromRef(_ctor().object);

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_MemoryInfo__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ActivityManager_MemoryInfo__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _readFromParcel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_MemoryInfo__readFromParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel source)
  void readFromParcel(os_.Parcel source) =>
      _readFromParcel(reference, source.reference).check();
}

/// from: android.app.ActivityManager$AppTask
///
/// The AppTask allows you to manage your own application's tasks.
/// See android.app.ActivityManager\#getAppTasks()
class ActivityManager_AppTask extends jni.JniObject {
  ActivityManager_AppTask.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ActivityManager_AppTask__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  ActivityManager_AppTask() : super.fromRef(_ctor().object);

  static final _finishAndRemoveTask = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_AppTask__finishAndRemoveTask")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void finishAndRemoveTask()
  ///
  /// Finishes all activities in this task and removes it from the recent tasks list.
  void finishAndRemoveTask() => _finishAndRemoveTask(reference).check();

  static final _getTaskInfo = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_AppTask__getTaskInfo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.ActivityManager.RecentTaskInfo getTaskInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the RecentTaskInfo associated with this task.
  ///@return The RecentTaskInfo for this task, or null if the task no longer exists.
  ActivityManager_RecentTaskInfo getTaskInfo() =>
      ActivityManager_RecentTaskInfo.fromRef(_getTaskInfo(reference).object);

  static final _moveToFront = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_AppTask__moveToFront")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void moveToFront()
  ///
  /// Bring this task to the foreground.  If it contains activities, they will be
  /// brought to the foreground with it and their instances re-created if needed.
  /// If it doesn't contain activities, the root activity of the task will be
  /// re-launched.
  void moveToFront() => _moveToFront(reference).check();

  static final _startActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "ActivityManager_AppTask__startActivity")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivity(android.content.Context context, android.content.Intent intent, android.os.Bundle options)
  ///
  /// Start an activity in this task.  Brings the task to the foreground.  If this task
  /// is not currently active (that is, its id < 0), then a new activity for the given
  /// Intent will be launched as the root of the task and the task brought to the
  /// foreground.  Otherwise, if this task is currently active and the Intent does not specify
  /// an activity to launch in a new task, then a new activity for the given Intent will
  /// be launched on top of the task and the task brought to the foreground.  If this
  /// task is currently active and the Intent specifies Intent\#FLAG_ACTIVITY_NEW_TASK
  /// or would otherwise be launched in to a new task, then the activity not launched but
  /// this task be brought to the foreground and a new intent delivered to the top
  /// activity if appropriate.
  ///
  /// In other words, you generally want to use an Intent here that does not specify
  /// Intent\#FLAG_ACTIVITY_NEW_TASK or Intent\#FLAG_ACTIVITY_NEW_DOCUMENT,
  /// and let the system do the right thing.
  ///
  ///@param intent The Intent describing the new activity to be launched on the task.
  ///@param options Optional launch options.
  ///@see Activity\#startActivity(android.content.Intent, android.os.Bundle)
  void startActivity(content_.Context context, content_.Intent intent,
          os_.Bundle options) =>
      _startActivity(
              reference, context.reference, intent.reference, options.reference)
          .check();

  static final _setExcludeFromRecents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("ActivityManager_AppTask__setExcludeFromRecents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setExcludeFromRecents(boolean exclude)
  ///
  /// Modify the Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS flag in the root
  /// Intent of this AppTask.
  ///@param exclude If true, Intent\#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS will
  /// be set; otherwise, it will be cleared.
  void setExcludeFromRecents(bool exclude) =>
      _setExcludeFromRecents(reference, exclude ? 1 : 0).check();
}

/// from: android.app.ActivityOptions
///
/// Helper class for building an options Bundle that can be used with
/// android.content.Context\#startActivity(android.content.Intent, android.os.Bundle) Context.startActivity(Intent, Bundle) and related methods.
class ActivityOptions extends jni.JniObject {
  ActivityOptions.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String EXTRA_USAGE_TIME_REPORT
  ///
  /// A long in the extras delivered by \#requestUsageTimeReport that contains
  /// the total time (in ms) the user spent in the app flow.
  static const EXTRA_USAGE_TIME_REPORT = "android.activity.usage_time";

  /// from: static public final java.lang.String EXTRA_USAGE_TIME_REPORT_PACKAGES
  ///
  /// A Bundle in the extras delivered by \#requestUsageTimeReport that contains
  /// detailed information about the time spent in each package associated with the app;
  /// each key is a package name, whose value is a long containing the time (in ms).
  static const EXTRA_USAGE_TIME_REPORT_PACKAGES = "android.usage_time_packages";

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ActivityOptions__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  ActivityOptions() : super.fromRef(_ctor().object);

  static final _makeCustomAnimation = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("ActivityOptions__makeCustomAnimation")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: static public android.app.ActivityOptions makeCustomAnimation(android.content.Context context, int enterResId, int exitResId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an ActivityOptions specifying a custom animation to run when
  /// the activity is displayed.
  ///@param context Who is defining this.  This is the application that the
  /// animation resources will be loaded from.
  ///@param enterResId A resource ID of the animation resource to use for
  /// the incoming activity.  Use 0 for no animation.
  ///@param exitResId A resource ID of the animation resource to use for
  /// the outgoing activity.  Use 0 for no animation.
  ///@return Returns a new ActivityOptions object that you can use to
  /// supply these options as the options Bundle when starting an activity.
  static ActivityOptions makeCustomAnimation(
          content_.Context context, int enterResId, int exitResId) =>
      ActivityOptions.fromRef(
          _makeCustomAnimation(context.reference, enterResId, exitResId)
              .object);

  static final _makeScaleUpAnimation = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("ActivityOptions__makeScaleUpAnimation")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: static public android.app.ActivityOptions makeScaleUpAnimation(android.view.View source, int startX, int startY, int width, int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an ActivityOptions specifying an animation where the new
  /// activity is scaled from a small originating area of the screen to
  /// its final full representation.
  ///
  /// If the Intent this is being used with has not set its
  /// android.content.Intent\#setSourceBounds Intent.setSourceBounds,
  /// those bounds will be filled in for you based on the initial
  /// bounds passed in here.
  ///@param source The View that the new activity is animating from.  This
  /// defines the coordinate space for <var>startX</var> and <var>startY</var>.
  ///@param startX The x starting location of the new activity, relative to <var>source</var>.
  ///@param startY The y starting location of the activity, relative to <var>source</var>.
  ///@param width The initial width of the new activity.
  ///@param height The initial height of the new activity.
  ///@return Returns a new ActivityOptions object that you can use to
  /// supply these options as the options Bundle when starting an activity.
  static ActivityOptions makeScaleUpAnimation(jni.JniObject source, int startX,
          int startY, int width, int height) =>
      ActivityOptions.fromRef(
          _makeScaleUpAnimation(source.reference, startX, startY, width, height)
              .object);

  static final _makeClipRevealAnimation = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("ActivityOptions__makeClipRevealAnimation")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: static public android.app.ActivityOptions makeClipRevealAnimation(android.view.View source, int startX, int startY, int width, int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an ActivityOptions specifying an animation where the new
  /// activity is revealed from a small originating area of the screen to
  /// its final full representation.
  ///@param source The View that the new activity is animating from.  This
  /// defines the coordinate space for <var>startX</var> and <var>startY</var>.
  ///@param startX The x starting location of the new activity, relative to <var>source</var>.
  ///@param startY The y starting location of the activity, relative to <var>source</var>.
  ///@param width The initial width of the new activity.
  ///@param height The initial height of the new activity.
  ///@return Returns a new ActivityOptions object that you can use to
  /// supply these options as the options Bundle when starting an activity.
  static ActivityOptions makeClipRevealAnimation(jni.JniObject source,
          int startX, int startY, int width, int height) =>
      ActivityOptions.fromRef(_makeClipRevealAnimation(
              source.reference, startX, startY, width, height)
          .object);

  static final _makeThumbnailScaleUpAnimation = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32)>>("ActivityOptions__makeThumbnailScaleUpAnimation")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: static public android.app.ActivityOptions makeThumbnailScaleUpAnimation(android.view.View source, android.graphics.Bitmap thumbnail, int startX, int startY)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an ActivityOptions specifying an animation where a thumbnail
  /// is scaled from a given position to the new activity window that is
  /// being started.
  ///
  /// If the Intent this is being used with has not set its
  /// android.content.Intent\#setSourceBounds Intent.setSourceBounds,
  /// those bounds will be filled in for you based on the initial
  /// thumbnail location and size provided here.
  ///@param source The View that this thumbnail is animating from.  This
  /// defines the coordinate space for <var>startX</var> and <var>startY</var>.
  ///@param thumbnail The bitmap that will be shown as the initial thumbnail
  /// of the animation.
  ///@param startX The x starting location of the bitmap, relative to <var>source</var>.
  ///@param startY The y starting location of the bitmap, relative to <var>source</var>.
  ///@return Returns a new ActivityOptions object that you can use to
  /// supply these options as the options Bundle when starting an activity.
  static ActivityOptions makeThumbnailScaleUpAnimation(jni.JniObject source,
          jni.JniObject thumbnail, int startX, int startY) =>
      ActivityOptions.fromRef(_makeThumbnailScaleUpAnimation(
              source.reference, thumbnail.reference, startX, startY)
          .object);

  static final _makeSceneTransitionAnimation = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActivityOptions__makeSceneTransitionAnimation")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.ActivityOptions makeSceneTransitionAnimation(android.app.Activity activity, android.view.View sharedElement, java.lang.String sharedElementName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an ActivityOptions to transition between Activities using cross-Activity scene
  /// animations. This method carries the position of one shared element to the started Activity.
  /// The position of <code>sharedElement</code> will be used as the epicenter for the
  /// exit Transition. The position of the shared element in the launched Activity will be the
  /// epicenter of its entering Transition.
  ///
  /// This requires android.view.Window\#FEATURE_ACTIVITY_TRANSITIONS to be
  /// enabled on the calling Activity to cause an exit transition. The same must be in
  /// the called Activity to get an entering transition.
  ///
  ///@param activity The Activity whose window contains the shared elements.
  ///@param sharedElement The View to transition to the started Activity.
  ///@param sharedElementName The shared element name as used in the target Activity. This
  ///                          must not be null.
  ///@return Returns a new ActivityOptions object that you can use to
  ///         supply these options as the options Bundle when starting an activity.
  ///@see android.transition.Transition\#setEpicenterCallback(
  ///          android.transition.Transition.EpicenterCallback)
  static ActivityOptions makeSceneTransitionAnimation(Activity activity,
          jni.JniObject sharedElement, jni.JniString sharedElementName) =>
      ActivityOptions.fromRef(_makeSceneTransitionAnimation(activity.reference,
              sharedElement.reference, sharedElementName.reference)
          .object);

  static final _makeSceneTransitionAnimation1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActivityOptions__makeSceneTransitionAnimation1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.ActivityOptions makeSceneTransitionAnimation(android.app.Activity activity, android.util.Pair<android.view.View,java.lang.String>[] sharedElements)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create an ActivityOptions to transition between Activities using cross-Activity scene
  /// animations. This method carries the position of multiple shared elements to the started
  /// Activity. The position of the first element in sharedElements
  /// will be used as the epicenter for the exit Transition. The position of the associated
  /// shared element in the launched Activity will be the epicenter of its entering Transition.
  ///
  /// This requires android.view.Window\#FEATURE_ACTIVITY_TRANSITIONS to be
  /// enabled on the calling Activity to cause an exit transition. The same must be in
  /// the called Activity to get an entering transition.
  ///
  ///@param activity The Activity whose window contains the shared elements.
  ///@param sharedElements The names of the shared elements to transfer to the called
  ///                       Activity and their associated Views. The Views must each have
  ///                       a unique shared element name.
  ///@return Returns a new ActivityOptions object that you can use to
  ///         supply these options as the options Bundle when starting an activity.
  ///@see android.transition.Transition\#setEpicenterCallback(
  ///          android.transition.Transition.EpicenterCallback)
  static ActivityOptions makeSceneTransitionAnimation1(
          Activity activity, jni.JniObject sharedElements) =>
      ActivityOptions.fromRef(_makeSceneTransitionAnimation1(
              activity.reference, sharedElements.reference)
          .object);

  static final _makeTaskLaunchBehind =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "ActivityOptions__makeTaskLaunchBehind")
          .asFunction<jni.JniResult Function()>();

  /// from: static public android.app.ActivityOptions makeTaskLaunchBehind()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If set along with Intent.FLAG_ACTIVITY_NEW_DOCUMENT then the task being launched will not be
  /// presented to the user but will instead be only available through the recents task list.
  /// In addition, the new task wil be affiliated with the launching activity's task.
  /// Affiliated tasks are grouped together in the recents task list.
  ///
  /// This behavior is not supported for activities with android.R.styleable\#AndroidManifestActivity_launchMode launchMode values of
  /// <code>singleInstance</code> or <code>singleTask</code>.
  static ActivityOptions makeTaskLaunchBehind() =>
      ActivityOptions.fromRef(_makeTaskLaunchBehind().object);

  static final _makeBasic =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "ActivityOptions__makeBasic")
          .asFunction<jni.JniResult Function()>();

  /// from: static public android.app.ActivityOptions makeBasic()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a basic ActivityOptions that has no special animation associated with it.
  /// Other options can still be set.
  static ActivityOptions makeBasic() =>
      ActivityOptions.fromRef(_makeBasic().object);

  static final _setLaunchBounds = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActivityOptions__setLaunchBounds")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.ActivityOptions setLaunchBounds(android.graphics.Rect screenSpacePixelRect)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the bounds (window size) that the activity should be launched in.
  /// Rect position should be provided in pixels and in screen coordinates.
  /// Set to null explicitly for fullscreen.
  ///
  /// <strong>NOTE:<strong/> This value is ignored on devices that don't have
  /// android.content.pm.PackageManager\#FEATURE_FREEFORM_WINDOW_MANAGEMENT or
  /// android.content.pm.PackageManager\#FEATURE_PICTURE_IN_PICTURE enabled.
  ///@param screenSpacePixelRect Launch bounds to use for the activity or null for fullscreen.
  ///
  /// This value may be {@code null}.
  ActivityOptions setLaunchBounds(jni.JniObject screenSpacePixelRect) =>
      ActivityOptions.fromRef(
          _setLaunchBounds(reference, screenSpacePixelRect.reference).object);

  static final _getLaunchBounds = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActivityOptions__getLaunchBounds")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Rect getLaunchBounds()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the bounds that should be used to launch the activity.
  ///@see \#setLaunchBounds(Rect)
  ///@return Bounds used to launch the activity.
  ///
  /// This value may be {@code null}.
  jni.JniObject getLaunchBounds() =>
      jni.JniObject.fromRef(_getLaunchBounds(reference).object);

  static final _getLockTaskMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActivityOptions__getLockTaskMode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getLockTaskMode()
  ///
  /// Gets whether the activity is to be launched into LockTask mode.
  ///@return {@code true} if the activity is to be launched into LockTask mode.
  ///@see Activity\#startLockTask()
  ///@see android.app.admin.DevicePolicyManager\#setLockTaskPackages(ComponentName, String[])
  bool getLockTaskMode() => _getLockTaskMode(reference).boolean;

  static final _setLockTaskEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("ActivityOptions__setLockTaskEnabled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.ActivityOptions setLockTaskEnabled(boolean lockTaskMode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets whether the activity is to be launched into LockTask mode.
  ///
  /// Use this option to start an activity in LockTask mode. Note that only apps permitted by
  /// android.app.admin.DevicePolicyManager can run in LockTask mode. Therefore, if
  /// android.app.admin.DevicePolicyManager\#isLockTaskPermitted(String) returns
  /// {@code false} for the package of the target activity, a SecurityException will be
  /// thrown during Context\#startActivity(Intent, Bundle). This method doesn't affect
  /// activities that are already running \u2014 relaunch the activity to run in lock task mode.
  ///
  /// Defaults to {@code false} if not set.
  ///@param lockTaskMode {@code true} if the activity is to be launched into LockTask mode.
  ///@return {@code this} ActivityOptions instance.
  ///@see Activity\#startLockTask()
  ///@see android.app.admin.DevicePolicyManager\#setLockTaskPackages(ComponentName, String[])
  ActivityOptions setLockTaskEnabled(bool lockTaskMode) =>
      ActivityOptions.fromRef(
          _setLockTaskEnabled(reference, lockTaskMode ? 1 : 0).object);

  static final _getLaunchDisplayId = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ActivityOptions__getLaunchDisplayId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLaunchDisplayId()
  ///
  /// Gets the id of the display where activity should be launched.
  ///@return The id of the display where activity should be launched,
  ///         android.view.Display\#INVALID_DISPLAY if not set.
  ///@see \#setLaunchDisplayId(int)
  int getLaunchDisplayId() => _getLaunchDisplayId(reference).integer;

  static final _setLaunchDisplayId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ActivityOptions__setLaunchDisplayId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.ActivityOptions setLaunchDisplayId(int launchDisplayId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the id of the display where activity should be launched.
  /// An app can launch activities on public displays or private displays that are owned by the app
  /// or where an app already has activities. Otherwise, trying to launch on a private display
  /// or providing an invalid display id will result in an exception.
  ///
  /// Setting launch display id will be ignored on devices that don't have
  /// android.content.pm.PackageManager\#FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS.
  ///@param launchDisplayId The id of the display where the activity should be launched.
  ///@return {@code this} ActivityOptions instance.
  ActivityOptions setLaunchDisplayId(int launchDisplayId) =>
      ActivityOptions.fromRef(
          _setLaunchDisplayId(reference, launchDisplayId).object);

  static final _update = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ActivityOptions__update")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void update(android.app.ActivityOptions otherOptions)
  ///
  /// Update the current values in this ActivityOptions from those supplied
  /// in <var>otherOptions</var>.  Any values
  /// defined in <var>otherOptions</var> replace those in the base options.
  void update(ActivityOptions otherOptions) =>
      _update(reference, otherOptions.reference).check();

  static final _toBundle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActivityOptions__toBundle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle toBundle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the created options as a Bundle, which can be passed to
  /// android.content.Context\#startActivity(android.content.Intent, android.os.Bundle) Context.startActivity(Intent, Bundle) and related methods.
  /// Note that the returned Bundle is still owned by the ActivityOptions
  /// object; you must not modify it, but can supply it to the startActivity
  /// methods that take an options Bundle.
  os_.Bundle toBundle() => os_.Bundle.fromRef(_toBundle(reference).object);

  static final _requestUsageTimeReport = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActivityOptions__requestUsageTimeReport")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void requestUsageTimeReport(android.app.PendingIntent receiver)
  ///
  /// Ask the the system track that time the user spends in the app being launched, and
  /// report it back once done.  The report will be sent to the given receiver, with
  /// the extras \#EXTRA_USAGE_TIME_REPORT and \#EXTRA_USAGE_TIME_REPORT_PACKAGES
  /// filled in.
  ///
  /// The time interval tracked is from launching this activity until the user leaves
  /// that activity's flow.  They are considered to stay in the flow as long as
  /// new activities are being launched or returned to from the original flow,
  /// even if this crosses package or task boundaries.  For example, if the originator
  /// starts an activity to view an image, and while there the user selects to share,
  /// which launches their email app in a new task, and they complete the share, the
  /// time during that entire operation will be included until they finally hit back from
  /// the original image viewer activity.
  ///
  ///
  /// The user is considered to complete a flow once they switch to another
  /// activity that is not part of the tracked flow.  This may happen, for example, by
  /// using the notification shade, launcher, or recents to launch or switch to another
  /// app.  Simply going in to these navigation elements does not break the flow (although
  /// the launcher and recents stops time tracking of the session); it is the act of
  /// going somewhere else that completes the tracking.
  ///
  ///@param receiver A broadcast receiver that willl receive the report.
  void requestUsageTimeReport(PendingIntent receiver) =>
      _requestUsageTimeReport(reference, receiver.reference).check();

  static final _setAppVerificationBundle = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ActivityOptions__setAppVerificationBundle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.ActivityOptions setAppVerificationBundle(android.os.Bundle bundle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the Bundle that is provided to the app installer for additional verification
  /// if the call to Context\#startActivity results in an app being installed.
  ///
  /// This Bundle is not provided to any other app besides the installer.
  ActivityOptions setAppVerificationBundle(os_.Bundle bundle) =>
      ActivityOptions.fromRef(
          _setAppVerificationBundle(reference, bundle.reference).object);

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ActivityOptions__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);
}

/// from: android.app.AlarmManager
///
/// This class provides access to the system alarm services.  These allow you
/// to schedule your application to be run at some point in the future.  When
/// an alarm goes off, the Intent that had been registered for it
/// is broadcast by the system, automatically starting the target application
/// if it is not already running.  Registered alarms are retained while the
/// device is asleep (and can optionally wake the device up if they go off
/// during that time), but will be cleared if it is turned off and rebooted.
///
/// The Alarm Manager holds a CPU wake lock as long as the alarm receiver's
/// onReceive() method is executing. This guarantees that the phone will not sleep
/// until you have finished handling the broadcast. Once onReceive() returns, the
/// Alarm Manager releases this wake lock. This means that the phone will in some
/// cases sleep as soon as your onReceive() method completes.  If your alarm receiver
/// called android.content.Context\#startService Context.startService(), it
/// is possible that the phone will sleep before the requested service is launched.
/// To prevent this, your BroadcastReceiver and Service will need to implement a
/// separate wake lock policy to ensure that the phone continues running until the
/// service becomes available.
///
/// __Note: The Alarm Manager is intended for cases where you want to have
/// your application code run at a specific time, even if your application is
/// not currently running.  For normal timing operations (ticks, timeouts,
/// etc) it is easier and much more efficient to use
/// android.os.Handler.__
///
/// <p class="caution"><strong>Note:</strong> Beginning with API 19
/// (android.os.Build.VERSION_CODES\#KITKAT) alarm delivery is inexact:
/// the OS will shift alarms in order to minimize wakeups and battery use.  There are
/// new APIs to support applications which need strict delivery guarantees; see
/// \#setWindow(int, long, long, PendingIntent) and
/// \#setExact(int, long, PendingIntent).  Applications whose {@code targetSdkVersion}
/// is earlier than API 19 will continue to see the previous behavior in which all
/// alarms are delivered exactly when requested.
class AlarmManager extends jni.JniObject {
  AlarmManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_NEXT_ALARM_CLOCK_CHANGED
  ///
  /// Broadcast Action: Sent after the value returned by
  /// \#getNextAlarmClock() has changed.
  ///
  /// <p class="note">This is a protected intent that can only be sent by the system.
  /// It is only sent to registered receivers.
  ///
  static const ACTION_NEXT_ALARM_CLOCK_CHANGED =
      "android.app.action.NEXT_ALARM_CLOCK_CHANGED";

  /// from: static public final int ELAPSED_REALTIME
  ///
  /// Alarm time in android.os.SystemClock\#elapsedRealtime SystemClock.elapsedRealtime() (time since boot, including sleep).
  /// This alarm does not wake the device up; if it goes off while the device
  /// is asleep, it will not be delivered until the next time the device
  /// wakes up.
  static const ELAPSED_REALTIME = 3;

  /// from: static public final int ELAPSED_REALTIME_WAKEUP
  ///
  /// Alarm time in android.os.SystemClock\#elapsedRealtime SystemClock.elapsedRealtime() (time since boot, including sleep),
  /// which will wake up the device when it goes off.
  static const ELAPSED_REALTIME_WAKEUP = 2;

  /// from: static public final long INTERVAL_DAY
  ///
  /// Available inexact recurrence interval recognized by
  /// \#setInexactRepeating(int, long, long, PendingIntent)
  /// when running on Android prior to API 19.
  static const INTERVAL_DAY = 86400000;

  /// from: static public final long INTERVAL_FIFTEEN_MINUTES
  ///
  /// Available inexact recurrence interval recognized by
  /// \#setInexactRepeating(int, long, long, PendingIntent)
  /// when running on Android prior to API 19.
  static const INTERVAL_FIFTEEN_MINUTES = 900000;

  /// from: static public final long INTERVAL_HALF_DAY
  ///
  /// Available inexact recurrence interval recognized by
  /// \#setInexactRepeating(int, long, long, PendingIntent)
  /// when running on Android prior to API 19.
  static const INTERVAL_HALF_DAY = 43200000;

  /// from: static public final long INTERVAL_HALF_HOUR
  ///
  /// Available inexact recurrence interval recognized by
  /// \#setInexactRepeating(int, long, long, PendingIntent)
  /// when running on Android prior to API 19.
  static const INTERVAL_HALF_HOUR = 1800000;

  /// from: static public final long INTERVAL_HOUR
  ///
  /// Available inexact recurrence interval recognized by
  /// \#setInexactRepeating(int, long, long, PendingIntent)
  /// when running on Android prior to API 19.
  static const INTERVAL_HOUR = 3600000;

  /// from: static public final int RTC
  ///
  /// Alarm time in System\#currentTimeMillis System.currentTimeMillis()
  /// (wall clock time in UTC).  This alarm does not wake the
  /// device up; if it goes off while the device is asleep, it will not be
  /// delivered until the next time the device wakes up.
  static const RTC = 1;

  /// from: static public final int RTC_WAKEUP
  ///
  /// Alarm time in System\#currentTimeMillis System.currentTimeMillis()
  /// (wall clock time in UTC), which will wake up the device when
  /// it goes off.
  static const RTC_WAKEUP = 0;

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "AlarmManager__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  AlarmManager() : super.fromRef(_ctor().object);

  static final _set0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int64, ffi.Pointer<ffi.Void>)>>("AlarmManager__set0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void set(int type, long triggerAtMillis, android.app.PendingIntent operation)
  ///
  /// Schedule an alarm.  __Note: for timing operations (ticks, timeouts,
  /// etc) it is easier and much more efficient to use android.os.Handler.__
  /// If there is already an alarm scheduled for the same IntentSender, that previous
  /// alarm will first be canceled.
  ///
  /// If the stated trigger time is in the past, the alarm will be triggered
  /// immediately.  If there is already an alarm for this Intent
  /// scheduled (with the equality of two intents being defined by
  /// Intent\#filterEquals), then it will be removed and replaced by
  /// this one.
  ///
  ///
  /// The alarm is an Intent broadcast that goes to a broadcast receiver that
  /// you registered with android.content.Context\#registerReceiver
  /// or through the &lt;receiver&gt; tag in an AndroidManifest.xml file.
  ///
  ///
  /// Alarm intents are delivered with a data extra of type int called
  /// Intent\#EXTRA_ALARM_COUNT Intent.EXTRA_ALARM_COUNT that indicates
  /// how many past alarm events have been accumulated into this intent
  /// broadcast.  Recurring alarms that have gone undelivered because the
  /// phone was asleep may have a count greater than one when delivered.
  ///
  /// <div class="note">
  ///
  /// __Note:__ Beginning in API 19, the trigger time passed to this method
  /// is treated as inexact: the alarm will not be delivered before this time, but
  /// may be deferred and delivered some time later.  The OS will use
  /// this policy in order to "batch" alarms together across the entire system,
  /// minimizing the number of times the device needs to "wake up" and minimizing
  /// battery use.  In general, alarms scheduled in the near future will not
  /// be deferred as long as alarms scheduled far in the future.
  ///
  ///
  /// With the new batching policy, delivery ordering guarantees are not as
  /// strong as they were previously.  If the application sets multiple alarms,
  /// it is possible that these alarms' _actual_ delivery ordering may not match
  /// the order of their _requested_ delivery times.  If your application has
  /// strong ordering requirements there are other APIs that you can use to get
  /// the necessary behavior; see \#setWindow(int, long, long, PendingIntent)
  /// and \#setExact(int, long, PendingIntent).
  ///
  ///
  /// Applications whose {@code targetSdkVersion} is before API 19 will
  /// continue to get the previous alarm behavior: all of their scheduled alarms
  /// will be treated as exact.
  /// </div>
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should go
  /// off, using the appropriate clock (depending on the alarm type).
  ///@param operation Action to perform when the alarm goes off;
  /// typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see android.os.Handler
  ///@see \#setExact
  ///@see \#setRepeating
  ///@see \#setWindow
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  void set0(int type, int triggerAtMillis, PendingIntent operation) =>
      _set0(reference, type, triggerAtMillis, operation.reference).check();

  static final _set1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlarmManager__set1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              int,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void set(int type, long triggerAtMillis, java.lang.String tag, android.app.AlarmManager.OnAlarmListener listener, android.os.Handler targetHandler)
  ///
  /// Direct callback version of \#set(int, long, PendingIntent).  Rather than
  /// supplying a PendingIntent to be sent when the alarm time is reached, this variant
  /// supplies an OnAlarmListener instance that will be invoked at that time.
  ///
  /// The OnAlarmListener's OnAlarmListener\#onAlarm() onAlarm() method will be
  /// invoked via the specified target Handler, or on the application's main looper
  /// if {@code null} is passed as the {@code targetHandler} parameter.
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should go
  ///         off, using the appropriate clock (depending on the alarm type).
  ///@param tag string describing the alarm, used for logging and battery-use
  ///         attribution
  ///@param listener OnAlarmListener instance whose
  ///         OnAlarmListener\#onAlarm() onAlarm() method will be
  ///         called when the alarm time is reached.  A given OnAlarmListener instance can
  ///         only be the target of a single pending alarm, just as a given PendingIntent
  ///         can only be used with one alarm at a time.
  ///@param targetHandler Handler on which to execute the listener's onAlarm()
  ///         callback, or {@code null} to run that callback on the main looper.
  void set1(int type, int triggerAtMillis, jni.JniString tag,
          AlarmManager_OnAlarmListener listener, os_.Handler targetHandler) =>
      _set1(reference, type, triggerAtMillis, tag.reference, listener.reference,
              targetHandler.reference)
          .check();

  static final _setRepeating = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("AlarmManager__setRepeating")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void setRepeating(int type, long triggerAtMillis, long intervalMillis, android.app.PendingIntent operation)
  ///
  /// Schedule a repeating alarm.  __Note: for timing operations (ticks,
  /// timeouts, etc) it is easier and much more efficient to use
  /// android.os.Handler.__  If there is already an alarm scheduled
  /// for the same IntentSender, it will first be canceled.
  ///
  /// Like \#set, except you can also supply a period at which
  /// the alarm will automatically repeat.  This alarm continues
  /// repeating until explicitly removed with \#cancel.  If the stated
  /// trigger time is in the past, the alarm will be triggered immediately, with an
  /// alarm count depending on how far in the past the trigger time is relative
  /// to the repeat interval.
  ///
  /// If an alarm is delayed (by system sleep, for example, for non
  /// _WAKEUP alarm types), a skipped repeat will be delivered as soon as
  /// possible.  After that, future alarms will be delivered according to the
  /// original schedule; they do not drift over time.  For example, if you have
  /// set a recurring alarm for the top of every hour but the phone was asleep
  /// from 7:45 until 8:45, an alarm will be sent as soon as the phone awakens,
  /// then the next alarm will be sent at 9:00.
  ///
  /// If your application wants to allow the delivery times to drift in
  /// order to guarantee that at least a certain time interval always elapses
  /// between alarms, then the approach to take is to use one-time alarms,
  /// scheduling the next one yourself when handling each alarm delivery.
  ///
  /// <p class="note">
  /// __Note:__ as of API 19, all repeating alarms are inexact.  If your
  /// application needs precise delivery times then it must use one-time
  /// exact alarms, rescheduling each time as described above. Legacy applications
  /// whose {@code targetSdkVersion} is earlier than API 19 will continue to have all
  /// of their alarms, including repeating alarms, treated as exact.
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should first
  /// go off, using the appropriate clock (depending on the alarm type).
  ///@param intervalMillis interval in milliseconds between subsequent repeats
  /// of the alarm.
  ///@param operation Action to perform when the alarm goes off;
  /// typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see android.os.Handler
  ///@see \#set
  ///@see \#setExact
  ///@see \#setWindow
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  void setRepeating(int type, int triggerAtMillis, int intervalMillis,
          PendingIntent operation) =>
      _setRepeating(reference, type, triggerAtMillis, intervalMillis,
              operation.reference)
          .check();

  static final _setWindow = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("AlarmManager__setWindow")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void setWindow(int type, long windowStartMillis, long windowLengthMillis, android.app.PendingIntent operation)
  ///
  /// Schedule an alarm to be delivered within a given window of time.  This method
  /// is similar to \#set(int, long, PendingIntent), but allows the
  /// application to precisely control the degree to which its delivery might be
  /// adjusted by the OS. This method allows an application to take advantage of the
  /// battery optimizations that arise from delivery batching even when it has
  /// modest timeliness requirements for its alarms.
  ///
  ///
  /// This method can also be used to achieve strict ordering guarantees among
  /// multiple alarms by ensuring that the windows requested for each alarm do
  /// not intersect.
  ///
  ///
  /// When precise delivery is not required, applications should use the standard
  /// \#set(int, long, PendingIntent) method.  This will give the OS the most
  /// flexibility to minimize wakeups and battery use.  For alarms that must be delivered
  /// at precisely-specified times with no acceptable variation, applications can use
  /// \#setExact(int, long, PendingIntent).
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param windowStartMillis The earliest time, in milliseconds, that the alarm should
  ///        be delivered, expressed in the appropriate clock's units (depending on the alarm
  ///        type).
  ///@param windowLengthMillis The length of the requested delivery window,
  ///        in milliseconds.  The alarm will be delivered no later than this many
  ///        milliseconds after {@code windowStartMillis}.  Note that this parameter
  ///        is a <i>duration,</i> not the timestamp of the end of the window.
  ///@param operation Action to perform when the alarm goes off;
  ///        typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see \#set
  ///@see \#setExact
  ///@see \#setRepeating
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  void setWindow(int type, int windowStartMillis, int windowLengthMillis,
          PendingIntent operation) =>
      _setWindow(reference, type, windowStartMillis, windowLengthMillis,
              operation.reference)
          .check();

  static final _setWindow1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlarmManager__setWindow1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setWindow(int type, long windowStartMillis, long windowLengthMillis, java.lang.String tag, android.app.AlarmManager.OnAlarmListener listener, android.os.Handler targetHandler)
  ///
  /// Direct callback version of \#setWindow(int, long, long, PendingIntent).  Rather
  /// than supplying a PendingIntent to be sent when the alarm time is reached, this variant
  /// supplies an OnAlarmListener instance that will be invoked at that time.
  ///
  /// The OnAlarmListener OnAlarmListener\#onAlarm() onAlarm() method will be
  /// invoked via the specified target Handler, or on the application's main looper
  /// if {@code null} is passed as the {@code targetHandler} parameter.
  ///@param type Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  void setWindow1(
          int type,
          int windowStartMillis,
          int windowLengthMillis,
          jni.JniString tag,
          AlarmManager_OnAlarmListener listener,
          os_.Handler targetHandler) =>
      _setWindow1(reference, type, windowStartMillis, windowLengthMillis,
              tag.reference, listener.reference, targetHandler.reference)
          .check();

  static final _setExact = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int64, ffi.Pointer<ffi.Void>)>>("AlarmManager__setExact")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExact(int type, long triggerAtMillis, android.app.PendingIntent operation)
  ///
  /// Schedule an alarm to be delivered precisely at the stated time.
  ///
  ///
  /// This method is like \#set(int, long, PendingIntent), but does not permit
  /// the OS to adjust the delivery time.  The alarm will be delivered as nearly as
  /// possible to the requested trigger time.
  ///
  ///
  /// __Note:__ only alarms for which there is a strong demand for exact-time
  /// delivery (such as an alarm clock ringing at the requested time) should be
  /// scheduled as exact.  Applications are strongly discouraged from using exact
  /// alarms unnecessarily as they reduce the OS's ability to minimize battery use.
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should go
  ///        off, using the appropriate clock (depending on the alarm type).
  ///@param operation Action to perform when the alarm goes off;
  ///        typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see \#set
  ///@see \#setRepeating
  ///@see \#setWindow
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  void setExact(int type, int triggerAtMillis, PendingIntent operation) =>
      _setExact(reference, type, triggerAtMillis, operation.reference).check();

  static final _setExact1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlarmManager__setExact1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              int,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setExact(int type, long triggerAtMillis, java.lang.String tag, android.app.AlarmManager.OnAlarmListener listener, android.os.Handler targetHandler)
  ///
  /// Direct callback version of \#setExact(int, long, PendingIntent).  Rather
  /// than supplying a PendingIntent to be sent when the alarm time is reached, this variant
  /// supplies an OnAlarmListener instance that will be invoked at that time.
  ///
  /// The OnAlarmListener's OnAlarmListener\#onAlarm() onAlarm() method will be
  /// invoked via the specified target Handler, or on the application's main looper
  /// if {@code null} is passed as the {@code targetHandler} parameter.
  ///@param type Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  void setExact1(int type, int triggerAtMillis, jni.JniString tag,
          AlarmManager_OnAlarmListener listener, os_.Handler targetHandler) =>
      _setExact1(reference, type, triggerAtMillis, tag.reference,
              listener.reference, targetHandler.reference)
          .check();

  static final _setAlarmClock = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlarmManager__setAlarmClock")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setAlarmClock(android.app.AlarmManager.AlarmClockInfo info, android.app.PendingIntent operation)
  ///
  /// Schedule an alarm that represents an alarm clock, which will be used to notify the user
  /// when it goes off.  The expectation is that when this alarm triggers, the application will
  /// further wake up the device to tell the user about the alarm -- turning on the screen,
  /// playing a sound, vibrating, etc.  As such, the system will typically also use the
  /// information supplied here to tell the user about this upcoming alarm if appropriate.
  ///
  /// Due to the nature of this kind of alarm, similar to \#setExactAndAllowWhileIdle,
  /// these alarms will be allowed to trigger even if the system is in a low-power idle
  /// (a.k.a. doze) mode.  The system may also do some prep-work when it sees that such an
  /// alarm coming up, to reduce the amount of background work that could happen if this
  /// causes the device to fully wake up -- this is to avoid situations such as a large number
  /// of devices having an alarm set at the same time in the morning, all waking up at that
  /// time and suddenly swamping the network with pending background work.  As such, these
  /// types of alarms can be extremely expensive on battery use and should only be used for
  /// their intended purpose.
  ///
  ///
  ///
  /// This method is like \#setExact(int, long, PendingIntent), but implies
  /// \#RTC_WAKEUP.
  ///@param info
  ///@param operation Action to perform when the alarm goes off;
  ///        typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see \#set
  ///@see \#setRepeating
  ///@see \#setWindow
  ///@see \#setExact
  ///@see \#cancel
  ///@see \#getNextAlarmClock()
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  void setAlarmClock(
          AlarmManager_AlarmClockInfo info, PendingIntent operation) =>
      _setAlarmClock(reference, info.reference, operation.reference).check();

  static final _setInexactRepeating = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("AlarmManager__setInexactRepeating")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void setInexactRepeating(int type, long triggerAtMillis, long intervalMillis, android.app.PendingIntent operation)
  ///
  /// Schedule a repeating alarm that has inexact trigger time requirements;
  /// for example, an alarm that repeats every hour, but not necessarily at
  /// the top of every hour.  These alarms are more power-efficient than
  /// the strict recurrences traditionally supplied by \#setRepeating, since the
  /// system can adjust alarms' delivery times to cause them to fire simultaneously,
  /// avoiding waking the device from sleep more than necessary.
  ///
  /// Your alarm's first trigger will not be before the requested time,
  /// but it might not occur for almost a full interval after that time.  In
  /// addition, while the overall period of the repeating alarm will be as
  /// requested, the time between any two successive firings of the alarm
  /// may vary.  If your application demands very low jitter, use
  /// one-shot alarms with an appropriate window instead; see \#setWindow(int, long, long, PendingIntent) and
  /// \#setExact(int, long, PendingIntent).
  ///
  /// <p class="note">
  /// As of API 19, all repeating alarms are inexact.  Because this method has
  /// been available since API 3, your application can safely call it and be
  /// assured that it will get similar behavior on both current and older versions
  /// of Android.
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should first
  /// go off, using the appropriate clock (depending on the alarm type).  This
  /// is inexact: the alarm will not fire before this time, but there may be a
  /// delay of almost an entire alarm interval before the first invocation of
  /// the alarm.
  ///@param intervalMillis interval in milliseconds between subsequent repeats
  /// of the alarm.  Prior to API 19, if this is one of INTERVAL_FIFTEEN_MINUTES,
  /// INTERVAL_HALF_HOUR, INTERVAL_HOUR, INTERVAL_HALF_DAY, or INTERVAL_DAY
  /// then the alarm will be phase-aligned with other alarms to reduce the
  /// number of wakeups.  Otherwise, the alarm will be set as though the
  /// application had called \#setRepeating.  As of API 19, all repeating
  /// alarms will be inexact and subject to batching with other alarms regardless
  /// of their stated repeat interval.
  ///@param operation Action to perform when the alarm goes off;
  /// typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see android.os.Handler
  ///@see \#set
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  ///@see \#INTERVAL_FIFTEEN_MINUTES
  ///@see \#INTERVAL_HALF_HOUR
  ///@see \#INTERVAL_HOUR
  ///@see \#INTERVAL_HALF_DAY
  ///@see \#INTERVAL_DAY
  void setInexactRepeating(int type, int triggerAtMillis, int intervalMillis,
          PendingIntent operation) =>
      _setInexactRepeating(reference, type, triggerAtMillis, intervalMillis,
              operation.reference)
          .check();

  static final _setAndAllowWhileIdle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("AlarmManager__setAndAllowWhileIdle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void setAndAllowWhileIdle(int type, long triggerAtMillis, android.app.PendingIntent operation)
  ///
  /// Like \#set(int, long, PendingIntent), but this alarm will be allowed to execute
  /// even when the system is in low-power idle (a.k.a. doze) modes.  This type of alarm must
  /// __only__ be used for situations where it is actually required that the alarm go off while
  /// in idle -- a reasonable example would be for a calendar notification that should make a
  /// sound so the user is aware of it.  When the alarm is dispatched, the app will also be
  /// added to the system's temporary whitelist for approximately 10 seconds to allow that
  /// application to acquire further wake locks in which to complete its work.
  ///
  ///
  /// These alarms can significantly impact the power use
  /// of the device when idle (and thus cause significant battery blame to the app scheduling
  /// them), so they should be used with care.  To reduce abuse, there are restrictions on how
  /// frequently these alarms will go off for a particular application.
  /// Under normal system operation, it will not dispatch these
  /// alarms more than about every minute (at which point every such pending alarm is
  /// dispatched); when in low-power idle modes this duration may be significantly longer,
  /// such as 15 minutes.
  ///
  ///
  /// Unlike other alarms, the system is free to reschedule this type of alarm to happen
  /// out of order with any other alarms, even those from the same app.  This will clearly happen
  /// when the device is idle (since this alarm can go off while idle, when any other alarms
  /// from the app will be held until later), but may also happen even when not idle.
  ///
  ///
  /// Regardless of the app's target SDK version, this call always allows batching of the
  /// alarm.
  ///
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should go
  /// off, using the appropriate clock (depending on the alarm type).
  ///@param operation Action to perform when the alarm goes off;
  /// typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see \#set(int, long, PendingIntent)
  ///@see \#setExactAndAllowWhileIdle
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  void setAndAllowWhileIdle(
          int type, int triggerAtMillis, PendingIntent operation) =>
      _setAndAllowWhileIdle(
              reference, type, triggerAtMillis, operation.reference)
          .check();

  static final _setExactAndAllowWhileIdle = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Int64, ffi.Pointer<ffi.Void>)>>(
          "AlarmManager__setExactAndAllowWhileIdle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExactAndAllowWhileIdle(int type, long triggerAtMillis, android.app.PendingIntent operation)
  ///
  /// Like \#setExact(int, long, PendingIntent), but this alarm will be allowed to execute
  /// even when the system is in low-power idle modes.  If you don't need exact scheduling of
  /// the alarm but still need to execute while idle, consider using
  /// \#setAndAllowWhileIdle.  This type of alarm must __only__
  /// be used for situations where it is actually required that the alarm go off while in
  /// idle -- a reasonable example would be for a calendar notification that should make a
  /// sound so the user is aware of it.  When the alarm is dispatched, the app will also be
  /// added to the system's temporary whitelist for approximately 10 seconds to allow that
  /// application to acquire further wake locks in which to complete its work.
  ///
  ///
  /// These alarms can significantly impact the power use
  /// of the device when idle (and thus cause significant battery blame to the app scheduling
  /// them), so they should be used with care.  To reduce abuse, there are restrictions on how
  /// frequently these alarms will go off for a particular application.
  /// Under normal system operation, it will not dispatch these
  /// alarms more than about every minute (at which point every such pending alarm is
  /// dispatched); when in low-power idle modes this duration may be significantly longer,
  /// such as 15 minutes.
  ///
  ///
  /// Unlike other alarms, the system is free to reschedule this type of alarm to happen
  /// out of order with any other alarms, even those from the same app.  This will clearly happen
  /// when the device is idle (since this alarm can go off while idle, when any other alarms
  /// from the app will be held until later), but may also happen even when not idle.
  /// Note that the OS will allow itself more flexibility for scheduling these alarms than
  /// regular exact alarms, since the application has opted into this behavior.  When the
  /// device is idle it may take even more liberties with scheduling in order to optimize
  /// for battery life.
  ///
  ///@param type type of alarm.
  /// Value is android.app.AlarmManager\#RTC_WAKEUP, android.app.AlarmManager\#RTC, android.app.AlarmManager\#ELAPSED_REALTIME_WAKEUP, or android.app.AlarmManager\#ELAPSED_REALTIME
  ///@param triggerAtMillis time in milliseconds that the alarm should go
  ///        off, using the appropriate clock (depending on the alarm type).
  ///@param operation Action to perform when the alarm goes off;
  ///        typically comes from PendingIntent\#getBroadcast IntentSender.getBroadcast().
  ///@see \#set
  ///@see \#setRepeating
  ///@see \#setWindow
  ///@see \#cancel
  ///@see android.content.Context\#sendBroadcast
  ///@see android.content.Context\#registerReceiver
  ///@see android.content.Intent\#filterEquals
  ///@see \#ELAPSED_REALTIME
  ///@see \#ELAPSED_REALTIME_WAKEUP
  ///@see \#RTC
  ///@see \#RTC_WAKEUP
  void setExactAndAllowWhileIdle(
          int type, int triggerAtMillis, PendingIntent operation) =>
      _setExactAndAllowWhileIdle(
              reference, type, triggerAtMillis, operation.reference)
          .check();

  static final _cancel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlarmManager__cancel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void cancel(android.app.PendingIntent operation)
  ///
  /// Remove any alarms with a matching Intent.
  /// Any alarm, of any type, whose Intent matches this one (as defined by
  /// Intent\#filterEquals), will be canceled.
  ///@param operation IntentSender which matches a previously added
  /// IntentSender. This parameter must not be {@code null}.
  ///@see \#set
  void cancel(PendingIntent operation) =>
      _cancel(reference, operation.reference).check();

  static final _cancel1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlarmManager__cancel1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void cancel(android.app.AlarmManager.OnAlarmListener listener)
  ///
  /// Remove any alarm scheduled to be delivered to the given OnAlarmListener.
  ///@param listener OnAlarmListener instance that is the target of a currently-set alarm.
  void cancel1(AlarmManager_OnAlarmListener listener) =>
      _cancel1(reference, listener.reference).check();

  static final _setTime = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int64)>>("AlarmManager__setTime")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setTime(long millis)
  ///
  /// Set the system wall clock time.
  /// Requires the permission android.permission.SET_TIME.
  ///@param millis time in milliseconds since the Epoch
  void setTime(int millis) => _setTime(reference, millis).check();

  static final _setTimeZone = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlarmManager__setTimeZone")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTimeZone(java.lang.String timeZone)
  ///
  /// Sets the system's persistent default time zone. This is the time zone for all apps, even
  /// after a reboot. Use java.util.TimeZone\#setDefault if you just want to change the
  /// time zone within your app, and even then prefer to pass an explicit
  /// java.util.TimeZone to APIs that require it rather than changing the time zone for
  /// all threads.
  ///
  ///  On android M and above, it is an error to pass in a non-Olson timezone to this
  /// function. Note that this is a bad idea on all Android releases because POSIX and
  /// the {@code TimeZone} class have opposite interpretations of {@code '+'} and {@code '-'}
  /// in the same non-Olson ID.
  ///@param timeZone one of the Olson ids from the list returned by
  ///     java.util.TimeZone\#getAvailableIDs
  void setTimeZone(jni.JniString timeZone) =>
      _setTimeZone(reference, timeZone.reference).check();

  static final _getNextAlarmClock = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AlarmManager__getNextAlarmClock")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlarmManager.AlarmClockInfo getNextAlarmClock()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets information about the next alarm clock currently scheduled.
  ///
  /// The alarm clocks considered are those scheduled by any application
  /// using the \#setAlarmClock method.
  ///@return An AlarmClockInfo object describing the next upcoming alarm
  ///   clock event that will occur.  If there are no alarm clock events currently
  ///   scheduled, this method will return {@code null}.
  ///@see \#setAlarmClock
  ///@see AlarmClockInfo
  ///@see \#ACTION_NEXT_ALARM_CLOCK_CHANGED
  AlarmManager_AlarmClockInfo getNextAlarmClock() =>
      AlarmManager_AlarmClockInfo.fromRef(_getNextAlarmClock(reference).object);
}

/// from: android.app.AlarmManager$OnAlarmListener
///
/// Direct-notification alarms: the requester must be running continuously from the
/// time the alarm is set to the time it is delivered, or delivery will fail.  Only
/// one-shot alarms can be set using this mechanism, not repeating alarms.
class AlarmManager_OnAlarmListener extends jni.JniObject {
  AlarmManager_OnAlarmListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onAlarm = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AlarmManager_OnAlarmListener__onAlarm")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onAlarm()
  ///
  /// Callback method that is invoked by the system when the alarm time is reached.
  void onAlarm() => _onAlarm(reference).check();
}

/// from: android.app.AlarmManager$AlarmClockInfo
///
/// An immutable description of a scheduled "alarm clock" event.
///@see AlarmManager\#setAlarmClock
///@see AlarmManager\#getNextAlarmClock
class AlarmManager_AlarmClockInfo extends jni.JniObject {
  AlarmManager_AlarmClockInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_AlarmManager_AlarmClockInfo__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.AlarmManager.AlarmClockInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("AlarmManager_AlarmClockInfo__ctor")
      .asFunction<jni.JniResult Function(int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(long triggerTime, android.app.PendingIntent showIntent)
  ///
  /// Creates a new alarm clock description.
  ///@param triggerTime time at which the underlying alarm is triggered in wall time
  ///                    milliseconds since the epoch
  ///@param showIntent an intent that can be used to show or edit details of
  ///                        the alarm clock.
  AlarmManager_AlarmClockInfo(int triggerTime, PendingIntent showIntent)
      : super.fromRef(_ctor(triggerTime, showIntent.reference).object);

  static final _getTriggerTime = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AlarmManager_AlarmClockInfo__getTriggerTime")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTriggerTime()
  ///
  /// Returns the time at which the alarm is going to trigger.
  ///
  /// This value is UTC wall clock time in milliseconds, as returned by
  /// System\#currentTimeMillis() for example.
  int getTriggerTime() => _getTriggerTime(reference).long;

  static final _getShowIntent = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AlarmManager_AlarmClockInfo__getShowIntent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent getShowIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an intent that can be used to show or edit details of the alarm clock in
  /// the application that scheduled it.
  ///
  /// <p class="note">Beware that any application can retrieve and send this intent,
  /// potentially with additional fields filled in. See
  /// PendingIntent\#send(android.content.Context, int, android.content.Intent) PendingIntent.send() and android.content.Intent\#fillIn Intent.fillIn()
  /// for details.
  PendingIntent getShowIntent() =>
      PendingIntent.fromRef(_getShowIntent(reference).object);

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AlarmManager_AlarmClockInfo__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("AlarmManager_AlarmClockInfo__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();
}

/// from: android.app.AlertDialog
///
/// A subclass of Dialog that can display one, two or three buttons. If you only want to
/// display a String in this dialog box, use the setMessage() method.  If you
/// want to display a more complex view, look up the FrameLayout called "custom"
/// and add your view to it:
///
/// <pre>
/// FrameLayout fl = findViewById(android.R.id.custom);
/// fl.addView(myView, new LayoutParams(MATCH_PARENT, WRAP_CONTENT));
/// </pre>
///
/// The AlertDialog class takes care of automatically setting
/// android.view.WindowManager.LayoutParams\#FLAG_ALT_FOCUSABLE_IM WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM for you based on whether
/// any views in the dialog return true from View\#onCheckIsTextEditor() View.onCheckIsTextEditor().  Generally you want this set for a Dialog
/// without text editors, so that it will be placed on top of the current
/// input method UI.  You can modify this behavior by forcing the flag to your
/// desired mode after calling \#onCreate.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about creating dialogs, read the
/// <a href="{@docRoot}guide/topics/ui/dialogs.html">Dialogs</a> developer guide.
///
/// </div>
class AlertDialog extends Dialog {
  AlertDialog.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int THEME_DEVICE_DEFAULT_DARK
  ///
  /// Special theme constant for \#AlertDialog(Context, int): use
  /// the device's default alert theme with a dark background.
  ///@deprecated Use android.R.style\#Theme_DeviceDefault_Dialog_Alert.
  static const THEME_DEVICE_DEFAULT_DARK = 4;

  /// from: static public final int THEME_DEVICE_DEFAULT_LIGHT
  ///
  /// Special theme constant for \#AlertDialog(Context, int): use
  /// the device's default alert theme with a light background.
  ///@deprecated Use android.R.style\#Theme_DeviceDefault_Light_Dialog_Alert.
  static const THEME_DEVICE_DEFAULT_LIGHT = 5;

  /// from: static public final int THEME_HOLO_DARK
  ///
  /// Special theme constant for \#AlertDialog(Context, int): use
  /// the holographic alert theme with a dark background.
  ///@deprecated Use android.R.style\#Theme_Material_Dialog_Alert.
  static const THEME_HOLO_DARK = 2;

  /// from: static public final int THEME_HOLO_LIGHT
  ///
  /// Special theme constant for \#AlertDialog(Context, int): use
  /// the holographic alert theme with a light background.
  ///@deprecated Use android.R.style\#Theme_Material_Light_Dialog_Alert.
  static const THEME_HOLO_LIGHT = 3;

  /// from: static public final int THEME_TRADITIONAL
  ///
  /// Special theme constant for \#AlertDialog(Context, int): use
  /// the traditional (pre-Holo) alert dialog theme.
  ///@deprecated Use android.R.style\#Theme_Material_Dialog_Alert.
  static const THEME_TRADITIONAL = 1;

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AlertDialog__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void <init>(android.content.Context context)
  ///
  /// Creates an alert dialog that uses the default alert dialog theme.
  ///
  /// The default alert dialog theme is defined by
  /// android.R.attr\#alertDialogTheme within the parent
  /// {@code context}'s theme.
  ///@param context the parent context
  ///@see android.R.styleable\#Theme_alertDialogTheme
  AlertDialog(content_.Context context)
      : super.fromRef(_ctor(context.reference).object);

  static final _ctor2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog__ctor2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: protected void <init>(android.content.Context context, boolean cancelable, android.content.DialogInterface.OnCancelListener cancelListener)
  ///
  /// Creates an alert dialog that uses the default alert dialog theme and a
  /// custom cancel listener.
  ///
  /// This is functionally identical to:
  /// <pre>
  ///     AlertDialog dialog = new AlertDialog(context);
  ///     alertDialog.setCancelable(cancelable);
  ///     alertDialog.setOnCancelListener(cancelListener);
  /// </pre>
  ///
  /// The default alert dialog theme is defined by
  /// android.R.attr\#alertDialogTheme within the parent
  /// {@code context}'s theme.
  ///@param context the parent context
  ///@see android.R.styleable\#Theme_alertDialogTheme
  AlertDialog.ctor2(content_.Context context, bool cancelable,
      content_.DialogInterface_OnCancelListener cancelListener)
      : super.fromRef(_ctor2(
                context.reference, cancelable ? 1 : 0, cancelListener.reference)
            .object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("AlertDialog__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: protected void <init>(android.content.Context context, int themeResId)
  ///
  /// Creates an alert dialog that uses an explicit theme resource.
  ///
  /// The specified theme resource ({@code themeResId}) is applied on top of
  /// the parent {@code context}'s theme. It may be specified as a style
  /// resource containing a fully-populated theme, such as
  /// android.R.style\#Theme_Material_Dialog, to replace all attributes
  /// in the parent {@code context}'s theme including primary and accent
  /// colors.
  ///
  /// To preserve attributes such as primary and accent colors, the
  /// {@code themeResId} may instead be specified as an overlay theme such as
  /// android.R.style\#ThemeOverlay_Material_Dialog. This will override
  /// only the window attributes necessary to style the alert window as a
  /// dialog.
  ///
  /// Alternatively, the {@code themeResId} may be specified as {@code 0} to
  /// use the parent {@code context}'s resolved value for
  /// android.R.attr\#alertDialogTheme.
  ///@param context the parent context
  ///@param themeResId the resource ID of the theme against which to inflate
  ///                   this dialog, or {@code 0} to use the parent
  ///                   {@code context}'s default alert dialog theme
  ///@see android.R.styleable\#Theme_alertDialogTheme
  AlertDialog.ctor1(content_.Context context, int themeResId)
      : super.fromRef(_ctor1(context.reference, themeResId).object);

  static final _getButton = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("AlertDialog__getButton")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.widget.Button getButton(int whichButton)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets one of the buttons used in the dialog. Returns null if the specified
  /// button does not exist or the dialog has not yet been fully created (for
  /// example, via \#show() or \#create()).
  ///@param whichButton The identifier of the button that should be returned.
  ///            For example, this can be
  ///            DialogInterface\#BUTTON_POSITIVE.
  ///@return The button from the dialog, or null if a button does not exist.
  jni.JniObject getButton(int whichButton) =>
      jni.JniObject.fromRef(_getButton(reference, whichButton).object);

  static final _getListView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AlertDialog__getListView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.ListView getListView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the list view used in the dialog.
  ///@return The ListView from the dialog.
  jni.JniObject getListView() =>
      jni.JniObject.fromRef(_getListView(reference).object);

  static final _setTitle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog__setTitle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTitle(java.lang.CharSequence title)
  void setTitle(jni.JniObject title) =>
      _setTitle(reference, title.reference).check();

  static final _setCustomTitle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog__setCustomTitle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setCustomTitle(android.view.View customTitleView)
  ///
  /// @see Builder\#setCustomTitle(View)
  void setCustomTitle(jni.JniObject customTitleView) =>
      _setCustomTitle(reference, customTitleView.reference).check();

  static final _setMessage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog__setMessage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setMessage(java.lang.CharSequence message)
  void setMessage(jni.JniObject message) =>
      _setMessage(reference, message.reference).check();

  static final _setView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog__setView")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setView(android.view.View view)
  ///
  /// Set the view to display in that dialog.
  void setView(jni.JniObject view) =>
      _setView(reference, view.reference).check();

  static final _setView1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("AlertDialog__setView1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, int, int, int)>();

  /// from: public void setView(android.view.View view, int viewSpacingLeft, int viewSpacingTop, int viewSpacingRight, int viewSpacingBottom)
  ///
  /// Set the view to display in that dialog, specifying the spacing to appear around that
  /// view.
  ///@param view The view to show in the content area of the dialog
  ///@param viewSpacingLeft Extra space to appear to the left of {@code view}
  ///@param viewSpacingTop Extra space to appear above {@code view}
  ///@param viewSpacingRight Extra space to appear to the right of {@code view}
  ///@param viewSpacingBottom Extra space to appear below {@code view}
  void setView1(jni.JniObject view, int viewSpacingLeft, int viewSpacingTop,
          int viewSpacingRight, int viewSpacingBottom) =>
      _setView1(reference, view.reference, viewSpacingLeft, viewSpacingTop,
              viewSpacingRight, viewSpacingBottom)
          .check();

  static final _setButton = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog__setButton")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setButton(int whichButton, java.lang.CharSequence text, android.os.Message msg)
  ///
  /// Set a message to be sent when a button is pressed.
  ///@param whichButton Which button to set the message for, can be one of
  ///            DialogInterface\#BUTTON_POSITIVE,
  ///            DialogInterface\#BUTTON_NEGATIVE, or
  ///            DialogInterface\#BUTTON_NEUTRAL
  ///@param text The text to display in positive button.
  ///@param msg The Message to be sent when clicked.
  void setButton(int whichButton, jni.JniObject text, os_.Message msg) =>
      _setButton(reference, whichButton, text.reference, msg.reference).check();

  static final _setButton1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog__setButton1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setButton(int whichButton, java.lang.CharSequence text, android.content.DialogInterface.OnClickListener listener)
  ///
  /// Set a listener to be invoked when the positive button of the dialog is pressed.
  ///@param whichButton Which button to set the listener on, can be one of
  ///            DialogInterface\#BUTTON_POSITIVE,
  ///            DialogInterface\#BUTTON_NEGATIVE, or
  ///            DialogInterface\#BUTTON_NEUTRAL
  ///@param text The text to display in positive button.
  ///@param listener The DialogInterface.OnClickListener to use.
  void setButton1(int whichButton, jni.JniObject text,
          content_.DialogInterface_OnClickListener listener) =>
      _setButton1(reference, whichButton, text.reference, listener.reference)
          .check();

  static final _setButton2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog__setButton2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setButton(java.lang.CharSequence text, android.os.Message msg)
  ///
  /// @deprecated Use \#setButton(int, CharSequence, Message) with
  ///             DialogInterface\#BUTTON_POSITIVE.
  void setButton2(jni.JniObject text, os_.Message msg) =>
      _setButton2(reference, text.reference, msg.reference).check();

  static final _setButton3 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog__setButton3")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setButton(java.lang.CharSequence text, android.content.DialogInterface.OnClickListener listener)
  ///
  /// Set a listener to be invoked when button 1 of the dialog is pressed.
  ///@param text The text to display in button 1.
  ///@param listener The DialogInterface.OnClickListener to use.
  ///@deprecated Use
  ///             \#setButton(int, CharSequence, android.content.DialogInterface.OnClickListener)
  ///             with DialogInterface\#BUTTON_POSITIVE
  void setButton3(jni.JniObject text,
          content_.DialogInterface_OnClickListener listener) =>
      _setButton3(reference, text.reference, listener.reference).check();

  static final _setIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("AlertDialog__setIcon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setIcon(int resId)
  ///
  /// Set resId to 0 if you don't want an icon.
  ///@param resId the resourceId of the drawable to use as the icon or 0
  /// if you don't want an icon.
  void setIcon(int resId) => _setIcon(reference, resId).check();

  static final _setIcon1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog__setIcon1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setIcon(android.graphics.drawable.Drawable icon)
  void setIcon1(jni.JniObject icon) =>
      _setIcon1(reference, icon.reference).check();

  static final _setIconAttribute = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("AlertDialog__setIconAttribute")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setIconAttribute(int attrId)
  ///
  /// Set an icon as supplied by a theme attribute. e.g. android.R.attr.alertDialogIcon
  ///@param attrId ID of a theme attribute that points to a drawable resource.
  void setIconAttribute(int attrId) =>
      _setIconAttribute(reference, attrId).check();

  static final _setInverseBackgroundForced = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("AlertDialog__setInverseBackgroundForced")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setInverseBackgroundForced(boolean forceInverseBackground)
  void setInverseBackgroundForced(bool forceInverseBackground) =>
      _setInverseBackgroundForced(reference, forceInverseBackground ? 1 : 0)
          .check();

  static final _onCreate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog__onCreate")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onCreate(android.os.Bundle savedInstanceState)
  void onCreate(os_.Bundle savedInstanceState) =>
      _onCreate(reference, savedInstanceState.reference).check();

  static final _onKeyDown = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog__onKeyDown")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyDown(int keyCode, android.view.KeyEvent event)
  bool onKeyDown(int keyCode, jni.JniObject event) =>
      _onKeyDown(reference, keyCode, event.reference).boolean;

  static final _onKeyUp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog__onKeyUp")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyUp(int keyCode, android.view.KeyEvent event)
  bool onKeyUp(int keyCode, jni.JniObject event) =>
      _onKeyUp(reference, keyCode, event.reference).boolean;
}

/// from: android.app.AlertDialog$Builder
class AlertDialog_Builder extends jni.JniObject {
  AlertDialog_Builder.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AlertDialog_Builder__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  ///
  /// Creates a builder for an alert dialog that uses the default alert
  /// dialog theme.
  ///
  /// The default alert dialog theme is defined by
  /// android.R.attr\#alertDialogTheme within the parent
  /// {@code context}'s theme.
  ///@param context the parent context
  AlertDialog_Builder(content_.Context context)
      : super.fromRef(_ctor(context.reference).object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("AlertDialog_Builder__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Context context, int themeResId)
  ///
  /// Creates a builder for an alert dialog that uses an explicit theme
  /// resource.
  ///
  /// The specified theme resource ({@code themeResId}) is applied on top
  /// of the parent {@code context}'s theme. It may be specified as a
  /// style resource containing a fully-populated theme, such as
  /// android.R.style\#Theme_Material_Dialog, to replace all
  /// attributes in the parent {@code context}'s theme including primary
  /// and accent colors.
  ///
  /// To preserve attributes such as primary and accent colors, the
  /// {@code themeResId} may instead be specified as an overlay theme such
  /// as android.R.style\#ThemeOverlay_Material_Dialog. This will
  /// override only the window attributes necessary to style the alert
  /// window as a dialog.
  ///
  /// Alternatively, the {@code themeResId} may be specified as {@code 0}
  /// to use the parent {@code context}'s resolved value for
  /// android.R.attr\#alertDialogTheme.
  ///@param context the parent context
  ///@param themeResId the resource ID of the theme against which to inflate
  ///                   this dialog, or {@code 0} to use the parent
  ///                   {@code context}'s default alert dialog theme
  AlertDialog_Builder.ctor1(content_.Context context, int themeResId)
      : super.fromRef(_ctor1(context.reference, themeResId).object);

  static final _getContext = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AlertDialog_Builder__getContext")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Context with the appropriate theme for dialogs created by this Builder.
  /// Applications should use this Context for obtaining LayoutInflaters for inflating views
  /// that will be used in the resulting dialogs, as it will cause views to be inflated with
  /// the correct theme.
  ///@return A Context for built Dialogs.
  content_.Context getContext() =>
      content_.Context.fromRef(_getContext(reference).object);

  static final _setTitle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("AlertDialog_Builder__setTitle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.AlertDialog.Builder setTitle(int titleId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the title using the given resource id.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setTitle(int titleId) =>
      AlertDialog_Builder.fromRef(_setTitle(reference, titleId).object);

  static final _setTitle1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog_Builder__setTitle1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setTitle(java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the title displayed in the Dialog.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setTitle1(jni.JniObject title) =>
      AlertDialog_Builder.fromRef(
          _setTitle1(reference, title.reference).object);

  static final _setCustomTitle = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "AlertDialog_Builder__setCustomTitle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setCustomTitle(android.view.View customTitleView)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the title using the custom view {@code customTitleView}.
  ///
  /// The methods \#setTitle(int) and \#setIcon(int) should
  /// be sufficient for most titles, but this is provided if the title
  /// needs more customization. Using this will replace the title and icon
  /// set via the other methods.
  ///
  /// <strong>Note:</strong> To ensure consistent styling, the custom view
  /// should be inflated or constructed using the alert dialog's themed
  /// context obtained via \#getContext().
  ///@param customTitleView the custom view to use as the title
  ///@return this Builder object to allow for chaining of calls to set
  ///         methods
  AlertDialog_Builder setCustomTitle(jni.JniObject customTitleView) =>
      AlertDialog_Builder.fromRef(
          _setCustomTitle(reference, customTitleView.reference).object);

  static final _setMessage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("AlertDialog_Builder__setMessage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.AlertDialog.Builder setMessage(int messageId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the message to display using the given resource id.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setMessage(int messageId) =>
      AlertDialog_Builder.fromRef(_setMessage(reference, messageId).object);

  static final _setMessage1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog_Builder__setMessage1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setMessage(java.lang.CharSequence message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the message to display.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setMessage1(jni.JniObject message) =>
      AlertDialog_Builder.fromRef(
          _setMessage1(reference, message.reference).object);

  static final _setIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("AlertDialog_Builder__setIcon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.AlertDialog.Builder setIcon(int iconId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the resource id of the Drawable to be used in the title.
  ///
  /// Takes precedence over values set using \#setIcon(Drawable).
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setIcon(int iconId) =>
      AlertDialog_Builder.fromRef(_setIcon(reference, iconId).object);

  static final _setIcon1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog_Builder__setIcon1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setIcon(android.graphics.drawable.Drawable icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the Drawable to be used in the title.
  ///
  /// <strong>Note:</strong> To ensure consistent styling, the drawable
  /// should be inflated or constructed using the alert dialog's themed
  /// context obtained via \#getContext().
  ///@return this Builder object to allow for chaining of calls to set
  ///         methods
  AlertDialog_Builder setIcon1(jni.JniObject icon) =>
      AlertDialog_Builder.fromRef(_setIcon1(reference, icon.reference).object);

  static final _setIconAttribute = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("AlertDialog_Builder__setIconAttribute")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.AlertDialog.Builder setIconAttribute(int attrId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set an icon as supplied by a theme attribute. e.g.
  /// android.R.attr\#alertDialogIcon.
  ///
  /// Takes precedence over values set using \#setIcon(int) or
  /// \#setIcon(Drawable).
  ///@param attrId ID of a theme attribute that points to a drawable resource.
  AlertDialog_Builder setIconAttribute(int attrId) =>
      AlertDialog_Builder.fromRef(_setIconAttribute(reference, attrId).object);

  static final _setPositiveButton = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "AlertDialog_Builder__setPositiveButton")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setPositiveButton(int textId, android.content.DialogInterface.OnClickListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a listener to be invoked when the positive button of the dialog is pressed.
  ///@param textId The resource id of the text to display in the positive button
  ///@param listener The DialogInterface.OnClickListener to use.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setPositiveButton(
          int textId, content_.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(
          _setPositiveButton(reference, textId, listener.reference).object);

  static final _setPositiveButton1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "AlertDialog_Builder__setPositiveButton1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setPositiveButton(java.lang.CharSequence text, android.content.DialogInterface.OnClickListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a listener to be invoked when the positive button of the dialog is pressed.
  ///@param text The text to display in the positive button
  ///@param listener The DialogInterface.OnClickListener to use.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setPositiveButton1(jni.JniObject text,
          content_.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(
          _setPositiveButton1(reference, text.reference, listener.reference)
              .object);

  static final _setNegativeButton = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "AlertDialog_Builder__setNegativeButton")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setNegativeButton(int textId, android.content.DialogInterface.OnClickListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a listener to be invoked when the negative button of the dialog is pressed.
  ///@param textId The resource id of the text to display in the negative button
  ///@param listener The DialogInterface.OnClickListener to use.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setNegativeButton(
          int textId, content_.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(
          _setNegativeButton(reference, textId, listener.reference).object);

  static final _setNegativeButton1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "AlertDialog_Builder__setNegativeButton1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setNegativeButton(java.lang.CharSequence text, android.content.DialogInterface.OnClickListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a listener to be invoked when the negative button of the dialog is pressed.
  ///@param text The text to display in the negative button
  ///@param listener The DialogInterface.OnClickListener to use.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setNegativeButton1(jni.JniObject text,
          content_.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(
          _setNegativeButton1(reference, text.reference, listener.reference)
              .object);

  static final _setNeutralButton = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "AlertDialog_Builder__setNeutralButton")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setNeutralButton(int textId, android.content.DialogInterface.OnClickListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a listener to be invoked when the neutral button of the dialog is pressed.
  ///@param textId The resource id of the text to display in the neutral button
  ///@param listener The DialogInterface.OnClickListener to use.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setNeutralButton(
          int textId, content_.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(
          _setNeutralButton(reference, textId, listener.reference).object);

  static final _setNeutralButton1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "AlertDialog_Builder__setNeutralButton1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setNeutralButton(java.lang.CharSequence text, android.content.DialogInterface.OnClickListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a listener to be invoked when the neutral button of the dialog is pressed.
  ///@param text The text to display in the neutral button
  ///@param listener The DialogInterface.OnClickListener to use.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setNeutralButton1(jni.JniObject text,
          content_.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(
          _setNeutralButton1(reference, text.reference, listener.reference)
              .object);

  static final _setCancelable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("AlertDialog_Builder__setCancelable")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.AlertDialog.Builder setCancelable(boolean cancelable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets whether the dialog is cancelable or not.  Default is true.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setCancelable(bool cancelable) =>
      AlertDialog_Builder.fromRef(
          _setCancelable(reference, cancelable ? 1 : 0).object);

  static final _setOnCancelListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "AlertDialog_Builder__setOnCancelListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setOnCancelListener(android.content.DialogInterface.OnCancelListener onCancelListener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the callback that will be called if the dialog is canceled.
  ///
  /// Even in a cancelable dialog, the dialog may be dismissed for reasons other than
  /// being canceled or one of the supplied choices being selected.
  /// If you are interested in listening for all cases where the dialog is dismissed
  /// and not just when it is canceled, see
  /// \#setOnDismissListener(android.content.DialogInterface.OnDismissListener) setOnDismissListener.
  ///
  ///@see \#setCancelable(boolean)
  ///@see \#setOnDismissListener(android.content.DialogInterface.OnDismissListener)
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setOnCancelListener(
          content_.DialogInterface_OnCancelListener onCancelListener) =>
      AlertDialog_Builder.fromRef(
          _setOnCancelListener(reference, onCancelListener.reference).object);

  static final _setOnDismissListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "AlertDialog_Builder__setOnDismissListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setOnDismissListener(android.content.DialogInterface.OnDismissListener onDismissListener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the callback that will be called when the dialog is dismissed for any reason.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setOnDismissListener(
          content_.DialogInterface_OnDismissListener onDismissListener) =>
      AlertDialog_Builder.fromRef(
          _setOnDismissListener(reference, onDismissListener.reference).object);

  static final _setOnKeyListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "AlertDialog_Builder__setOnKeyListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setOnKeyListener(android.content.DialogInterface.OnKeyListener onKeyListener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the callback that will be called if a key is dispatched to the dialog.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setOnKeyListener(
          content_.DialogInterface_OnKeyListener onKeyListener) =>
      AlertDialog_Builder.fromRef(
          _setOnKeyListener(reference, onKeyListener.reference).object);

  static final _setItems = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog_Builder__setItems")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setItems(int itemsId, android.content.DialogInterface.OnClickListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a list of items to be displayed in the dialog as the content, you will be notified of the
  /// selected item via the supplied listener. This should be an array type i.e. R.array.foo
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setItems(
          int itemsId, content_.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(
          _setItems(reference, itemsId, listener.reference).object);

  static final _setItems1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog_Builder__setItems1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setItems(java.lang.CharSequence[] items, android.content.DialogInterface.OnClickListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a list of items to be displayed in the dialog as the content, you will be notified of the
  /// selected item via the supplied listener.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setItems1(jni.JniObject items,
          content_.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(
          _setItems1(reference, items.reference, listener.reference).object);

  static final _setAdapter = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog_Builder__setAdapter")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setAdapter(android.widget.ListAdapter adapter, android.content.DialogInterface.OnClickListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a list of items, which are supplied by the given ListAdapter, to be
  /// displayed in the dialog as the content, you will be notified of the
  /// selected item via the supplied listener.
  ///@param adapter The ListAdapter to supply the list of items
  ///@param listener The listener that will be called when an item is clicked.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setAdapter(jni.JniObject adapter,
          content_.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(
          _setAdapter(reference, adapter.reference, listener.reference).object);

  static final _setCursor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog_Builder__setCursor")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setCursor(android.database.Cursor cursor, android.content.DialogInterface.OnClickListener listener, java.lang.String labelColumn)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a list of items, which are supplied by the given Cursor, to be
  /// displayed in the dialog as the content, you will be notified of the
  /// selected item via the supplied listener.
  ///@param cursor The Cursor to supply the list of items
  ///@param listener The listener that will be called when an item is clicked.
  ///@param labelColumn The column name on the cursor containing the string to display
  ///          in the label.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setCursor(
          jni.JniObject cursor,
          content_.DialogInterface_OnClickListener listener,
          jni.JniString labelColumn) =>
      AlertDialog_Builder.fromRef(_setCursor(reference, cursor.reference,
              listener.reference, labelColumn.reference)
          .object);

  static final _setMultiChoiceItems = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "AlertDialog_Builder__setMultiChoiceItems")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setMultiChoiceItems(int itemsId, boolean[] checkedItems, android.content.DialogInterface.OnMultiChoiceClickListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a list of items to be displayed in the dialog as the content,
  /// you will be notified of the selected item via the supplied listener.
  /// This should be an array type, e.g. R.array.foo. The list will have
  /// a check mark displayed to the right of the text for each checked
  /// item. Clicking on an item in the list will not dismiss the dialog.
  /// Clicking on a button will dismiss the dialog.
  ///@param itemsId the resource id of an array i.e. R.array.foo
  ///@param checkedItems specifies which items are checked. It should be null in which case no
  ///        items are checked. If non null it must be exactly the same length as the array of
  ///        items.
  ///@param listener notified when an item on the list is clicked. The dialog will not be
  ///        dismissed when an item is clicked. It will only be dismissed if clicked on a
  ///        button, if no buttons are supplied it's up to the user to dismiss the dialog.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setMultiChoiceItems(
          int itemsId,
          jni.JniObject checkedItems,
          content_.DialogInterface_OnMultiChoiceClickListener listener) =>
      AlertDialog_Builder.fromRef(_setMultiChoiceItems(
              reference, itemsId, checkedItems.reference, listener.reference)
          .object);

  static final _setMultiChoiceItems1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "AlertDialog_Builder__setMultiChoiceItems1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setMultiChoiceItems(java.lang.CharSequence[] items, boolean[] checkedItems, android.content.DialogInterface.OnMultiChoiceClickListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a list of items to be displayed in the dialog as the content,
  /// you will be notified of the selected item via the supplied listener.
  /// The list will have a check mark displayed to the right of the text
  /// for each checked item. Clicking on an item in the list will not
  /// dismiss the dialog. Clicking on a button will dismiss the dialog.
  ///@param items the text of the items to be displayed in the list.
  ///@param checkedItems specifies which items are checked. It should be null in which case no
  ///        items are checked. If non null it must be exactly the same length as the array of
  ///        items.
  ///@param listener notified when an item on the list is clicked. The dialog will not be
  ///        dismissed when an item is clicked. It will only be dismissed if clicked on a
  ///        button, if no buttons are supplied it's up to the user to dismiss the dialog.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setMultiChoiceItems1(
          jni.JniObject items,
          jni.JniObject checkedItems,
          content_.DialogInterface_OnMultiChoiceClickListener listener) =>
      AlertDialog_Builder.fromRef(_setMultiChoiceItems1(reference,
              items.reference, checkedItems.reference, listener.reference)
          .object);

  static final _setMultiChoiceItems2 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "AlertDialog_Builder__setMultiChoiceItems2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setMultiChoiceItems(android.database.Cursor cursor, java.lang.String isCheckedColumn, java.lang.String labelColumn, android.content.DialogInterface.OnMultiChoiceClickListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a list of items to be displayed in the dialog as the content,
  /// you will be notified of the selected item via the supplied listener.
  /// The list will have a check mark displayed to the right of the text
  /// for each checked item. Clicking on an item in the list will not
  /// dismiss the dialog. Clicking on a button will dismiss the dialog.
  ///@param cursor the cursor used to provide the items.
  ///@param isCheckedColumn specifies the column name on the cursor to use to determine
  ///        whether a checkbox is checked or not. It must return an integer value where 1
  ///        means checked and 0 means unchecked.
  ///@param labelColumn The column name on the cursor containing the string to display in the
  ///        label.
  ///@param listener notified when an item on the list is clicked. The dialog will not be
  ///        dismissed when an item is clicked. It will only be dismissed if clicked on a
  ///        button, if no buttons are supplied it's up to the user to dismiss the dialog.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setMultiChoiceItems2(
          jni.JniObject cursor,
          jni.JniString isCheckedColumn,
          jni.JniString labelColumn,
          content_.DialogInterface_OnMultiChoiceClickListener listener) =>
      AlertDialog_Builder.fromRef(_setMultiChoiceItems2(
              reference,
              cursor.reference,
              isCheckedColumn.reference,
              labelColumn.reference,
              listener.reference)
          .object);

  static final _setSingleChoiceItems = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "AlertDialog_Builder__setSingleChoiceItems")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setSingleChoiceItems(int itemsId, int checkedItem, android.content.DialogInterface.OnClickListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a list of items to be displayed in the dialog as the content, you will be notified of
  /// the selected item via the supplied listener. This should be an array type i.e.
  /// R.array.foo The list will have a check mark displayed to the right of the text for the
  /// checked item. Clicking on an item in the list will not dismiss the dialog. Clicking on a
  /// button will dismiss the dialog.
  ///@param itemsId the resource id of an array i.e. R.array.foo
  ///@param checkedItem specifies which item is checked. If -1 no items are checked.
  ///@param listener notified when an item on the list is clicked. The dialog will not be
  ///        dismissed when an item is clicked. It will only be dismissed if clicked on a
  ///        button, if no buttons are supplied it's up to the user to dismiss the dialog.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setSingleChoiceItems(int itemsId, int checkedItem,
          content_.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(_setSingleChoiceItems(
              reference, itemsId, checkedItem, listener.reference)
          .object);

  static final _setSingleChoiceItems1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "AlertDialog_Builder__setSingleChoiceItems1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setSingleChoiceItems(android.database.Cursor cursor, int checkedItem, java.lang.String labelColumn, android.content.DialogInterface.OnClickListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a list of items to be displayed in the dialog as the content, you will be notified of
  /// the selected item via the supplied listener. The list will have a check mark displayed to
  /// the right of the text for the checked item. Clicking on an item in the list will not
  /// dismiss the dialog. Clicking on a button will dismiss the dialog.
  ///@param cursor the cursor to retrieve the items from.
  ///@param checkedItem specifies which item is checked. If -1 no items are checked.
  ///@param labelColumn The column name on the cursor containing the string to display in the
  ///        label.
  ///@param listener notified when an item on the list is clicked. The dialog will not be
  ///        dismissed when an item is clicked. It will only be dismissed if clicked on a
  ///        button, if no buttons are supplied it's up to the user to dismiss the dialog.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setSingleChoiceItems1(
          jni.JniObject cursor,
          int checkedItem,
          jni.JniString labelColumn,
          content_.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(_setSingleChoiceItems1(
              reference,
              cursor.reference,
              checkedItem,
              labelColumn.reference,
              listener.reference)
          .object);

  static final _setSingleChoiceItems2 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "AlertDialog_Builder__setSingleChoiceItems2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setSingleChoiceItems(java.lang.CharSequence[] items, int checkedItem, android.content.DialogInterface.OnClickListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a list of items to be displayed in the dialog as the content, you will be notified of
  /// the selected item via the supplied listener. The list will have a check mark displayed to
  /// the right of the text for the checked item. Clicking on an item in the list will not
  /// dismiss the dialog. Clicking on a button will dismiss the dialog.
  ///@param items the items to be displayed.
  ///@param checkedItem specifies which item is checked. If -1 no items are checked.
  ///@param listener notified when an item on the list is clicked. The dialog will not be
  ///        dismissed when an item is clicked. It will only be dismissed if clicked on a
  ///        button, if no buttons are supplied it's up to the user to dismiss the dialog.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setSingleChoiceItems2(jni.JniObject items,
          int checkedItem, content_.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(_setSingleChoiceItems2(
              reference, items.reference, checkedItem, listener.reference)
          .object);

  static final _setSingleChoiceItems3 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "AlertDialog_Builder__setSingleChoiceItems3")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setSingleChoiceItems(android.widget.ListAdapter adapter, int checkedItem, android.content.DialogInterface.OnClickListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a list of items to be displayed in the dialog as the content, you will be notified of
  /// the selected item via the supplied listener. The list will have a check mark displayed to
  /// the right of the text for the checked item. Clicking on an item in the list will not
  /// dismiss the dialog. Clicking on a button will dismiss the dialog.
  ///@param adapter The ListAdapter to supply the list of items
  ///@param checkedItem specifies which item is checked. If -1 no items are checked.
  ///@param listener notified when an item on the list is clicked. The dialog will not be
  ///        dismissed when an item is clicked. It will only be dismissed if clicked on a
  ///        button, if no buttons are supplied it's up to the user to dismiss the dialog.
  ///@return This Builder object to allow for chaining of calls to set methods
  AlertDialog_Builder setSingleChoiceItems3(jni.JniObject adapter,
          int checkedItem, content_.DialogInterface_OnClickListener listener) =>
      AlertDialog_Builder.fromRef(_setSingleChoiceItems3(
              reference, adapter.reference, checkedItem, listener.reference)
          .object);

  static final _setOnItemSelectedListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "AlertDialog_Builder__setOnItemSelectedListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setOnItemSelectedListener(android.widget.AdapterView.OnItemSelectedListener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets a listener to be invoked when an item in the list is selected.
  ///@param listener the listener to be invoked
  ///@return this Builder object to allow for chaining of calls to set methods
  ///@see AdapterView\#setOnItemSelectedListener(android.widget.AdapterView.OnItemSelectedListener)
  AlertDialog_Builder setOnItemSelectedListener(jni.JniObject listener) =>
      AlertDialog_Builder.fromRef(
          _setOnItemSelectedListener(reference, listener.reference).object);

  static final _setView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("AlertDialog_Builder__setView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.AlertDialog.Builder setView(int layoutResId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a custom view resource to be the contents of the Dialog. The
  /// resource will be inflated, adding all top-level views to the screen.
  ///@param layoutResId Resource ID to be inflated.
  ///@return this Builder object to allow for chaining of calls to set
  ///         methods
  AlertDialog_Builder setView(int layoutResId) =>
      AlertDialog_Builder.fromRef(_setView(reference, layoutResId).object);

  static final _setView1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AlertDialog_Builder__setView1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog.Builder setView(android.view.View view)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets a custom view to be the contents of the alert dialog.
  ///
  /// When using a pre-Holo theme, if the supplied view is an instance of
  /// a ListView then the light background will be used.
  ///
  /// <strong>Note:</strong> To ensure consistent styling, the custom view
  /// should be inflated or constructed using the alert dialog's themed
  /// context obtained via \#getContext().
  ///@param view the view to use as the contents of the alert dialog
  ///@return this Builder object to allow for chaining of calls to set
  ///         methods
  AlertDialog_Builder setView1(jni.JniObject view) =>
      AlertDialog_Builder.fromRef(_setView1(reference, view.reference).object);

  static final _setInverseBackgroundForced = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "AlertDialog_Builder__setInverseBackgroundForced")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.AlertDialog.Builder setInverseBackgroundForced(boolean useInverseBackground)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the alert dialog to use the inverse background, regardless of
  /// what the contents is.
  ///@param useInverseBackground whether to use the inverse background
  ///@return this Builder object to allow for chaining of calls to set methods
  ///@deprecated This flag is only used for pre-Material themes. Instead,
  ///             specify the window background using on the alert dialog
  ///             theme.
  AlertDialog_Builder setInverseBackgroundForced(bool useInverseBackground) =>
      AlertDialog_Builder.fromRef(
          _setInverseBackgroundForced(reference, useInverseBackground ? 1 : 0)
              .object);

  static final _create = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AlertDialog_Builder__create")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog create()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an AlertDialog with the arguments supplied to this
  /// builder.
  ///
  /// Calling this method does not display the dialog. If no additional
  /// processing is needed, \#show() may be called instead to both
  /// create and display the dialog.
  AlertDialog create() => AlertDialog.fromRef(_create(reference).object);

  static final _show0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AlertDialog_Builder__show0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AlertDialog show()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates an AlertDialog with the arguments supplied to this
  /// builder and immediately displays the dialog.
  ///
  /// Calling this method is functionally identical to:
  /// <pre>
  ///     AlertDialog dialog = builder.create();
  ///     dialog.show();
  /// </pre>
  AlertDialog show0() => AlertDialog.fromRef(_show0(reference).object);
}

/// from: android.app.AliasActivity
///
/// Stub activity that launches another activity (and then finishes itself)
/// based on information in its component's manifest meta-data.  This is a
/// simple way to implement an alias-like mechanism.
///
/// To use this activity, you should include in the manifest for the associated
/// component an entry named "android.app.alias".  It is a reference to an XML
/// resource describing an intent that launches the real application.
class AliasActivity extends Activity {
  AliasActivity.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "AliasActivity__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  AliasActivity() : super.fromRef(_ctor().object);

  static final _onCreate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AliasActivity__onCreate")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onCreate(android.os.Bundle savedInstanceState)
  void onCreate(os_.Bundle savedInstanceState) =>
      _onCreate(reference, savedInstanceState.reference).check();
}

/// from: android.app.AppComponentFactory
///
/// Interface used to control the instantiation of manifest elements.
///@see \#instantiateApplication
///@see \#instantiateActivity
///@see \#instantiateService
///@see \#instantiateReceiver
///@see \#instantiateProvider
class AppComponentFactory extends jni.JniObject {
  AppComponentFactory.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "AppComponentFactory__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  AppComponentFactory() : super.fromRef(_ctor().object);

  static final _instantiateApplication = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "AppComponentFactory__instantiateApplication")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Application instantiateApplication(java.lang.ClassLoader cl, java.lang.String className)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Allows application to override the creation of the application object. This can be used to
  /// perform things such as dependency injection or class loader changes to these
  /// classes.
  ///
  /// This method is only intended to provide a hook for instantiation. It does not provide
  /// earlier access to the Application object. The returned object will not be initialized
  /// as a Context yet and should not be used to interact with other android APIs.
  ///@param cl The default classloader to use for instantiation.
  /// This value must never be {@code null}.
  ///@param className The class to be instantiated.
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  Application instantiateApplication(
          jni.JniObject cl, jni.JniString className) =>
      Application.fromRef(
          _instantiateApplication(reference, cl.reference, className.reference)
              .object);

  static final _instantiateActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "AppComponentFactory__instantiateActivity")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity instantiateActivity(java.lang.ClassLoader cl, java.lang.String className, android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Allows application to override the creation of activities. This can be used to
  /// perform things such as dependency injection or class loader changes to these
  /// classes.
  ///
  /// This method is only intended to provide a hook for instantiation. It does not provide
  /// earlier access to the Activity object. The returned object will not be initialized
  /// as a Context yet and should not be used to interact with other android APIs.
  ///@param cl The default classloader to use for instantiation.
  /// This value must never be {@code null}.
  ///@param className The class to be instantiated.
  /// This value must never be {@code null}.
  ///@param intent Intent creating the class.
  ///
  /// This value may be {@code null}.
  ///@return This value will never be {@code null}.
  Activity instantiateActivity(
          jni.JniObject cl, jni.JniString className, content_.Intent intent) =>
      Activity.fromRef(_instantiateActivity(
              reference, cl.reference, className.reference, intent.reference)
          .object);

  static final _instantiateReceiver = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "AppComponentFactory__instantiateReceiver")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.BroadcastReceiver instantiateReceiver(java.lang.ClassLoader cl, java.lang.String className, android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Allows application to override the creation of receivers. This can be used to
  /// perform things such as dependency injection or class loader changes to these
  /// classes.
  ///@param cl The default classloader to use for instantiation.
  /// This value must never be {@code null}.
  ///@param className The class to be instantiated.
  /// This value must never be {@code null}.
  ///@param intent Intent creating the class.
  ///
  /// This value may be {@code null}.
  ///@return This value will never be {@code null}.
  content_.BroadcastReceiver instantiateReceiver(
          jni.JniObject cl, jni.JniString className, content_.Intent intent) =>
      content_.BroadcastReceiver.fromRef(_instantiateReceiver(
              reference, cl.reference, className.reference, intent.reference)
          .object);

  static final _instantiateService = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "AppComponentFactory__instantiateService")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Service instantiateService(java.lang.ClassLoader cl, java.lang.String className, android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Allows application to override the creation of services. This can be used to
  /// perform things such as dependency injection or class loader changes to these
  /// classes.
  ///
  /// This method is only intended to provide a hook for instantiation. It does not provide
  /// earlier access to the Service object. The returned object will not be initialized
  /// as a Context yet and should not be used to interact with other android APIs.
  ///@param cl The default classloader to use for instantiation.
  /// This value must never be {@code null}.
  ///@param className The class to be instantiated.
  /// This value must never be {@code null}.
  ///@param intent Intent creating the class.
  ///
  /// This value may be {@code null}.
  ///@return This value will never be {@code null}.
  Service instantiateService(
          jni.JniObject cl, jni.JniString className, content_.Intent intent) =>
      Service.fromRef(_instantiateService(
              reference, cl.reference, className.reference, intent.reference)
          .object);

  static final _instantiateProvider = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "AppComponentFactory__instantiateProvider")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ContentProvider instantiateProvider(java.lang.ClassLoader cl, java.lang.String className)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Allows application to override the creation of providers. This can be used to
  /// perform things such as dependency injection or class loader changes to these
  /// classes.
  ///
  /// This method is only intended to provide a hook for instantiation. It does not provide
  /// earlier access to the ContentProvider object. The returned object will not be initialized
  /// with a Context yet and should not be used to interact with other android APIs.
  ///@param cl The default classloader to use for instantiation.
  /// This value must never be {@code null}.
  ///@param className The class to be instantiated.
  ///
  /// This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  content_.ContentProvider instantiateProvider(
          jni.JniObject cl, jni.JniString className) =>
      content_.ContentProvider.fromRef(
          _instantiateProvider(reference, cl.reference, className.reference)
              .object);
}

/// from: android.app.AppOpsManager
///
/// API for interacting with "application operation" tracking.
///
/// This API is not generally intended for third party application developers; most
/// features are only available to system applications.
class AppOpsManager extends jni.JniObject {
  AppOpsManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int MODE_ALLOWED
  ///
  /// Result from \#checkOp, \#noteOp, \#startOp: the given caller is
  /// allowed to perform the given operation.
  static const MODE_ALLOWED = 0;

  /// from: static public final int MODE_DEFAULT
  ///
  /// Result from \#checkOp, \#noteOp, \#startOp: the given caller should
  /// use its default security check.  This mode is not normally used; it should only be used
  /// with appop permissions, and callers must explicitly check for it and deal with it.
  static const MODE_DEFAULT = 3;

  /// from: static public final int MODE_ERRORED
  ///
  /// Result from \#checkOpNoThrow, \#noteOpNoThrow, \#startOpNoThrow: the
  /// given caller is not allowed to perform the given operation, and this attempt should
  /// cause it to have a fatal error, typically a SecurityException.
  static const MODE_ERRORED = 2;

  /// from: static public final int MODE_IGNORED
  ///
  /// Result from \#checkOp, \#noteOp, \#startOp: the given caller is
  /// not allowed to perform the given operation, and this attempt should
  /// _silently fail_ (it should not cause the app to crash).
  static const MODE_IGNORED = 1;

  /// from: static public final java.lang.String OPSTR_ADD_VOICEMAIL
  ///
  /// Required to access phone state related information.
  static const OPSTR_ADD_VOICEMAIL = "android:add_voicemail";

  /// from: static public final java.lang.String OPSTR_ANSWER_PHONE_CALLS
  ///
  /// Answer incoming phone calls
  static const OPSTR_ANSWER_PHONE_CALLS = "android:answer_phone_calls";

  /// from: static public final java.lang.String OPSTR_BODY_SENSORS
  ///
  /// Access to body sensors such as heart rate, etc.
  static const OPSTR_BODY_SENSORS = "android:body_sensors";

  /// from: static public final java.lang.String OPSTR_CALL_PHONE
  ///
  /// Allows an application to initiate a phone call.
  static const OPSTR_CALL_PHONE = "android:call_phone";

  /// from: static public final java.lang.String OPSTR_CAMERA
  ///
  /// Required to be able to access the camera device.
  static const OPSTR_CAMERA = "android:camera";

  /// from: static public final java.lang.String OPSTR_COARSE_LOCATION
  ///
  /// Access to coarse location information.
  static const OPSTR_COARSE_LOCATION = "android:coarse_location";

  /// from: static public final java.lang.String OPSTR_FINE_LOCATION
  ///
  /// Access to fine location information.
  static const OPSTR_FINE_LOCATION = "android:fine_location";

  /// from: static public final java.lang.String OPSTR_GET_USAGE_STATS
  ///
  /// Access to android.app.usage.UsageStatsManager.
  static const OPSTR_GET_USAGE_STATS = "android:get_usage_stats";

  /// from: static public final java.lang.String OPSTR_MOCK_LOCATION
  ///
  /// Inject mock location into the system.
  static const OPSTR_MOCK_LOCATION = "android:mock_location";

  /// from: static public final java.lang.String OPSTR_MONITOR_HIGH_POWER_LOCATION
  ///
  /// Continually monitoring location data with a relatively high power request.
  static const OPSTR_MONITOR_HIGH_POWER_LOCATION =
      "android:monitor_location_high_power";

  /// from: static public final java.lang.String OPSTR_MONITOR_LOCATION
  ///
  /// Continually monitoring location data.
  static const OPSTR_MONITOR_LOCATION = "android:monitor_location";

  /// from: static public final java.lang.String OPSTR_PICTURE_IN_PICTURE
  ///
  /// Access to picture-in-picture.
  static const OPSTR_PICTURE_IN_PICTURE = "android:picture_in_picture";

  /// from: static public final java.lang.String OPSTR_PROCESS_OUTGOING_CALLS
  ///
  /// Access APIs for diverting outgoing calls
  static const OPSTR_PROCESS_OUTGOING_CALLS = "android:process_outgoing_calls";

  /// from: static public final java.lang.String OPSTR_READ_CALENDAR
  ///
  /// Allows an application to read the user's calendar data.
  static const OPSTR_READ_CALENDAR = "android:read_calendar";

  /// from: static public final java.lang.String OPSTR_READ_CALL_LOG
  ///
  /// Allows an application to read the user's call log.
  static const OPSTR_READ_CALL_LOG = "android:read_call_log";

  /// from: static public final java.lang.String OPSTR_READ_CELL_BROADCASTS
  ///
  /// Read previously received cell broadcast messages.
  static const OPSTR_READ_CELL_BROADCASTS = "android:read_cell_broadcasts";

  /// from: static public final java.lang.String OPSTR_READ_CONTACTS
  ///
  /// Allows an application to read the user's contacts data.
  static const OPSTR_READ_CONTACTS = "android:read_contacts";

  /// from: static public final java.lang.String OPSTR_READ_EXTERNAL_STORAGE
  ///
  /// Read external storage.
  static const OPSTR_READ_EXTERNAL_STORAGE = "android:read_external_storage";

  /// from: static public final java.lang.String OPSTR_READ_PHONE_NUMBERS
  static const OPSTR_READ_PHONE_NUMBERS = "android:read_phone_numbers";

  /// from: static public final java.lang.String OPSTR_READ_PHONE_STATE
  ///
  /// Required to access phone state related information.
  static const OPSTR_READ_PHONE_STATE = "android:read_phone_state";

  /// from: static public final java.lang.String OPSTR_READ_SMS
  ///
  /// Allows an application to read SMS messages.
  static const OPSTR_READ_SMS = "android:read_sms";

  /// from: static public final java.lang.String OPSTR_RECEIVE_MMS
  ///
  /// Allows an application to receive MMS messages.
  static const OPSTR_RECEIVE_MMS = "android:receive_mms";

  /// from: static public final java.lang.String OPSTR_RECEIVE_SMS
  ///
  /// Allows an application to receive SMS messages.
  static const OPSTR_RECEIVE_SMS = "android:receive_sms";

  /// from: static public final java.lang.String OPSTR_RECEIVE_WAP_PUSH
  ///
  /// Allows an application to receive WAP push messages.
  static const OPSTR_RECEIVE_WAP_PUSH = "android:receive_wap_push";

  /// from: static public final java.lang.String OPSTR_RECORD_AUDIO
  ///
  /// Required to be able to access the microphone device.
  static const OPSTR_RECORD_AUDIO = "android:record_audio";

  /// from: static public final java.lang.String OPSTR_SEND_SMS
  ///
  /// Allows an application to send SMS messages.
  static const OPSTR_SEND_SMS = "android:send_sms";

  /// from: static public final java.lang.String OPSTR_SYSTEM_ALERT_WINDOW
  ///
  /// Required to draw on top of other apps.
  static const OPSTR_SYSTEM_ALERT_WINDOW = "android:system_alert_window";

  /// from: static public final java.lang.String OPSTR_USE_FINGERPRINT
  ///
  /// Use the fingerprint API.
  static const OPSTR_USE_FINGERPRINT = "android:use_fingerprint";

  /// from: static public final java.lang.String OPSTR_USE_SIP
  ///
  /// Access APIs for SIP calling over VOIP or WiFi
  static const OPSTR_USE_SIP = "android:use_sip";

  /// from: static public final java.lang.String OPSTR_WRITE_CALENDAR
  ///
  /// Allows an application to write to the user's calendar data.
  static const OPSTR_WRITE_CALENDAR = "android:write_calendar";

  /// from: static public final java.lang.String OPSTR_WRITE_CALL_LOG
  ///
  /// Allows an application to write to the user's call log.
  static const OPSTR_WRITE_CALL_LOG = "android:write_call_log";

  /// from: static public final java.lang.String OPSTR_WRITE_CONTACTS
  ///
  /// Allows an application to write to the user's contacts data.
  static const OPSTR_WRITE_CONTACTS = "android:write_contacts";

  /// from: static public final java.lang.String OPSTR_WRITE_EXTERNAL_STORAGE
  ///
  /// Write external storage.
  static const OPSTR_WRITE_EXTERNAL_STORAGE = "android:write_external_storage";

  /// from: static public final java.lang.String OPSTR_WRITE_SETTINGS
  ///
  /// Required to write/modify/update system settingss.
  static const OPSTR_WRITE_SETTINGS = "android:write_settings";

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "AppOpsManager__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  AppOpsManager() : super.fromRef(_ctor().object);

  static final _permissionToOp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AppOpsManager__permissionToOp")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String permissionToOp(java.lang.String permission)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the app op name associated with a given permission.
  /// The app op name is one of the public constants defined
  /// in this class such as \#OPSTR_COARSE_LOCATION.
  /// This API is intended to be used for mapping runtime
  /// permissions to the corresponding app op.
  ///@param permission The permission.
  ///@return The app op associated with the permission or null.
  static jni.JniString permissionToOp(jni.JniString permission) =>
      jni.JniString.fromRef(_permissionToOp(permission.reference).object);

  static final _startWatchingMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AppOpsManager__startWatchingMode")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startWatchingMode(java.lang.String op, java.lang.String packageName, android.app.AppOpsManager.OnOpChangedListener callback)
  ///
  /// Monitor for changes to the operating mode for the given op in the given app package.
  /// You can watch op changes only for your UID.
  ///@param op The operation to monitor, one of OPSTR_*.
  ///@param packageName The name of the application to monitor.
  ///@param callback Where to report changes.
  void startWatchingMode(jni.JniString op, jni.JniString packageName,
          AppOpsManager_OnOpChangedListener callback) =>
      _startWatchingMode(reference, op.reference, packageName.reference,
              callback.reference)
          .check();

  static final _stopWatchingMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AppOpsManager__stopWatchingMode")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void stopWatchingMode(android.app.AppOpsManager.OnOpChangedListener callback)
  ///
  /// Stop monitoring that was previously started with \#startWatchingMode.  All
  /// monitoring associated with this callback will be removed.
  void stopWatchingMode(AppOpsManager_OnOpChangedListener callback) =>
      _stopWatchingMode(reference, callback.reference).check();

  static final _checkOp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("AppOpsManager__checkOp")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public int checkOp(java.lang.String op, int uid, java.lang.String packageName)
  ///
  /// Do a quick check for whether an application might be able to perform an operation.
  /// This is _not_ a security check; you must use \#noteOp(String, int, String)
  /// or \#startOp(String, int, String) for your actual security checks, which also
  /// ensure that the given uid and package name are consistent.  This function can just be
  /// used for a quick check to see if an operation has been disabled for the application,
  /// as an early reject of some work.  This does not modify the time stamp or other data
  /// about the operation.
  ///
  /// Important things this will not do (which you need to ultimate use
  /// \#noteOp(String, int, String) or \#startOp(String, int, String) to cover):
  ///
  /// <ul>
  ///     <li>Verifying the uid and package are consistent, so callers can't spoof
  ///     their identity.</li>
  ///     <li>Taking into account the current foreground/background state of the
  ///     app; apps whose mode varies by this state will always be reported
  ///     as \#MODE_ALLOWED.</li>
  /// </ul>
  ///@param op The operation to check.  One of the OPSTR_* constants.
  ///@param uid The user id of the application attempting to perform the operation.
  ///@param packageName The name of the application attempting to perform the operation.
  ///@return Returns \#MODE_ALLOWED if the operation is allowed, or
  /// \#MODE_IGNORED if it is not allowed and should be silently ignored (without
  /// causing the app to crash).
  ///@throws SecurityException If the app has been configured to crash on this op.
  int checkOp(jni.JniString op, int uid, jni.JniString packageName) =>
      _checkOp(reference, op.reference, uid, packageName.reference).integer;

  static final _checkOpNoThrow = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("AppOpsManager__checkOpNoThrow")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public int checkOpNoThrow(java.lang.String op, int uid, java.lang.String packageName)
  ///
  /// Like \#checkOp but instead of throwing a SecurityException it
  /// returns \#MODE_ERRORED.
  int checkOpNoThrow(jni.JniString op, int uid, jni.JniString packageName) =>
      _checkOpNoThrow(reference, op.reference, uid, packageName.reference)
          .integer;

  static final _noteOp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("AppOpsManager__noteOp")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public int noteOp(java.lang.String op, int uid, java.lang.String packageName)
  ///
  /// Make note of an application performing an operation.  Note that you must pass
  /// in both the uid and name of the application to be checked; this function will verify
  /// that these two match, and if not, return \#MODE_IGNORED.  If this call
  /// succeeds, the last execution time of the operation for this app will be updated to
  /// the current time.
  ///@param op The operation to note.  One of the OPSTR_* constants.
  ///@param uid The user id of the application attempting to perform the operation.
  ///@param packageName The name of the application attempting to perform the operation.
  ///@return Returns \#MODE_ALLOWED if the operation is allowed, or
  /// \#MODE_IGNORED if it is not allowed and should be silently ignored (without
  /// causing the app to crash).
  ///@throws SecurityException If the app has been configured to crash on this op.
  int noteOp(jni.JniString op, int uid, jni.JniString packageName) =>
      _noteOp(reference, op.reference, uid, packageName.reference).integer;

  static final _noteOpNoThrow = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("AppOpsManager__noteOpNoThrow")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public int noteOpNoThrow(java.lang.String op, int uid, java.lang.String packageName)
  ///
  /// Like \#noteOp but instead of throwing a SecurityException it
  /// returns \#MODE_ERRORED.
  int noteOpNoThrow(jni.JniString op, int uid, jni.JniString packageName) =>
      _noteOpNoThrow(reference, op.reference, uid, packageName.reference)
          .integer;

  static final _noteProxyOp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AppOpsManager__noteProxyOp")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int noteProxyOp(java.lang.String op, java.lang.String proxiedPackageName)
  ///
  /// Make note of an application performing an operation on behalf of another
  /// application when handling an IPC. Note that you must pass the package name
  /// of the application that is being proxied while its UID will be inferred from
  /// the IPC state; this function will verify that the calling uid and proxied
  /// package name match, and if not, return \#MODE_IGNORED. If this call
  /// succeeds, the last execution time of the operation for the proxied app and
  /// your app will be updated to the current time.
  ///@param op The operation to note.  One of the OPSTR_* constants.
  ///@param proxiedPackageName The name of the application calling into the proxy application.
  ///@return Returns \#MODE_ALLOWED if the operation is allowed, or
  /// \#MODE_IGNORED if it is not allowed and should be silently ignored (without
  /// causing the app to crash).
  ///@throws SecurityException If the app has been configured to crash on this op.
  int noteProxyOp(jni.JniString op, jni.JniString proxiedPackageName) =>
      _noteProxyOp(reference, op.reference, proxiedPackageName.reference)
          .integer;

  static final _noteProxyOpNoThrow = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AppOpsManager__noteProxyOpNoThrow")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int noteProxyOpNoThrow(java.lang.String op, java.lang.String proxiedPackageName)
  ///
  /// Like \#noteProxyOp(String, String) but instead
  /// of throwing a SecurityException it returns \#MODE_ERRORED.
  int noteProxyOpNoThrow(jni.JniString op, jni.JniString proxiedPackageName) =>
      _noteProxyOpNoThrow(reference, op.reference, proxiedPackageName.reference)
          .integer;

  static final _startOp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("AppOpsManager__startOp")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public int startOp(java.lang.String op, int uid, java.lang.String packageName)
  ///
  /// Report that an application has started executing a long-running operation.  Note that you
  /// must pass in both the uid and name of the application to be checked; this function will
  /// verify that these two match, and if not, return \#MODE_IGNORED.  If this call
  /// succeeds, the last execution time of the operation for this app will be updated to
  /// the current time and the operation will be marked as "running".  In this case you must
  /// later call \#finishOp(String, int, String) to report when the application is no
  /// longer performing the operation.
  ///@param op The operation to start.  One of the OPSTR_* constants.
  ///@param uid The user id of the application attempting to perform the operation.
  ///@param packageName The name of the application attempting to perform the operation.
  ///@return Returns \#MODE_ALLOWED if the operation is allowed, or
  /// \#MODE_IGNORED if it is not allowed and should be silently ignored (without
  /// causing the app to crash).
  ///@throws SecurityException If the app has been configured to crash on this op.
  int startOp(jni.JniString op, int uid, jni.JniString packageName) =>
      _startOp(reference, op.reference, uid, packageName.reference).integer;

  static final _startOpNoThrow = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("AppOpsManager__startOpNoThrow")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public int startOpNoThrow(java.lang.String op, int uid, java.lang.String packageName)
  ///
  /// Like \#startOp but instead of throwing a SecurityException it
  /// returns \#MODE_ERRORED.
  int startOpNoThrow(jni.JniString op, int uid, jni.JniString packageName) =>
      _startOpNoThrow(reference, op.reference, uid, packageName.reference)
          .integer;

  static final _finishOp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("AppOpsManager__finishOp")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public void finishOp(java.lang.String op, int uid, java.lang.String packageName)
  ///
  /// Report that an application is no longer performing an operation that had previously
  /// been started with \#startOp(String, int, String).  There is no validation of input
  /// or result; the parameters supplied here must be the exact same ones previously passed
  /// in when starting the operation.
  void finishOp(jni.JniString op, int uid, jni.JniString packageName) =>
      _finishOp(reference, op.reference, uid, packageName.reference).check();

  static final _checkPackage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("AppOpsManager__checkPackage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void checkPackage(int uid, java.lang.String packageName)
  ///
  /// Do a quick check to validate if a package name belongs to a UID.
  ///@throws SecurityException if the package name doesn't belong to the given
  ///             UID, or if ownership cannot be verified.
  void checkPackage(int uid, jni.JniString packageName) =>
      _checkPackage(reference, uid, packageName.reference).check();
}

/// from: android.app.AppOpsManager$OnOpChangedListener
///
/// Callback for notification of changes to operation state.
class AppOpsManager_OnOpChangedListener extends jni.JniObject {
  AppOpsManager_OnOpChangedListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onOpChanged = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "AppOpsManager_OnOpChangedListener__onOpChanged")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onOpChanged(java.lang.String op, java.lang.String packageName)
  void onOpChanged(jni.JniString op, jni.JniString packageName) =>
      _onOpChanged(reference, op.reference, packageName.reference).check();
}

/// from: android.app.Application
///
/// Base class for maintaining global application state. You can provide your own
/// implementation by creating a subclass and specifying the fully-qualified name
/// of this subclass as the <code>"android:name"</code> attribute in your
/// AndroidManifest.xml's <code>&lt;application&gt;</code> tag. The Application
/// class, or your subclass of the Application class, is instantiated before any
/// other class when the process for your application/package is created.
///
/// <p class="note"><strong>Note: </strong>There is normally no need to subclass
/// Application.  In most situations, static singletons can provide the same
/// functionality in a more modular way.  If your singleton needs a global
/// context (for example to register broadcast receivers), include
/// android.content.Context\#getApplicationContext() Context.getApplicationContext()
/// as a android.content.Context argument when invoking your singleton's
/// <code>getInstance()</code> method.
///
///
class Application extends content_.ContextWrapper {
  Application.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor2 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Application__ctor2")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  Application.ctor2() : super.fromRef(_ctor2().object);

  static final _onCreate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Application__onCreate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreate()
  ///
  /// Called when the application is starting, before any activity, service,
  /// or receiver objects (excluding content providers) have been created.
  ///
  /// Implementations should be as quick as possible (for example using
  /// lazy initialization of state) since the time spent in this function
  /// directly impacts the performance of starting the first activity,
  /// service, or receiver in a process.
  ///
  ///
  /// If you override this method, be sure to call {@code super.onCreate()}.
  ///
  ///
  /// <p class="note">Be aware that direct boot may also affect callback order on
  /// Android android.os.Build.VERSION_CODES\#N and later devices.
  /// Until the user unlocks the device, only direct boot aware components are
  /// allowed to run. You should consider that all direct boot unaware
  /// components, including such android.content.ContentProvider, are
  /// disabled until user unlock happens, especially when component callback
  /// order matters.
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onCreate() => _onCreate(reference).check();

  static final _onTerminate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Application__onTerminate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onTerminate()
  ///
  /// This method is for use in emulated process environments.  It will
  /// never be called on a production Android device, where processes are
  /// removed by simply killing them; no user code (including this callback)
  /// is executed when doing so.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onTerminate() => _onTerminate(reference).check();

  static final _onConfigurationChanged = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Application__onConfigurationChanged")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onConfigurationChanged(android.content.res.Configuration newConfig)
  ///
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  void onConfigurationChanged(res_.Configuration newConfig) =>
      _onConfigurationChanged(reference, newConfig.reference).check();

  static final _onLowMemory = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Application__onLowMemory")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onLowMemory()
  ///
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  void onLowMemory() => _onLowMemory(reference).check();

  static final _onTrimMemory = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Application__onTrimMemory")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onTrimMemory(int level)
  ///
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  void onTrimMemory(int level) => _onTrimMemory(reference, level).check();

  static final _registerComponentCallbacks1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Application__registerComponentCallbacks1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerComponentCallbacks(android.content.ComponentCallbacks callback)
  void registerComponentCallbacks1(content_.ComponentCallbacks callback) =>
      _registerComponentCallbacks1(reference, callback.reference).check();

  static final _unregisterComponentCallbacks1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Application__unregisterComponentCallbacks1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterComponentCallbacks(android.content.ComponentCallbacks callback)
  void unregisterComponentCallbacks1(content_.ComponentCallbacks callback) =>
      _unregisterComponentCallbacks1(reference, callback.reference).check();

  static final _registerActivityLifecycleCallbacks = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Application__registerActivityLifecycleCallbacks")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerActivityLifecycleCallbacks(android.app.Application.ActivityLifecycleCallbacks callback)
  void registerActivityLifecycleCallbacks(
          Application_ActivityLifecycleCallbacks callback) =>
      _registerActivityLifecycleCallbacks(reference, callback.reference)
          .check();

  static final _unregisterActivityLifecycleCallbacks = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Application__unregisterActivityLifecycleCallbacks")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterActivityLifecycleCallbacks(android.app.Application.ActivityLifecycleCallbacks callback)
  void unregisterActivityLifecycleCallbacks(
          Application_ActivityLifecycleCallbacks callback) =>
      _unregisterActivityLifecycleCallbacks(reference, callback.reference)
          .check();

  static final _registerOnProvideAssistDataListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Application__registerOnProvideAssistDataListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerOnProvideAssistDataListener(android.app.Application.OnProvideAssistDataListener callback)
  void registerOnProvideAssistDataListener(
          Application_OnProvideAssistDataListener callback) =>
      _registerOnProvideAssistDataListener(reference, callback.reference)
          .check();

  static final _unregisterOnProvideAssistDataListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Application__unregisterOnProvideAssistDataListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterOnProvideAssistDataListener(android.app.Application.OnProvideAssistDataListener callback)
  void unregisterOnProvideAssistDataListener(
          Application_OnProvideAssistDataListener callback) =>
      _unregisterOnProvideAssistDataListener(reference, callback.reference)
          .check();

  static final _getProcessName =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Application__getProcessName")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.lang.String getProcessName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the name of the current process. A package's default process name
  /// is the same as its package name. Non-default processes will look like
  /// "$PACKAGE_NAME:$NAME", where $NAME corresponds to an android:process
  /// attribute within AndroidManifest.xml.
  static jni.JniString getProcessName() =>
      jni.JniString.fromRef(_getProcessName().object);
}

/// from: android.app.Application$OnProvideAssistDataListener
///
/// Callback interface for use with Application\#registerOnProvideAssistDataListener
/// and Application\#unregisterOnProvideAssistDataListener.
class Application_OnProvideAssistDataListener extends jni.JniObject {
  Application_OnProvideAssistDataListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onProvideAssistData = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Application_OnProvideAssistDataListener__onProvideAssistData")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onProvideAssistData(android.app.Activity activity, android.os.Bundle data)
  ///
  /// This is called when the user is requesting an assist, to build a full
  /// Intent\#ACTION_ASSIST Intent with all of the context of the current
  /// application.  You can override this method to place into the bundle anything
  /// you would like to appear in the Intent\#EXTRA_ASSIST_CONTEXT part
  /// of the assist Intent.
  void onProvideAssistData(Activity activity, os_.Bundle data) =>
      _onProvideAssistData(reference, activity.reference, data.reference)
          .check();
}

/// from: android.app.Application$ActivityLifecycleCallbacks
class Application_ActivityLifecycleCallbacks extends jni.JniObject {
  Application_ActivityLifecycleCallbacks.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onActivityCreated = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Application_ActivityLifecycleCallbacks__onActivityCreated")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onActivityCreated(android.app.Activity activity, android.os.Bundle savedInstanceState)
  void onActivityCreated(Activity activity, os_.Bundle savedInstanceState) =>
      _onActivityCreated(
              reference, activity.reference, savedInstanceState.reference)
          .check();

  static final _onActivityStarted = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Application_ActivityLifecycleCallbacks__onActivityStarted")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onActivityStarted(android.app.Activity activity)
  void onActivityStarted(Activity activity) =>
      _onActivityStarted(reference, activity.reference).check();

  static final _onActivityResumed = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Application_ActivityLifecycleCallbacks__onActivityResumed")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onActivityResumed(android.app.Activity activity)
  void onActivityResumed(Activity activity) =>
      _onActivityResumed(reference, activity.reference).check();

  static final _onActivityPaused = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Application_ActivityLifecycleCallbacks__onActivityPaused")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onActivityPaused(android.app.Activity activity)
  void onActivityPaused(Activity activity) =>
      _onActivityPaused(reference, activity.reference).check();

  static final _onActivityStopped = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Application_ActivityLifecycleCallbacks__onActivityStopped")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onActivityStopped(android.app.Activity activity)
  void onActivityStopped(Activity activity) =>
      _onActivityStopped(reference, activity.reference).check();

  static final _onActivitySaveInstanceState = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Application_ActivityLifecycleCallbacks__onActivitySaveInstanceState")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onActivitySaveInstanceState(android.app.Activity activity, android.os.Bundle outState)
  void onActivitySaveInstanceState(Activity activity, os_.Bundle outState) =>
      _onActivitySaveInstanceState(
              reference, activity.reference, outState.reference)
          .check();

  static final _onActivityDestroyed = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Application_ActivityLifecycleCallbacks__onActivityDestroyed")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onActivityDestroyed(android.app.Activity activity)
  void onActivityDestroyed(Activity activity) =>
      _onActivityDestroyed(reference, activity.reference).check();
}

/// from: android.app.ApplicationErrorReport
///
/// Describes an application error.
///
/// A report has a type, which is one of
/// <ul>
/// <li> \#TYPE_NONE uninitialized instance of ApplicationErrorReport.
/// <li> \#TYPE_CRASH application crash. Information about the crash
/// is stored in \#crashInfo.
/// <li> \#TYPE_ANR application not responding. Information about the
/// ANR is stored in \#anrInfo.
/// <li> \#TYPE_BATTERY user reported application is using too much
/// battery. Information about the battery use is stored in \#batteryInfo.
/// <li> \#TYPE_RUNNING_SERVICE user reported application is leaving an
/// unneeded serive running. Information about the battery use is stored in
/// \#runningServiceInfo.
/// </ul>
class ApplicationErrorReport extends jni.JniObject {
  ApplicationErrorReport.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_ApplicationErrorReport__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.ApplicationErrorReport> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  /// from: static public final int TYPE_ANR
  ///
  /// An error report about an application that's not responding.
  static const TYPE_ANR = 2;

  /// from: static public final int TYPE_BATTERY
  ///
  /// An error report about an application that's consuming too much battery.
  static const TYPE_BATTERY = 3;

  /// from: static public final int TYPE_CRASH
  ///
  /// An error report about an application crash.
  static const TYPE_CRASH = 1;

  /// from: static public final int TYPE_NONE
  ///
  /// Uninitialized error report.
  static const TYPE_NONE = 0;

  /// from: static public final int TYPE_RUNNING_SERVICE
  ///
  /// A report from a user to a developer about a running service that the
  /// user doesn't think should be running.
  static const TYPE_RUNNING_SERVICE = 5;

  static final _get_anrInfo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport__anrInfo")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.app.ApplicationErrorReport.AnrInfo anrInfo
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this report is of type \#TYPE_ANR, contains an instance
  /// of AnrInfo describing the ANR; otherwise null.
  ApplicationErrorReport_AnrInfo get anrInfo =>
      ApplicationErrorReport_AnrInfo.fromRef(_get_anrInfo(reference).object);
  static final _set_anrInfo = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport__anrInfo")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.ApplicationErrorReport.AnrInfo anrInfo
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this report is of type \#TYPE_ANR, contains an instance
  /// of AnrInfo describing the ANR; otherwise null.
  set anrInfo(ApplicationErrorReport_AnrInfo value) =>
      _set_anrInfo(reference, value.reference);

  static final _get_batteryInfo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport__batteryInfo")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.app.ApplicationErrorReport.BatteryInfo batteryInfo
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this report is of type \#TYPE_BATTERY, contains an instance
  /// of BatteryInfo; otherwise null.
  ApplicationErrorReport_BatteryInfo get batteryInfo =>
      ApplicationErrorReport_BatteryInfo.fromRef(
          _get_batteryInfo(reference).object);
  static final _set_batteryInfo = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport__batteryInfo")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.ApplicationErrorReport.BatteryInfo batteryInfo
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this report is of type \#TYPE_BATTERY, contains an instance
  /// of BatteryInfo; otherwise null.
  set batteryInfo(ApplicationErrorReport_BatteryInfo value) =>
      _set_batteryInfo(reference, value.reference);

  static final _get_crashInfo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport__crashInfo")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.app.ApplicationErrorReport.CrashInfo crashInfo
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this report is of type \#TYPE_CRASH, contains an instance
  /// of CrashInfo describing the crash; otherwise null.
  ApplicationErrorReport_CrashInfo get crashInfo =>
      ApplicationErrorReport_CrashInfo.fromRef(
          _get_crashInfo(reference).object);
  static final _set_crashInfo = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport__crashInfo")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.ApplicationErrorReport.CrashInfo crashInfo
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this report is of type \#TYPE_CRASH, contains an instance
  /// of CrashInfo describing the crash; otherwise null.
  set crashInfo(ApplicationErrorReport_CrashInfo value) =>
      _set_crashInfo(reference, value.reference);

  static final _get_installerPackageName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport__installerPackageName")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String installerPackageName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Package name of the application which installed the application this
  /// report pertains to.
  /// This identifies which market the application came from.
  jni.JniString get installerPackageName =>
      jni.JniString.fromRef(_get_installerPackageName(reference).object);
  static final _set_installerPackageName = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport__installerPackageName")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String installerPackageName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Package name of the application which installed the application this
  /// report pertains to.
  /// This identifies which market the application came from.
  set installerPackageName(jni.JniString value) =>
      _set_installerPackageName(reference, value.reference);

  static final _get_packageName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport__packageName")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String packageName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Package name of the application.
  jni.JniString get packageName =>
      jni.JniString.fromRef(_get_packageName(reference).object);
  static final _set_packageName = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport__packageName")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String packageName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Package name of the application.
  set packageName(jni.JniString value) =>
      _set_packageName(reference, value.reference);

  static final _get_processName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport__processName")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String processName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Process name of the application.
  jni.JniString get processName =>
      jni.JniString.fromRef(_get_processName(reference).object);
  static final _set_processName = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport__processName")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String processName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Process name of the application.
  set processName(jni.JniString value) =>
      _set_processName(reference, value.reference);

  static final _get_runningServiceInfo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport__runningServiceInfo")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.app.ApplicationErrorReport.RunningServiceInfo runningServiceInfo
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this report is of type \#TYPE_RUNNING_SERVICE, contains an instance
  /// of RunningServiceInfo; otherwise null.
  ApplicationErrorReport_RunningServiceInfo get runningServiceInfo =>
      ApplicationErrorReport_RunningServiceInfo.fromRef(
          _get_runningServiceInfo(reference).object);
  static final _set_runningServiceInfo = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport__runningServiceInfo")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.ApplicationErrorReport.RunningServiceInfo runningServiceInfo
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this report is of type \#TYPE_RUNNING_SERVICE, contains an instance
  /// of RunningServiceInfo; otherwise null.
  set runningServiceInfo(ApplicationErrorReport_RunningServiceInfo value) =>
      _set_runningServiceInfo(reference, value.reference);

  static final _get_systemApp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport__systemApp")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public boolean systemApp
  ///
  /// Set if the app is on the system image.
  bool get systemApp => _get_systemApp(reference).boolean;
  static final _set_systemApp = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Uint8)>>("set_ApplicationErrorReport__systemApp")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public boolean systemApp
  ///
  /// Set if the app is on the system image.
  set systemApp(bool value) => _set_systemApp(reference, value ? 1 : 0);

  static final _get_time = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport__time")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public long time
  ///
  /// Time at which the error occurred.
  int get time => _get_time(reference).long;
  static final _set_time = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int64)>>("set_ApplicationErrorReport__time")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public long time
  ///
  /// Time at which the error occurred.
  set time(int value) => _set_time(reference, value);

  static final _get_type = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport__type")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int type
  ///
  /// Type of this report. Can be one of \#TYPE_NONE,
  /// \#TYPE_CRASH, \#TYPE_ANR, \#TYPE_BATTERY,
  /// or \#TYPE_RUNNING_SERVICE.
  int get type => _get_type(reference).integer;
  static final _set_type = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_ApplicationErrorReport__type")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int type
  ///
  /// Type of this report. Can be one of \#TYPE_NONE,
  /// \#TYPE_CRASH, \#TYPE_ANR, \#TYPE_BATTERY,
  /// or \#TYPE_RUNNING_SERVICE.
  set type(int value) => _set_type(reference, value);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ApplicationErrorReport__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ///
  /// Create an uninitialized instance of ApplicationErrorReport.
  ApplicationErrorReport() : super.fromRef(_ctor().object);

  static final _getErrorReportReceiver = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ApplicationErrorReport__getErrorReportReceiver")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.content.ComponentName getErrorReportReceiver(android.content.Context context, java.lang.String packageName, int appFlags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static content_.ComponentName getErrorReportReceiver(
          content_.Context context, jni.JniString packageName, int appFlags) =>
      content_.ComponentName.fromRef(_getErrorReportReceiver(
              context.reference, packageName.reference, appFlags)
          .object);

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ApplicationErrorReport__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _readFromParcel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ApplicationErrorReport__readFromParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel in)
  void readFromParcel(os_.Parcel in0) =>
      _readFromParcel(reference, in0.reference).check();

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ApplicationErrorReport__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _dump = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ApplicationErrorReport__dump")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  ///
  /// Dump the report to a Printer.
  void dump(jni.JniObject pw, jni.JniString prefix) =>
      _dump(reference, pw.reference, prefix.reference).check();
}

/// from: android.app.ApplicationErrorReport$RunningServiceInfo
///
/// Describes a running service report.
class ApplicationErrorReport_RunningServiceInfo extends jni.JniObject {
  ApplicationErrorReport_RunningServiceInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_durationMillis = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport_RunningServiceInfo__durationMillis")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public long durationMillis
  ///
  /// Duration in milliseconds that the service has been running.
  int get durationMillis => _get_durationMillis(reference).long;
  static final _set_durationMillis = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int64)>>(
          "set_ApplicationErrorReport_RunningServiceInfo__durationMillis")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public long durationMillis
  ///
  /// Duration in milliseconds that the service has been running.
  set durationMillis(int value) => _set_durationMillis(reference, value);

  static final _get_serviceDetails = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport_RunningServiceInfo__serviceDetails")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String serviceDetails
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Dump of debug information about the service.
  jni.JniString get serviceDetails =>
      jni.JniString.fromRef(_get_serviceDetails(reference).object);
  static final _set_serviceDetails = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport_RunningServiceInfo__serviceDetails")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String serviceDetails
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Dump of debug information about the service.
  set serviceDetails(jni.JniString value) =>
      _set_serviceDetails(reference, value.reference);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ApplicationErrorReport_RunningServiceInfo__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ///
  /// Create an uninitialized instance of RunningServiceInfo.
  ApplicationErrorReport_RunningServiceInfo() : super.fromRef(_ctor().object);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ApplicationErrorReport_RunningServiceInfo__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel in)
  ///
  /// Create an instance of RunningServiceInfo initialized from a Parcel.
  ApplicationErrorReport_RunningServiceInfo.ctor1(os_.Parcel in0)
      : super.fromRef(_ctor1(in0.reference).object);

  static final _writeToParcel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "ApplicationErrorReport_RunningServiceInfo__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  ///
  /// Save a RunningServiceInfo instance to a parcel.
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _dump = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ApplicationErrorReport_RunningServiceInfo__dump")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  ///
  /// Dump a BatteryInfo instance to a Printer.
  void dump(jni.JniObject pw, jni.JniString prefix) =>
      _dump(reference, pw.reference, prefix.reference).check();
}

/// from: android.app.ApplicationErrorReport$CrashInfo
///
/// Describes an application crash.
class ApplicationErrorReport_CrashInfo extends jni.JniObject {
  ApplicationErrorReport_CrashInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_exceptionClassName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport_CrashInfo__exceptionClassName")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String exceptionClassName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Class name of the exception that caused the crash.
  jni.JniString get exceptionClassName =>
      jni.JniString.fromRef(_get_exceptionClassName(reference).object);
  static final _set_exceptionClassName = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport_CrashInfo__exceptionClassName")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String exceptionClassName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Class name of the exception that caused the crash.
  set exceptionClassName(jni.JniString value) =>
      _set_exceptionClassName(reference, value.reference);

  static final _get_exceptionMessage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport_CrashInfo__exceptionMessage")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String exceptionMessage
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Message stored in the exception.
  jni.JniString get exceptionMessage =>
      jni.JniString.fromRef(_get_exceptionMessage(reference).object);
  static final _set_exceptionMessage = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport_CrashInfo__exceptionMessage")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String exceptionMessage
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Message stored in the exception.
  set exceptionMessage(jni.JniString value) =>
      _set_exceptionMessage(reference, value.reference);

  static final _get_stackTrace = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport_CrashInfo__stackTrace")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String stackTrace
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Stack trace.
  jni.JniString get stackTrace =>
      jni.JniString.fromRef(_get_stackTrace(reference).object);
  static final _set_stackTrace = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport_CrashInfo__stackTrace")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String stackTrace
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Stack trace.
  set stackTrace(jni.JniString value) =>
      _set_stackTrace(reference, value.reference);

  static final _get_throwClassName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport_CrashInfo__throwClassName")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String throwClassName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Class which the exception was thrown from.
  jni.JniString get throwClassName =>
      jni.JniString.fromRef(_get_throwClassName(reference).object);
  static final _set_throwClassName = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport_CrashInfo__throwClassName")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String throwClassName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Class which the exception was thrown from.
  set throwClassName(jni.JniString value) =>
      _set_throwClassName(reference, value.reference);

  static final _get_throwFileName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport_CrashInfo__throwFileName")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String throwFileName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// File which the exception was thrown from.
  jni.JniString get throwFileName =>
      jni.JniString.fromRef(_get_throwFileName(reference).object);
  static final _set_throwFileName = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport_CrashInfo__throwFileName")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String throwFileName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// File which the exception was thrown from.
  set throwFileName(jni.JniString value) =>
      _set_throwFileName(reference, value.reference);

  static final _get_throwLineNumber = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport_CrashInfo__throwLineNumber")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int throwLineNumber
  ///
  /// Line number the exception was thrown from.
  int get throwLineNumber => _get_throwLineNumber(reference).integer;
  static final _set_throwLineNumber = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int32)>>(
          "set_ApplicationErrorReport_CrashInfo__throwLineNumber")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int throwLineNumber
  ///
  /// Line number the exception was thrown from.
  set throwLineNumber(int value) => _set_throwLineNumber(reference, value);

  static final _get_throwMethodName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport_CrashInfo__throwMethodName")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String throwMethodName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Method which the exception was thrown from.
  jni.JniString get throwMethodName =>
      jni.JniString.fromRef(_get_throwMethodName(reference).object);
  static final _set_throwMethodName = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport_CrashInfo__throwMethodName")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String throwMethodName
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Method which the exception was thrown from.
  set throwMethodName(jni.JniString value) =>
      _set_throwMethodName(reference, value.reference);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ApplicationErrorReport_CrashInfo__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ///
  /// Create an uninitialized instance of CrashInfo.
  ApplicationErrorReport_CrashInfo() : super.fromRef(_ctor().object);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ApplicationErrorReport_CrashInfo__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.Throwable tr)
  ///
  /// Create an instance of CrashInfo initialized from an exception.
  ApplicationErrorReport_CrashInfo.ctor1(jni.JniObject tr)
      : super.fromRef(_ctor1(tr.reference).object);

  static final _ctor2 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ApplicationErrorReport_CrashInfo__ctor2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel in)
  ///
  /// Create an instance of CrashInfo initialized from a Parcel.
  ApplicationErrorReport_CrashInfo.ctor2(os_.Parcel in0)
      : super.fromRef(_ctor2(in0.reference).object);

  static final _writeToParcel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "ApplicationErrorReport_CrashInfo__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  ///
  /// Save a CrashInfo instance to a parcel.
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _dump = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ApplicationErrorReport_CrashInfo__dump")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  ///
  /// Dump a CrashInfo instance to a Printer.
  void dump(jni.JniObject pw, jni.JniString prefix) =>
      _dump(reference, pw.reference, prefix.reference).check();
}

/// from: android.app.ApplicationErrorReport$BatteryInfo
///
/// Describes a battery usage report.
class ApplicationErrorReport_BatteryInfo extends jni.JniObject {
  ApplicationErrorReport_BatteryInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_checkinDetails = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport_BatteryInfo__checkinDetails")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String checkinDetails
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Checkin details.
  jni.JniString get checkinDetails =>
      jni.JniString.fromRef(_get_checkinDetails(reference).object);
  static final _set_checkinDetails = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport_BatteryInfo__checkinDetails")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String checkinDetails
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Checkin details.
  set checkinDetails(jni.JniString value) =>
      _set_checkinDetails(reference, value.reference);

  static final _get_durationMicros = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport_BatteryInfo__durationMicros")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public long durationMicros
  ///
  /// Duration in microseconds over which the process used the above
  /// percentage of battery.
  int get durationMicros => _get_durationMicros(reference).long;
  static final _set_durationMicros = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int64)>>(
          "set_ApplicationErrorReport_BatteryInfo__durationMicros")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public long durationMicros
  ///
  /// Duration in microseconds over which the process used the above
  /// percentage of battery.
  set durationMicros(int value) => _set_durationMicros(reference, value);

  static final _get_usageDetails = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport_BatteryInfo__usageDetails")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String usageDetails
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Dump of various info impacting battery use.
  jni.JniString get usageDetails =>
      jni.JniString.fromRef(_get_usageDetails(reference).object);
  static final _set_usageDetails = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport_BatteryInfo__usageDetails")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String usageDetails
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Dump of various info impacting battery use.
  set usageDetails(jni.JniString value) =>
      _set_usageDetails(reference, value.reference);

  static final _get_usagePercent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport_BatteryInfo__usagePercent")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int usagePercent
  ///
  /// Percentage of the battery that was used up by the process.
  int get usagePercent => _get_usagePercent(reference).integer;
  static final _set_usagePercent = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Int32)>>(
          "set_ApplicationErrorReport_BatteryInfo__usagePercent")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int usagePercent
  ///
  /// Percentage of the battery that was used up by the process.
  set usagePercent(int value) => _set_usagePercent(reference, value);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ApplicationErrorReport_BatteryInfo__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ///
  /// Create an uninitialized instance of BatteryInfo.
  ApplicationErrorReport_BatteryInfo() : super.fromRef(_ctor().object);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ApplicationErrorReport_BatteryInfo__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel in)
  ///
  /// Create an instance of BatteryInfo initialized from a Parcel.
  ApplicationErrorReport_BatteryInfo.ctor1(os_.Parcel in0)
      : super.fromRef(_ctor1(in0.reference).object);

  static final _writeToParcel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "ApplicationErrorReport_BatteryInfo__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  ///
  /// Save a BatteryInfo instance to a parcel.
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _dump = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ApplicationErrorReport_BatteryInfo__dump")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  ///
  /// Dump a BatteryInfo instance to a Printer.
  void dump(jni.JniObject pw, jni.JniString prefix) =>
      _dump(reference, pw.reference, prefix.reference).check();
}

/// from: android.app.ApplicationErrorReport$AnrInfo
///
/// Describes an application not responding error.
class ApplicationErrorReport_AnrInfo extends jni.JniObject {
  ApplicationErrorReport_AnrInfo.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_activity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport_AnrInfo__activity")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String activity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Activity name.
  jni.JniString get activity =>
      jni.JniString.fromRef(_get_activity(reference).object);
  static final _set_activity = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport_AnrInfo__activity")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String activity
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Activity name.
  set activity(jni.JniString value) =>
      _set_activity(reference, value.reference);

  static final _get_cause = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport_AnrInfo__cause")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String cause
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Description of the operation that timed out.
  jni.JniString get cause =>
      jni.JniString.fromRef(_get_cause(reference).object);
  static final _set_cause = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport_AnrInfo__cause")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String cause
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Description of the operation that timed out.
  set cause(jni.JniString value) => _set_cause(reference, value.reference);

  static final _get_info = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_ApplicationErrorReport_AnrInfo__info")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String info
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Additional info, including CPU stats.
  jni.JniString get info => jni.JniString.fromRef(_get_info(reference).object);
  static final _set_info = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_ApplicationErrorReport_AnrInfo__info")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String info
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Additional info, including CPU stats.
  set info(jni.JniString value) => _set_info(reference, value.reference);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ApplicationErrorReport_AnrInfo__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ///
  /// Create an uninitialized instance of AnrInfo.
  ApplicationErrorReport_AnrInfo() : super.fromRef(_ctor().object);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ApplicationErrorReport_AnrInfo__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel in)
  ///
  /// Create an instance of AnrInfo initialized from a Parcel.
  ApplicationErrorReport_AnrInfo.ctor1(os_.Parcel in0)
      : super.fromRef(_ctor1(in0.reference).object);

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ApplicationErrorReport_AnrInfo__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  ///
  /// Save an AnrInfo instance to a parcel.
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _dump = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ApplicationErrorReport_AnrInfo__dump")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  ///
  /// Dump an AnrInfo instance to a Printer.
  void dump(jni.JniObject pw, jni.JniString prefix) =>
      _dump(reference, pw.reference, prefix.reference).check();
}

/// from: android.app.AuthenticationRequiredException
///
/// Specialization of SecurityException that is thrown when authentication is needed from the
/// end user before viewing the content.
///
/// This exception is only appropriate where there is a concrete action the user can take to
/// authorize and make forward progress, such as confirming or entering authentication credentials,
/// or granting access via other means.
/// <p class="note">
/// Note: legacy code that receives this exception may treat it as a general
/// SecurityException, and thus there is no guarantee that the action contained will be
/// invoked by the user.
///
///
class AuthenticationRequiredException extends jni.JniObject {
  AuthenticationRequiredException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_AuthenticationRequiredException__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.AuthenticationRequiredException> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "AuthenticationRequiredException__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.Throwable cause, android.app.PendingIntent userAction)
  ///
  /// Create an instance ready to be thrown.
  ///@param cause original cause with details designed for engineering
  ///            audiences.
  ///@param userAction primary action that will initiate the recovery. This
  ///            must launch an activity that is expected to set
  ///            Activity\#setResult(int) before finishing to
  ///            communicate the final status of the recovery. For example,
  ///            apps that observe Activity\#RESULT_OK may choose to
  ///            immediately retry their operation.
  AuthenticationRequiredException(jni.JniObject cause, PendingIntent userAction)
      : super.fromRef(_ctor(cause.reference, userAction.reference).object);

  static final _getUserAction = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AuthenticationRequiredException__getUserAction")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent getUserAction()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return primary action that will initiate the authorization.
  PendingIntent getUserAction() =>
      PendingIntent.fromRef(_getUserAction(reference).object);

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AuthenticationRequiredException__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("AuthenticationRequiredException__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();
}

/// from: android.app.AutomaticZenRule
///
/// Rule instance information for zen mode.
class AutomaticZenRule extends jni.JniObject {
  AutomaticZenRule.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_AutomaticZenRule__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.AutomaticZenRule> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Uint8)>>("AutomaticZenRule__ctor")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void <init>(java.lang.String name, android.content.ComponentName owner, android.net.Uri conditionId, int interruptionFilter, boolean enabled)
  ///
  /// Creates an automatic zen rule.
  ///@param name The name of the rule.
  ///@param owner The Condition Provider service that owns this rule.
  ///@param conditionId A representation of the state that should cause the Condition Provider
  ///                    service to apply the given interruption filter.
  ///@param interruptionFilter The interruption filter defines which notifications are allowed to
  ///                           interrupt the user (e.g. via sound &amp; vibration) while this rule
  ///                           is active.
  ///@param enabled Whether the rule is enabled.
  AutomaticZenRule(jni.JniString name, content_.ComponentName owner,
      jni.JniObject conditionId, int interruptionFilter, bool enabled)
      : super.fromRef(_ctor(name.reference, owner.reference,
                conditionId.reference, interruptionFilter, enabled ? 1 : 0)
            .object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AutomaticZenRule__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel source)
  AutomaticZenRule.ctor1(os_.Parcel source)
      : super.fromRef(_ctor1(source.reference).object);

  static final _getOwner = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AutomaticZenRule__getOwner")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getOwner()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the ComponentName of the condition provider service that owns this rule.
  content_.ComponentName getOwner() =>
      content_.ComponentName.fromRef(_getOwner(reference).object);

  static final _getConditionId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AutomaticZenRule__getConditionId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri getConditionId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the representation of the state that causes this rule to become active.
  jni.JniObject getConditionId() =>
      jni.JniObject.fromRef(_getConditionId(reference).object);

  static final _getInterruptionFilter = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "AutomaticZenRule__getInterruptionFilter")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getInterruptionFilter()
  ///
  /// Returns the interruption filter that is applied when this rule is active.
  int getInterruptionFilter() => _getInterruptionFilter(reference).integer;

  static final _getName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AutomaticZenRule__getName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the name of this rule.
  jni.JniString getName() => jni.JniString.fromRef(_getName(reference).object);

  static final _isEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AutomaticZenRule__isEnabled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isEnabled()
  ///
  /// Returns whether this rule is enabled.
  bool isEnabled() => _isEnabled(reference).boolean;

  static final _getCreationTime = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AutomaticZenRule__getCreationTime")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getCreationTime()
  ///
  /// Returns the time this rule was created, represented as milliseconds since the epoch.
  int getCreationTime() => _getCreationTime(reference).long;

  static final _setConditionId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AutomaticZenRule__setConditionId")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setConditionId(android.net.Uri conditionId)
  ///
  /// Sets the representation of the state that causes this rule to become active.
  void setConditionId(jni.JniObject conditionId) =>
      _setConditionId(reference, conditionId.reference).check();

  static final _setInterruptionFilter = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("AutomaticZenRule__setInterruptionFilter")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setInterruptionFilter(int interruptionFilter)
  ///
  /// Sets the interruption filter that is applied when this rule is active.
  ///@param interruptionFilter The do not disturb mode to enter when this rule is active.
  ///
  /// Value is android.app.NotificationManager\#INTERRUPTION_FILTER_NONE, android.app.NotificationManager\#INTERRUPTION_FILTER_PRIORITY, android.app.NotificationManager\#INTERRUPTION_FILTER_ALARMS, android.app.NotificationManager\#INTERRUPTION_FILTER_ALL, or android.app.NotificationManager\#INTERRUPTION_FILTER_UNKNOWN
  void setInterruptionFilter(int interruptionFilter) =>
      _setInterruptionFilter(reference, interruptionFilter).check();

  static final _setName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AutomaticZenRule__setName")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setName(java.lang.String name)
  ///
  /// Sets the name of this rule.
  void setName(jni.JniString name) =>
      _setName(reference, name.reference).check();

  static final _setEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("AutomaticZenRule__setEnabled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setEnabled(boolean enabled)
  ///
  /// Enables this rule.
  void setEnabled(bool enabled) =>
      _setEnabled(reference, enabled ? 1 : 0).check();

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AutomaticZenRule__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("AutomaticZenRule__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AutomaticZenRule__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("AutomaticZenRule__equals1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => _equals1(reference, o.reference).boolean;

  static final _hashCode1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("AutomaticZenRule__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() => _hashCode1(reference).integer;
}

/// from: android.app.DatePickerDialog
///
/// A simple dialog containing an android.widget.DatePicker.
///
/// See the <a href="{@docRoot}guide/topics/ui/controls/pickers.html">Pickers</a>
/// guide.
class DatePickerDialog extends AlertDialog {
  DatePickerDialog.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DatePickerDialog__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  ///
  /// Creates a new date picker dialog for the current date using the parent
  /// context's default date picker dialog theme.
  ///@param context the parent context
  ///
  /// This value must never be {@code null}.
  DatePickerDialog(content_.Context context)
      : super.fromRef(_ctor(context.reference).object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("DatePickerDialog__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Context context, int themeResId)
  ///
  /// Creates a new date picker dialog for the current date.
  ///@param context the parent context
  /// This value must never be {@code null}.
  ///@param themeResId the resource ID of the theme against which to inflate
  ///                   this dialog, or {@code 0} to use the parent
  ///                   {@code context}'s default alert dialog theme
  DatePickerDialog.ctor1(content_.Context context, int themeResId)
      : super.fromRef(_ctor1(context.reference, themeResId).object);

  static final _ctor3 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("DatePickerDialog__ctor3")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void <init>(android.content.Context context, android.app.DatePickerDialog.OnDateSetListener listener, int year, int month, int dayOfMonth)
  ///
  /// Creates a new date picker dialog for the specified date using the parent
  /// context's default date picker dialog theme.
  ///@param context the parent context
  /// This value must never be {@code null}.
  ///@param listener the listener to call when the user sets the date
  /// This value may be {@code null}.
  ///@param year the initially selected year
  ///@param month the initially selected month (0-11 for compatibility with
  ///              Calendar\#MONTH)
  ///@param dayOfMonth the initially selected day of month (1-31, depending
  ///                   on month)
  DatePickerDialog.ctor3(
      content_.Context context,
      DatePickerDialog_OnDateSetListener listener,
      int year,
      int month,
      int dayOfMonth)
      : super.fromRef(_ctor3(
                context.reference, listener.reference, year, month, dayOfMonth)
            .object);

  static final _ctor4 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("DatePickerDialog__ctor4")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void <init>(android.content.Context context, int themeResId, android.app.DatePickerDialog.OnDateSetListener listener, int year, int monthOfYear, int dayOfMonth)
  ///
  /// Creates a new date picker dialog for the specified date.
  ///@param context the parent context
  /// This value must never be {@code null}.
  ///@param themeResId the resource ID of the theme against which to inflate
  ///                   this dialog, or {@code 0} to use the parent
  ///                   {@code context}'s default alert dialog theme
  ///@param listener the listener to call when the user sets the date
  /// This value may be {@code null}.
  ///@param year the initially selected year
  ///@param monthOfYear the initially selected month of the year (0-11 for
  ///                    compatibility with Calendar\#MONTH)
  ///@param dayOfMonth the initially selected day of month (1-31, depending
  ///                   on month)
  DatePickerDialog.ctor4(
      content_.Context context,
      int themeResId,
      DatePickerDialog_OnDateSetListener listener,
      int year,
      int monthOfYear,
      int dayOfMonth)
      : super.fromRef(_ctor4(context.reference, themeResId, listener.reference,
                year, monthOfYear, dayOfMonth)
            .object);

  static final _onDateChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("DatePickerDialog__onDateChanged")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void onDateChanged(android.widget.DatePicker view, int year, int month, int dayOfMonth)
  ///
  /// @param view This value must never be {@code null}.
  void onDateChanged(jni.JniObject view, int year, int month, int dayOfMonth) =>
      _onDateChanged(reference, view.reference, year, month, dayOfMonth)
          .check();

  static final _setOnDateSetListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DatePickerDialog__setOnDateSetListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnDateSetListener(android.app.DatePickerDialog.OnDateSetListener listener)
  ///
  /// Sets the listener to call when the user sets the date.
  ///@param listener the listener to call when the user sets the date
  ///
  /// This value may be {@code null}.
  void setOnDateSetListener(DatePickerDialog_OnDateSetListener listener) =>
      _setOnDateSetListener(reference, listener.reference).check();

  static final _onClick = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DatePickerDialog__onClick")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onClick(android.content.DialogInterface dialog, int which)
  ///
  /// @param dialog This value must never be {@code null}.
  void onClick(content_.DialogInterface dialog, int which) =>
      _onClick(reference, dialog.reference, which).check();

  static final _getDatePicker = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DatePickerDialog__getDatePicker")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.DatePicker getDatePicker()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the DatePicker contained in this dialog.
  ///@return the date picker
  ///
  /// This value will never be {@code null}.
  jni.JniObject getDatePicker() =>
      jni.JniObject.fromRef(_getDatePicker(reference).object);

  static final _updateDate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32)>>("DatePickerDialog__updateDate")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void updateDate(int year, int month, int dayOfMonth)
  ///
  /// Sets the current date.
  ///@param year the year
  ///@param month the month (0-11 for compatibility with
  ///              Calendar\#MONTH)
  ///@param dayOfMonth the day of month (1-31, depending on month)
  void updateDate(int year, int month, int dayOfMonth) =>
      _updateDate(reference, year, month, dayOfMonth).check();

  static final _onSaveInstanceState1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DatePickerDialog__onSaveInstanceState1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle onSaveInstanceState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  os_.Bundle onSaveInstanceState1() =>
      os_.Bundle.fromRef(_onSaveInstanceState1(reference).object);

  static final _onRestoreInstanceState1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DatePickerDialog__onRestoreInstanceState1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onRestoreInstanceState(android.os.Bundle savedInstanceState)
  void onRestoreInstanceState1(os_.Bundle savedInstanceState) =>
      _onRestoreInstanceState1(reference, savedInstanceState.reference).check();
}

/// from: android.app.DatePickerDialog$OnDateSetListener
///
/// The listener used to indicate the user has finished selecting a date.
class DatePickerDialog_OnDateSetListener extends jni.JniObject {
  DatePickerDialog_OnDateSetListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onDateSet = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("DatePickerDialog_OnDateSetListener__onDateSet")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public abstract void onDateSet(android.widget.DatePicker view, int year, int month, int dayOfMonth)
  ///
  /// @param view the picker associated with the dialog
  ///@param year the selected year
  ///@param month the selected month (0-11 for compatibility with
  ///              Calendar\#MONTH)
  ///@param dayOfMonth th selected day of the month (1-31, depending on
  ///                   month)
  void onDateSet(jni.JniObject view, int year, int month, int dayOfMonth) =>
      _onDateSet(reference, view.reference, year, month, dayOfMonth).check();
}

/// from: android.app.Dialog
///
/// Base class for Dialogs.
///
/// Note: Activities provide a facility to manage the creation, saving and
/// restoring of dialogs. See Activity\#onCreateDialog(int),
/// Activity\#onPrepareDialog(int, Dialog),
/// Activity\#showDialog(int), and Activity\#dismissDialog(int). If
/// these methods are used, \#getOwnerActivity() will return the Activity
/// that managed this dialog.
///
/// Often you will want to have a Dialog display on top of the current
/// input method, because there is no reason for it to accept text.  You can
/// do this by setting the WindowManager.LayoutParams\#FLAG_ALT_FOCUSABLE_IM WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM window flag (assuming
/// your Dialog takes input focus, as it the default) with the following code:
///
/// <pre>
/// getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,
///         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);</pre>
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about creating dialogs, read the
/// <a href="{@docRoot}guide/topics/ui/dialogs.html">Dialogs</a> developer guide.
///
/// </div>
class Dialog extends jni.JniObject {
  Dialog.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Dialog__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  ///
  /// Creates a dialog window that uses the default dialog theme.
  ///
  /// The supplied {@code context} is used to obtain the window manager and
  /// base theme used to present the dialog.
  ///@param context the context in which the dialog should run
  /// This value must never be {@code null}.
  ///@see android.R.styleable\#Theme_dialogTheme
  Dialog(content_.Context context)
      : super.fromRef(_ctor(context.reference).object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Dialog__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Context context, int themeResId)
  ///
  /// Creates a dialog window that uses a custom dialog style.
  ///
  /// The supplied {@code context} is used to obtain the window manager and
  /// base theme used to present the dialog.
  ///
  /// The supplied {@code theme} is applied on top of the context's theme. See
  /// <a href="{@docRoot}guide/topics/resources/available-resources.html\#stylesandthemes">
  /// Style and Theme Resources</a> for more information about defining and
  /// using styles.
  ///@param context the context in which the dialog should run
  /// This value must never be {@code null}.
  ///@param themeResId a style resource describing the theme to use for the
  ///              window, or {@code 0} to use the default dialog theme
  Dialog.ctor1(content_.Context context, int themeResId)
      : super.fromRef(_ctor1(context.reference, themeResId).object);

  static final _ctor2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                  ffi.Pointer<ffi.Void>)>>("Dialog__ctor2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: protected void <init>(android.content.Context context, boolean cancelable, android.content.DialogInterface.OnCancelListener cancelListener)
  ///
  /// @param context This value must never be {@code null}.
  ///@param cancelListener This value may be {@code null}.
  Dialog.ctor2(content_.Context context, bool cancelable,
      content_.DialogInterface_OnCancelListener cancelListener)
      : super.fromRef(_ctor2(
                context.reference, cancelable ? 1 : 0, cancelListener.reference)
            .object);

  static final _getContext = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Dialog__getContext")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the Context this Dialog is running in.
  ///@return Context The Context used by the Dialog.
  ///
  /// This value will never be {@code null}.
  content_.Context getContext() =>
      content_.Context.fromRef(_getContext(reference).object);

  static final _getActionBar = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Dialog__getActionBar")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.ActionBar getActionBar()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the ActionBar attached to this dialog, if present.
  ///@return The ActionBar attached to the dialog or null if no ActionBar is present.
  ActionBar getActionBar() =>
      ActionBar.fromRef(_getActionBar(reference).object);

  static final _setOwnerActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__setOwnerActivity")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setOwnerActivity(android.app.Activity activity)
  ///
  /// Sets the Activity that owns this dialog. An example use: This Dialog will
  /// use the suggested volume control stream of the Activity.
  ///@param activity The Activity that owns this dialog.
  ///
  /// This value must never be {@code null}.
  void setOwnerActivity(Activity activity) =>
      _setOwnerActivity(reference, activity.reference).check();

  static final _getOwnerActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Dialog__getOwnerActivity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Activity getOwnerActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Activity that owns this Dialog. For example, if
  /// Activity\#showDialog(int) is used to show this Dialog, that
  /// Activity will be the owner (by default). Depending on how this dialog was
  /// created, this may return null.
  ///@return The Activity that owns this Dialog.
  Activity getOwnerActivity() =>
      Activity.fromRef(_getOwnerActivity(reference).object);

  static final _isShowing = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Dialog__isShowing")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isShowing()
  ///
  /// @return Whether the dialog is currently showing.
  bool isShowing() => _isShowing(reference).boolean;

  static final _create = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Dialog__create")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void create()
  ///
  /// Forces immediate creation of the dialog.
  ///
  /// Note that you should not override this method to perform dialog creation.
  /// Rather, override \#onCreate(Bundle).
  void create() => _create(reference).check();

  static final _show0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Dialog__show0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void show()
  ///
  /// Start the dialog and display it on screen.  The window is placed in the
  /// application layer and opaque.  Note that you should not override this
  /// method to do initialization when the dialog is shown, instead implement
  /// that in \#onStart.
  void show0() => _show0(reference).check();

  static final _hide0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Dialog__hide0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void hide()
  ///
  /// Hide the dialog, but do not dismiss it.
  void hide0() => _hide0(reference).check();

  static final _dismiss = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Dialog__dismiss")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dismiss()
  ///
  /// Dismiss this dialog, removing it from the screen. This method can be
  /// invoked safely from any thread.  Note that you should not override this
  /// method to do cleanup when the dialog is dismissed, instead implement
  /// that in \#onStop.
  void dismiss() => _dismiss(reference).check();

  static final _onCreate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onCreate")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onCreate(android.os.Bundle savedInstanceState)
  ///
  /// Similar to Activity\#onCreate, you should initialize your dialog
  /// in this method, including calling \#setContentView.
  ///@param savedInstanceState If this dialog is being reinitialized after a
  ///     the hosting activity was previously shut down, holds the result from
  ///     the most recent call to \#onSaveInstanceState, or null if this
  ///     is the first time.
  void onCreate(os_.Bundle savedInstanceState) =>
      _onCreate(reference, savedInstanceState.reference).check();

  static final _onStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Dialog__onStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStart()
  ///
  /// Called when the dialog is starting.
  void onStart() => _onStart(reference).check();

  static final _onStop = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Dialog__onStop")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStop()
  ///
  /// Called to tell you that you're stopping.
  void onStop() => _onStop(reference).check();

  static final _onSaveInstanceState = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Dialog__onSaveInstanceState")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle onSaveInstanceState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Saves the state of the dialog into a bundle.
  ///
  /// The default implementation saves the state of its view hierarchy, so you'll
  /// likely want to call through to super if you override this to save additional
  /// state.
  ///@return A bundle with the state of the dialog.
  ///
  /// This value will never be {@code null}.
  os_.Bundle onSaveInstanceState() =>
      os_.Bundle.fromRef(_onSaveInstanceState(reference).object);

  static final _onRestoreInstanceState = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onRestoreInstanceState")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onRestoreInstanceState(android.os.Bundle savedInstanceState)
  ///
  /// Restore the state of the dialog from a previously saved bundle.
  ///
  /// The default implementation restores the state of the dialog's view
  /// hierarchy that was saved in the default implementation of \#onSaveInstanceState(),
  /// so be sure to call through to super when overriding unless you want to
  /// do all restoring of state yourself.
  ///@param savedInstanceState The state of the dialog previously saved by
  ///     \#onSaveInstanceState().
  ///
  /// This value must never be {@code null}.
  void onRestoreInstanceState(os_.Bundle savedInstanceState) =>
      _onRestoreInstanceState(reference, savedInstanceState.reference).check();

  static final _getWindow = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Dialog__getWindow")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.Window getWindow()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the current Window for the activity.  This can be used to
  /// directly access parts of the Window API that are not available
  /// through Activity/Screen.
  ///@return Window The current window, or null if the activity is not
  ///         visual.
  jni.JniObject getWindow() =>
      jni.JniObject.fromRef(_getWindow(reference).object);

  static final _getCurrentFocus = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Dialog__getCurrentFocus")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View getCurrentFocus()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Call android.view.Window\#getCurrentFocus on the
  /// Window if this Activity to return the currently focused view.
  ///@return View The current View with focus or null.
  ///@see \#getWindow
  ///@see android.view.Window\#getCurrentFocus
  jni.JniObject getCurrentFocus() =>
      jni.JniObject.fromRef(_getCurrentFocus(reference).object);

  static final _setContentView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Dialog__setContentView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setContentView(int layoutResID)
  ///
  /// Set the screen content from a layout resource.  The resource will be
  /// inflated, adding all top-level views to the screen.
  ///@param layoutResID Resource ID to be inflated.
  void setContentView(int layoutResID) =>
      _setContentView(reference, layoutResID).check();

  static final _setContentView1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__setContentView1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setContentView(android.view.View view)
  ///
  /// Set the screen content to an explicit view.  This view is placed
  /// directly into the screen's view hierarchy.  It can itself be a complex
  /// view hierarchy.
  ///@param view The desired content to display.
  ///
  /// This value must never be {@code null}.
  void setContentView1(jni.JniObject view) =>
      _setContentView1(reference, view.reference).check();

  static final _setContentView2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__setContentView2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setContentView(android.view.View view, android.view.ViewGroup.LayoutParams params)
  ///
  /// Set the screen content to an explicit view.  This view is placed
  /// directly into the screen's view hierarchy.  It can itself be a complex
  /// view hierarchy.
  ///@param view The desired content to display.
  /// This value must never be {@code null}.
  ///@param params Layout parameters for the view.
  ///
  /// This value may be {@code null}.
  void setContentView2(jni.JniObject view, jni.JniObject params) =>
      _setContentView2(reference, view.reference, params.reference).check();

  static final _addContentView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__addContentView")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void addContentView(android.view.View view, android.view.ViewGroup.LayoutParams params)
  ///
  /// Add an additional content view to the screen.  Added after any existing
  /// ones in the screen -- existing views are NOT removed.
  ///@param view The desired content to display.
  /// This value must never be {@code null}.
  ///@param params Layout parameters for the view.
  ///
  /// This value may be {@code null}.
  void addContentView(jni.JniObject view, jni.JniObject params) =>
      _addContentView(reference, view.reference, params.reference).check();

  static final _setTitle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__setTitle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTitle(java.lang.CharSequence title)
  ///
  /// Set the title text for this dialog's window.
  ///@param title The new text to display in the title.
  ///
  /// This value may be {@code null}.
  void setTitle(jni.JniObject title) =>
      _setTitle(reference, title.reference).check();

  static final _setTitle1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Dialog__setTitle1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setTitle(int titleId)
  ///
  /// Set the title text for this dialog's window. The text is retrieved
  /// from the resources with the supplied identifier.
  ///@param titleId the title's text resource identifier
  void setTitle1(int titleId) => _setTitle1(reference, titleId).check();

  static final _onKeyDown = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onKeyDown")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyDown(int keyCode, android.view.KeyEvent event)
  ///
  /// A key was pressed down.
  ///
  /// If the focused view didn't want this event, this method is called.
  ///
  /// Default implementation consumes KeyEvent\#KEYCODE_BACK KEYCODE_BACK
  /// and, as of android.os.Build.VERSION_CODES\#P P, KeyEvent\#KEYCODE_ESCAPE KEYCODE_ESCAPE to later handle them in \#onKeyUp.
  ///@see \#onKeyUp
  ///@see android.view.KeyEvent
  ///@param event This value must never be {@code null}.
  bool onKeyDown(int keyCode, jni.JniObject event) =>
      _onKeyDown(reference, keyCode, event.reference).boolean;

  static final _onKeyLongPress = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onKeyLongPress")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyLongPress(int keyCode, android.view.KeyEvent event)
  ///
  /// Default implementation of KeyEvent.Callback\#onKeyLongPress(int, KeyEvent) KeyEvent.Callback.onKeyLongPress(): always returns false (doesn't handle
  /// the event).
  ///@param event This value must never be {@code null}.
  bool onKeyLongPress(int keyCode, jni.JniObject event) =>
      _onKeyLongPress(reference, keyCode, event.reference).boolean;

  static final _onKeyUp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onKeyUp")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyUp(int keyCode, android.view.KeyEvent event)
  ///
  /// A key was released.
  ///
  /// Default implementation consumes KeyEvent\#KEYCODE_BACK KEYCODE_BACK
  /// and, as of android.os.Build.VERSION_CODES\#P P, KeyEvent\#KEYCODE_ESCAPE KEYCODE_ESCAPE to close the dialog.
  ///@see \#onKeyDown
  ///@see android.view.KeyEvent
  ///@param event This value must never be {@code null}.
  bool onKeyUp(int keyCode, jni.JniObject event) =>
      _onKeyUp(reference, keyCode, event.reference).boolean;

  static final _onKeyMultiple = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Pointer<ffi.Void>)>>("Dialog__onKeyMultiple")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyMultiple(int keyCode, int repeatCount, android.view.KeyEvent event)
  ///
  /// Default implementation of KeyEvent.Callback\#onKeyMultiple(int, int, KeyEvent) KeyEvent.Callback.onKeyMultiple(): always returns false (doesn't handle
  /// the event).
  ///@param event This value must never be {@code null}.
  bool onKeyMultiple(int keyCode, int repeatCount, jni.JniObject event) =>
      _onKeyMultiple(reference, keyCode, repeatCount, event.reference).boolean;

  static final _onBackPressed = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Dialog__onBackPressed")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onBackPressed()
  ///
  /// Called when the dialog has detected the user's press of the back
  /// key.  The default implementation simply cancels the dialog (only if
  /// it is cancelable), but you can override this to do whatever you want.
  void onBackPressed() => _onBackPressed(reference).check();

  static final _onKeyShortcut = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onKeyShortcut")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onKeyShortcut(int keyCode, android.view.KeyEvent event)
  ///
  /// Called when a key shortcut event is not handled by any of the views in the Dialog.
  /// Override this method to implement global key shortcuts for the Dialog.
  /// Key shortcuts can also be implemented by setting the
  /// MenuItem\#setShortcut(char, char) shortcut property of menu items.
  ///@param keyCode The value in event.getKeyCode().
  ///@param event Description of the key event.
  /// This value must never be {@code null}.
  ///@return True if the key shortcut was handled.
  bool onKeyShortcut(int keyCode, jni.JniObject event) =>
      _onKeyShortcut(reference, keyCode, event.reference).boolean;

  static final _onTouchEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onTouchEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onTouchEvent(android.view.MotionEvent event)
  ///
  /// Called when a touch screen event was not handled by any of the views
  /// under it. This is most useful to process touch events that happen outside
  /// of your window bounds, where there is no view to receive it.
  ///@param event The touch screen event being processed.
  /// This value must never be {@code null}.
  ///@return Return true if you have consumed the event, false if you haven't.
  ///         The default implementation will cancel the dialog when a touch
  ///         happens outside of the window bounds.
  bool onTouchEvent(jni.JniObject event) =>
      _onTouchEvent(reference, event.reference).boolean;

  static final _onTrackballEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onTrackballEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onTrackballEvent(android.view.MotionEvent event)
  ///
  /// Called when the trackball was moved and not handled by any of the
  /// views inside of the activity.  So, for example, if the trackball moves
  /// while focus is on a button, you will receive a call here because
  /// buttons do not normally do anything with trackball events.  The call
  /// here happens _before_ trackball movements are converted to
  /// DPAD key events, which then get sent back to the view hierarchy, and
  /// will be processed at the point for things like focus navigation.
  ///@param event The trackball event being processed.
  ///
  /// This value must never be {@code null}.
  ///@return Return true if you have consumed the event, false if you haven't.
  /// The default implementation always returns false.
  bool onTrackballEvent(jni.JniObject event) =>
      _onTrackballEvent(reference, event.reference).boolean;

  static final _onGenericMotionEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onGenericMotionEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onGenericMotionEvent(android.view.MotionEvent event)
  ///
  /// Called when a generic motion event was not handled by any of the
  /// views inside of the dialog.
  ///
  /// Generic motion events describe joystick movements, mouse hovers, track pad
  /// touches, scroll wheel movements and other input events.  The
  /// MotionEvent\#getSource() source of the motion event specifies
  /// the class of input that was received.  Implementations of this method
  /// must examine the bits in the source before processing the event.
  /// The following code example shows how this is done.
  ///
  ///
  /// Generic motion events with source class
  /// android.view.InputDevice\#SOURCE_CLASS_POINTER
  /// are delivered to the view under the pointer.  All other generic motion events are
  /// delivered to the focused view.
  ///
  ///
  /// See View\#onGenericMotionEvent(MotionEvent) for an example of how to
  /// handle this event.
  ///
  ///
  ///@param event The generic motion event being processed.
  ///
  /// This value must never be {@code null}.
  ///@return Return true if you have consumed the event, false if you haven't.
  /// The default implementation always returns false.
  bool onGenericMotionEvent(jni.JniObject event) =>
      _onGenericMotionEvent(reference, event.reference).boolean;

  static final _onWindowAttributesChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onWindowAttributesChanged")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onWindowAttributesChanged(android.view.WindowManager.LayoutParams params)
  void onWindowAttributesChanged(jni.JniObject params) =>
      _onWindowAttributesChanged(reference, params.reference).check();

  static final _onContentChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Dialog__onContentChanged")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onContentChanged()
  void onContentChanged() => _onContentChanged(reference).check();

  static final _onWindowFocusChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Dialog__onWindowFocusChanged")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onWindowFocusChanged(boolean hasFocus)
  void onWindowFocusChanged(bool hasFocus) =>
      _onWindowFocusChanged(reference, hasFocus ? 1 : 0).check();

  static final _onAttachedToWindow = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Dialog__onAttachedToWindow")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttachedToWindow()
  void onAttachedToWindow() => _onAttachedToWindow(reference).check();

  static final _onDetachedFromWindow = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Dialog__onDetachedFromWindow")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDetachedFromWindow()
  void onDetachedFromWindow() => _onDetachedFromWindow(reference).check();

  static final _dispatchKeyEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__dispatchKeyEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchKeyEvent(android.view.KeyEvent event)
  ///
  /// Called to process key events.  You can override this to intercept all
  /// key events before they are dispatched to the window.  Be sure to call
  /// this implementation for key events that should be handled normally.
  ///@param event The key event.
  ///
  /// This value must never be {@code null}.
  ///@return boolean Return true if this event was consumed.
  bool dispatchKeyEvent(jni.JniObject event) =>
      _dispatchKeyEvent(reference, event.reference).boolean;

  static final _dispatchKeyShortcutEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__dispatchKeyShortcutEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchKeyShortcutEvent(android.view.KeyEvent event)
  ///
  /// Called to process a key shortcut event.
  /// You can override this to intercept all key shortcut events before they are
  /// dispatched to the window.  Be sure to call this implementation for key shortcut
  /// events that should be handled normally.
  ///@param event The key shortcut event.
  /// This value must never be {@code null}.
  ///@return True if this event was consumed.
  bool dispatchKeyShortcutEvent(jni.JniObject event) =>
      _dispatchKeyShortcutEvent(reference, event.reference).boolean;

  static final _dispatchTouchEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__dispatchTouchEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchTouchEvent(android.view.MotionEvent ev)
  ///
  /// Called to process touch screen events.  You can override this to
  /// intercept all touch screen events before they are dispatched to the
  /// window.  Be sure to call this implementation for touch screen events
  /// that should be handled normally.
  ///@param ev The touch screen event.
  ///
  /// This value must never be {@code null}.
  ///@return boolean Return true if this event was consumed.
  bool dispatchTouchEvent(jni.JniObject ev) =>
      _dispatchTouchEvent(reference, ev.reference).boolean;

  static final _dispatchTrackballEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__dispatchTrackballEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchTrackballEvent(android.view.MotionEvent ev)
  ///
  /// Called to process trackball events.  You can override this to
  /// intercept all trackball events before they are dispatched to the
  /// window.  Be sure to call this implementation for trackball events
  /// that should be handled normally.
  ///@param ev The trackball event.
  ///
  /// This value must never be {@code null}.
  ///@return boolean Return true if this event was consumed.
  bool dispatchTrackballEvent(jni.JniObject ev) =>
      _dispatchTrackballEvent(reference, ev.reference).boolean;

  static final _dispatchGenericMotionEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__dispatchGenericMotionEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchGenericMotionEvent(android.view.MotionEvent ev)
  ///
  /// Called to process generic motion events.  You can override this to
  /// intercept all generic motion events before they are dispatched to the
  /// window.  Be sure to call this implementation for generic motion events
  /// that should be handled normally.
  ///@param ev The generic motion event.
  ///
  /// This value must never be {@code null}.
  ///@return boolean Return true if this event was consumed.
  bool dispatchGenericMotionEvent(jni.JniObject ev) =>
      _dispatchGenericMotionEvent(reference, ev.reference).boolean;

  static final _dispatchPopulateAccessibilityEvent = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Dialog__dispatchPopulateAccessibilityEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)
  ///
  /// @param event This value must never be {@code null}.
  bool dispatchPopulateAccessibilityEvent(jni.JniObject event) =>
      _dispatchPopulateAccessibilityEvent(reference, event.reference).boolean;

  static final _onCreatePanelView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Dialog__onCreatePanelView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.View onCreatePanelView(int featureId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @see Activity\#onCreatePanelView(int)
  jni.JniObject onCreatePanelView(int featureId) =>
      jni.JniObject.fromRef(_onCreatePanelView(reference, featureId).object);

  static final _onCreatePanelMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onCreatePanelMenu")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onCreatePanelMenu(int featureId, android.view.Menu menu)
  ///
  /// @see Activity\#onCreatePanelMenu(int, Menu)
  ///@param menu This value must never be {@code null}.
  bool onCreatePanelMenu(int featureId, jni.JniObject menu) =>
      _onCreatePanelMenu(reference, featureId, menu.reference).boolean;

  static final _onPreparePanel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onPreparePanel")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onPreparePanel(int featureId, android.view.View view, android.view.Menu menu)
  ///
  /// @see Activity\#onPreparePanel(int, View, Menu)
  bool onPreparePanel(int featureId, jni.JniObject view, jni.JniObject menu) =>
      _onPreparePanel(reference, featureId, view.reference, menu.reference)
          .boolean;

  static final _onMenuOpened = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onMenuOpened")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onMenuOpened(int featureId, android.view.Menu menu)
  ///
  /// @see Activity\#onMenuOpened(int, Menu)
  bool onMenuOpened(int featureId, jni.JniObject menu) =>
      _onMenuOpened(reference, featureId, menu.reference).boolean;

  static final _onMenuItemSelected = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onMenuItemSelected")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onMenuItemSelected(int featureId, android.view.MenuItem item)
  ///
  /// @see Activity\#onMenuItemSelected(int, MenuItem)
  bool onMenuItemSelected(int featureId, jni.JniObject item) =>
      _onMenuItemSelected(reference, featureId, item.reference).boolean;

  static final _onPanelClosed = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onPanelClosed")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPanelClosed(int featureId, android.view.Menu menu)
  ///
  /// @see Activity\#onPanelClosed(int, Menu)
  void onPanelClosed(int featureId, jni.JniObject menu) =>
      _onPanelClosed(reference, featureId, menu.reference).check();

  static final _onCreateOptionsMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onCreateOptionsMenu")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onCreateOptionsMenu(android.view.Menu menu)
  ///
  /// It is usually safe to proxy this call to the owner activity's
  /// Activity\#onCreateOptionsMenu(Menu) if the client desires the same
  /// menu for this Dialog.
  ///@see Activity\#onCreateOptionsMenu(Menu)
  ///@see \#getOwnerActivity()
  ///@param menu This value must never be {@code null}.
  bool onCreateOptionsMenu(jni.JniObject menu) =>
      _onCreateOptionsMenu(reference, menu.reference).boolean;

  static final _onPrepareOptionsMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onPrepareOptionsMenu")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onPrepareOptionsMenu(android.view.Menu menu)
  ///
  /// It is usually safe to proxy this call to the owner activity's
  /// Activity\#onPrepareOptionsMenu(Menu) if the client desires the
  /// same menu for this Dialog.
  ///@see Activity\#onPrepareOptionsMenu(Menu)
  ///@see \#getOwnerActivity()
  ///@param menu This value must never be {@code null}.
  bool onPrepareOptionsMenu(jni.JniObject menu) =>
      _onPrepareOptionsMenu(reference, menu.reference).boolean;

  static final _onOptionsItemSelected = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onOptionsItemSelected")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onOptionsItemSelected(android.view.MenuItem item)
  ///
  /// @see Activity\#onOptionsItemSelected(MenuItem)
  ///@param item This value must never be {@code null}.
  bool onOptionsItemSelected(jni.JniObject item) =>
      _onOptionsItemSelected(reference, item.reference).boolean;

  static final _onOptionsMenuClosed = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onOptionsMenuClosed")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onOptionsMenuClosed(android.view.Menu menu)
  ///
  /// @see Activity\#onOptionsMenuClosed(Menu)
  ///@param menu This value must never be {@code null}.
  void onOptionsMenuClosed(jni.JniObject menu) =>
      _onOptionsMenuClosed(reference, menu.reference).check();

  static final _openOptionsMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Dialog__openOptionsMenu")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void openOptionsMenu()
  ///
  /// @see Activity\#openOptionsMenu()
  void openOptionsMenu() => _openOptionsMenu(reference).check();

  static final _closeOptionsMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Dialog__closeOptionsMenu")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void closeOptionsMenu()
  ///
  /// @see Activity\#closeOptionsMenu()
  void closeOptionsMenu() => _closeOptionsMenu(reference).check();

  static final _invalidateOptionsMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Dialog__invalidateOptionsMenu")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void invalidateOptionsMenu()
  ///
  /// @see Activity\#invalidateOptionsMenu()
  void invalidateOptionsMenu() => _invalidateOptionsMenu(reference).check();

  static final _onCreateContextMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onCreateContextMenu")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreateContextMenu(android.view.ContextMenu menu, android.view.View v, android.view.ContextMenu.ContextMenuInfo menuInfo)
  ///
  /// @see Activity\#onCreateContextMenu(ContextMenu, View, ContextMenuInfo)
  void onCreateContextMenu(
          jni.JniObject menu, jni.JniObject v, jni.JniObject menuInfo) =>
      _onCreateContextMenu(
              reference, menu.reference, v.reference, menuInfo.reference)
          .check();

  static final _registerForContextMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__registerForContextMenu")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerForContextMenu(android.view.View view)
  ///
  /// @see Activity\#registerForContextMenu(View)
  ///@param view This value must never be {@code null}.
  void registerForContextMenu(jni.JniObject view) =>
      _registerForContextMenu(reference, view.reference).check();

  static final _unregisterForContextMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__unregisterForContextMenu")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterForContextMenu(android.view.View view)
  ///
  /// @see Activity\#unregisterForContextMenu(View)
  ///@param view This value must never be {@code null}.
  void unregisterForContextMenu(jni.JniObject view) =>
      _unregisterForContextMenu(reference, view.reference).check();

  static final _openContextMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__openContextMenu")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void openContextMenu(android.view.View view)
  ///
  /// @see Activity\#openContextMenu(View)
  ///@param view This value must never be {@code null}.
  void openContextMenu(jni.JniObject view) =>
      _openContextMenu(reference, view.reference).check();

  static final _onContextItemSelected = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onContextItemSelected")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onContextItemSelected(android.view.MenuItem item)
  ///
  /// @see Activity\#onContextItemSelected(MenuItem)
  ///@param item This value must never be {@code null}.
  bool onContextItemSelected(jni.JniObject item) =>
      _onContextItemSelected(reference, item.reference).boolean;

  static final _onContextMenuClosed = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onContextMenuClosed")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onContextMenuClosed(android.view.Menu menu)
  ///
  /// @see Activity\#onContextMenuClosed(Menu)
  ///@param menu This value must never be {@code null}.
  void onContextMenuClosed(jni.JniObject menu) =>
      _onContextMenuClosed(reference, menu.reference).check();

  static final _onSearchRequested = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onSearchRequested")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onSearchRequested(android.view.SearchEvent searchEvent)
  ///
  /// This hook is called when the user signals the desire to start a search.
  ///@param searchEvent This value must never be {@code null}.
  bool onSearchRequested(jni.JniObject searchEvent) =>
      _onSearchRequested(reference, searchEvent.reference).boolean;

  static final _onSearchRequested1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Dialog__onSearchRequested1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onSearchRequested()
  ///
  /// This hook is called when the user signals the desire to start a search.
  bool onSearchRequested1() => _onSearchRequested1(reference).boolean;

  static final _getSearchEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Dialog__getSearchEvent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.view.SearchEvent getSearchEvent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// During the onSearchRequested() callbacks, this function will return the
  /// SearchEvent that triggered the callback, if it exists.
  ///@return SearchEvent The SearchEvent that triggered the \#onSearchRequested callback.
  ///
  /// This value may be {@code null}.
  jni.JniObject getSearchEvent() =>
      jni.JniObject.fromRef(_getSearchEvent(reference).object);

  static final _onWindowStartingActionMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onWindowStartingActionMode")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject onWindowStartingActionMode(jni.JniObject callback) =>
      jni.JniObject.fromRef(
          _onWindowStartingActionMode(reference, callback.reference).object);

  static final _onWindowStartingActionMode1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Dialog__onWindowStartingActionMode1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.ActionMode onWindowStartingActionMode(android.view.ActionMode.Callback callback, int type)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject onWindowStartingActionMode1(jni.JniObject callback, int type) =>
      jni.JniObject.fromRef(
          _onWindowStartingActionMode1(reference, callback.reference, type)
              .object);

  static final _onActionModeStarted = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onActionModeStarted")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onActionModeStarted(android.view.ActionMode mode)
  ///
  /// {@inheritDoc}
  ///
  /// Note that if you override this method you should always call through
  /// to the superclass implementation by calling super.onActionModeStarted(mode).
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onActionModeStarted(jni.JniObject mode) =>
      _onActionModeStarted(reference, mode.reference).check();

  static final _onActionModeFinished = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__onActionModeFinished")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onActionModeFinished(android.view.ActionMode mode)
  ///
  /// {@inheritDoc}
  ///
  /// Note that if you override this method you should always call through
  /// to the superclass implementation by calling super.onActionModeFinished(mode).
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onActionModeFinished(jni.JniObject mode) =>
      _onActionModeFinished(reference, mode.reference).check();

  static final _takeKeyEvents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Dialog__takeKeyEvents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void takeKeyEvents(boolean get)
  ///
  /// Request that key events come to this dialog. Use this if your
  /// dialog has no views with focus, but the dialog still wants
  /// a chance to process key events.
  ///@param get true if the dialog should receive key events, false otherwise
  ///@see android.view.Window\#takeKeyEvents
  void takeKeyEvents(bool get0) =>
      _takeKeyEvents(reference, get0 ? 1 : 0).check();

  static final _requestWindowFeature = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Dialog__requestWindowFeature")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final boolean requestWindowFeature(int featureId)
  ///
  /// Enable extended window features.  This is a convenience for calling
  /// android.view.Window\#requestFeature getWindow().requestFeature().
  ///@param featureId The desired feature as defined in
  ///                  android.view.Window.
  ///@return Returns true if the requested feature is supported and now
  ///         enabled.
  ///@see android.view.Window\#requestFeature
  bool requestWindowFeature(int featureId) =>
      _requestWindowFeature(reference, featureId).boolean;

  static final _setFeatureDrawableResource = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Dialog__setFeatureDrawableResource")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final void setFeatureDrawableResource(int featureId, int resId)
  ///
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawableResource.
  void setFeatureDrawableResource(int featureId, int resId) =>
      _setFeatureDrawableResource(reference, featureId, resId).check();

  static final _setFeatureDrawableUri = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Dialog__setFeatureDrawableUri")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setFeatureDrawableUri(int featureId, android.net.Uri uri)
  ///
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawableUri.
  ///@param uri This value may be {@code null}.
  void setFeatureDrawableUri(int featureId, jni.JniObject uri) =>
      _setFeatureDrawableUri(reference, featureId, uri.reference).check();

  static final _setFeatureDrawable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Dialog__setFeatureDrawable")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final void setFeatureDrawable(int featureId, android.graphics.drawable.Drawable drawable)
  ///
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawable(int, Drawable).
  ///@param drawable This value may be {@code null}.
  void setFeatureDrawable(int featureId, jni.JniObject drawable) =>
      _setFeatureDrawable(reference, featureId, drawable.reference).check();

  static final _setFeatureDrawableAlpha = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Dialog__setFeatureDrawableAlpha")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final void setFeatureDrawableAlpha(int featureId, int alpha)
  ///
  /// Convenience for calling
  /// android.view.Window\#setFeatureDrawableAlpha.
  void setFeatureDrawableAlpha(int featureId, int alpha) =>
      _setFeatureDrawableAlpha(reference, featureId, alpha).check();

  static final _getLayoutInflater = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Dialog__getLayoutInflater")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.LayoutInflater getLayoutInflater()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return This value will never be {@code null}.
  jni.JniObject getLayoutInflater() =>
      jni.JniObject.fromRef(_getLayoutInflater(reference).object);

  static final _setCancelable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Dialog__setCancelable")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setCancelable(boolean flag)
  ///
  /// Sets whether this dialog is cancelable with the
  /// KeyEvent\#KEYCODE_BACK BACK key.
  void setCancelable(bool flag) =>
      _setCancelable(reference, flag ? 1 : 0).check();

  static final _setCanceledOnTouchOutside = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Dialog__setCanceledOnTouchOutside")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setCanceledOnTouchOutside(boolean cancel)
  ///
  /// Sets whether this dialog is canceled when touched outside the window's
  /// bounds. If setting to true, the dialog is set to be cancelable if not
  /// already set.
  ///@param cancel Whether the dialog should be canceled when touched outside
  ///            the window.
  void setCanceledOnTouchOutside(bool cancel) =>
      _setCanceledOnTouchOutside(reference, cancel ? 1 : 0).check();

  static final _cancel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Dialog__cancel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void cancel()
  ///
  /// Cancel the dialog.  This is essentially the same as calling \#dismiss(), but it will
  /// also call your DialogInterface.OnCancelListener (if registered).
  void cancel() => _cancel(reference).check();

  static final _setOnCancelListener = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__setOnCancelListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnCancelListener(android.content.DialogInterface.OnCancelListener listener)
  ///
  /// Set a listener to be invoked when the dialog is canceled.
  ///
  /// This will only be invoked when the dialog is canceled.
  /// Cancel events alone will not capture all ways that
  /// the dialog might be dismissed. If the creator needs
  /// to know when a dialog is dismissed in general, use
  /// \#setOnDismissListener.
  ///
  ///@param listener The DialogInterface.OnCancelListener to use.
  ///
  /// This value may be {@code null}.
  void setOnCancelListener(
          content_.DialogInterface_OnCancelListener listener) =>
      _setOnCancelListener(reference, listener.reference).check();

  static final _setCancelMessage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__setCancelMessage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setCancelMessage(android.os.Message msg)
  ///
  /// Set a message to be sent when the dialog is canceled.
  ///@param msg The msg to send when the dialog is canceled.
  /// This value may be {@code null}.
  ///@see \#setOnCancelListener(android.content.DialogInterface.OnCancelListener)
  void setCancelMessage(os_.Message msg) =>
      _setCancelMessage(reference, msg.reference).check();

  static final _setOnDismissListener = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__setOnDismissListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnDismissListener(android.content.DialogInterface.OnDismissListener listener)
  ///
  /// Set a listener to be invoked when the dialog is dismissed.
  ///@param listener The DialogInterface.OnDismissListener to use.
  ///
  /// This value may be {@code null}.
  void setOnDismissListener(
          content_.DialogInterface_OnDismissListener listener) =>
      _setOnDismissListener(reference, listener.reference).check();

  static final _setOnShowListener = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__setOnShowListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnShowListener(android.content.DialogInterface.OnShowListener listener)
  ///
  /// Sets a listener to be invoked when the dialog is shown.
  ///@param listener The DialogInterface.OnShowListener to use.
  ///
  /// This value may be {@code null}.
  void setOnShowListener(content_.DialogInterface_OnShowListener listener) =>
      _setOnShowListener(reference, listener.reference).check();

  static final _setDismissMessage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__setDismissMessage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setDismissMessage(android.os.Message msg)
  ///
  /// Set a message to be sent when the dialog is dismissed.
  ///@param msg The msg to send when the dialog is dismissed.
  ///
  /// This value may be {@code null}.
  void setDismissMessage(os_.Message msg) =>
      _setDismissMessage(reference, msg.reference).check();

  static final _setVolumeControlStream = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Dialog__setVolumeControlStream")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setVolumeControlStream(int streamType)
  ///
  /// By default, this will use the owner Activity's suggested stream type.
  ///@see Activity\#setVolumeControlStream(int)
  ///@see \#setOwnerActivity(Activity)
  void setVolumeControlStream(int streamType) =>
      _setVolumeControlStream(reference, streamType).check();

  static final _getVolumeControlStream = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Dialog__getVolumeControlStream")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getVolumeControlStream()
  ///
  /// @see Activity\#getVolumeControlStream()
  int getVolumeControlStream() => _getVolumeControlStream(reference).integer;

  static final _setOnKeyListener = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Dialog__setOnKeyListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnKeyListener(android.content.DialogInterface.OnKeyListener onKeyListener)
  ///
  /// Sets the callback that will be called if a key is dispatched to the dialog.
  ///@param onKeyListener This value may be {@code null}.
  void setOnKeyListener(content_.DialogInterface_OnKeyListener onKeyListener) =>
      _setOnKeyListener(reference, onKeyListener.reference).check();
}

/// from: android.app.DialogFragment
///
/// A fragment that displays a dialog window, floating on top of its
/// activity's window.  This fragment contains a Dialog object, which it
/// displays as appropriate based on the fragment's state.  Control of
/// the dialog (deciding when to show, hide, dismiss it) should be done through
/// the API here, not with direct calls on the dialog.
///
/// Implementations should override this class and implement
/// \#onCreateView(LayoutInflater, ViewGroup, Bundle) to supply the
/// content of the dialog.  Alternatively, they can override
/// \#onCreateDialog(Bundle) to create an entirely custom dialog, such
/// as an AlertDialog, with its own content.
///
/// Topics covered here:
/// <ol>
/// <li><a href="\#Lifecycle">Lifecycle</a>
/// <li><a href="\#BasicDialog">Basic Dialog</a>
/// <li><a href="\#AlertDialog">Alert Dialog</a>
/// <li><a href="\#DialogOrEmbed">Selecting Between Dialog or Embedding</a>
/// </ol>
///
/// <a name="Lifecycle"></a>
/// <h3>Lifecycle</h3>
///
/// DialogFragment does various things to keep the fragment's lifecycle
/// driving it, instead of the Dialog.  Note that dialogs are generally
/// autonomous entities -- they are their own window, receiving their own
/// input events, and often deciding on their own when to disappear (by
/// receiving a back key event or the user clicking on a button).
///
/// DialogFragment needs to ensure that what is happening with the Fragment
/// and Dialog states remains consistent.  To do this, it watches for dismiss
/// events from the dialog and takes care of removing its own state when they
/// happen.  This means you should use \#show(FragmentManager, String)
/// or \#show(FragmentTransaction, String) to add an instance of
/// DialogFragment to your UI, as these keep track of how DialogFragment should
/// remove itself when the dialog is dismissed.
///
/// <a name="BasicDialog"></a>
/// <h3>Basic Dialog</h3>
///
/// The simplest use of DialogFragment is as a floating container for the
/// fragment's view hierarchy.  A simple implementation may look like this:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentDialog.java
///      dialog}
///
/// An example showDialog() method on the Activity could be:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentDialog.java
///      add_dialog}
///
/// This removes any currently shown dialog, creates a new DialogFragment
/// with an argument, and shows it as a new state on the back stack.  When the
/// transaction is popped, the current DialogFragment and its Dialog will be
/// destroyed, and the previous one (if any) re-shown.  Note that in this case
/// DialogFragment will take care of popping the transaction of the Dialog
/// is dismissed separately from it.
///
/// <a name="AlertDialog"></a>
/// <h3>Alert Dialog</h3>
///
/// Instead of (or in addition to) implementing \#onCreateView to
/// generate the view hierarchy inside of a dialog, you may implement
/// \#onCreateDialog(Bundle) to create your own custom Dialog object.
///
/// This is most useful for creating an AlertDialog, allowing you
/// to display standard alerts to the user that are managed by a fragment.
/// A simple example implementation of this is:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentAlertDialog.java
///      dialog}
///
/// The activity creating this fragment may have the following methods to
/// show the dialog and receive results from it:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentAlertDialog.java
///      activity}
///
/// Note that in this case the fragment is not placed on the back stack, it
/// is just added as an indefinitely running fragment.  Because dialogs normally
/// are modal, this will still operate as a back stack, since the dialog will
/// capture user input until it is dismissed.  When it is dismissed, DialogFragment
/// will take care of removing itself from its fragment manager.
///
/// <a name="DialogOrEmbed"></a>
/// <h3>Selecting Between Dialog or Embedding</h3>
///
/// A DialogFragment can still optionally be used as a normal fragment, if
/// desired.  This is useful if you have a fragment that in some cases should
/// be shown as a dialog and others embedded in a larger UI.  This behavior
/// will normally be automatically selected for you based on how you are using
/// the fragment, but can be customized with \#setShowsDialog(boolean).
///
/// For example, here is a simple dialog fragment:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentDialogOrActivity.java
///      dialog}
///
/// An instance of this fragment can be created and shown as a dialog:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentDialogOrActivity.java
///      show_dialog}
///
/// It can also be added as content in a view hierarchy:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentDialogOrActivity.java
///      embed}
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.DialogFragment for consistent behavior across all devices
///      and access to <a href="{@docRoot}topic/libraries/architecture/lifecycle.html">Lifecycle</a>.
class DialogFragment extends Fragment {
  DialogFragment.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int STYLE_NORMAL
  ///
  /// Style for \#setStyle(int, int): a basic,
  /// normal dialog.
  static const STYLE_NORMAL = 0;

  /// from: static public final int STYLE_NO_FRAME
  ///
  /// Style for \#setStyle(int, int): don't draw
  /// any frame at all; the view hierarchy returned by \#onCreateView
  /// is entirely responsible for drawing the dialog.
  static const STYLE_NO_FRAME = 2;

  /// from: static public final int STYLE_NO_INPUT
  ///
  /// Style for \#setStyle(int, int): like
  /// \#STYLE_NO_FRAME, but also disables all input to the dialog.
  /// The user can not touch it, and its window will not receive input focus.
  static const STYLE_NO_INPUT = 3;

  /// from: static public final int STYLE_NO_TITLE
  ///
  /// Style for \#setStyle(int, int): don't include
  /// a title area.
  static const STYLE_NO_TITLE = 1;

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "DialogFragment__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  DialogFragment() : super.fromRef(_ctor().object);

  static final _setStyle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("DialogFragment__setStyle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void setStyle(int style, int theme)
  ///
  /// Call to customize the basic appearance and behavior of the
  /// fragment's dialog.  This can be used for some common dialog behaviors,
  /// taking care of selecting flags, theme, and other options for you.  The
  /// same effect can be achieve by manually setting Dialog and Window
  /// attributes yourself.  Calling this after the fragment's Dialog is
  /// created will have no effect.
  ///@param style Selects a standard style: may be \#STYLE_NORMAL,
  /// \#STYLE_NO_TITLE, \#STYLE_NO_FRAME, or
  /// \#STYLE_NO_INPUT.
  ///@param theme Optional custom theme.  If 0, an appropriate theme (based
  /// on the style) will be selected for you.
  void setStyle(int style, int theme) =>
      _setStyle(reference, style, theme).check();

  static final _show0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DialogFragment__show0")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void show(android.app.FragmentManager manager, java.lang.String tag)
  ///
  /// Display the dialog, adding the fragment to the given FragmentManager.  This
  /// is a convenience for explicitly creating a transaction, adding the
  /// fragment to it with the given tag, and committing it.  This does
  /// _not_ add the transaction to the back stack.  When the fragment
  /// is dismissed, a new transaction will be executed to remove it from
  /// the activity.
  ///@param manager The FragmentManager this fragment will be added to.
  ///@param tag The tag for this fragment, as per
  /// FragmentTransaction\#add(Fragment, String) FragmentTransaction.add.
  void show0(FragmentManager manager, jni.JniString tag) =>
      _show0(reference, manager.reference, tag.reference).check();

  static final _show1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DialogFragment__show1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int show(android.app.FragmentTransaction transaction, java.lang.String tag)
  ///
  /// Display the dialog, adding the fragment using an existing transaction
  /// and then committing the transaction.
  ///@param transaction An existing transaction in which to add the fragment.
  ///@param tag The tag for this fragment, as per
  /// FragmentTransaction\#add(Fragment, String) FragmentTransaction.add.
  ///@return Returns the identifier of the committed transaction, as per
  /// FragmentTransaction\#commit() FragmentTransaction.commit().
  int show1(FragmentTransaction transaction, jni.JniString tag) =>
      _show1(reference, transaction.reference, tag.reference).integer;

  static final _dismiss = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DialogFragment__dismiss")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dismiss()
  ///
  /// Dismiss the fragment and its dialog.  If the fragment was added to the
  /// back stack, all back stack state up to and including this entry will
  /// be popped.  Otherwise, a new transaction will be committed to remove
  /// the fragment.
  void dismiss() => _dismiss(reference).check();

  static final _dismissAllowingStateLoss = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DialogFragment__dismissAllowingStateLoss")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dismissAllowingStateLoss()
  ///
  /// Version of \#dismiss() that uses
  /// FragmentTransaction\#commitAllowingStateLoss() FragmentTransaction.commitAllowingStateLoss().  See linked
  /// documentation for further details.
  void dismissAllowingStateLoss() =>
      _dismissAllowingStateLoss(reference).check();

  static final _getDialog = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DialogFragment__getDialog")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Dialog getDialog()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Dialog getDialog() => Dialog.fromRef(_getDialog(reference).object);

  static final _getTheme = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DialogFragment__getTheme")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getTheme()
  int getTheme() => _getTheme(reference).integer;

  static final _setCancelable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DialogFragment__setCancelable")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setCancelable(boolean cancelable)
  ///
  /// Control whether the shown Dialog is cancelable.  Use this instead of
  /// directly calling Dialog\#setCancelable(boolean) Dialog.setCancelable(boolean), because DialogFragment needs to change
  /// its behavior based on this.
  ///@param cancelable If true, the dialog is cancelable.  The default
  /// is true.
  void setCancelable(bool cancelable) =>
      _setCancelable(reference, cancelable ? 1 : 0).check();

  static final _isCancelable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DialogFragment__isCancelable")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isCancelable()
  ///
  /// Return the current value of \#setCancelable(boolean).
  bool isCancelable() => _isCancelable(reference).boolean;

  static final _setShowsDialog = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DialogFragment__setShowsDialog")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setShowsDialog(boolean showsDialog)
  ///
  /// Controls whether this fragment should be shown in a dialog.  If not
  /// set, no Dialog will be created in \#onActivityCreated(Bundle),
  /// and the fragment's view hierarchy will thus not be added to it.  This
  /// allows you to instead use it as a normal fragment (embedded inside of
  /// its activity).
  ///
  /// This is normally set for you based on whether the fragment is
  /// associated with a container view ID passed to
  /// FragmentTransaction\#add(int, Fragment) FragmentTransaction.add(int, Fragment).
  /// If the fragment was added with a container, setShowsDialog will be
  /// initialized to false; otherwise, it will be true.
  ///@param showsDialog If true, the fragment will be displayed in a Dialog.
  /// If false, no Dialog will be created and the fragment's view hierarchly
  /// left undisturbed.
  void setShowsDialog(bool showsDialog) =>
      _setShowsDialog(reference, showsDialog ? 1 : 0).check();

  static final _getShowsDialog = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DialogFragment__getShowsDialog")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getShowsDialog()
  ///
  /// Return the current value of \#setShowsDialog(boolean).
  bool getShowsDialog() => _getShowsDialog(reference).boolean;

  static final _onAttach = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DialogFragment__onAttach")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttach(android.content.Context context)
  void onAttach(content_.Context context) =>
      _onAttach(reference, context.reference).check();

  static final _onDetach = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DialogFragment__onDetach")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDetach()
  void onDetach() => _onDetach(reference).check();

  static final _onCreate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DialogFragment__onCreate")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreate(android.os.Bundle savedInstanceState)
  void onCreate(os_.Bundle savedInstanceState) =>
      _onCreate(reference, savedInstanceState.reference).check();

  static final _onGetLayoutInflater = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DialogFragment__onGetLayoutInflater")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.LayoutInflater onGetLayoutInflater(android.os.Bundle savedInstanceState)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @hide
  jni.JniObject onGetLayoutInflater(os_.Bundle savedInstanceState) =>
      jni.JniObject.fromRef(
          _onGetLayoutInflater(reference, savedInstanceState.reference).object);

  static final _onCreateDialog = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DialogFragment__onCreateDialog")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Dialog onCreateDialog(android.os.Bundle savedInstanceState)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Override to build your own custom Dialog container.  This is typically
  /// used to show an AlertDialog instead of a generic Dialog; when doing so,
  /// \#onCreateView(LayoutInflater, ViewGroup, Bundle) does not need
  /// to be implemented since the AlertDialog takes care of its own content.
  ///
  /// This method will be called after \#onCreate(Bundle) and
  /// before \#onCreateView(LayoutInflater, ViewGroup, Bundle).  The
  /// default implementation simply instantiates and returns a Dialog
  /// class.
  ///
  /// _Note: DialogFragment own the Dialog\#setOnCancelListener Dialog.setOnCancelListener and Dialog\#setOnDismissListener Dialog.setOnDismissListener callbacks.  You must not set them yourself._
  /// To find out about these events, override \#onCancel(DialogInterface)
  /// and \#onDismiss(DialogInterface).
  ///
  ///@param savedInstanceState The last saved instance state of the Fragment,
  /// or null if this is a freshly created Fragment.
  ///@return Return a new Dialog instance to be displayed by the Fragment.
  Dialog onCreateDialog(os_.Bundle savedInstanceState) => Dialog.fromRef(
      _onCreateDialog(reference, savedInstanceState.reference).object);

  static final _onCancel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DialogFragment__onCancel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCancel(android.content.DialogInterface dialog)
  void onCancel(content_.DialogInterface dialog) =>
      _onCancel(reference, dialog.reference).check();

  static final _onDismiss = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DialogFragment__onDismiss")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onDismiss(android.content.DialogInterface dialog)
  void onDismiss(content_.DialogInterface dialog) =>
      _onDismiss(reference, dialog.reference).check();

  static final _onActivityCreated = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DialogFragment__onActivityCreated")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onActivityCreated(android.os.Bundle savedInstanceState)
  void onActivityCreated(os_.Bundle savedInstanceState) =>
      _onActivityCreated(reference, savedInstanceState.reference).check();

  static final _onStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DialogFragment__onStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onStart()
  void onStart() => _onStart(reference).check();

  static final _onSaveInstanceState = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DialogFragment__onSaveInstanceState")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onSaveInstanceState(android.os.Bundle outState)
  void onSaveInstanceState(os_.Bundle outState) =>
      _onSaveInstanceState(reference, outState.reference).check();

  static final _onStop = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DialogFragment__onStop")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onStop()
  void onStop() => _onStop(reference).check();

  static final _onDestroyView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DialogFragment__onDestroyView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDestroyView()
  ///
  /// Remove dialog.
  void onDestroyView() => _onDestroyView(reference).check();

  static final _dump = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DialogFragment__dump")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  void dump(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
          jni.JniObject args) =>
      _dump(reference, prefix.reference, fd.reference, writer.reference,
              args.reference)
          .check();
}

/// from: android.app.DownloadManager
///
/// The download manager is a system service that handles long-running HTTP downloads. Clients may
/// request that a URI be downloaded to a particular destination file. The download manager will
/// conduct the download in the background, taking care of HTTP interactions and retrying downloads
/// after failures or across connectivity changes and system reboots.
///
/// Apps that request downloads through this API should register a broadcast receiver for
/// \#ACTION_NOTIFICATION_CLICKED to appropriately handle when the user clicks on a running
/// download in a notification or from the downloads UI.
///
/// Note that the application must have the android.Manifest.permission\#INTERNET
/// permission to use this class.
class DownloadManager extends jni.JniObject {
  DownloadManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_DOWNLOAD_COMPLETE
  ///
  /// Broadcast intent action sent by the download manager when a download completes.
  static const ACTION_DOWNLOAD_COMPLETE =
      "android.intent.action.DOWNLOAD_COMPLETE";

  /// from: static public final java.lang.String ACTION_NOTIFICATION_CLICKED
  ///
  /// Broadcast intent action sent by the download manager when the user clicks on a running
  /// download, either from a system notification or from the downloads UI.
  static const ACTION_NOTIFICATION_CLICKED =
      "android.intent.action.DOWNLOAD_NOTIFICATION_CLICKED";

  /// from: static public final java.lang.String ACTION_VIEW_DOWNLOADS
  ///
  /// Intent action to launch an activity to display all downloads.
  static const ACTION_VIEW_DOWNLOADS = "android.intent.action.VIEW_DOWNLOADS";

  /// from: static public final java.lang.String COLUMN_BYTES_DOWNLOADED_SO_FAR
  ///
  /// Number of bytes download so far.
  static const COLUMN_BYTES_DOWNLOADED_SO_FAR = "bytes_so_far";

  /// from: static public final java.lang.String COLUMN_DESCRIPTION
  ///
  /// The client-supplied description of this download.  This will be displayed in system
  /// notifications.  Defaults to the empty string.
  static const COLUMN_DESCRIPTION = "description";

  /// from: static public final java.lang.String COLUMN_ID
  ///
  /// An identifier for a particular download, unique across the system.  Clients use this ID to
  /// make subsequent calls related to the download.
  static const COLUMN_ID = "_id";

  /// from: static public final java.lang.String COLUMN_LAST_MODIFIED_TIMESTAMP
  ///
  /// Timestamp when the download was last modified, in System\#currentTimeMillis System.currentTimeMillis() (wall clock time in UTC).
  static const COLUMN_LAST_MODIFIED_TIMESTAMP = "last_modified_timestamp";

  /// from: static public final java.lang.String COLUMN_LOCAL_FILENAME
  ///
  /// Path to the downloaded file on disk.
  ///
  /// Note that apps may not have filesystem permissions to directly access
  /// this path. Instead of trying to open this path directly, apps should use
  /// ContentResolver\#openFileDescriptor(Uri, String) to gain access.
  ///@deprecated apps should transition to using
  ///             ContentResolver\#openFileDescriptor(Uri, String)
  ///             instead.
  static const COLUMN_LOCAL_FILENAME = "local_filename";

  /// from: static public final java.lang.String COLUMN_LOCAL_URI
  ///
  /// Uri where downloaded file will be stored.  If a destination is supplied by client, that URI
  /// will be used here.  Otherwise, the value will initially be null and will be filled in with a
  /// generated URI once the download has started.
  static const COLUMN_LOCAL_URI = "local_uri";

  /// from: static public final java.lang.String COLUMN_MEDIAPROVIDER_URI
  ///
  /// The URI to the corresponding entry in MediaProvider for this downloaded entry. It is
  /// used to delete the entries from MediaProvider database when it is deleted from the
  /// downloaded list.
  static const COLUMN_MEDIAPROVIDER_URI = "mediaprovider_uri";

  /// from: static public final java.lang.String COLUMN_MEDIA_TYPE
  ///
  /// Internet Media Type of the downloaded file.  If no value is provided upon creation, this will
  /// initially be null and will be filled in based on the server's response once the download has
  /// started.
  ///@see <a href="http://www.ietf.org/rfc/rfc1590.txt">RFC 1590, defining Media Types</a>
  static const COLUMN_MEDIA_TYPE = "media_type";

  /// from: static public final java.lang.String COLUMN_REASON
  ///
  /// Provides more detail on the status of the download.  Its meaning depends on the value of
  /// \#COLUMN_STATUS.
  ///
  /// When \#COLUMN_STATUS is \#STATUS_FAILED, this indicates the type of error that
  /// occurred.  If an HTTP error occurred, this will hold the HTTP status code as defined in RFC
  /// 2616.  Otherwise, it will hold one of the ERROR_* constants.
  ///
  /// When \#COLUMN_STATUS is \#STATUS_PAUSED, this indicates why the download is
  /// paused.  It will hold one of the PAUSED_* constants.
  ///
  /// If \#COLUMN_STATUS is neither \#STATUS_FAILED nor \#STATUS_PAUSED, this
  /// column's value is undefined.
  ///@see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html\#sec6.1.1">RFC 2616
  /// status codes</a>
  static const COLUMN_REASON = "reason";

  /// from: static public final java.lang.String COLUMN_STATUS
  ///
  /// Current status of the download, as one of the STATUS_* constants.
  static const COLUMN_STATUS = "status";

  /// from: static public final java.lang.String COLUMN_TITLE
  ///
  /// The client-supplied title for this download.  This will be displayed in system notifications.
  /// Defaults to the empty string.
  static const COLUMN_TITLE = "title";

  /// from: static public final java.lang.String COLUMN_TOTAL_SIZE_BYTES
  ///
  /// Total size of the download in bytes.  This will initially be -1 and will be filled in once
  /// the download starts.
  static const COLUMN_TOTAL_SIZE_BYTES = "total_size";

  /// from: static public final java.lang.String COLUMN_URI
  ///
  /// URI to be downloaded.
  static const COLUMN_URI = "uri";

  /// from: static public final int ERROR_CANNOT_RESUME
  ///
  /// Value of \#COLUMN_REASON when some possibly transient error occurred but we can't
  /// resume the download.
  static const ERROR_CANNOT_RESUME = 1008;

  /// from: static public final int ERROR_DEVICE_NOT_FOUND
  ///
  /// Value of \#COLUMN_REASON when no external storage device was found. Typically,
  /// this is because the SD card is not mounted.
  static const ERROR_DEVICE_NOT_FOUND = 1007;

  /// from: static public final int ERROR_FILE_ALREADY_EXISTS
  ///
  /// Value of \#COLUMN_REASON when the requested destination file already exists (the
  /// download manager will not overwrite an existing file).
  static const ERROR_FILE_ALREADY_EXISTS = 1009;

  /// from: static public final int ERROR_FILE_ERROR
  ///
  /// Value of \#COLUMN_REASON when a storage issue arises which doesn't fit under any
  /// other error code. Use the more specific \#ERROR_INSUFFICIENT_SPACE and
  /// \#ERROR_DEVICE_NOT_FOUND when appropriate.
  static const ERROR_FILE_ERROR = 1001;

  /// from: static public final int ERROR_HTTP_DATA_ERROR
  ///
  /// Value of \#COLUMN_REASON when an error receiving or processing data occurred at
  /// the HTTP level.
  static const ERROR_HTTP_DATA_ERROR = 1004;

  /// from: static public final int ERROR_INSUFFICIENT_SPACE
  ///
  /// Value of \#COLUMN_REASON when there was insufficient storage space. Typically,
  /// this is because the SD card is full.
  static const ERROR_INSUFFICIENT_SPACE = 1006;

  /// from: static public final int ERROR_TOO_MANY_REDIRECTS
  ///
  /// Value of \#COLUMN_REASON when there were too many redirects.
  static const ERROR_TOO_MANY_REDIRECTS = 1005;

  /// from: static public final int ERROR_UNHANDLED_HTTP_CODE
  ///
  /// Value of \#COLUMN_REASON when an HTTP code was received that download manager
  /// can't handle.
  static const ERROR_UNHANDLED_HTTP_CODE = 1002;

  /// from: static public final int ERROR_UNKNOWN
  ///
  /// Value of COLUMN_ERROR_CODE when the download has completed with an error that doesn't fit
  /// under any other error code.
  static const ERROR_UNKNOWN = 1000;

  /// from: static public final java.lang.String EXTRA_DOWNLOAD_ID
  ///
  /// Intent extra included with \#ACTION_DOWNLOAD_COMPLETE intents, indicating the ID (as a
  /// long) of the download that just completed.
  static const EXTRA_DOWNLOAD_ID = "extra_download_id";

  /// from: static public final java.lang.String EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS
  ///
  /// When clicks on multiple notifications are received, the following
  /// provides an array of download ids corresponding to the download notification that was
  /// clicked. It can be retrieved by the receiver of this
  /// Intent using android.content.Intent\#getLongArrayExtra(String).
  static const EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS =
      "extra_click_download_ids";

  /// from: static public final java.lang.String INTENT_EXTRAS_SORT_BY_SIZE
  ///
  /// Intent extra included with \#ACTION_VIEW_DOWNLOADS to start DownloadApp in
  /// sort-by-size mode.
  static const INTENT_EXTRAS_SORT_BY_SIZE =
      "android.app.DownloadManager.extra_sortBySize";

  /// from: static public final int PAUSED_QUEUED_FOR_WIFI
  ///
  /// Value of \#COLUMN_REASON when the download exceeds a size limit for downloads over
  /// the mobile network and the download manager is waiting for a Wi-Fi connection to proceed.
  static const PAUSED_QUEUED_FOR_WIFI = 3;

  /// from: static public final int PAUSED_UNKNOWN
  ///
  /// Value of \#COLUMN_REASON when the download is paused for some other reason.
  static const PAUSED_UNKNOWN = 4;

  /// from: static public final int PAUSED_WAITING_FOR_NETWORK
  ///
  /// Value of \#COLUMN_REASON when the download is waiting for network connectivity to
  /// proceed.
  static const PAUSED_WAITING_FOR_NETWORK = 2;

  /// from: static public final int PAUSED_WAITING_TO_RETRY
  ///
  /// Value of \#COLUMN_REASON when the download is paused because some network error
  /// occurred and the download manager is waiting before retrying the request.
  static const PAUSED_WAITING_TO_RETRY = 1;

  /// from: static public final int STATUS_FAILED
  ///
  /// Value of \#COLUMN_STATUS when the download has failed (and will not be retried).
  static const STATUS_FAILED = 16;

  /// from: static public final int STATUS_PAUSED
  ///
  /// Value of \#COLUMN_STATUS when the download is waiting to retry or resume.
  static const STATUS_PAUSED = 4;

  /// from: static public final int STATUS_PENDING
  ///
  /// Value of \#COLUMN_STATUS when the download is waiting to start.
  static const STATUS_PENDING = 1;

  /// from: static public final int STATUS_RUNNING
  ///
  /// Value of \#COLUMN_STATUS when the download is currently running.
  static const STATUS_RUNNING = 2;

  /// from: static public final int STATUS_SUCCESSFUL
  ///
  /// Value of \#COLUMN_STATUS when the download has successfully completed.
  static const STATUS_SUCCESSFUL = 8;

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DownloadManager__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.content.Context context)
  ///
  /// @hide
  DownloadManager(content_.Context context)
      : super.fromRef(_ctor(context.reference).object);

  static final _enqueue = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DownloadManager__enqueue")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public long enqueue(android.app.DownloadManager.Request request)
  ///
  /// Enqueue a new download.  The download will start automatically once the download manager is
  /// ready to execute it and connectivity is available.
  ///@param request the parameters specifying this download
  ///@return an ID for the download, unique across the system.  This ID is used to make future
  /// calls related to this download.
  int enqueue(DownloadManager_Request request) =>
      _enqueue(reference, request.reference).long;

  static final _remove = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DownloadManager__remove")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int remove(long[] ids)
  ///
  /// Cancel downloads and remove them from the download manager.  Each download will be stopped if
  /// it was running, and it will no longer be accessible through the download manager.
  /// If there is a downloaded file, partial or complete, it is deleted.
  ///@param ids the IDs of the downloads to remove
  ///@return the number of downloads actually removed
  int remove(jni.JniObject ids) => _remove(reference, ids.reference).integer;

  static final _query = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DownloadManager__query")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.database.Cursor query(android.app.DownloadManager.Query query)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query the download manager about downloads that have been requested.
  ///@param query parameters specifying filters for this query
  ///@return a Cursor over the result set of downloads, with columns consisting of all the
  /// COLUMN_* constants.
  jni.JniObject query(DownloadManager_Query query) =>
      jni.JniObject.fromRef(_query(reference, query.reference).object);

  static final _openDownloadedFile = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("DownloadManager__openDownloadedFile")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.os.ParcelFileDescriptor openDownloadedFile(long id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Open a downloaded file for reading.  The download must have completed.
  ///@param id the ID of the download
  ///@return a read-only ParcelFileDescriptor
  ///@throws FileNotFoundException if the destination file does not already exist
  os_.ParcelFileDescriptor openDownloadedFile(int id) =>
      os_.ParcelFileDescriptor.fromRef(
          _openDownloadedFile(reference, id).object);

  static final _getUriForDownloadedFile = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("DownloadManager__getUriForDownloadedFile")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.net.Uri getUriForDownloadedFile(long id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Uri of the given downloaded file id, if the file is
  /// downloaded successfully. Otherwise, null is returned.
  ///@param id the id of the downloaded file.
  ///@return the Uri of the given downloaded file id, if download was
  ///         successful. null otherwise.
  jni.JniObject getUriForDownloadedFile(int id) =>
      jni.JniObject.fromRef(_getUriForDownloadedFile(reference, id).object);

  static final _getMimeTypeForDownloadedFile = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("DownloadManager__getMimeTypeForDownloadedFile")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.String getMimeTypeForDownloadedFile(long id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the media type of the given downloaded file id, if the file was
  /// downloaded successfully. Otherwise, null is returned.
  ///@param id the id of the downloaded file.
  ///@return the media type of the given downloaded file id, if download was successful. null
  /// otherwise.
  jni.JniString getMimeTypeForDownloadedFile(int id) => jni.JniString.fromRef(
      _getMimeTypeForDownloadedFile(reference, id).object);

  static final _getMaxBytesOverMobile = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DownloadManager__getMaxBytesOverMobile")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.Long getMaxBytesOverMobile(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns maximum size, in bytes, of downloads that may go over a mobile connection; or null if
  /// there's no limit
  ///@param context the Context to use for accessing the ContentResolver
  ///@return maximum size, in bytes, of downloads that may go over a mobile connection; or null if
  /// there's no limit
  static jni.JniObject getMaxBytesOverMobile(content_.Context context) =>
      jni.JniObject.fromRef(_getMaxBytesOverMobile(context.reference).object);

  static final _getRecommendedMaxBytesOverMobile = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DownloadManager__getRecommendedMaxBytesOverMobile")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.Long getRecommendedMaxBytesOverMobile(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns recommended maximum size, in bytes, of downloads that may go over a mobile
  /// connection; or null if there's no recommended limit.  The user will have the option to bypass
  /// this limit.
  ///@param context the Context to use for accessing the ContentResolver
  ///@return recommended maximum size, in bytes, of downloads that may go over a mobile
  /// connection; or null if there's no recommended limit.
  static jni.JniObject getRecommendedMaxBytesOverMobile(
          content_.Context context) =>
      jni.JniObject.fromRef(
          _getRecommendedMaxBytesOverMobile(context.reference).object);

  static final _addCompletedDownload = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Uint8)>>("DownloadManager__addCompletedDownload")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int)>();

  /// from: public long addCompletedDownload(java.lang.String title, java.lang.String description, boolean isMediaScannerScannable, java.lang.String mimeType, java.lang.String path, long length, boolean showNotification)
  ///
  /// Adds a file to the downloads database system, so it could appear in Downloads App
  /// (and thus become eligible for management by the Downloads App).
  ///
  /// It is helpful to make the file scannable by MediaScanner by setting the param
  /// isMediaScannerScannable to true. It makes the file visible in media managing
  /// applications such as Gallery App, which could be a useful purpose of using this API.
  ///@param title the title that would appear for this file in Downloads App.
  ///@param description the description that would appear for this file in Downloads App.
  ///@param isMediaScannerScannable true if the file is to be scanned by MediaScanner. Files
  /// scanned by MediaScanner appear in the applications used to view media (for example,
  /// Gallery app).
  ///@param mimeType mimetype of the file.
  ///@param path absolute pathname to the file. The file should be world-readable, so that it can
  /// be managed by the Downloads App and any other app that is used to read it (for example,
  /// Gallery app to display the file, if the file contents represent a video/image).
  ///@param length length of the downloaded file
  ///@param showNotification true if a notification is to be sent, false otherwise
  ///@return an ID for the download entry added to the downloads app, unique across the system
  /// This ID is used to make future calls related to this download.
  int addCompletedDownload(
          jni.JniString title,
          jni.JniString description,
          bool isMediaScannerScannable,
          jni.JniString mimeType,
          jni.JniString path,
          int length,
          bool showNotification) =>
      _addCompletedDownload(
              reference,
              title.reference,
              description.reference,
              isMediaScannerScannable ? 1 : 0,
              mimeType.reference,
              path.reference,
              length,
              showNotification ? 1 : 0)
          .long;

  static final _addCompletedDownload1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Uint8,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int64,
                      ffi.Uint8,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DownloadManager__addCompletedDownload1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public long addCompletedDownload(java.lang.String title, java.lang.String description, boolean isMediaScannerScannable, java.lang.String mimeType, java.lang.String path, long length, boolean showNotification, android.net.Uri uri, android.net.Uri referer)
  ///
  /// Adds a file to the downloads database system, so it could appear in Downloads App
  /// (and thus become eligible for management by the Downloads App).
  ///
  /// It is helpful to make the file scannable by MediaScanner by setting the param
  /// isMediaScannerScannable to true. It makes the file visible in media managing
  /// applications such as Gallery App, which could be a useful purpose of using this API.
  ///@param title the title that would appear for this file in Downloads App.
  ///@param description the description that would appear for this file in Downloads App.
  ///@param isMediaScannerScannable true if the file is to be scanned by MediaScanner. Files
  /// scanned by MediaScanner appear in the applications used to view media (for example,
  /// Gallery app).
  ///@param mimeType mimetype of the file.
  ///@param path absolute pathname to the file. The file should be world-readable, so that it can
  /// be managed by the Downloads App and any other app that is used to read it (for example,
  /// Gallery app to display the file, if the file contents represent a video/image).
  ///@param length length of the downloaded file
  ///@param showNotification true if a notification is to be sent, false otherwise
  ///@param uri the original HTTP URI of the download
  ///@param referer the HTTP Referer for the download
  ///@return an ID for the download entry added to the downloads app, unique across the system
  /// This ID is used to make future calls related to this download.
  int addCompletedDownload1(
          jni.JniString title,
          jni.JniString description,
          bool isMediaScannerScannable,
          jni.JniString mimeType,
          jni.JniString path,
          int length,
          bool showNotification,
          jni.JniObject uri,
          jni.JniObject referer) =>
      _addCompletedDownload1(
              reference,
              title.reference,
              description.reference,
              isMediaScannerScannable ? 1 : 0,
              mimeType.reference,
              path.reference,
              length,
              showNotification ? 1 : 0,
              uri.reference,
              referer.reference)
          .long;
}

/// from: android.app.DownloadManager$Request
///
/// This class contains all the information necessary to request a new download. The URI is the
/// only required parameter.
///
/// Note that the default download destination is a shared volume where the system might delete
/// your file if it needs to reclaim space for system use. If this is a problem, use a location
/// on external storage (see \#setDestinationUri(Uri).
class DownloadManager_Request extends jni.JniObject {
  DownloadManager_Request.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final int NETWORK_MOBILE
  ///
  /// Bit flag for \#setAllowedNetworkTypes corresponding to
  /// ConnectivityManager\#TYPE_MOBILE.
  static const NETWORK_MOBILE = 1;

  /// from: static public final int NETWORK_WIFI
  ///
  /// Bit flag for \#setAllowedNetworkTypes corresponding to
  /// ConnectivityManager\#TYPE_WIFI.
  static const NETWORK_WIFI = 2;

  /// from: static public final int VISIBILITY_HIDDEN
  ///
  /// This download doesn't show in the UI or in the notifications.
  static const VISIBILITY_HIDDEN = 2;

  /// from: static public final int VISIBILITY_VISIBLE
  ///
  /// This download is visible but only shows in the notifications
  /// while it's in progress.
  static const VISIBILITY_VISIBLE = 0;

  /// from: static public final int VISIBILITY_VISIBLE_NOTIFY_COMPLETED
  ///
  /// This download is visible and shows in the notifications while
  /// in progress and after completion.
  static const VISIBILITY_VISIBLE_NOTIFY_COMPLETED = 1;

  /// from: static public final int VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION
  ///
  /// This download shows in the notifications after completion ONLY.
  /// It is usuable only with
  /// DownloadManager\#addCompletedDownload(String, String,
  /// boolean, String, String, long, boolean).
  static const VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION = 3;

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("DownloadManager_Request__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.net.Uri uri)
  ///
  /// @param uri the HTTP or HTTPS URI to download.
  DownloadManager_Request(jni.JniObject uri)
      : super.fromRef(_ctor(uri.reference).object);

  static final _setDestinationUri = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DownloadManager_Request__setDestinationUri")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.DownloadManager.Request setDestinationUri(android.net.Uri uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the local destination for the downloaded file. Must be a file URI to a path on
  /// external storage, and the calling application must have the WRITE_EXTERNAL_STORAGE
  /// permission.
  ///
  /// The downloaded file is not scanned by MediaScanner.
  /// But it can be made scannable by calling \#allowScanningByMediaScanner().
  ///
  /// By default, downloads are saved to a generated filename in the shared download cache and
  /// may be deleted by the system at any time to reclaim space.
  ///@return this object
  DownloadManager_Request setDestinationUri(jni.JniObject uri) =>
      DownloadManager_Request.fromRef(
          _setDestinationUri(reference, uri.reference).object);

  static final _setDestinationInExternalFilesDir = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "DownloadManager_Request__setDestinationInExternalFilesDir")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.DownloadManager.Request setDestinationInExternalFilesDir(android.content.Context context, java.lang.String dirType, java.lang.String subPath)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the local destination for the downloaded file to a path within
  /// the application's external files directory (as returned by
  /// Context\#getExternalFilesDir(String).
  ///
  /// The downloaded file is not scanned by MediaScanner. But it can be
  /// made scannable by calling \#allowScanningByMediaScanner().
  ///@param context the Context to use in determining the external
  ///            files directory
  ///@param dirType the directory type to pass to
  ///            Context\#getExternalFilesDir(String)
  ///@param subPath the path within the external directory, including the
  ///            destination filename
  ///@return this object
  ///@throws IllegalStateException If the external storage directory
  ///             cannot be found or created.
  DownloadManager_Request setDestinationInExternalFilesDir(
          content_.Context context,
          jni.JniString dirType,
          jni.JniString subPath) =>
      DownloadManager_Request.fromRef(_setDestinationInExternalFilesDir(
              reference,
              context.reference,
              dirType.reference,
              subPath.reference)
          .object);

  static final _setDestinationInExternalPublicDir = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DownloadManager_Request__setDestinationInExternalPublicDir")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.DownloadManager.Request setDestinationInExternalPublicDir(java.lang.String dirType, java.lang.String subPath)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the local destination for the downloaded file to a path within
  /// the public external storage directory (as returned by
  /// Environment\#getExternalStoragePublicDirectory(String)).
  ///
  /// The downloaded file is not scanned by MediaScanner. But it can be
  /// made scannable by calling \#allowScanningByMediaScanner().
  ///@param dirType the directory type to pass to Environment\#getExternalStoragePublicDirectory(String)
  ///@param subPath the path within the external directory, including the
  ///            destination filename
  ///@return this object
  ///@throws IllegalStateException If the external storage directory
  ///             cannot be found or created.
  DownloadManager_Request setDestinationInExternalPublicDir(
          jni.JniString dirType, jni.JniString subPath) =>
      DownloadManager_Request.fromRef(_setDestinationInExternalPublicDir(
              reference, dirType.reference, subPath.reference)
          .object);

  static final _allowScanningByMediaScanner = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "DownloadManager_Request__allowScanningByMediaScanner")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void allowScanningByMediaScanner()
  ///
  /// If the file to be downloaded is to be scanned by MediaScanner, this method
  /// should be called before DownloadManager\#enqueue(Request) is called.
  void allowScanningByMediaScanner() =>
      _allowScanningByMediaScanner(reference).check();

  static final _addRequestHeader = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DownloadManager_Request__addRequestHeader")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.DownloadManager.Request addRequestHeader(java.lang.String header, java.lang.String value)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add an HTTP header to be included with the download request.  The header will be added to
  /// the end of the list.
  ///@param header HTTP header name
  ///@param value header value
  ///@return this object
  ///@see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html\#sec4.2">HTTP/1.1
  ///      Message Headers</a>
  DownloadManager_Request addRequestHeader(
          jni.JniString header, jni.JniString value) =>
      DownloadManager_Request.fromRef(
          _addRequestHeader(reference, header.reference, value.reference)
              .object);

  static final _setTitle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("DownloadManager_Request__setTitle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.DownloadManager.Request setTitle(java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the title of this download, to be displayed in notifications (if enabled).  If no
  /// title is given, a default one will be assigned based on the download filename, once the
  /// download starts.
  ///@return this object
  DownloadManager_Request setTitle(jni.JniObject title) =>
      DownloadManager_Request.fromRef(
          _setTitle(reference, title.reference).object);

  static final _setDescription = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DownloadManager_Request__setDescription")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.DownloadManager.Request setDescription(java.lang.CharSequence description)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a description of this download, to be displayed in notifications (if enabled)
  ///@return this object
  DownloadManager_Request setDescription(jni.JniObject description) =>
      DownloadManager_Request.fromRef(
          _setDescription(reference, description.reference).object);

  static final _setMimeType = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DownloadManager_Request__setMimeType")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.DownloadManager.Request setMimeType(java.lang.String mimeType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the MIME content type of this download.  This will override the content type declared
  /// in the server's response.
  ///@see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html\#sec3.7">HTTP/1.1
  ///      Media Types</a>
  ///@return this object
  DownloadManager_Request setMimeType(jni.JniString mimeType) =>
      DownloadManager_Request.fromRef(
          _setMimeType(reference, mimeType.reference).object);

  static final _setShowRunningNotification = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "DownloadManager_Request__setShowRunningNotification")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.DownloadManager.Request setShowRunningNotification(boolean show)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Control whether a system notification is posted by the download manager while this
  /// download is running. If enabled, the download manager posts notifications about downloads
  /// through the system android.app.NotificationManager. By default, a notification is
  /// shown.
  ///
  /// If set to false, this requires the permission
  /// android.permission.DOWNLOAD_WITHOUT_NOTIFICATION.
  ///@param show whether the download manager should show a notification for this download.
  ///@return this object
  ///@deprecated use \#setNotificationVisibility(int)
  DownloadManager_Request setShowRunningNotification(bool show0) =>
      DownloadManager_Request.fromRef(
          _setShowRunningNotification(reference, show0 ? 1 : 0).object);

  static final _setNotificationVisibility = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "DownloadManager_Request__setNotificationVisibility")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.DownloadManager.Request setNotificationVisibility(int visibility)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Control whether a system notification is posted by the download manager while this
  /// download is running or when it is completed.
  /// If enabled, the download manager posts notifications about downloads
  /// through the system android.app.NotificationManager.
  /// By default, a notification is shown only when the download is in progress.
  ///
  /// It can take the following values: \#VISIBILITY_HIDDEN,
  /// \#VISIBILITY_VISIBLE,
  /// \#VISIBILITY_VISIBLE_NOTIFY_COMPLETED.
  ///
  /// If set to \#VISIBILITY_HIDDEN, this requires the permission
  /// android.permission.DOWNLOAD_WITHOUT_NOTIFICATION.
  ///@param visibility the visibility setting value
  ///@return this object
  DownloadManager_Request setNotificationVisibility(int visibility) =>
      DownloadManager_Request.fromRef(
          _setNotificationVisibility(reference, visibility).object);

  static final _setAllowedNetworkTypes = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "DownloadManager_Request__setAllowedNetworkTypes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.DownloadManager.Request setAllowedNetworkTypes(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Restrict the types of networks over which this download may proceed.
  /// By default, all network types are allowed. Consider using
  /// \#setAllowedOverMetered(boolean) instead, since it's more
  /// flexible.
  ///
  /// As of android.os.Build.VERSION_CODES\#N, setting only the
  /// \#NETWORK_WIFI flag here is equivalent to calling
  /// \#setAllowedOverMetered(boolean) with {@code false}.
  ///@param flags any combination of the NETWORK_* bit flags.
  ///@return this object
  DownloadManager_Request setAllowedNetworkTypes(int flags) =>
      DownloadManager_Request.fromRef(
          _setAllowedNetworkTypes(reference, flags).object);

  static final _setAllowedOverRoaming = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DownloadManager_Request__setAllowedOverRoaming")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.DownloadManager.Request setAllowedOverRoaming(boolean allowed)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether this download may proceed over a roaming connection.  By default, roaming is
  /// allowed.
  ///@param allowed whether to allow a roaming connection to be used
  ///@return this object
  DownloadManager_Request setAllowedOverRoaming(bool allowed) =>
      DownloadManager_Request.fromRef(
          _setAllowedOverRoaming(reference, allowed ? 1 : 0).object);

  static final _setAllowedOverMetered = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DownloadManager_Request__setAllowedOverMetered")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.DownloadManager.Request setAllowedOverMetered(boolean allow)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether this download may proceed over a metered network
  /// connection. By default, metered networks are allowed.
  ///@see ConnectivityManager\#isActiveNetworkMetered()
  DownloadManager_Request setAllowedOverMetered(bool allow) =>
      DownloadManager_Request.fromRef(
          _setAllowedOverMetered(reference, allow ? 1 : 0).object);

  static final _setRequiresCharging = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DownloadManager_Request__setRequiresCharging")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.DownloadManager.Request setRequiresCharging(boolean requiresCharging)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify that to run this download, the device needs to be plugged in.
  /// This defaults to false.
  ///@param requiresCharging Whether or not the device is plugged in.
  ///@see android.app.job.JobInfo.Builder\#setRequiresCharging(boolean)
  DownloadManager_Request setRequiresCharging(bool requiresCharging) =>
      DownloadManager_Request.fromRef(
          _setRequiresCharging(reference, requiresCharging ? 1 : 0).object);

  static final _setRequiresDeviceIdle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("DownloadManager_Request__setRequiresDeviceIdle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.DownloadManager.Request setRequiresDeviceIdle(boolean requiresDeviceIdle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify that to run, the download needs the device to be in idle
  /// mode. This defaults to false.
  ///
  /// Idle mode is a loose definition provided by the system, which means
  /// that the device is not in use, and has not been in use for some time.
  ///@param requiresDeviceIdle Whether or not the device need be within an
  ///            idle maintenance window.
  ///@see android.app.job.JobInfo.Builder\#setRequiresDeviceIdle(boolean)
  DownloadManager_Request setRequiresDeviceIdle(bool requiresDeviceIdle) =>
      DownloadManager_Request.fromRef(
          _setRequiresDeviceIdle(reference, requiresDeviceIdle ? 1 : 0).object);

  static final _setVisibleInDownloadsUi = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "DownloadManager_Request__setVisibleInDownloadsUi")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.DownloadManager.Request setVisibleInDownloadsUi(boolean isVisible)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether this download should be displayed in the system's Downloads UI. True by
  /// default.
  ///@param isVisible whether to display this download in the Downloads UI
  ///@return this object
  DownloadManager_Request setVisibleInDownloadsUi(bool isVisible) =>
      DownloadManager_Request.fromRef(
          _setVisibleInDownloadsUi(reference, isVisible ? 1 : 0).object);
}

/// from: android.app.DownloadManager$Query
///
/// This class may be used to filter download manager queries.
class DownloadManager_Query extends jni.JniObject {
  DownloadManager_Query.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "DownloadManager_Query__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  DownloadManager_Query() : super.fromRef(_ctor().object);

  static final _setFilterById = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "DownloadManager_Query__setFilterById")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.DownloadManager.Query setFilterById(long[] ids)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Include only the downloads with the given IDs.
  ///@return this object
  DownloadManager_Query setFilterById(jni.JniObject ids) =>
      DownloadManager_Query.fromRef(
          _setFilterById(reference, ids.reference).object);

  static final _setFilterByStatus = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("DownloadManager_Query__setFilterByStatus")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.DownloadManager.Query setFilterByStatus(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Include only downloads with status matching any the given status flags.
  ///@param flags any combination of the STATUS_* bit flags
  ///@return this object
  DownloadManager_Query setFilterByStatus(int flags) =>
      DownloadManager_Query.fromRef(
          _setFilterByStatus(reference, flags).object);
}

/// from: android.app.ExpandableListActivity
///
/// An activity that displays an expandable list of items by binding to a data
/// source implementing the ExpandableListAdapter, and exposes event handlers
/// when the user selects an item.
///
/// ExpandableListActivity hosts a
/// android.widget.ExpandableListView ExpandableListView object that can
/// be bound to different data sources that provide a two-levels of data (the
/// top-level is group, and below each group are children). Binding, screen
/// layout, and row layout are discussed in the following sections.
///
/// <strong>Screen Layout</strong>
///
///
///
/// ExpandableListActivity has a default layout that consists of a single,
/// full-screen, centered expandable list. However, if you desire, you can
/// customize the screen layout by setting your own view layout with
/// setContentView() in onCreate(). To do this, your own view MUST contain an
/// ExpandableListView object with the id "@android:id/list" (or
/// android.R.id\#list if it's in code)
///
/// Optionally, your custom view can contain another view object of any type to
/// display when the list view is empty. This "empty list" notifier must have an
/// id "android:empty". Note that when an empty view is present, the expandable
/// list view will be hidden when there is no data to display.
///
/// The following code demonstrates an (ugly) custom screen layout. It has a list
/// with a green background, and an alternate red "no data" message.
///
///
///
/// <pre>
/// &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
/// &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
///         android:orientation=&quot;vertical&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;match_parent&quot;
///         android:paddingLeft=&quot;8dp&quot;
///         android:paddingRight=&quot;8dp&quot;&gt;
///
///     &lt;ExpandableListView android:id=&quot;@id/android:list&quot;
///               android:layout_width=&quot;match_parent&quot;
///               android:layout_height=&quot;match_parent&quot;
///               android:background=&quot;\#00FF00&quot;
///               android:layout_weight=&quot;1&quot;
///               android:drawSelectorOnTop=&quot;false&quot;/&gt;
///
///     &lt;TextView android:id=&quot;@id/android:empty&quot;
///               android:layout_width=&quot;match_parent&quot;
///               android:layout_height=&quot;match_parent&quot;
///               android:background=&quot;\#FF0000&quot;
///               android:text=&quot;No data&quot;/&gt;
/// &lt;/LinearLayout&gt;
/// </pre>
///
///
/// <strong>Row Layout</strong>
///
///
/// The ExpandableListAdapter set in the ExpandableListActivity
/// via \#setListAdapter(ExpandableListAdapter) provides the Views
/// for each row. This adapter has separate methods for providing the group
/// Views and child Views. There are a couple provided
/// ExpandableListAdapters that simplify use of adapters:
/// SimpleCursorTreeAdapter and SimpleExpandableListAdapter.
///
/// With these, you can specify the layout of individual rows for groups and
/// children in the list. These constructor takes a few parameters that specify
/// layout resources for groups and children. It also has additional parameters
/// that let you specify which data field to associate with which object in the
/// row layout resource. The SimpleCursorTreeAdapter fetches data from
/// Cursors and the SimpleExpandableListAdapter fetches data
/// from Lists of Maps.
///
///
///
/// Android provides some standard row layout resources. These are in the
/// android.R.layout class, and have names such as simple_list_item_1,
/// simple_list_item_2, and two_line_list_item. The following layout XML is the
/// source for the resource two_line_list_item, which displays two data
/// fields,one above the other, for each list row.
///
///
///
/// <pre>
/// &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
/// &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
///     android:layout_width=&quot;match_parent&quot;
///     android:layout_height=&quot;wrap_content&quot;
///     android:orientation=&quot;vertical&quot;&gt;
///
///     &lt;TextView android:id=&quot;@+id/text1&quot;
///         android:textSize=&quot;16sp&quot;
///         android:textStyle=&quot;bold&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;wrap_content&quot;/&gt;
///
///     &lt;TextView android:id=&quot;@+id/text2&quot;
///         android:textSize=&quot;16sp&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;wrap_content&quot;/&gt;
/// &lt;/LinearLayout&gt;
/// </pre>
///
///
/// You must identify the data bound to each TextView object in this layout. The
/// syntax for this is discussed in the next section.
///
///
///
/// <strong>Binding to Data</strong>
///
///
///
/// You bind the ExpandableListActivity's ExpandableListView object to data using
/// a class that implements the
/// android.widget.ExpandableListAdapter ExpandableListAdapter interface.
/// Android provides two standard list adapters:
/// android.widget.SimpleExpandableListAdapter SimpleExpandableListAdapter
/// for static data (Maps), and
/// android.widget.SimpleCursorTreeAdapter SimpleCursorTreeAdapter for
/// Cursor query results.
///
///
///@see \#setListAdapter
///@see android.widget.ExpandableListView
class ExpandableListActivity extends Activity {
  ExpandableListActivity.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ExpandableListActivity__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ExpandableListActivity() : super.fromRef(_ctor().object);

  static final _onCreateContextMenu = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "ExpandableListActivity__onCreateContextMenu")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreateContextMenu(android.view.ContextMenu menu, android.view.View v, android.view.ContextMenu.ContextMenuInfo menuInfo)
  ///
  /// Override this to populate the context menu when an item is long pressed. menuInfo
  /// will contain an android.widget.ExpandableListView.ExpandableListContextMenuInfo
  /// whose packedPosition is a packed position
  /// that should be used with ExpandableListView\#getPackedPositionType(long) and
  /// the other similar methods.
  ///
  /// {@inheritDoc}
  void onCreateContextMenu(
          jni.JniObject menu, jni.JniObject v, jni.JniObject menuInfo) =>
      _onCreateContextMenu(
              reference, menu.reference, v.reference, menuInfo.reference)
          .check();

  static final _onChildClick = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int64)>>("ExpandableListActivity__onChildClick")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public boolean onChildClick(android.widget.ExpandableListView parent, android.view.View v, int groupPosition, int childPosition, long id)
  ///
  /// Override this for receiving callbacks when a child has been clicked.
  ///
  /// {@inheritDoc}
  bool onChildClick(jni.JniObject parent, jni.JniObject v, int groupPosition,
          int childPosition, int id) =>
      _onChildClick(reference, parent.reference, v.reference, groupPosition,
              childPosition, id)
          .boolean;

  static final _onGroupCollapse = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ExpandableListActivity__onGroupCollapse")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onGroupCollapse(int groupPosition)
  ///
  /// Override this for receiving callbacks when a group has been collapsed.
  void onGroupCollapse(int groupPosition) =>
      _onGroupCollapse(reference, groupPosition).check();

  static final _onGroupExpand = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ExpandableListActivity__onGroupExpand")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onGroupExpand(int groupPosition)
  ///
  /// Override this for receiving callbacks when a group has been expanded.
  void onGroupExpand(int groupPosition) =>
      _onGroupExpand(reference, groupPosition).check();

  static final _onRestoreInstanceState = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ExpandableListActivity__onRestoreInstanceState")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onRestoreInstanceState(android.os.Bundle state)
  ///
  /// Ensures the expandable list view has been created before Activity restores all
  /// of the view states.
  ///@see Activity\#onRestoreInstanceState(Bundle)
  void onRestoreInstanceState(os_.Bundle state) =>
      _onRestoreInstanceState(reference, state.reference).check();

  static final _onContentChanged = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ExpandableListActivity__onContentChanged")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onContentChanged()
  ///
  /// Updates the screen state (current list and other views) when the
  /// content changes.
  ///@see Activity\#onContentChanged()
  void onContentChanged() => _onContentChanged(reference).check();

  static final _setListAdapter = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ExpandableListActivity__setListAdapter")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setListAdapter(android.widget.ExpandableListAdapter adapter)
  ///
  /// Provide the adapter for the expandable list.
  void setListAdapter(jni.JniObject adapter) =>
      _setListAdapter(reference, adapter.reference).check();

  static final _getExpandableListView = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ExpandableListActivity__getExpandableListView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.ExpandableListView getExpandableListView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the activity's expandable list view widget.  This can be used to get the selection,
  /// set the selection, and many other useful functions.
  ///@see ExpandableListView
  jni.JniObject getExpandableListView() =>
      jni.JniObject.fromRef(_getExpandableListView(reference).object);

  static final _getExpandableListAdapter = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ExpandableListActivity__getExpandableListAdapter")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.ExpandableListAdapter getExpandableListAdapter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the ExpandableListAdapter associated with this activity's
  /// ExpandableListView.
  jni.JniObject getExpandableListAdapter() =>
      jni.JniObject.fromRef(_getExpandableListAdapter(reference).object);

  static final _getSelectedId = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ExpandableListActivity__getSelectedId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getSelectedId()
  ///
  /// Gets the ID of the currently selected group or child.
  ///@return The ID of the currently selected group or child.
  int getSelectedId() => _getSelectedId(reference).long;

  static final _getSelectedPosition = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ExpandableListActivity__getSelectedPosition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getSelectedPosition()
  ///
  /// Gets the position (in packed position representation) of the currently
  /// selected group or child. Use
  /// ExpandableListView\#getPackedPositionType,
  /// ExpandableListView\#getPackedPositionGroup, and
  /// ExpandableListView\#getPackedPositionChild to unpack the returned
  /// packed position.
  ///@return A packed position representation containing the currently
  ///         selected group or child's position and type.
  int getSelectedPosition() => _getSelectedPosition(reference).long;

  static final _setSelectedChild = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Uint8)>>("ExpandableListActivity__setSelectedChild")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public boolean setSelectedChild(int groupPosition, int childPosition, boolean shouldExpandGroup)
  ///
  /// Sets the selection to the specified child. If the child is in a collapsed
  /// group, the group will only be expanded and child subsequently selected if
  /// shouldExpandGroup is set to true, otherwise the method will return false.
  ///@param groupPosition The position of the group that contains the child.
  ///@param childPosition The position of the child within the group.
  ///@param shouldExpandGroup Whether the child's group should be expanded if
  ///            it is collapsed.
  ///@return Whether the selection was successfully set on the child.
  bool setSelectedChild(
          int groupPosition, int childPosition, bool shouldExpandGroup) =>
      _setSelectedChild(reference, groupPosition, childPosition,
              shouldExpandGroup ? 1 : 0)
          .boolean;

  static final _setSelectedGroup = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ExpandableListActivity__setSelectedGroup")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setSelectedGroup(int groupPosition)
  ///
  /// Sets the selection to the specified group.
  ///@param groupPosition The position of the group that should be selected.
  void setSelectedGroup(int groupPosition) =>
      _setSelectedGroup(reference, groupPosition).check();
}

/// from: android.app.Fragment
///
/// A Fragment is a piece of an application's user interface or behavior
/// that can be placed in an Activity.  Interaction with fragments
/// is done through FragmentManager, which can be obtained via
/// Activity\#getFragmentManager() Activity.getFragmentManager() and
/// Fragment\#getFragmentManager() Fragment.getFragmentManager().
///
/// The Fragment class can be used many ways to achieve a wide variety of
/// results. In its core, it represents a particular operation or interface
/// that is running within a larger Activity.  A Fragment is closely
/// tied to the Activity it is in, and can not be used apart from one.  Though
/// Fragment defines its own lifecycle, that lifecycle is dependent on its
/// activity: if the activity is stopped, no fragments inside of it can be
/// started; when the activity is destroyed, all fragments will be destroyed.
///
/// All subclasses of Fragment must include a public no-argument constructor.
/// The framework will often re-instantiate a fragment class when needed,
/// in particular during state restore, and needs to be able to find this
/// constructor to instantiate it.  If the no-argument constructor is not
/// available, a runtime exception will occur in some cases during state
/// restore.
///
/// Topics covered here:
/// <ol>
/// <li><a href="\#OlderPlatforms">Older Platforms</a>
/// <li><a href="\#Lifecycle">Lifecycle</a>
/// <li><a href="\#Layout">Layout</a>
/// <li><a href="\#BackStack">Back Stack</a>
/// </ol>
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using fragments, read the
/// <a href="{@docRoot}guide/components/fragments.html">Fragments</a> developer guide.
///
/// </div>
///
/// <a name="OlderPlatforms"></a>
/// <h3>Older Platforms</h3>
///
/// While the Fragment API was introduced in
/// android.os.Build.VERSION_CODES\#HONEYCOMB, a version of the API
/// at is also available for use on older platforms through
/// android.support.v4.app.FragmentActivity.  See the blog post
/// <a href="http://android-developers.blogspot.com/2011/03/fragments-for-all.html">
/// Fragments For All</a> for more details.
///
/// <a name="Lifecycle"></a>
/// <h3>Lifecycle</h3>
///
/// Though a Fragment's lifecycle is tied to its owning activity, it has
/// its own wrinkle on the standard activity lifecycle.  It includes basic
/// activity lifecycle methods such as \#onResume, but also important
/// are methods related to interactions with the activity and UI generation.
///
/// The core series of lifecycle methods that are called to bring a fragment
/// up to resumed state (interacting with the user) are:
///
/// <ol>
/// <li> \#onAttach called once the fragment is associated with its activity.
/// <li> \#onCreate called to do initial creation of the fragment.
/// <li> \#onCreateView creates and returns the view hierarchy associated
/// with the fragment.
/// <li> \#onActivityCreated tells the fragment that its activity has
/// completed its own Activity\#onCreate Activity.onCreate().
/// <li> \#onViewStateRestored tells the fragment that all of the saved
/// state of its view hierarchy has been restored.
/// <li> \#onStart makes the fragment visible to the user (based on its
/// containing activity being started).
/// <li> \#onResume makes the fragment begin interacting with the user
/// (based on its containing activity being resumed).
/// </ol>
///
/// As a fragment is no longer being used, it goes through a reverse
/// series of callbacks:
///
/// <ol>
/// <li> \#onPause fragment is no longer interacting with the user either
/// because its activity is being paused or a fragment operation is modifying it
/// in the activity.
/// <li> \#onStop fragment is no longer visible to the user either
/// because its activity is being stopped or a fragment operation is modifying it
/// in the activity.
/// <li> \#onDestroyView allows the fragment to clean up resources
/// associated with its View.
/// <li> \#onDestroy called to do final cleanup of the fragment's state.
/// <li> \#onDetach called immediately prior to the fragment no longer
/// being associated with its activity.
/// </ol>
///
/// <a name="Layout"></a>
/// <h3>Layout</h3>
///
/// Fragments can be used as part of your application's layout, allowing
/// you to better modularize your code and more easily adjust your user
/// interface to the screen it is running on.  As an example, we can look
/// at a simple program consisting of a list of items, and display of the
/// details of each item.
///
///
/// An activity's layout XML can include <code>&lt;fragment&gt;</code> tags
/// to embed fragment instances inside of the layout.  For example, here is
/// a simple layout that embeds one fragment:
///
///
/// {@sample development/samples/ApiDemos/res/layout/fragment_layout.xml layout}
///
/// The layout is installed in the activity in the normal way:
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentLayout.java
///      main}
///
/// The titles fragment, showing a list of titles, is fairly simple, relying
/// on ListFragment for most of its work.  Note the implementation of
/// clicking an item: depending on the current activity's layout, it can either
/// create and display a new fragment to show the details in-place (more about
/// this later), or start a new activity to show the details.
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentLayout.java
///      titles}
///
/// The details fragment showing the contents of a selected item just
/// displays a string of text based on an index of a string array built in to
/// the app:
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentLayout.java
///      details}
///
/// In this case when the user clicks on a title, there is no details
/// container in the current activity, so the titles fragment's click code will
/// launch a new activity to display the details fragment:
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentLayout.java
///      details_activity}
///
/// However the screen may be large enough to show both the list of titles
/// and details about the currently selected title.  To use such a layout on
/// a landscape screen, this alternative layout can be placed under layout-land:
///
///
/// {@sample development/samples/ApiDemos/res/layout-land/fragment_layout.xml layout}
///
/// Note how the prior code will adjust to this alternative UI flow: the titles
/// fragment will now embed the details fragment inside of this activity, and the
/// details activity will finish itself if it is running in a configuration
/// where the details can be shown in-place.
///
/// When a configuration change causes the activity hosting these fragments
/// to restart, its new instance may use a different layout that doesn't
/// include the same fragments as the previous layout.  In this case all of
/// the previous fragments will still be instantiated and running in the new
/// instance.  However, any that are no longer associated with a &lt;fragment&gt;
/// tag in the view hierarchy will not have their content view created
/// and will return false from \#isInLayout.  (The code here also shows
/// how you can determine if a fragment placed in a container is no longer
/// running in a layout with that container and avoid creating its view hierarchy
/// in that case.)
///
/// The attributes of the &lt;fragment&gt; tag are used to control the
/// LayoutParams provided when attaching the fragment's view to the parent
/// container.  They can also be parsed by the fragment in \#onInflate
/// as parameters.
///
/// The fragment being instantiated must have some kind of unique identifier
/// so that it can be re-associated with a previous instance if the parent
/// activity needs to be destroyed and recreated.  This can be provided these
/// ways:
///
/// <ul>
/// <li>If nothing is explicitly supplied, the view ID of the container will
/// be used.
/// <li><code>android:tag</code> can be used in &lt;fragment&gt; to provide
/// a specific tag name for the fragment.
/// <li><code>android:id</code> can be used in &lt;fragment&gt; to provide
/// a specific identifier for the fragment.
/// </ul>
///
/// <a name="BackStack"></a>
/// <h3>Back Stack</h3>
///
/// The transaction in which fragments are modified can be placed on an
/// internal back-stack of the owning activity.  When the user presses back
/// in the activity, any transactions on the back stack are popped off before
/// the activity itself is finished.
///
/// For example, consider this simple fragment that is instantiated with
/// an integer argument and displays that in a TextView in its UI:
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentStack.java
///      fragment}
///
/// A function that creates a new instance of the fragment, replacing
/// whatever current fragment instance is being shown and pushing that change
/// on to the back stack could be written as:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentStack.java
///      add_stack}
///
/// After each call to this function, a new entry is on the stack, and
/// pressing back will pop it to return the user to whatever previous state
/// the activity UI was in.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.Fragment for consistent behavior across all devices
///      and access to <a href="{@docRoot}topic/libraries/architecture/lifecycle.html">Lifecycle</a>.
class Fragment extends jni.JniObject {
  Fragment.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Fragment__ctor")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ///
  /// Default constructor.  <strong>Every</strong> fragment must have an
  /// empty constructor, so it can be instantiated when restoring its
  /// activity's state.  It is strongly recommended that subclasses do not
  /// have other constructors with parameters, since these constructors
  /// will not be called when the fragment is re-instantiated; instead,
  /// arguments can be supplied by the caller with \#setArguments
  /// and later retrieved by the Fragment with \#getArguments.
  ///
  /// Applications should generally not implement a constructor. Prefer
  /// \#onAttach(Context) instead. It is the first place application code can run where
  /// the fragment is ready to be used - the point where the fragment is actually associated with
  /// its context. Some applications may also want to implement \#onInflate to retrieve
  /// attributes from a layout resource, although note this happens when the fragment is attached.
  Fragment() : super.fromRef(_ctor().object);

  static final _instantiate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__instantiate")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.Fragment instantiate(android.content.Context context, java.lang.String fname)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#instantiate(Context, String, Bundle) but with a null
  /// argument Bundle.
  static Fragment instantiate(content_.Context context, jni.JniString fname) =>
      Fragment.fromRef(_instantiate(context.reference, fname.reference).object);

  static final _instantiate1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__instantiate1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.Fragment instantiate(android.content.Context context, java.lang.String fname, android.os.Bundle args)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Create a new instance of a Fragment with the given class name.  This is
  /// the same as calling its empty constructor.
  ///@param context The calling context being used to instantiate the fragment.
  /// This is currently just used to get its ClassLoader.
  ///@param fname The class name of the fragment to instantiate.
  ///@param args Bundle of arguments to supply to the fragment, which it
  /// can retrieve with \#getArguments().  May be null.
  /// This value may be {@code null}.
  ///@return Returns a new fragment instance.
  ///@throws InstantiationException If there is a failure in instantiating
  /// the given fragment class.  This is a runtime exception; it is not
  /// normally expected to happen.
  static Fragment instantiate1(
          content_.Context context, jni.JniString fname, os_.Bundle args) =>
      Fragment.fromRef(
          _instantiate1(context.reference, fname.reference, args.reference)
              .object);

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__equals1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean equals(java.lang.Object o)
  ///
  /// Subclasses can not override equals().
  bool equals1(jni.JniObject o) => _equals1(reference, o.reference).boolean;

  static final _hashCode1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int hashCode()
  ///
  /// Subclasses can not override hashCode().
  int hashCode1() => _hashCode1(reference).integer;

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);

  static final _getId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Fragment__getId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getId()
  ///
  /// Return the identifier this fragment is known by.  This is either
  /// the android:id value supplied in a layout or the container view ID
  /// supplied when adding the fragment.
  int getId() => _getId(reference).integer;

  static final _getTag = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getTag")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String getTag()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the tag name of the fragment, if specified.
  jni.JniString getTag() => jni.JniString.fromRef(_getTag(reference).object);

  static final _setArguments = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__setArguments")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setArguments(android.os.Bundle args)
  ///
  /// Supply the construction arguments for this fragment.
  /// The arguments supplied here will be retained across fragment destroy and
  /// creation.
  ///
  /// This method cannot be called if the fragment is added to a FragmentManager and
  /// if \#isStateSaved() would return true. Prior to Build.VERSION_CODES\#O,
  /// this method may only be called if the fragment has not yet been added to a FragmentManager.
  ///
  ///
  void setArguments(os_.Bundle args) =>
      _setArguments(reference, args.reference).check();

  static final _getArguments = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getArguments")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.os.Bundle getArguments()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the arguments supplied to \#setArguments, if any.
  os_.Bundle getArguments() =>
      os_.Bundle.fromRef(_getArguments(reference).object);

  static final _isStateSaved = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__isStateSaved")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isStateSaved()
  ///
  /// Returns true if this fragment is added and its state has already been saved
  /// by its host. Any operations that would change saved state should not be performed
  /// if this method returns true, and some operations such as \#setArguments(Bundle)
  /// will fail.
  ///@return true if this fragment's state has already been saved by its host
  bool isStateSaved() => _isStateSaved(reference).boolean;

  static final _setInitialSavedState = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__setInitialSavedState")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setInitialSavedState(android.app.Fragment.SavedState state)
  ///
  /// Set the initial saved state that this Fragment should restore itself
  /// from when first being constructed, as returned by
  /// FragmentManager\#saveFragmentInstanceState(Fragment) FragmentManager.saveFragmentInstanceState.
  ///@param state The state the fragment should be restored from.
  void setInitialSavedState(Fragment_SavedState state) =>
      _setInitialSavedState(reference, state.reference).check();

  static final _setTargetFragment = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Fragment__setTargetFragment")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setTargetFragment(android.app.Fragment fragment, int requestCode)
  ///
  /// Optional target for this fragment.  This may be used, for example,
  /// if this fragment is being started by another, and when done wants to
  /// give a result back to the first.  The target set here is retained
  /// across instances via FragmentManager\#putFragment FragmentManager.putFragment().
  ///@param fragment The fragment that is the target of this one.
  ///@param requestCode Optional request code, for convenience if you
  /// are going to call back with \#onActivityResult(int, int, Intent).
  void setTargetFragment(Fragment fragment, int requestCode) =>
      _setTargetFragment(reference, fragment.reference, requestCode).check();

  static final _getTargetFragment = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getTargetFragment")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Fragment getTargetFragment()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the target fragment set by \#setTargetFragment.
  Fragment getTargetFragment() =>
      Fragment.fromRef(_getTargetFragment(reference).object);

  static final _getTargetRequestCode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getTargetRequestCode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getTargetRequestCode()
  ///
  /// Return the target request code set by \#setTargetFragment.
  int getTargetRequestCode() => _getTargetRequestCode(reference).integer;

  static final _getContext = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getContext")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Context this fragment is currently associated with.
  content_.Context getContext() =>
      content_.Context.fromRef(_getContext(reference).object);

  static final _getActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getActivity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Activity getActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Activity this fragment is currently associated with.
  Activity getActivity() => Activity.fromRef(_getActivity(reference).object);

  static final _getHost = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getHost")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.Object getHost()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the host object of this fragment. May return {@code null} if the fragment
  /// isn't currently being hosted.
  jni.JniObject getHost() => jni.JniObject.fromRef(_getHost(reference).object);

  static final _getResources = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getResources")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.res.Resources getResources()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return <code>getActivity().getResources()</code>.
  res_.Resources getResources() =>
      res_.Resources.fromRef(_getResources(reference).object);

  static final _getText = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Fragment__getText")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final java.lang.CharSequence getText(int resId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a localized, styled CharSequence from the application's package's
  /// default string table.
  ///@param resId Resource id for the CharSequence text
  jni.JniObject getText(int resId) =>
      jni.JniObject.fromRef(_getText(reference, resId).object);

  static final _getString = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Fragment__getString")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final java.lang.String getString(int resId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a localized string from the application's package's
  /// default string table.
  ///@param resId Resource id for the string
  jni.JniString getString(int resId) =>
      jni.JniString.fromRef(_getString(reference, resId).object);

  static final _getString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Fragment__getString1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String getString(int resId, java.lang.Object[] formatArgs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a localized formatted string from the application's package's
  /// default string table, substituting the format arguments as defined in
  /// java.util.Formatter and java.lang.String\#format.
  ///@param resId Resource id for the format string
  ///@param formatArgs The format arguments that will be used for substitution.
  jni.JniString getString1(int resId, jni.JniObject formatArgs) =>
      jni.JniString.fromRef(
          _getString1(reference, resId, formatArgs.reference).object);

  static final _getFragmentManager = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getFragmentManager")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.FragmentManager getFragmentManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the FragmentManager for interacting with fragments associated
  /// with this fragment's activity.  Note that this will be non-null slightly
  /// before \#getActivity(), during the time from when the fragment is
  /// placed in a FragmentTransaction until it is committed and
  /// attached to its activity.
  ///
  /// If this Fragment is a child of another Fragment, the FragmentManager
  /// returned here will be the parent's \#getChildFragmentManager().
  FragmentManager getFragmentManager() =>
      FragmentManager.fromRef(_getFragmentManager(reference).object);

  static final _getChildFragmentManager = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getChildFragmentManager")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.FragmentManager getChildFragmentManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a private FragmentManager for placing and managing Fragments
  /// inside of this Fragment.
  FragmentManager getChildFragmentManager() =>
      FragmentManager.fromRef(_getChildFragmentManager(reference).object);

  static final _getParentFragment = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getParentFragment")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Fragment getParentFragment()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the parent Fragment containing this Fragment.  If this Fragment
  /// is attached directly to an Activity, returns null.
  Fragment getParentFragment() =>
      Fragment.fromRef(_getParentFragment(reference).object);

  static final _isAdded = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__isAdded")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isAdded()
  ///
  /// Return true if the fragment is currently added to its activity.
  bool isAdded() => _isAdded(reference).boolean;

  static final _isDetached = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__isDetached")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isDetached()
  ///
  /// Return true if the fragment has been explicitly detached from the UI.
  /// That is, FragmentTransaction\#detach(Fragment) FragmentTransaction.detach(Fragment) has been used on it.
  bool isDetached() => _isDetached(reference).boolean;

  static final _isRemoving = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__isRemoving")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isRemoving()
  ///
  /// Return true if this fragment is currently being removed from its
  /// activity.  This is  _not_ whether its activity is finishing, but
  /// rather whether it is in the process of being removed from its activity.
  bool isRemoving() => _isRemoving(reference).boolean;

  static final _isInLayout = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__isInLayout")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isInLayout()
  ///
  /// Return true if the layout is included as part of an activity view
  /// hierarchy via the &lt;fragment&gt; tag.  This will always be true when
  /// fragments are created through the &lt;fragment&gt; tag, _except_
  /// in the case where an old fragment is restored from a previous state and
  /// it does not appear in the layout of the current state.
  bool isInLayout() => _isInLayout(reference).boolean;

  static final _isResumed = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__isResumed")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isResumed()
  ///
  /// Return true if the fragment is in the resumed state.  This is true
  /// for the duration of \#onResume() and \#onPause() as well.
  bool isResumed() => _isResumed(reference).boolean;

  static final _isVisible = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__isVisible")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isVisible()
  ///
  /// Return true if the fragment is currently visible to the user.  This means
  /// it: (1) has been added, (2) has its view attached to the window, and
  /// (3) is not hidden.
  bool isVisible() => _isVisible(reference).boolean;

  static final _isHidden = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__isHidden")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isHidden()
  ///
  /// Return true if the fragment has been hidden.  By default fragments
  /// are shown.  You can find out about changes to this state with
  /// \#onHiddenChanged.  Note that the hidden state is orthogonal
  /// to other states -- that is, to be visible to the user, a fragment
  /// must be both started and not hidden.
  bool isHidden() => _isHidden(reference).boolean;

  static final _onHiddenChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Fragment__onHiddenChanged")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onHiddenChanged(boolean hidden)
  ///
  /// Called when the hidden state (as returned by \#isHidden() of
  /// the fragment has changed.  Fragments start out not hidden; this will
  /// be called whenever the fragment changes state from that.
  ///@param hidden True if the fragment is now hidden, false otherwise.
  void onHiddenChanged(bool hidden) =>
      _onHiddenChanged(reference, hidden ? 1 : 0).check();

  static final _setRetainInstance = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Fragment__setRetainInstance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setRetainInstance(boolean retain)
  ///
  /// Control whether a fragment instance is retained across Activity
  /// re-creation (such as from a configuration change).  This can only
  /// be used with fragments not in the back stack.  If set, the fragment
  /// lifecycle will be slightly different when an activity is recreated:
  /// <ul>
  /// <li> \#onDestroy() will not be called (but \#onDetach() still
  /// will be, because the fragment is being detached from its current activity).
  /// <li> \#onCreate(Bundle) will not be called since the fragment
  /// is not being re-created.
  /// <li> \#onAttach(Activity) and \#onActivityCreated(Bundle) __will__
  /// still be called.
  /// </ul>
  void setRetainInstance(bool retain) =>
      _setRetainInstance(reference, retain ? 1 : 0).check();

  static final _getRetainInstance = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getRetainInstance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean getRetainInstance()
  bool getRetainInstance() => _getRetainInstance(reference).boolean;

  static final _setHasOptionsMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Fragment__setHasOptionsMenu")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setHasOptionsMenu(boolean hasMenu)
  ///
  /// Report that this fragment would like to participate in populating
  /// the options menu by receiving a call to \#onCreateOptionsMenu
  /// and related methods.
  ///@param hasMenu If true, the fragment has menu items to contribute.
  void setHasOptionsMenu(bool hasMenu) =>
      _setHasOptionsMenu(reference, hasMenu ? 1 : 0).check();

  static final _setMenuVisibility = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Fragment__setMenuVisibility")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setMenuVisibility(boolean menuVisible)
  ///
  /// Set a hint for whether this fragment's menu should be visible.  This
  /// is useful if you know that a fragment has been placed in your view
  /// hierarchy so that the user can not currently seen it, so any menu items
  /// it has should also not be shown.
  ///@param menuVisible The default is true, meaning the fragment's menu will
  /// be shown as usual.  If false, the user will not see the menu.
  void setMenuVisibility(bool menuVisible) =>
      _setMenuVisibility(reference, menuVisible ? 1 : 0).check();

  static final _setUserVisibleHint = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Fragment__setUserVisibleHint")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setUserVisibleHint(boolean isVisibleToUser)
  ///
  /// Set a hint to the system about whether this fragment's UI is currently visible
  /// to the user. This hint defaults to true and is persistent across fragment instance
  /// state save and restore.
  ///
  /// An app may set this to false to indicate that the fragment's UI is
  /// scrolled out of visibility or is otherwise not directly visible to the user.
  /// This may be used by the system to prioritize operations such as fragment lifecycle updates
  /// or loader ordering behavior.
  ///
  ///
  /// <strong>Note:</strong> This method may be called outside of the fragment lifecycle
  /// and thus has no ordering guarantees with regard to fragment lifecycle method calls.
  ///
  ///
  /// <strong>Note:</strong> Prior to Android N there was a platform bug that could cause
  /// <code>setUserVisibleHint</code> to bring a fragment up to the started state before its
  /// <code>FragmentTransaction</code> had been committed. As some apps relied on this behavior,
  /// it is preserved for apps that declare a <code>targetSdkVersion</code> of 23 or lower.
  ///
  ///@param isVisibleToUser true if this fragment's UI is currently visible to the user (default),
  ///                        false if it is not.
  void setUserVisibleHint(bool isVisibleToUser) =>
      _setUserVisibleHint(reference, isVisibleToUser ? 1 : 0).check();

  static final _getUserVisibleHint = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getUserVisibleHint")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getUserVisibleHint()
  ///
  /// @return The current value of the user-visible hint on this fragment.
  ///@see \#setUserVisibleHint(boolean)
  bool getUserVisibleHint() => _getUserVisibleHint(reference).boolean;

  static final _getLoaderManager = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getLoaderManager")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.LoaderManager getLoaderManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the LoaderManager for this fragment, creating it if needed.
  ///@deprecated Use android.support.v4.app.Fragment\#getLoaderManager()
  LoaderManager getLoaderManager() =>
      LoaderManager.fromRef(_getLoaderManager(reference).object);

  static final _startActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__startActivity")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivity(android.content.Intent intent)
  ///
  /// Call Activity\#startActivity(Intent) from the fragment's
  /// containing Activity.
  ///@param intent The intent to start.
  void startActivity(content_.Intent intent) =>
      _startActivity(reference, intent.reference).check();

  static final _startActivity1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__startActivity1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivity(android.content.Intent intent, android.os.Bundle options)
  ///
  /// Call Activity\#startActivity(Intent, Bundle) from the fragment's
  /// containing Activity.
  ///@param intent The intent to start.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  void startActivity1(content_.Intent intent, os_.Bundle options) =>
      _startActivity1(reference, intent.reference, options.reference).check();

  static final _startActivityForResult = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Fragment__startActivityForResult")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void startActivityForResult(android.content.Intent intent, int requestCode)
  ///
  /// Call Activity\#startActivityForResult(Intent, int) from the fragment's
  /// containing Activity.
  void startActivityForResult(content_.Intent intent, int requestCode) =>
      _startActivityForResult(reference, intent.reference, requestCode).check();

  static final _startActivityForResult1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Fragment__startActivityForResult1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivityForResult(android.content.Intent intent, int requestCode, android.os.Bundle options)
  ///
  /// Call Activity\#startActivityForResult(Intent, int, Bundle) from the fragment's
  /// containing Activity.
  void startActivityForResult1(
          content_.Intent intent, int requestCode, os_.Bundle options) =>
      _startActivityForResult1(
              reference, intent.reference, requestCode, options.reference)
          .check();

  static final _startIntentSenderForResult = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "Fragment__startIntentSenderForResult")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void startIntentSenderForResult(android.content.IntentSender intent, int requestCode, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, android.os.Bundle options)
  ///
  /// Call Activity\#startIntentSenderForResult(IntentSender, int, Intent, int, int, int,
  /// Bundle) from the fragment's containing Activity.
  ///@param fillInIntent This value may be {@code null}.
  void startIntentSenderForResult(
          content_.IntentSender intent,
          int requestCode,
          content_.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags,
          os_.Bundle options) =>
      _startIntentSenderForResult(
              reference,
              intent.reference,
              requestCode,
              fillInIntent.reference,
              flagsMask,
              flagsValues,
              extraFlags,
              options.reference)
          .check();

  static final _onActivityResult = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onActivityResult")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onActivityResult(int requestCode, int resultCode, android.content.Intent data)
  ///
  /// Receive the result from a previous call to
  /// \#startActivityForResult(Intent, int).  This follows the
  /// related Activity API as described there in
  /// Activity\#onActivityResult(int, int, Intent).
  ///@param requestCode The integer request code originally supplied to
  ///                    startActivityForResult(), allowing you to identify who this
  ///                    result came from.
  ///@param resultCode The integer result code returned by the child activity
  ///                   through its setResult().
  ///@param data An Intent, which can return result data to the caller
  ///               (various data can be attached to Intent "extras").
  void onActivityResult(
          int requestCode, int resultCode, content_.Intent data) =>
      _onActivityResult(reference, requestCode, resultCode, data.reference)
          .check();

  static final _requestPermissions = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Fragment__requestPermissions")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void requestPermissions(java.lang.String[] permissions, int requestCode)
  ///
  /// Requests permissions to be granted to this application. These permissions
  /// must be requested in your manifest, they should not be granted to your app,
  /// and they should have protection level android.content.pm.PermissionInfo \#PROTECTION_DANGEROUS dangerous, regardless whether they are declared by
  /// the platform or a third-party app.
  ///
  /// Normal permissions android.content.pm.PermissionInfo\#PROTECTION_NORMAL
  /// are granted at install time if requested in the manifest. Signature permissions
  /// android.content.pm.PermissionInfo\#PROTECTION_SIGNATURE are granted at
  /// install time if requested in the manifest and the signature of your app matches
  /// the signature of the app declaring the permissions.
  ///
  ///
  ///
  /// If your app does not have the requested permissions the user will be presented
  /// with UI for accepting them. After the user has accepted or rejected the
  /// requested permissions you will receive a callback on \#onRequestPermissionsResult(int, String[], int[]) reporting whether the
  /// permissions were granted or not.
  ///
  ///
  ///
  /// Note that requesting a permission does not guarantee it will be granted and
  /// your app should be able to run without having this permission.
  ///
  ///
  ///
  /// This method may start an activity allowing the user to choose which permissions
  /// to grant and which to reject. Hence, you should be prepared that your activity
  /// may be paused and resumed. Further, granting some permissions may require
  /// a restart of you application. In such a case, the system will recreate the
  /// activity stack before delivering the result to \#onRequestPermissionsResult(int, String[], int[]).
  ///
  ///
  ///
  /// When checking whether you have a permission you should use android.content.Context\#checkSelfPermission(String).
  ///
  ///
  ///
  /// Calling this API for permissions already granted to your app would show UI
  /// to the user to decide whether the app can still hold these permissions. This
  /// can be useful if the way your app uses data guarded by the permissions
  /// changes significantly.
  ///
  ///
  ///
  /// You cannot request a permission if your activity sets android.R.styleable\#AndroidManifestActivity_noHistory noHistory to
  /// <code>true</code> because in this case the activity would not receive
  /// result callbacks including \#onRequestPermissionsResult(int, String[], int[]).
  ///
  ///
  ///
  /// A sample permissions request looks like this:
  ///
  ///
  /// <code><pre>
  /// private void showContacts() {
  ///     if (getActivity().checkSelfPermission(Manifest.permission.READ_CONTACTS)
  ///             != PackageManager.PERMISSION_GRANTED) {
  ///         requestPermissions(new String[]{Manifest.permission.READ_CONTACTS},
  ///                 PERMISSIONS_REQUEST_READ_CONTACTS);
  ///     } else {
  ///         doShowContacts();
  ///     }
  /// }
  ///
  /// {@literal @}Override
  /// public void onRequestPermissionsResult(int requestCode, String[] permissions,
  ///         int[] grantResults) {
  ///     if (requestCode == PERMISSIONS_REQUEST_READ_CONTACTS
  ///             && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
  ///         doShowContacts();
  ///     }
  /// }
  /// </code></pre>
  ///
  ///@param permissions The requested permissions. Must me non-null and not empty.
  /// This value must never be {@code null}.
  ///@param requestCode Application specific request code to match with a result
  ///    reported to \#onRequestPermissionsResult(int, String[], int[]).
  ///    Should be >= 0.
  ///@see \#onRequestPermissionsResult(int, String[], int[])
  ///@see android.content.Context\#checkSelfPermission(String)
  void requestPermissions(jni.JniObject permissions, int requestCode) =>
      _requestPermissions(reference, permissions.reference, requestCode)
          .check();

  static final _onRequestPermissionsResult = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Fragment__onRequestPermissionsResult")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onRequestPermissionsResult(int requestCode, java.lang.String[] permissions, int[] grantResults)
  ///
  /// Callback for the result from requesting permissions. This method
  /// is invoked for every call on \#requestPermissions(String[], int).
  ///
  /// <strong>Note:</strong> It is possible that the permissions request interaction
  /// with the user is interrupted. In this case you will receive empty permissions
  /// and results arrays which should be treated as a cancellation.
  ///
  ///
  ///@param requestCode The request code passed in \#requestPermissions(String[], int).
  ///@param permissions The requested permissions. Never null.
  /// This value must never be {@code null}.
  ///@param grantResults The grant results for the corresponding permissions
  ///     which is either android.content.pm.PackageManager\#PERMISSION_GRANTED
  ///     or android.content.pm.PackageManager\#PERMISSION_DENIED. Never null.
  ///
  /// This value must never be {@code null}.
  ///@see \#requestPermissions(String[], int)
  void onRequestPermissionsResult(int requestCode, jni.JniObject permissions,
          jni.JniObject grantResults) =>
      _onRequestPermissionsResult(reference, requestCode, permissions.reference,
              grantResults.reference)
          .check();

  static final _shouldShowRequestPermissionRationale = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Fragment__shouldShowRequestPermissionRationale")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldShowRequestPermissionRationale(java.lang.String permission)
  ///
  /// Gets whether you should show UI with rationale for requesting a permission.
  /// You should do this only if you do not have the permission and the context in
  /// which the permission is requested does not clearly communicate to the user
  /// what would be the benefit from granting this permission.
  ///
  /// For example, if you write a camera app, requesting the camera permission
  /// would be expected by the user and no rationale for why it is requested is
  /// needed. If however, the app needs location for tagging photos then a non-tech
  /// savvy user may wonder how location is related to taking photos. In this case
  /// you may choose to show UI with rationale of requesting this permission.
  ///
  ///
  ///@param permission A permission your app wants to request.
  /// This value must never be {@code null}.
  ///@return Whether you can show permission rationale UI.
  ///@see Context\#checkSelfPermission(String)
  ///@see \#requestPermissions(String[], int)
  ///@see \#onRequestPermissionsResult(int, String[], int[])
  bool shouldShowRequestPermissionRationale(jni.JniString permission) =>
      _shouldShowRequestPermissionRationale(reference, permission.reference)
          .boolean;

  static final _onGetLayoutInflater = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onGetLayoutInflater")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.LayoutInflater onGetLayoutInflater(android.os.Bundle savedInstanceState)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the LayoutInflater used to inflate Views of this Fragment. The default
  /// implementation will throw an exception if the Fragment is not attached.
  ///@return The LayoutInflater used to inflate Views of this Fragment.
  jni.JniObject onGetLayoutInflater(os_.Bundle savedInstanceState) =>
      jni.JniObject.fromRef(
          _onGetLayoutInflater(reference, savedInstanceState.reference).object);

  static final _getLayoutInflater = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getLayoutInflater")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.view.LayoutInflater getLayoutInflater()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the cached LayoutInflater used to inflate Views of this Fragment. If
  /// \#onGetLayoutInflater(Bundle) has not been called \#onGetLayoutInflater(Bundle)
  /// will be called with a {@code null} argument and that value will be cached.
  ///
  /// The cached LayoutInflater will be replaced immediately prior to
  /// \#onCreateView(LayoutInflater, ViewGroup, Bundle) and cleared immediately after
  /// \#onDetach().
  ///@return The LayoutInflater used to inflate Views of this Fragment.
  jni.JniObject getLayoutInflater() =>
      jni.JniObject.fromRef(_getLayoutInflater(reference).object);

  static final _onInflate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onInflate")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onInflate(android.util.AttributeSet attrs, android.os.Bundle savedInstanceState)
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@deprecated Use \#onInflate(Context, AttributeSet, Bundle) instead.
  void onInflate(jni.JniObject attrs, os_.Bundle savedInstanceState) =>
      _onInflate(reference, attrs.reference, savedInstanceState.reference)
          .check();

  static final _onInflate1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onInflate1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onInflate(android.content.Context context, android.util.AttributeSet attrs, android.os.Bundle savedInstanceState)
  ///
  /// Called when a fragment is being created as part of a view layout
  /// inflation, typically from setting the content view of an activity.  This
  /// may be called immediately after the fragment is created from a <fragment>
  /// tag in a layout file.  Note this is _before_ the fragment's
  /// \#onAttach(Activity) has been called; all you should do here is
  /// parse the attributes and save them away.
  ///
  /// This is called every time the fragment is inflated, even if it is
  /// being inflated into a new instance with saved state.  It typically makes
  /// sense to re-parse the parameters each time, to allow them to change with
  /// different configurations.
  ///
  ///
  /// Here is a typical implementation of a fragment that can take parameters
  /// both through attributes supplied here as well from \#getArguments():
  ///
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentArguments.java
  ///      fragment}
  ///
  /// Note that parsing the XML attributes uses a "styleable" resource.  The
  /// declaration for the styleable used here is:
  ///
  ///
  /// {@sample development/samples/ApiDemos/res/values/attrs.xml fragment_arguments}
  ///
  /// The fragment can then be declared within its activity's content layout
  /// through a tag like this:
  ///
  ///
  /// {@sample development/samples/ApiDemos/res/layout/fragment_arguments.xml from_attributes}
  ///
  /// This fragment can also be created dynamically from arguments given
  /// at runtime in the arguments Bundle; here is an example of doing so at
  /// creation of the containing activity:
  ///
  ///
  /// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentArguments.java
  ///      create}
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param context The Context that is inflating this fragment.
  ///@param attrs The attributes at the tag where the fragment is
  /// being created.
  ///@param savedInstanceState If the fragment is being re-created from
  /// a previous saved state, this is the state.
  void onInflate1(content_.Context context, jni.JniObject attrs,
          os_.Bundle savedInstanceState) =>
      _onInflate1(reference, context.reference, attrs.reference,
              savedInstanceState.reference)
          .check();

  static final _onInflate2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onInflate2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onInflate(android.app.Activity activity, android.util.AttributeSet attrs, android.os.Bundle savedInstanceState)
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@deprecated Use \#onInflate(Context, AttributeSet, Bundle) instead.
  void onInflate2(Activity activity, jni.JniObject attrs,
          os_.Bundle savedInstanceState) =>
      _onInflate2(reference, activity.reference, attrs.reference,
              savedInstanceState.reference)
          .check();

  static final _onAttachFragment = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onAttachFragment")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttachFragment(android.app.Fragment childFragment)
  ///
  /// Called when a fragment is attached as a child of this fragment.
  ///
  /// This is called after the attached fragment's <code>onAttach</code> and before
  /// the attached fragment's <code>onCreate</code> if the fragment has not yet had a previous
  /// call to <code>onCreate</code>.
  ///
  ///@param childFragment child fragment being attached
  void onAttachFragment(Fragment childFragment) =>
      _onAttachFragment(reference, childFragment.reference).check();

  static final _onAttach = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onAttach")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttach(android.content.Context context)
  ///
  /// Called when a fragment is first attached to its context.
  /// \#onCreate(Bundle) will be called after this.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onAttach(content_.Context context) =>
      _onAttach(reference, context.reference).check();

  static final _onAttach1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onAttach1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttach(android.app.Activity activity)
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@deprecated Use \#onAttach(Context) instead.
  void onAttach1(Activity activity) =>
      _onAttach1(reference, activity.reference).check();

  static final _onCreateAnimator = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Uint8, ffi.Int32)>>("Fragment__onCreateAnimator")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public android.animation.Animator onCreateAnimator(int transit, boolean enter, int nextAnim)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called when a fragment loads an animation.
  jni.JniObject onCreateAnimator(int transit, bool enter, int nextAnim) =>
      jni.JniObject.fromRef(
          _onCreateAnimator(reference, transit, enter ? 1 : 0, nextAnim)
              .object);

  static final _onCreate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onCreate")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreate(android.os.Bundle savedInstanceState)
  ///
  /// Called to do initial creation of a fragment.  This is called after
  /// \#onAttach(Activity) and before
  /// \#onCreateView(LayoutInflater, ViewGroup, Bundle), but is not called if the fragment
  /// instance is retained across Activity re-creation (see \#setRetainInstance(boolean)).
  ///
  /// Note that this can be called while the fragment's activity is
  /// still in the process of being created.  As such, you can not rely
  /// on things like the activity's content view hierarchy being initialized
  /// at this point.  If you want to do work once the activity itself is
  /// created, see \#onActivityCreated(Bundle).
  ///
  /// If your app's <code>targetSdkVersion</code> is android.os.Build.VERSION_CODES\#M
  /// or lower, child fragments being restored from the savedInstanceState are restored after
  /// <code>onCreate</code> returns. When targeting android.os.Build.VERSION_CODES\#N or
  /// above and running on an N or newer platform version
  /// they are restored by <code>Fragment.onCreate</code>.
  ///
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param savedInstanceState If the fragment is being re-created from
  /// a previous saved state, this is the state.
  ///
  /// This value may be {@code null}.
  void onCreate(os_.Bundle savedInstanceState) =>
      _onCreate(reference, savedInstanceState.reference).check();

  static final _onCreateView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onCreateView")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View onCreateView(android.view.LayoutInflater inflater, android.view.ViewGroup container, android.os.Bundle savedInstanceState)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Called to have the fragment instantiate its user interface view.
  /// This is optional, and non-graphical fragments can return null (which
  /// is the default implementation).  This will be called between
  /// \#onCreate(Bundle) and \#onActivityCreated(Bundle).
  ///
  /// If you return a View from here, you will later be called in
  /// \#onDestroyView when the view is being released.
  ///@param inflater The LayoutInflater object that can be used to inflate
  /// any views in the fragment,
  ///@param container If non-null, this is the parent view that the fragment's
  /// UI should be attached to.  The fragment should not add the view itself,
  /// but this can be used to generate the LayoutParams of the view.
  /// This value may be {@code null}.
  ///@param savedInstanceState If non-null, this fragment is being re-constructed
  /// from a previous saved state as given here.
  ///@return Return the View for the fragment's UI, or null.
  jni.JniObject onCreateView(jni.JniObject inflater, jni.JniObject container,
          os_.Bundle savedInstanceState) =>
      jni.JniObject.fromRef(_onCreateView(reference, inflater.reference,
              container.reference, savedInstanceState.reference)
          .object);

  static final _onViewCreated = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onViewCreated")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onViewCreated(android.view.View view, android.os.Bundle savedInstanceState)
  ///
  /// Called immediately after \#onCreateView(LayoutInflater, ViewGroup, Bundle)
  /// has returned, but before any saved state has been restored in to the view.
  /// This gives subclasses a chance to initialize themselves once
  /// they know their view hierarchy has been completely created.  The fragment's
  /// view hierarchy is not however attached to its parent at this point.
  ///@param view The View returned by \#onCreateView(LayoutInflater, ViewGroup, Bundle).
  ///@param savedInstanceState If non-null, this fragment is being re-constructed
  /// from a previous saved state as given here.
  ///
  /// This value may be {@code null}.
  void onViewCreated(jni.JniObject view, os_.Bundle savedInstanceState) =>
      _onViewCreated(reference, view.reference, savedInstanceState.reference)
          .check();

  static final _getView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View getView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the root view for the fragment's layout (the one returned by \#onCreateView),
  /// if provided.
  ///@return The fragment's root view, or null if it has no layout.
  jni.JniObject getView() => jni.JniObject.fromRef(_getView(reference).object);

  static final _onActivityCreated = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onActivityCreated")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onActivityCreated(android.os.Bundle savedInstanceState)
  ///
  /// Called when the fragment's activity has been created and this
  /// fragment's view hierarchy instantiated.  It can be used to do final
  /// initialization once these pieces are in place, such as retrieving
  /// views or restoring state.  It is also useful for fragments that use
  /// \#setRetainInstance(boolean) to retain their instance,
  /// as this callback tells the fragment when it is fully associated with
  /// the new activity instance.  This is called after \#onCreateView
  /// and before \#onViewStateRestored(Bundle).
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param savedInstanceState If the fragment is being re-created from
  /// a previous saved state, this is the state.
  ///
  /// This value may be {@code null}.
  void onActivityCreated(os_.Bundle savedInstanceState) =>
      _onActivityCreated(reference, savedInstanceState.reference).check();

  static final _onViewStateRestored = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onViewStateRestored")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onViewStateRestored(android.os.Bundle savedInstanceState)
  ///
  /// Called when all saved state has been restored into the view hierarchy
  /// of the fragment.  This can be used to do initialization based on saved
  /// state that you are letting the view hierarchy track itself, such as
  /// whether check box widgets are currently checked.  This is called
  /// after \#onActivityCreated(Bundle) and before
  /// \#onStart().
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  ///@param savedInstanceState If the fragment is being re-created from
  /// a previous saved state, this is the state.
  void onViewStateRestored(os_.Bundle savedInstanceState) =>
      _onViewStateRestored(reference, savedInstanceState.reference).check();

  static final _onStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__onStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onStart()
  ///
  /// Called when the Fragment is visible to the user.  This is generally
  /// tied to Activity\#onStart() Activity.onStart of the containing
  /// Activity's lifecycle.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onStart() => _onStart(reference).check();

  static final _onResume = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__onResume")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onResume()
  ///
  /// Called when the fragment is visible to the user and actively running.
  /// This is generally
  /// tied to Activity\#onResume() Activity.onResume of the containing
  /// Activity's lifecycle.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onResume() => _onResume(reference).check();

  static final _onSaveInstanceState = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onSaveInstanceState")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onSaveInstanceState(android.os.Bundle outState)
  ///
  /// Called to ask the fragment to save its current dynamic state, so it
  /// can later be reconstructed in a new instance of its process is
  /// restarted.  If a new instance of the fragment later needs to be
  /// created, the data you place in the Bundle here will be available
  /// in the Bundle given to \#onCreate(Bundle),
  /// \#onCreateView(LayoutInflater, ViewGroup, Bundle), and
  /// \#onActivityCreated(Bundle).
  ///
  /// This corresponds to Activity\#onSaveInstanceState(Bundle) Activity.onSaveInstanceState(Bundle) and most of the discussion there
  /// applies here as well.  Note however: _this method may be called
  /// at any time before \#onDestroy()_.  There are many situations
  /// where a fragment may be mostly torn down (such as when placed on the
  /// back stack with no UI showing), but its state will not be saved until
  /// its owning activity actually needs to save its state.
  ///@param outState Bundle in which to place your saved state.
  void onSaveInstanceState(os_.Bundle outState) =>
      _onSaveInstanceState(reference, outState.reference).check();

  static final _onMultiWindowModeChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onMultiWindowModeChanged")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onMultiWindowModeChanged(boolean isInMultiWindowMode, android.content.res.Configuration newConfig)
  ///
  /// Called when the Fragment's activity changes from fullscreen mode to multi-window mode and
  /// visa-versa. This is generally tied to Activity\#onMultiWindowModeChanged of the
  /// containing Activity. This method provides the same configuration that will be sent in the
  /// following \#onConfigurationChanged(Configuration) call after the activity enters this
  /// mode.
  ///@param isInMultiWindowMode True if the activity is in multi-window mode.
  ///@param newConfig The new configuration of the activity with the state
  ///                  {@param isInMultiWindowMode}.
  void onMultiWindowModeChanged(
          bool isInMultiWindowMode, res_.Configuration newConfig) =>
      _onMultiWindowModeChanged(
              reference, isInMultiWindowMode ? 1 : 0, newConfig.reference)
          .check();

  static final _onMultiWindowModeChanged1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Fragment__onMultiWindowModeChanged1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onMultiWindowModeChanged(boolean isInMultiWindowMode)
  ///
  /// Called when the Fragment's activity changes from fullscreen mode to multi-window mode and
  /// visa-versa. This is generally tied to Activity\#onMultiWindowModeChanged of the
  /// containing Activity.
  ///@param isInMultiWindowMode True if the activity is in multi-window mode.
  ///@deprecated Use \#onMultiWindowModeChanged(boolean, Configuration) instead.
  void onMultiWindowModeChanged1(bool isInMultiWindowMode) =>
      _onMultiWindowModeChanged1(reference, isInMultiWindowMode ? 1 : 0)
          .check();

  static final _onPictureInPictureModeChanged = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                      ffi.Pointer<ffi.Void>)>>(
          "Fragment__onPictureInPictureModeChanged")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode, android.content.res.Configuration newConfig)
  ///
  /// Called by the system when the activity changes to and from picture-in-picture mode. This is
  /// generally tied to Activity\#onPictureInPictureModeChanged of the containing Activity.
  /// This method provides the same configuration that will be sent in the following
  /// \#onConfigurationChanged(Configuration) call after the activity enters this mode.
  ///@param isInPictureInPictureMode True if the activity is in picture-in-picture mode.
  ///@param newConfig The new configuration of the activity with the state
  ///                  {@param isInPictureInPictureMode}.
  void onPictureInPictureModeChanged(
          bool isInPictureInPictureMode, res_.Configuration newConfig) =>
      _onPictureInPictureModeChanged(
              reference, isInPictureInPictureMode ? 1 : 0, newConfig.reference)
          .check();

  static final _onPictureInPictureModeChanged1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Fragment__onPictureInPictureModeChanged1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode)
  ///
  /// Called by the system when the activity changes to and from picture-in-picture mode. This is
  /// generally tied to Activity\#onPictureInPictureModeChanged of the containing Activity.
  ///@param isInPictureInPictureMode True if the activity is in picture-in-picture mode.
  ///@deprecated Use \#onPictureInPictureModeChanged(boolean, Configuration) instead.
  void onPictureInPictureModeChanged1(bool isInPictureInPictureMode) =>
      _onPictureInPictureModeChanged1(
              reference, isInPictureInPictureMode ? 1 : 0)
          .check();

  static final _onConfigurationChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onConfigurationChanged")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onConfigurationChanged(android.content.res.Configuration newConfig)
  ///
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  void onConfigurationChanged(res_.Configuration newConfig) =>
      _onConfigurationChanged(reference, newConfig.reference).check();

  static final _onPause = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__onPause")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onPause()
  ///
  /// Called when the Fragment is no longer resumed.  This is generally
  /// tied to Activity\#onPause() Activity.onPause of the containing
  /// Activity's lifecycle.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onPause() => _onPause(reference).check();

  static final _onStop = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__onStop")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onStop()
  ///
  /// Called when the Fragment is no longer started.  This is generally
  /// tied to Activity\#onStop() Activity.onStop of the containing
  /// Activity's lifecycle.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onStop() => _onStop(reference).check();

  static final _onLowMemory = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__onLowMemory")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onLowMemory()
  ///
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  void onLowMemory() => _onLowMemory(reference).check();

  static final _onTrimMemory = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Fragment__onTrimMemory")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onTrimMemory(int level)
  ///
  /// If you override this method you _must_ call through to the
  ///            superclass implementation.
  void onTrimMemory(int level) => _onTrimMemory(reference, level).check();

  static final _onDestroyView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__onDestroyView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDestroyView()
  ///
  /// Called when the view previously created by \#onCreateView has
  /// been detached from the fragment.  The next time the fragment needs
  /// to be displayed, a new view will be created.  This is called
  /// after \#onStop() and before \#onDestroy().  It is called
  /// _regardless_ of whether \#onCreateView returned a
  /// non-null view.  Internally it is called after the view's state has
  /// been saved but before it has been removed from its parent.
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onDestroyView() => _onDestroyView(reference).check();

  static final _onDestroy = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__onDestroy")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDestroy()
  ///
  /// Called when the fragment is no longer in use.  This is called
  /// after \#onStop() and before \#onDetach().
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onDestroy() => _onDestroy(reference).check();

  static final _onDetach = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__onDetach")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDetach()
  ///
  /// Called when the fragment is no longer attached to its activity.  This is called after
  /// \#onDestroy(), except in the cases where the fragment instance is retained across
  /// Activity re-creation (see \#setRetainInstance(boolean)), in which case it is called
  /// after \#onStop().
  ///
  /// If you override this method you _must_ call through to the
  ///  *            superclass implementation.
  void onDetach() => _onDetach(reference).check();

  static final _onCreateOptionsMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onCreateOptionsMenu")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreateOptionsMenu(android.view.Menu menu, android.view.MenuInflater inflater)
  ///
  /// Initialize the contents of the Activity's standard options menu.  You
  /// should place your menu items in to <var>menu</var>.  For this method
  /// to be called, you must have first called \#setHasOptionsMenu.  See
  /// Activity\#onCreateOptionsMenu(Menu) Activity.onCreateOptionsMenu
  /// for more information.
  ///@param menu The options menu in which you place your items.
  ///@see \#setHasOptionsMenu
  ///@see \#onPrepareOptionsMenu
  ///@see \#onOptionsItemSelected
  void onCreateOptionsMenu(jni.JniObject menu, jni.JniObject inflater) =>
      _onCreateOptionsMenu(reference, menu.reference, inflater.reference)
          .check();

  static final _onPrepareOptionsMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onPrepareOptionsMenu")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPrepareOptionsMenu(android.view.Menu menu)
  ///
  /// Prepare the Screen's standard options menu to be displayed.  This is
  /// called right before the menu is shown, every time it is shown.  You can
  /// use this method to efficiently enable/disable items or otherwise
  /// dynamically modify the contents.  See
  /// Activity\#onPrepareOptionsMenu(Menu) Activity.onPrepareOptionsMenu
  /// for more information.
  ///@param menu The options menu as last shown or first initialized by
  ///             onCreateOptionsMenu().
  ///@see \#setHasOptionsMenu
  ///@see \#onCreateOptionsMenu
  void onPrepareOptionsMenu(jni.JniObject menu) =>
      _onPrepareOptionsMenu(reference, menu.reference).check();

  static final _onDestroyOptionsMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__onDestroyOptionsMenu")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDestroyOptionsMenu()
  ///
  /// Called when this fragment's option menu items are no longer being
  /// included in the overall options menu.  Receiving this call means that
  /// the menu needed to be rebuilt, but this fragment's items were not
  /// included in the newly built menu (its \#onCreateOptionsMenu(Menu, MenuInflater)
  /// was not called).
  void onDestroyOptionsMenu() => _onDestroyOptionsMenu(reference).check();

  static final _onOptionsItemSelected = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onOptionsItemSelected")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onOptionsItemSelected(android.view.MenuItem item)
  ///
  /// This hook is called whenever an item in your options menu is selected.
  /// The default implementation simply returns false to have the normal
  /// processing happen (calling the item's Runnable or sending a message to
  /// its Handler as appropriate).  You can use this method for any items
  /// for which you would like to do processing without those other
  /// facilities.
  ///
  /// Derived classes should call through to the base class for it to
  /// perform the default menu handling.
  ///@param item The menu item that was selected.
  ///@return boolean Return false to allow normal menu processing to
  ///         proceed, true to consume it here.
  ///@see \#onCreateOptionsMenu
  bool onOptionsItemSelected(jni.JniObject item) =>
      _onOptionsItemSelected(reference, item.reference).boolean;

  static final _onOptionsMenuClosed = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onOptionsMenuClosed")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onOptionsMenuClosed(android.view.Menu menu)
  ///
  /// This hook is called whenever the options menu is being closed (either by the user canceling
  /// the menu with the back/menu button, or when an item is selected).
  ///@param menu The options menu as last shown or first initialized by
  ///             onCreateOptionsMenu().
  void onOptionsMenuClosed(jni.JniObject menu) =>
      _onOptionsMenuClosed(reference, menu.reference).check();

  static final _onCreateContextMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onCreateContextMenu")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreateContextMenu(android.view.ContextMenu menu, android.view.View v, android.view.ContextMenu.ContextMenuInfo menuInfo)
  ///
  /// Called when a context menu for the {@code view} is about to be shown.
  /// Unlike \#onCreateOptionsMenu, this will be called every
  /// time the context menu is about to be shown and should be populated for
  /// the view (or item inside the view for AdapterView subclasses,
  /// this can be found in the {@code menuInfo})).
  ///
  /// Use \#onContextItemSelected(android.view.MenuItem) to know when an
  /// item has been selected.
  ///
  /// The default implementation calls up to
  /// Activity\#onCreateContextMenu Activity.onCreateContextMenu, though
  /// you can not call this implementation if you don't want that behavior.
  ///
  /// It is not safe to hold onto the context menu after this method returns.
  /// {@inheritDoc}
  void onCreateContextMenu(
          jni.JniObject menu, jni.JniObject v, jni.JniObject menuInfo) =>
      _onCreateContextMenu(
              reference, menu.reference, v.reference, menuInfo.reference)
          .check();

  static final _registerForContextMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__registerForContextMenu")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerForContextMenu(android.view.View view)
  ///
  /// Registers a context menu to be shown for the given view (multiple views
  /// can show the context menu). This method will set the
  /// OnCreateContextMenuListener on the view to this fragment, so
  /// \#onCreateContextMenu(ContextMenu, View, ContextMenuInfo) will be
  /// called when it is time to show the context menu.
  ///@see \#unregisterForContextMenu(View)
  ///@param view The view that should show a context menu.
  void registerForContextMenu(jni.JniObject view) =>
      _registerForContextMenu(reference, view.reference).check();

  static final _unregisterForContextMenu = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__unregisterForContextMenu")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterForContextMenu(android.view.View view)
  ///
  /// Prevents a context menu to be shown for the given view. This method will
  /// remove the OnCreateContextMenuListener on the view.
  ///@see \#registerForContextMenu(View)
  ///@param view The view that should stop showing a context menu.
  void unregisterForContextMenu(jni.JniObject view) =>
      _unregisterForContextMenu(reference, view.reference).check();

  static final _onContextItemSelected = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__onContextItemSelected")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onContextItemSelected(android.view.MenuItem item)
  ///
  /// This hook is called whenever an item in a context menu is selected. The
  /// default implementation simply returns false to have the normal processing
  /// happen (calling the item's Runnable or sending a message to its Handler
  /// as appropriate). You can use this method for any items for which you
  /// would like to do processing without those other facilities.
  ///
  /// Use MenuItem\#getMenuInfo() to get extra information set by the
  /// View that added this menu item.
  ///
  /// Derived classes should call through to the base class for it to perform
  /// the default menu handling.
  ///@param item The context menu item that was selected.
  ///@return boolean Return false to allow normal context menu processing to
  ///         proceed, true to consume it here.
  bool onContextItemSelected(jni.JniObject item) =>
      _onContextItemSelected(reference, item.reference).boolean;

  static final _setEnterSharedElementCallback = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Fragment__setEnterSharedElementCallback")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setEnterSharedElementCallback(android.app.SharedElementCallback callback)
  ///
  /// When custom transitions are used with Fragments, the enter transition callback
  /// is called when this Fragment is attached or detached when not popping the back stack.
  ///@param callback Used to manipulate the shared element transitions on this Fragment
  ///                 when added not as a pop from the back stack.
  void setEnterSharedElementCallback(SharedElementCallback callback) =>
      _setEnterSharedElementCallback(reference, callback.reference).check();

  static final _setExitSharedElementCallback = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Fragment__setExitSharedElementCallback")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExitSharedElementCallback(android.app.SharedElementCallback callback)
  ///
  /// When custom transitions are used with Fragments, the exit transition callback
  /// is called when this Fragment is attached or detached when popping the back stack.
  ///@param callback Used to manipulate the shared element transitions on this Fragment
  ///                 when added as a pop from the back stack.
  void setExitSharedElementCallback(SharedElementCallback callback) =>
      _setExitSharedElementCallback(reference, callback.reference).check();

  static final _setEnterTransition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__setEnterTransition")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setEnterTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used to move Views into the initial scene. The entering
  /// Views will be those that are regular Views or ViewGroups that have
  /// ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as entering is governed by changing visibility from
  /// View\#INVISIBLE to View\#VISIBLE. If <code>transition</code> is null,
  /// entering Views will remain unaffected.
  ///@param transition The Transition to use to move Views into the initial Scene.
  ///@attr ref android.R.styleable\#Fragment_fragmentEnterTransition
  void setEnterTransition(jni.JniObject transition) =>
      _setEnterTransition(reference, transition.reference).check();

  static final _getEnterTransition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getEnterTransition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.transition.Transition getEnterTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Transition that will be used to move Views into the initial scene. The entering
  /// Views will be those that are regular Views or ViewGroups that have
  /// ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as entering is governed by changing visibility from
  /// View\#INVISIBLE to View\#VISIBLE.
  ///@return the Transition to use to move Views into the initial Scene.
  ///@attr ref android.R.styleable\#Fragment_fragmentEnterTransition
  jni.JniObject getEnterTransition() =>
      jni.JniObject.fromRef(_getEnterTransition(reference).object);

  static final _setReturnTransition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__setReturnTransition")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setReturnTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used to move Views out of the scene when the Fragment is
  /// preparing to be removed, hidden, or detached because of popping the back stack. The exiting
  /// Views will be those that are regular Views or ViewGroups that have
  /// ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as entering is governed by changing visibility from
  /// View\#VISIBLE to View\#INVISIBLE. If <code>transition</code> is null,
  /// entering Views will remain unaffected. If nothing is set, the default will be to
  /// use the same value as set in \#setEnterTransition(android.transition.Transition).
  ///@param transition The Transition to use to move Views out of the Scene when the Fragment
  ///                   is preparing to close.
  ///@attr ref android.R.styleable\#Fragment_fragmentExitTransition
  void setReturnTransition(jni.JniObject transition) =>
      _setReturnTransition(reference, transition.reference).check();

  static final _getReturnTransition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getReturnTransition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.transition.Transition getReturnTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Transition that will be used to move Views out of the scene when the Fragment is
  /// preparing to be removed, hidden, or detached because of popping the back stack. The exiting
  /// Views will be those that are regular Views or ViewGroups that have
  /// ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as entering is governed by changing visibility from
  /// View\#VISIBLE to View\#INVISIBLE. If <code>transition</code> is null,
  /// entering Views will remain unaffected.
  ///@return the Transition to use to move Views out of the Scene when the Fragment
  ///         is preparing to close.
  ///@attr ref android.R.styleable\#Fragment_fragmentExitTransition
  jni.JniObject getReturnTransition() =>
      jni.JniObject.fromRef(_getReturnTransition(reference).object);

  static final _setExitTransition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__setExitTransition")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExitTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used to move Views out of the scene when the
  /// fragment is removed, hidden, or detached when not popping the back stack.
  /// The exiting Views will be those that are regular Views or ViewGroups that
  /// have ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as exiting is governed by changing visibility
  /// from View\#VISIBLE to View\#INVISIBLE. If transition is null, the views will
  /// remain unaffected.
  ///@param transition The Transition to use to move Views out of the Scene when the Fragment
  ///                   is being closed not due to popping the back stack.
  ///@attr ref android.R.styleable\#Fragment_fragmentExitTransition
  void setExitTransition(jni.JniObject transition) =>
      _setExitTransition(reference, transition.reference).check();

  static final _getExitTransition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getExitTransition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.transition.Transition getExitTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Transition that will be used to move Views out of the scene when the
  /// fragment is removed, hidden, or detached when not popping the back stack.
  /// The exiting Views will be those that are regular Views or ViewGroups that
  /// have ViewGroup\#isTransitionGroup return true. Typical Transitions will extend
  /// android.transition.Visibility as exiting is governed by changing visibility
  /// from View\#VISIBLE to View\#INVISIBLE. If transition is null, the views will
  /// remain unaffected.
  ///@return the Transition to use to move Views out of the Scene when the Fragment
  ///         is being closed not due to popping the back stack.
  ///@attr ref android.R.styleable\#Fragment_fragmentExitTransition
  jni.JniObject getExitTransition() =>
      jni.JniObject.fromRef(_getExitTransition(reference).object);

  static final _setReenterTransition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__setReenterTransition")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setReenterTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used to move Views in to the scene when returning due
  /// to popping a back stack. The entering Views will be those that are regular Views
  /// or ViewGroups that have ViewGroup\#isTransitionGroup return true. Typical Transitions
  /// will extend android.transition.Visibility as exiting is governed by changing
  /// visibility from View\#VISIBLE to View\#INVISIBLE. If transition is null,
  /// the views will remain unaffected. If nothing is set, the default will be to use the same
  /// transition as \#setExitTransition(android.transition.Transition).
  ///@param transition The Transition to use to move Views into the scene when reentering from a
  ///                   previously-started Activity.
  ///@attr ref android.R.styleable\#Fragment_fragmentReenterTransition
  void setReenterTransition(jni.JniObject transition) =>
      _setReenterTransition(reference, transition.reference).check();

  static final _getReenterTransition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__getReenterTransition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.transition.Transition getReenterTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Transition that will be used to move Views in to the scene when returning due
  /// to popping a back stack. The entering Views will be those that are regular Views
  /// or ViewGroups that have ViewGroup\#isTransitionGroup return true. Typical Transitions
  /// will extend android.transition.Visibility as exiting is governed by changing
  /// visibility from View\#VISIBLE to View\#INVISIBLE. If transition is null,
  /// the views will remain unaffected. If nothing is set, the default will be to use the same
  /// transition as \#setExitTransition(android.transition.Transition).
  ///@return the Transition to use to move Views into the scene when reentering from a
  ///                   previously-started Activity.
  ///@attr ref android.R.styleable\#Fragment_fragmentReenterTransition
  jni.JniObject getReenterTransition() =>
      jni.JniObject.fromRef(_getReenterTransition(reference).object);

  static final _setSharedElementEnterTransition = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Fragment__setSharedElementEnterTransition")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setSharedElementEnterTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used for shared elements transferred into the content
  /// Scene. Typical Transitions will affect size and location, such as
  /// android.transition.ChangeBounds. A null
  /// value will cause transferred shared elements to blink to the final position.
  ///@param transition The Transition to use for shared elements transferred into the content
  ///                   Scene.
  ///@attr ref android.R.styleable\#Fragment_fragmentSharedElementEnterTransition
  void setSharedElementEnterTransition(jni.JniObject transition) =>
      _setSharedElementEnterTransition(reference, transition.reference).check();

  static final _getSharedElementEnterTransition = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Fragment__getSharedElementEnterTransition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.transition.Transition getSharedElementEnterTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the Transition that will be used for shared elements transferred into the content
  /// Scene. Typical Transitions will affect size and location, such as
  /// android.transition.ChangeBounds. A null
  /// value will cause transferred shared elements to blink to the final position.
  ///@return The Transition to use for shared elements transferred into the content
  ///                   Scene.
  ///@attr ref android.R.styleable\#Fragment_fragmentSharedElementEnterTransition
  jni.JniObject getSharedElementEnterTransition() =>
      jni.JniObject.fromRef(_getSharedElementEnterTransition(reference).object);

  static final _setSharedElementReturnTransition = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Fragment__setSharedElementReturnTransition")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setSharedElementReturnTransition(android.transition.Transition transition)
  ///
  /// Sets the Transition that will be used for shared elements transferred back during a
  /// pop of the back stack. This Transition acts in the leaving Fragment.
  /// Typical Transitions will affect size and location, such as
  /// android.transition.ChangeBounds. A null
  /// value will cause transferred shared elements to blink to the final position.
  /// If no value is set, the default will be to use the same value as
  /// \#setSharedElementEnterTransition(android.transition.Transition).
  ///@param transition The Transition to use for shared elements transferred out of the content
  ///                   Scene.
  ///@attr ref android.R.styleable\#Fragment_fragmentSharedElementReturnTransition
  void setSharedElementReturnTransition(jni.JniObject transition) =>
      _setSharedElementReturnTransition(reference, transition.reference)
          .check();

  static final _getSharedElementReturnTransition = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Fragment__getSharedElementReturnTransition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.transition.Transition getSharedElementReturnTransition()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Transition that will be used for shared elements transferred back during a
  /// pop of the back stack. This Transition acts in the leaving Fragment.
  /// Typical Transitions will affect size and location, such as
  /// android.transition.ChangeBounds. A null
  /// value will cause transferred shared elements to blink to the final position.
  /// If no value is set, the default will be to use the same value as
  /// \#setSharedElementEnterTransition(android.transition.Transition).
  ///@return The Transition to use for shared elements transferred out of the content
  ///                   Scene.
  ///@attr ref android.R.styleable\#Fragment_fragmentSharedElementReturnTransition
  jni.JniObject getSharedElementReturnTransition() => jni.JniObject.fromRef(
      _getSharedElementReturnTransition(reference).object);

  static final _setAllowEnterTransitionOverlap = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Fragment__setAllowEnterTransitionOverlap")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setAllowEnterTransitionOverlap(boolean allow)
  ///
  /// Sets whether the the exit transition and enter transition overlap or not.
  /// When true, the enter transition will start as soon as possible. When false, the
  /// enter transition will wait until the exit transition completes before starting.
  ///@param allow true to start the enter transition when possible or false to
  ///              wait until the exiting transition completes.
  ///@attr ref android.R.styleable\#Fragment_fragmentAllowEnterTransitionOverlap
  void setAllowEnterTransitionOverlap(bool allow) =>
      _setAllowEnterTransitionOverlap(reference, allow ? 1 : 0).check();

  static final _getAllowEnterTransitionOverlap = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Fragment__getAllowEnterTransitionOverlap")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getAllowEnterTransitionOverlap()
  ///
  /// Returns whether the the exit transition and enter transition overlap or not.
  /// When true, the enter transition will start as soon as possible. When false, the
  /// enter transition will wait until the exit transition completes before starting.
  ///@return true when the enter transition should start as soon as possible or false to
  /// when it should wait until the exiting transition completes.
  ///@attr ref android.R.styleable\#Fragment_fragmentAllowEnterTransitionOverlap
  bool getAllowEnterTransitionOverlap() =>
      _getAllowEnterTransitionOverlap(reference).boolean;

  static final _setAllowReturnTransitionOverlap = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Fragment__setAllowReturnTransitionOverlap")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setAllowReturnTransitionOverlap(boolean allow)
  ///
  /// Sets whether the the return transition and reenter transition overlap or not.
  /// When true, the reenter transition will start as soon as possible. When false, the
  /// reenter transition will wait until the return transition completes before starting.
  ///@param allow true to start the reenter transition when possible or false to wait until the
  ///              return transition completes.
  ///@attr ref android.R.styleable\#Fragment_fragmentAllowReturnTransitionOverlap
  void setAllowReturnTransitionOverlap(bool allow) =>
      _setAllowReturnTransitionOverlap(reference, allow ? 1 : 0).check();

  static final _getAllowReturnTransitionOverlap = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Fragment__getAllowReturnTransitionOverlap")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getAllowReturnTransitionOverlap()
  ///
  /// Returns whether the the return transition and reenter transition overlap or not.
  /// When true, the reenter transition will start as soon as possible. When false, the
  /// reenter transition will wait until the return transition completes before starting.
  ///@return true to start the reenter transition when possible or false to wait until the
  ///         return transition completes.
  ///@attr ref android.R.styleable\#Fragment_fragmentAllowReturnTransitionOverlap
  bool getAllowReturnTransitionOverlap() =>
      _getAllowReturnTransitionOverlap(reference).boolean;

  static final _postponeEnterTransition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment__postponeEnterTransition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void postponeEnterTransition()
  ///
  /// Postpone the entering Fragment transition until \#startPostponedEnterTransition()
  /// or FragmentManager\#executePendingTransactions() has been called.
  ///
  /// This method gives the Fragment the ability to delay Fragment animations
  /// until all data is loaded. Until then, the added, shown, and
  /// attached Fragments will be INVISIBLE and removed, hidden, and detached Fragments won't
  /// be have their Views removed. The transaction runs when all postponed added Fragments in the
  /// transaction have called \#startPostponedEnterTransition().
  ///
  /// This method should be called before being added to the FragmentTransaction or
  /// in \#onCreate(Bundle), \#onAttach(Context), or
  /// \#onCreateView(LayoutInflater, ViewGroup, Bundle)}.
  /// \#startPostponedEnterTransition() must be called to allow the Fragment to
  /// start the transitions.
  ///
  /// When a FragmentTransaction is started that may affect a postponed FragmentTransaction,
  /// based on which containers are in their operations, the postponed FragmentTransaction
  /// will have its start triggered. The early triggering may result in faulty or nonexistent
  /// animations in the postponed transaction. FragmentTransactions that operate only on
  /// independent containers will not interfere with each other's postponement.
  ///
  /// Calling postponeEnterTransition on Fragments with a null View will not postpone the
  /// transition. Likewise, postponement only works if FragmentTransaction optimizations are
  /// enabled.
  ///@see Activity\#postponeEnterTransition()
  ///@see FragmentTransaction\#setReorderingAllowed(boolean)
  void postponeEnterTransition() => _postponeEnterTransition(reference).check();

  static final _startPostponedEnterTransition = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Fragment__startPostponedEnterTransition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void startPostponedEnterTransition()
  ///
  /// Begin postponed transitions after \#postponeEnterTransition() was called.
  /// If postponeEnterTransition() was called, you must call startPostponedEnterTransition()
  /// or FragmentManager\#executePendingTransactions() to complete the FragmentTransaction.
  /// If postponement was interrupted with FragmentManager\#executePendingTransactions(),
  /// before {@code startPostponedEnterTransition()}, animations may not run or may execute
  /// improperly.
  ///@see Activity\#startPostponedEnterTransition()
  void startPostponedEnterTransition() =>
      _startPostponedEnterTransition(reference).check();

  static final _dump = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Fragment__dump")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  ///
  /// Print the Fragments's state into the given stream.
  ///@param prefix Text to print at the front of each line.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer The PrintWriter to which you should dump your state.  This will be
  /// closed for you after you return.
  ///@param args additional arguments to the dump request.
  void dump(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
          jni.JniObject args) =>
      _dump(reference, prefix.reference, fd.reference, writer.reference,
              args.reference)
          .check();
}

/// from: android.app.Fragment$SavedState
///
/// State information that has been retrieved from a fragment instance
/// through FragmentManager\#saveFragmentInstanceState(Fragment) FragmentManager.saveFragmentInstanceState.
///@deprecated Use android.support.v4.app.Fragment.SavedState
class Fragment_SavedState extends jni.JniObject {
  Fragment_SavedState.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Fragment_SavedState__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.ClassLoaderCreator<android.app.Fragment.SavedState> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_ClassLoaderCreator get CREATOR =>
      os_.Parcelable_ClassLoaderCreator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Fragment_SavedState__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Bundle state)
  Fragment_SavedState(os_.Bundle state)
      : super.fromRef(_ctor(state.reference).object);

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Fragment_SavedState__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Fragment_SavedState__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();
}

/// from: android.app.Fragment$InstantiationException
///
/// Thrown by Fragment\#instantiate(Context, String, Bundle) when
/// there is an instantiation failure.
///@deprecated Use android.support.v4.app.Fragment.InstantiationException
class Fragment_InstantiationException extends jni.JniObject {
  Fragment_InstantiationException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Fragment_InstantiationException__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String msg, java.lang.Exception cause)
  Fragment_InstantiationException(jni.JniString msg, jni.JniObject cause)
      : super.fromRef(_ctor(msg.reference, cause.reference).object);
}

/// from: android.app.FragmentBreadCrumbs
///
/// Helper class for showing "bread crumbs" representing the fragment
/// stack in an activity.  This is intended to be used with
/// ActionBar\#setCustomView(View) ActionBar.setCustomView(View) to place the bread crumbs in
/// the action bar.
///
/// The default style for this view is
/// android.R.style\#Widget_FragmentBreadCrumbs.
///@deprecated This widget is no longer supported.
class FragmentBreadCrumbs extends jni.JniObject {
  FragmentBreadCrumbs.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentBreadCrumbs__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  FragmentBreadCrumbs(content_.Context context)
      : super.fromRef(_ctor(context.reference).object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentBreadCrumbs__ctor1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  FragmentBreadCrumbs.ctor1(content_.Context context, jni.JniObject attrs)
      : super.fromRef(_ctor1(context.reference, attrs.reference).object);

  static final _ctor2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("FragmentBreadCrumbs__ctor2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  FragmentBreadCrumbs.ctor2(
      content_.Context context, jni.JniObject attrs, int defStyleAttr)
      : super.fromRef(
            _ctor2(context.reference, attrs.reference, defStyleAttr).object);

  static final _setActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentBreadCrumbs__setActivity")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setActivity(android.app.Activity a)
  ///
  /// Attach the bread crumbs to their activity.  This must be called once
  /// when creating the bread crumbs.
  void setActivity(Activity a) => _setActivity(reference, a.reference).check();

  static final _setMaxVisible = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("FragmentBreadCrumbs__setMaxVisible")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setMaxVisible(int visibleCrumbs)
  ///
  /// The maximum number of breadcrumbs to show. Older fragment headers will be hidden from view.
  ///@param visibleCrumbs the number of visible breadcrumbs. This should be greater than zero.
  void setMaxVisible(int visibleCrumbs) =>
      _setMaxVisible(reference, visibleCrumbs).check();

  static final _setParentTitle = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "FragmentBreadCrumbs__setParentTitle")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setParentTitle(java.lang.CharSequence title, java.lang.CharSequence shortTitle, android.view.View.OnClickListener listener)
  ///
  /// Inserts an optional parent entry at the first position in the breadcrumbs. Selecting this
  /// entry will result in a call to the specified listener's
  /// android.view.View.OnClickListener\#onClick(View)
  /// method.
  ///@param title the title for the parent entry
  ///@param shortTitle the short title for the parent entry
  ///@param listener the android.view.View.OnClickListener to be called when clicked.
  /// A null will result in no action being taken when the parent entry is clicked.
  void setParentTitle(jni.JniObject title, jni.JniObject shortTitle,
          jni.JniObject listener) =>
      _setParentTitle(reference, title.reference, shortTitle.reference,
              listener.reference)
          .check();

  static final _setOnBreadCrumbClickListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentBreadCrumbs__setOnBreadCrumbClickListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnBreadCrumbClickListener(android.app.FragmentBreadCrumbs.OnBreadCrumbClickListener listener)
  ///
  /// Sets a listener for clicks on the bread crumbs.  This will be called before
  /// the default click action is performed.
  ///@param listener The new listener to set.  Replaces any existing listener.
  void setOnBreadCrumbClickListener(
          FragmentBreadCrumbs_OnBreadCrumbClickListener listener) =>
      _setOnBreadCrumbClickListener(reference, listener.reference).check();

  static final _setTitle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentBreadCrumbs__setTitle")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setTitle(java.lang.CharSequence title, java.lang.CharSequence shortTitle)
  ///
  /// Set a custom title for the bread crumbs.  This will be the first entry
  /// shown at the left, representing the root of the bread crumbs.  If the
  /// title is null, it will not be shown.
  void setTitle(jni.JniObject title, jni.JniObject shortTitle) =>
      _setTitle(reference, title.reference, shortTitle.reference).check();

  static final _onLayout = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("FragmentBreadCrumbs__onLayout")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, int, int, int)>();

  /// from: protected void onLayout(boolean changed, int l, int t, int r, int b)
  void onLayout(bool changed, int l, int t, int r, int b) =>
      _onLayout(reference, changed ? 1 : 0, l, t, r, b).check();

  static final _onMeasure = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("FragmentBreadCrumbs__onMeasure")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  void onMeasure(int widthMeasureSpec, int heightMeasureSpec) =>
      _onMeasure(reference, widthMeasureSpec, heightMeasureSpec).check();

  static final _onBackStackChanged = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentBreadCrumbs__onBackStackChanged")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onBackStackChanged()
  void onBackStackChanged() => _onBackStackChanged(reference).check();
}

/// from: android.app.FragmentBreadCrumbs$OnBreadCrumbClickListener
///
/// Interface to intercept clicks on the bread crumbs.
///@deprecated This widget is no longer supported.
class FragmentBreadCrumbs_OnBreadCrumbClickListener extends jni.JniObject {
  FragmentBreadCrumbs_OnBreadCrumbClickListener.fromRef(
      ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onBreadCrumbClick = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "FragmentBreadCrumbs_OnBreadCrumbClickListener__onBreadCrumbClick")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract boolean onBreadCrumbClick(android.app.FragmentManager.BackStackEntry backStack, int flags)
  ///
  /// Called when a bread crumb is clicked.
  ///@param backStack The BackStackEntry whose bread crumb was clicked.
  /// May be null, if this bread crumb is for the root of the back stack.
  ///@param flags Additional information about the entry.  Currently
  /// always 0.
  ///@return Return true to consume this click.  Return to false to allow
  /// the default action (popping back stack to this entry) to occur.
  bool onBreadCrumbClick(FragmentManager_BackStackEntry backStack, int flags) =>
      _onBreadCrumbClick(reference, backStack.reference, flags).boolean;
}

/// from: android.app.FragmentContainer
///
/// Callbacks to a Fragment's container.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.FragmentContainer.
class FragmentContainer extends jni.JniObject {
  FragmentContainer.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "FragmentContainer__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  FragmentContainer() : super.fromRef(_ctor().object);

  static final _onHasView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentContainer__onHasView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean onHasView()
  ///
  /// Return {@code true} if the container holds any view.
  bool onHasView() => _onHasView(reference).boolean;
}

/// from: android.app.FragmentController
///
/// Provides integration points with a FragmentManager for a fragment host.
///
/// It is the responsibility of the host to take care of the Fragment's lifecycle.
/// The methods provided by FragmentController are for that purpose.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.FragmentController
class FragmentController extends jni.JniObject {
  FragmentController.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentController__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.app.FragmentHostCallback<?> callbacks)
  FragmentController(FragmentHostCallback callbacks)
      : super.fromRef(_ctor(callbacks.reference).object);

  static final _createController = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentController__createController")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public final android.app.FragmentController createController(android.app.FragmentHostCallback<?> callbacks)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a FragmentController.
  static FragmentController createController(FragmentHostCallback callbacks) =>
      FragmentController.fromRef(_createController(callbacks.reference).object);

  static final _getFragmentManager = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentController__getFragmentManager")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.FragmentManager getFragmentManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a FragmentManager for this controller.
  FragmentManager getFragmentManager() =>
      FragmentManager.fromRef(_getFragmentManager(reference).object);

  static final _getLoaderManager = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentController__getLoaderManager")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.LoaderManager getLoaderManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a LoaderManager.
  LoaderManager getLoaderManager() =>
      LoaderManager.fromRef(_getLoaderManager(reference).object);

  static final _findFragmentByWho = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentController__findFragmentByWho")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Fragment findFragmentByWho(java.lang.String who)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a fragment with the given identifier.
  ///@return This value may be {@code null}.
  Fragment findFragmentByWho(jni.JniString who) =>
      Fragment.fromRef(_findFragmentByWho(reference, who.reference).object);

  static final _attachHost = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentController__attachHost")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void attachHost(android.app.Fragment parent)
  ///
  /// Attaches the host to the FragmentManager for this controller. The host must be
  /// attached before the FragmentManager can be used to manage Fragments.
  void attachHost(Fragment parent) =>
      _attachHost(reference, parent.reference).check();

  static final _onCreateView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentController__onCreateView")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View onCreateView(android.view.View parent, java.lang.String name, android.content.Context context, android.util.AttributeSet attrs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Instantiates a Fragment's view.
  ///@param parent The parent that the created view will be placed
  /// in; _note that this may be null_.
  ///@param name Tag name to be inflated.
  ///@param context The context the view is being created in.
  ///@param attrs Inflation attributes as specified in XML file.
  ///@return view the newly created view
  jni.JniObject onCreateView(jni.JniObject parent, jni.JniString name,
          content_.Context context, jni.JniObject attrs) =>
      jni.JniObject.fromRef(_onCreateView(reference, parent.reference,
              name.reference, context.reference, attrs.reference)
          .object);

  static final _noteStateNotSaved = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentController__noteStateNotSaved")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void noteStateNotSaved()
  ///
  /// Marks the fragment state as unsaved. This allows for "state loss" detection.
  void noteStateNotSaved() => _noteStateNotSaved(reference).check();

  static final _saveAllState = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentController__saveAllState")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Parcelable saveAllState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Saves the state for all Fragments.
  os_.Parcelable saveAllState() =>
      os_.Parcelable.fromRef(_saveAllState(reference).object);

  static final _restoreAllState = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentController__restoreAllState")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void restoreAllState(android.os.Parcelable state, java.util.List<android.app.Fragment> nonConfigList)
  ///
  /// Restores the saved state for all Fragments. The given Fragment list are Fragment
  /// instances retained across configuration changes.
  ///@see \#retainNonConfig()
  ///@deprecated use \#restoreAllState(Parcelable, FragmentManagerNonConfig)
  void restoreAllState(os_.Parcelable state, jni.JniObject nonConfigList) =>
      _restoreAllState(reference, state.reference, nonConfigList.reference)
          .check();

  static final _restoreAllState1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentController__restoreAllState1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void restoreAllState(android.os.Parcelable state, android.app.FragmentManagerNonConfig nonConfig)
  ///
  /// Restores the saved state for all Fragments. The given FragmentManagerNonConfig are Fragment
  /// instances retained across configuration changes, including nested fragments
  ///@see \#retainNestedNonConfig()
  void restoreAllState1(
          os_.Parcelable state, FragmentManagerNonConfig nonConfig) =>
      _restoreAllState1(reference, state.reference, nonConfig.reference)
          .check();

  static final _retainNonConfig = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentController__retainNonConfig")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.Fragment> retainNonConfig()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of Fragments that have opted to retain their instance across
  /// configuration changes.
  ///@deprecated use \#retainNestedNonConfig() to also track retained
  ///             nested child fragments
  jni.JniObject retainNonConfig() =>
      jni.JniObject.fromRef(_retainNonConfig(reference).object);

  static final _retainNestedNonConfig = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentController__retainNestedNonConfig")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.FragmentManagerNonConfig retainNestedNonConfig()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a nested tree of Fragments that have opted to retain their instance across
  /// configuration changes.
  FragmentManagerNonConfig retainNestedNonConfig() =>
      FragmentManagerNonConfig.fromRef(
          _retainNestedNonConfig(reference).object);

  static final _dispatchCreate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentController__dispatchCreate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchCreate()
  ///
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the create state.
  /// Call when Fragments should be created.
  ///@see Fragment\#onCreate(Bundle)
  void dispatchCreate() => _dispatchCreate(reference).check();

  static final _dispatchActivityCreated = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentController__dispatchActivityCreated")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchActivityCreated()
  ///
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the activity created state.
  /// Call when Fragments should be informed their host has been created.
  ///@see Fragment\#onActivityCreated(Bundle)
  void dispatchActivityCreated() => _dispatchActivityCreated(reference).check();

  static final _dispatchStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentController__dispatchStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchStart()
  ///
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the start state.
  /// Call when Fragments should be started.
  ///@see Fragment\#onStart()
  void dispatchStart() => _dispatchStart(reference).check();

  static final _dispatchResume = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentController__dispatchResume")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchResume()
  ///
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the resume state.
  /// Call when Fragments should be resumed.
  ///@see Fragment\#onResume()
  void dispatchResume() => _dispatchResume(reference).check();

  static final _dispatchPause = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentController__dispatchPause")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchPause()
  ///
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the pause state.
  /// Call when Fragments should be paused.
  ///@see Fragment\#onPause()
  void dispatchPause() => _dispatchPause(reference).check();

  static final _dispatchStop = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentController__dispatchStop")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchStop()
  ///
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the stop state.
  /// Call when Fragments should be stopped.
  ///@see Fragment\#onStop()
  void dispatchStop() => _dispatchStop(reference).check();

  static final _dispatchDestroyView = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentController__dispatchDestroyView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchDestroyView()
  ///
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the destroy view state.
  /// Call when the Fragment's views should be destroyed.
  ///@see Fragment\#onDestroyView()
  void dispatchDestroyView() => _dispatchDestroyView(reference).check();

  static final _dispatchDestroy = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentController__dispatchDestroy")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchDestroy()
  ///
  /// Moves all Fragments managed by the controller's FragmentManager
  /// into the destroy state.
  /// Call when Fragments should be destroyed.
  ///@see Fragment\#onDestroy()
  void dispatchDestroy() => _dispatchDestroy(reference).check();

  static final _dispatchMultiWindowModeChanged = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "FragmentController__dispatchMultiWindowModeChanged")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void dispatchMultiWindowModeChanged(boolean isInMultiWindowMode)
  ///
  /// Lets all Fragments managed by the controller's FragmentManager know the multi-window mode of
  /// the activity changed.
  /// Call when the multi-window mode of the activity changed.
  ///@see Fragment\#onMultiWindowModeChanged
  ///@deprecated use \#dispatchMultiWindowModeChanged(boolean, Configuration)
  void dispatchMultiWindowModeChanged(bool isInMultiWindowMode) =>
      _dispatchMultiWindowModeChanged(reference, isInMultiWindowMode ? 1 : 0)
          .check();

  static final _dispatchMultiWindowModeChanged1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                      ffi.Pointer<ffi.Void>)>>(
          "FragmentController__dispatchMultiWindowModeChanged1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchMultiWindowModeChanged(boolean isInMultiWindowMode, android.content.res.Configuration newConfig)
  ///
  /// Lets all Fragments managed by the controller's FragmentManager know the multi-window mode of
  /// the activity changed.
  /// Call when the multi-window mode of the activity changed.
  ///@see Fragment\#onMultiWindowModeChanged
  void dispatchMultiWindowModeChanged1(
          bool isInMultiWindowMode, res_.Configuration newConfig) =>
      _dispatchMultiWindowModeChanged1(
              reference, isInMultiWindowMode ? 1 : 0, newConfig.reference)
          .check();

  static final _dispatchPictureInPictureModeChanged = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "FragmentController__dispatchPictureInPictureModeChanged")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void dispatchPictureInPictureModeChanged(boolean isInPictureInPictureMode)
  ///
  /// Lets all Fragments managed by the controller's FragmentManager know the picture-in-picture
  /// mode of the activity changed.
  /// Call when the picture-in-picture mode of the activity changed.
  ///@see Fragment\#onPictureInPictureModeChanged
  ///@deprecated use \#dispatchPictureInPictureModeChanged(boolean, Configuration)
  void dispatchPictureInPictureModeChanged(bool isInPictureInPictureMode) =>
      _dispatchPictureInPictureModeChanged(
              reference, isInPictureInPictureMode ? 1 : 0)
          .check();

  static final _dispatchPictureInPictureModeChanged1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                      ffi.Pointer<ffi.Void>)>>(
          "FragmentController__dispatchPictureInPictureModeChanged1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchPictureInPictureModeChanged(boolean isInPictureInPictureMode, android.content.res.Configuration newConfig)
  ///
  /// Lets all Fragments managed by the controller's FragmentManager know the picture-in-picture
  /// mode of the activity changed.
  /// Call when the picture-in-picture mode of the activity changed.
  ///@see Fragment\#onPictureInPictureModeChanged
  void dispatchPictureInPictureModeChanged1(
          bool isInPictureInPictureMode, res_.Configuration newConfig) =>
      _dispatchPictureInPictureModeChanged1(
              reference, isInPictureInPictureMode ? 1 : 0, newConfig.reference)
          .check();

  static final _dispatchConfigurationChanged = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentController__dispatchConfigurationChanged")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchConfigurationChanged(android.content.res.Configuration newConfig)
  ///
  /// Lets all Fragments managed by the controller's FragmentManager
  /// know a configuration change occurred.
  /// Call when there is a configuration change.
  ///@see Fragment\#onConfigurationChanged(Configuration)
  void dispatchConfigurationChanged(res_.Configuration newConfig) =>
      _dispatchConfigurationChanged(reference, newConfig.reference).check();

  static final _dispatchLowMemory = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentController__dispatchLowMemory")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchLowMemory()
  ///
  /// Lets all Fragments managed by the controller's FragmentManager
  /// know the device is in a low memory condition.
  /// Call when the device is low on memory and Fragment's should trim
  /// their memory usage.
  ///@see Fragment\#onLowMemory()
  void dispatchLowMemory() => _dispatchLowMemory(reference).check();

  static final _dispatchTrimMemory = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("FragmentController__dispatchTrimMemory")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void dispatchTrimMemory(int level)
  ///
  /// Lets all Fragments managed by the controller's FragmentManager
  /// know they should trim their memory usage.
  /// Call when the Fragment can release allocated memory [such as if
  /// the Fragment is in the background].
  ///@see Fragment\#onTrimMemory(int)
  void dispatchTrimMemory(int level) =>
      _dispatchTrimMemory(reference, level).check();

  static final _dispatchCreateOptionsMenu = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentController__dispatchCreateOptionsMenu")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchCreateOptionsMenu(android.view.Menu menu, android.view.MenuInflater inflater)
  ///
  /// Lets all Fragments managed by the controller's FragmentManager
  /// know they should create an options menu.
  /// Call when the Fragment should create an options menu.
  ///@return {@code true} if the options menu contains items to display
  ///@see Fragment\#onCreateOptionsMenu(Menu, MenuInflater)
  bool dispatchCreateOptionsMenu(jni.JniObject menu, jni.JniObject inflater) =>
      _dispatchCreateOptionsMenu(reference, menu.reference, inflater.reference)
          .boolean;

  static final _dispatchPrepareOptionsMenu = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentController__dispatchPrepareOptionsMenu")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchPrepareOptionsMenu(android.view.Menu menu)
  ///
  /// Lets all Fragments managed by the controller's FragmentManager
  /// know they should prepare their options menu for display.
  /// Call immediately before displaying the Fragment's options menu.
  ///@return {@code true} if the options menu contains items to display
  ///@see Fragment\#onPrepareOptionsMenu(Menu)
  bool dispatchPrepareOptionsMenu(jni.JniObject menu) =>
      _dispatchPrepareOptionsMenu(reference, menu.reference).boolean;

  static final _dispatchOptionsItemSelected = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentController__dispatchOptionsItemSelected")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchOptionsItemSelected(android.view.MenuItem item)
  ///
  /// Sends an option item selection event to the Fragments managed by the
  /// controller's FragmentManager. Once the event has been consumed,
  /// no additional handling will be performed.
  /// Call immediately after an options menu item has been selected
  ///@return {@code true} if the options menu selection event was consumed
  ///@see Fragment\#onOptionsItemSelected(MenuItem)
  bool dispatchOptionsItemSelected(jni.JniObject item) =>
      _dispatchOptionsItemSelected(reference, item.reference).boolean;

  static final _dispatchContextItemSelected = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentController__dispatchContextItemSelected")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean dispatchContextItemSelected(android.view.MenuItem item)
  ///
  /// Sends a context item selection event to the Fragments managed by the
  /// controller's FragmentManager. Once the event has been consumed,
  /// no additional handling will be performed.
  /// Call immediately after an options menu item has been selected
  ///@return {@code true} if the context menu selection event was consumed
  ///@see Fragment\#onContextItemSelected(MenuItem)
  bool dispatchContextItemSelected(jni.JniObject item) =>
      _dispatchContextItemSelected(reference, item.reference).boolean;

  static final _dispatchOptionsMenuClosed = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentController__dispatchOptionsMenuClosed")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchOptionsMenuClosed(android.view.Menu menu)
  ///
  /// Lets all Fragments managed by the controller's FragmentManager
  /// know their options menu has closed.
  /// Call immediately after closing the Fragment's options menu.
  ///@see Fragment\#onOptionsMenuClosed(Menu)
  void dispatchOptionsMenuClosed(jni.JniObject menu) =>
      _dispatchOptionsMenuClosed(reference, menu.reference).check();

  static final _execPendingActions = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentController__execPendingActions")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean execPendingActions()
  ///
  /// Execute any pending actions for the Fragments managed by the
  /// controller's FragmentManager.
  /// Call when queued actions can be performed [eg when the
  /// Fragment moves into a start or resume state].
  ///@return {@code true} if queued actions were performed
  bool execPendingActions() => _execPendingActions(reference).boolean;

  static final _doLoaderStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentController__doLoaderStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void doLoaderStart()
  ///
  /// Starts the loaders.
  void doLoaderStart() => _doLoaderStart(reference).check();

  static final _doLoaderStop = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("FragmentController__doLoaderStop")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void doLoaderStop(boolean retain)
  ///
  /// Stops the loaders, optionally retaining their state. This is useful for keeping the
  /// loader state across configuration changes.
  ///@param retain When {@code true}, the loaders aren't stopped, but, their instances
  /// are retained in a started state
  void doLoaderStop(bool retain) =>
      _doLoaderStop(reference, retain ? 1 : 0).check();

  static final _doLoaderDestroy = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentController__doLoaderDestroy")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void doLoaderDestroy()
  ///
  /// Destroys the loaders and, if their state is not being retained, removes them.
  void doLoaderDestroy() => _doLoaderDestroy(reference).check();

  static final _reportLoaderStart = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentController__reportLoaderStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void reportLoaderStart()
  ///
  /// Lets the loaders know the host is ready to receive notifications.
  void reportLoaderStart() => _reportLoaderStart(reference).check();

  static final _retainLoaderNonConfig = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentController__retainLoaderNonConfig")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.util.ArrayMap<java.lang.String,android.app.LoaderManager> retainLoaderNonConfig()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of LoaderManagers that have opted to retain their instance across
  /// configuration changes.
  jni.JniObject retainLoaderNonConfig() =>
      jni.JniObject.fromRef(_retainLoaderNonConfig(reference).object);

  static final _restoreLoaderNonConfig = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentController__restoreLoaderNonConfig")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void restoreLoaderNonConfig(android.util.ArrayMap<java.lang.String,android.app.LoaderManager> loaderManagers)
  ///
  /// Restores the saved state for all LoaderManagers. The given LoaderManager list are
  /// LoaderManager instances retained across configuration changes.
  ///@see \#retainLoaderNonConfig()
  void restoreLoaderNonConfig(jni.JniObject loaderManagers) =>
      _restoreLoaderNonConfig(reference, loaderManagers.reference).check();

  static final _dumpLoaders = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentController__dumpLoaders")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dumpLoaders(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  ///
  /// Dumps the current state of the loaders.
  void dumpLoaders(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
          jni.JniObject args) =>
      _dumpLoaders(reference, prefix.reference, fd.reference, writer.reference,
              args.reference)
          .check();
}

/// from: android.app.FragmentHostCallback
///
/// Integration points with the Fragment host.
///
/// Fragments may be hosted by any object; such as an Activity. In order to
/// host fragments, implement FragmentHostCallback, overriding the methods
/// applicable to the host.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.FragmentHostCallback
class FragmentHostCallback extends FragmentContainer {
  FragmentHostCallback.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("FragmentHostCallback__ctor1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Context context, android.os.Handler handler, int windowAnimations)
  FragmentHostCallback.ctor1(
      content_.Context context, os_.Handler handler, int windowAnimations)
      : super.fromRef(
            _ctor1(context.reference, handler.reference, windowAnimations)
                .object);

  static final _onDump = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentHostCallback__onDump")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onDump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  ///
  /// Print internal state into the given stream.
  ///@param prefix Desired prefix to prepend at each line of output.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer The PrintWriter to which you should dump your state. This will be closed
  ///                  for you after you return.
  ///@param args additional arguments to the dump request.
  void onDump(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
          jni.JniObject args) =>
      _onDump(reference, prefix.reference, fd.reference, writer.reference,
              args.reference)
          .check();

  static final _onShouldSaveFragmentState = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentHostCallback__onShouldSaveFragmentState")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onShouldSaveFragmentState(android.app.Fragment fragment)
  ///
  /// Return {@code true} if the fragment's state needs to be saved.
  bool onShouldSaveFragmentState(Fragment fragment) =>
      _onShouldSaveFragmentState(reference, fragment.reference).boolean;

  static final _onGetLayoutInflater = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentHostCallback__onGetLayoutInflater")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.LayoutInflater onGetLayoutInflater()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a LayoutInflater.
  /// See Activity\#getLayoutInflater().
  jni.JniObject onGetLayoutInflater() =>
      jni.JniObject.fromRef(_onGetLayoutInflater(reference).object);

  static final _onUseFragmentManagerInflaterFactory = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentHostCallback__onUseFragmentManagerInflaterFactory")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onUseFragmentManagerInflaterFactory()
  ///
  /// Return {@code true} if the FragmentManager's LayoutInflaterFactory should be used.
  bool onUseFragmentManagerInflaterFactory() =>
      _onUseFragmentManagerInflaterFactory(reference).boolean;

  static final _onInvalidateOptionsMenu = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentHostCallback__onInvalidateOptionsMenu")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onInvalidateOptionsMenu()
  ///
  /// Invalidates the activity's options menu.
  /// See Activity\#invalidateOptionsMenu()
  void onInvalidateOptionsMenu() => _onInvalidateOptionsMenu(reference).check();

  static final _onStartActivityFromFragment = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "FragmentHostCallback__onStartActivityFromFragment")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onStartActivityFromFragment(android.app.Fragment fragment, android.content.Intent intent, int requestCode, android.os.Bundle options)
  ///
  /// Starts a new Activity from the given fragment.
  /// See Activity\#startActivityForResult(Intent, int).
  void onStartActivityFromFragment(Fragment fragment, content_.Intent intent,
          int requestCode, os_.Bundle options) =>
      _onStartActivityFromFragment(reference, fragment.reference,
              intent.reference, requestCode, options.reference)
          .check();

  static final _onStartIntentSenderFromFragment = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "FragmentHostCallback__onStartIntentSenderFromFragment")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onStartIntentSenderFromFragment(android.app.Fragment fragment, android.content.IntentSender intent, int requestCode, android.content.Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, android.os.Bundle options)
  ///
  /// Starts a new IntentSender from the given fragment.
  /// See Activity\#startIntentSender(IntentSender, Intent, int, int, int, Bundle).
  ///@param fillInIntent This value may be {@code null}.
  void onStartIntentSenderFromFragment(
          Fragment fragment,
          content_.IntentSender intent,
          int requestCode,
          content_.Intent fillInIntent,
          int flagsMask,
          int flagsValues,
          int extraFlags,
          os_.Bundle options) =>
      _onStartIntentSenderFromFragment(
              reference,
              fragment.reference,
              intent.reference,
              requestCode,
              fillInIntent.reference,
              flagsMask,
              flagsValues,
              extraFlags,
              options.reference)
          .check();

  static final _onRequestPermissionsFromFragment = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32)>>(
          "FragmentHostCallback__onRequestPermissionsFromFragment")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onRequestPermissionsFromFragment(android.app.Fragment fragment, java.lang.String[] permissions, int requestCode)
  ///
  /// Requests permissions from the given fragment.
  /// See Activity\#requestPermissions(String[], int)
  ///@param fragment This value must never be {@code null}.
  ///@param permissions This value must never be {@code null}.
  void onRequestPermissionsFromFragment(
          Fragment fragment, jni.JniObject permissions, int requestCode) =>
      _onRequestPermissionsFromFragment(
              reference, fragment.reference, permissions.reference, requestCode)
          .check();

  static final _onHasWindowAnimations = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentHostCallback__onHasWindowAnimations")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onHasWindowAnimations()
  ///
  /// Return {@code true} if there are window animations.
  bool onHasWindowAnimations() => _onHasWindowAnimations(reference).boolean;

  static final _onGetWindowAnimations = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentHostCallback__onGetWindowAnimations")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int onGetWindowAnimations()
  ///
  /// Return the window animations.
  int onGetWindowAnimations() => _onGetWindowAnimations(reference).integer;

  static final _onAttachFragment = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentHostCallback__onAttachFragment")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttachFragment(android.app.Fragment fragment)
  ///
  /// Called when a Fragment is being attached to this host, immediately
  /// after the call to its Fragment\#onAttach(Context) method and before
  /// Fragment\#onCreate(Bundle).
  void onAttachFragment(Fragment fragment) =>
      _onAttachFragment(reference, fragment.reference).check();

  static final _onHasView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentHostCallback__onHasView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onHasView()
  bool onHasView() => _onHasView(reference).boolean;
}

/// from: android.app.FragmentManager
///
/// Interface for interacting with Fragment objects inside of an
/// Activity
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using fragments, read the
/// <a href="{@docRoot}guide/components/fragments.html">Fragments</a> developer guide.
///
/// </div>
///
/// While the FragmentManager API was introduced in
/// android.os.Build.VERSION_CODES\#HONEYCOMB, a version of the API
/// at is also available for use on older platforms through
/// android.support.v4.app.FragmentActivity.  See the blog post
/// <a href="http://android-developers.blogspot.com/2011/03/fragments-for-all.html">
/// Fragments For All</a> for more details.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.FragmentManager for consistent behavior across all devices
///      and access to <a href="{@docRoot}topic/libraries/architecture/lifecycle.html">Lifecycle</a>.
class FragmentManager extends jni.JniObject {
  FragmentManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int POP_BACK_STACK_INCLUSIVE
  ///
  /// Flag for \#popBackStack(String, int)
  /// and \#popBackStack(int, int): If set, and the name or ID of
  /// a back stack entry has been supplied, then all matching entries will
  /// be consumed until one that doesn't match is found or the bottom of
  /// the stack is reached.  Otherwise, all entries up to but not including that entry
  /// will be removed.
  static const POP_BACK_STACK_INCLUSIVE = 1;

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "FragmentManager__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  FragmentManager() : super.fromRef(_ctor().object);

  static final _beginTransaction = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentManager__beginTransaction")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction beginTransaction()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start a series of edit operations on the Fragments associated with
  /// this FragmentManager.
  ///
  /// Note: A fragment transaction can only be created/committed prior
  /// to an activity saving its state.  If you try to commit a transaction
  /// after Activity\#onSaveInstanceState Activity.onSaveInstanceState()
  /// (and prior to a following Activity\#onStart Activity.onStart
  /// or Activity\#onResume Activity.onResume(), you will get an error.
  /// This is because the framework takes care of saving your current fragments
  /// in the state, and if changes are made after the state is saved then they
  /// will be lost.
  ///
  FragmentTransaction beginTransaction() =>
      FragmentTransaction.fromRef(_beginTransaction(reference).object);

  static final _executePendingTransactions = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentManager__executePendingTransactions")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean executePendingTransactions()
  ///
  /// After a FragmentTransaction is committed with
  /// FragmentTransaction\#commit FragmentTransaction.commit(), it
  /// is scheduled to be executed asynchronously on the process's main thread.
  /// If you want to immediately executing any such pending operations, you
  /// can call this function (only from the main thread) to do so.  Note that
  /// all callbacks and other related behavior will be done from within this
  /// call, so be careful about where this is called from.
  ///
  /// This also forces the start of any postponed Transactions where
  /// Fragment\#postponeEnterTransition() has been called.
  ///@return Returns true if there were any pending transactions to be
  /// executed.
  bool executePendingTransactions() =>
      _executePendingTransactions(reference).boolean;

  static final _findFragmentById = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("FragmentManager__findFragmentById")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.Fragment findFragmentById(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Finds a fragment that was identified by the given id either when inflated
  /// from XML or as the container ID when added in a transaction.  This first
  /// searches through fragments that are currently added to the manager's
  /// activity; if no such fragment is found, then all fragments currently
  /// on the back stack associated with this ID are searched.
  ///@return The fragment if found or null otherwise.
  Fragment findFragmentById(int id) =>
      Fragment.fromRef(_findFragmentById(reference, id).object);

  static final _findFragmentByTag = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentManager__findFragmentByTag")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.Fragment findFragmentByTag(java.lang.String tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Finds a fragment that was identified by the given tag either when inflated
  /// from XML or as supplied when added in a transaction.  This first
  /// searches through fragments that are currently added to the manager's
  /// activity; if no such fragment is found, then all fragments currently
  /// on the back stack are searched.
  ///@return The fragment if found or null otherwise.
  Fragment findFragmentByTag(jni.JniString tag) =>
      Fragment.fromRef(_findFragmentByTag(reference, tag.reference).object);

  static final _popBackStack = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentManager__popBackStack")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void popBackStack()
  ///
  /// Pop the top state off the back stack.  This function is asynchronous -- it
  /// enqueues the request to pop, but the action will not be performed until the
  /// application returns to its event loop.
  void popBackStack() => _popBackStack(reference).check();

  static final _popBackStackImmediate = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentManager__popBackStackImmediate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean popBackStackImmediate()
  ///
  /// Like \#popBackStack(), but performs the operation immediately
  /// inside of the call.  This is like calling \#executePendingTransactions()
  /// afterwards without forcing the start of postponed Transactions.
  ///@return Returns true if there was something popped, else false.
  bool popBackStackImmediate() => _popBackStackImmediate(reference).boolean;

  static final _popBackStack1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("FragmentManager__popBackStack1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void popBackStack(java.lang.String name, int flags)
  ///
  /// Pop the last fragment transition from the manager's fragment
  /// back stack.  If there is nothing to pop, false is returned.
  /// This function is asynchronous -- it enqueues the
  /// request to pop, but the action will not be performed until the application
  /// returns to its event loop.
  ///@param name If non-null, this is the name of a previous back state
  /// to look for; if found, all states up to that state will be popped.  The
  /// \#POP_BACK_STACK_INCLUSIVE flag can be used to control whether
  /// the named state itself is popped. If null, only the top state is popped.
  ///@param flags Either 0 or \#POP_BACK_STACK_INCLUSIVE.
  void popBackStack1(jni.JniString name, int flags) =>
      _popBackStack1(reference, name.reference, flags).check();

  static final _popBackStackImmediate1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("FragmentManager__popBackStackImmediate1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract boolean popBackStackImmediate(java.lang.String name, int flags)
  ///
  /// Like \#popBackStack(String, int), but performs the operation immediately
  /// inside of the call.  This is like calling \#executePendingTransactions()
  /// afterwards without forcing the start of postponed Transactions.
  ///@return Returns true if there was something popped, else false.
  bool popBackStackImmediate1(jni.JniString name, int flags) =>
      _popBackStackImmediate1(reference, name.reference, flags).boolean;

  static final _popBackStack2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("FragmentManager__popBackStack2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void popBackStack(int id, int flags)
  ///
  /// Pop all back stack states up to the one with the given identifier.
  /// This function is asynchronous -- it enqueues the
  /// request to pop, but the action will not be performed until the application
  /// returns to its event loop.
  ///@param id Identifier of the stated to be popped. If no identifier exists,
  /// false is returned.
  /// The identifier is the number returned by
  /// FragmentTransaction\#commit() FragmentTransaction.commit().  The
  /// \#POP_BACK_STACK_INCLUSIVE flag can be used to control whether
  /// the named state itself is popped.
  ///@param flags Either 0 or \#POP_BACK_STACK_INCLUSIVE.
  void popBackStack2(int id, int flags) =>
      _popBackStack2(reference, id, flags).check();

  static final _popBackStackImmediate2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("FragmentManager__popBackStackImmediate2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract boolean popBackStackImmediate(int id, int flags)
  ///
  /// Like \#popBackStack(int, int), but performs the operation immediately
  /// inside of the call.  This is like calling \#executePendingTransactions()
  /// afterwards without forcing the start of postponed Transactions.
  ///@return Returns true if there was something popped, else false.
  bool popBackStackImmediate2(int id, int flags) =>
      _popBackStackImmediate2(reference, id, flags).boolean;

  static final _getBackStackEntryCount = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentManager__getBackStackEntryCount")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getBackStackEntryCount()
  ///
  /// Return the number of entries currently in the back stack.
  int getBackStackEntryCount() => _getBackStackEntryCount(reference).integer;

  static final _getBackStackEntryAt = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("FragmentManager__getBackStackEntryAt")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.FragmentManager.BackStackEntry getBackStackEntryAt(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the BackStackEntry at index <var>index</var> in the back stack;
  /// where the item on the bottom of the stack has index 0.
  FragmentManager_BackStackEntry getBackStackEntryAt(int index) =>
      FragmentManager_BackStackEntry.fromRef(
          _getBackStackEntryAt(reference, index).object);

  static final _addOnBackStackChangedListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentManager__addOnBackStackChangedListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void addOnBackStackChangedListener(android.app.FragmentManager.OnBackStackChangedListener listener)
  ///
  /// Add a new listener for changes to the fragment back stack.
  void addOnBackStackChangedListener(
          FragmentManager_OnBackStackChangedListener listener) =>
      _addOnBackStackChangedListener(reference, listener.reference).check();

  static final _removeOnBackStackChangedListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentManager__removeOnBackStackChangedListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void removeOnBackStackChangedListener(android.app.FragmentManager.OnBackStackChangedListener listener)
  ///
  /// Remove a listener that was previously added with
  /// \#addOnBackStackChangedListener(OnBackStackChangedListener).
  void removeOnBackStackChangedListener(
          FragmentManager_OnBackStackChangedListener listener) =>
      _removeOnBackStackChangedListener(reference, listener.reference).check();

  static final _putFragment = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentManager__putFragment")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void putFragment(android.os.Bundle bundle, java.lang.String key, android.app.Fragment fragment)
  ///
  /// Put a reference to a fragment in a Bundle.  This Bundle can be
  /// persisted as saved state, and when later restoring
  /// \#getFragment(Bundle, String) will return the current
  /// instance of the same fragment.
  ///@param bundle The bundle in which to put the fragment reference.
  ///@param key The name of the entry in the bundle.
  ///@param fragment The Fragment whose reference is to be stored.
  void putFragment(os_.Bundle bundle, jni.JniString key, Fragment fragment) =>
      _putFragment(
              reference, bundle.reference, key.reference, fragment.reference)
          .check();

  static final _getFragment = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentManager__getFragment")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.Fragment getFragment(android.os.Bundle bundle, java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the current Fragment instance for a reference previously
  /// placed with \#putFragment(Bundle, String, Fragment).
  ///@param bundle The bundle from which to retrieve the fragment reference.
  ///@param key The name of the entry in the bundle.
  ///@return Returns the current Fragment instance that is associated with
  /// the given reference.
  Fragment getFragment(os_.Bundle bundle, jni.JniString key) =>
      Fragment.fromRef(
          _getFragment(reference, bundle.reference, key.reference).object);

  static final _getFragments = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentManager__getFragments")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.util.List<android.app.Fragment> getFragments()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a list of all fragments that are currently added to the FragmentManager.
  /// This may include those that are hidden as well as those that are shown.
  /// This will not include any fragments only in the back stack, or fragments that
  /// are detached or removed.
  ///
  /// The order of the fragments in the list is the order in which they were
  /// added or attached.
  ///@return A list of all fragments that are added to the FragmentManager.
  jni.JniObject getFragments() =>
      jni.JniObject.fromRef(_getFragments(reference).object);

  static final _saveFragmentInstanceState = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentManager__saveFragmentInstanceState")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.Fragment.SavedState saveFragmentInstanceState(android.app.Fragment f)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Save the current instance state of the given Fragment.  This can be
  /// used later when creating a new instance of the Fragment and adding
  /// it to the fragment manager, to have it create itself to match the
  /// current state returned here.  Note that there are limits on how
  /// this can be used:
  ///
  /// <ul>
  /// <li>The Fragment must currently be attached to the FragmentManager.
  /// <li>A new Fragment created using this saved state must be the same class
  /// type as the Fragment it was created from.
  /// <li>The saved state can not contain dependencies on other fragments --
  /// that is it can't use \#putFragment(Bundle, String, Fragment) to
  /// store a fragment reference because that reference may not be valid when
  /// this saved state is later used.  Likewise the Fragment's target and
  /// result code are not included in this state.
  /// </ul>
  ///@param f The Fragment whose state is to be saved.
  ///@return The generated state.  This will be null if there was no
  /// interesting state created by the fragment.
  Fragment_SavedState saveFragmentInstanceState(Fragment f) =>
      Fragment_SavedState.fromRef(
          _saveFragmentInstanceState(reference, f.reference).object);

  static final _isDestroyed = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentManager__isDestroyed")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isDestroyed()
  ///
  /// Returns true if the final Activity\#onDestroy() Activity.onDestroy()
  /// call has been made on the FragmentManager's Activity, so this instance is now dead.
  bool isDestroyed() => _isDestroyed(reference).boolean;

  static final _registerFragmentLifecycleCallbacks = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "FragmentManager__registerFragmentLifecycleCallbacks")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void registerFragmentLifecycleCallbacks(android.app.FragmentManager.FragmentLifecycleCallbacks cb, boolean recursive)
  ///
  /// Registers a FragmentLifecycleCallbacks to listen to fragment lifecycle events
  /// happening in this FragmentManager. All registered callbacks will be automatically
  /// unregistered when this FragmentManager is destroyed.
  ///@param cb Callbacks to register
  ///@param recursive true to automatically register this callback for all child FragmentManagers
  void registerFragmentLifecycleCallbacks(
          FragmentManager_FragmentLifecycleCallbacks cb, bool recursive) =>
      _registerFragmentLifecycleCallbacks(
              reference, cb.reference, recursive ? 1 : 0)
          .check();

  static final _unregisterFragmentLifecycleCallbacks = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentManager__unregisterFragmentLifecycleCallbacks")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void unregisterFragmentLifecycleCallbacks(android.app.FragmentManager.FragmentLifecycleCallbacks cb)
  ///
  /// Unregisters a previously registered FragmentLifecycleCallbacks. If the callback
  /// was not previously registered this call has no effect. All registered callbacks will be
  /// automatically unregistered when this FragmentManager is destroyed.
  ///@param cb Callbacks to unregister
  void unregisterFragmentLifecycleCallbacks(
          FragmentManager_FragmentLifecycleCallbacks cb) =>
      _unregisterFragmentLifecycleCallbacks(reference, cb.reference).check();

  static final _getPrimaryNavigationFragment = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentManager__getPrimaryNavigationFragment")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.Fragment getPrimaryNavigationFragment()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the currently active primary navigation fragment for this FragmentManager.
  ///
  /// The primary navigation fragment's
  /// Fragment\#getChildFragmentManager() child FragmentManager will be called first
  /// to process delegated navigation actions such as \#popBackStack() if no ID
  /// or transaction name is provided to pop to.
  ///
  ///@return the fragment designated as the primary navigation fragment
  Fragment getPrimaryNavigationFragment() =>
      Fragment.fromRef(_getPrimaryNavigationFragment(reference).object);

  static final _dump = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentManager__dump")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  ///
  /// Print the FragmentManager's state into the given stream.
  ///@param prefix Text to print at the front of each line.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer A PrintWriter to which the dump is to be set.
  ///@param args Additional arguments to the dump request.
  void dump(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
          jni.JniObject args) =>
      _dump(reference, prefix.reference, fd.reference, writer.reference,
              args.reference)
          .check();

  static final _enableDebugLogging =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Uint8)>>(
              "FragmentManager__enableDebugLogging")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public void enableDebugLogging(boolean enabled)
  ///
  /// Control whether the framework's internal fragment manager debugging
  /// logs are turned on.  If enabled, you will see output in logcat as
  /// the framework performs fragment operations.
  static void enableDebugLogging(bool enabled) =>
      _enableDebugLogging(enabled ? 1 : 0).check();

  static final _invalidateOptionsMenu = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentManager__invalidateOptionsMenu")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void invalidateOptionsMenu()
  ///
  /// Invalidate the attached activity's options menu as necessary.
  /// This may end up being deferred until we move to the resumed state.
  void invalidateOptionsMenu() => _invalidateOptionsMenu(reference).check();

  static final _isStateSaved = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentManager__isStateSaved")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isStateSaved()
  ///
  /// Returns {@code true} if the FragmentManager's state has already been saved
  /// by its host. Any operations that would change saved state should not be performed
  /// if this method returns true. For example, any popBackStack() method, such as
  /// \#popBackStackImmediate() or any FragmentTransaction using
  /// FragmentTransaction\#commit() instead of
  /// FragmentTransaction\#commitAllowingStateLoss() will change
  /// the state and will result in an error.
  ///@return true if this FragmentManager's state has already been saved by its host
  bool isStateSaved() => _isStateSaved(reference).boolean;
}

/// from: android.app.FragmentManager$OnBackStackChangedListener
///
/// Interface to watch for changes to the back stack.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">
///      Support Library</a>
///      android.support.v4.app.FragmentManager.OnBackStackChangedListener
class FragmentManager_OnBackStackChangedListener extends jni.JniObject {
  FragmentManager_OnBackStackChangedListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onBackStackChanged = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_OnBackStackChangedListener__onBackStackChanged")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onBackStackChanged()
  ///
  /// Called whenever the contents of the back stack change.
  void onBackStackChanged() => _onBackStackChanged(reference).check();
}

/// from: android.app.FragmentManager$FragmentLifecycleCallbacks
///
/// Callback interface for listening to fragment state changes that happen
/// within a given FragmentManager.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">
///      Support Library</a>
///      android.support.v4.app.FragmentManager.FragmentLifecycleCallbacks
class FragmentManager_FragmentLifecycleCallbacks extends jni.JniObject {
  FragmentManager_FragmentLifecycleCallbacks.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "FragmentManager_FragmentLifecycleCallbacks__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  FragmentManager_FragmentLifecycleCallbacks() : super.fromRef(_ctor().object);

  static final _onFragmentPreAttached = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_FragmentLifecycleCallbacks__onFragmentPreAttached")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentPreAttached(android.app.FragmentManager fm, android.app.Fragment f, android.content.Context context)
  ///
  /// Called right before the fragment's Fragment\#onAttach(Context) method is called.
  /// This is a good time to inject any required dependencies for the fragment before any of
  /// the fragment's lifecycle methods are invoked.
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  ///@param context Context that the Fragment is being attached to
  void onFragmentPreAttached(
          FragmentManager fm, Fragment f, content_.Context context) =>
      _onFragmentPreAttached(
              reference, fm.reference, f.reference, context.reference)
          .check();

  static final _onFragmentAttached = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_FragmentLifecycleCallbacks__onFragmentAttached")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentAttached(android.app.FragmentManager fm, android.app.Fragment f, android.content.Context context)
  ///
  /// Called after the fragment has been attached to its host. Its host will have had
  /// <code>onAttachFragment</code> called before this call happens.
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  ///@param context Context that the Fragment was attached to
  void onFragmentAttached(
          FragmentManager fm, Fragment f, content_.Context context) =>
      _onFragmentAttached(
              reference, fm.reference, f.reference, context.reference)
          .check();

  static final _onFragmentPreCreated = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_FragmentLifecycleCallbacks__onFragmentPreCreated")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentPreCreated(android.app.FragmentManager fm, android.app.Fragment f, android.os.Bundle savedInstanceState)
  ///
  /// Called right before the fragment's Fragment\#onCreate(Bundle) method is called.
  /// This is a good time to inject any required dependencies or perform other configuration
  /// for the fragment.
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  ///@param savedInstanceState Saved instance bundle from a previous instance
  void onFragmentPreCreated(
          FragmentManager fm, Fragment f, os_.Bundle savedInstanceState) =>
      _onFragmentPreCreated(reference, fm.reference, f.reference,
              savedInstanceState.reference)
          .check();

  static final _onFragmentCreated = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_FragmentLifecycleCallbacks__onFragmentCreated")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentCreated(android.app.FragmentManager fm, android.app.Fragment f, android.os.Bundle savedInstanceState)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onCreate(Bundle). This will only happen once for any given
  /// fragment instance, though the fragment may be attached and detached multiple times.
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  ///@param savedInstanceState Saved instance bundle from a previous instance
  void onFragmentCreated(
          FragmentManager fm, Fragment f, os_.Bundle savedInstanceState) =>
      _onFragmentCreated(reference, fm.reference, f.reference,
              savedInstanceState.reference)
          .check();

  static final _onFragmentActivityCreated = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_FragmentLifecycleCallbacks__onFragmentActivityCreated")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentActivityCreated(android.app.FragmentManager fm, android.app.Fragment f, android.os.Bundle savedInstanceState)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onActivityCreated(Bundle). This will only happen once for any given
  /// fragment instance, though the fragment may be attached and detached multiple times.
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  ///@param savedInstanceState Saved instance bundle from a previous instance
  void onFragmentActivityCreated(
          FragmentManager fm, Fragment f, os_.Bundle savedInstanceState) =>
      _onFragmentActivityCreated(reference, fm.reference, f.reference,
              savedInstanceState.reference)
          .check();

  static final _onFragmentViewCreated = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_FragmentLifecycleCallbacks__onFragmentViewCreated")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentViewCreated(android.app.FragmentManager fm, android.app.Fragment f, android.view.View v, android.os.Bundle savedInstanceState)
  ///
  /// Called after the fragment has returned a non-null view from the FragmentManager's
  /// request to Fragment\#onCreateView(LayoutInflater, ViewGroup, Bundle).
  ///@param fm Host FragmentManager
  ///@param f Fragment that created and owns the view
  ///@param v View returned by the fragment
  ///@param savedInstanceState Saved instance bundle from a previous instance
  void onFragmentViewCreated(FragmentManager fm, Fragment f, jni.JniObject v,
          os_.Bundle savedInstanceState) =>
      _onFragmentViewCreated(reference, fm.reference, f.reference, v.reference,
              savedInstanceState.reference)
          .check();

  static final _onFragmentStarted = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_FragmentLifecycleCallbacks__onFragmentStarted")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentStarted(android.app.FragmentManager fm, android.app.Fragment f)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onStart().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentStarted(FragmentManager fm, Fragment f) =>
      _onFragmentStarted(reference, fm.reference, f.reference).check();

  static final _onFragmentResumed = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_FragmentLifecycleCallbacks__onFragmentResumed")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentResumed(android.app.FragmentManager fm, android.app.Fragment f)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onResume().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentResumed(FragmentManager fm, Fragment f) =>
      _onFragmentResumed(reference, fm.reference, f.reference).check();

  static final _onFragmentPaused = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_FragmentLifecycleCallbacks__onFragmentPaused")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentPaused(android.app.FragmentManager fm, android.app.Fragment f)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onPause().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentPaused(FragmentManager fm, Fragment f) =>
      _onFragmentPaused(reference, fm.reference, f.reference).check();

  static final _onFragmentStopped = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_FragmentLifecycleCallbacks__onFragmentStopped")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentStopped(android.app.FragmentManager fm, android.app.Fragment f)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onStop().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentStopped(FragmentManager fm, Fragment f) =>
      _onFragmentStopped(reference, fm.reference, f.reference).check();

  static final _onFragmentSaveInstanceState = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_FragmentLifecycleCallbacks__onFragmentSaveInstanceState")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentSaveInstanceState(android.app.FragmentManager fm, android.app.Fragment f, android.os.Bundle outState)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onSaveInstanceState(Bundle).
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  ///@param outState Saved state bundle for the fragment
  void onFragmentSaveInstanceState(
          FragmentManager fm, Fragment f, os_.Bundle outState) =>
      _onFragmentSaveInstanceState(
              reference, fm.reference, f.reference, outState.reference)
          .check();

  static final _onFragmentViewDestroyed = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_FragmentLifecycleCallbacks__onFragmentViewDestroyed")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentViewDestroyed(android.app.FragmentManager fm, android.app.Fragment f)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onDestroyView().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentViewDestroyed(FragmentManager fm, Fragment f) =>
      _onFragmentViewDestroyed(reference, fm.reference, f.reference).check();

  static final _onFragmentDestroyed = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_FragmentLifecycleCallbacks__onFragmentDestroyed")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentDestroyed(android.app.FragmentManager fm, android.app.Fragment f)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onDestroy().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentDestroyed(FragmentManager fm, Fragment f) =>
      _onFragmentDestroyed(reference, fm.reference, f.reference).check();

  static final _onFragmentDetached = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_FragmentLifecycleCallbacks__onFragmentDetached")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onFragmentDetached(android.app.FragmentManager fm, android.app.Fragment f)
  ///
  /// Called after the fragment has returned from the FragmentManager's call to
  /// Fragment\#onDetach().
  ///@param fm Host FragmentManager
  ///@param f Fragment changing state
  void onFragmentDetached(FragmentManager fm, Fragment f) =>
      _onFragmentDetached(reference, fm.reference, f.reference).check();
}

/// from: android.app.FragmentManager$BackStackEntry
///
/// Representation of an entry on the fragment back stack, as created
/// with FragmentTransaction\#addToBackStack(String) FragmentTransaction.addToBackStack().  Entries can later be
/// retrieved with FragmentManager\#getBackStackEntryAt(int) FragmentManager.getBackStackEntryAt().
///
/// Note that you should never hold on to a BackStackEntry object;
/// the identifier as returned by \#getId is the only thing that
/// will be persisted across activity instances.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">
///      Support Library</a> android.support.v4.app.FragmentManager.BackStackEntry
class FragmentManager_BackStackEntry extends jni.JniObject {
  FragmentManager_BackStackEntry.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _getId = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_BackStackEntry__getId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getId()
  ///
  /// Return the unique identifier for the entry.  This is the only
  /// representation of the entry that will persist across activity
  /// instances.
  int getId() => _getId(reference).integer;

  static final _getName = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_BackStackEntry__getName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the name that was supplied to
  /// FragmentTransaction\#addToBackStack(String) FragmentTransaction.addToBackStack(String) when creating this entry.
  jni.JniString getName() => jni.JniString.fromRef(_getName(reference).object);

  static final _getBreadCrumbTitleRes = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_BackStackEntry__getBreadCrumbTitleRes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getBreadCrumbTitleRes()
  ///
  /// Return the full bread crumb title resource identifier for the entry,
  /// or 0 if it does not have one.
  int getBreadCrumbTitleRes() => _getBreadCrumbTitleRes(reference).integer;

  static final _getBreadCrumbShortTitleRes = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_BackStackEntry__getBreadCrumbShortTitleRes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getBreadCrumbShortTitleRes()
  ///
  /// Return the short bread crumb title resource identifier for the entry,
  /// or 0 if it does not have one.
  int getBreadCrumbShortTitleRes() =>
      _getBreadCrumbShortTitleRes(reference).integer;

  static final _getBreadCrumbTitle = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_BackStackEntry__getBreadCrumbTitle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.CharSequence getBreadCrumbTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the full bread crumb title for the entry, or null if it
  /// does not have one.
  jni.JniObject getBreadCrumbTitle() =>
      jni.JniObject.fromRef(_getBreadCrumbTitle(reference).object);

  static final _getBreadCrumbShortTitle = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentManager_BackStackEntry__getBreadCrumbShortTitle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.CharSequence getBreadCrumbShortTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the short bread crumb title for the entry, or null if it
  /// does not have one.
  jni.JniObject getBreadCrumbShortTitle() =>
      jni.JniObject.fromRef(_getBreadCrumbShortTitle(reference).object);
}

/// from: android.app.FragmentManagerNonConfig
///
/// FragmentManagerNonConfig stores the retained instance fragments across
/// activity recreation events.
///
/// Apps should treat objects of this type as opaque, returned by
/// and passed to the state save and restore process for fragments in
/// FragmentController\#retainNonConfig() and
/// FragmentController\#restoreAllState(Parcelable, FragmentManagerNonConfig).
///
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.FragmentManagerNonConfig
class FragmentManagerNonConfig extends jni.JniObject {
  FragmentManagerNonConfig.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentManagerNonConfig__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(java.util.List<android.app.Fragment> fragments, java.util.List<android.app.FragmentManagerNonConfig> childNonConfigs)
  FragmentManagerNonConfig(
      jni.JniObject fragments, jni.JniObject childNonConfigs)
      : super.fromRef(
            _ctor(fragments.reference, childNonConfigs.reference).object);
}

/// from: android.app.FragmentTransaction
///
/// API for performing a set of Fragment operations.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using fragments, read the
/// <a href="{@docRoot}guide/components/fragments.html">Fragments</a> developer
/// guide.
///
/// </div>
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.FragmentTransaction
class FragmentTransaction extends jni.JniObject {
  FragmentTransaction.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int TRANSIT_ENTER_MASK
  ///
  /// Bit mask that is set for all enter transitions.
  static const TRANSIT_ENTER_MASK = 4096;

  /// from: static public final int TRANSIT_EXIT_MASK
  ///
  /// Bit mask that is set for all exit transitions.
  static const TRANSIT_EXIT_MASK = 8192;

  /// from: static public final int TRANSIT_FRAGMENT_CLOSE
  ///
  /// Fragment is being removed from the stack
  static const TRANSIT_FRAGMENT_CLOSE = 8194;

  /// from: static public final int TRANSIT_FRAGMENT_FADE
  ///
  /// Fragment should simply fade in or out; that is, no strong navigation associated
  /// with it except that it is appearing or disappearing for some reason.
  static const TRANSIT_FRAGMENT_FADE = 4099;

  /// from: static public final int TRANSIT_FRAGMENT_OPEN
  ///
  /// Fragment is being added onto the stack
  static const TRANSIT_FRAGMENT_OPEN = 4097;

  /// from: static public final int TRANSIT_NONE
  ///
  /// No animation for transition.
  static const TRANSIT_NONE = 0;

  /// from: static public final int TRANSIT_UNSET
  ///
  /// Not set up for a transition.
  static const TRANSIT_UNSET = -1;

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "FragmentTransaction__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  FragmentTransaction() : super.fromRef(_ctor().object);

  static final _add = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentTransaction__add")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction add(android.app.Fragment fragment, java.lang.String tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Calls \#add(int, Fragment, String) with a 0 containerViewId.
  FragmentTransaction add(Fragment fragment, jni.JniString tag) =>
      FragmentTransaction.fromRef(
          _add(reference, fragment.reference, tag.reference).object);

  static final _add1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("FragmentTransaction__add1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction add(int containerViewId, android.app.Fragment fragment)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Calls \#add(int, Fragment, String) with a null tag.
  FragmentTransaction add1(int containerViewId, Fragment fragment) =>
      FragmentTransaction.fromRef(
          _add1(reference, containerViewId, fragment.reference).object);

  static final _add2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentTransaction__add2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction add(int containerViewId, android.app.Fragment fragment, java.lang.String tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a fragment to the activity state.  This fragment may optionally
  /// also have its view (if Fragment\#onCreateView Fragment.onCreateView
  /// returns non-null) inserted into a container view of the activity.
  ///@param containerViewId Optional identifier of the container this fragment is
  /// to be placed in.  If 0, it will not be placed in a container.
  ///@param fragment The fragment to be added.  This fragment must not already
  /// be added to the activity.
  ///@param tag Optional tag name for the fragment, to later retrieve the
  /// fragment with FragmentManager\#findFragmentByTag(String) FragmentManager.findFragmentByTag(String).
  ///@return Returns the same FragmentTransaction instance.
  FragmentTransaction add2(
          int containerViewId, Fragment fragment, jni.JniString tag) =>
      FragmentTransaction.fromRef(
          _add2(reference, containerViewId, fragment.reference, tag.reference)
              .object);

  static final _replace = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("FragmentTransaction__replace")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction replace(int containerViewId, android.app.Fragment fragment)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Calls \#replace(int, Fragment, String) with a null tag.
  FragmentTransaction replace(int containerViewId, Fragment fragment) =>
      FragmentTransaction.fromRef(
          _replace(reference, containerViewId, fragment.reference).object);

  static final _replace1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentTransaction__replace1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction replace(int containerViewId, android.app.Fragment fragment, java.lang.String tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Replace an existing fragment that was added to a container.  This is
  /// essentially the same as calling \#remove(Fragment) for all
  /// currently added fragments that were added with the same containerViewId
  /// and then \#add(int, Fragment, String) with the same arguments
  /// given here.
  ///@param containerViewId Identifier of the container whose fragment(s) are
  /// to be replaced.
  ///@param fragment The new fragment to place in the container.
  ///@param tag Optional tag name for the fragment, to later retrieve the
  /// fragment with FragmentManager\#findFragmentByTag(String) FragmentManager.findFragmentByTag(String).
  ///@return Returns the same FragmentTransaction instance.
  FragmentTransaction replace1(
          int containerViewId, Fragment fragment, jni.JniString tag) =>
      FragmentTransaction.fromRef(_replace1(
              reference, containerViewId, fragment.reference, tag.reference)
          .object);

  static final _remove = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentTransaction__remove")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction remove(android.app.Fragment fragment)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Remove an existing fragment.  If it was added to a container, its view
  /// is also removed from that container.
  ///@param fragment The fragment to be removed.
  ///@return Returns the same FragmentTransaction instance.
  FragmentTransaction remove(Fragment fragment) => FragmentTransaction.fromRef(
      _remove(reference, fragment.reference).object);

  static final _hide0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentTransaction__hide0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction hide(android.app.Fragment fragment)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Hides an existing fragment.  This is only relevant for fragments whose
  /// views have been added to a container, as this will cause the view to
  /// be hidden.
  ///@param fragment The fragment to be hidden.
  ///@return Returns the same FragmentTransaction instance.
  FragmentTransaction hide0(Fragment fragment) =>
      FragmentTransaction.fromRef(_hide0(reference, fragment.reference).object);

  static final _show0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentTransaction__show0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction show(android.app.Fragment fragment)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Shows a previously hidden fragment.  This is only relevant for fragments whose
  /// views have been added to a container, as this will cause the view to
  /// be shown.
  ///@param fragment The fragment to be shown.
  ///@return Returns the same FragmentTransaction instance.
  FragmentTransaction show0(Fragment fragment) =>
      FragmentTransaction.fromRef(_show0(reference, fragment.reference).object);

  static final _detach = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentTransaction__detach")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction detach(android.app.Fragment fragment)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Detach the given fragment from the UI.  This is the same state as
  /// when it is put on the back stack: the fragment is removed from
  /// the UI, however its state is still being actively managed by the
  /// fragment manager.  When going into this state its view hierarchy
  /// is destroyed.
  ///@param fragment The fragment to be detached.
  ///@return Returns the same FragmentTransaction instance.
  FragmentTransaction detach(Fragment fragment) => FragmentTransaction.fromRef(
      _detach(reference, fragment.reference).object);

  static final _attach = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentTransaction__attach")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction attach(android.app.Fragment fragment)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Re-attach a fragment after it had previously been detached from
  /// the UI with \#detach(Fragment).  This
  /// causes its view hierarchy to be re-created, attached to the UI,
  /// and displayed.
  ///@param fragment The fragment to be attached.
  ///@return Returns the same FragmentTransaction instance.
  FragmentTransaction attach(Fragment fragment) => FragmentTransaction.fromRef(
      _attach(reference, fragment.reference).object);

  static final _setPrimaryNavigationFragment = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentTransaction__setPrimaryNavigationFragment")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction setPrimaryNavigationFragment(android.app.Fragment fragment)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a currently active fragment in this FragmentManager as the primary navigation fragment.
  ///
  /// The primary navigation fragment's
  /// Fragment\#getChildFragmentManager() child FragmentManager will be called first
  /// to process delegated navigation actions such as FragmentManager\#popBackStack()
  /// if no ID or transaction name is provided to pop to. Navigation operations outside of the
  /// fragment system may choose to delegate those actions to the primary navigation fragment
  /// as returned by FragmentManager\#getPrimaryNavigationFragment().
  ///
  ///
  /// The fragment provided must currently be added to the FragmentManager to be set as
  /// a primary navigation fragment, or previously added as part of this transaction.
  ///
  ///@param fragment the fragment to set as the primary navigation fragment
  ///@return the same FragmentTransaction instance
  FragmentTransaction setPrimaryNavigationFragment(Fragment fragment) =>
      FragmentTransaction.fromRef(
          _setPrimaryNavigationFragment(reference, fragment.reference).object);

  static final _isEmpty = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentTransaction__isEmpty")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isEmpty()
  ///
  /// @return <code>true</code> if this transaction contains no operations,
  /// <code>false</code> otherwise.
  bool isEmpty() => _isEmpty(reference).boolean;

  static final _setCustomAnimations = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("FragmentTransaction__setCustomAnimations")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract android.app.FragmentTransaction setCustomAnimations(int enter, int exit)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set specific animation resources to run for the fragments that are
  /// entering and exiting in this transaction. These animations will not be
  /// played when popping the back stack.
  FragmentTransaction setCustomAnimations(int enter, int exit) =>
      FragmentTransaction.fromRef(
          _setCustomAnimations(reference, enter, exit).object);

  static final _setCustomAnimations1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("FragmentTransaction__setCustomAnimations1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: public abstract android.app.FragmentTransaction setCustomAnimations(int enter, int exit, int popEnter, int popExit)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set specific animation resources to run for the fragments that are
  /// entering and exiting in this transaction. The <code>popEnter</code>
  /// and <code>popExit</code> animations will be played for enter/exit
  /// operations specifically when popping the back stack.
  FragmentTransaction setCustomAnimations1(
          int enter, int exit, int popEnter, int popExit) =>
      FragmentTransaction.fromRef(
          _setCustomAnimations1(reference, enter, exit, popEnter, popExit)
              .object);

  static final _setTransition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("FragmentTransaction__setTransition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.FragmentTransaction setTransition(int transit)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Select a standard transition animation for this transaction.  May be
  /// one of \#TRANSIT_NONE, \#TRANSIT_FRAGMENT_OPEN,
  /// \#TRANSIT_FRAGMENT_CLOSE, or \#TRANSIT_FRAGMENT_FADE.
  ///@param transit Value is android.app.FragmentTransaction\#TRANSIT_NONE, android.app.FragmentTransaction\#TRANSIT_FRAGMENT_OPEN, android.app.FragmentTransaction\#TRANSIT_FRAGMENT_CLOSE, or android.app.FragmentTransaction\#TRANSIT_FRAGMENT_FADE
  FragmentTransaction setTransition(int transit) =>
      FragmentTransaction.fromRef(_setTransition(reference, transit).object);

  static final _addSharedElement = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentTransaction__addSharedElement")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction addSharedElement(android.view.View sharedElement, java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used with to map a View from a removed or hidden Fragment to a View from a shown
  /// or added Fragment.
  ///@param sharedElement A View in a disappearing Fragment to match with a View in an
  ///                      appearing Fragment.
  ///@param name The transitionName for a View in an appearing Fragment to match to the shared
  ///             element.
  FragmentTransaction addSharedElement(
          jni.JniObject sharedElement, jni.JniString name) =>
      FragmentTransaction.fromRef(
          _addSharedElement(reference, sharedElement.reference, name.reference)
              .object);

  static final _setTransitionStyle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("FragmentTransaction__setTransitionStyle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.FragmentTransaction setTransitionStyle(int styleRes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a custom style resource that will be used for resolving transit
  /// animations.
  FragmentTransaction setTransitionStyle(int styleRes) =>
      FragmentTransaction.fromRef(
          _setTransitionStyle(reference, styleRes).object);

  static final _addToBackStack = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentTransaction__addToBackStack")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction addToBackStack(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add this transaction to the back stack.  This means that the transaction
  /// will be remembered after it is committed, and will reverse its operation
  /// when later popped off the stack.
  ///@param name An optional name for this back stack state, or null.
  ///
  /// This value may be {@code null}.
  FragmentTransaction addToBackStack(jni.JniString name) =>
      FragmentTransaction.fromRef(
          _addToBackStack(reference, name.reference).object);

  static final _isAddToBackStackAllowed = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentTransaction__isAddToBackStackAllowed")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isAddToBackStackAllowed()
  ///
  /// Returns true if this FragmentTransaction is allowed to be added to the back
  /// stack. If this method would return false, \#addToBackStack(String)
  /// will throw IllegalStateException.
  ///@return True if \#addToBackStack(String) is permitted on this transaction.
  bool isAddToBackStackAllowed() => _isAddToBackStackAllowed(reference).boolean;

  static final _disallowAddToBackStack = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentTransaction__disallowAddToBackStack")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction disallowAddToBackStack()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Disallow calls to \#addToBackStack(String). Any future calls to
  /// addToBackStack will throw IllegalStateException. If addToBackStack
  /// has already been called, this method will throw IllegalStateException.
  FragmentTransaction disallowAddToBackStack() =>
      FragmentTransaction.fromRef(_disallowAddToBackStack(reference).object);

  static final _setBreadCrumbTitle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("FragmentTransaction__setBreadCrumbTitle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.FragmentTransaction setBreadCrumbTitle(int res)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the full title to show as a bread crumb when this transaction
  /// is on the back stack, as used by FragmentBreadCrumbs.
  ///@param res A string resource containing the title.
  FragmentTransaction setBreadCrumbTitle(int res) =>
      FragmentTransaction.fromRef(_setBreadCrumbTitle(reference, res).object);

  static final _setBreadCrumbTitle1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentTransaction__setBreadCrumbTitle1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction setBreadCrumbTitle(java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#setBreadCrumbTitle(int) but taking a raw string; this
  /// method is _not_ recommended, as the string can not be changed
  /// later if the locale changes.
  FragmentTransaction setBreadCrumbTitle1(jni.JniObject text) =>
      FragmentTransaction.fromRef(
          _setBreadCrumbTitle1(reference, text.reference).object);

  static final _setBreadCrumbShortTitle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("FragmentTransaction__setBreadCrumbShortTitle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.FragmentTransaction setBreadCrumbShortTitle(int res)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the short title to show as a bread crumb when this transaction
  /// is on the back stack, as used by FragmentBreadCrumbs.
  ///@param res A string resource containing the title.
  FragmentTransaction setBreadCrumbShortTitle(int res) =>
      FragmentTransaction.fromRef(
          _setBreadCrumbShortTitle(reference, res).object);

  static final _setBreadCrumbShortTitle1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "FragmentTransaction__setBreadCrumbShortTitle1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction setBreadCrumbShortTitle(java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#setBreadCrumbShortTitle(int) but taking a raw string; this
  /// method is _not_ recommended, as the string can not be changed
  /// later if the locale changes.
  FragmentTransaction setBreadCrumbShortTitle1(jni.JniObject text) =>
      FragmentTransaction.fromRef(
          _setBreadCrumbShortTitle1(reference, text.reference).object);

  static final _setReorderingAllowed = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("FragmentTransaction__setReorderingAllowed")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.app.FragmentTransaction setReorderingAllowed(boolean reorderingAllowed)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets whether or not to allow optimizing operations within and across
  /// transactions. This will remove redundant operations, eliminating
  /// operations that cancel. For example, if two transactions are executed
  /// together, one that adds a fragment A and the next replaces it with fragment B,
  /// the operations will cancel and only fragment B will be added. That means that
  /// fragment A may not go through the creation/destruction lifecycle.
  ///
  /// The side effect of removing redundant operations is that fragments may have state changes
  /// out of the expected order. For example, one transaction adds fragment A,
  /// a second adds fragment B, then a third removes fragment A. Without removing the redundant
  /// operations, fragment B could expect that while it is being created, fragment A will also
  /// exist because fragment A will be removed after fragment B was added.
  /// With removing redundant operations, fragment B cannot expect fragment A to exist when
  /// it has been created because fragment A's add/remove will be optimized out.
  ///
  /// It can also reorder the state changes of Fragments to allow for better Transitions.
  /// Added Fragments may have Fragment\#onCreate(Bundle) called before replaced
  /// Fragments have Fragment\#onDestroy() called.
  ///
  /// The default is {@code false} for applications targeting version
  /// versions prior to O and {@code true} for applications targeting O and
  /// later.
  ///@param reorderingAllowed {@code true} to enable optimizing out redundant operations
  ///                          or {@code false} to disable optimizing out redundant
  ///                          operations on this transaction.
  FragmentTransaction setReorderingAllowed(bool reorderingAllowed) =>
      FragmentTransaction.fromRef(
          _setReorderingAllowed(reference, reorderingAllowed ? 1 : 0).object);

  static final _runOnCommit = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("FragmentTransaction__runOnCommit")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.FragmentTransaction runOnCommit(java.lang.Runnable runnable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a Runnable to this transaction that will be run after this transaction has
  /// been committed. If fragment transactions are \#setReorderingAllowed(boolean) optimized
  /// this may be after other subsequent fragment operations have also taken place, or operations
  /// in this transaction may have been optimized out due to the presence of a subsequent
  /// fragment transaction in the batch.
  ///
  ///
  /// If a transaction is committed using \#commitAllowingStateLoss() this runnable
  /// may be executed when the FragmentManager is in a state where new transactions may not
  /// be committed without allowing state loss.
  ///
  ///
  /// <code>runOnCommit</code> may not be used with transactions
  /// \#addToBackStack(String) added to the back stack as Runnables cannot be persisted
  /// with back stack state. IllegalStateException will be thrown if
  /// \#addToBackStack(String) has been previously called for this transaction
  /// or if it is called after a call to <code>runOnCommit</code>.
  ///
  ///@param runnable Runnable to add
  ///@return this FragmentTransaction
  ///@throws IllegalStateException if \#addToBackStack(String) has been called
  FragmentTransaction runOnCommit(jni.JniObject runnable) =>
      FragmentTransaction.fromRef(
          _runOnCommit(reference, runnable.reference).object);

  static final _commit = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentTransaction__commit")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int commit()
  ///
  /// Schedules a commit of this transaction.  The commit does
  /// not happen immediately; it will be scheduled as work on the main thread
  /// to be done the next time that thread is ready.
  ///
  /// <p class="note">A transaction can only be committed with this method
  /// prior to its containing activity saving its state.  If the commit is
  /// attempted after that point, an exception will be thrown.  This is
  /// because the state after the commit can be lost if the activity needs to
  /// be restored from its state.  See \#commitAllowingStateLoss() for
  /// situations where it may be okay to lose the commit.
  ///
  ///@return Returns the identifier of this transaction's back stack entry,
  /// if \#addToBackStack(String) had been called.  Otherwise, returns
  /// a negative number.
  int commit() => _commit(reference).integer;

  static final _commitAllowingStateLoss = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentTransaction__commitAllowingStateLoss")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int commitAllowingStateLoss()
  ///
  /// Like \#commit but allows the commit to be executed after an
  /// activity's state is saved.  This is dangerous because the commit can
  /// be lost if the activity needs to later be restored from its state, so
  /// this should only be used for cases where it is okay for the UI state
  /// to change unexpectedly on the user.
  int commitAllowingStateLoss() => _commitAllowingStateLoss(reference).integer;

  static final _commitNow = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("FragmentTransaction__commitNow")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void commitNow()
  ///
  /// Commits this transaction synchronously. Any added fragments will be
  /// initialized and brought completely to the lifecycle state of their host
  /// and any removed fragments will be torn down accordingly before this
  /// call returns. Committing a transaction in this way allows fragments
  /// to be added as dedicated, encapsulated components that monitor the
  /// lifecycle state of their host while providing firmer ordering guarantees
  /// around when those fragments are fully initialized and ready. Fragments
  /// that manage views will have those views created and attached.
  ///
  /// Calling <code>commitNow</code> is preferable to calling
  /// \#commit() followed by FragmentManager\#executePendingTransactions()
  /// as the latter will have the side effect of attempting to commit _all_
  /// currently pending transactions whether that is the desired behavior
  /// or not.
  ///
  ///
  /// Transactions committed in this way may not be added to the
  /// FragmentManager's back stack, as doing so would break other expected
  /// ordering guarantees for other asynchronously committed transactions.
  /// This method will throw IllegalStateException if the transaction
  /// previously requested to be added to the back stack with
  /// \#addToBackStack(String).
  ///
  ///
  /// <p class="note">A transaction can only be committed with this method
  /// prior to its containing activity saving its state.  If the commit is
  /// attempted after that point, an exception will be thrown.  This is
  /// because the state after the commit can be lost if the activity needs to
  /// be restored from its state.  See \#commitAllowingStateLoss() for
  /// situations where it may be okay to lose the commit.
  ///
  void commitNow() => _commitNow(reference).check();

  static final _commitNowAllowingStateLoss = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "FragmentTransaction__commitNowAllowingStateLoss")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void commitNowAllowingStateLoss()
  ///
  /// Like \#commitNow but allows the commit to be executed after an
  /// activity's state is saved.  This is dangerous because the commit can
  /// be lost if the activity needs to later be restored from its state, so
  /// this should only be used for cases where it is okay for the UI state
  /// to change unexpectedly on the user.
  void commitNowAllowingStateLoss() =>
      _commitNowAllowingStateLoss(reference).check();
}

/// from: android.app.Instrumentation
///
/// Base class for implementing application instrumentation code.  When running
/// with instrumentation turned on, this class will be instantiated for you
/// before any of the application code, allowing you to monitor all of the
/// interaction the system has with the application.  An Instrumentation
/// implementation is described to the system through an AndroidManifest.xml's
/// &lt;instrumentation&gt; tag.
class Instrumentation extends jni.JniObject {
  Instrumentation.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String REPORT_KEY_IDENTIFIER
  ///
  /// If included in the status or final bundle sent to an IInstrumentationWatcher, this key
  /// identifies the class that is writing the report.  This can be used to provide more structured
  /// logging or reporting capabilities in the IInstrumentationWatcher.
  static const REPORT_KEY_IDENTIFIER = "id";

  /// from: static public final java.lang.String REPORT_KEY_STREAMRESULT
  ///
  /// If included in the status or final bundle sent to an IInstrumentationWatcher, this key
  /// identifies a string which can simply be printed to the output stream.  Using these streams
  /// provides a "pretty printer" version of the status & final packets.  Any bundles including
  /// this key should also include the complete set of raw key/value pairs, so that the
  /// instrumentation can also be launched, and results collected, by an automated system.
  static const REPORT_KEY_STREAMRESULT = "stream";

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Instrumentation__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  Instrumentation() : super.fromRef(_ctor().object);

  static final _onCreate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__onCreate")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreate(android.os.Bundle arguments)
  ///
  /// Called when the instrumentation is starting, before any application code
  /// has been loaded.  Usually this will be implemented to simply call
  /// \#start to begin the instrumentation thread, which will then
  /// continue execution in \#onStart.
  ///
  /// If you do not need your own thread -- that is you are writing your
  /// instrumentation to be completely asynchronous (returning to the event
  /// loop so that the application can run), you can simply begin your
  /// instrumentation here, for example call Context\#startActivity to
  /// begin the appropriate first activity of the application.
  ///@param arguments Any additional arguments that were supplied when the
  ///                  instrumentation was started.
  void onCreate(os_.Bundle arguments) =>
      _onCreate(reference, arguments.reference).check();

  static final _start = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__start")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void start()
  ///
  /// Create and start a new thread in which to run instrumentation.  This new
  /// thread will call to \#onStart where you can implement the
  /// instrumentation.
  void start() => _start(reference).check();

  static final _onStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__onStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onStart()
  ///
  /// Method where the instrumentation thread enters execution.  This allows
  /// you to run your instrumentation code in a separate thread than the
  /// application, so that it can perform blocking operation such as
  /// \#sendKeySync or \#startActivitySync.
  ///
  /// You will typically want to call finish() when this function is done,
  /// to end your instrumentation.
  void onStart() => _onStart(reference).check();

  static final _onException = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__onException")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onException(java.lang.Object obj, java.lang.Throwable e)
  ///
  /// This is called whenever the system captures an unhandled exception that
  /// was thrown by the application.  The default implementation simply
  /// returns false, allowing normal system handling of the exception to take
  /// place.
  ///@param obj The client object that generated the exception.  May be an
  ///            Application, Activity, BroadcastReceiver, Service, or null.
  ///@param e The exception that was thrown.
  ///@return To allow normal system exception process to occur, return false.
  ///         If true is returned, the system will proceed as if the exception
  ///         didn't happen.
  bool onException(jni.JniObject obj, jni.JniObject e) =>
      _onException(reference, obj.reference, e.reference).boolean;

  static final _sendStatus = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__sendStatus")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void sendStatus(int resultCode, android.os.Bundle results)
  ///
  /// Provide a status report about the application.
  ///@param resultCode Current success/failure of instrumentation.
  ///@param results Any results to send back to the code that started the instrumentation.
  void sendStatus(int resultCode, os_.Bundle results) =>
      _sendStatus(reference, resultCode, results.reference).check();

  static final _addResults = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__addResults")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void addResults(android.os.Bundle results)
  ///
  /// Report some results in the middle of instrumentation execution.  Later results (including
  /// those provided by \#finish) will be combined with Bundle\#putAll.
  void addResults(os_.Bundle results) =>
      _addResults(reference, results.reference).check();

  static final _finish = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__finish")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void finish(int resultCode, android.os.Bundle results)
  ///
  /// Terminate instrumentation of the application.  This will cause the
  /// application process to exit, removing this instrumentation from the next
  /// time the application is started.  If multiple processes are currently running
  /// for this instrumentation, all of those processes will be killed.
  ///@param resultCode Overall success/failure of instrumentation.
  ///@param results Any results to send back to the code that started the
  ///                instrumentation.
  void finish(int resultCode, os_.Bundle results) =>
      _finish(reference, resultCode, results.reference).check();

  static final _setAutomaticPerformanceSnapshots = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__setAutomaticPerformanceSnapshots")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void setAutomaticPerformanceSnapshots()
  void setAutomaticPerformanceSnapshots() =>
      _setAutomaticPerformanceSnapshots(reference).check();

  static final _startPerformanceSnapshot = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__startPerformanceSnapshot")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void startPerformanceSnapshot()
  void startPerformanceSnapshot() =>
      _startPerformanceSnapshot(reference).check();

  static final _endPerformanceSnapshot = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__endPerformanceSnapshot")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void endPerformanceSnapshot()
  void endPerformanceSnapshot() => _endPerformanceSnapshot(reference).check();

  static final _onDestroy = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__onDestroy")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDestroy()
  ///
  /// Called when the instrumented application is stopping, after all of the
  /// normal application cleanup has occurred.
  void onDestroy() => _onDestroy(reference).check();

  static final _getContext = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__getContext")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Context of this instrumentation's package.  Note that this is
  /// often different than the Context of the application being
  /// instrumentated, since the instrumentation code often lives is a
  /// different package than that of the application it is running against.
  /// See \#getTargetContext to retrieve a Context for the target
  /// application.
  ///@return The instrumentation's package context.
  ///@see \#getTargetContext
  content_.Context getContext() =>
      content_.Context.fromRef(_getContext(reference).object);

  static final _getComponentName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__getComponentName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getComponentName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns complete component name of this instrumentation.
  ///@return Returns the complete component name for this instrumentation.
  content_.ComponentName getComponentName() =>
      content_.ComponentName.fromRef(_getComponentName(reference).object);

  static final _getTargetContext = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__getTargetContext")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context getTargetContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a Context for the target application being instrumented.  Note
  /// that this is often different than the Context of the instrumentation
  /// code, since the instrumentation code often lives is a different package
  /// than that of the application it is running against. See
  /// \#getContext to retrieve a Context for the instrumentation code.
  ///@return A Context in the target application.
  ///@see \#getContext
  content_.Context getTargetContext() =>
      content_.Context.fromRef(_getTargetContext(reference).object);

  static final _getProcessName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__getProcessName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getProcessName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the name of the process this instrumentation is running in.  Note this should
  /// only be used for testing and debugging.  If you are thinking about using this to,
  /// for example, conditionalize what is initialized in an Application class, it is strongly
  /// recommended to instead use lazy initialization (such as a getter for the state that
  /// only creates it when requested).  This can greatly reduce the work your process does
  /// when created for secondary things, such as to receive a broadcast.
  jni.JniString getProcessName() =>
      jni.JniString.fromRef(_getProcessName(reference).object);

  static final _isProfiling = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__isProfiling")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isProfiling()
  ///
  /// Check whether this instrumentation was started with profiling enabled.
  ///@return Returns true if profiling was enabled when starting, else false.
  bool isProfiling() => _isProfiling(reference).boolean;

  static final _startProfiling = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__startProfiling")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void startProfiling()
  ///
  /// This method will start profiling if isProfiling() returns true. You should
  /// only call this method if you set the handleProfiling attribute in the
  /// manifest file for this Instrumentation to true.
  void startProfiling() => _startProfiling(reference).check();

  static final _stopProfiling = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__stopProfiling")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void stopProfiling()
  ///
  /// Stops profiling if isProfiling() returns true.
  void stopProfiling() => _stopProfiling(reference).check();

  static final _setInTouchMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Instrumentation__setInTouchMode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setInTouchMode(boolean inTouch)
  ///
  /// Force the global system in or out of touch mode.  This can be used if
  /// your instrumentation relies on the UI being in one more or the other
  /// when it starts.
  ///@param inTouch Set to true to be in touch mode, false to be in
  /// focus mode.
  void setInTouchMode(bool inTouch) =>
      _setInTouchMode(reference, inTouch ? 1 : 0).check();

  static final _waitForIdle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__waitForIdle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void waitForIdle(java.lang.Runnable recipient)
  ///
  /// Schedule a callback for when the application's main thread goes idle
  /// (has no more events to process).
  ///@param recipient Called the next time the thread's message queue is
  ///                  idle.
  void waitForIdle(jni.JniObject recipient) =>
      _waitForIdle(reference, recipient.reference).check();

  static final _waitForIdleSync = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__waitForIdleSync")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void waitForIdleSync()
  ///
  /// Synchronously wait for the application to be idle.  Can not be called
  /// from the main application thread -- use \#start to execute
  /// instrumentation in its own thread.
  void waitForIdleSync() => _waitForIdleSync(reference).check();

  static final _runOnMainSync = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__runOnMainSync")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void runOnMainSync(java.lang.Runnable runner)
  ///
  /// Execute a call on the application's main thread, blocking until it is
  /// complete.  Useful for doing things that are not thread-safe, such as
  /// looking at or modifying the view hierarchy.
  ///@param runner The code to run on the main thread.
  void runOnMainSync(jni.JniObject runner) =>
      _runOnMainSync(reference, runner.reference).check();

  static final _startActivitySync = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__startActivitySync")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity startActivitySync(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start a new activity and wait for it to begin running before returning.
  /// In addition to being synchronous, this method as some semantic
  /// differences from the standard Context\#startActivity call: the
  /// activity component is resolved before talking with the activity manager
  /// (its class name is specified in the Intent that this method ultimately
  /// starts), and it does not allow you to start activities that run in a
  /// different process.  In addition, if the given Intent resolves to
  /// multiple activities, instead of displaying a dialog for the user to
  /// select an activity, an exception will be thrown.
  ///
  /// The function returns as soon as the activity goes idle following the
  /// call to its Activity\#onCreate.  Generally this means it has gone
  /// through the full initialization including Activity\#onResume and
  /// drawn and displayed its initial window.
  ///@param intent Description of the activity to start.
  ///@see Context\#startActivity
  ///@see \#startActivitySync(Intent, Bundle)
  Activity startActivitySync(content_.Intent intent) =>
      Activity.fromRef(_startActivitySync(reference, intent.reference).object);

  static final _startActivitySync1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__startActivitySync1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity startActivitySync(android.content.Intent intent, android.os.Bundle options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start a new activity and wait for it to begin running before returning.
  /// In addition to being synchronous, this method as some semantic
  /// differences from the standard Context\#startActivity call: the
  /// activity component is resolved before talking with the activity manager
  /// (its class name is specified in the Intent that this method ultimately
  /// starts), and it does not allow you to start activities that run in a
  /// different process.  In addition, if the given Intent resolves to
  /// multiple activities, instead of displaying a dialog for the user to
  /// select an activity, an exception will be thrown.
  ///
  /// The function returns as soon as the activity goes idle following the
  /// call to its Activity\#onCreate.  Generally this means it has gone
  /// through the full initialization including Activity\#onResume and
  /// drawn and displayed its initial window.
  ///@param intent Description of the activity to start.
  /// This value must never be {@code null}.
  ///@param options Additional options for how the Activity should be started.
  /// May be null if there are no options.  See android.app.ActivityOptions
  /// for how to build the Bundle supplied here; there are no supported definitions
  /// for building it manually.
  ///
  /// This value may be {@code null}.
  ///@see Context\#startActivity(Intent, Bundle)
  Activity startActivitySync1(content_.Intent intent, os_.Bundle options) =>
      Activity.fromRef(
          _startActivitySync1(reference, intent.reference, options.reference)
              .object);

  static final _addMonitor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__addMonitor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void addMonitor(android.app.Instrumentation.ActivityMonitor monitor)
  ///
  /// Add a new ActivityMonitor that will be checked whenever an
  /// activity is started.  The monitor is added
  /// after any existing ones; the monitor will be hit only if none of the
  /// existing monitors can themselves handle the Intent.
  ///@param monitor The new ActivityMonitor to see.
  ///@see \#addMonitor(IntentFilter, ActivityResult, boolean)
  ///@see \#checkMonitorHit
  void addMonitor(Instrumentation_ActivityMonitor monitor) =>
      _addMonitor(reference, monitor.reference).check();

  static final _addMonitor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Instrumentation__addMonitor1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Instrumentation.ActivityMonitor addMonitor(android.content.IntentFilter filter, android.app.Instrumentation.ActivityResult result, boolean block)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A convenience wrapper for \#addMonitor(ActivityMonitor) that
  /// creates an intent filter matching ActivityMonitor for you and
  /// returns it.
  ///@param filter The set of intents this monitor is responsible for.
  ///@param result A canned result to return if the monitor is hit; can
  ///               be null.
  ///@param block Controls whether the monitor should block the activity
  ///              start (returning its canned result) or let the call
  ///              proceed.
  ///@return The newly created and added activity monitor.
  ///@see \#addMonitor(ActivityMonitor)
  ///@see \#checkMonitorHit
  Instrumentation_ActivityMonitor addMonitor1(content_.IntentFilter filter,
          Instrumentation_ActivityResult result, bool block) =>
      Instrumentation_ActivityMonitor.fromRef(_addMonitor1(
              reference, filter.reference, result.reference, block ? 1 : 0)
          .object);

  static final _addMonitor2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Instrumentation__addMonitor2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Instrumentation.ActivityMonitor addMonitor(java.lang.String cls, android.app.Instrumentation.ActivityResult result, boolean block)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A convenience wrapper for \#addMonitor(ActivityMonitor) that
  /// creates a class matching ActivityMonitor for you and returns it.
  ///@param cls The activity class this monitor is responsible for.
  ///@param result A canned result to return if the monitor is hit; can
  ///               be null.
  ///@param block Controls whether the monitor should block the activity
  ///              start (returning its canned result) or let the call
  ///              proceed.
  ///@return The newly created and added activity monitor.
  ///@see \#addMonitor(ActivityMonitor)
  ///@see \#checkMonitorHit
  Instrumentation_ActivityMonitor addMonitor2(jni.JniString cls,
          Instrumentation_ActivityResult result, bool block) =>
      Instrumentation_ActivityMonitor.fromRef(_addMonitor2(
              reference, cls.reference, result.reference, block ? 1 : 0)
          .object);

  static final _checkMonitorHit = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Instrumentation__checkMonitorHit")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean checkMonitorHit(android.app.Instrumentation.ActivityMonitor monitor, int minHits)
  ///
  /// Test whether an existing ActivityMonitor has been hit.  If the
  /// monitor has been hit at least <var>minHits</var> times, then it will be
  /// removed from the activity monitor list and true returned.  Otherwise it
  /// is left as-is and false is returned.
  ///@param monitor The ActivityMonitor to check.
  ///@param minHits The minimum number of hits required.
  ///@return True if the hit count has been reached, else false.
  ///@see \#addMonitor
  bool checkMonitorHit(Instrumentation_ActivityMonitor monitor, int minHits) =>
      _checkMonitorHit(reference, monitor.reference, minHits).boolean;

  static final _waitForMonitor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__waitForMonitor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity waitForMonitor(android.app.Instrumentation.ActivityMonitor monitor)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Wait for an existing ActivityMonitor to be hit.  Once the
  /// monitor has been hit, it is removed from the activity monitor list and
  /// the first created Activity object that matched it is returned.
  ///@param monitor The ActivityMonitor to wait for.
  ///@return The Activity object that matched the monitor.
  Activity waitForMonitor(Instrumentation_ActivityMonitor monitor) =>
      Activity.fromRef(_waitForMonitor(reference, monitor.reference).object);

  static final _waitForMonitorWithTimeout = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("Instrumentation__waitForMonitorWithTimeout")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Activity waitForMonitorWithTimeout(android.app.Instrumentation.ActivityMonitor monitor, long timeOut)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Wait for an existing ActivityMonitor to be hit till the timeout
  /// expires.  Once the monitor has been hit, it is removed from the activity
  /// monitor list and the first created Activity object that matched it is
  /// returned.  If the timeout expires, a null object is returned.
  ///@param monitor The ActivityMonitor to wait for.
  ///@param timeOut The timeout value in milliseconds.
  ///@return The Activity object that matched the monitor.
  Activity waitForMonitorWithTimeout(
          Instrumentation_ActivityMonitor monitor, int timeOut) =>
      Activity.fromRef(
          _waitForMonitorWithTimeout(reference, monitor.reference, timeOut)
              .object);

  static final _removeMonitor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__removeMonitor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void removeMonitor(android.app.Instrumentation.ActivityMonitor monitor)
  ///
  /// Remove an ActivityMonitor that was previously added with
  /// \#addMonitor.
  ///@param monitor The monitor to remove.
  ///@see \#addMonitor
  void removeMonitor(Instrumentation_ActivityMonitor monitor) =>
      _removeMonitor(reference, monitor.reference).check();

  static final _invokeMenuActionSync = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32)>>("Instrumentation__invokeMenuActionSync")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public boolean invokeMenuActionSync(android.app.Activity targetActivity, int id, int flag)
  ///
  /// Execute a particular menu item.
  ///@param targetActivity The activity in question.
  ///@param id The identifier associated with the menu item.
  ///@param flag Additional flags, if any.
  ///@return Whether the invocation was successful (for example, it could be
  ///         false if item is disabled).
  bool invokeMenuActionSync(Activity targetActivity, int id, int flag) =>
      _invokeMenuActionSync(reference, targetActivity.reference, id, flag)
          .boolean;

  static final _invokeContextMenuAction = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32)>>("Instrumentation__invokeContextMenuAction")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public boolean invokeContextMenuAction(android.app.Activity targetActivity, int id, int flag)
  ///
  /// Show the context menu for the currently focused view and executes a
  /// particular context menu item.
  ///@param targetActivity The activity in question.
  ///@param id The identifier associated with the context menu item.
  ///@param flag Additional flags, if any.
  ///@return Whether the invocation was successful (for example, it could be
  ///         false if item is disabled).
  bool invokeContextMenuAction(Activity targetActivity, int id, int flag) =>
      _invokeContextMenuAction(reference, targetActivity.reference, id, flag)
          .boolean;

  static final _sendStringSync = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__sendStringSync")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void sendStringSync(java.lang.String text)
  ///
  /// Sends the key events corresponding to the text to the app being
  /// instrumented.
  ///@param text The text to be sent.
  void sendStringSync(jni.JniString text) =>
      _sendStringSync(reference, text.reference).check();

  static final _sendKeySync = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__sendKeySync")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void sendKeySync(android.view.KeyEvent event)
  ///
  /// Send a key event to the currently focused window/view and wait for it to
  /// be processed.  Finished at some point after the recipient has returned
  /// from its event processing, though it may _not_ have completely
  /// finished reacting from the event -- for example, if it needs to update
  /// its display as a result, it may still be in the process of doing that.
  ///@param event The event to send to the current focus.
  void sendKeySync(jni.JniObject event) =>
      _sendKeySync(reference, event.reference).check();

  static final _sendKeyDownUpSync = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Instrumentation__sendKeyDownUpSync")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void sendKeyDownUpSync(int key)
  ///
  /// Sends an up and down key event sync to the currently focused window.
  ///@param key The integer keycode for the event.
  void sendKeyDownUpSync(int key) => _sendKeyDownUpSync(reference, key).check();

  static final _sendCharacterSync = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Instrumentation__sendCharacterSync")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void sendCharacterSync(int keyCode)
  ///
  /// Higher-level method for sending both the down and up key events for a
  /// particular character key code.  Equivalent to creating both KeyEvent
  /// objects by hand and calling \#sendKeySync.  The event appears
  /// as if it came from keyboard 0, the built in one.
  ///@param keyCode The key code of the character to send.
  void sendCharacterSync(int keyCode) =>
      _sendCharacterSync(reference, keyCode).check();

  static final _sendPointerSync = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__sendPointerSync")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void sendPointerSync(android.view.MotionEvent event)
  ///
  /// Dispatch a pointer event. Finished at some point after the recipient has
  /// returned from its event processing, though it may _not_ have
  /// completely finished reacting from the event -- for example, if it needs
  /// to update its display as a result, it may still be in the process of
  /// doing that.
  ///@param event A motion event describing the pointer action.  (As noted in
  /// MotionEvent\#obtain(long, long, int, float, float, int), be sure to use
  /// SystemClock\#uptimeMillis() as the timebase.
  void sendPointerSync(jni.JniObject event) =>
      _sendPointerSync(reference, event.reference).check();

  static final _sendTrackballEventSync = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__sendTrackballEventSync")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void sendTrackballEventSync(android.view.MotionEvent event)
  ///
  /// Dispatch a trackball event. Finished at some point after the recipient has
  /// returned from its event processing, though it may _not_ have
  /// completely finished reacting from the event -- for example, if it needs
  /// to update its display as a result, it may still be in the process of
  /// doing that.
  ///@param event A motion event describing the trackball action.  (As noted in
  /// MotionEvent\#obtain(long, long, int, float, float, int), be sure to use
  /// SystemClock\#uptimeMillis() as the timebase.
  void sendTrackballEventSync(jni.JniObject event) =>
      _sendTrackballEventSync(reference, event.reference).check();

  static final _newApplication = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__newApplication")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Application newApplication(java.lang.ClassLoader cl, java.lang.String className, android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform instantiation of the process's Application object.  The
  /// default implementation provides the normal system behavior.
  ///@param cl The ClassLoader with which to instantiate the object.
  ///@param className The name of the class implementing the Application
  ///                  object.
  ///@param context The context to initialize the application with
  ///@return The newly instantiated Application object.
  Application newApplication(jni.JniObject cl, jni.JniString className,
          content_.Context context) =>
      Application.fromRef(_newApplication(
              reference, cl.reference, className.reference, context.reference)
          .object);

  static final _newApplication1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__newApplication1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.Application newApplication(java.lang.Class<?> clazz, android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform instantiation of the process's Application object.  The
  /// default implementation provides the normal system behavior.
  ///@param clazz The class used to create an Application object from.
  ///@param context The context to initialize the application with
  ///@return The newly instantiated Application object.
  static Application newApplication1(
          jni.JniObject clazz, content_.Context context) =>
      Application.fromRef(
          _newApplication1(clazz.reference, context.reference).object);

  static final _callApplicationOnCreate = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__callApplicationOnCreate")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callApplicationOnCreate(android.app.Application app)
  ///
  /// Perform calling of the application's Application\#onCreate
  /// method.  The default implementation simply calls through to that method.
  ///
  /// Note: This method will be called immediately after \#onCreate(Bundle).
  /// Often instrumentation tests start their test thread in onCreate(); you
  /// need to be careful of races between these.  (Well between it and
  /// everything else, but let's start here.)
  ///@param app The application being created.
  void callApplicationOnCreate(Application app) =>
      _callApplicationOnCreate(reference, app.reference).check();

  static final _newActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__newActivity")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity newActivity(java.lang.Class<?> clazz, android.content.Context context, android.os.IBinder token, android.app.Application application, android.content.Intent intent, android.content.pm.ActivityInfo info, java.lang.CharSequence title, android.app.Activity parent, java.lang.String id, java.lang.Object lastNonConfigurationInstance)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform instantiation of an Activity object.  This method is intended for use with
  /// unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
  /// locally but will be missing some of the linkages necessary for use within the system.
  ///@param clazz The Class of the desired Activity
  ///@param context The base context for the activity to use
  ///@param token The token for this activity to communicate with
  ///@param application The application object (if any)
  ///@param intent The intent that started this Activity
  ///@param info ActivityInfo from the manifest
  ///@param title The title, typically retrieved from the ActivityInfo record
  ///@param parent The parent Activity (if any)
  ///@param id The embedded Id (if any)
  ///@param lastNonConfigurationInstance Arbitrary object that will be
  /// available via Activity\#getLastNonConfigurationInstance() Activity.getLastNonConfigurationInstance().
  ///@return Returns the instantiated activity
  ///@throws InstantiationException
  ///@throws IllegalAccessException
  Activity newActivity(
          jni.JniObject clazz,
          content_.Context context,
          os_.IBinder token,
          Application application,
          content_.Intent intent,
          pm_.ActivityInfo info,
          jni.JniObject title,
          Activity parent,
          jni.JniString id,
          jni.JniObject lastNonConfigurationInstance) =>
      Activity.fromRef(_newActivity(
              reference,
              clazz.reference,
              context.reference,
              token.reference,
              application.reference,
              intent.reference,
              info.reference,
              title.reference,
              parent.reference,
              id.reference,
              lastNonConfigurationInstance.reference)
          .object);

  static final _newActivity1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__newActivity1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity newActivity(java.lang.ClassLoader cl, java.lang.String className, android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform instantiation of the process's Activity object.  The
  /// default implementation provides the normal system behavior.
  ///@param cl The ClassLoader with which to instantiate the object.
  ///@param className The name of the class implementing the Activity
  ///                  object.
  ///@param intent The Intent object that specified the activity class being
  ///               instantiated.
  ///@return The newly instantiated Activity object.
  Activity newActivity1(
          jni.JniObject cl, jni.JniString className, content_.Intent intent) =>
      Activity.fromRef(_newActivity1(
              reference, cl.reference, className.reference, intent.reference)
          .object);

  static final _callActivityOnCreate = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__callActivityOnCreate")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnCreate(android.app.Activity activity, android.os.Bundle icicle)
  ///
  /// Perform calling of an activity's Activity\#onCreate
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being created.
  ///@param icicle The previously frozen state (or null) to pass through to onCreate().
  void callActivityOnCreate(Activity activity, os_.Bundle icicle) =>
      _callActivityOnCreate(reference, activity.reference, icicle.reference)
          .check();

  static final _callActivityOnCreate1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__callActivityOnCreate1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnCreate(android.app.Activity activity, android.os.Bundle icicle, android.os.PersistableBundle persistentState)
  ///
  /// Perform calling of an activity's Activity\#onCreate
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being created.
  ///@param icicle The previously frozen state (or null) to pass through to
  ///@param persistentState The previously persisted state (or null)
  void callActivityOnCreate1(Activity activity, os_.Bundle icicle,
          os_.PersistableBundle persistentState) =>
      _callActivityOnCreate1(reference, activity.reference, icicle.reference,
              persistentState.reference)
          .check();

  static final _callActivityOnDestroy = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__callActivityOnDestroy")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnDestroy(android.app.Activity activity)
  void callActivityOnDestroy(Activity activity) =>
      _callActivityOnDestroy(reference, activity.reference).check();

  static final _callActivityOnRestoreInstanceState = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__callActivityOnRestoreInstanceState")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnRestoreInstanceState(android.app.Activity activity, android.os.Bundle savedInstanceState)
  ///
  /// Perform calling of an activity's Activity\#onRestoreInstanceState
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being restored.
  ///@param savedInstanceState The previously saved state being restored.
  void callActivityOnRestoreInstanceState(
          Activity activity, os_.Bundle savedInstanceState) =>
      _callActivityOnRestoreInstanceState(
              reference, activity.reference, savedInstanceState.reference)
          .check();

  static final _callActivityOnRestoreInstanceState1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__callActivityOnRestoreInstanceState1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnRestoreInstanceState(android.app.Activity activity, android.os.Bundle savedInstanceState, android.os.PersistableBundle persistentState)
  ///
  /// Perform calling of an activity's Activity\#onRestoreInstanceState
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being restored.
  ///@param savedInstanceState The previously saved state being restored.
  ///@param persistentState The previously persisted state (or null)
  void callActivityOnRestoreInstanceState1(
          Activity activity,
          os_.Bundle savedInstanceState,
          os_.PersistableBundle persistentState) =>
      _callActivityOnRestoreInstanceState1(reference, activity.reference,
              savedInstanceState.reference, persistentState.reference)
          .check();

  static final _callActivityOnPostCreate = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__callActivityOnPostCreate")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnPostCreate(android.app.Activity activity, android.os.Bundle icicle)
  ///
  /// Perform calling of an activity's Activity\#onPostCreate method.
  /// The default implementation simply calls through to that method.
  ///@param activity The activity being created.
  ///@param icicle The previously frozen state (or null) to pass through to
  ///               onPostCreate().
  void callActivityOnPostCreate(Activity activity, os_.Bundle icicle) =>
      _callActivityOnPostCreate(reference, activity.reference, icicle.reference)
          .check();

  static final _callActivityOnPostCreate1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__callActivityOnPostCreate1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnPostCreate(android.app.Activity activity, android.os.Bundle icicle, android.os.PersistableBundle persistentState)
  ///
  /// Perform calling of an activity's Activity\#onPostCreate method.
  /// The default implementation simply calls through to that method.
  ///@param activity The activity being created.
  ///@param icicle The previously frozen state (or null) to pass through to
  ///               onPostCreate().
  void callActivityOnPostCreate1(Activity activity, os_.Bundle icicle,
          os_.PersistableBundle persistentState) =>
      _callActivityOnPostCreate1(reference, activity.reference,
              icicle.reference, persistentState.reference)
          .check();

  static final _callActivityOnNewIntent = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__callActivityOnNewIntent")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnNewIntent(android.app.Activity activity, android.content.Intent intent)
  ///
  /// Perform calling of an activity's Activity\#onNewIntent
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity receiving a new Intent.
  ///@param intent The new intent being received.
  void callActivityOnNewIntent(Activity activity, content_.Intent intent) =>
      _callActivityOnNewIntent(reference, activity.reference, intent.reference)
          .check();

  static final _callActivityOnStart = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__callActivityOnStart")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnStart(android.app.Activity activity)
  ///
  /// Perform calling of an activity's Activity\#onStart
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being started.
  void callActivityOnStart(Activity activity) =>
      _callActivityOnStart(reference, activity.reference).check();

  static final _callActivityOnRestart = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__callActivityOnRestart")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnRestart(android.app.Activity activity)
  ///
  /// Perform calling of an activity's Activity\#onRestart
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being restarted.
  void callActivityOnRestart(Activity activity) =>
      _callActivityOnRestart(reference, activity.reference).check();

  static final _callActivityOnResume = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__callActivityOnResume")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnResume(android.app.Activity activity)
  ///
  /// Perform calling of an activity's Activity\#onResume method.  The
  /// default implementation simply calls through to that method.
  ///@param activity The activity being resumed.
  void callActivityOnResume(Activity activity) =>
      _callActivityOnResume(reference, activity.reference).check();

  static final _callActivityOnStop = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__callActivityOnStop")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnStop(android.app.Activity activity)
  ///
  /// Perform calling of an activity's Activity\#onStop
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being stopped.
  void callActivityOnStop(Activity activity) =>
      _callActivityOnStop(reference, activity.reference).check();

  static final _callActivityOnSaveInstanceState = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__callActivityOnSaveInstanceState")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnSaveInstanceState(android.app.Activity activity, android.os.Bundle outState)
  ///
  /// Perform calling of an activity's Activity\#onSaveInstanceState
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being saved.
  ///@param outState The bundle to pass to the call.
  void callActivityOnSaveInstanceState(
          Activity activity, os_.Bundle outState) =>
      _callActivityOnSaveInstanceState(
              reference, activity.reference, outState.reference)
          .check();

  static final _callActivityOnSaveInstanceState1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__callActivityOnSaveInstanceState1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnSaveInstanceState(android.app.Activity activity, android.os.Bundle outState, android.os.PersistableBundle outPersistentState)
  ///
  /// Perform calling of an activity's Activity\#onSaveInstanceState
  /// method.  The default implementation simply calls through to that method.
  ///@param activity The activity being saved.
  ///@param outState The bundle to pass to the call.
  ///@param outPersistentState The persistent bundle to pass to the call.
  void callActivityOnSaveInstanceState1(Activity activity, os_.Bundle outState,
          os_.PersistableBundle outPersistentState) =>
      _callActivityOnSaveInstanceState1(reference, activity.reference,
              outState.reference, outPersistentState.reference)
          .check();

  static final _callActivityOnPause = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__callActivityOnPause")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnPause(android.app.Activity activity)
  ///
  /// Perform calling of an activity's Activity\#onPause method.  The
  /// default implementation simply calls through to that method.
  ///@param activity The activity being paused.
  void callActivityOnPause(Activity activity) =>
      _callActivityOnPause(reference, activity.reference).check();

  static final _callActivityOnUserLeaving = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__callActivityOnUserLeaving")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void callActivityOnUserLeaving(android.app.Activity activity)
  ///
  /// Perform calling of an activity's Activity\#onUserLeaveHint method.
  /// The default implementation simply calls through to that method.
  ///@param activity The activity being notified that the user has navigated away
  void callActivityOnUserLeaving(Activity activity) =>
      _callActivityOnUserLeaving(reference, activity.reference).check();

  static final _startAllocCounting = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__startAllocCounting")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void startAllocCounting()
  void startAllocCounting() => _startAllocCounting(reference).check();

  static final _stopAllocCounting = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__stopAllocCounting")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void stopAllocCounting()
  void stopAllocCounting() => _stopAllocCounting(reference).check();

  static final _getAllocCounts = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__getAllocCounts")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getAllocCounts()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a bundle with the current results from the allocation counting.
  os_.Bundle getAllocCounts() =>
      os_.Bundle.fromRef(_getAllocCounts(reference).object);

  static final _getBinderCounts = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__getBinderCounts")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getBinderCounts()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a bundle with the counts for various binder counts for this process. Currently the only two that are
  /// reported are the number of send and the number of received transactions.
  os_.Bundle getBinderCounts() =>
      os_.Bundle.fromRef(_getBinderCounts(reference).object);

  static final _getUiAutomation = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Instrumentation__getUiAutomation")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.UiAutomation getUiAutomation()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the UiAutomation instance with no flags set.
  ///
  /// <strong>Note:</strong> The APIs exposed via the returned UiAutomation
  /// work across application boundaries while the APIs exposed by the instrumentation
  /// do not. For example, Instrumentation\#sendPointerSync(MotionEvent) will
  /// not allow you to inject the event in an app different from the instrumentation
  /// target, while UiAutomation\#injectInputEvent(android.view.InputEvent, boolean)
  /// will work regardless of the current application.
  ///
  ///
  ///
  /// A typical test case should be using either the UiAutomation or
  /// Instrumentation APIs. Using both APIs at the same time is not
  /// a mistake by itself but a client has to be aware of the APIs limitations.
  ///
  ///
  ///
  /// Equivalent to {@code getUiAutomation(0)}. If a UiAutomation exists with different
  /// flags, the flags on that instance will be changed, and then it will be returned.
  ///
  ///
  ///@return The UI automation instance.
  ///@see UiAutomation
  UiAutomation getUiAutomation() =>
      UiAutomation.fromRef(_getUiAutomation(reference).object);

  static final _getUiAutomation1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Instrumentation__getUiAutomation1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.UiAutomation getUiAutomation(int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the UiAutomation instance with flags set.
  ///
  /// <strong>Note:</strong> The APIs exposed via the returned UiAutomation
  /// work across application boundaries while the APIs exposed by the instrumentation
  /// do not. For example, Instrumentation\#sendPointerSync(MotionEvent) will
  /// not allow you to inject the event in an app different from the instrumentation
  /// target, while UiAutomation\#injectInputEvent(android.view.InputEvent, boolean)
  /// will work regardless of the current application.
  ///
  ///
  ///
  /// A typical test case should be using either the UiAutomation or
  /// Instrumentation APIs. Using both APIs at the same time is not
  /// a mistake by itself but a client has to be aware of the APIs limitations.
  ///
  ///
  ///
  /// If a UiAutomation exists with different flags, the flags on that instance will be
  /// changed, and then it will be returned.
  ///
  ///
  ///@param flags The flags to be passed to the UiAutomation, for example
  ///        UiAutomation\#FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES.
  ///
  /// Value is 0, or android.app.UiAutomation\#FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES
  ///@return The UI automation instance.
  ///@see UiAutomation
  UiAutomation getUiAutomation1(int flags) =>
      UiAutomation.fromRef(_getUiAutomation1(reference, flags).object);

  static final _acquireLooperManager = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Instrumentation__acquireLooperManager")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.TestLooperManager acquireLooperManager(android.os.Looper looper)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Takes control of the execution of messages on the specified looper until
  /// TestLooperManager\#release is called.
  os_.TestLooperManager acquireLooperManager(os_.Looper looper) =>
      os_.TestLooperManager.fromRef(
          _acquireLooperManager(reference, looper.reference).object);
}

/// from: android.app.Instrumentation$ActivityResult
///
/// Description of a Activity execution result to return to the original
/// activity.
class Instrumentation_ActivityResult extends jni.JniObject {
  Instrumentation_ActivityResult.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "Instrumentation_ActivityResult__ctor")
      .asFunction<jni.JniResult Function(int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int resultCode, android.content.Intent resultData)
  ///
  /// Create a new activity result.  See Activity\#setResult for
  /// more information.
  ///@param resultCode The result code to propagate back to the
  /// originating activity, often RESULT_CANCELED or RESULT_OK
  ///@param resultData The data to propagate back to the originating
  /// activity.
  Instrumentation_ActivityResult(int resultCode, content_.Intent resultData)
      : super.fromRef(_ctor(resultCode, resultData.reference).object);

  static final _getResultCode = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Instrumentation_ActivityResult__getResultCode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getResultCode()
  ///
  /// Retrieve the result code contained in this result.
  int getResultCode() => _getResultCode(reference).integer;

  static final _getResultData = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Instrumentation_ActivityResult__getResultData")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent getResultData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the data contained in this result.
  content_.Intent getResultData() =>
      content_.Intent.fromRef(_getResultData(reference).object);
}

/// from: android.app.Instrumentation$ActivityMonitor
///
/// Information about a particular kind of Intent that is being monitored.
/// An instance of this class is added to the
/// current instrumentation through \#addMonitor; after being added,
/// when a new activity is being started the monitor will be checked and, if
/// matching, its hit count updated and (optionally) the call stopped and a
/// canned result returned.
///
/// An ActivityMonitor can also be used to look for the creation of an
/// activity, through the \#waitForActivity method.  This will return
/// after a matching activity has been created with that activity object.
class Instrumentation_ActivityMonitor extends jni.JniObject {
  Instrumentation_ActivityMonitor.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Instrumentation_ActivityMonitor__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.IntentFilter which, android.app.Instrumentation.ActivityResult result, boolean block)
  ///
  /// Create a new ActivityMonitor that looks for a particular kind of
  /// intent to be started.
  ///@param which The set of intents this monitor is responsible for.
  ///@param result A canned result to return if the monitor is hit; can
  ///               be null.
  ///@param block Controls whether the monitor should block the activity
  ///              start (returning its canned result) or let the call
  ///              proceed.
  ///@see Instrumentation\#addMonitor
  Instrumentation_ActivityMonitor(content_.IntentFilter which,
      Instrumentation_ActivityResult result, bool block)
      : super.fromRef(
            _ctor(which.reference, result.reference, block ? 1 : 0).object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Instrumentation_ActivityMonitor__ctor1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String cls, android.app.Instrumentation.ActivityResult result, boolean block)
  ///
  /// Create a new ActivityMonitor that looks for a specific activity
  /// class to be started.
  ///@param cls The activity class this monitor is responsible for.
  ///@param result A canned result to return if the monitor is hit; can
  ///               be null.
  ///@param block Controls whether the monitor should block the activity
  ///              start (returning its canned result) or let the call
  ///              proceed.
  ///@see Instrumentation\#addMonitor
  Instrumentation_ActivityMonitor.ctor1(
      jni.JniString cls, Instrumentation_ActivityResult result, bool block)
      : super.fromRef(
            _ctor1(cls.reference, result.reference, block ? 1 : 0).object);

  static final _ctor2 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Instrumentation_ActivityMonitor__ctor2")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ///
  /// Create a new ActivityMonitor that can be used for intercepting any activity to be
  /// started.
  ///
  ///  When an activity is started, \#onStartActivity(Intent) will be called on
  /// instances created using this constructor to see if it is a hit.
  ///@see \#onStartActivity(Intent)
  Instrumentation_ActivityMonitor.ctor2() : super.fromRef(_ctor2().object);

  static final _getFilter = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Instrumentation_ActivityMonitor__getFilter")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.content.IntentFilter getFilter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the filter associated with this ActivityMonitor.
  content_.IntentFilter getFilter() =>
      content_.IntentFilter.fromRef(_getFilter(reference).object);

  static final _getResult = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Instrumentation_ActivityMonitor__getResult")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Instrumentation.ActivityResult getResult()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the result associated with this ActivityMonitor, or null if
  /// none.
  Instrumentation_ActivityResult getResult() =>
      Instrumentation_ActivityResult.fromRef(_getResult(reference).object);

  static final _isBlocking = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Instrumentation_ActivityMonitor__isBlocking")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean isBlocking()
  ///
  /// Check whether this monitor blocks activity starts (not allowing the
  /// actual activity to run) or allows them to execute normally.
  bool isBlocking() => _isBlocking(reference).boolean;

  static final _getHits = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Instrumentation_ActivityMonitor__getHits")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getHits()
  ///
  /// Retrieve the number of times the monitor has been hit so far.
  int getHits() => _getHits(reference).integer;

  static final _getLastActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Instrumentation_ActivityMonitor__getLastActivity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Activity getLastActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the most recent activity class that was seen by this
  /// monitor.
  Activity getLastActivity() =>
      Activity.fromRef(_getLastActivity(reference).object);

  static final _waitForActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Instrumentation_ActivityMonitor__waitForActivity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Activity waitForActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Block until an Activity is created that matches this monitor,
  /// returning the resulting activity.
  ///@return Activity
  Activity waitForActivity() =>
      Activity.fromRef(_waitForActivity(reference).object);

  static final _waitForActivityWithTimeout = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "Instrumentation_ActivityMonitor__waitForActivityWithTimeout")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final android.app.Activity waitForActivityWithTimeout(long timeOut)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Block until an Activity is created that matches this monitor,
  /// returning the resulting activity or till the timeOut period expires.
  /// If the timeOut expires before the activity is started, return null.
  ///@param timeOut Time to wait in milliseconds before the activity is created.
  ///@return Activity
  Activity waitForActivityWithTimeout(int timeOut) =>
      Activity.fromRef(_waitForActivityWithTimeout(reference, timeOut).object);

  static final _onStartActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Instrumentation_ActivityMonitor__onStartActivity")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Instrumentation.ActivityResult onStartActivity(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used for intercepting any started activity.
  ///
  ///  A non-null return value here will be considered a hit for this monitor.
  /// By default this will return {@code null} and subclasses can override this to return
  /// a non-null value if the intent needs to be intercepted.
  ///
  ///  Whenever a new activity is started, this method will be called on instances created
  /// using \#Instrumentation.ActivityMonitor() to check if there is a match. In case
  /// of a match, the activity start will be blocked and the returned result will be used.
  ///@param intent The intent used for starting the activity.
  ///@return The ActivityResult that needs to be used in case of a match.
  Instrumentation_ActivityResult onStartActivity(content_.Intent intent) =>
      Instrumentation_ActivityResult.fromRef(
          _onStartActivity(reference, intent.reference).object);
}

/// from: android.app.IntentService
///
/// IntentService is a base class for Services that handle asynchronous
/// requests (expressed as Intents) on demand.  Clients send requests
/// through android.content.Context\#startService(Intent) calls; the
/// service is started as needed, handles each Intent in turn using a worker
/// thread, and stops itself when it runs out of work.
///
/// This "work queue processor" pattern is commonly used to offload tasks
/// from an application's main thread.  The IntentService class exists to
/// simplify this pattern and take care of the mechanics.  To use it, extend
/// IntentService and implement \#onHandleIntent(Intent).  IntentService
/// will receive the Intents, launch a worker thread, and stop the service as
/// appropriate.
///
/// All requests are handled on a single worker thread -- they may take as
/// long as necessary (and will not block the application's main loop), but
/// only one request will be processed at a time.
///
/// <p class="note">__Note:__ IntentService is subject to all the
/// <a href="/preview/features/background.html">background execution limits</a>
/// imposed with Android 8.0 (API level 26). In most cases, you are better off
/// using android.support.v4.app.JobIntentService, which uses jobs
/// instead of services when running on Android 8.0 or higher.
///
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For a detailed discussion about how to create services, read the
/// <a href="{@docRoot}guide/components/services.html">Services</a> developer
/// guide.
///
/// </div>
///@see android.support.v4.app.JobIntentService
///@see android.os.AsyncTask
class IntentService extends Service {
  IntentService.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor3 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("IntentService__ctor3")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String name)
  ///
  /// Creates an IntentService.  Invoked by your subclass's constructor.
  ///@param name Used to name the worker thread, important only for debugging.
  IntentService.ctor3(jni.JniString name)
      : super.fromRef(_ctor3(name.reference).object);

  static final _setIntentRedelivery = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("IntentService__setIntentRedelivery")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setIntentRedelivery(boolean enabled)
  ///
  /// Sets intent redelivery preferences.  Usually called from the constructor
  /// with your preferred semantics.
  ///
  /// If enabled is true,
  /// \#onStartCommand(Intent, int, int) will return
  /// Service\#START_REDELIVER_INTENT, so if this process dies before
  /// \#onHandleIntent(Intent) returns, the process will be restarted
  /// and the intent redelivered.  If multiple Intents have been sent, only
  /// the most recent one is guaranteed to be redelivered.
  ///
  /// If enabled is false (the default),
  /// \#onStartCommand(Intent, int, int) will return
  /// Service\#START_NOT_STICKY, and if the process dies, the Intent
  /// dies along with it.
  void setIntentRedelivery(bool enabled) =>
      _setIntentRedelivery(reference, enabled ? 1 : 0).check();

  static final _onCreate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("IntentService__onCreate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreate()
  void onCreate() => _onCreate(reference).check();

  static final _onStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("IntentService__onStart")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onStart(android.content.Intent intent, int startId)
  ///
  /// @param intent This value may be {@code null}.
  void onStart(content_.Intent intent, int startId) =>
      _onStart(reference, intent.reference, startId).check();

  static final _onStartCommand = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32)>>("IntentService__onStartCommand")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int onStartCommand(android.content.Intent intent, int flags, int startId)
  ///
  /// You should not override this method for your IntentService. Instead,
  /// override \#onHandleIntent, which the system calls when the IntentService
  /// receives a start request.
  ///@see android.app.Service\#onStartCommand
  ///@param intent This value may be {@code null}.
  int onStartCommand(content_.Intent intent, int flags, int startId) =>
      _onStartCommand(reference, intent.reference, flags, startId).integer;

  static final _onDestroy = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("IntentService__onDestroy")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDestroy()
  void onDestroy() => _onDestroy(reference).check();

  static final _onBind = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("IntentService__onBind")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Unless you provide binding for your service, you don't need to implement this
  /// method, because the default implementation returns null.
  ///@see android.app.Service\#onBind
  os_.IBinder onBind(content_.Intent intent) =>
      os_.IBinder.fromRef(_onBind(reference, intent.reference).object);

  static final _onHandleIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("IntentService__onHandleIntent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected abstract void onHandleIntent(android.content.Intent intent)
  ///
  /// This method is invoked on the worker thread with a request to process.
  /// Only one Intent is processed at a time, but the processing happens on a
  /// worker thread that runs independently from other application logic.
  /// So, if this code takes a long time, it will hold up other requests to
  /// the same IntentService, but it will not hold up anything else.
  /// When all requests have been handled, the IntentService stops itself,
  /// so you should not call \#stopSelf.
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param intent The value passed to android.content.Context\#startService(Intent).
  ///               This may be null if the service is being restarted after
  ///               its process has gone away; see
  ///               android.app.Service\#onStartCommand
  ///               for details.
  ///
  /// This value may be {@code null}.
  void onHandleIntent(content_.Intent intent) =>
      _onHandleIntent(reference, intent.reference).check();
}

/// from: android.app.KeyguardManager
///
/// Class that can be used to lock and unlock the keyboard. The
/// actual class to control the keyboard locking is
/// android.app.KeyguardManager.KeyguardLock.
class KeyguardManager extends jni.JniObject {
  KeyguardManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "KeyguardManager__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  KeyguardManager() : super.fromRef(_ctor().object);

  static final _createConfirmDeviceCredentialIntent = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "KeyguardManager__createConfirmDeviceCredentialIntent")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent createConfirmDeviceCredentialIntent(java.lang.CharSequence title, java.lang.CharSequence description)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get an intent to prompt the user to confirm credentials (pin, pattern or password)
  /// for the current user of the device. The caller is expected to launch this activity using
  /// android.app.Activity\#startActivityForResult(Intent, int) and check for
  /// android.app.Activity\#RESULT_OK if the user successfully completes the challenge.
  ///@return the intent for launching the activity or null if no password is required.
  content_.Intent createConfirmDeviceCredentialIntent(
          jni.JniObject title, jni.JniObject description) =>
      content_.Intent.fromRef(_createConfirmDeviceCredentialIntent(
              reference, title.reference, description.reference)
          .object);

  static final _newKeyguardLock = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("KeyguardManager__newKeyguardLock")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.KeyguardManager.KeyguardLock newKeyguardLock(java.lang.String tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Use LayoutParams\#FLAG_DISMISS_KEYGUARD
  /// and/or LayoutParams\#FLAG_SHOW_WHEN_LOCKED
  /// instead; this allows you to seamlessly hide the keyguard as your application
  /// moves in and out of the foreground and does not require that any special
  /// permissions be requested.
  ///
  /// Enables you to lock or unlock the keyboard. Get an instance of this class by
  /// calling android.content.Context\#getSystemService(java.lang.String) Context.getSystemService().
  /// This class is wrapped by android.app.KeyguardManager KeyguardManager.
  ///@param tag A tag that informally identifies who you are (for debugging who
  ///   is disabling he keyguard).
  ///@return A KeyguardLock handle to use to disable and reenable the
  ///   keyguard.
  KeyguardManager_KeyguardLock newKeyguardLock(jni.JniString tag) =>
      KeyguardManager_KeyguardLock.fromRef(
          _newKeyguardLock(reference, tag.reference).object);

  static final _isKeyguardLocked = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("KeyguardManager__isKeyguardLocked")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isKeyguardLocked()
  ///
  /// Return whether the keyguard is currently locked.
  ///@return true if keyguard is locked.
  bool isKeyguardLocked() => _isKeyguardLocked(reference).boolean;

  static final _isKeyguardSecure = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("KeyguardManager__isKeyguardSecure")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isKeyguardSecure()
  ///
  /// Return whether the keyguard is secured by a PIN, pattern or password or a SIM card
  /// is currently locked.
  ///
  /// See also \#isDeviceSecure() which ignores SIM locked states.
  ///@return true if a PIN, pattern or password is set or a SIM card is locked.
  bool isKeyguardSecure() => _isKeyguardSecure(reference).boolean;

  static final _inKeyguardRestrictedInputMode = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "KeyguardManager__inKeyguardRestrictedInputMode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean inKeyguardRestrictedInputMode()
  ///
  /// @deprecated Use \#isKeyguardLocked() instead.
  ///
  /// If keyguard screen is showing or in restricted key input mode (i.e. in
  /// keyguard password emergency screen). When in such mode, certain keys,
  /// such as the Home key and the right soft keys, don't work.
  ///@return true if in keyguard restricted input mode.
  bool inKeyguardRestrictedInputMode() =>
      _inKeyguardRestrictedInputMode(reference).boolean;

  static final _isDeviceLocked = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("KeyguardManager__isDeviceLocked")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isDeviceLocked()
  ///
  /// Returns whether the device is currently locked and requires a PIN, pattern or
  /// password to unlock.
  ///@return true if unlocking the device currently requires a PIN, pattern or
  /// password.
  bool isDeviceLocked() => _isDeviceLocked(reference).boolean;

  static final _isDeviceSecure = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("KeyguardManager__isDeviceSecure")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isDeviceSecure()
  ///
  /// Returns whether the device is secured with a PIN, pattern or
  /// password.
  ///
  /// See also \#isKeyguardSecure which treats SIM locked states as secure.
  ///@return true if a PIN, pattern or password was set.
  bool isDeviceSecure() => _isDeviceSecure(reference).boolean;

  static final _requestDismissKeyguard = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "KeyguardManager__requestDismissKeyguard")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void requestDismissKeyguard(android.app.Activity activity, android.app.KeyguardManager.KeyguardDismissCallback callback)
  ///
  /// If the device is currently locked (see \#isKeyguardLocked(), requests the Keyguard to
  /// be dismissed.
  ///
  /// If the Keyguard is not secure or the device is currently in a trusted state, calling this
  /// method will immediately dismiss the Keyguard without any user interaction.
  ///
  /// If the Keyguard is secure and the device is not in a trusted state, this will bring up the
  /// UI so the user can enter their credentials.
  ///
  /// If the value set for the Activity attr android.R.attr\#turnScreenOn is true,
  /// the screen will turn on when the keyguard is dismissed.
  ///@param activity The activity requesting the dismissal. The activity must be either visible
  ///                 by using LayoutParams\#FLAG_SHOW_WHEN_LOCKED or must be in a state in
  ///                 which it would be visible if Keyguard would not be hiding it. If that's not
  ///                 the case, the request will fail immediately and
  ///                 KeyguardDismissCallback\#onDismissError will be invoked.
  /// This value must never be {@code null}.
  ///@param callback The callback to be called if the request to dismiss Keyguard was successful
  ///                 or {@code null} if the caller isn't interested in knowing the result. The
  ///                 callback will not be invoked if the activity was destroyed before the
  ///                 callback was received.
  ///
  /// This value may be {@code null}.
  void requestDismissKeyguard(Activity activity,
          KeyguardManager_KeyguardDismissCallback callback) =>
      _requestDismissKeyguard(reference, activity.reference, callback.reference)
          .check();

  static final _exitKeyguardSecurely = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "KeyguardManager__exitKeyguardSecurely")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void exitKeyguardSecurely(android.app.KeyguardManager.OnKeyguardExitResult callback)
  ///
  /// Requires android.Manifest.permission\#DISABLE_KEYGUARD
  ///@deprecated Use LayoutParams\#FLAG_DISMISS_KEYGUARD
  /// and/or LayoutParams\#FLAG_SHOW_WHEN_LOCKED
  /// instead; this allows you to seamlessly hide the keyguard as your application
  /// moves in and out of the foreground and does not require that any special
  /// permissions be requested.
  ///
  /// Exit the keyguard securely.  The use case for this api is that, after
  /// disabling the keyguard, your app, which was granted permission to
  /// disable the keyguard and show a limited amount of information deemed
  /// safe without the user getting past the keyguard, needs to navigate to
  /// something that is not safe to view without getting past the keyguard.
  ///
  /// This will, if the keyguard is secure, bring up the unlock screen of
  /// the keyguard.
  ///@param callback Let's you know whether the operation was succesful and
  ///   it is safe to launch anything that would normally be considered safe
  ///   once the user has gotten past the keyguard.
  void exitKeyguardSecurely(KeyguardManager_OnKeyguardExitResult callback) =>
      _exitKeyguardSecurely(reference, callback.reference).check();
}

/// from: android.app.KeyguardManager$OnKeyguardExitResult
///
/// @deprecated Use KeyguardDismissCallback
/// Callback passed to KeyguardManager\#exitKeyguardSecurely to notify
/// caller of result.
class KeyguardManager_OnKeyguardExitResult extends jni.JniObject {
  KeyguardManager_OnKeyguardExitResult.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onKeyguardExitResult = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "KeyguardManager_OnKeyguardExitResult__onKeyguardExitResult")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void onKeyguardExitResult(boolean success)
  ///
  /// @param success True if the user was able to authenticate, false if
  ///   not.
  void onKeyguardExitResult(bool success) =>
      _onKeyguardExitResult(reference, success ? 1 : 0).check();
}

/// from: android.app.KeyguardManager$KeyguardLock
///
/// @deprecated Use LayoutParams\#FLAG_DISMISS_KEYGUARD
/// and/or LayoutParams\#FLAG_SHOW_WHEN_LOCKED
/// instead; this allows you to seamlessly hide the keyguard as your application
/// moves in and out of the foreground and does not require that any special
/// permissions be requested.
///
/// Handle returned by KeyguardManager\#newKeyguardLock that allows
/// you to disable / reenable the keyguard.
class KeyguardManager_KeyguardLock extends jni.JniObject {
  KeyguardManager_KeyguardLock.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("KeyguardManager_KeyguardLock__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(java.lang.String tag)
  KeyguardManager_KeyguardLock(jni.JniString tag)
      : super.fromRef(_ctor(tag.reference).object);

  static final _disableKeyguard = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "KeyguardManager_KeyguardLock__disableKeyguard")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void disableKeyguard()
  ///
  /// Disable the keyguard from showing.  If the keyguard is currently
  /// showing, hide it.  The keyguard will be prevented from showing again
  /// until \#reenableKeyguard() is called.
  ///
  /// A good place to call this is from android.app.Activity\#onResume()
  ///
  /// Note: This call has no effect while any android.app.admin.DevicePolicyManager
  /// is enabled that requires a password.
  ///
  /// Requires android.Manifest.permission\#DISABLE_KEYGUARD
  ///@see \#reenableKeyguard()
  void disableKeyguard() => _disableKeyguard(reference).check();

  static final _reenableKeyguard = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "KeyguardManager_KeyguardLock__reenableKeyguard")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void reenableKeyguard()
  ///
  /// Reenable the keyguard.  The keyguard will reappear if the previous
  /// call to \#disableKeyguard() caused it to be hidden.
  ///
  /// A good place to call this is from android.app.Activity\#onPause()
  ///
  /// Note: This call has no effect while any android.app.admin.DevicePolicyManager
  /// is enabled that requires a password.
  ///
  /// Requires android.Manifest.permission\#DISABLE_KEYGUARD
  ///@see \#disableKeyguard()
  void reenableKeyguard() => _reenableKeyguard(reference).check();
}

/// from: android.app.KeyguardManager$KeyguardDismissCallback
///
/// Callback passed to
/// KeyguardManager\#requestDismissKeyguard(Activity, KeyguardDismissCallback)
/// to notify caller of result.
class KeyguardManager_KeyguardDismissCallback extends jni.JniObject {
  KeyguardManager_KeyguardDismissCallback.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "KeyguardManager_KeyguardDismissCallback__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  KeyguardManager_KeyguardDismissCallback() : super.fromRef(_ctor().object);

  static final _onDismissError = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "KeyguardManager_KeyguardDismissCallback__onDismissError")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDismissError()
  ///
  /// Called when dismissing Keyguard is currently not feasible, i.e. when Keyguard is not
  /// available, not showing or when the activity requesting the Keyguard dismissal isn't
  /// showing or isn't showing behind Keyguard.
  void onDismissError() => _onDismissError(reference).check();

  static final _onDismissSucceeded = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "KeyguardManager_KeyguardDismissCallback__onDismissSucceeded")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDismissSucceeded()
  ///
  /// Called when dismissing Keyguard has succeeded and the device is now unlocked.
  void onDismissSucceeded() => _onDismissSucceeded(reference).check();

  static final _onDismissCancelled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "KeyguardManager_KeyguardDismissCallback__onDismissCancelled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDismissCancelled()
  ///
  /// Called when dismissing Keyguard has been cancelled, i.e. when the user cancelled the
  /// operation or the bouncer was hidden for some other reason.
  void onDismissCancelled() => _onDismissCancelled(reference).check();
}

/// from: android.app.LauncherActivity
///
/// Displays a list of all activities which can be performed
/// for a given intent. Launches when clicked.
class LauncherActivity extends ListActivity {
  LauncherActivity.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "LauncherActivity__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  LauncherActivity() : super.fromRef(_ctor().object);

  static final _onCreate2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("LauncherActivity__onCreate2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onCreate(android.os.Bundle icicle)
  void onCreate2(os_.Bundle icicle) =>
      _onCreate2(reference, icicle.reference).check();

  static final _setTitle2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("LauncherActivity__setTitle2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setTitle(java.lang.CharSequence title)
  void setTitle2(jni.JniObject title) =>
      _setTitle2(reference, title.reference).check();

  static final _setTitle3 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("LauncherActivity__setTitle3")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setTitle(int titleId)
  void setTitle3(int titleId) => _setTitle3(reference, titleId).check();

  static final _onSetContentView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("LauncherActivity__onSetContentView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onSetContentView()
  ///
  /// Override to call setContentView() with your own content view to
  /// customize the list layout.
  void onSetContentView() => _onSetContentView(reference).check();

  static final _onListItemClick = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int64)>>("LauncherActivity__onListItemClick")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: protected void onListItemClick(android.widget.ListView l, android.view.View v, int position, long id)
  void onListItemClick(
          jni.JniObject l, jni.JniObject v, int position, int id) =>
      _onListItemClick(reference, l.reference, v.reference, position, id)
          .check();

  static final _intentForPosition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("LauncherActivity__intentForPosition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: protected android.content.Intent intentForPosition(int position)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the actual Intent for a specific position in our
  /// android.widget.ListView.
  ///@param position The item whose Intent to return
  content_.Intent intentForPosition(int position) =>
      content_.Intent.fromRef(_intentForPosition(reference, position).object);

  static final _itemForPosition = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("LauncherActivity__itemForPosition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: protected android.app.LauncherActivity.ListItem itemForPosition(int position)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the ListItem for a specific position in our
  /// android.widget.ListView.
  ///@param position The item to return
  LauncherActivity_ListItem itemForPosition(int position) =>
      LauncherActivity_ListItem.fromRef(
          _itemForPosition(reference, position).object);

  static final _getTargetIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("LauncherActivity__getTargetIntent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected android.content.Intent getTargetIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the base intent to use when running
  /// PackageManager\#queryIntentActivities(Intent, int).
  content_.Intent getTargetIntent() =>
      content_.Intent.fromRef(_getTargetIntent(reference).object);

  static final _onQueryPackageManager = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "LauncherActivity__onQueryPackageManager")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected java.util.List<android.content.pm.ResolveInfo> onQueryPackageManager(android.content.Intent queryIntent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform query on package manager for list items.  The default
  /// implementation queries for activities.
  jni.JniObject onQueryPackageManager(content_.Intent queryIntent) =>
      jni.JniObject.fromRef(
          _onQueryPackageManager(reference, queryIntent.reference).object);

  static final _makeListItems = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("LauncherActivity__makeListItems")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.LauncherActivity.ListItem> makeListItems()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Perform the query to determine which results to show and return a list of them.
  jni.JniObject makeListItems() =>
      jni.JniObject.fromRef(_makeListItems(reference).object);
}

/// from: android.app.LauncherActivity$ListItem
///
/// An item in the list
class LauncherActivity_ListItem extends jni.JniObject {
  LauncherActivity_ListItem.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_className = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_LauncherActivity_ListItem__className")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String className
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString get className =>
      jni.JniString.fromRef(_get_className(reference).object);
  static final _set_className = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_LauncherActivity_ListItem__className")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String className
  /// The returned object must be deleted after use, by calling the `delete` method.
  set className(jni.JniString value) =>
      _set_className(reference, value.reference);

  static final _get_extras = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_LauncherActivity_ListItem__extras")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.os.Bundle extras
  /// The returned object must be deleted after use, by calling the `delete` method.
  os_.Bundle get extras => os_.Bundle.fromRef(_get_extras(reference).object);
  static final _set_extras = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_LauncherActivity_ListItem__extras")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle extras
  /// The returned object must be deleted after use, by calling the `delete` method.
  set extras(os_.Bundle value) => _set_extras(reference, value.reference);

  static final _get_icon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_LauncherActivity_ListItem__icon")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.graphics.drawable.Drawable icon
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get icon => jni.JniObject.fromRef(_get_icon(reference).object);
  static final _set_icon = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_LauncherActivity_ListItem__icon")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable icon
  /// The returned object must be deleted after use, by calling the `delete` method.
  set icon(jni.JniObject value) => _set_icon(reference, value.reference);

  static final _get_label = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_LauncherActivity_ListItem__label")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.CharSequence label
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject get label =>
      jni.JniObject.fromRef(_get_label(reference).object);
  static final _set_label = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_LauncherActivity_ListItem__label")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence label
  /// The returned object must be deleted after use, by calling the `delete` method.
  set label(jni.JniObject value) => _set_label(reference, value.reference);

  static final _get_packageName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_LauncherActivity_ListItem__packageName")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String packageName
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString get packageName =>
      jni.JniString.fromRef(_get_packageName(reference).object);
  static final _set_packageName = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_LauncherActivity_ListItem__packageName")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String packageName
  /// The returned object must be deleted after use, by calling the `delete` method.
  set packageName(jni.JniString value) =>
      _set_packageName(reference, value.reference);

  static final _get_resolveInfo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_LauncherActivity_ListItem__resolveInfo")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.content.pm.ResolveInfo resolveInfo
  /// The returned object must be deleted after use, by calling the `delete` method.
  pm_.ResolveInfo get resolveInfo =>
      pm_.ResolveInfo.fromRef(_get_resolveInfo(reference).object);
  static final _set_resolveInfo = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_LauncherActivity_ListItem__resolveInfo")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ResolveInfo resolveInfo
  /// The returned object must be deleted after use, by calling the `delete` method.
  set resolveInfo(pm_.ResolveInfo value) =>
      _set_resolveInfo(reference, value.reference);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "LauncherActivity_ListItem__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  LauncherActivity_ListItem() : super.fromRef(_ctor().object);
}

/// from: android.app.LauncherActivity$IconResizer
///
/// Utility class to resize icons to match default icon size.
class LauncherActivity_IconResizer extends jni.JniObject {
  LauncherActivity_IconResizer.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "LauncherActivity_IconResizer__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  LauncherActivity_IconResizer() : super.fromRef(_ctor().object);

  static final _createIconThumbnail = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "LauncherActivity_IconResizer__createIconThumbnail")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable createIconThumbnail(android.graphics.drawable.Drawable icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Drawable representing the thumbnail of the specified Drawable.
  /// The size of the thumbnail is defined by the dimension
  /// android.R.dimen.launcher_application_icon_size.
  ///
  /// This method is not thread-safe and should be invoked on the UI thread only.
  ///@param icon The icon to get a thumbnail of.
  ///@return A thumbnail for the specified icon or the icon itself if the
  ///         thumbnail could not be created.
  jni.JniObject createIconThumbnail(jni.JniObject icon) =>
      jni.JniObject.fromRef(
          _createIconThumbnail(reference, icon.reference).object);
}

/// from: android.app.ListActivity
///
/// An activity that displays a list of items by binding to a data source such as
/// an array or Cursor, and exposes event handlers when the user selects an item.
///
/// ListActivity hosts a android.widget.ListView ListView object that can
/// be bound to different data sources, typically either an array or a Cursor
/// holding query results. Binding, screen layout, and row layout are discussed
/// in the following sections.
///
/// <strong>Screen Layout</strong>
///
///
///
/// ListActivity has a default layout that consists of a single, full-screen list
/// in the center of the screen. However, if you desire, you can customize the
/// screen layout by setting your own view layout with setContentView() in
/// onCreate(). To do this, your own view MUST contain a ListView object with the
/// id "@android:id/list" (or android.R.id\#list if it's in code)
///
/// Optionally, your custom view can contain another view object of any type to
/// display when the list view is empty. This "empty list" notifier must have an
/// id "android:id/empty". Note that when an empty view is present, the list view
/// will be hidden when there is no data to display.
///
/// The following code demonstrates an (ugly) custom screen layout. It has a list
/// with a green background, and an alternate red "no data" message.
///
///
///
/// <pre>
/// &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
/// &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
///         android:orientation=&quot;vertical&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;match_parent&quot;
///         android:paddingLeft=&quot;8dp&quot;
///         android:paddingRight=&quot;8dp&quot;&gt;
///
///     &lt;ListView android:id=&quot;@android:id/list&quot;
///               android:layout_width=&quot;match_parent&quot;
///               android:layout_height=&quot;match_parent&quot;
///               android:background=&quot;\#00FF00&quot;
///               android:layout_weight=&quot;1&quot;
///               android:drawSelectorOnTop=&quot;false&quot;/&gt;
///
///     &lt;TextView android:id=&quot;@android:id/empty&quot;
///               android:layout_width=&quot;match_parent&quot;
///               android:layout_height=&quot;match_parent&quot;
///               android:background=&quot;\#FF0000&quot;
///               android:text=&quot;No data&quot;/&gt;
/// &lt;/LinearLayout&gt;
/// </pre>
///
///
/// <strong>Row Layout</strong>
///
///
///
/// You can specify the layout of individual rows in the list. You do this by
/// specifying a layout resource in the ListAdapter object hosted by the activity
/// (the ListAdapter binds the ListView to the data; more on this later).
///
/// A ListAdapter constructor takes a parameter that specifies a layout resource
/// for each row. It also has two additional parameters that let you specify
/// which data field to associate with which object in the row layout resource.
/// These two parameters are typically parallel arrays.
///
///
///
/// Android provides some standard row layout resources. These are in the
/// android.R.layout class, and have names such as simple_list_item_1,
/// simple_list_item_2, and two_line_list_item. The following layout XML is the
/// source for the resource two_line_list_item, which displays two data
/// fields,one above the other, for each list row.
///
///
///
/// <pre>
/// &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
/// &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
///     android:layout_width=&quot;match_parent&quot;
///     android:layout_height=&quot;wrap_content&quot;
///     android:orientation=&quot;vertical&quot;&gt;
///
///     &lt;TextView android:id=&quot;@+id/text1&quot;
///         android:textSize=&quot;16sp&quot;
///         android:textStyle=&quot;bold&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;wrap_content&quot;/&gt;
///
///     &lt;TextView android:id=&quot;@+id/text2&quot;
///         android:textSize=&quot;16sp&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;wrap_content&quot;/&gt;
/// &lt;/LinearLayout&gt;
/// </pre>
///
///
/// You must identify the data bound to each TextView object in this layout. The
/// syntax for this is discussed in the next section.
///
///
///
/// <strong>Binding to Data</strong>
///
///
///
/// You bind the ListActivity's ListView object to data using a class that
/// implements the android.widget.ListAdapter ListAdapter interface.
/// Android provides two standard list adapters:
/// android.widget.SimpleAdapter SimpleAdapter for static data (Maps),
/// and android.widget.SimpleCursorAdapter SimpleCursorAdapter for Cursor
/// query results.
///
///
///
/// The following code from a custom ListActivity demonstrates querying the
/// Contacts provider for all contacts, then binding the Name and Company fields
/// to a two line row layout in the activity's ListView.
///
///
///
/// <pre>
/// public class MyListAdapter extends ListActivity {
///
///     &\#064;Override
///     protected void onCreate(Bundle savedInstanceState){
///         super.onCreate(savedInstanceState);
///
///         // We'll define a custom screen layout here (the one shown above), but
///         // typically, you could just use the standard ListActivity layout.
///         setContentView(R.layout.custom_list_activity_view);
///
///         // Query for all people contacts using the android.provider.Contacts.People convenience class.
///         // Put a managed wrapper around the retrieved cursor so we don't have to worry about
///         // requerying or closing it as the activity changes state.
///         mCursor = this.getContentResolver().query(People.CONTENT_URI, null, null, null, null);
///         startManagingCursor(mCursor);
///
///         // Now create a new list adapter bound to the cursor.
///         // SimpleListAdapter is designed for binding to a Cursor.
///         ListAdapter adapter = new SimpleCursorAdapter(
///                 this, // Context.
///                 android.R.layout.two_line_list_item,  // Specify the row template to use (here, two columns bound to the two retrieved cursor
/// rows).
///                 mCursor,                                              // Pass in the cursor to bind to.
///                 new String[] {People.NAME, People.COMPANY},           // Array of cursor columns to bind to.
///                 new int[] {android.R.id.text1, android.R.id.text2});  // Parallel array of which template objects to bind to those columns.
///
///         // Bind to our new adapter.
///         setListAdapter(adapter);
///     }
/// }
/// </pre>
///@see \#setListAdapter
///@see android.widget.ListView
class ListActivity extends Activity {
  ListActivity.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ListActivity__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ListActivity() : super.fromRef(_ctor().object);

  static final _onListItemClick = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int64)>>("ListActivity__onListItemClick")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: protected void onListItemClick(android.widget.ListView l, android.view.View v, int position, long id)
  ///
  /// This method will be called when an item in the list is selected.
  /// Subclasses should override. Subclasses can call
  /// getListView().getItemAtPosition(position) if they need to access the
  /// data associated with the selected item.
  ///@param l The ListView where the click happened
  ///@param v The view that was clicked within the ListView
  ///@param position The position of the view in the list
  ///@param id The row id of the item that was clicked
  void onListItemClick(
          jni.JniObject l, jni.JniObject v, int position, int id) =>
      _onListItemClick(reference, l.reference, v.reference, position, id)
          .check();

  static final _onRestoreInstanceState = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ListActivity__onRestoreInstanceState")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onRestoreInstanceState(android.os.Bundle state)
  ///
  /// Ensures the list view has been created before Activity restores all
  /// of the view states.
  ///@see Activity\#onRestoreInstanceState(Bundle)
  void onRestoreInstanceState(os_.Bundle state) =>
      _onRestoreInstanceState(reference, state.reference).check();

  static final _onDestroy = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ListActivity__onDestroy")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onDestroy()
  ///
  /// @see Activity\#onDestroy()
  void onDestroy() => _onDestroy(reference).check();

  static final _onContentChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ListActivity__onContentChanged")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onContentChanged()
  ///
  /// Updates the screen state (current list and other views) when the
  /// content changes.
  ///@see Activity\#onContentChanged()
  void onContentChanged() => _onContentChanged(reference).check();

  static final _setListAdapter = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ListActivity__setListAdapter")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setListAdapter(android.widget.ListAdapter adapter)
  ///
  /// Provide the cursor for the list view.
  void setListAdapter(jni.JniObject adapter) =>
      _setListAdapter(reference, adapter.reference).check();

  static final _setSelection = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ListActivity__setSelection")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setSelection(int position)
  ///
  /// Set the currently selected list item to the specified
  /// position with the adapter's data
  ///@param position
  void setSelection(int position) => _setSelection(reference, position).check();

  static final _getSelectedItemPosition = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ListActivity__getSelectedItemPosition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getSelectedItemPosition()
  ///
  /// Get the position of the currently selected list item.
  int getSelectedItemPosition() => _getSelectedItemPosition(reference).integer;

  static final _getSelectedItemId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ListActivity__getSelectedItemId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getSelectedItemId()
  ///
  /// Get the cursor row ID of the currently selected list item.
  int getSelectedItemId() => _getSelectedItemId(reference).long;

  static final _getListView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ListActivity__getListView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.ListView getListView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the activity's list view widget.
  jni.JniObject getListView() =>
      jni.JniObject.fromRef(_getListView(reference).object);

  static final _getListAdapter = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ListActivity__getListAdapter")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.ListAdapter getListAdapter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the ListAdapter associated with this activity's ListView.
  jni.JniObject getListAdapter() =>
      jni.JniObject.fromRef(_getListAdapter(reference).object);
}

/// from: android.app.ListFragment
///
/// A fragment that displays a list of items by binding to a data source such as
/// an array or Cursor, and exposes event handlers when the user selects an item.
///
/// ListFragment hosts a android.widget.ListView ListView object that can
/// be bound to different data sources, typically either an array or a Cursor
/// holding query results. Binding, screen layout, and row layout are discussed
/// in the following sections.
///
/// <strong>Screen Layout</strong>
///
///
///
/// ListFragment has a default layout that consists of a single list view.
/// However, if you desire, you can customize the fragment layout by returning
/// your own view hierarchy from \#onCreateView.
/// To do this, your view hierarchy _must_ contain a ListView object with the
/// id "@android:id/list" (or android.R.id\#list if it's in code)
///
/// Optionally, your view hierarchy can contain another view object of any type to
/// display when the list view is empty. This "empty list" notifier must have an
/// id "android:empty". Note that when an empty view is present, the list view
/// will be hidden when there is no data to display.
///
/// The following code demonstrates an (ugly) custom list layout. It has a list
/// with a green background, and an alternate red "no data" message.
///
///
///
/// <pre>
/// &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
/// &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
///         android:orientation=&quot;vertical&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;match_parent&quot;
///         android:paddingLeft=&quot;8dp&quot;
///         android:paddingRight=&quot;8dp&quot;&gt;
///
///     &lt;ListView android:id=&quot;@id/android:list&quot;
///               android:layout_width=&quot;match_parent&quot;
///               android:layout_height=&quot;match_parent&quot;
///               android:background=&quot;\#00FF00&quot;
///               android:layout_weight=&quot;1&quot;
///               android:drawSelectorOnTop=&quot;false&quot;/&gt;
///
///     &lt;TextView android:id=&quot;@id/android:empty&quot;
///               android:layout_width=&quot;match_parent&quot;
///               android:layout_height=&quot;match_parent&quot;
///               android:background=&quot;\#FF0000&quot;
///               android:text=&quot;No data&quot;/&gt;
/// &lt;/LinearLayout&gt;
/// </pre>
///
///
/// <strong>Row Layout</strong>
///
///
///
/// You can specify the layout of individual rows in the list. You do this by
/// specifying a layout resource in the ListAdapter object hosted by the fragment
/// (the ListAdapter binds the ListView to the data; more on this later).
///
/// A ListAdapter constructor takes a parameter that specifies a layout resource
/// for each row. It also has two additional parameters that let you specify
/// which data field to associate with which object in the row layout resource.
/// These two parameters are typically parallel arrays.
///
///
///
/// Android provides some standard row layout resources. These are in the
/// android.R.layout class, and have names such as simple_list_item_1,
/// simple_list_item_2, and two_line_list_item. The following layout XML is the
/// source for the resource two_line_list_item, which displays two data
/// fields,one above the other, for each list row.
///
///
///
/// <pre>
/// &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
/// &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
///     android:layout_width=&quot;match_parent&quot;
///     android:layout_height=&quot;wrap_content&quot;
///     android:orientation=&quot;vertical&quot;&gt;
///
///     &lt;TextView android:id=&quot;@+id/text1&quot;
///         android:textSize=&quot;16sp&quot;
///         android:textStyle=&quot;bold&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;wrap_content&quot;/&gt;
///
///     &lt;TextView android:id=&quot;@+id/text2&quot;
///         android:textSize=&quot;16sp&quot;
///         android:layout_width=&quot;match_parent&quot;
///         android:layout_height=&quot;wrap_content&quot;/&gt;
/// &lt;/LinearLayout&gt;
/// </pre>
///
///
/// You must identify the data bound to each TextView object in this layout. The
/// syntax for this is discussed in the next section.
///
///
///
/// <strong>Binding to Data</strong>
///
///
///
/// You bind the ListFragment's ListView object to data using a class that
/// implements the android.widget.ListAdapter ListAdapter interface.
/// Android provides two standard list adapters:
/// android.widget.SimpleAdapter SimpleAdapter for static data (Maps),
/// and android.widget.SimpleCursorAdapter SimpleCursorAdapter for Cursor
/// query results.
///
///
///
/// You __must__ use
/// \#setListAdapter(ListAdapter) ListFragment.setListAdapter() to
/// associate the list with an adapter.  Do not directly call
/// ListView\#setAdapter(ListAdapter) ListView.setAdapter() or else
/// important initialization will be skipped.
///
///
///@see \#setListAdapter
///@see android.widget.ListView
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.ListFragment for consistent behavior across all devices
///      and access to <a href="{@docRoot}topic/libraries/architecture/lifecycle.html">Lifecycle</a>.
class ListFragment extends Fragment {
  ListFragment.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ListFragment__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ListFragment() : super.fromRef(_ctor().object);

  static final _onCreateView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ListFragment__onCreateView")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View onCreateView(android.view.LayoutInflater inflater, android.view.ViewGroup container, android.os.Bundle savedInstanceState)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Provide default implementation to return a simple list view.  Subclasses
  /// can override to replace with their own layout.  If doing so, the
  /// returned view hierarchy _must_ have a ListView whose id
  /// is android.R.id\#list android.R.id.list and can optionally
  /// have a sibling view id android.R.id\#empty android.R.id.empty
  /// that is to be shown when the list is empty.
  ///
  /// If you are overriding this method with your own custom content,
  /// consider including the standard layout android.R.layout\#list_content
  /// in your layout file, so that you continue to retain all of the standard
  /// behavior of ListFragment.  In particular, this is currently the only
  /// way to have the built-in indeterminant progress state be shown.
  jni.JniObject onCreateView(jni.JniObject inflater, jni.JniObject container,
          os_.Bundle savedInstanceState) =>
      jni.JniObject.fromRef(_onCreateView(reference, inflater.reference,
              container.reference, savedInstanceState.reference)
          .object);

  static final _onViewCreated = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ListFragment__onViewCreated")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onViewCreated(android.view.View view, android.os.Bundle savedInstanceState)
  ///
  /// Attach to list view once the view hierarchy has been created.
  void onViewCreated(jni.JniObject view, os_.Bundle savedInstanceState) =>
      _onViewCreated(reference, view.reference, savedInstanceState.reference)
          .check();

  static final _onDestroyView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ListFragment__onDestroyView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDestroyView()
  ///
  /// Detach from list view.
  void onDestroyView() => _onDestroyView(reference).check();

  static final _onListItemClick = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int64)>>("ListFragment__onListItemClick")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void onListItemClick(android.widget.ListView l, android.view.View v, int position, long id)
  ///
  /// This method will be called when an item in the list is selected.
  /// Subclasses should override. Subclasses can call
  /// getListView().getItemAtPosition(position) if they need to access the
  /// data associated with the selected item.
  ///@param l The ListView where the click happened
  ///@param v The view that was clicked within the ListView
  ///@param position The position of the view in the list
  ///@param id The row id of the item that was clicked
  void onListItemClick(
          jni.JniObject l, jni.JniObject v, int position, int id) =>
      _onListItemClick(reference, l.reference, v.reference, position, id)
          .check();

  static final _setListAdapter = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ListFragment__setListAdapter")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setListAdapter(android.widget.ListAdapter adapter)
  ///
  /// Provide the cursor for the list view.
  void setListAdapter(jni.JniObject adapter) =>
      _setListAdapter(reference, adapter.reference).check();

  static final _setSelection = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ListFragment__setSelection")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setSelection(int position)
  ///
  /// Set the currently selected list item to the specified
  /// position with the adapter's data
  ///@param position
  void setSelection(int position) => _setSelection(reference, position).check();

  static final _getSelectedItemPosition = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ListFragment__getSelectedItemPosition")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getSelectedItemPosition()
  ///
  /// Get the position of the currently selected list item.
  int getSelectedItemPosition() => _getSelectedItemPosition(reference).integer;

  static final _getSelectedItemId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ListFragment__getSelectedItemId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getSelectedItemId()
  ///
  /// Get the cursor row ID of the currently selected list item.
  int getSelectedItemId() => _getSelectedItemId(reference).long;

  static final _getListView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ListFragment__getListView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.ListView getListView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the fragment's list view widget.
  jni.JniObject getListView() =>
      jni.JniObject.fromRef(_getListView(reference).object);

  static final _setEmptyText = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ListFragment__setEmptyText")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setEmptyText(java.lang.CharSequence text)
  ///
  /// The default content for a ListFragment has a TextView that can
  /// be shown when the list is empty.  If you would like to have it
  /// shown, call this method to supply the text it should use.
  void setEmptyText(jni.JniObject text) =>
      _setEmptyText(reference, text.reference).check();

  static final _setListShown = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("ListFragment__setListShown")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setListShown(boolean shown)
  ///
  /// Control whether the list is being displayed.  You can make it not
  /// displayed if you are waiting for the initial data to show in it.  During
  /// this time an indeterminant progress indicator will be shown instead.
  ///
  /// Applications do not normally need to use this themselves.  The default
  /// behavior of ListFragment is to start with the list not being shown, only
  /// showing it once an adapter is given with \#setListAdapter(ListAdapter).
  /// If the list at that point had not been shown, when it does get shown
  /// it will be do without the user ever seeing the hidden state.
  ///@param shown If true, the list view is shown; if false, the progress
  /// indicator.  The initial value is true.
  void setListShown(bool shown) =>
      _setListShown(reference, shown ? 1 : 0).check();

  static final _setListShownNoAnimation = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("ListFragment__setListShownNoAnimation")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setListShownNoAnimation(boolean shown)
  ///
  /// Like \#setListShown(boolean), but no animation is used when
  /// transitioning from the previous state.
  void setListShownNoAnimation(bool shown) =>
      _setListShownNoAnimation(reference, shown ? 1 : 0).check();

  static final _getListAdapter = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ListFragment__getListAdapter")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.ListAdapter getListAdapter()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the ListAdapter associated with this fragment's ListView.
  jni.JniObject getListAdapter() =>
      jni.JniObject.fromRef(_getListAdapter(reference).object);
}

/// from: android.app.LoaderManager
///
/// Interface associated with an Activity or Fragment for managing
/// one or more android.content.Loader instances associated with it.  This
/// helps an application manage longer-running operations in conjunction with the
/// Activity or Fragment lifecycle; the most common use of this is with a
/// android.content.CursorLoader, however applications are free to write
/// their own loaders for loading other types of data.
///
/// While the LoaderManager API was introduced in
/// android.os.Build.VERSION_CODES\#HONEYCOMB, a version of the API
/// at is also available for use on older platforms through
/// android.support.v4.app.FragmentActivity.  See the blog post
/// <a href="http://android-developers.blogspot.com/2011/03/fragments-for-all.html">
/// Fragments For All</a> for more details.
///
/// As an example, here is the full implementation of a Fragment
/// that displays a android.widget.ListView containing the results of
/// a query against the contacts content provider.  It uses a
/// android.content.CursorLoader to manage the query on the provider.
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/LoaderCursor.java
///      fragment_cursor}
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using loaders, read the
/// <a href="{@docRoot}guide/topics/fundamentals/loaders.html">Loaders</a> developer guide.
///
/// </div>
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">Support Library</a>
///      android.support.v4.app.LoaderManager
class LoaderManager extends jni.JniObject {
  LoaderManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "LoaderManager__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  LoaderManager() : super.fromRef(_ctor().object);

  static final _initLoader = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("LoaderManager__initLoader")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Loader<D> initLoader(int id, android.os.Bundle args, android.app.LoaderManager.LoaderCallbacks<D> callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Ensures a loader is initialized and active.  If the loader doesn't
  /// already exist, one is created and (if the activity/fragment is currently
  /// started) starts the loader.  Otherwise the last created
  /// loader is re-used.
  ///
  /// In either case, the given callback is associated with the loader, and
  /// will be called as the loader state changes.  If at the point of call
  /// the caller is in its started state, and the requested loader
  /// already exists and has generated its data, then
  /// callback LoaderCallbacks\#onLoadFinished will
  /// be called immediately (inside of this function), so you must be prepared
  /// for this to happen.
  ///@param id A unique identifier for this loader.  Can be whatever you want.
  /// Identifiers are scoped to a particular LoaderManager instance.
  ///@param args Optional arguments to supply to the loader at construction.
  /// If a loader already exists (a new one does not need to be created), this
  /// parameter will be ignored and the last arguments continue to be used.
  ///@param callback Interface the LoaderManager will call to report about
  /// changes in the state of the loader.  Required.
  content_.Loader initLoader(
          int id, os_.Bundle args, LoaderManager_LoaderCallbacks callback) =>
      content_.Loader.fromRef(
          _initLoader(reference, id, args.reference, callback.reference)
              .object);

  static final _restartLoader = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("LoaderManager__restartLoader")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Loader<D> restartLoader(int id, android.os.Bundle args, android.app.LoaderManager.LoaderCallbacks<D> callback)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Starts a new or restarts an existing android.content.Loader in
  /// this manager, registers the callbacks to it,
  /// and (if the activity/fragment is currently started) starts loading it.
  /// If a loader with the same id has previously been
  /// started it will automatically be destroyed when the new loader completes
  /// its work. The callback will be delivered before the old loader
  /// is destroyed.
  ///@param id A unique identifier for this loader.  Can be whatever you want.
  /// Identifiers are scoped to a particular LoaderManager instance.
  ///@param args Optional arguments to supply to the loader at construction.
  ///@param callback Interface the LoaderManager will call to report about
  /// changes in the state of the loader.  Required.
  content_.Loader restartLoader(
          int id, os_.Bundle args, LoaderManager_LoaderCallbacks callback) =>
      content_.Loader.fromRef(
          _restartLoader(reference, id, args.reference, callback.reference)
              .object);

  static final _destroyLoader = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("LoaderManager__destroyLoader")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void destroyLoader(int id)
  ///
  /// Stops and removes the loader with the given ID.  If this loader
  /// had previously reported data to the client through
  /// LoaderCallbacks\#onLoadFinished(Loader, Object), a call
  /// will be made to LoaderCallbacks\#onLoaderReset(Loader).
  void destroyLoader(int id) => _destroyLoader(reference, id).check();

  static final _getLoader = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("LoaderManager__getLoader")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract android.content.Loader<D> getLoader(int id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Loader with the given id or null if no matching Loader
  /// is found.
  content_.Loader getLoader(int id) =>
      content_.Loader.fromRef(_getLoader(reference, id).object);

  static final _dump = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("LoaderManager__dump")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void dump(java.lang.String prefix, java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  ///
  /// Print the LoaderManager's state into the given stream.
  ///@param prefix Text to print at the front of each line.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer A PrintWriter to which the dump is to be set.
  ///@param args Additional arguments to the dump request.
  void dump(jni.JniString prefix, jni.JniObject fd, jni.JniObject writer,
          jni.JniObject args) =>
      _dump(reference, prefix.reference, fd.reference, writer.reference,
              args.reference)
          .check();

  static final _enableDebugLogging =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Uint8)>>(
              "LoaderManager__enableDebugLogging")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public void enableDebugLogging(boolean enabled)
  ///
  /// Control whether the framework's internal loader manager debugging
  /// logs are turned on.  If enabled, you will see output in logcat as
  /// the framework performs loader operations.
  static void enableDebugLogging(bool enabled) =>
      _enableDebugLogging(enabled ? 1 : 0).check();
}

/// from: android.app.LoaderManager$LoaderCallbacks
///
/// Callback interface for a client to interact with the manager.
///@deprecated Use the <a href="{@docRoot}tools/extras/support-library.html">
///      Support Library</a> android.support.v4.app.LoaderManager.LoaderCallbacks
class LoaderManager_LoaderCallbacks extends jni.JniObject {
  LoaderManager_LoaderCallbacks.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onCreateLoader = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "LoaderManager_LoaderCallbacks__onCreateLoader")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.content.Loader<D> onCreateLoader(int id, android.os.Bundle args)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Instantiate and return a new Loader for the given ID.
  ///@param id The ID whose loader is to be created.
  ///@param args Any arguments supplied by the caller.
  ///@return Return a new Loader instance that is ready to start loading.
  content_.Loader onCreateLoader(int id, os_.Bundle args) =>
      content_.Loader.fromRef(
          _onCreateLoader(reference, id, args.reference).object);

  static final _onLoaderReset = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "LoaderManager_LoaderCallbacks__onLoaderReset")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onLoaderReset(android.content.Loader<D> loader)
  ///
  /// Called when a previously created loader is being reset, and thus
  /// making its data unavailable.  The application should at this point
  /// remove any references it has to the Loader's data.
  ///@param loader The Loader that is being reset.
  void onLoaderReset(content_.Loader loader) =>
      _onLoaderReset(reference, loader.reference).check();
}

/// from: android.app.LocalActivityManager
///
/// Helper class for managing multiple running embedded activities in the same
/// process. This class is not normally used directly, but rather created for
/// you as part of the android.app.ActivityGroup implementation.
///@see ActivityGroup
///@deprecated Use the new Fragment and FragmentManager APIs
/// instead; these are also
/// available on older platforms through the Android compatibility package.
class LocalActivityManager extends jni.JniObject {
  LocalActivityManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("LocalActivityManager__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.app.Activity parent, boolean singleMode)
  ///
  /// Create a new LocalActivityManager for holding activities running within
  /// the given <var>parent</var>.
  ///@param parent the host of the embedded activities
  ///@param singleMode True if the LocalActivityManger should keep a maximum
  /// of one activity resumed
  LocalActivityManager(Activity parent, bool singleMode)
      : super.fromRef(_ctor(parent.reference, singleMode ? 1 : 0).object);

  static final _startActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "LocalActivityManager__startActivity")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.Window startActivity(java.lang.String id, android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Start a new activity running in the group.  Every activity you start
  /// must have a unique string ID associated with it -- this is used to keep
  /// track of the activity, so that if you later call startActivity() again
  /// on it the same activity object will be retained.
  ///
  /// When there had previously been an activity started under this id,
  /// it may either be destroyed and a new one started, or the current
  /// one re-used, based on these conditions, in order:
  ///
  ///
  /// <ul>
  /// <li> If the Intent maps to a different activity component than is
  /// currently running, the current activity is finished and a new one
  /// started.
  /// <li> If the current activity uses a non-multiple launch mode (such
  /// as singleTop), or the Intent has the
  /// Intent\#FLAG_ACTIVITY_SINGLE_TOP flag set, then the current
  /// activity will remain running and its
  /// Activity\#onNewIntent(Intent) Activity.onNewIntent() method
  /// called.
  /// <li> If the new Intent is the same (excluding extras) as the previous
  /// one, and the new Intent does not have the
  /// Intent\#FLAG_ACTIVITY_CLEAR_TOP set, then the current activity
  /// will remain running as-is.
  /// <li> Otherwise, the current activity will be finished and a new
  /// one started.
  /// </ul>
  ///
  /// If the given Intent can not be resolved to an available Activity,
  /// this method throws android.content.ActivityNotFoundException.
  ///
  /// Warning: There is an issue where, if the Intent does not
  /// include an explicit component, we can restore the state for a different
  /// activity class than was previously running when the state was saved (if
  /// the set of available activities changes between those points).
  ///@param id Unique identifier of the activity to be started
  ///@param intent The Intent describing the activity to be started
  ///@return Returns the window of the activity.  The caller needs to take
  /// care of adding this window to a view hierarchy, and likewise dealing
  /// with removing the old window if the activity has changed.
  ///@throws android.content.ActivityNotFoundException
  jni.JniObject startActivity(jni.JniString id, content_.Intent intent) =>
      jni.JniObject.fromRef(
          _startActivity(reference, id.reference, intent.reference).object);

  static final _destroyActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("LocalActivityManager__destroyActivity")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.Window destroyActivity(java.lang.String id, boolean finish)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Destroy the activity associated with a particular id.  This activity
  /// will go through the normal lifecycle events and fine onDestroy(), and
  /// then the id removed from the group.
  ///@param id Unique identifier of the activity to be destroyed
  ///@param finish If true, this activity will be finished, so its id and
  /// all state are removed from the group.
  ///@return Returns the window that was used to display the activity, or
  /// null if there was none.
  jni.JniObject destroyActivity(jni.JniString id, bool finish) =>
      jni.JniObject.fromRef(
          _destroyActivity(reference, id.reference, finish ? 1 : 0).object);

  static final _getCurrentActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "LocalActivityManager__getCurrentActivity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity getCurrentActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the Activity that is currently running.
  ///@return the currently running (resumed) Activity, or null if there is
  ///         not one
  ///@see \#startActivity
  ///@see \#getCurrentId
  Activity getCurrentActivity() =>
      Activity.fromRef(_getCurrentActivity(reference).object);

  static final _getCurrentId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("LocalActivityManager__getCurrentId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getCurrentId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the ID of the activity that is currently running.
  ///@return the ID of the currently running (resumed) Activity, or null if
  ///         there is not one
  ///@see \#startActivity
  ///@see \#getCurrentActivity
  jni.JniString getCurrentId() =>
      jni.JniString.fromRef(_getCurrentId(reference).object);

  static final _getActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("LocalActivityManager__getActivity")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity getActivity(java.lang.String id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the Activity object associated with a string ID.
  ///@see \#startActivity
  ///@return the associated Activity object, or null if the id is unknown or
  ///         its activity is not currently instantiated
  Activity getActivity(jni.JniString id) =>
      Activity.fromRef(_getActivity(reference, id.reference).object);

  static final _dispatchCreate = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "LocalActivityManager__dispatchCreate")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchCreate(android.os.Bundle state)
  ///
  /// Restore a state that was previously returned by \#saveInstanceState.  This
  /// adds to the activity group information about all activity IDs that had
  /// previously been saved, even if they have not been started yet, so if the
  /// user later navigates to them the correct state will be restored.
  ///
  /// Note: This does __not__ change the current running activity, or
  /// start whatever activity was previously running when the state was saved.
  /// That is up to the client to do, in whatever way it thinks is best.
  ///@param state a previously saved state; does nothing if this is null
  ///@see \#saveInstanceState
  void dispatchCreate(os_.Bundle state) =>
      _dispatchCreate(reference, state.reference).check();

  static final _saveInstanceState = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "LocalActivityManager__saveInstanceState")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle saveInstanceState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the state of all activities known by the group.  For
  /// activities that have previously run and are now stopped or finished, the
  /// last saved state is used.  For the current running activity, its
  /// Activity\#onSaveInstanceState is called to retrieve its current state.
  ///@return a Bundle holding the newly created state of all known activities
  ///@see \#dispatchCreate
  os_.Bundle saveInstanceState() =>
      os_.Bundle.fromRef(_saveInstanceState(reference).object);

  static final _dispatchResume = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "LocalActivityManager__dispatchResume")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchResume()
  ///
  /// Called by the container activity in its Activity\#onResume so
  /// that LocalActivityManager can perform the corresponding action on the
  /// activities it holds.
  ///@see Activity\#onResume
  void dispatchResume() => _dispatchResume(reference).check();

  static final _dispatchPause = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("LocalActivityManager__dispatchPause")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void dispatchPause(boolean finishing)
  ///
  /// Called by the container activity in its Activity\#onPause so
  /// that LocalActivityManager can perform the corresponding action on the
  /// activities it holds.
  ///@param finishing set to true if the parent activity has been finished;
  ///                  this can be determined by calling
  ///                  Activity.isFinishing()
  ///@see Activity\#onPause
  ///@see Activity\#isFinishing
  void dispatchPause(bool finishing) =>
      _dispatchPause(reference, finishing ? 1 : 0).check();

  static final _dispatchStop = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("LocalActivityManager__dispatchStop")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void dispatchStop()
  ///
  /// Called by the container activity in its Activity\#onStop so
  /// that LocalActivityManager can perform the corresponding action on the
  /// activities it holds.
  ///@see Activity\#onStop
  void dispatchStop() => _dispatchStop(reference).check();

  static final _removeAllActivities = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "LocalActivityManager__removeAllActivities")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void removeAllActivities()
  ///
  /// Remove all activities from this LocalActivityManager, performing an
  /// Activity\#onDestroy on any that are currently instantiated.
  void removeAllActivities() => _removeAllActivities(reference).check();

  static final _dispatchDestroy = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("LocalActivityManager__dispatchDestroy")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void dispatchDestroy(boolean finishing)
  ///
  /// Called by the container activity in its Activity\#onDestroy so
  /// that LocalActivityManager can perform the corresponding action on the
  /// activities it holds.
  ///@see Activity\#onDestroy
  void dispatchDestroy(bool finishing) =>
      _dispatchDestroy(reference, finishing ? 1 : 0).check();
}

/// from: android.app.MediaRouteActionProvider
///
/// The media route action provider displays a MediaRouteButton media route button
/// in the application's ActionBar to allow the user to select routes and
/// to control the currently selected route.
///
/// The application must specify the kinds of routes that the user should be allowed
/// to select by specifying the route types with the \#setRouteTypes method.
///
///
/// Refer to MediaRouteButton for a description of the button that will
/// appear in the action bar menu.  Note that instead of disabling the button
/// when no routes are available, the action provider will instead make the
/// menu item invisible.  In this way, the button will only be visible when it
/// is possible for the user to discover and select a matching route.
///
///
class MediaRouteActionProvider extends jni.JniObject {
  MediaRouteActionProvider.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("MediaRouteActionProvider__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  MediaRouteActionProvider(content_.Context context)
      : super.fromRef(_ctor(context.reference).object);

  static final _setRouteTypes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("MediaRouteActionProvider__setRouteTypes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setRouteTypes(int types)
  ///
  /// Sets the types of routes that will be shown in the media route chooser dialog
  /// launched by this button.
  ///@param types The route types to match.
  void setRouteTypes(int types) => _setRouteTypes(reference, types).check();

  static final _setExtendedSettingsClickListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "MediaRouteActionProvider__setExtendedSettingsClickListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExtendedSettingsClickListener(android.view.View.OnClickListener listener)
  void setExtendedSettingsClickListener(jni.JniObject listener) =>
      _setExtendedSettingsClickListener(reference, listener.reference).check();

  static final _onCreateActionView = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "MediaRouteActionProvider__onCreateActionView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View onCreateActionView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject onCreateActionView() =>
      jni.JniObject.fromRef(_onCreateActionView(reference).object);

  static final _onCreateActionView1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "MediaRouteActionProvider__onCreateActionView1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View onCreateActionView(android.view.MenuItem item)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject onCreateActionView1(jni.JniObject item) =>
      jni.JniObject.fromRef(
          _onCreateActionView1(reference, item.reference).object);

  static final _onPerformDefaultAction = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "MediaRouteActionProvider__onPerformDefaultAction")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onPerformDefaultAction()
  bool onPerformDefaultAction() => _onPerformDefaultAction(reference).boolean;

  static final _overridesItemVisibility = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "MediaRouteActionProvider__overridesItemVisibility")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean overridesItemVisibility()
  bool overridesItemVisibility() => _overridesItemVisibility(reference).boolean;

  static final _isVisible = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "MediaRouteActionProvider__isVisible")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isVisible()
  bool isVisible() => _isVisible(reference).boolean;
}

/// from: android.app.MediaRouteButton
class MediaRouteButton extends jni.JniObject {
  MediaRouteButton.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("MediaRouteButton__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  MediaRouteButton(content_.Context context)
      : super.fromRef(_ctor(context.reference).object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("MediaRouteButton__ctor1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs)
  MediaRouteButton.ctor1(content_.Context context, jni.JniObject attrs)
      : super.fromRef(_ctor1(context.reference, attrs.reference).object);

  static final _ctor2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("MediaRouteButton__ctor2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr)
  MediaRouteButton.ctor2(
      content_.Context context, jni.JniObject attrs, int defStyleAttr)
      : super.fromRef(
            _ctor2(context.reference, attrs.reference, defStyleAttr).object);

  static final _ctor3 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32)>>("MediaRouteButton__ctor3")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void <init>(android.content.Context context, android.util.AttributeSet attrs, int defStyleAttr, int defStyleRes)
  MediaRouteButton.ctor3(content_.Context context, jni.JniObject attrs,
      int defStyleAttr, int defStyleRes)
      : super.fromRef(_ctor3(
                context.reference, attrs.reference, defStyleAttr, defStyleRes)
            .object);

  static final _getRouteTypes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("MediaRouteButton__getRouteTypes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getRouteTypes()
  ///
  /// Gets the media route types for filtering the routes that the user can
  /// select using the media route chooser dialog.
  ///@return The route types.
  int getRouteTypes() => _getRouteTypes(reference).integer;

  static final _setRouteTypes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("MediaRouteButton__setRouteTypes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setRouteTypes(int types)
  ///
  /// Sets the types of routes that will be shown in the media route chooser dialog
  /// launched by this button.
  ///@param types The route types to match.
  void setRouteTypes(int types) => _setRouteTypes(reference, types).check();

  static final _setExtendedSettingsClickListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "MediaRouteButton__setExtendedSettingsClickListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExtendedSettingsClickListener(android.view.View.OnClickListener listener)
  void setExtendedSettingsClickListener(jni.JniObject listener) =>
      _setExtendedSettingsClickListener(reference, listener.reference).check();

  static final _showDialog = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("MediaRouteButton__showDialog")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void showDialog()
  ///
  /// Show the route chooser or controller dialog.
  ///
  /// If the default route is selected or if the currently selected route does
  /// not match the \#getRouteTypes route types, then shows the route chooser dialog.
  /// Otherwise, shows the route controller dialog to offer the user
  /// a choice to disconnect from the route or perform other control actions
  /// such as setting the route's volume.
  ///
  ///
  /// This will attach a DialogFragment to the containing Activity.
  ///
  ///
  void showDialog() => _showDialog(reference).check();

  static final _setContentDescription = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "MediaRouteButton__setContentDescription")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setContentDescription(java.lang.CharSequence contentDescription)
  void setContentDescription(jni.JniObject contentDescription) =>
      _setContentDescription(reference, contentDescription.reference).check();

  static final _performClick = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("MediaRouteButton__performClick")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean performClick()
  bool performClick() => _performClick(reference).boolean;

  static final _onCreateDrawableState = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("MediaRouteButton__onCreateDrawableState")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: protected int[] onCreateDrawableState(int extraSpace)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject onCreateDrawableState(int extraSpace) => jni.JniObject.fromRef(
      _onCreateDrawableState(reference, extraSpace).object);

  static final _drawableStateChanged = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "MediaRouteButton__drawableStateChanged")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void drawableStateChanged()
  void drawableStateChanged() => _drawableStateChanged(reference).check();

  static final _verifyDrawable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("MediaRouteButton__verifyDrawable")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected boolean verifyDrawable(android.graphics.drawable.Drawable who)
  ///
  /// @param who This value must never be {@code null}.
  bool verifyDrawable(jni.JniObject who) =>
      _verifyDrawable(reference, who.reference).boolean;

  static final _jumpDrawablesToCurrentState = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "MediaRouteButton__jumpDrawablesToCurrentState")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void jumpDrawablesToCurrentState()
  void jumpDrawablesToCurrentState() =>
      _jumpDrawablesToCurrentState(reference).check();

  static final _setVisibility = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("MediaRouteButton__setVisibility")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setVisibility(int visibility)
  void setVisibility(int visibility) =>
      _setVisibility(reference, visibility).check();

  static final _onAttachedToWindow = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "MediaRouteButton__onAttachedToWindow")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttachedToWindow()
  void onAttachedToWindow() => _onAttachedToWindow(reference).check();

  static final _onDetachedFromWindow = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "MediaRouteButton__onDetachedFromWindow")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDetachedFromWindow()
  void onDetachedFromWindow() => _onDetachedFromWindow(reference).check();

  static final _onMeasure = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("MediaRouteButton__onMeasure")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
  void onMeasure(int widthMeasureSpec, int heightMeasureSpec) =>
      _onMeasure(reference, widthMeasureSpec, heightMeasureSpec).check();

  static final _onDraw = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("MediaRouteButton__onDraw")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onDraw(android.graphics.Canvas canvas)
  void onDraw(jni.JniObject canvas) =>
      _onDraw(reference, canvas.reference).check();
}

/// from: android.app.NativeActivity
///
/// Convenience for implementing an activity that will be implemented
/// purely in native code.  That is, a game (or game-like thing).  There
/// is no need to derive from this class; you can simply declare it in your
/// manifest, and use the NDK APIs from there.
///
/// A <a href="https://github.com/googlesamples/android-ndk/tree/master/native-activity">sample
/// native activity</a> is available in the NDK samples.
class NativeActivity extends Activity {
  NativeActivity.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String META_DATA_FUNC_NAME
  ///
  /// Optional meta-that can be in the manifest for this component, specifying
  /// the name of the main entry point for this native activity in the
  /// \#META_DATA_LIB_NAME native code.  If not specified,
  /// "ANativeActivity_onCreate" is used.
  static const META_DATA_FUNC_NAME = "android.app.func_name";

  /// from: static public final java.lang.String META_DATA_LIB_NAME
  ///
  /// Optional meta-that can be in the manifest for this component, specifying
  /// the name of the native shared library to load.  If not specified,
  /// "main" is used.
  static const META_DATA_LIB_NAME = "android.app.lib_name";

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "NativeActivity__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  NativeActivity() : super.fromRef(_ctor().object);

  static final _onCreate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("NativeActivity__onCreate")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onCreate(android.os.Bundle savedInstanceState)
  void onCreate(os_.Bundle savedInstanceState) =>
      _onCreate(reference, savedInstanceState.reference).check();

  static final _onDestroy = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NativeActivity__onDestroy")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onDestroy()
  void onDestroy() => _onDestroy(reference).check();

  static final _onPause = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NativeActivity__onPause")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPause()
  void onPause() => _onPause(reference).check();

  static final _onResume = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NativeActivity__onResume")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onResume()
  void onResume() => _onResume(reference).check();

  static final _onSaveInstanceState = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NativeActivity__onSaveInstanceState")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onSaveInstanceState(android.os.Bundle outState)
  void onSaveInstanceState(os_.Bundle outState) =>
      _onSaveInstanceState(reference, outState.reference).check();

  static final _onStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NativeActivity__onStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStart()
  void onStart() => _onStart(reference).check();

  static final _onStop = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NativeActivity__onStop")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStop()
  void onStop() => _onStop(reference).check();

  static final _onConfigurationChanged = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NativeActivity__onConfigurationChanged")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onConfigurationChanged(android.content.res.Configuration newConfig)
  void onConfigurationChanged(res_.Configuration newConfig) =>
      _onConfigurationChanged(reference, newConfig.reference).check();

  static final _onLowMemory = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NativeActivity__onLowMemory")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onLowMemory()
  void onLowMemory() => _onLowMemory(reference).check();

  static final _onWindowFocusChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("NativeActivity__onWindowFocusChanged")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onWindowFocusChanged(boolean hasFocus)
  void onWindowFocusChanged(bool hasFocus) =>
      _onWindowFocusChanged(reference, hasFocus ? 1 : 0).check();

  static final _surfaceCreated = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("NativeActivity__surfaceCreated")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void surfaceCreated(android.view.SurfaceHolder holder)
  void surfaceCreated(jni.JniObject holder) =>
      _surfaceCreated(reference, holder.reference).check();

  static final _surfaceChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("NativeActivity__surfaceChanged")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void surfaceChanged(android.view.SurfaceHolder holder, int format, int width, int height)
  void surfaceChanged(
          jni.JniObject holder, int format, int width, int height) =>
      _surfaceChanged(reference, holder.reference, format, width, height)
          .check();

  static final _surfaceRedrawNeeded = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NativeActivity__surfaceRedrawNeeded")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void surfaceRedrawNeeded(android.view.SurfaceHolder holder)
  void surfaceRedrawNeeded(jni.JniObject holder) =>
      _surfaceRedrawNeeded(reference, holder.reference).check();

  static final _surfaceDestroyed = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("NativeActivity__surfaceDestroyed")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void surfaceDestroyed(android.view.SurfaceHolder holder)
  void surfaceDestroyed(jni.JniObject holder) =>
      _surfaceDestroyed(reference, holder.reference).check();

  static final _onInputQueueCreated = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NativeActivity__onInputQueueCreated")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onInputQueueCreated(android.view.InputQueue queue)
  void onInputQueueCreated(jni.JniObject queue) =>
      _onInputQueueCreated(reference, queue.reference).check();

  static final _onInputQueueDestroyed = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NativeActivity__onInputQueueDestroyed")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onInputQueueDestroyed(android.view.InputQueue queue)
  void onInputQueueDestroyed(jni.JniObject queue) =>
      _onInputQueueDestroyed(reference, queue.reference).check();

  static final _onGlobalLayout = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NativeActivity__onGlobalLayout")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onGlobalLayout()
  void onGlobalLayout() => _onGlobalLayout(reference).check();
}

/// from: android.app.Notification
///
/// A class that represents how a persistent notification is to be presented to
/// the user using the android.app.NotificationManager.
///
/// The Notification.Builder Notification.Builder has been added to make it
/// easier to construct Notifications.
///
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For a guide to creating notifications, read the
/// <a href="{@docRoot}guide/topics/ui/notifiers/notifications.html">Status Bar Notifications</a>
/// developer guide.
///
/// </div>
class Notification extends jni.JniObject {
  Notification.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_AUDIO_ATTRIBUTES_DEFAULT =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Notification__AUDIO_ATTRIBUTES_DEFAULT")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.media.AudioAttributes AUDIO_ATTRIBUTES_DEFAULT
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The default value of \#audioAttributes.
  static jni.JniObject get AUDIO_ATTRIBUTES_DEFAULT =>
      jni.JniObject.fromRef(_get_AUDIO_ATTRIBUTES_DEFAULT().object);

  /// from: static public final int BADGE_ICON_LARGE
  ///
  /// If this notification is being shown as a badge, use the \#getLargeIcon() to
  /// represent this notification.
  static const BADGE_ICON_LARGE = 2;

  /// from: static public final int BADGE_ICON_NONE
  ///
  /// If this notification is being shown as a badge, always show as a number.
  static const BADGE_ICON_NONE = 0;

  /// from: static public final int BADGE_ICON_SMALL
  ///
  /// If this notification is being shown as a badge, use the \#getSmallIcon() to
  /// represent this notification.
  static const BADGE_ICON_SMALL = 1;

  /// from: static public final java.lang.String CATEGORY_ALARM
  ///
  /// Notification category: alarm or timer.
  static const CATEGORY_ALARM = "alarm";

  /// from: static public final java.lang.String CATEGORY_CALL
  ///
  /// Notification category: incoming call (voice or video) or similar synchronous communication request.
  static const CATEGORY_CALL = "call";

  /// from: static public final java.lang.String CATEGORY_EMAIL
  ///
  /// Notification category: asynchronous bulk message (email).
  static const CATEGORY_EMAIL = "email";

  /// from: static public final java.lang.String CATEGORY_ERROR
  ///
  /// Notification category: error in background operation or authentication status.
  static const CATEGORY_ERROR = "err";

  /// from: static public final java.lang.String CATEGORY_EVENT
  ///
  /// Notification category: calendar event.
  static const CATEGORY_EVENT = "event";

  /// from: static public final java.lang.String CATEGORY_MESSAGE
  ///
  /// Notification category: incoming direct message (SMS, instant message, etc.).
  static const CATEGORY_MESSAGE = "msg";

  /// from: static public final java.lang.String CATEGORY_NAVIGATION
  ///
  /// Notification category: map turn-by-turn navigation.
  static const CATEGORY_NAVIGATION = "navigation";

  /// from: static public final java.lang.String CATEGORY_PROGRESS
  ///
  /// Notification category: progress of a long-running background operation.
  static const CATEGORY_PROGRESS = "progress";

  /// from: static public final java.lang.String CATEGORY_PROMO
  ///
  /// Notification category: promotion or advertisement.
  static const CATEGORY_PROMO = "promo";

  /// from: static public final java.lang.String CATEGORY_RECOMMENDATION
  ///
  /// Notification category: a specific, timely recommendation for a single thing.
  /// For example, a news app might want to recommend a news story it believes the user will
  /// want to read next.
  static const CATEGORY_RECOMMENDATION = "recommendation";

  /// from: static public final java.lang.String CATEGORY_REMINDER
  ///
  /// Notification category: user-scheduled reminder.
  static const CATEGORY_REMINDER = "reminder";

  /// from: static public final java.lang.String CATEGORY_SERVICE
  ///
  /// Notification category: indication of running background service.
  static const CATEGORY_SERVICE = "service";

  /// from: static public final java.lang.String CATEGORY_SOCIAL
  ///
  /// Notification category: social network or sharing update.
  static const CATEGORY_SOCIAL = "social";

  /// from: static public final java.lang.String CATEGORY_STATUS
  ///
  /// Notification category: ongoing information about device or contextual status.
  static const CATEGORY_STATUS = "status";

  /// from: static public final java.lang.String CATEGORY_SYSTEM
  ///
  /// Notification category: system or device status update.  Reserved for system use.
  static const CATEGORY_SYSTEM = "sys";

  /// from: static public final java.lang.String CATEGORY_TRANSPORT
  ///
  /// Notification category: media transport control for playback.
  static const CATEGORY_TRANSPORT = "transport";

  /// from: static public final int COLOR_DEFAULT
  ///
  /// Special value of \#color telling the system not to decorate this notification with
  /// any special color but instead use default colors when presenting this notification.
  static const COLOR_DEFAULT = 0;

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Notification__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.Notification> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Parcelable.Creator that instantiates Notification objects
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  /// from: static public final int DEFAULT_ALL
  ///
  /// Use all default values (where applicable).
  static const DEFAULT_ALL = -1;

  /// from: static public final int DEFAULT_LIGHTS
  ///
  /// Use the default notification lights. This will ignore the
  /// \#FLAG_SHOW_LIGHTS bit, and \#ledARGB, \#ledOffMS, or
  /// \#ledOnMS.
  ///@see \#defaults
  static const DEFAULT_LIGHTS = 4;

  /// from: static public final int DEFAULT_SOUND
  ///
  /// Use the default notification sound. This will ignore any given
  /// \#sound.
  ///
  ///
  /// A notification that is noisy is more likely to be presented as a heads-up notification.
  ///
  ///
  ///@see \#defaults
  static const DEFAULT_SOUND = 1;

  /// from: static public final int DEFAULT_VIBRATE
  ///
  /// Use the default notification vibrate. This will ignore any given
  /// \#vibrate. Using phone vibration requires the
  /// android.Manifest.permission\#VIBRATE VIBRATE permission.
  ///
  ///
  /// A notification that vibrates is more likely to be presented as a heads-up notification.
  ///
  ///
  ///@see \#defaults
  static const DEFAULT_VIBRATE = 2;

  /// from: static public final java.lang.String EXTRA_AUDIO_CONTENTS_URI
  ///
  /// \#extras key: the audio contents of this notification.
  ///
  /// This is for use when rendering the notification on an audio-focused interface;
  /// the audio contents are a complete sound sample that contains the contents/body of the
  /// notification. This may be used in substitute of a Text-to-Speech reading of the
  /// notification. For example if the notification represents a voice message this should point
  /// to the audio of that message.
  ///
  /// The data stored under this key should be a String representation of a Uri that contains the
  /// audio contents in one of the following formats: WAV, PCM 16-bit, AMR-WB.
  ///
  /// This extra is unnecessary if you are using {@code MessagingStyle} since each {@code Message}
  /// has a field for holding data URI. That field can be used for audio.
  /// See {@code Message\#setData}.
  ///
  /// Example usage:
  /// <pre>
  /// {@code
  /// Notification.Builder myBuilder = (build your Notification as normal);
  /// myBuilder.getExtras().putString(EXTRA_AUDIO_CONTENTS_URI, myAudioUri.toString());
  /// }
  /// </pre>
  static const EXTRA_AUDIO_CONTENTS_URI = "android.audioContents";

  /// from: static public final java.lang.String EXTRA_BACKGROUND_IMAGE_URI
  ///
  /// \#extras key: A
  /// android.content.ContentUris content URI pointing to an image that can be displayed
  /// in the background when the notification is selected. Used on television platforms.
  /// The URI must point to an image stream suitable for passing into
  /// android.graphics.BitmapFactory\#decodeStream(java.io.InputStream) BitmapFactory.decodeStream; all other content types will be ignored.
  static const EXTRA_BACKGROUND_IMAGE_URI = "android.backgroundImageUri";

  /// from: static public final java.lang.String EXTRA_BIG_TEXT
  ///
  /// \#extras key: this is the longer text shown in the big form of a
  /// BigTextStyle notification, as supplied to
  /// BigTextStyle\#bigText(CharSequence).
  static const EXTRA_BIG_TEXT = "android.bigText";

  /// from: static public final java.lang.String EXTRA_CHANNEL_GROUP_ID
  ///
  /// Optional extra for \#INTENT_CATEGORY_NOTIFICATION_PREFERENCES. If provided, will
  /// contain a NotificationChannelGroup\#getId() group id that can be used to narrow down
  /// what settings should be shown in the target app.
  static const EXTRA_CHANNEL_GROUP_ID = "android.intent.extra.CHANNEL_GROUP_ID";

  /// from: static public final java.lang.String EXTRA_CHANNEL_ID
  ///
  /// Optional extra for \#INTENT_CATEGORY_NOTIFICATION_PREFERENCES. If provided, will
  /// contain a NotificationChannel\#getId() channel id that can be used to narrow down
  /// what settings should be shown in the target app.
  static const EXTRA_CHANNEL_ID = "android.intent.extra.CHANNEL_ID";

  /// from: static public final java.lang.String EXTRA_CHRONOMETER_COUNT_DOWN
  ///
  /// \#extras key: whether the chronometer set on the notification should count down
  /// instead of counting up. Is only relevant if key \#EXTRA_SHOW_CHRONOMETER is present.
  /// This extra is a boolean. The default is false.
  static const EXTRA_CHRONOMETER_COUNT_DOWN = "android.chronometerCountDown";

  /// from: static public final java.lang.String EXTRA_COLORIZED
  ///
  /// \#extras key: whether the notification should be colorized as
  /// supplied to Builder\#setColorized(boolean)}.
  static const EXTRA_COLORIZED = "android.colorized";

  /// from: static public final java.lang.String EXTRA_COMPACT_ACTIONS
  ///
  /// \#extras key: the indices of actions to be shown in the compact view,
  /// as supplied to (e.g.) MediaStyle\#setShowActionsInCompactView(int...).
  static const EXTRA_COMPACT_ACTIONS = "android.compactActions";

  /// from: static public final java.lang.String EXTRA_CONVERSATION_TITLE
  ///
  /// \#extras key: a CharSequence to be displayed as the title to a conversation
  /// represented by a android.app.Notification.MessagingStyle
  static const EXTRA_CONVERSATION_TITLE = "android.conversationTitle";

  /// from: static public final java.lang.String EXTRA_HISTORIC_MESSAGES
  ///
  /// \#extras key: an array of
  /// android.app.Notification.MessagingStyle\#addHistoricMessage historic
  /// android.app.Notification.MessagingStyle.Message bundles provided by a
  /// android.app.Notification.MessagingStyle notification. This extra is a parcelable
  /// array of bundles.
  static const EXTRA_HISTORIC_MESSAGES = "android.messages.historic";

  /// from: static public final java.lang.String EXTRA_INFO_TEXT
  ///
  /// \#extras key: this is a small piece of additional text as supplied to
  /// Builder\#setContentInfo(CharSequence).
  static const EXTRA_INFO_TEXT = "android.infoText";

  /// from: static public final java.lang.String EXTRA_IS_GROUP_CONVERSATION
  ///
  /// \#extras key: whether the android.app.Notification.MessagingStyle notification
  /// represents a group conversation.
  static const EXTRA_IS_GROUP_CONVERSATION = "android.isGroupConversation";

  /// from: static public final java.lang.String EXTRA_LARGE_ICON
  ///
  /// \#extras key: this is a bitmap to be used instead of the small icon when showing the
  /// notification payload, as
  /// supplied to Builder\#setLargeIcon(android.graphics.Bitmap).
  ///@deprecated Use \#getLargeIcon(), which supports a wider variety of icon sources.
  static const EXTRA_LARGE_ICON = "android.largeIcon";

  /// from: static public final java.lang.String EXTRA_LARGE_ICON_BIG
  ///
  /// \#extras key: this is a bitmap to be used instead of the one from
  /// Builder\#setLargeIcon(android.graphics.Bitmap) when the notification is
  /// shown in its expanded form, as supplied to
  /// BigPictureStyle\#bigLargeIcon(android.graphics.Bitmap).
  static const EXTRA_LARGE_ICON_BIG = "android.largeIcon.big";

  /// from: static public final java.lang.String EXTRA_MEDIA_SESSION
  ///
  /// \#extras key: A
  /// android.media.session.MediaSession.Token associated with a
  /// android.app.Notification.MediaStyle notification.
  static const EXTRA_MEDIA_SESSION = "android.mediaSession";

  /// from: static public final java.lang.String EXTRA_MESSAGES
  ///
  /// \#extras key: an array of android.app.Notification.MessagingStyle.Message
  /// bundles provided by a
  /// android.app.Notification.MessagingStyle notification. This extra is a parcelable
  /// array of bundles.
  static const EXTRA_MESSAGES = "android.messages";

  /// from: static public final java.lang.String EXTRA_MESSAGING_PERSON
  ///
  /// \#extras key: the person to be displayed for all messages sent by the user including
  /// direct replies
  /// android.app.Notification.MessagingStyle notification. This extra is a
  /// Person
  static const EXTRA_MESSAGING_PERSON = "android.messagingUser";

  /// from: static public final java.lang.String EXTRA_NOTIFICATION_ID
  ///
  /// Optional extra for \#INTENT_CATEGORY_NOTIFICATION_PREFERENCES. If provided, will
  /// contain the id provided to NotificationManager\#notify(String, int, Notification)
  /// that can be used to narrow down what settings should be shown in the target app.
  static const EXTRA_NOTIFICATION_ID = "android.intent.extra.NOTIFICATION_ID";

  /// from: static public final java.lang.String EXTRA_NOTIFICATION_TAG
  ///
  /// Optional extra for \#INTENT_CATEGORY_NOTIFICATION_PREFERENCES. If provided, will
  /// contain the tag provided to NotificationManager\#notify(String, int, Notification)
  /// that can be used to narrow down what settings should be shown in the target app.
  static const EXTRA_NOTIFICATION_TAG = "android.intent.extra.NOTIFICATION_TAG";

  /// from: static public final java.lang.String EXTRA_PEOPLE
  ///
  /// \#extras key: A String array containing the people that this notification relates to,
  /// each of which was supplied to Builder\#addPerson(String).
  ///@deprecated the actual objects are now in \#EXTRA_PEOPLE_LIST
  static const EXTRA_PEOPLE = "android.people";

  /// from: static public final java.lang.String EXTRA_PEOPLE_LIST
  ///
  /// \#extras key: An arrayList of Person objects containing the people that
  /// this notification relates to.
  static const EXTRA_PEOPLE_LIST = "android.people.list";

  /// from: static public final java.lang.String EXTRA_PICTURE
  ///
  /// \#extras key: this is a bitmap to be shown in BigPictureStyle expanded
  /// notifications, supplied to BigPictureStyle\#bigPicture(android.graphics.Bitmap).
  static const EXTRA_PICTURE = "android.picture";

  /// from: static public final java.lang.String EXTRA_PROGRESS
  ///
  /// \#extras key: this is the progress value supplied to
  /// Builder\#setProgress(int, int, boolean).
  static const EXTRA_PROGRESS = "android.progress";

  /// from: static public final java.lang.String EXTRA_PROGRESS_INDETERMINATE
  ///
  /// \#extras key: whether the progress bar is indeterminate, supplied to
  /// Builder\#setProgress(int, int, boolean).
  static const EXTRA_PROGRESS_INDETERMINATE = "android.progressIndeterminate";

  /// from: static public final java.lang.String EXTRA_PROGRESS_MAX
  ///
  /// \#extras key: this is the maximum value supplied to
  /// Builder\#setProgress(int, int, boolean).
  static const EXTRA_PROGRESS_MAX = "android.progressMax";

  /// from: static public final java.lang.String EXTRA_REMOTE_INPUT_DRAFT
  ///
  /// If the notification contained an unsent draft for a RemoteInput when the user clicked on it,
  /// we're adding the draft as a String extra to the \#contentIntent using this key.
  ///
  /// Apps may use this extra to prepopulate text fields in the app, where the user usually
  /// sends messages.
  ///
  static const EXTRA_REMOTE_INPUT_DRAFT = "android.remoteInputDraft";

  /// from: static public final java.lang.String EXTRA_REMOTE_INPUT_HISTORY
  ///
  /// \#extras key: this is the remote input history, as supplied to
  /// Builder\#setRemoteInputHistory(CharSequence[]).
  ///
  /// Apps can fill this through Builder\#setRemoteInputHistory(CharSequence[])
  /// with the most recent inputs that have been sent through a RemoteInput of this
  /// Notification and are expected to clear it once the it is no longer relevant (e.g. for chat
  /// notifications once the other party has responded).
  ///
  /// The extra with this key is of type CharSequence[] and contains the most recent entry at
  /// the 0 index, the second most recent at the 1 index, etc.
  ///@see Builder\#setRemoteInputHistory(CharSequence[])
  static const EXTRA_REMOTE_INPUT_HISTORY = "android.remoteInputHistory";

  /// from: static public final java.lang.String EXTRA_SELF_DISPLAY_NAME
  ///
  /// \#extras key: the username to be displayed for all messages sent by the user including
  /// direct replies
  /// android.app.Notification.MessagingStyle notification. This extra is a
  /// CharSequence
  ///@deprecated use \#EXTRA_MESSAGING_PERSON
  static const EXTRA_SELF_DISPLAY_NAME = "android.selfDisplayName";

  /// from: static public final java.lang.String EXTRA_SHOW_CHRONOMETER
  ///
  /// \#extras key: whether \#when should be shown as a count-up timer (specifically
  /// a android.widget.Chronometer) instead of a timestamp, as supplied to
  /// Builder\#setUsesChronometer(boolean).
  static const EXTRA_SHOW_CHRONOMETER = "android.showChronometer";

  /// from: static public final java.lang.String EXTRA_SHOW_WHEN
  ///
  /// \#extras key: whether \#when should be shown,
  /// as supplied to Builder\#setShowWhen(boolean).
  static const EXTRA_SHOW_WHEN = "android.showWhen";

  /// from: static public final java.lang.String EXTRA_SMALL_ICON
  ///
  /// \#extras key: this is the resource ID of the notification's main small icon, as
  /// supplied to Builder\#setSmallIcon(int).
  ///@deprecated Use \#getSmallIcon(), which supports a wider variety of icon sources.
  static const EXTRA_SMALL_ICON = "android.icon";

  /// from: static public final java.lang.String EXTRA_SUB_TEXT
  ///
  /// \#extras key: this is a third line of text, as supplied to
  /// Builder\#setSubText(CharSequence).
  static const EXTRA_SUB_TEXT = "android.subText";

  /// from: static public final java.lang.String EXTRA_SUMMARY_TEXT
  ///
  /// \#extras key: this is a line of summary information intended to be shown
  /// alongside expanded notifications, as supplied to (e.g.)
  /// BigTextStyle\#setSummaryText(CharSequence).
  static const EXTRA_SUMMARY_TEXT = "android.summaryText";

  /// from: static public final java.lang.String EXTRA_TEMPLATE
  ///
  /// \#extras key: A string representing the name of the specific
  /// android.app.Notification.Style used to create this notification.
  static const EXTRA_TEMPLATE = "android.template";

  /// from: static public final java.lang.String EXTRA_TEXT
  ///
  /// \#extras key: this is the main text payload, as supplied to
  /// Builder\#setContentText(CharSequence).
  static const EXTRA_TEXT = "android.text";

  /// from: static public final java.lang.String EXTRA_TEXT_LINES
  ///
  /// \#extras key: An array of CharSequences to show in InboxStyle expanded
  /// notifications, each of which was supplied to InboxStyle\#addLine(CharSequence).
  static const EXTRA_TEXT_LINES = "android.textLines";

  /// from: static public final java.lang.String EXTRA_TITLE
  ///
  /// \#extras key: this is the title of the notification,
  /// as supplied to Builder\#setContentTitle(CharSequence).
  static const EXTRA_TITLE = "android.title";

  /// from: static public final java.lang.String EXTRA_TITLE_BIG
  ///
  /// \#extras key: this is the title of the notification when shown in expanded form,
  /// e.g.&nbsp;as supplied to BigTextStyle\#setBigContentTitle(CharSequence).
  static const EXTRA_TITLE_BIG = "android.title.big";

  /// from: static public final int FLAG_AUTO_CANCEL
  ///
  /// Bit to be bitwise-ored into the \#flags field that should be
  /// set if the notification should be canceled when it is clicked by the
  /// user.
  static const FLAG_AUTO_CANCEL = 16;

  /// from: static public final int FLAG_FOREGROUND_SERVICE
  ///
  /// Bit to be bitwise-ored into the \#flags field that should be
  /// set if this notification represents a currently running service.  This
  /// will normally be set for you by Service\#startForeground.
  static const FLAG_FOREGROUND_SERVICE = 64;

  /// from: static public final int FLAG_GROUP_SUMMARY
  ///
  /// Bit to be bitswise-ored into the \#flags field that should be
  /// set if this notification is the group summary for a group of notifications.
  /// Grouped notifications may display in a cluster or stack on devices which
  /// support such rendering. Requires a group key also be set using Builder\#setGroup.
  static const FLAG_GROUP_SUMMARY = 512;

  /// from: static public final int FLAG_HIGH_PRIORITY
  ///
  /// Obsolete flag indicating high-priority notifications; use the priority field instead.
  ///@deprecated Use \#priority with a positive value.
  static const FLAG_HIGH_PRIORITY = 128;

  /// from: static public final int FLAG_INSISTENT
  ///
  /// Bit to be bitwise-ored into the \#flags field that if set,
  /// the audio will be repeated until the notification is
  /// cancelled or the notification window is opened.
  static const FLAG_INSISTENT = 4;

  /// from: static public final int FLAG_LOCAL_ONLY
  ///
  /// Bit to be bitswise-ored into the \#flags field that should be
  /// set if this notification is relevant to the current device only
  /// and it is not recommended that it bridge to other devices.
  static const FLAG_LOCAL_ONLY = 256;

  /// from: static public final int FLAG_NO_CLEAR
  ///
  /// Bit to be bitwise-ored into the \#flags field that should be
  /// set if the notification should not be canceled when the user clicks
  /// the Clear all button.
  static const FLAG_NO_CLEAR = 32;

  /// from: static public final int FLAG_ONGOING_EVENT
  ///
  /// Bit to be bitwise-ored into the \#flags field that should be
  /// set if this notification is in reference to something that is ongoing,
  /// like a phone call.  It should not be set if this notification is in
  /// reference to something that happened at a particular point in time,
  /// like a missed phone call.
  static const FLAG_ONGOING_EVENT = 2;

  /// from: static public final int FLAG_ONLY_ALERT_ONCE
  ///
  /// Bit to be bitwise-ored into the \#flags field that should be
  /// set if you would only like the sound, vibrate and ticker to be played
  /// if the notification was not already showing.
  static const FLAG_ONLY_ALERT_ONCE = 8;

  /// from: static public final int FLAG_SHOW_LIGHTS
  ///
  /// Bit to be bitwise-ored into the \#flags field that should be
  /// set if you want the LED on for this notification.
  /// <ul>
  /// <li>To turn the LED off, pass 0 in the alpha channel for colorARGB
  ///      or 0 for both ledOnMS and ledOffMS.</li>
  /// <li>To turn the LED on, pass 1 for ledOnMS and 0 for ledOffMS.</li>
  /// <li>To flash the LED, pass the number of milliseconds that it should
  ///      be on and off to ledOnMS and ledOffMS.</li>
  /// </ul>
  ///
  /// Since hardware varies, you are not guaranteed that any of the values
  /// you pass are honored exactly.  Use the system defaults if possible
  /// because they will be set to values that work on any given hardware.
  ///
  /// The alpha channel must be set for forward compatibility.
  ///@deprecated use NotificationChannel\#shouldShowLights().
  static const FLAG_SHOW_LIGHTS = 1;

  /// from: static public final int GROUP_ALERT_ALL
  ///
  /// Constant for Builder\#setGroupAlertBehavior(int), meaning that all notifications in a
  /// group with sound or vibration ought to make sound or vibrate (respectively), so this
  /// notification will not be muted when it is in a group.
  static const GROUP_ALERT_ALL = 0;

  /// from: static public final int GROUP_ALERT_CHILDREN
  ///
  /// Constant for Builder\#setGroupAlertBehavior(int), meaning that the summary
  /// notification in a group should be silenced (no sound or vibration) even if they are
  /// posted to a NotificationChannel that has sound and/or vibration. Use this constant
  /// to mute this notification if this notification is a group summary.
  ///
  /// For example, you might want to use this constant if only the children notifications
  /// in your group have content and the summary is only used to visually group notifications
  /// rather than to alert the user that new information is available.
  static const GROUP_ALERT_CHILDREN = 2;

  /// from: static public final int GROUP_ALERT_SUMMARY
  ///
  /// Constant for Builder\#setGroupAlertBehavior(int), meaning that all children
  /// notification in a group should be silenced (no sound or vibration) even if they are posted
  /// to a NotificationChannel that has sound and/or vibration. Use this constant to
  /// mute this notification if this notification is a group child. This must be applied to all
  /// children notifications you want to mute.
  ///
  ///  For example, you might want to use this constant if you post a number of children
  /// notifications at once (say, after a periodic sync), and only need to notify the user
  /// audibly once.
  static const GROUP_ALERT_SUMMARY = 1;

  /// from: static public final java.lang.String INTENT_CATEGORY_NOTIFICATION_PREFERENCES
  ///
  /// An activity that provides a user interface for adjusting notification preferences for its
  /// containing application.
  static const INTENT_CATEGORY_NOTIFICATION_PREFERENCES =
      "android.intent.category.NOTIFICATION_PREFERENCES";

  /// from: static public final int PRIORITY_DEFAULT
  ///
  /// Default notification \#priority. If your application does not prioritize its own
  /// notifications, use this value for all notifications.
  ///@deprecated use NotificationManager\#IMPORTANCE_DEFAULT instead.
  static const PRIORITY_DEFAULT = 0;

  /// from: static public final int PRIORITY_HIGH
  ///
  /// Higher \#priority, for more important notifications or alerts. The UI may choose to
  /// show these items larger, or at a different position in notification lists, compared with
  /// your app's \#PRIORITY_DEFAULT items.
  ///@deprecated use NotificationManager\#IMPORTANCE_HIGH instead.
  static const PRIORITY_HIGH = 1;

  /// from: static public final int PRIORITY_LOW
  ///
  /// Lower \#priority, for items that are less important. The UI may choose to show these
  /// items smaller, or at a different position in the list, compared with your app's
  /// \#PRIORITY_DEFAULT items.
  ///@deprecated use NotificationManager\#IMPORTANCE_LOW instead.
  static const PRIORITY_LOW = -1;

  /// from: static public final int PRIORITY_MAX
  ///
  /// Highest \#priority, for your application's most important items that require the
  /// user's prompt attention or input.
  ///@deprecated use NotificationManager\#IMPORTANCE_HIGH instead.
  static const PRIORITY_MAX = 2;

  /// from: static public final int PRIORITY_MIN
  ///
  /// Lowest \#priority; these items might not be shown to the user except under special
  /// circumstances, such as detailed notification logs.
  ///@deprecated use NotificationManager\#IMPORTANCE_MIN instead.
  static const PRIORITY_MIN = -2;

  /// from: static public final int STREAM_DEFAULT
  ///
  /// Use this constant as the value for audioStreamType to request that
  /// the default stream type for notifications be used.  Currently the
  /// default stream type is AudioManager\#STREAM_NOTIFICATION.
  ///@deprecated Use NotificationChannel\#getAudioAttributes() instead.
  static const STREAM_DEFAULT = -1;

  /// from: static public final int VISIBILITY_PRIVATE
  ///
  /// Notification visibility: Show this notification on all lockscreens, but conceal sensitive or
  /// private information on secure lockscreens.
  ///
  /// {@see \#visibility}
  static const VISIBILITY_PRIVATE = 0;

  /// from: static public final int VISIBILITY_PUBLIC
  ///
  /// Notification visibility: Show this notification in its entirety on all lockscreens.
  ///
  /// {@see \#visibility}
  static const VISIBILITY_PUBLIC = 1;

  /// from: static public final int VISIBILITY_SECRET
  ///
  /// Notification visibility: Do not reveal any part of this notification on a secure lockscreen.
  ///
  /// {@see \#visibility}
  static const VISIBILITY_SECRET = -1;

  static final _get_actions = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__actions")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.app.Notification.Action[] actions
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Array of all Action structures attached to this notification by
  /// Builder\#addAction(int, CharSequence, PendingIntent). Mostly useful for instances of
  /// android.service.notification.NotificationListenerService that provide an alternative
  /// interface for invoking actions.
  jni.JniObject get actions =>
      jni.JniObject.fromRef(_get_actions(reference).object);
  static final _set_actions = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_Notification__actions")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action[] actions
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Array of all Action structures attached to this notification by
  /// Builder\#addAction(int, CharSequence, PendingIntent). Mostly useful for instances of
  /// android.service.notification.NotificationListenerService that provide an alternative
  /// interface for invoking actions.
  set actions(jni.JniObject value) => _set_actions(reference, value.reference);

  static final _get_audioAttributes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__audioAttributes")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.media.AudioAttributes audioAttributes
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The AudioAttributes audio attributes to use when playing the sound.
  ///@deprecated use NotificationChannel\#getAudioAttributes() instead.
  jni.JniObject get audioAttributes =>
      jni.JniObject.fromRef(_get_audioAttributes(reference).object);
  static final _set_audioAttributes = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_Notification__audioAttributes")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.media.AudioAttributes audioAttributes
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The AudioAttributes audio attributes to use when playing the sound.
  ///@deprecated use NotificationChannel\#getAudioAttributes() instead.
  set audioAttributes(jni.JniObject value) =>
      _set_audioAttributes(reference, value.reference);

  static final _get_audioStreamType = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__audioStreamType")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int audioStreamType
  ///
  /// The audio stream type to use when playing the sound.
  /// Should be one of the STREAM_ constants from
  /// android.media.AudioManager.
  ///@deprecated Use \#audioAttributes instead.
  int get audioStreamType => _get_audioStreamType(reference).integer;
  static final _set_audioStreamType = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Notification__audioStreamType")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int audioStreamType
  ///
  /// The audio stream type to use when playing the sound.
  /// Should be one of the STREAM_ constants from
  /// android.media.AudioManager.
  ///@deprecated Use \#audioAttributes instead.
  set audioStreamType(int value) => _set_audioStreamType(reference, value);

  static final _get_bigContentView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__bigContentView")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.widget.RemoteViews bigContentView
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A large-format version of \#contentView, giving the Notification an
  /// opportunity to show more detail. The system UI may choose to show this
  /// instead of the normal content view at its discretion.
  ///
  /// As of N, this field may be null. The expanded notification view is determined by the
  /// inputs to Notification.Builder; a custom RemoteViews can optionally be
  /// supplied with Notification.Builder\#setCustomBigContentView(RemoteViews).
  jni.JniObject get bigContentView =>
      jni.JniObject.fromRef(_get_bigContentView(reference).object);
  static final _set_bigContentView = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_Notification__bigContentView")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.RemoteViews bigContentView
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A large-format version of \#contentView, giving the Notification an
  /// opportunity to show more detail. The system UI may choose to show this
  /// instead of the normal content view at its discretion.
  ///
  /// As of N, this field may be null. The expanded notification view is determined by the
  /// inputs to Notification.Builder; a custom RemoteViews can optionally be
  /// supplied with Notification.Builder\#setCustomBigContentView(RemoteViews).
  set bigContentView(jni.JniObject value) =>
      _set_bigContentView(reference, value.reference);

  static final _get_category = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__category")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.String category
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// One of the predefined notification categories (see the <code>CATEGORY_*</code> constants)
  /// that best describes this Notification.  May be used by the system for ranking and filtering.
  jni.JniString get category =>
      jni.JniString.fromRef(_get_category(reference).object);
  static final _set_category = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_Notification__category")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String category
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// One of the predefined notification categories (see the <code>CATEGORY_*</code> constants)
  /// that best describes this Notification.  May be used by the system for ranking and filtering.
  set category(jni.JniString value) =>
      _set_category(reference, value.reference);

  static final _get_color = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__color")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int color
  ///
  /// Accent color (an ARGB integer like the constants in android.graphics.Color)
  /// to be applied by the standard Style templates when presenting this notification.
  ///
  /// The current template design constructs a colorful header image by overlaying the
  /// \#icon image (stenciled in white) atop a field of this color. Alpha components are
  /// ignored.
  int get color => _get_color(reference).integer;
  static final _set_color = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Notification__color")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int color
  ///
  /// Accent color (an ARGB integer like the constants in android.graphics.Color)
  /// to be applied by the standard Style templates when presenting this notification.
  ///
  /// The current template design constructs a colorful header image by overlaying the
  /// \#icon image (stenciled in white) atop a field of this color. Alpha components are
  /// ignored.
  set color(int value) => _set_color(reference, value);

  static final _get_contentIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__contentIntent")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.app.PendingIntent contentIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The intent to execute when the expanded status entry is clicked.  If
  /// this is an activity, it must include the
  /// android.content.Intent\#FLAG_ACTIVITY_NEW_TASK flag, which requires
  /// that you take care of task management as described in the
  /// <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
  /// Stack</a> document.  In particular, make sure to read the notification section
  /// <a href="{@docRoot}guide/topics/ui/notifiers/notifications.html\#HandlingNotifications">Handling
  /// Notifications</a> for the correct ways to launch an application from a
  /// notification.
  PendingIntent get contentIntent =>
      PendingIntent.fromRef(_get_contentIntent(reference).object);
  static final _set_contentIntent = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_Notification__contentIntent")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent contentIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The intent to execute when the expanded status entry is clicked.  If
  /// this is an activity, it must include the
  /// android.content.Intent\#FLAG_ACTIVITY_NEW_TASK flag, which requires
  /// that you take care of task management as described in the
  /// <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back
  /// Stack</a> document.  In particular, make sure to read the notification section
  /// <a href="{@docRoot}guide/topics/ui/notifiers/notifications.html\#HandlingNotifications">Handling
  /// Notifications</a> for the correct ways to launch an application from a
  /// notification.
  set contentIntent(PendingIntent value) =>
      _set_contentIntent(reference, value.reference);

  static final _get_contentView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__contentView")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.widget.RemoteViews contentView
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The view that will represent this notification in the notification list (which is pulled
  /// down from the status bar).
  ///
  /// As of N, this field may be null. The notification view is determined by the inputs
  /// to Notification.Builder; a custom RemoteViews can optionally be
  /// supplied with Notification.Builder\#setCustomContentView(RemoteViews).
  jni.JniObject get contentView =>
      jni.JniObject.fromRef(_get_contentView(reference).object);
  static final _set_contentView = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_Notification__contentView")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.RemoteViews contentView
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The view that will represent this notification in the notification list (which is pulled
  /// down from the status bar).
  ///
  /// As of N, this field may be null. The notification view is determined by the inputs
  /// to Notification.Builder; a custom RemoteViews can optionally be
  /// supplied with Notification.Builder\#setCustomContentView(RemoteViews).
  set contentView(jni.JniObject value) =>
      _set_contentView(reference, value.reference);

  static final _get_defaults = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__defaults")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int defaults
  ///
  /// Specifies which values should be taken from the defaults.
  ///
  /// To set, OR the desired from \#DEFAULT_SOUND,
  /// \#DEFAULT_VIBRATE, \#DEFAULT_LIGHTS. For all default
  /// values, use \#DEFAULT_ALL.
  ///
  ///
  ///@deprecated use NotificationChannel\#getSound() and
  /// NotificationChannel\#shouldShowLights() and
  /// NotificationChannel\#shouldVibrate().
  int get defaults => _get_defaults(reference).integer;
  static final _set_defaults = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Notification__defaults")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int defaults
  ///
  /// Specifies which values should be taken from the defaults.
  ///
  /// To set, OR the desired from \#DEFAULT_SOUND,
  /// \#DEFAULT_VIBRATE, \#DEFAULT_LIGHTS. For all default
  /// values, use \#DEFAULT_ALL.
  ///
  ///
  ///@deprecated use NotificationChannel\#getSound() and
  /// NotificationChannel\#shouldShowLights() and
  /// NotificationChannel\#shouldVibrate().
  set defaults(int value) => _set_defaults(reference, value);

  static final _get_deleteIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__deleteIntent")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.app.PendingIntent deleteIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The intent to execute when the notification is explicitly dismissed by the user, either with
  /// the "Clear All" button or by swiping it away individually.
  ///
  /// This probably shouldn't be launching an activity since several of those will be sent
  /// at the same time.
  PendingIntent get deleteIntent =>
      PendingIntent.fromRef(_get_deleteIntent(reference).object);
  static final _set_deleteIntent = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_Notification__deleteIntent")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent deleteIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The intent to execute when the notification is explicitly dismissed by the user, either with
  /// the "Clear All" button or by swiping it away individually.
  ///
  /// This probably shouldn't be launching an activity since several of those will be sent
  /// at the same time.
  set deleteIntent(PendingIntent value) =>
      _set_deleteIntent(reference, value.reference);

  static final _get_extras = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__extras")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.os.Bundle extras
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Additional semantic data to be carried around with this Notification.
  ///
  /// The extras keys defined here are intended to capture the original inputs to Builder
  /// APIs, and are intended to be used by
  /// android.service.notification.NotificationListenerService implementations to extract
  /// detailed information from notification objects.
  os_.Bundle get extras => os_.Bundle.fromRef(_get_extras(reference).object);
  static final _set_extras = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_Notification__extras")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle extras
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Additional semantic data to be carried around with this Notification.
  ///
  /// The extras keys defined here are intended to capture the original inputs to Builder
  /// APIs, and are intended to be used by
  /// android.service.notification.NotificationListenerService implementations to extract
  /// detailed information from notification objects.
  set extras(os_.Bundle value) => _set_extras(reference, value.reference);

  static final _get_flags = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__flags")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int flags
  int get flags => _get_flags(reference).integer;
  static final _set_flags = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Notification__flags")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int flags
  set flags(int value) => _set_flags(reference, value);

  static final _get_fullScreenIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__fullScreenIntent")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.app.PendingIntent fullScreenIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// An intent to launch instead of posting the notification to the status bar.
  ///
  ///
  /// The system UI may choose to display a heads-up notification, instead of
  /// launching this intent, while the user is using the device.
  ///
  ///
  ///@see Notification.Builder\#setFullScreenIntent
  PendingIntent get fullScreenIntent =>
      PendingIntent.fromRef(_get_fullScreenIntent(reference).object);
  static final _set_fullScreenIntent = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_Notification__fullScreenIntent")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent fullScreenIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// An intent to launch instead of posting the notification to the status bar.
  ///
  ///
  /// The system UI may choose to display a heads-up notification, instead of
  /// launching this intent, while the user is using the device.
  ///
  ///
  ///@see Notification.Builder\#setFullScreenIntent
  set fullScreenIntent(PendingIntent value) =>
      _set_fullScreenIntent(reference, value.reference);

  static final _get_headsUpContentView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__headsUpContentView")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.widget.RemoteViews headsUpContentView
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A medium-format version of \#contentView, providing the Notification an
  /// opportunity to add action buttons to contentView. At its discretion, the system UI may
  /// choose to show this as a heads-up notification, which will pop up so the user can see
  /// it without leaving their current activity.
  ///
  /// As of N, this field may be null. The heads-up notification view is determined by the
  /// inputs to Notification.Builder; a custom RemoteViews can optionally be
  /// supplied with Notification.Builder\#setCustomHeadsUpContentView(RemoteViews).
  jni.JniObject get headsUpContentView =>
      jni.JniObject.fromRef(_get_headsUpContentView(reference).object);
  static final _set_headsUpContentView = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_Notification__headsUpContentView")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.RemoteViews headsUpContentView
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A medium-format version of \#contentView, providing the Notification an
  /// opportunity to add action buttons to contentView. At its discretion, the system UI may
  /// choose to show this as a heads-up notification, which will pop up so the user can see
  /// it without leaving their current activity.
  ///
  /// As of N, this field may be null. The heads-up notification view is determined by the
  /// inputs to Notification.Builder; a custom RemoteViews can optionally be
  /// supplied with Notification.Builder\#setCustomHeadsUpContentView(RemoteViews).
  set headsUpContentView(jni.JniObject value) =>
      _set_headsUpContentView(reference, value.reference);

  static final _get_icon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__icon")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int icon
  ///
  /// The resource id of a drawable to use as the icon in the status bar.
  ///@deprecated Use Builder\#setSmallIcon(Icon) instead.
  int get icon => _get_icon(reference).integer;
  static final _set_icon = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Notification__icon")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int icon
  ///
  /// The resource id of a drawable to use as the icon in the status bar.
  ///@deprecated Use Builder\#setSmallIcon(Icon) instead.
  set icon(int value) => _set_icon(reference, value);

  static final _get_iconLevel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__iconLevel")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int iconLevel
  ///
  /// If the icon in the status bar is to have more than one level, you can set this.  Otherwise,
  /// leave it at its default value of 0.
  ///@see android.widget.ImageView\#setImageLevel
  ///@see android.graphics.drawable.Drawable\#setLevel
  int get iconLevel => _get_iconLevel(reference).integer;
  static final _set_iconLevel = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Notification__iconLevel")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int iconLevel
  ///
  /// If the icon in the status bar is to have more than one level, you can set this.  Otherwise,
  /// leave it at its default value of 0.
  ///@see android.widget.ImageView\#setImageLevel
  ///@see android.graphics.drawable.Drawable\#setLevel
  set iconLevel(int value) => _set_iconLevel(reference, value);

  static final _get_largeIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__largeIcon")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.graphics.Bitmap largeIcon
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A large bitmap to be shown in the notification content area.
  ///@deprecated Use Builder\#setLargeIcon(Icon) instead.
  jni.JniObject get largeIcon =>
      jni.JniObject.fromRef(_get_largeIcon(reference).object);
  static final _set_largeIcon = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_Notification__largeIcon")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap largeIcon
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A large bitmap to be shown in the notification content area.
  ///@deprecated Use Builder\#setLargeIcon(Icon) instead.
  set largeIcon(jni.JniObject value) =>
      _set_largeIcon(reference, value.reference);

  static final _get_ledARGB = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__ledARGB")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int ledARGB
  ///
  /// The color of the led.  The hardware will do its best approximation.
  ///@see \#FLAG_SHOW_LIGHTS
  ///@see \#flags
  ///@deprecated use NotificationChannel\#shouldShowLights().
  int get ledARGB => _get_ledARGB(reference).integer;
  static final _set_ledARGB = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Notification__ledARGB")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int ledARGB
  ///
  /// The color of the led.  The hardware will do its best approximation.
  ///@see \#FLAG_SHOW_LIGHTS
  ///@see \#flags
  ///@deprecated use NotificationChannel\#shouldShowLights().
  set ledARGB(int value) => _set_ledARGB(reference, value);

  static final _get_ledOffMS = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__ledOffMS")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int ledOffMS
  ///
  /// The number of milliseconds for the LED to be off while it's flashing.
  /// The hardware will do its best approximation.
  ///@see \#FLAG_SHOW_LIGHTS
  ///@see \#flags
  ///@deprecated use NotificationChannel\#shouldShowLights().
  int get ledOffMS => _get_ledOffMS(reference).integer;
  static final _set_ledOffMS = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Notification__ledOffMS")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int ledOffMS
  ///
  /// The number of milliseconds for the LED to be off while it's flashing.
  /// The hardware will do its best approximation.
  ///@see \#FLAG_SHOW_LIGHTS
  ///@see \#flags
  ///@deprecated use NotificationChannel\#shouldShowLights().
  set ledOffMS(int value) => _set_ledOffMS(reference, value);

  static final _get_ledOnMS = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__ledOnMS")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int ledOnMS
  ///
  /// The number of milliseconds for the LED to be on while it's flashing.
  /// The hardware will do its best approximation.
  ///@see \#FLAG_SHOW_LIGHTS
  ///@see \#flags
  ///@deprecated use NotificationChannel\#shouldShowLights().
  int get ledOnMS => _get_ledOnMS(reference).integer;
  static final _set_ledOnMS = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Notification__ledOnMS")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int ledOnMS
  ///
  /// The number of milliseconds for the LED to be on while it's flashing.
  /// The hardware will do its best approximation.
  ///@see \#FLAG_SHOW_LIGHTS
  ///@see \#flags
  ///@deprecated use NotificationChannel\#shouldShowLights().
  set ledOnMS(int value) => _set_ledOnMS(reference, value);

  static final _get_number = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__number")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int number
  ///
  /// The number of events that this notification represents. For example, in a new mail
  /// notification, this could be the number of unread messages.
  ///
  /// The system may or may not use this field to modify the appearance of the notification.
  /// Starting with android.os.Build.VERSION_CODES\#O, the number may be displayed as a
  /// badge icon in Launchers that support badging.
  int get number => _get_number(reference).integer;
  static final _set_number = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Notification__number")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int number
  ///
  /// The number of events that this notification represents. For example, in a new mail
  /// notification, this could be the number of unread messages.
  ///
  /// The system may or may not use this field to modify the appearance of the notification.
  /// Starting with android.os.Build.VERSION_CODES\#O, the number may be displayed as a
  /// badge icon in Launchers that support badging.
  set number(int value) => _set_number(reference, value);

  static final _get_priority = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__priority")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int priority
  ///
  /// Relative priority for this notification.
  ///
  /// Priority is an indication of how much of the user's valuable attention should be consumed by
  /// this notification. Low-priority notifications may be hidden from the user in certain
  /// situations, while the user might be interrupted for a higher-priority notification. The
  /// system will make a determination about how to interpret this priority when presenting
  /// the notification.
  ///
  ///
  /// A notification that is at least \#PRIORITY_HIGH is more likely to be presented
  /// as a heads-up notification.
  ///
  ///
  ///
  /// Value is android.app.Notification\#PRIORITY_DEFAULT, android.app.Notification\#PRIORITY_LOW, android.app.Notification\#PRIORITY_MIN, android.app.Notification\#PRIORITY_HIGH, or android.app.Notification\#PRIORITY_MAX
  ///@deprecated use NotificationChannel\#getImportance() instead.
  int get priority => _get_priority(reference).integer;
  static final _set_priority = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Notification__priority")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int priority
  ///
  /// Relative priority for this notification.
  ///
  /// Priority is an indication of how much of the user's valuable attention should be consumed by
  /// this notification. Low-priority notifications may be hidden from the user in certain
  /// situations, while the user might be interrupted for a higher-priority notification. The
  /// system will make a determination about how to interpret this priority when presenting
  /// the notification.
  ///
  ///
  /// A notification that is at least \#PRIORITY_HIGH is more likely to be presented
  /// as a heads-up notification.
  ///
  ///
  ///
  /// Value is android.app.Notification\#PRIORITY_DEFAULT, android.app.Notification\#PRIORITY_LOW, android.app.Notification\#PRIORITY_MIN, android.app.Notification\#PRIORITY_HIGH, or android.app.Notification\#PRIORITY_MAX
  ///@deprecated use NotificationChannel\#getImportance() instead.
  set priority(int value) => _set_priority(reference, value);

  static final _get_publicVersion = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__publicVersion")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.app.Notification publicVersion
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Replacement version of this notification whose content will be shown
  /// in an insecure context such as atop a secure keyguard. See \#visibility
  /// and \#VISIBILITY_PUBLIC.
  Notification get publicVersion =>
      Notification.fromRef(_get_publicVersion(reference).object);
  static final _set_publicVersion = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_Notification__publicVersion")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification publicVersion
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Replacement version of this notification whose content will be shown
  /// in an insecure context such as atop a secure keyguard. See \#visibility
  /// and \#VISIBILITY_PUBLIC.
  set publicVersion(Notification value) =>
      _set_publicVersion(reference, value.reference);

  static final _get_sound = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__sound")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.net.Uri sound
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The sound to play.
  ///
  ///
  /// A notification that is noisy is more likely to be presented as a heads-up notification.
  ///
  ///
  ///
  ///
  /// To play the default notification sound, see \#defaults.
  ///
  ///
  ///@deprecated use NotificationChannel\#getSound().
  jni.JniObject get sound =>
      jni.JniObject.fromRef(_get_sound(reference).object);
  static final _set_sound = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_Notification__sound")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri sound
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The sound to play.
  ///
  ///
  /// A notification that is noisy is more likely to be presented as a heads-up notification.
  ///
  ///
  ///
  ///
  /// To play the default notification sound, see \#defaults.
  ///
  ///
  ///@deprecated use NotificationChannel\#getSound().
  set sound(jni.JniObject value) => _set_sound(reference, value.reference);

  static final _get_tickerText = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__tickerText")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.CharSequence tickerText
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Text that summarizes this notification for accessibility services.
  ///
  /// As of the L release, this text is no longer shown on screen, but it is still useful to
  /// accessibility services (where it serves as an audible announcement of the notification's
  /// appearance).
  ///@see \#tickerView
  jni.JniObject get tickerText =>
      jni.JniObject.fromRef(_get_tickerText(reference).object);
  static final _set_tickerText = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_Notification__tickerText")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence tickerText
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Text that summarizes this notification for accessibility services.
  ///
  /// As of the L release, this text is no longer shown on screen, but it is still useful to
  /// accessibility services (where it serves as an audible announcement of the notification's
  /// appearance).
  ///@see \#tickerView
  set tickerText(jni.JniObject value) =>
      _set_tickerText(reference, value.reference);

  static final _get_tickerView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__tickerView")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.widget.RemoteViews tickerView
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formerly, a view showing the \#tickerText.
  ///
  /// No longer displayed in the status bar as of API 21.
  jni.JniObject get tickerView =>
      jni.JniObject.fromRef(_get_tickerView(reference).object);
  static final _set_tickerView = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_Notification__tickerView")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.RemoteViews tickerView
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Formerly, a view showing the \#tickerText.
  ///
  /// No longer displayed in the status bar as of API 21.
  set tickerView(jni.JniObject value) =>
      _set_tickerView(reference, value.reference);

  static final _get_vibrate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__vibrate")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public long[] vibrate
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The pattern with which to vibrate.
  ///
  ///
  /// To vibrate the default pattern, see \#defaults.
  ///
  ///
  ///@see android.os.Vibrator\#vibrate(long[],int)
  ///@deprecated use NotificationChannel\#getVibrationPattern().
  jni.JniObject get vibrate =>
      jni.JniObject.fromRef(_get_vibrate(reference).object);
  static final _set_vibrate = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_Notification__vibrate")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public long[] vibrate
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The pattern with which to vibrate.
  ///
  ///
  /// To vibrate the default pattern, see \#defaults.
  ///
  ///
  ///@see android.os.Vibrator\#vibrate(long[],int)
  ///@deprecated use NotificationChannel\#getVibrationPattern().
  set vibrate(jni.JniObject value) => _set_vibrate(reference, value.reference);

  static final _get_visibility = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__visibility")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int visibility
  ///
  /// Sphere of visibility of this notification, which affects how and when the SystemUI reveals
  /// the notification's presence and contents in untrusted situations (namely, on the secure
  /// lockscreen).
  ///
  /// The default level, \#VISIBILITY_PRIVATE, behaves exactly as notifications have always
  /// done on Android: The notification's \#icon and \#tickerText (if available) are
  /// shown in all situations, but the contents are only available if the device is unlocked for
  /// the appropriate user.
  ///
  /// A more permissive policy can be expressed by \#VISIBILITY_PUBLIC; such a notification
  /// can be read even in an "insecure" context (that is, above a secure lockscreen).
  /// To modify the public version of this notification\u2014for example, to redact some portions\u2014see
  /// Builder\#setPublicVersion(Notification).
  ///
  /// Finally, a notification can be made \#VISIBILITY_SECRET, which will suppress its icon
  /// and ticker until the user has bypassed the lockscreen.
  ///
  /// Value is android.app.Notification\#VISIBILITY_PUBLIC, android.app.Notification\#VISIBILITY_PRIVATE, or android.app.Notification\#VISIBILITY_SECRET
  int get visibility => _get_visibility(reference).integer;
  static final _set_visibility = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Notification__visibility")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int visibility
  ///
  /// Sphere of visibility of this notification, which affects how and when the SystemUI reveals
  /// the notification's presence and contents in untrusted situations (namely, on the secure
  /// lockscreen).
  ///
  /// The default level, \#VISIBILITY_PRIVATE, behaves exactly as notifications have always
  /// done on Android: The notification's \#icon and \#tickerText (if available) are
  /// shown in all situations, but the contents are only available if the device is unlocked for
  /// the appropriate user.
  ///
  /// A more permissive policy can be expressed by \#VISIBILITY_PUBLIC; such a notification
  /// can be read even in an "insecure" context (that is, above a secure lockscreen).
  /// To modify the public version of this notification\u2014for example, to redact some portions\u2014see
  /// Builder\#setPublicVersion(Notification).
  ///
  /// Finally, a notification can be made \#VISIBILITY_SECRET, which will suppress its icon
  /// and ticker until the user has bypassed the lockscreen.
  ///
  /// Value is android.app.Notification\#VISIBILITY_PUBLIC, android.app.Notification\#VISIBILITY_PRIVATE, or android.app.Notification\#VISIBILITY_SECRET
  set visibility(int value) => _set_visibility(reference, value);

  static final _get_when = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification__when")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public long when
  ///
  /// A timestamp related to this notification, in milliseconds since the epoch.
  ///
  /// Default value: System\#currentTimeMillis() Now.
  ///
  /// Choose a timestamp that will be most relevant to the user. For most finite events, this
  /// corresponds to the time the event happened (or will happen, in the case of events that have
  /// yet to occur but about which the user is being informed). Indefinite events should be
  /// timestamped according to when the activity began.
  ///
  /// Some examples:
  ///
  /// <ul>
  ///   <li>Notification of a new chat message should be stamped when the message was received.</li>
  ///   <li>Notification of an ongoing file download (with a progress bar, for example) should be stamped when the download started.</li>
  ///   <li>Notification of a completed file download should be stamped when the download finished.</li>
  ///   <li>Notification of an upcoming meeting should be stamped with the time the meeting will begin (that is, in the future).</li>
  ///   <li>Notification of an ongoing stopwatch (increasing timer) should be stamped with the watch's start time.
  ///   <li>Notification of an ongoing countdown timer should be stamped with the timer's end time.
  /// </ul>
  ///
  /// For apps targeting android.os.Build.VERSION_CODES\#N and above, this time is not shown
  /// anymore by default and must be opted into by using
  /// android.app.Notification.Builder\#setShowWhen(boolean)
  int get when => _get_when(reference).long;
  static final _set_when = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int64)>>("set_Notification__when")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public long when
  ///
  /// A timestamp related to this notification, in milliseconds since the epoch.
  ///
  /// Default value: System\#currentTimeMillis() Now.
  ///
  /// Choose a timestamp that will be most relevant to the user. For most finite events, this
  /// corresponds to the time the event happened (or will happen, in the case of events that have
  /// yet to occur but about which the user is being informed). Indefinite events should be
  /// timestamped according to when the activity began.
  ///
  /// Some examples:
  ///
  /// <ul>
  ///   <li>Notification of a new chat message should be stamped when the message was received.</li>
  ///   <li>Notification of an ongoing file download (with a progress bar, for example) should be stamped when the download started.</li>
  ///   <li>Notification of a completed file download should be stamped when the download finished.</li>
  ///   <li>Notification of an upcoming meeting should be stamped with the time the meeting will begin (that is, in the future).</li>
  ///   <li>Notification of an ongoing stopwatch (increasing timer) should be stamped with the watch's start time.
  ///   <li>Notification of an ongoing countdown timer should be stamped with the timer's end time.
  /// </ul>
  ///
  /// For apps targeting android.os.Build.VERSION_CODES\#N and above, this time is not shown
  /// anymore by default and must be opted into by using
  /// android.app.Notification.Builder\#setShowWhen(boolean)
  set when(int value) => _set_when(reference, value);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Notification__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ///
  /// Constructs a Notification object with default values.
  /// You might want to consider using Builder instead.
  Notification() : super.fromRef(_ctor().object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Int32, ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("Notification__ctor1")
      .asFunction<jni.JniResult Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(int icon, java.lang.CharSequence tickerText, long when)
  ///
  /// Constructs a Notification object with the information needed to
  /// have a status bar icon without the standard expanded view.
  ///@param icon The resource id of the icon to put in the status bar.
  ///@param tickerText The text that flows by in the status bar when the notification first
  ///                      activates.
  ///@param when The time to show in the time field.  In the System.currentTimeMillis
  ///                      timebase.
  ///@deprecated Use Builder instead.
  Notification.ctor1(int icon, jni.JniObject tickerText, int when)
      : super.fromRef(_ctor1(icon, tickerText.reference, when).object);

  static final _ctor2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification__ctor2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel parcel)
  ///
  /// Unflatten the notification from a parcel.
  Notification.ctor2(os_.Parcel parcel)
      : super.fromRef(_ctor2(parcel.reference).object);

  static final _getGroup = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification__getGroup")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getGroup()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the key used to group this notification into a cluster or stack
  /// with other notifications on devices which support such rendering.
  jni.JniString getGroup() =>
      jni.JniString.fromRef(_getGroup(reference).object);

  static final _getSortKey = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification__getSortKey")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSortKey()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a sort key that orders this notification among other notifications from the
  /// same package. This can be useful if an external sort was already applied and an app
  /// would like to preserve this. Notifications will be sorted lexicographically using this
  /// value, although providing different priorities in addition to providing sort key may
  /// cause this value to be ignored.
  ///
  /// This sort key can also be used to order members of a notification group. See
  /// Builder\#setGroup.
  ///@see String\#compareTo(String)
  jni.JniString getSortKey() =>
      jni.JniString.fromRef(_getSortKey(reference).object);

  static final _clone = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification__clone")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Notification clone() => Notification.fromRef(_clone(reference).object);

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Notification__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int flags)
  ///
  /// Flatten this notification into a parcel.
  void writeToParcel(os_.Parcel parcel, int flags) =>
      _writeToParcel(reference, parcel.reference, flags).check();

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);

  static final _getChannelId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification__getChannelId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getChannelId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the id of the channel this notification posts to.
  jni.JniString getChannelId() =>
      jni.JniString.fromRef(_getChannelId(reference).object);

  static final _getTimeoutAfter = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification__getTimeoutAfter")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTimeoutAfter()
  ///
  /// Returns the duration from posting after which this notification should be canceled by the
  /// system, if it's not canceled already.
  int getTimeoutAfter() => _getTimeoutAfter(reference).long;

  static final _getBadgeIconType = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification__getBadgeIconType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getBadgeIconType()
  ///
  /// Returns what icon should be shown for this notification if it is being displayed in a
  /// Launcher that supports badging. Will be one of \#BADGE_ICON_NONE,
  /// \#BADGE_ICON_SMALL, or \#BADGE_ICON_LARGE.
  int getBadgeIconType() => _getBadgeIconType(reference).integer;

  static final _getShortcutId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification__getShortcutId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getShortcutId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the ShortcutInfo\#getId() id that this notification supersedes, if any.
  ///
  /// Used by some Launchers that display notification content to hide shortcuts that duplicate
  /// notifications.
  jni.JniString getShortcutId() =>
      jni.JniString.fromRef(_getShortcutId(reference).object);

  static final _getSettingsText = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification__getSettingsText")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getSettingsText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the settings text provided to Builder\#setSettingsText(CharSequence).
  jni.JniObject getSettingsText() =>
      jni.JniObject.fromRef(_getSettingsText(reference).object);

  static final _getGroupAlertBehavior = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification__getGroupAlertBehavior")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getGroupAlertBehavior()
  ///
  /// Returns which type of notifications in a group are responsible for audibly alerting the
  /// user. See \#GROUP_ALERT_ALL, \#GROUP_ALERT_CHILDREN,
  /// \#GROUP_ALERT_SUMMARY.
  ///@return Value is android.app.Notification\#GROUP_ALERT_ALL, android.app.Notification\#GROUP_ALERT_CHILDREN, or android.app.Notification\#GROUP_ALERT_SUMMARY
  int getGroupAlertBehavior() => _getGroupAlertBehavior(reference).integer;

  static final _getSmallIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification__getSmallIcon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Icon getSmallIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The small icon representing this notification in the status bar and content view.
  ///@return the small icon representing this notification.
  ///@see Builder\#getSmallIcon()
  ///@see Builder\#setSmallIcon(Icon)
  jni.JniObject getSmallIcon() =>
      jni.JniObject.fromRef(_getSmallIcon(reference).object);

  static final _getLargeIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification__getLargeIcon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Icon getLargeIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The large icon shown in this notification's content view.
  ///@see Builder\#getLargeIcon()
  ///@see Builder\#setLargeIcon(Icon)
  jni.JniObject getLargeIcon() =>
      jni.JniObject.fromRef(_getLargeIcon(reference).object);
}

/// from: android.app.Notification$WearableExtender
///
/// Helper class to add wearable extensions to notifications.
/// <p class="note"> See
/// <a href="{@docRoot}wear/notifications/creating.html">Creating Notifications
/// for Android Wear</a> for more information on how to use this class.
///
/// To create a notification with wearable extensions:
/// <ol>
///   <li>Create a android.app.Notification.Builder, setting any desired
///   properties.
///   <li>Create a android.app.Notification.WearableExtender.
///   <li>Set wearable-specific properties using the
///   {@code add} and {@code set} methods of android.app.Notification.WearableExtender.
///   <li>Call android.app.Notification.Builder\#extend to apply the extensions to a
///   notification.
///   <li>Post the notification to the notification system with the
///   {@code NotificationManager.notify(...)} methods.
/// </ol>
///
/// <pre class="prettyprint">
/// Notification notif = new Notification.Builder(mContext)
///         .setContentTitle(&quot;New mail from &quot; + sender.toString())
///         .setContentText(subject)
///         .setSmallIcon(R.drawable.new_mail)
///         .extend(new Notification.WearableExtender()
///                 .setContentIcon(R.drawable.new_mail))
///         .build();
/// NotificationManager notificationManger =
///         (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
/// notificationManger.notify(0, notif);</pre>
///
/// Wearable extensions can be accessed on an existing notification by using the
/// {@code WearableExtender(Notification)} constructor,
/// and then using the {@code get} methods to access values.
///
/// <pre class="prettyprint">
/// Notification.WearableExtender wearableExtender = new Notification.WearableExtender(
///         notification);
/// List&lt;Notification&gt; pages = wearableExtender.getPages();</pre>
class Notification_WearableExtender extends jni.JniObject {
  Notification_WearableExtender.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final int SCREEN_TIMEOUT_LONG
  ///
  /// Sentinel value for use with \#setHintScreenTimeout to keep the screen on
  /// for a longer amount of time when this notification is displayed on the screen.
  static const SCREEN_TIMEOUT_LONG = -1;

  /// from: static public final int SCREEN_TIMEOUT_SHORT
  ///
  /// Sentinel value for use with \#setHintScreenTimeout to keep the screen on for a
  /// short amount of time when this notification is displayed on the screen. This
  /// is the default value.
  static const SCREEN_TIMEOUT_SHORT = 0;

  /// from: static public final int SIZE_DEFAULT
  ///
  /// Size value for use with \#setCustomSizePreset to show this notification with
  /// default sizing.
  /// For custom display notifications created using \#setDisplayIntent,
  /// the default is \#SIZE_MEDIUM. All other notifications size automatically based
  /// on their content.
  static const SIZE_DEFAULT = 0;

  /// from: static public final int SIZE_FULL_SCREEN
  ///
  /// Size value for use with \#setCustomSizePreset to show this notification
  /// full screen.
  /// This value is only applicable for custom display notifications created using
  /// \#setDisplayIntent.
  static const SIZE_FULL_SCREEN = 5;

  /// from: static public final int SIZE_LARGE
  ///
  /// Size value for use with \#setCustomSizePreset to show this notification
  /// with a large size.
  /// This value is only applicable for custom display notifications created using
  /// \#setDisplayIntent.
  static const SIZE_LARGE = 4;

  /// from: static public final int SIZE_MEDIUM
  ///
  /// Size value for use with \#setCustomSizePreset to show this notification
  /// with a medium size.
  /// This value is only applicable for custom display notifications created using
  /// \#setDisplayIntent.
  static const SIZE_MEDIUM = 3;

  /// from: static public final int SIZE_SMALL
  ///
  /// Size value for use with \#setCustomSizePreset to show this notification
  /// with a small size.
  /// This value is only applicable for custom display notifications created using
  /// \#setDisplayIntent.
  static const SIZE_SMALL = 2;

  /// from: static public final int SIZE_XSMALL
  ///
  /// Size value for use with \#setCustomSizePreset to show this notification
  /// with an extra small size.
  /// This value is only applicable for custom display notifications created using
  /// \#setDisplayIntent.
  static const SIZE_XSMALL = 1;

  /// from: static public final int UNSET_ACTION_INDEX
  ///
  /// Sentinel value for an action index that is unset.
  static const UNSET_ACTION_INDEX = -1;

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Notification_WearableExtender__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ///
  /// Create a android.app.Notification.WearableExtender with default
  /// options.
  Notification_WearableExtender() : super.fromRef(_ctor().object);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Notification notif)
  Notification_WearableExtender.ctor1(Notification notif)
      : super.fromRef(_ctor1(notif.reference).object);

  static final _extend = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__extend")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder extend(android.app.Notification.Builder builder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Apply wearable extensions to a notification that is being built. This is typically
  /// called by the android.app.Notification.Builder\#extend method of
  /// android.app.Notification.Builder.
  Notification_Builder extend(Notification_Builder builder) =>
      Notification_Builder.fromRef(
          _extend(reference, builder.reference).object);

  static final _clone = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__clone")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Notification_WearableExtender clone() =>
      Notification_WearableExtender.fromRef(_clone(reference).object);

  static final _addAction = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__addAction")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender addAction(android.app.Notification.Action action)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a wearable action to this notification.
  ///
  /// When wearable actions are added using this method, the set of actions that
  /// show on a wearable device splits from devices that only show actions added
  /// using android.app.Notification.Builder\#addAction. This allows for customization
  /// of which actions display on different devices.
  ///@param action the action to add to this notification
  ///@return this object for method chaining
  ///@see android.app.Notification.Action
  Notification_WearableExtender addAction(Notification_Action action) =>
      Notification_WearableExtender.fromRef(
          _addAction(reference, action.reference).object);

  static final _addActions = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__addActions")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender addActions(java.util.List<android.app.Notification.Action> actions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds wearable actions to this notification.
  ///
  /// When wearable actions are added using this method, the set of actions that
  /// show on a wearable device splits from devices that only show actions added
  /// using android.app.Notification.Builder\#addAction. This allows for customization
  /// of which actions display on different devices.
  ///@param actions the actions to add to this notification
  ///@return this object for method chaining
  ///@see android.app.Notification.Action
  Notification_WearableExtender addActions(jni.JniObject actions) =>
      Notification_WearableExtender.fromRef(
          _addActions(reference, actions.reference).object);

  static final _clearActions = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__clearActions")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender clearActions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Clear all wearable actions present on this builder.
  ///@return this object for method chaining.
  ///@see \#addAction
  Notification_WearableExtender clearActions() =>
      Notification_WearableExtender.fromRef(_clearActions(reference).object);

  static final _getActions = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getActions")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.Notification.Action> getActions()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the wearable actions present on this notification.
  jni.JniObject getActions() =>
      jni.JniObject.fromRef(_getActions(reference).object);

  static final _setDisplayIntent = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__setDisplayIntent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender setDisplayIntent(android.app.PendingIntent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set an intent to launch inside of an activity view when displaying
  /// this notification. The PendingIntent provided should be for an activity.
  ///
  /// <pre class="prettyprint">
  /// Intent displayIntent = new Intent(context, MyDisplayActivity.class);
  /// PendingIntent displayPendingIntent = PendingIntent.getActivity(context,
  ///         0, displayIntent, PendingIntent.FLAG_UPDATE_CURRENT);
  /// Notification notif = new Notification.Builder(context)
  ///         .extend(new Notification.WearableExtender()
  ///                 .setDisplayIntent(displayPendingIntent)
  ///                 .setCustomSizePreset(Notification.WearableExtender.SIZE_MEDIUM))
  ///         .build();</pre>
  ///
  /// The activity to launch needs to allow embedding, must be exported, and
  /// should have an empty task affinity. It is also recommended to use the device
  /// default light theme.
  ///
  /// Example AndroidManifest.xml entry:
  /// <pre class="prettyprint">
  /// &lt;activity android:name=&quot;com.example.MyDisplayActivity&quot;
  ///     android:exported=&quot;true&quot;
  ///     android:allowEmbedded=&quot;true&quot;
  ///     android:taskAffinity=&quot;&quot;
  ///     android:theme=&quot;@android:style/Theme.DeviceDefault.Light&quot; /&gt;</pre>
  ///@param intent the PendingIntent for an activity
  ///@return this object for method chaining
  ///@see android.app.Notification.WearableExtender\#getDisplayIntent
  Notification_WearableExtender setDisplayIntent(PendingIntent intent) =>
      Notification_WearableExtender.fromRef(
          _setDisplayIntent(reference, intent.reference).object);

  static final _getDisplayIntent = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getDisplayIntent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent getDisplayIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the intent to launch inside of an activity view when displaying this
  /// notification. This {@code PendingIntent} should be for an activity.
  PendingIntent getDisplayIntent() =>
      PendingIntent.fromRef(_getDisplayIntent(reference).object);

  static final _addPage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__addPage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender addPage(android.app.Notification page)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add an additional page of content to display with this notification. The current
  /// notification forms the first page, and pages added using this function form
  /// subsequent pages. This field can be used to separate a notification into multiple
  /// sections.
  ///@param page the notification to add as another page
  ///@return this object for method chaining
  ///@see android.app.Notification.WearableExtender\#getPages
  Notification_WearableExtender addPage(Notification page) =>
      Notification_WearableExtender.fromRef(
          _addPage(reference, page.reference).object);

  static final _addPages = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__addPages")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender addPages(java.util.List<android.app.Notification> pages)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add additional pages of content to display with this notification. The current
  /// notification forms the first page, and pages added using this function form
  /// subsequent pages. This field can be used to separate a notification into multiple
  /// sections.
  ///@param pages a list of notifications
  ///@return this object for method chaining
  ///@see android.app.Notification.WearableExtender\#getPages
  Notification_WearableExtender addPages(jni.JniObject pages) =>
      Notification_WearableExtender.fromRef(
          _addPages(reference, pages.reference).object);

  static final _clearPages = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__clearPages")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender clearPages()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Clear all additional pages present on this builder.
  ///@return this object for method chaining.
  ///@see \#addPage
  Notification_WearableExtender clearPages() =>
      Notification_WearableExtender.fromRef(_clearPages(reference).object);

  static final _getPages = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getPages")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.Notification> getPages()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the array of additional pages of content for displaying this notification. The
  /// current notification forms the first page, and elements within this array form
  /// subsequent pages. This field can be used to separate a notification into multiple
  /// sections.
  ///@return the pages for this notification
  jni.JniObject getPages() =>
      jni.JniObject.fromRef(_getPages(reference).object);

  static final _setBackground = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__setBackground")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender setBackground(android.graphics.Bitmap background)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a background image to be displayed behind the notification content.
  /// Contrary to the android.app.Notification.BigPictureStyle, this background
  /// will work with any notification style.
  ///@param background the background bitmap
  ///@return this object for method chaining
  ///@see android.app.Notification.WearableExtender\#getBackground
  Notification_WearableExtender setBackground(jni.JniObject background) =>
      Notification_WearableExtender.fromRef(
          _setBackground(reference, background.reference).object);

  static final _getBackground = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getBackground")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap getBackground()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get a background image to be displayed behind the notification content.
  /// Contrary to the android.app.Notification.BigPictureStyle, this background
  /// will work with any notification style.
  ///@return the background image
  ///@see android.app.Notification.WearableExtender\#setBackground
  jni.JniObject getBackground() =>
      jni.JniObject.fromRef(_getBackground(reference).object);

  static final _setContentIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Notification_WearableExtender__setContentIcon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setContentIcon(int icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set an icon that goes with the content of this notification.
  Notification_WearableExtender setContentIcon(int icon) =>
      Notification_WearableExtender.fromRef(
          _setContentIcon(reference, icon).object);

  static final _getContentIcon = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getContentIcon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getContentIcon()
  ///
  /// Get an icon that goes with the content of this notification.
  int getContentIcon() => _getContentIcon(reference).integer;

  static final _setContentIconGravity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "Notification_WearableExtender__setContentIconGravity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setContentIconGravity(int contentIconGravity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the gravity that the content icon should have within the notification display.
  /// Supported values include android.view.Gravity\#START and
  /// android.view.Gravity\#END. The default value is android.view.Gravity\#END.
  ///@see \#setContentIcon
  Notification_WearableExtender setContentIconGravity(int contentIconGravity) =>
      Notification_WearableExtender.fromRef(
          _setContentIconGravity(reference, contentIconGravity).object);

  static final _getContentIconGravity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getContentIconGravity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getContentIconGravity()
  ///
  /// Get the gravity that the content icon should have within the notification display.
  /// Supported values include android.view.Gravity\#START and
  /// android.view.Gravity\#END. The default value is android.view.Gravity\#END.
  ///@see \#getContentIcon
  int getContentIconGravity() => _getContentIconGravity(reference).integer;

  static final _setContentAction = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "Notification_WearableExtender__setContentAction")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setContentAction(int actionIndex)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set an action from this notification's actions to be clickable with the content of
  /// this notification. This action will no longer display separately from the
  /// notification's content.
  ///
  /// For notifications with multiple pages, child pages can also have content actions
  /// set, although the list of available actions comes from the main notification and not
  /// from the child page's notification.
  ///@param actionIndex The index of the action to hoist onto the current notification page.
  ///                    If wearable actions were added to the main notification, this index
  ///                    will apply to that list, otherwise it will apply to the regular
  ///                    actions list.
  Notification_WearableExtender setContentAction(int actionIndex) =>
      Notification_WearableExtender.fromRef(
          _setContentAction(reference, actionIndex).object);

  static final _getContentAction = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getContentAction")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getContentAction()
  ///
  /// Get the index of the notification action, if any, that was specified as being clickable
  /// with the content of this notification. This action will no longer display separately
  /// from the notification's content.
  ///
  /// For notifications with multiple pages, child pages can also have content actions
  /// set, although the list of available actions comes from the main notification and not
  /// from the child page's notification.
  ///
  /// If wearable specific actions were added to the main notification, this index will
  /// apply to that list, otherwise it will apply to the regular actions list.
  ///@return the action index or \#UNSET_ACTION_INDEX if no action was selected.
  int getContentAction() => _getContentAction(reference).integer;

  static final _setGravity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Notification_WearableExtender__setGravity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setGravity(int gravity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the gravity that this notification should have within the available viewport space.
  /// Supported values include android.view.Gravity\#TOP,
  /// android.view.Gravity\#CENTER_VERTICAL and android.view.Gravity\#BOTTOM.
  /// The default value is android.view.Gravity\#BOTTOM.
  Notification_WearableExtender setGravity(int gravity) =>
      Notification_WearableExtender.fromRef(
          _setGravity(reference, gravity).object);

  static final _getGravity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getGravity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getGravity()
  ///
  /// Get the gravity that this notification should have within the available viewport space.
  /// Supported values include android.view.Gravity\#TOP,
  /// android.view.Gravity\#CENTER_VERTICAL and android.view.Gravity\#BOTTOM.
  /// The default value is android.view.Gravity\#BOTTOM.
  int getGravity() => _getGravity(reference).integer;

  static final _setCustomSizePreset = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "Notification_WearableExtender__setCustomSizePreset")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setCustomSizePreset(int sizePreset)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the custom size preset for the display of this notification out of the available
  /// presets found in android.app.Notification.WearableExtender, e.g.
  /// \#SIZE_LARGE.
  /// Some custom size presets are only applicable for custom display notifications created
  /// using android.app.Notification.WearableExtender\#setDisplayIntent. Check the
  /// documentation for the preset in question. See also
  /// \#setCustomContentHeight and \#getCustomSizePreset.
  Notification_WearableExtender setCustomSizePreset(int sizePreset) =>
      Notification_WearableExtender.fromRef(
          _setCustomSizePreset(reference, sizePreset).object);

  static final _getCustomSizePreset = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getCustomSizePreset")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getCustomSizePreset()
  ///
  /// Get the custom size preset for the display of this notification out of the available
  /// presets found in android.app.Notification.WearableExtender, e.g.
  /// \#SIZE_LARGE.
  /// Some custom size presets are only applicable for custom display notifications created
  /// using \#setDisplayIntent. Check the documentation for the preset in question.
  /// See also \#setCustomContentHeight and \#setCustomSizePreset.
  int getCustomSizePreset() => _getCustomSizePreset(reference).integer;

  static final _setCustomContentHeight = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "Notification_WearableExtender__setCustomContentHeight")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setCustomContentHeight(int height)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the custom height in pixels for the display of this notification's content.
  /// This option is only available for custom display notifications created
  /// using android.app.Notification.WearableExtender\#setDisplayIntent. See also
  /// android.app.Notification.WearableExtender\#setCustomSizePreset and
  /// \#getCustomContentHeight.
  Notification_WearableExtender setCustomContentHeight(int height) =>
      Notification_WearableExtender.fromRef(
          _setCustomContentHeight(reference, height).object);

  static final _getCustomContentHeight = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getCustomContentHeight")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getCustomContentHeight()
  ///
  /// Get the custom height in pixels for the display of this notification's content.
  /// This option is only available for custom display notifications created
  /// using \#setDisplayIntent. See also \#setCustomSizePreset and
  /// \#setCustomContentHeight.
  int getCustomContentHeight() => _getCustomContentHeight(reference).integer;

  static final _setStartScrollBottom = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "Notification_WearableExtender__setStartScrollBottom")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setStartScrollBottom(boolean startScrollBottom)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether the scrolling position for the contents of this notification should start
  /// at the bottom of the contents instead of the top when the contents are too long to
  /// display within the screen.  Default is false (start scroll at the top).
  Notification_WearableExtender setStartScrollBottom(bool startScrollBottom) =>
      Notification_WearableExtender.fromRef(
          _setStartScrollBottom(reference, startScrollBottom ? 1 : 0).object);

  static final _getStartScrollBottom = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getStartScrollBottom")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getStartScrollBottom()
  ///
  /// Get whether the scrolling position for the contents of this notification should start
  /// at the bottom of the contents instead of the top when the contents are too long to
  /// display within the screen. Default is false (start scroll at the top).
  bool getStartScrollBottom() => _getStartScrollBottom(reference).boolean;

  static final _setContentIntentAvailableOffline = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "Notification_WearableExtender__setContentIntentAvailableOffline")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setContentIntentAvailableOffline(boolean contentIntentAvailableOffline)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether the content intent is available when the wearable device is not connected
  /// to a companion device.  The user can still trigger this intent when the wearable device
  /// is offline, but a visual hint will indicate that the content intent may not be available.
  /// Defaults to true.
  Notification_WearableExtender setContentIntentAvailableOffline(
          bool contentIntentAvailableOffline) =>
      Notification_WearableExtender.fromRef(_setContentIntentAvailableOffline(
              reference, contentIntentAvailableOffline ? 1 : 0)
          .object);

  static final _getContentIntentAvailableOffline = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getContentIntentAvailableOffline")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getContentIntentAvailableOffline()
  ///
  /// Get whether the content intent is available when the wearable device is not connected
  /// to a companion device.  The user can still trigger this intent when the wearable device
  /// is offline, but a visual hint will indicate that the content intent may not be available.
  /// Defaults to true.
  bool getContentIntentAvailableOffline() =>
      _getContentIntentAvailableOffline(reference).boolean;

  static final _setHintHideIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Notification_WearableExtender__setHintHideIcon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setHintHideIcon(boolean hintHideIcon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a hint that this notification's icon should not be displayed.
  ///@param hintHideIcon {@code true} to hide the icon, {@code false} otherwise.
  ///@return this object for method chaining
  Notification_WearableExtender setHintHideIcon(bool hintHideIcon) =>
      Notification_WearableExtender.fromRef(
          _setHintHideIcon(reference, hintHideIcon ? 1 : 0).object);

  static final _getHintHideIcon = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getHintHideIcon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getHintHideIcon()
  ///
  /// Get a hint that this notification's icon should not be displayed.
  ///@return {@code true} if this icon should not be displayed, false otherwise.
  /// The default value is {@code false} if this was never set.
  bool getHintHideIcon() => _getHintHideIcon(reference).boolean;

  static final _setHintShowBackgroundOnly = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "Notification_WearableExtender__setHintShowBackgroundOnly")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setHintShowBackgroundOnly(boolean hintShowBackgroundOnly)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a visual hint that only the background image of this notification should be
  /// displayed, and other semantic content should be hidden. This hint is only applicable
  /// to sub-pages added using \#addPage.
  Notification_WearableExtender setHintShowBackgroundOnly(
          bool hintShowBackgroundOnly) =>
      Notification_WearableExtender.fromRef(
          _setHintShowBackgroundOnly(reference, hintShowBackgroundOnly ? 1 : 0)
              .object);

  static final _getHintShowBackgroundOnly = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getHintShowBackgroundOnly")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getHintShowBackgroundOnly()
  ///
  /// Get a visual hint that only the background image of this notification should be
  /// displayed, and other semantic content should be hidden. This hint is only applicable
  /// to sub-pages added using android.app.Notification.WearableExtender\#addPage.
  bool getHintShowBackgroundOnly() =>
      _getHintShowBackgroundOnly(reference).boolean;

  static final _setHintAvoidBackgroundClipping = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "Notification_WearableExtender__setHintAvoidBackgroundClipping")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setHintAvoidBackgroundClipping(boolean hintAvoidBackgroundClipping)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a hint that this notification's background should not be clipped if possible,
  /// and should instead be resized to fully display on the screen, retaining the aspect
  /// ratio of the image. This can be useful for images like barcodes or qr codes.
  ///@param hintAvoidBackgroundClipping {@code true} to avoid clipping if possible.
  ///@return this object for method chaining
  Notification_WearableExtender setHintAvoidBackgroundClipping(
          bool hintAvoidBackgroundClipping) =>
      Notification_WearableExtender.fromRef(_setHintAvoidBackgroundClipping(
              reference, hintAvoidBackgroundClipping ? 1 : 0)
          .object);

  static final _getHintAvoidBackgroundClipping = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getHintAvoidBackgroundClipping")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getHintAvoidBackgroundClipping()
  ///
  /// Get a hint that this notification's background should not be clipped if possible,
  /// and should instead be resized to fully display on the screen, retaining the aspect
  /// ratio of the image. This can be useful for images like barcodes or qr codes.
  ///@return {@code true} if it's ok if the background is clipped on the screen, false
  /// otherwise. The default value is {@code false} if this was never set.
  bool getHintAvoidBackgroundClipping() =>
      _getHintAvoidBackgroundClipping(reference).boolean;

  static final _setHintScreenTimeout = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "Notification_WearableExtender__setHintScreenTimeout")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setHintScreenTimeout(int timeout)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a hint that the screen should remain on for at least this duration when
  /// this notification is displayed on the screen.
  ///@param timeout The requested screen timeout in milliseconds. Can also be either
  ///     \#SCREEN_TIMEOUT_SHORT or \#SCREEN_TIMEOUT_LONG.
  ///@return this object for method chaining
  Notification_WearableExtender setHintScreenTimeout(int timeout) =>
      Notification_WearableExtender.fromRef(
          _setHintScreenTimeout(reference, timeout).object);

  static final _getHintScreenTimeout = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getHintScreenTimeout")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getHintScreenTimeout()
  ///
  /// Get the duration, in milliseconds, that the screen should remain on for
  /// when this notification is displayed.
  ///@return the duration in milliseconds if > 0, or either one of the sentinel values
  ///     \#SCREEN_TIMEOUT_SHORT or \#SCREEN_TIMEOUT_LONG.
  int getHintScreenTimeout() => _getHintScreenTimeout(reference).integer;

  static final _setHintAmbientBigPicture = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "Notification_WearableExtender__setHintAmbientBigPicture")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setHintAmbientBigPicture(boolean hintAmbientBigPicture)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a hint that this notification's BigPictureStyle (if present) should be
  /// converted to low-bit and displayed in ambient mode, especially useful for barcodes and
  /// qr codes, as well as other simple black-and-white tickets.
  ///@param hintAmbientBigPicture {@code true} to enable converstion and ambient.
  ///@return this object for method chaining
  Notification_WearableExtender setHintAmbientBigPicture(
          bool hintAmbientBigPicture) =>
      Notification_WearableExtender.fromRef(
          _setHintAmbientBigPicture(reference, hintAmbientBigPicture ? 1 : 0)
              .object);

  static final _getHintAmbientBigPicture = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getHintAmbientBigPicture")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getHintAmbientBigPicture()
  ///
  /// Get a hint that this notification's BigPictureStyle (if present) should be
  /// converted to low-bit and displayed in ambient mode, especially useful for barcodes and
  /// qr codes, as well as other simple black-and-white tickets.
  ///@return {@code true} if it should be displayed in ambient, false otherwise
  /// otherwise. The default value is {@code false} if this was never set.
  bool getHintAmbientBigPicture() =>
      _getHintAmbientBigPicture(reference).boolean;

  static final _setHintContentIntentLaunchesActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "Notification_WearableExtender__setHintContentIntentLaunchesActivity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.WearableExtender setHintContentIntentLaunchesActivity(boolean hintContentIntentLaunchesActivity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a hint that this notification's content intent will launch an Activity
  /// directly, telling the platform that it can generate the appropriate transitions.
  ///@param hintContentIntentLaunchesActivity {@code true} if the content intent will launch
  /// an activity and transitions should be generated, false otherwise.
  ///@return this object for method chaining
  Notification_WearableExtender setHintContentIntentLaunchesActivity(
          bool hintContentIntentLaunchesActivity) =>
      Notification_WearableExtender.fromRef(
          _setHintContentIntentLaunchesActivity(
                  reference, hintContentIntentLaunchesActivity ? 1 : 0)
              .object);

  static final _getHintContentIntentLaunchesActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getHintContentIntentLaunchesActivity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getHintContentIntentLaunchesActivity()
  ///
  /// Get a hint that this notification's content intent will launch an Activity
  /// directly, telling the platform that it can generate the appropriate transitions
  ///@return {@code true} if the content intent will launch an activity and transitions should
  /// be generated, false otherwise. The default value is {@code false} if this was never set.
  bool getHintContentIntentLaunchesActivity() =>
      _getHintContentIntentLaunchesActivity(reference).boolean;

  static final _setDismissalId = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__setDismissalId")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender setDismissalId(java.lang.String dismissalId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the dismissal id for this notification. If a notification is posted with a
  /// dismissal id, then when that notification is canceled, notifications on other wearables
  /// and the paired Android phone having that same dismissal id will also be canceled. See
  /// <a href="{@docRoot}wear/notifications/index.html">Adding Wearable Features to
  /// Notifications</a> for more information.
  ///@param dismissalId the dismissal id of the notification.
  ///@return this object for method chaining
  Notification_WearableExtender setDismissalId(jni.JniString dismissalId) =>
      Notification_WearableExtender.fromRef(
          _setDismissalId(reference, dismissalId.reference).object);

  static final _getDismissalId = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getDismissalId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getDismissalId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the dismissal id of the notification.
  ///@return the dismissal id of the notification or null if it has not been set.
  jni.JniString getDismissalId() =>
      jni.JniString.fromRef(_getDismissalId(reference).object);

  static final _setBridgeTag = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__setBridgeTag")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.WearableExtender setBridgeTag(java.lang.String bridgeTag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets a bridge tag for this notification. A bridge tag can be set for notifications
  /// posted from a phone to provide finer-grained control on what notifications are bridged
  /// to wearables. See <a href="{@docRoot}wear/notifications/index.html">Adding Wearable
  /// Features to Notifications</a> for more information.
  ///@param bridgeTag the bridge tag of the notification.
  ///@return this object for method chaining
  Notification_WearableExtender setBridgeTag(jni.JniString bridgeTag) =>
      Notification_WearableExtender.fromRef(
          _setBridgeTag(reference, bridgeTag.reference).object);

  static final _getBridgeTag = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_WearableExtender__getBridgeTag")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getBridgeTag()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the bridge tag of the notification.
  ///@return the bridge tag or null if not present.
  jni.JniString getBridgeTag() =>
      jni.JniString.fromRef(_getBridgeTag(reference).object);
}

/// from: android.app.Notification$Style
///
/// An object that can apply a rich notification style to a Notification.Builder
/// object.
class Notification_Style extends jni.JniObject {
  Notification_Style.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_mBuilder = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification_Style__mBuilder")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: protected android.app.Notification.Builder mBuilder
  /// The returned object must be deleted after use, by calling the `delete` method.
  Notification_Builder get mBuilder =>
      Notification_Builder.fromRef(_get_mBuilder(reference).object);
  static final _set_mBuilder = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_Notification_Style__mBuilder")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: protected android.app.Notification.Builder mBuilder
  /// The returned object must be deleted after use, by calling the `delete` method.
  set mBuilder(Notification_Builder value) =>
      _set_mBuilder(reference, value.reference);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Notification_Style__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  Notification_Style() : super.fromRef(_ctor().object);

  static final _internalSetBigContentTitle = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Style__internalSetBigContentTitle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void internalSetBigContentTitle(java.lang.CharSequence title)
  ///
  /// Overrides ContentTitle in the big form of the template.
  /// This defaults to the value passed to setContentTitle().
  void internalSetBigContentTitle(jni.JniObject title) =>
      _internalSetBigContentTitle(reference, title.reference).check();

  static final _internalSetSummaryText = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Style__internalSetSummaryText")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void internalSetSummaryText(java.lang.CharSequence cs)
  ///
  /// Set the first line of text after the detail section in the big form of the template.
  void internalSetSummaryText(jni.JniObject cs) =>
      _internalSetSummaryText(reference, cs.reference).check();

  static final _setBuilder = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Style__setBuilder")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setBuilder(android.app.Notification.Builder builder)
  void setBuilder(Notification_Builder builder) =>
      _setBuilder(reference, builder.reference).check();

  static final _checkBuilder = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification_Style__checkBuilder")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void checkBuilder()
  void checkBuilder() => _checkBuilder(reference).check();

  static final _getStandardView = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Notification_Style__getStandardView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: protected android.widget.RemoteViews getStandardView(int layoutId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getStandardView(int layoutId) =>
      jni.JniObject.fromRef(_getStandardView(reference, layoutId).object);

  static final _build = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification_Style__build")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Calls android.app.Notification.Builder\#build() on the Builder this Style is
  /// attached to.
  ///@return the fully constructed Notification.
  Notification build() => Notification.fromRef(_build(reference).object);
}

/// from: android.app.Notification$MessagingStyle
///
/// Helper class for generating large-format notifications that include multiple back-and-forth
/// messages of varying types between any number of people.
///
///
/// If the platform does not provide large-format notifications, this method has no effect. The
/// user will always see the normal notification view.
///
///
/// If the app is targeting Android P and above, it is required to use the Person
/// class in order to get an optimal rendering of the notification and its avatars. For
/// conversations involving multiple people, the app should also make sure that it marks the
/// conversation as a group with \#setGroupConversation(boolean).
///
///
/// This class is a "rebuilder": It attaches to a Builder object and modifies its behavior.
/// Here's an example of how this may be used:
/// <pre class="prettyprint">
///
/// Person user = new Person.Builder().setIcon(userIcon).setName(userName).build();
/// MessagingStyle style = new MessagingStyle(user)
///      .addMessage(messages[1].getText(), messages[1].getTime(), messages[1].getPerson())
///      .addMessage(messages[2].getText(), messages[2].getTime(), messages[2].getPerson())
///      .setGroupConversation(hasMultiplePeople());
///
/// Notification noti = new Notification.Builder()
///     .setContentTitle(&quot;2 new messages with &quot; + sender.toString())
///     .setContentText(subject)
///     .setSmallIcon(R.drawable.new_message)
///     .setLargeIcon(aBitmap)
///     .setStyle(style)
///     .build();
/// </pre>
class Notification_MessagingStyle extends Notification_Style {
  Notification_MessagingStyle.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  /// from: static public final int MAXIMUM_RETAINED_MESSAGES
  ///
  /// The maximum number of messages that will be retained in the Notification itself (the
  /// number displayed is up to the platform).
  static const MAXIMUM_RETAINED_MESSAGES = 25;

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification_MessagingStyle__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.CharSequence userDisplayName)
  ///
  /// @param userDisplayName Required - the name to be displayed for any replies sent by the
  /// user before the posting app reposts the notification with those messages after they've
  /// been actually sent and in previous messages sent by the user added in
  /// \#addMessage(Notification.MessagingStyle.Message)
  ///
  /// This value must never be {@code null}.
  ///@deprecated use {@code MessagingStyle(Person)}
  Notification_MessagingStyle.ctor1(jni.JniObject userDisplayName)
      : super.fromRef(_ctor1(userDisplayName.reference).object);

  static final _ctor2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification_MessagingStyle__ctor2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Person user)
  ///
  /// @param user Required - The person displayed for any messages that are sent by the
  /// user. Any messages added with \#addMessage(Notification.MessagingStyle.Message)
  /// who don't have a Person associated with it will be displayed as if they were sent
  /// by this user. The user also needs to have a valid name associated with it, which will
  /// be enforced starting in Android P.
  ///
  /// This value must never be {@code null}.
  Notification_MessagingStyle.ctor2(Person user)
      : super.fromRef(_ctor2(user.reference).object);

  static final _getUser = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle__getUser")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Person getUser()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the user to be displayed for any replies sent by the user
  ///
  /// This value will never be {@code null}.
  Person getUser() => Person.fromRef(_getUser(reference).object);

  static final _getUserDisplayName = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle__getUserDisplayName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getUserDisplayName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the name to be displayed for any replies sent by the user
  ///@deprecated use \#getUser() instead
  jni.JniObject getUserDisplayName() =>
      jni.JniObject.fromRef(_getUserDisplayName(reference).object);

  static final _setConversationTitle = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle__setConversationTitle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.MessagingStyle setConversationTitle(java.lang.CharSequence conversationTitle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the title to be displayed on this conversation. May be set to {@code null}.
  ///
  /// This API's behavior was changed in SDK version Build.VERSION_CODES\#P. If your
  /// application's target version is less than Build.VERSION_CODES\#P, setting a
  /// conversation title to a non-null value will make \#isGroupConversation() return
  /// {@code true} and passing {@code null} will make it return {@code false}. In
  /// Build.VERSION_CODES\#P and beyond, use \#setGroupConversation(boolean)
  /// to set group conversation status.
  ///@param conversationTitle Title displayed for this conversation
  /// This value may be {@code null}.
  ///@return this object for method chaining
  Notification_MessagingStyle setConversationTitle(
          jni.JniObject conversationTitle) =>
      Notification_MessagingStyle.fromRef(
          _setConversationTitle(reference, conversationTitle.reference).object);

  static final _getConversationTitle = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle__getConversationTitle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getConversationTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the title to be displayed on this conversation. May return {@code null}.
  jni.JniObject getConversationTitle() =>
      jni.JniObject.fromRef(_getConversationTitle(reference).object);

  static final _addMessage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int64,
                      ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle__addMessage")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.MessagingStyle addMessage(java.lang.CharSequence text, long timestamp, java.lang.CharSequence sender)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds a message for display by this notification. Convenience call for a simple
  /// Message in \#addMessage(Notification.MessagingStyle.Message).
  ///@param text A CharSequence to be displayed as the message content
  ///@param timestamp Time at which the message arrived
  ///@param sender A CharSequence to be used for displaying the name of the
  /// sender. Should be <code>null</code> for messages by the current user, in which case
  /// the platform will insert \#getUserDisplayName().
  /// Should be unique amongst all individuals in the conversation, and should be
  /// consistent during re-posts of the notification.
  ///@see Message\#Message(CharSequence, long, CharSequence)
  ///@return this object for method chaining
  ///@deprecated use \#addMessage(CharSequence, long, Person)
  Notification_MessagingStyle addMessage(
          jni.JniObject text, int timestamp, jni.JniObject sender) =>
      Notification_MessagingStyle.fromRef(
          _addMessage(reference, text.reference, timestamp, sender.reference)
              .object);

  static final _addMessage1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int64,
                      ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle__addMessage1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.MessagingStyle addMessage(java.lang.CharSequence text, long timestamp, android.app.Person sender)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds a message for display by this notification. Convenience call for a simple
  /// Message in \#addMessage(Notification.MessagingStyle.Message).
  ///@param text A CharSequence to be displayed as the message content
  /// This value must never be {@code null}.
  ///@param timestamp Time at which the message arrived
  ///@param sender The Person who sent the message.
  /// Should be <code>null</code> for messages by the current user, in which case
  /// the platform will insert the user set in {@code MessagingStyle(Person)}.
  ///
  /// This value may be {@code null}.
  ///@see Message\#Message(CharSequence, long, CharSequence)
  ///@return this object for method chaining
  Notification_MessagingStyle addMessage1(
          jni.JniObject text, int timestamp, Person sender) =>
      Notification_MessagingStyle.fromRef(
          _addMessage1(reference, text.reference, timestamp, sender.reference)
              .object);

  static final _addMessage2 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle__addMessage2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.MessagingStyle addMessage(android.app.Notification.MessagingStyle.Message message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds a Message for display in this notification.
  ///
  /// The messages should be added in chronologic order, i.e. the oldest first,
  /// the newest last.
  ///@param message The Message to be displayed
  ///@return this object for method chaining
  Notification_MessagingStyle addMessage2(
          Notification_MessagingStyle_Message message) =>
      Notification_MessagingStyle.fromRef(
          _addMessage2(reference, message.reference).object);

  static final _addHistoricMessage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle__addHistoricMessage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.MessagingStyle addHistoricMessage(android.app.Notification.MessagingStyle.Message message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Adds a Message for historic context in this notification.
  ///
  /// Messages should be added as historic if they are not the main subject of the
  /// notification but may give context to a conversation. The system may choose to present
  /// them only when relevant, e.g. when replying to a message through a RemoteInput.
  ///
  /// The messages should be added in chronologic order, i.e. the oldest first,
  /// the newest last.
  ///@param message The historic Message to be added
  ///@return this object for method chaining
  Notification_MessagingStyle addHistoricMessage(
          Notification_MessagingStyle_Message message) =>
      Notification_MessagingStyle.fromRef(
          _addHistoricMessage(reference, message.reference).object);

  static final _getMessages = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle__getMessages")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.Notification.MessagingStyle.Message> getMessages()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the list of {@code Message} objects that represent the notification
  jni.JniObject getMessages() =>
      jni.JniObject.fromRef(_getMessages(reference).object);

  static final _getHistoricMessages = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle__getHistoricMessages")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.Notification.MessagingStyle.Message> getHistoricMessages()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the list of historic {@code Message}s in the notification.
  jni.JniObject getHistoricMessages() =>
      jni.JniObject.fromRef(_getHistoricMessages(reference).object);

  static final _setGroupConversation = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "Notification_MessagingStyle__setGroupConversation")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.MessagingStyle setGroupConversation(boolean isGroupConversation)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets whether this conversation notification represents a group. If the app is targeting
  /// Android P, this is required if the app wants to display the largeIcon set with
  /// Notification.Builder\#setLargeIcon(Bitmap), otherwise it will be hidden.
  ///@param isGroupConversation {@code true} if the conversation represents a group,
  /// {@code false} otherwise.
  ///@return this object for method chaining
  Notification_MessagingStyle setGroupConversation(bool isGroupConversation) =>
      Notification_MessagingStyle.fromRef(
          _setGroupConversation(reference, isGroupConversation ? 1 : 0).object);

  static final _isGroupConversation = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle__isGroupConversation")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isGroupConversation()
  ///
  /// Returns {@code true} if this notification represents a group conversation, otherwise
  /// {@code false}.
  ///
  ///  If the application that generated this MessagingStyle targets an SDK version
  /// less than Build.VERSION_CODES\#P, this method becomes dependent on whether or
  /// not the conversation title is set; returning {@code true} if the conversation title is
  /// a non-null value, or {@code false} otherwise. From Build.VERSION_CODES\#P forward,
  /// this method returns what's set by \#setGroupConversation(boolean) allowing for
  /// named, non-group conversations.
  ///@see \#setConversationTitle(CharSequence)
  bool isGroupConversation() => _isGroupConversation(reference).boolean;
}

/// from: android.app.Notification$MessagingStyle$Message
class Notification_MessagingStyle_Message extends jni.JniObject {
  Notification_MessagingStyle_Message.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                      ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle_Message__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.CharSequence text, long timestamp, java.lang.CharSequence sender)
  ///
  /// Constructor
  ///@param text A CharSequence to be displayed as the message content
  ///@param timestamp Time at which the message arrived
  ///@param sender A CharSequence to be used for displaying the name of the
  /// sender. Should be <code>null</code> for messages by the current user, in which case
  /// the platform will insert MessagingStyle\#getUserDisplayName().
  /// Should be unique amongst all individuals in the conversation, and should be
  /// consistent during re-posts of the notification.
  ///@deprecated use {@code Message(CharSequence, long, Person)}
  Notification_MessagingStyle_Message(
      jni.JniObject text, int timestamp, jni.JniObject sender)
      : super.fromRef(
            _ctor(text.reference, timestamp, sender.reference).object);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                      ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle_Message__ctor1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.CharSequence text, long timestamp, android.app.Person sender)
  ///
  /// Constructor
  ///@param text A CharSequence to be displayed as the message content
  /// This value must never be {@code null}.
  ///@param timestamp Time at which the message arrived
  ///@param sender The Person who sent the message.
  /// Should be <code>null</code> for messages by the current user, in which case
  /// the platform will insert the user set in {@code MessagingStyle(Person)}.
  ///
  /// The person provided should contain an Icon, set with
  /// Person.Builder\#setIcon(Icon) and also have a name provided
  /// with Person.Builder\#setName(CharSequence). If multiple users have the same
  /// name, consider providing a key with Person.Builder\#setKey(String) in order
  /// to differentiate between the different users.
  ///
  ///
  ///
  /// This value may be {@code null}.
  Notification_MessagingStyle_Message.ctor1(
      jni.JniObject text, int timestamp, Person sender)
      : super.fromRef(
            _ctor1(text.reference, timestamp, sender.reference).object);

  static final _setData = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle_Message__setData")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.MessagingStyle.Message setData(java.lang.String dataMimeType, android.net.Uri dataUri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets a binary blob of data and an associated MIME type for a message. In the case
  /// where the platform doesn't support the MIME type, the original text provided in the
  /// constructor will be used.
  ///@param dataMimeType The MIME type of the content. See
  /// <a href="{@docRoot}notifications/messaging.html"> for the list of supported MIME
  /// types on Android and Android Wear.
  ///@param dataUri The uri containing the content whose type is given by the MIME type.
  /// <p class="note">
  /// <ol>
  ///   <li>Notification Listeners including the System UI need permission to access the
  ///       data the Uri points to. The recommended ways to do this are:</li>
  ///   <li>Store the data in your own ContentProvider, making sure that other apps have
  ///       the correct permission to access your provider. The preferred mechanism for
  ///       providing access is to use per-URI permissions which are temporary and only
  ///       grant access to the receiving application. An easy way to create a
  ///       ContentProvider like this is to use the FileProvider helper class.</li>
  ///   <li>Use the system MediaStore. The MediaStore is primarily aimed at video, audio
  ///       and image MIME types, however beginning with Android 3.0 (API level 11) it can
  ///       also store non-media types (see MediaStore.Files for more info). Files can be
  ///       inserted into the MediaStore using scanFile() after which a content:// style
  ///       Uri suitable for sharing is passed to the provided onScanCompleted() callback.
  ///       Note that once added to the system MediaStore the content is accessible to any
  ///       app on the device.</li>
  /// </ol>
  ///@return this object for method chaining
  Notification_MessagingStyle_Message setData(
          jni.JniString dataMimeType, jni.JniObject dataUri) =>
      Notification_MessagingStyle_Message.fromRef(
          _setData(reference, dataMimeType.reference, dataUri.reference)
              .object);

  static final _getText = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle_Message__getText")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the text to be used for this message, or the fallback text if a type and content
  /// Uri have been set
  jni.JniObject getText() => jni.JniObject.fromRef(_getText(reference).object);

  static final _getTimestamp = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle_Message__getTimestamp")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTimestamp()
  ///
  /// Get the time at which this message arrived
  int getTimestamp() => _getTimestamp(reference).long;

  static final _getExtras = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle_Message__getExtras")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the extras Bundle for this message.
  os_.Bundle getExtras() => os_.Bundle.fromRef(_getExtras(reference).object);

  static final _getSender = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle_Message__getSender")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getSender()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the text used to display the contact's name in the messaging experience
  ///@deprecated use \#getSenderPerson()
  jni.JniObject getSender() =>
      jni.JniObject.fromRef(_getSender(reference).object);

  static final _getSenderPerson = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle_Message__getSenderPerson")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Person getSenderPerson()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the sender associated with this message.
  ///@return This value may be {@code null}.
  Person getSenderPerson() =>
      Person.fromRef(_getSenderPerson(reference).object);

  static final _getDataMimeType = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle_Message__getDataMimeType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getDataMimeType()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the MIME type of the data pointed to by the Uri
  jni.JniString getDataMimeType() =>
      jni.JniString.fromRef(_getDataMimeType(reference).object);

  static final _getDataUri = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_MessagingStyle_Message__getDataUri")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri getDataUri()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the the Uri pointing to the content of the message. Can be null, in which case
  /// {@see \#getText()} is used.
  jni.JniObject getDataUri() =>
      jni.JniObject.fromRef(_getDataUri(reference).object);
}

/// from: android.app.Notification$MediaStyle
///
/// Notification style for media playback notifications.
///
/// In the expanded form, Notification\#bigContentView, up to 5
/// Notification.Actions specified with
/// Notification.Builder\#addAction(Action) addAction will be
/// shown as icon-only pushbuttons, suitable for transport controls. The Bitmap given to
/// Notification.Builder\#setLargeIcon(android.graphics.Bitmap) setLargeIcon() will be
/// treated as album artwork.
///
/// Unlike the other styles provided here, MediaStyle can also modify the standard-size
/// Notification\#contentView; by providing action indices to
/// \#setShowActionsInCompactView(int...) you can promote up to 3 actions to be displayed
/// in the standard view alongside the usual content.
///
/// Notifications created with MediaStyle will have their category set to
/// Notification\#CATEGORY_TRANSPORT CATEGORY_TRANSPORT unless you set a different
/// category using Notification.Builder\#setCategory(String) setCategory().
///
/// Finally, if you attach a android.media.session.MediaSession.Token using
/// android.app.Notification.MediaStyle\#setMediaSession(MediaSession.Token),
/// the System UI can identify this as a notification representing an active media session
/// and respond accordingly (by showing album artwork in the lockscreen, for example).
///
///
/// Starting at android.os.Build.VERSION_CODES\#O Android O any notification that has a
/// media session attached with \#setMediaSession(MediaSession.Token) will be colorized.
/// You can opt-out of this behavior by using Notification.Builder\#setColorized(boolean).
///
///
/// To use this style with your Notification, feed it to
/// Notification.Builder\#setStyle(android.app.Notification.Style) like so:
/// <pre class="prettyprint">
/// Notification noti = new Notification.Builder()
///     .setSmallIcon(R.drawable.ic_stat_player)
///     .setContentTitle(&quot;Track title&quot;)
///     .setContentText(&quot;Artist - Album&quot;)
///     .setLargeIcon(albumArtBitmap))
///     .setStyle(__new Notification.MediaStyle()__
///         .setMediaSession(mySession))
///     .build();
/// </pre>
///@see Notification\#bigContentView
///@see Notification.Builder\#setColorized(boolean)
class Notification_MediaStyle extends Notification_Style {
  Notification_MediaStyle.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Notification_MediaStyle__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  Notification_MediaStyle() : super.fromRef(_ctor().object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification_MediaStyle__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Notification.Builder builder)
  ///
  /// @deprecated use {@code MediaStyle()}.
  Notification_MediaStyle.ctor1(Notification_Builder builder)
      : super.fromRef(_ctor1(builder.reference).object);

  static final _setShowActionsInCompactView = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_MediaStyle__setShowActionsInCompactView")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.MediaStyle setShowActionsInCompactView(int[] actions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Request up to 3 actions (by index in the order of addition) to be shown in the compact
  /// notification view.
  ///@param actions the indices of the actions to show in the compact notification view
  Notification_MediaStyle setShowActionsInCompactView(jni.JniObject actions) =>
      Notification_MediaStyle.fromRef(
          _setShowActionsInCompactView(reference, actions.reference).object);

  static final _setMediaSession = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_MediaStyle__setMediaSession")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.MediaStyle setMediaSession(android.media.session.MediaSession.Token token)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Attach a android.media.session.MediaSession.Token to this Notification
  /// to provide additional playback information and control to the SystemUI.
  Notification_MediaStyle setMediaSession(jni.JniObject token) =>
      Notification_MediaStyle.fromRef(
          _setMediaSession(reference, token.reference).object);
}

/// from: android.app.Notification$InboxStyle
///
/// Helper class for generating large-format notifications that include a list of (up to 5) strings.
///
/// Here's how you'd set the <code>InboxStyle</code> on a notification:
/// <pre class="prettyprint">
/// Notification notif = new Notification.Builder(mContext)
///     .setContentTitle(&quot;5 New mails from &quot; + sender.toString())
///     .setContentText(subject)
///     .setSmallIcon(R.drawable.new_mail)
///     .setLargeIcon(aBitmap)
///     .setStyle(new Notification.InboxStyle()
///         .addLine(str1)
///         .addLine(str2)
///         .setContentTitle(&quot;&quot;)
///         .setSummaryText(&quot;+3 more&quot;))
///     .build();
/// </pre>
///@see Notification\#bigContentView
class Notification_InboxStyle extends Notification_Style {
  Notification_InboxStyle.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Notification_InboxStyle__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  Notification_InboxStyle() : super.fromRef(_ctor().object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification_InboxStyle__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Notification.Builder builder)
  ///
  /// @deprecated use {@code InboxStyle()}.
  Notification_InboxStyle.ctor1(Notification_Builder builder)
      : super.fromRef(_ctor1(builder.reference).object);

  static final _setBigContentTitle = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_InboxStyle__setBigContentTitle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.InboxStyle setBigContentTitle(java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Overrides ContentTitle in the big form of the template.
  /// This defaults to the value passed to setContentTitle().
  Notification_InboxStyle setBigContentTitle(jni.JniObject title) =>
      Notification_InboxStyle.fromRef(
          _setBigContentTitle(reference, title.reference).object);

  static final _setSummaryText = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_InboxStyle__setSummaryText")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.InboxStyle setSummaryText(java.lang.CharSequence cs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the first line of text after the detail section in the big form of the template.
  Notification_InboxStyle setSummaryText(jni.JniObject cs) =>
      Notification_InboxStyle.fromRef(
          _setSummaryText(reference, cs.reference).object);

  static final _addLine = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_InboxStyle__addLine")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.InboxStyle addLine(java.lang.CharSequence cs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Append a line to the digest section of the Inbox notification.
  Notification_InboxStyle addLine(jni.JniObject cs) =>
      Notification_InboxStyle.fromRef(_addLine(reference, cs.reference).object);
}

/// from: android.app.Notification$Extender
///
/// Extender interface for use with Builder\#extend. Extenders may be used to add
/// metadata or change options on a notification builder.
class Notification_Extender extends jni.JniObject {
  Notification_Extender.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _extend = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Extender__extend")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.Notification.Builder extend(android.app.Notification.Builder builder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Apply this extender to a notification builder.
  ///@param builder the builder to be modified.
  ///@return the build object for chaining.
  Notification_Builder extend(Notification_Builder builder) =>
      Notification_Builder.fromRef(
          _extend(reference, builder.reference).object);
}

/// from: android.app.Notification$DecoratedMediaCustomViewStyle
///
/// Notification style for media custom views that are decorated by the system
///
/// Instead of providing a media notification that is completely custom, a developer can set
/// this style and still obtain system decorations like the notification header with the expand
/// affordance and actions.
///
/// Use android.app.Notification.Builder\#setCustomContentView(RemoteViews),
/// android.app.Notification.Builder\#setCustomBigContentView(RemoteViews) and
/// android.app.Notification.Builder\#setCustomHeadsUpContentView(RemoteViews) to set the
/// corresponding custom views to display.
///
/// Contrary to MediaStyle a developer has to opt-in to the colorizing of the
/// notification by using Notification.Builder\#setColorized(boolean).
///
/// To use this style with your Notification, feed it to
/// Notification.Builder\#setStyle(android.app.Notification.Style) like so:
/// <pre class="prettyprint">
/// Notification noti = new Notification.Builder()
///     .setSmallIcon(R.drawable.ic_stat_player)
///     .setLargeIcon(albumArtBitmap))
///     .setCustomContentView(contentView);
///     .setStyle(__new Notification.DecoratedMediaCustomViewStyle()__
///          .setMediaSession(mySession))
///     .build();
/// </pre>
///@see android.app.Notification.DecoratedCustomViewStyle
///@see android.app.Notification.MediaStyle
class Notification_DecoratedMediaCustomViewStyle
    extends Notification_MediaStyle {
  Notification_DecoratedMediaCustomViewStyle.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Notification_DecoratedMediaCustomViewStyle__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  Notification_DecoratedMediaCustomViewStyle() : super.fromRef(_ctor().object);
}

/// from: android.app.Notification$DecoratedCustomViewStyle
///
/// Notification style for custom views that are decorated by the system
///
/// Instead of providing a notification that is completely custom, a developer can set this
/// style and still obtain system decorations like the notification header with the expand
/// affordance and actions.
///
/// Use android.app.Notification.Builder\#setCustomContentView(RemoteViews),
/// android.app.Notification.Builder\#setCustomBigContentView(RemoteViews) and
/// android.app.Notification.Builder\#setCustomHeadsUpContentView(RemoteViews) to set the
/// corresponding custom views to display.
///
/// To use this style with your Notification, feed it to
/// Notification.Builder\#setStyle(android.app.Notification.Style) like so:
/// <pre class="prettyprint">
/// Notification noti = new Notification.Builder()
///     .setSmallIcon(R.drawable.ic_stat_player)
///     .setLargeIcon(albumArtBitmap))
///     .setCustomContentView(contentView);
///     .setStyle(__new Notification.DecoratedCustomViewStyle()__)
///     .build();
/// </pre>
class Notification_DecoratedCustomViewStyle extends Notification_Style {
  Notification_DecoratedCustomViewStyle.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Notification_DecoratedCustomViewStyle__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  Notification_DecoratedCustomViewStyle() : super.fromRef(_ctor().object);
}

/// from: android.app.Notification$CarExtender
///
/// Helper class to add Android Auto extensions to notifications. To create a notification
/// with car extensions:
///
/// <ol>
///  <li>Create an Notification.Builder, setting any desired
///  properties.
///  <li>Create a CarExtender.
///  <li>Set car-specific properties using the {@code add} and {@code set} methods of
///  CarExtender.
///  <li>Call Notification.Builder\#extend(Notification.Extender)
///  to apply the extensions to a notification.
/// </ol>
///
/// <pre class="prettyprint">
/// Notification notification = new Notification.Builder(context)
///         ...
///         .extend(new CarExtender()
///                 .set*(...))
///         .build();
/// </pre>
///
/// Car extensions can be accessed on an existing notification by using the
/// {@code CarExtender(Notification)} constructor, and then using the {@code get} methods
/// to access values.
class Notification_CarExtender extends jni.JniObject {
  Notification_CarExtender.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Notification_CarExtender__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ///
  /// Create a CarExtender with default options.
  Notification_CarExtender() : super.fromRef(_ctor().object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification_CarExtender__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Notification notif)
  ///
  /// Create a CarExtender from the CarExtender options of an existing Notification.
  ///@param notif The notification from which to copy options.
  Notification_CarExtender.ctor1(Notification notif)
      : super.fromRef(_ctor1(notif.reference).object);

  static final _extend = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_CarExtender__extend")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder extend(android.app.Notification.Builder builder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Apply car extensions to a notification that is being built. This is typically called by
  /// the Notification.Builder\#extend(Notification.Extender)
  /// method of Notification.Builder.
  Notification_Builder extend(Notification_Builder builder) =>
      Notification_Builder.fromRef(
          _extend(reference, builder.reference).object);

  static final _setColor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Notification_CarExtender__setColor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.CarExtender setColor(int color)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the accent color to use when Android Auto presents the notification.
  ///
  /// Android Auto uses the color set with Notification.Builder\#setColor(int)
  /// to accent the displayed notification. However, not all colors are acceptable in an
  /// automotive setting. This method can be used to override the color provided in the
  /// notification in such a situation.
  Notification_CarExtender setColor(int color) =>
      Notification_CarExtender.fromRef(_setColor(reference, color).object);

  static final _getColor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification_CarExtender__getColor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getColor()
  ///
  /// Gets the accent color.
  ///@see \#setColor
  int getColor() => _getColor(reference).integer;

  static final _setLargeIcon = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_CarExtender__setLargeIcon")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.CarExtender setLargeIcon(android.graphics.Bitmap largeIcon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the large icon of the car notification.
  ///
  /// If no large icon is set in the extender, Android Auto will display the icon
  /// specified by Notification.Builder\#setLargeIcon(android.graphics.Bitmap)
  ///@param largeIcon The large icon to use in the car notification.
  ///@return This object for method chaining.
  Notification_CarExtender setLargeIcon(jni.JniObject largeIcon) =>
      Notification_CarExtender.fromRef(
          _setLargeIcon(reference, largeIcon.reference).object);

  static final _getLargeIcon = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_CarExtender__getLargeIcon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap getLargeIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the large icon used in this car notification, or null if no icon has been set.
  ///@return The large icon for the car notification.
  ///@see CarExtender\#setLargeIcon
  jni.JniObject getLargeIcon() =>
      jni.JniObject.fromRef(_getLargeIcon(reference).object);

  static final _setUnreadConversation = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_CarExtender__setUnreadConversation")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.CarExtender setUnreadConversation(android.app.Notification.CarExtender.UnreadConversation unreadConversation)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the unread conversation in a message notification.
  ///@param unreadConversation The unread part of the conversation this notification conveys.
  ///@return This object for method chaining.
  Notification_CarExtender setUnreadConversation(
          Notification_CarExtender_UnreadConversation unreadConversation) =>
      Notification_CarExtender.fromRef(
          _setUnreadConversation(reference, unreadConversation.reference)
              .object);

  static final _getUnreadConversation = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_CarExtender__getUnreadConversation")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.CarExtender.UnreadConversation getUnreadConversation()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the unread conversation conveyed by this notification.
  ///@see \#setUnreadConversation(UnreadConversation)
  Notification_CarExtender_UnreadConversation getUnreadConversation() =>
      Notification_CarExtender_UnreadConversation.fromRef(
          _getUnreadConversation(reference).object);
}

/// from: android.app.Notification$CarExtender$UnreadConversation
///
/// A class which holds the unread messages from a conversation.
class Notification_CarExtender_UnreadConversation extends jni.JniObject {
  Notification_CarExtender_UnreadConversation.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int64)>>(
          "Notification_CarExtender_UnreadConversation__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int)>();

  /// from: void <init>(java.lang.String[] messages, android.app.RemoteInput remoteInput, android.app.PendingIntent replyPendingIntent, android.app.PendingIntent readPendingIntent, java.lang.String[] participants, long latestTimestamp)
  Notification_CarExtender_UnreadConversation(
      jni.JniObject messages,
      RemoteInput remoteInput,
      PendingIntent replyPendingIntent,
      PendingIntent readPendingIntent,
      jni.JniObject participants,
      int latestTimestamp)
      : super.fromRef(_ctor(
                messages.reference,
                remoteInput.reference,
                replyPendingIntent.reference,
                readPendingIntent.reference,
                participants.reference,
                latestTimestamp)
            .object);

  static final _getMessages = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_CarExtender_UnreadConversation__getMessages")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getMessages()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the list of messages conveyed by this notification.
  jni.JniObject getMessages() =>
      jni.JniObject.fromRef(_getMessages(reference).object);

  static final _getRemoteInput = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_CarExtender_UnreadConversation__getRemoteInput")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.RemoteInput getRemoteInput()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the remote input that will be used to convey the response to a message list, or
  /// null if no such remote input exists.
  RemoteInput getRemoteInput() =>
      RemoteInput.fromRef(_getRemoteInput(reference).object);

  static final _getReplyPendingIntent = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_CarExtender_UnreadConversation__getReplyPendingIntent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent getReplyPendingIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the pending intent that will be triggered when the user replies to this
  /// notification.
  PendingIntent getReplyPendingIntent() =>
      PendingIntent.fromRef(_getReplyPendingIntent(reference).object);

  static final _getReadPendingIntent = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_CarExtender_UnreadConversation__getReadPendingIntent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent getReadPendingIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the pending intent that Android Auto will send after it reads aloud all messages
  /// in this object's message list.
  PendingIntent getReadPendingIntent() =>
      PendingIntent.fromRef(_getReadPendingIntent(reference).object);

  static final _getParticipants = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_CarExtender_UnreadConversation__getParticipants")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getParticipants()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the participants in the conversation.
  jni.JniObject getParticipants() =>
      jni.JniObject.fromRef(_getParticipants(reference).object);

  static final _getParticipant = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_CarExtender_UnreadConversation__getParticipant")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getParticipant()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the firs participant in the conversation.
  jni.JniString getParticipant() =>
      jni.JniString.fromRef(_getParticipant(reference).object);

  static final _getLatestTimestamp = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_CarExtender_UnreadConversation__getLatestTimestamp")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getLatestTimestamp()
  ///
  /// Gets the timestamp of the conversation.
  int getLatestTimestamp() => _getLatestTimestamp(reference).long;
}

/// from: android.app.Notification$CarExtender$Builder
///
/// Builder class for CarExtender.UnreadConversation objects.
class Notification_CarExtender_Builder extends jni.JniObject {
  Notification_CarExtender_Builder.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_CarExtender_Builder__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String name)
  ///
  /// Constructs a new builder for CarExtender.UnreadConversation.
  ///@param name The name of the other participant in the conversation.
  Notification_CarExtender_Builder(jni.JniString name)
      : super.fromRef(_ctor(name.reference).object);

  static final _addMessage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_CarExtender_Builder__addMessage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.CarExtender.Builder addMessage(java.lang.String message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Appends a new unread message to the list of messages for this conversation.
  ///
  /// The messages should be added from oldest to newest.
  ///@param message The text of the new unread message.
  ///@return This object for method chaining.
  Notification_CarExtender_Builder addMessage(jni.JniString message) =>
      Notification_CarExtender_Builder.fromRef(
          _addMessage(reference, message.reference).object);

  static final _setReplyAction = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_CarExtender_Builder__setReplyAction")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.CarExtender.Builder setReplyAction(android.app.PendingIntent pendingIntent, android.app.RemoteInput remoteInput)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the pending intent and remote input which will convey the reply to this
  /// notification.
  ///@param pendingIntent The pending intent which will be triggered on a reply.
  ///@param remoteInput The remote input parcelable which will carry the reply.
  ///@return This object for method chaining.
  ///@see CarExtender.UnreadConversation\#getRemoteInput
  ///@see CarExtender.UnreadConversation\#getReplyPendingIntent
  Notification_CarExtender_Builder setReplyAction(
          PendingIntent pendingIntent, RemoteInput remoteInput) =>
      Notification_CarExtender_Builder.fromRef(_setReplyAction(
              reference, pendingIntent.reference, remoteInput.reference)
          .object);

  static final _setReadPendingIntent = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_CarExtender_Builder__setReadPendingIntent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.CarExtender.Builder setReadPendingIntent(android.app.PendingIntent pendingIntent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the pending intent that will be sent once the messages in this notification
  /// are read.
  ///@param pendingIntent The pending intent to use.
  ///@return This object for method chaining.
  Notification_CarExtender_Builder setReadPendingIntent(
          PendingIntent pendingIntent) =>
      Notification_CarExtender_Builder.fromRef(
          _setReadPendingIntent(reference, pendingIntent.reference).object);

  static final _setLatestTimestamp = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64)>>(
          "Notification_CarExtender_Builder__setLatestTimestamp")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.CarExtender.Builder setLatestTimestamp(long timestamp)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the timestamp of the most recent message in an unread conversation.
  ///
  /// If a messaging notification has been posted by your application and has not
  /// yet been cancelled, posting a later notification with the same id and tag
  /// but without a newer timestamp may result in Android Auto not displaying a
  /// heads up notification for the later notification.
  ///@param timestamp The timestamp of the most recent message in the conversation.
  ///@return This object for method chaining.
  Notification_CarExtender_Builder setLatestTimestamp(int timestamp) =>
      Notification_CarExtender_Builder.fromRef(
          _setLatestTimestamp(reference, timestamp).object);

  static final _build = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_CarExtender_Builder__build")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.CarExtender.UnreadConversation build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Builds a new unread conversation object.
  ///@return The new unread conversation object.
  Notification_CarExtender_UnreadConversation build() =>
      Notification_CarExtender_UnreadConversation.fromRef(
          _build(reference).object);
}

/// from: android.app.Notification$Builder
///
/// Builder class for Notification objects.
///
/// Provides a convenient way to set the various fields of a Notification and generate
/// content views using the platform's notification layout template. If your app supports
/// versions of Android as old as API level 4, you can instead use
/// android.support.v4.app.NotificationCompat.Builder NotificationCompat.Builder,
/// available in the <a href="{@docRoot}tools/extras/support-library.html">Android Support
/// library</a>.
///
/// Example:
///
/// <pre class="prettyprint">
/// Notification noti = new Notification.Builder(mContext)
///         .setContentTitle(&quot;New mail from &quot; + sender.toString())
///         .setContentText(subject)
///         .setSmallIcon(R.drawable.new_mail)
///         .setLargeIcon(aBitmap)
///         .build();
/// </pre>
class Notification_Builder extends jni.JniObject {
  Notification_Builder.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context, java.lang.String channelId)
  ///
  /// Constructs a new Builder with the defaults:
  ///@param context A Context that will be used by the Builder to construct the
  ///            RemoteViews. The Context will not be held past the lifetime of this Builder
  ///            object.
  ///@param channelId The constructed Notification will be posted on this
  ///            NotificationChannel. To use a NotificationChannel, it must first be
  ///            created using NotificationManager\#createNotificationChannel.
  Notification_Builder(content_.Context context, jni.JniString channelId)
      : super.fromRef(_ctor(context.reference, channelId.reference).object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  ///
  /// @deprecated use Notification.Builder\#Notification.Builder(Context, String)
  /// instead. All posted Notifications must specify a NotificationChannel Id.
  Notification_Builder.ctor1(content_.Context context)
      : super.fromRef(_ctor1(context.reference).object);

  static final _setShortcutId = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__setShortcutId")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setShortcutId(java.lang.String shortcutId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If this notification is duplicative of a Launcher shortcut, sets the
  /// ShortcutInfo\#getId() id of the shortcut, in case the Launcher wants to hide
  /// the shortcut.
  ///
  /// This field will be ignored by Launchers that don't support badging, don't show
  /// notification content, or don't show android.content.pm.ShortcutManager shortcuts.
  ///@param shortcutId the ShortcutInfo\#getId() id of the shortcut this notification
  ///                   supersedes
  Notification_Builder setShortcutId(jni.JniString shortcutId) =>
      Notification_Builder.fromRef(
          _setShortcutId(reference, shortcutId.reference).object);

  static final _setBadgeIconType = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Notification_Builder__setBadgeIconType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setBadgeIconType(int icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets which icon to display as a badge for this notification.
  ///
  /// Must be one of \#BADGE_ICON_NONE, \#BADGE_ICON_SMALL,
  /// \#BADGE_ICON_LARGE.
  ///
  /// Note: This value might be ignored, for launchers that don't support badge icons.
  Notification_Builder setBadgeIconType(int icon) =>
      Notification_Builder.fromRef(_setBadgeIconType(reference, icon).object);

  static final _setGroupAlertBehavior = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Notification_Builder__setGroupAlertBehavior")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setGroupAlertBehavior(int groupAlertBehavior)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the group alert behavior for this notification. Use this method to mute this
  /// notification if alerts for this notification's group should be handled by a different
  /// notification. This is only applicable for notifications that belong to a
  /// \#setGroup(String) group. This must be called on all notifications you want to
  /// mute. For example, if you want only the summary of your group to make noise, all
  /// children in the group should have the group alert behavior \#GROUP_ALERT_SUMMARY.
  ///
  ///  The default value is \#GROUP_ALERT_ALL.
  ///
  ///@param groupAlertBehavior Value is android.app.Notification\#GROUP_ALERT_ALL, android.app.Notification\#GROUP_ALERT_CHILDREN, or android.app.Notification\#GROUP_ALERT_SUMMARY
  Notification_Builder setGroupAlertBehavior(int groupAlertBehavior) =>
      Notification_Builder.fromRef(
          _setGroupAlertBehavior(reference, groupAlertBehavior).object);

  static final _setChannelId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__setChannelId")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setChannelId(java.lang.String channelId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specifies the channel the notification should be delivered on.
  Notification_Builder setChannelId(jni.JniString channelId) =>
      Notification_Builder.fromRef(
          _setChannelId(reference, channelId.reference).object);

  static final _setTimeoutAfter = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("Notification_Builder__setTimeoutAfter")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setTimeoutAfter(long durationMs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specifies a duration in milliseconds after which this notification should be canceled,
  /// if it is not already canceled.
  Notification_Builder setTimeoutAfter(int durationMs) =>
      Notification_Builder.fromRef(
          _setTimeoutAfter(reference, durationMs).object);

  static final _setWhen = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("Notification_Builder__setWhen")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setWhen(long when)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a timestamp pertaining to the notification (usually the time the event occurred).
  ///
  /// For apps targeting android.os.Build.VERSION_CODES\#N and above, this time is not
  /// shown anymore by default and must be opted into by using
  /// android.app.Notification.Builder\#setShowWhen(boolean)
  ///@see Notification\#when
  Notification_Builder setWhen(int when) =>
      Notification_Builder.fromRef(_setWhen(reference, when).object);

  static final _setShowWhen = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Notification_Builder__setShowWhen")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setShowWhen(boolean show)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Control whether the timestamp set with \#setWhen(long) setWhen is shown
  /// in the content view.
  /// For apps targeting android.os.Build.VERSION_CODES\#N and above, this defaults to
  /// {@code false}. For earlier apps, the default is {@code true}.
  Notification_Builder setShowWhen(bool show0) => Notification_Builder.fromRef(
      _setShowWhen(reference, show0 ? 1 : 0).object);

  static final _setUsesChronometer = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Notification_Builder__setUsesChronometer")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setUsesChronometer(boolean b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Show the Notification\#when field as a stopwatch.
  ///
  /// Instead of presenting <code>when</code> as a timestamp, the notification will show an
  /// automatically updating display of the minutes and seconds since <code>when</code>.
  ///
  /// Useful when showing an elapsed time (like an ongoing phone call).
  ///
  /// The counter can also be set to count down to <code>when</code> when using
  /// \#setChronometerCountDown(boolean).
  ///@see android.widget.Chronometer
  ///@see Notification\#when
  ///@see \#setChronometerCountDown(boolean)
  Notification_Builder setUsesChronometer(bool b) =>
      Notification_Builder.fromRef(
          _setUsesChronometer(reference, b ? 1 : 0).object);

  static final _setChronometerCountDown = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Notification_Builder__setChronometerCountDown")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setChronometerCountDown(boolean countDown)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the Chronometer to count down instead of counting up.
  ///
  /// This is only relevant if \#setUsesChronometer(boolean) has been set to true.
  /// If it isn't set the chronometer will count up.
  ///@see \#setUsesChronometer(boolean)
  Notification_Builder setChronometerCountDown(bool countDown) =>
      Notification_Builder.fromRef(
          _setChronometerCountDown(reference, countDown ? 1 : 0).object);

  static final _setSmallIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Notification_Builder__setSmallIcon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setSmallIcon(int icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the small icon resource, which will be used to represent the notification in the
  /// status bar.
  ///
  ///
  /// The platform template for the expanded view will draw this icon in the left, unless a
  /// \#setLargeIcon(Bitmap) large icon has also been specified, in which case the small
  /// icon will be moved to the right-hand side.
  ///@param icon A resource ID in the application's package of the drawable to use.
  ///@see Notification\#icon
  Notification_Builder setSmallIcon(int icon) =>
      Notification_Builder.fromRef(_setSmallIcon(reference, icon).object);

  static final _setSmallIcon1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Notification_Builder__setSmallIcon1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.app.Notification.Builder setSmallIcon(int icon, int level)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A variant of \#setSmallIcon(int) setSmallIcon(int) that takes an additional
  /// level parameter for when the icon is a android.graphics.drawable.LevelListDrawable LevelListDrawable.
  ///@param icon A resource ID in the application's package of the drawable to use.
  ///@param level The level to use for the icon.
  ///@see Notification\#icon
  ///@see Notification\#iconLevel
  Notification_Builder setSmallIcon1(int icon, int level) =>
      Notification_Builder.fromRef(
          _setSmallIcon1(reference, icon, level).object);

  static final _setSmallIcon2 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__setSmallIcon2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setSmallIcon(android.graphics.drawable.Icon icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the small icon, which will be used to represent the notification in the
  /// status bar and content view (unless overriden there by a
  /// \#setLargeIcon(Bitmap) large icon).
  ///@param icon An Icon object to use.
  ///@see Notification\#icon
  Notification_Builder setSmallIcon2(jni.JniObject icon) =>
      Notification_Builder.fromRef(
          _setSmallIcon2(reference, icon.reference).object);

  static final _setContentTitle = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__setContentTitle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setContentTitle(java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the first line of text in the platform notification template.
  Notification_Builder setContentTitle(jni.JniObject title) =>
      Notification_Builder.fromRef(
          _setContentTitle(reference, title.reference).object);

  static final _setContentText = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__setContentText")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setContentText(java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the second line of text in the platform notification template.
  Notification_Builder setContentText(jni.JniObject text) =>
      Notification_Builder.fromRef(
          _setContentText(reference, text.reference).object);

  static final _setSubText = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__setSubText")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setSubText(java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// This provides some additional information that is displayed in the notification. No
  /// guarantees are given where exactly it is displayed.
  ///
  /// This information should only be provided if it provides an essential
  /// benefit to the understanding of the notification. The more text you provide the
  /// less readable it becomes. For example, an email client should only provide the account
  /// name here if more than one email account has been added.
  ///
  ///
  /// As of android.os.Build.VERSION_CODES\#N this information is displayed in the
  /// notification header area.
  ///
  /// On Android versions before android.os.Build.VERSION_CODES\#N
  /// this will be shown in the third line of text in the platform notification template.
  /// You should not be using \#setProgress(int, int, boolean) at the
  /// same time on those versions; they occupy the same place.
  ///
  ///
  Notification_Builder setSubText(jni.JniObject text) =>
      Notification_Builder.fromRef(
          _setSubText(reference, text.reference).object);

  static final _setSettingsText = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__setSettingsText")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setSettingsText(java.lang.CharSequence text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Provides text that will appear as a link to your application's settings.
  ///
  /// This text does not appear within notification Style templates but may
  /// appear when the user uses an affordance to learn more about the notification.
  /// Additionally, this text will not appear unless you provide a valid link target by
  /// handling \#INTENT_CATEGORY_NOTIFICATION_PREFERENCES.
  ///
  /// This text is meant to be concise description about what the user can customize
  /// when they click on this link. The recommended maximum length is 40 characters.
  ///@param text
  ///@return
  Notification_Builder setSettingsText(jni.JniObject text) =>
      Notification_Builder.fromRef(
          _setSettingsText(reference, text.reference).object);

  static final _setRemoteInputHistory = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__setRemoteInputHistory")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setRemoteInputHistory(java.lang.CharSequence[] text)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the remote input history.
  ///
  /// This should be set to the most recent inputs that have been sent
  /// through a RemoteInput of this Notification and cleared once the it is no
  /// longer relevant (e.g. for chat notifications once the other party has responded).
  ///
  /// The most recent input must be stored at the 0 index, the second most recent at the
  /// 1 index, etc. Note that the system will limit both how far back the inputs will be shown
  /// and how much of each individual input is shown.
  ///
  /// Note: The reply text will only be shown on notifications that have least one action
  /// with a {@code RemoteInput}.
  ///
  Notification_Builder setRemoteInputHistory(jni.JniObject text) =>
      Notification_Builder.fromRef(
          _setRemoteInputHistory(reference, text.reference).object);

  static final _setNumber = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Notification_Builder__setNumber")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setNumber(int number)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the number of items this notification represents. May be displayed as a badge count
  /// for Launchers that support badging.
  Notification_Builder setNumber(int number) =>
      Notification_Builder.fromRef(_setNumber(reference, number).object);

  static final _setContentInfo = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__setContentInfo")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setContentInfo(java.lang.CharSequence info)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A small piece of additional information pertaining to this notification.
  ///
  /// The platform template will draw this on the last line of the notification, at the far
  /// right (to the right of a smallIcon if it has been placed there).
  ///@deprecated use \#setSubText(CharSequence) instead to set a text in the header.
  /// For legacy apps targeting a version below android.os.Build.VERSION_CODES\#N this
  /// field will still show up, but the subtext will take precedence.
  Notification_Builder setContentInfo(jni.JniObject info) =>
      Notification_Builder.fromRef(
          _setContentInfo(reference, info.reference).object);

  static final _setProgress = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Uint8)>>("Notification_Builder__setProgress")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public android.app.Notification.Builder setProgress(int max, int progress, boolean indeterminate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the progress this notification represents.
  ///
  /// The platform template will represent this using a ProgressBar.
  Notification_Builder setProgress(int max, int progress, bool indeterminate) =>
      Notification_Builder.fromRef(
          _setProgress(reference, max, progress, indeterminate ? 1 : 0).object);

  static final _setContent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__setContent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setContent(android.widget.RemoteViews views)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Supply a custom RemoteViews to use instead of the platform template.
  ///
  /// Use \#setCustomContentView(RemoteViews) instead.
  Notification_Builder setContent(jni.JniObject views) =>
      Notification_Builder.fromRef(
          _setContent(reference, views.reference).object);

  static final _setCustomContentView = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__setCustomContentView")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setCustomContentView(android.widget.RemoteViews contentView)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Supply custom RemoteViews to use instead of the platform template.
  ///
  /// This will override the layout that would otherwise be constructed by this Builder
  /// object.
  Notification_Builder setCustomContentView(jni.JniObject contentView) =>
      Notification_Builder.fromRef(
          _setCustomContentView(reference, contentView.reference).object);

  static final _setCustomBigContentView = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__setCustomBigContentView")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setCustomBigContentView(android.widget.RemoteViews contentView)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Supply custom RemoteViews to use instead of the platform template in the expanded form.
  ///
  /// This will override the expanded layout that would otherwise be constructed by this
  /// Builder object.
  Notification_Builder setCustomBigContentView(jni.JniObject contentView) =>
      Notification_Builder.fromRef(
          _setCustomBigContentView(reference, contentView.reference).object);

  static final _setCustomHeadsUpContentView = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__setCustomHeadsUpContentView")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setCustomHeadsUpContentView(android.widget.RemoteViews contentView)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Supply custom RemoteViews to use instead of the platform template in the heads up dialog.
  ///
  /// This will override the heads-up layout that would otherwise be constructed by this
  /// Builder object.
  Notification_Builder setCustomHeadsUpContentView(jni.JniObject contentView) =>
      Notification_Builder.fromRef(
          _setCustomHeadsUpContentView(reference, contentView.reference)
              .object);

  static final _setContentIntent = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__setContentIntent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setContentIntent(android.app.PendingIntent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Supply a PendingIntent to be sent when the notification is clicked.
  ///
  /// As of android.os.Build.VERSION_CODES\#HONEYCOMB, if this field is unset and you
  /// have specified a custom RemoteViews with \#setContent(RemoteViews), you can use
  /// RemoteViews\#setOnClickPendingIntent RemoteViews.setOnClickPendingIntent(int,PendingIntent)
  /// to assign PendingIntents to individual views in that custom layout (i.e., to create
  /// clickable buttons inside the notification view).
  ///@see Notification\#contentIntent Notification.contentIntent
  Notification_Builder setContentIntent(PendingIntent intent) =>
      Notification_Builder.fromRef(
          _setContentIntent(reference, intent.reference).object);

  static final _setDeleteIntent = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__setDeleteIntent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setDeleteIntent(android.app.PendingIntent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Supply a PendingIntent to send when the notification is cleared explicitly by the user.
  ///@see Notification\#deleteIntent
  Notification_Builder setDeleteIntent(PendingIntent intent) =>
      Notification_Builder.fromRef(
          _setDeleteIntent(reference, intent.reference).object);

  static final _setFullScreenIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Notification_Builder__setFullScreenIntent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setFullScreenIntent(android.app.PendingIntent intent, boolean highPriority)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// An intent to launch instead of posting the notification to the status bar.
  /// Only for use with extremely high-priority notifications demanding the user's
  /// <strong>immediate</strong> attention, such as an incoming phone call or
  /// alarm clock that the user has explicitly set to a particular time.
  /// If this facility is used for something else, please give the user an option
  /// to turn it off and use a normal notification, as this can be extremely
  /// disruptive.
  ///
  ///
  /// The system UI may choose to display a heads-up notification, instead of
  /// launching this intent, while the user is using the device.
  ///
  ///
  ///@param intent The pending intent to launch.
  ///@param highPriority Passing true will cause this notification to be sent
  ///          even if other notifications are suppressed.
  ///@see Notification\#fullScreenIntent
  Notification_Builder setFullScreenIntent(
          PendingIntent intent, bool highPriority) =>
      Notification_Builder.fromRef(_setFullScreenIntent(
              reference, intent.reference, highPriority ? 1 : 0)
          .object);

  static final _setTicker = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__setTicker")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setTicker(java.lang.CharSequence tickerText)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the "ticker" text which is sent to accessibility services.
  ///@see Notification\#tickerText
  Notification_Builder setTicker(jni.JniObject tickerText) =>
      Notification_Builder.fromRef(
          _setTicker(reference, tickerText.reference).object);

  static final _setTicker1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__setTicker1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setTicker(java.lang.CharSequence tickerText, android.widget.RemoteViews views)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obsolete version of \#setTicker(CharSequence).
  Notification_Builder setTicker1(
          jni.JniObject tickerText, jni.JniObject views) =>
      Notification_Builder.fromRef(
          _setTicker1(reference, tickerText.reference, views.reference).object);

  static final _setLargeIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__setLargeIcon")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setLargeIcon(android.graphics.Bitmap b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a large icon to the notification content view.
  ///
  /// In the platform template, this image will be shown on the left of the notification view
  /// in place of the \#setSmallIcon(Icon) small icon (which will be placed in a small
  /// badge atop the large icon).
  Notification_Builder setLargeIcon(jni.JniObject b) =>
      Notification_Builder.fromRef(
          _setLargeIcon(reference, b.reference).object);

  static final _setLargeIcon1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__setLargeIcon1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setLargeIcon(android.graphics.drawable.Icon icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a large icon to the notification content view.
  ///
  /// In the platform template, this image will be shown on the left of the notification view
  /// in place of the \#setSmallIcon(Icon) small icon (which will be placed in a small
  /// badge atop the large icon).
  Notification_Builder setLargeIcon1(jni.JniObject icon) =>
      Notification_Builder.fromRef(
          _setLargeIcon1(reference, icon.reference).object);

  static final _setSound = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__setSound")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setSound(android.net.Uri sound)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the sound to play.
  ///
  /// It will be played using the \#AUDIO_ATTRIBUTES_DEFAULT default audio attributes
  /// for notifications.
  ///@deprecated use NotificationChannel\#setSound(Uri, AudioAttributes) instead.
  Notification_Builder setSound(jni.JniObject sound) =>
      Notification_Builder.fromRef(
          _setSound(reference, sound.reference).object);

  static final _setSound1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Notification_Builder__setSound1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setSound(android.net.Uri sound, int streamType)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the sound to play, along with a specific stream on which to play it.
  ///
  /// See android.media.AudioManager for the <code>STREAM_</code> constants.
  ///@deprecated use NotificationChannel\#setSound(Uri, AudioAttributes).
  Notification_Builder setSound1(jni.JniObject sound, int streamType) =>
      Notification_Builder.fromRef(
          _setSound1(reference, sound.reference, streamType).object);

  static final _setSound2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__setSound2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setSound(android.net.Uri sound, android.media.AudioAttributes audioAttributes)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the sound to play, along with specific AudioAttributes audio attributes to
  /// use during playback.
  ///@deprecated use NotificationChannel\#setSound(Uri, AudioAttributes) instead.
  ///@see Notification\#sound
  Notification_Builder setSound2(
          jni.JniObject sound, jni.JniObject audioAttributes) =>
      Notification_Builder.fromRef(
          _setSound2(reference, sound.reference, audioAttributes.reference)
              .object);

  static final _setVibrate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__setVibrate")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setVibrate(long[] pattern)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the vibration pattern to use.
  ///
  /// See android.os.Vibrator\#vibrate(long[], int) for a discussion of the
  /// <code>pattern</code> parameter.
  ///
  ///
  /// A notification that vibrates is more likely to be presented as a heads-up notification.
  ///
  ///
  ///@deprecated use NotificationChannel\#setVibrationPattern(long[]) instead.
  ///@see Notification\#vibrate
  Notification_Builder setVibrate(jni.JniObject pattern) =>
      Notification_Builder.fromRef(
          _setVibrate(reference, pattern.reference).object);

  static final _setLights = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32)>>("Notification_Builder__setLights")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public android.app.Notification.Builder setLights(int argb, int onMs, int offMs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the desired color for the indicator LED on the device, as well as the
  /// blink duty cycle (specified in milliseconds).
  ///
  ///
  /// Not all devices will honor all (or even any) of these values.
  ///@deprecated use NotificationChannel\#enableLights(boolean) instead.
  ///@see Notification\#ledARGB
  ///@see Notification\#ledOnMS
  ///@see Notification\#ledOffMS
  Notification_Builder setLights(int argb, int onMs, int offMs) =>
      Notification_Builder.fromRef(
          _setLights(reference, argb, onMs, offMs).object);

  static final _setOngoing = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Notification_Builder__setOngoing")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setOngoing(boolean ongoing)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether this is an "ongoing" notification.
  ///
  ///
  /// Ongoing notifications cannot be dismissed by the user, so your application or service
  /// must take care of canceling them.
  ///
  ///
  /// They are typically used to indicate a background task that the user is actively engaged
  /// with (e.g., playing music) or is pending in some way and therefore occupying the device
  /// (e.g., a file download, sync operation, active network connection).
  ///@see Notification\#FLAG_ONGOING_EVENT
  ///@see Service\#setForeground(boolean)
  Notification_Builder setOngoing(bool ongoing) => Notification_Builder.fromRef(
      _setOngoing(reference, ongoing ? 1 : 0).object);

  static final _setColorized = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Notification_Builder__setColorized")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setColorized(boolean colorize)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether this notification should be colorized. When set, the color set with
  /// \#setColor(int) will be used as the background color of this notification.
  ///
  /// This should only be used for high priority ongoing tasks like navigation, an ongoing
  /// call, or other similarly high-priority events for the user.
  ///
  /// For most styles, the coloring will only be applied if the notification is for a
  /// foreground service notification.
  /// However, for MediaStyle and DecoratedMediaCustomViewStyle notifications
  /// that have a media session attached there is no such requirement.
  ///@see Builder\#setColor(int)
  ///@see MediaStyle\#setMediaSession(MediaSession.Token)
  Notification_Builder setColorized(bool colorize) =>
      Notification_Builder.fromRef(
          _setColorized(reference, colorize ? 1 : 0).object);

  static final _setOnlyAlertOnce = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Notification_Builder__setOnlyAlertOnce")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setOnlyAlertOnce(boolean onlyAlertOnce)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set this flag if you would only like the sound, vibrate
  /// and ticker to be played if the notification is not already showing.
  ///@see Notification\#FLAG_ONLY_ALERT_ONCE
  Notification_Builder setOnlyAlertOnce(bool onlyAlertOnce) =>
      Notification_Builder.fromRef(
          _setOnlyAlertOnce(reference, onlyAlertOnce ? 1 : 0).object);

  static final _setAutoCancel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Notification_Builder__setAutoCancel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setAutoCancel(boolean autoCancel)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Make this notification automatically dismissed when the user touches it.
  ///@see Notification\#FLAG_AUTO_CANCEL
  Notification_Builder setAutoCancel(bool autoCancel) =>
      Notification_Builder.fromRef(
          _setAutoCancel(reference, autoCancel ? 1 : 0).object);

  static final _setLocalOnly = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Notification_Builder__setLocalOnly")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setLocalOnly(boolean localOnly)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether or not this notification should not bridge to other devices.
  ///
  /// Some notifications can be bridged to other devices for remote display.
  /// This hint can be set to recommend this notification not be bridged.
  Notification_Builder setLocalOnly(bool localOnly) =>
      Notification_Builder.fromRef(
          _setLocalOnly(reference, localOnly ? 1 : 0).object);

  static final _setDefaults = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Notification_Builder__setDefaults")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setDefaults(int defaults)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set which notification properties will be inherited from system defaults.
  ///
  /// The value should be one or more of the following fields combined with
  /// bitwise-or:
  /// \#DEFAULT_SOUND, \#DEFAULT_VIBRATE, \#DEFAULT_LIGHTS.
  ///
  /// For all default values, use \#DEFAULT_ALL.
  ///@deprecated use NotificationChannel\#enableVibration(boolean) and
  /// NotificationChannel\#enableLights(boolean) and
  /// NotificationChannel\#setSound(Uri, AudioAttributes) instead.
  Notification_Builder setDefaults(int defaults) =>
      Notification_Builder.fromRef(_setDefaults(reference, defaults).object);

  static final _setPriority = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Notification_Builder__setPriority")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setPriority(int pri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the priority of this notification.
  ///@see Notification\#priority
  ///@deprecated use NotificationChannel\#setImportance(int) instead.
  ///@param pri Value is android.app.Notification\#PRIORITY_DEFAULT, android.app.Notification\#PRIORITY_LOW, android.app.Notification\#PRIORITY_MIN, android.app.Notification\#PRIORITY_HIGH, or android.app.Notification\#PRIORITY_MAX
  Notification_Builder setPriority(int pri) =>
      Notification_Builder.fromRef(_setPriority(reference, pri).object);

  static final _setCategory = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__setCategory")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setCategory(java.lang.String category)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the notification category.
  ///@see Notification\#category
  Notification_Builder setCategory(jni.JniString category) =>
      Notification_Builder.fromRef(
          _setCategory(reference, category.reference).object);

  static final _addPerson = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__addPerson")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder addPerson(java.lang.String uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a person that is relevant to this notification.
  ///
  /// <P>
  /// Depending on user preferences, this annotation may allow the notification to pass
  /// through interruption filters, if this notification is of category \#CATEGORY_CALL
  /// or \#CATEGORY_MESSAGE. The addition of people may also cause this notification to
  /// appear more prominently in the user interface.
  /// </P>
  ///
  /// <P>
  /// The person should be specified by the {@code String} representation of a
  /// android.provider.ContactsContract.Contacts\#CONTENT_LOOKUP_URI.
  /// </P>
  ///
  /// <P>The system will also attempt to resolve {@code mailto:} and {@code tel:} schema
  /// URIs.  The path part of these URIs must exist in the contacts database, in the
  /// appropriate column, or the reference will be discarded as invalid. Telephone schema
  /// URIs will be resolved by android.provider.ContactsContract.PhoneLookup.
  /// It is also possible to provide a URI with the schema {@code name:} in order to uniquely
  /// identify a person without an entry in the contacts database.
  /// </P>
  ///@param uri A URI for the person.
  ///@see Notification\#EXTRA_PEOPLE
  ///@deprecated use \#addPerson(Person)
  Notification_Builder addPerson(jni.JniString uri) =>
      Notification_Builder.fromRef(_addPerson(reference, uri.reference).object);

  static final _addPerson1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__addPerson1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder addPerson(android.app.Person person)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a person that is relevant to this notification.
  ///
  /// <P>
  /// Depending on user preferences, this annotation may allow the notification to pass
  /// through interruption filters, if this notification is of category \#CATEGORY_CALL
  /// or \#CATEGORY_MESSAGE. The addition of people may also cause this notification to
  /// appear more prominently in the user interface.
  /// </P>
  ///
  /// <P>
  /// A person should usually contain a uri in order to benefit from the ranking boost.
  /// However, even if no uri is provided, it's beneficial to provide other people in the
  /// notification, such that listeners and voice only devices can announce and handle them
  /// properly.
  /// </P>
  ///@param person the person to add.
  ///@see Notification\#EXTRA_PEOPLE_LIST
  Notification_Builder addPerson1(Person person) =>
      Notification_Builder.fromRef(
          _addPerson1(reference, person.reference).object);

  static final _setGroup = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__setGroup")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setGroup(java.lang.String groupKey)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set this notification to be part of a group of notifications sharing the same key.
  /// Grouped notifications may display in a cluster or stack on devices which
  /// support such rendering.
  ///
  /// To make this notification the summary for its group, also call
  /// \#setGroupSummary. A sort order can be specified for group members by using
  /// \#setSortKey.
  ///@param groupKey The group key of the group.
  ///@return this object for method chaining
  Notification_Builder setGroup(jni.JniString groupKey) =>
      Notification_Builder.fromRef(
          _setGroup(reference, groupKey.reference).object);

  static final _setGroupSummary = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Notification_Builder__setGroupSummary")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setGroupSummary(boolean isGroupSummary)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set this notification to be the group summary for a group of notifications.
  /// Grouped notifications may display in a cluster or stack on devices which
  /// support such rendering. If thereRequires a group key also be set using \#setGroup.
  /// The group summary may be suppressed if too few notifications are included in the group.
  ///@param isGroupSummary Whether this notification should be a group summary.
  ///@return this object for method chaining
  Notification_Builder setGroupSummary(bool isGroupSummary) =>
      Notification_Builder.fromRef(
          _setGroupSummary(reference, isGroupSummary ? 1 : 0).object);

  static final _setSortKey = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__setSortKey")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setSortKey(java.lang.String sortKey)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a sort key that orders this notification among other notifications from the
  /// same package. This can be useful if an external sort was already applied and an app
  /// would like to preserve this. Notifications will be sorted lexicographically using this
  /// value, although providing different priorities in addition to providing sort key may
  /// cause this value to be ignored.
  ///
  /// This sort key can also be used to order members of a notification group. See
  /// \#setGroup.
  ///@see String\#compareTo(String)
  Notification_Builder setSortKey(jni.JniString sortKey) =>
      Notification_Builder.fromRef(
          _setSortKey(reference, sortKey.reference).object);

  static final _addExtras = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__addExtras")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder addExtras(android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Merge additional metadata into this notification.
  ///
  /// Values within the Bundle will replace existing extras values in this Builder.
  ///@see Notification\#extras
  Notification_Builder addExtras(os_.Bundle extras) =>
      Notification_Builder.fromRef(
          _addExtras(reference, extras.reference).object);

  static final _setExtras = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__setExtras")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setExtras(android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set metadata for this notification.
  ///
  /// A reference to the Bundle is held for the lifetime of this Builder, and the Bundle's
  /// current contents are copied into the Notification each time \#build() is
  /// called.
  ///
  /// Replaces any existing extras values with those from the provided Bundle.
  /// Use \#addExtras to merge in metadata instead.
  ///@see Notification\#extras
  Notification_Builder setExtras(os_.Bundle extras) =>
      Notification_Builder.fromRef(
          _setExtras(reference, extras.reference).object);

  static final _getExtras = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__getExtras")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the current metadata Bundle used by this notification Builder.
  ///
  /// The returned Bundle is shared with this Builder.
  ///
  /// The current contents of this Bundle are copied into the Notification each time
  /// \#build() is called.
  ///@see Notification\#extras
  os_.Bundle getExtras() => os_.Bundle.fromRef(_getExtras(reference).object);

  static final _addAction = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__addAction")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder addAction(int icon, java.lang.CharSequence title, android.app.PendingIntent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add an action to this notification. Actions are typically displayed by
  /// the system as a button adjacent to the notification content.
  ///
  /// Every action must have an icon (32dp square and matching the
  /// <a href="{@docRoot}design/style/iconography.html\#action-bar">Holo
  /// Dark action bar</a> visual style), a textual label, and a PendingIntent.
  ///
  /// A notification in its expanded form can display up to 3 actions, from left to right in
  /// the order they were added. Actions will not be displayed when the notification is
  /// collapsed, however, so be sure that any essential functions may be accessed by the user
  /// in some other way (for example, in the Activity pointed to by \#contentIntent).
  ///@param icon Resource ID of a drawable that represents the action.
  ///@param title Text describing the action.
  ///@param intent PendingIntent to be fired when the action is invoked.
  ///@deprecated Use \#addAction(Action) instead.
  Notification_Builder addAction(
          int icon, jni.JniObject title, PendingIntent intent) =>
      Notification_Builder.fromRef(
          _addAction(reference, icon, title.reference, intent.reference)
              .object);

  static final _addAction1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__addAction1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder addAction(android.app.Notification.Action action)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add an action to this notification. Actions are typically displayed by
  /// the system as a button adjacent to the notification content.
  ///
  /// Every action must have an icon (32dp square and matching the
  /// <a href="{@docRoot}design/style/iconography.html\#action-bar">Holo
  /// Dark action bar</a> visual style), a textual label, and a PendingIntent.
  ///
  /// A notification in its expanded form can display up to 3 actions, from left to right in
  /// the order they were added. Actions will not be displayed when the notification is
  /// collapsed, however, so be sure that any essential functions may be accessed by the user
  /// in some other way (for example, in the Activity pointed to by \#contentIntent).
  ///@param action The action to add.
  Notification_Builder addAction1(Notification_Action action) =>
      Notification_Builder.fromRef(
          _addAction1(reference, action.reference).object);

  static final _setActions = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__setActions")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setActions(android.app.Notification.Action[] actions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Alter the complete list of actions attached to this notification.
  ///@see \#addAction(Action).
  ///@param actions
  ///@return
  Notification_Builder setActions(jni.JniObject actions) =>
      Notification_Builder.fromRef(
          _setActions(reference, actions.reference).object);

  static final _setStyle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__setStyle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setStyle(android.app.Notification.Style style)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a rich notification style to be applied at build time.
  ///@param style Object responsible for modifying the notification style.
  Notification_Builder setStyle(Notification_Style style) =>
      Notification_Builder.fromRef(
          _setStyle(reference, style.reference).object);

  static final _getStyle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__getStyle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Style getStyle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the style set by \#setStyle(Style).
  Notification_Style getStyle() =>
      Notification_Style.fromRef(_getStyle(reference).object);

  static final _setVisibility = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Notification_Builder__setVisibility")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setVisibility(int visibility)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specify the value of \#visibility.
  ///@param visibility Value is android.app.Notification\#VISIBILITY_PUBLIC, android.app.Notification\#VISIBILITY_PRIVATE, or android.app.Notification\#VISIBILITY_SECRET
  ///@return The same Builder.
  Notification_Builder setVisibility(int visibility) =>
      Notification_Builder.fromRef(
          _setVisibility(reference, visibility).object);

  static final _setPublicVersion = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__setPublicVersion")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder setPublicVersion(android.app.Notification n)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Supply a replacement Notification whose contents should be shown in insecure contexts
  /// (i.e. atop the secure lockscreen). See \#visibility and \#VISIBILITY_PUBLIC.
  ///@param n A replacement notification, presumably with some or all info redacted.
  ///@return The same Builder.
  Notification_Builder setPublicVersion(Notification n) =>
      Notification_Builder.fromRef(
          _setPublicVersion(reference, n.reference).object);

  static final _extend = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__extend")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Builder extend(android.app.Notification.Extender extender)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Apply an extender to this notification builder. Extenders may be used to add
  /// metadata or change options on this builder.
  Notification_Builder extend(Notification_Extender extender) =>
      Notification_Builder.fromRef(
          _extend(reference, extender.reference).object);

  static final _setColor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Notification_Builder__setColor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Builder setColor(int argb)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets Notification\#color.
  ///@param argb The accent color to use
  ///@return The same Builder.
  Notification_Builder setColor(int argb) =>
      Notification_Builder.fromRef(_setColor(reference, argb).object);

  static final _createContentView = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__createContentView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.RemoteViews createContentView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a RemoteViews for the final 1U notification layout. In order:
  ///   1. Custom contentView from the caller
  ///   2. Style's proposed content view
  ///   3. Standard template view
  jni.JniObject createContentView() =>
      jni.JniObject.fromRef(_createContentView(reference).object);

  static final _createBigContentView = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__createBigContentView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.RemoteViews createBigContentView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a RemoteViews for the final big notification layout.
  jni.JniObject createBigContentView() =>
      jni.JniObject.fromRef(_createBigContentView(reference).object);

  static final _createHeadsUpContentView = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__createHeadsUpContentView")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.RemoteViews createHeadsUpContentView()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Construct a RemoteViews for the final heads-up notification layout.
  jni.JniObject createHeadsUpContentView() =>
      jni.JniObject.fromRef(_createHeadsUpContentView(reference).object);

  static final _recoverBuilder = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__recoverBuilder")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.Notification.Builder recoverBuilder(android.content.Context context, android.app.Notification n)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a Builder from an existing notification so further changes can be made.
  ///@param context The context for your application / activity.
  ///@param n The notification to create a Builder from.
  static Notification_Builder recoverBuilder(
          content_.Context context, Notification n) =>
      Notification_Builder.fromRef(
          _recoverBuilder(context.reference, n.reference).object);

  static final _getNotification = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_Builder__getNotification")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification getNotification()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Use \#build() instead.
  Notification getNotification() =>
      Notification.fromRef(_getNotification(reference).object);

  static final _build = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification_Builder__build")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Combine all of the options that have been set and return a new Notification
  /// object.
  Notification build() => Notification.fromRef(_build(reference).object);
}

/// from: android.app.Notification$BigTextStyle
///
/// Helper class for generating large-format notifications that include a lot of text.
///
/// Here's how you'd set the <code>BigTextStyle</code> on a notification:
/// <pre class="prettyprint">
/// Notification notif = new Notification.Builder(mContext)
///     .setContentTitle(&quot;New mail from &quot; + sender.toString())
///     .setContentText(subject)
///     .setSmallIcon(R.drawable.new_mail)
///     .setLargeIcon(aBitmap)
///     .setStyle(new Notification.BigTextStyle()
///         .bigText(aVeryLongString))
///     .build();
/// </pre>
///@see Notification\#bigContentView
class Notification_BigTextStyle extends Notification_Style {
  Notification_BigTextStyle.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Notification_BigTextStyle__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  Notification_BigTextStyle() : super.fromRef(_ctor().object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification_BigTextStyle__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Notification.Builder builder)
  ///
  /// @deprecated use {@code BigTextStyle()}.
  Notification_BigTextStyle.ctor1(Notification_Builder builder)
      : super.fromRef(_ctor1(builder.reference).object);

  static final _setBigContentTitle = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_BigTextStyle__setBigContentTitle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.BigTextStyle setBigContentTitle(java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Overrides ContentTitle in the big form of the template.
  /// This defaults to the value passed to setContentTitle().
  Notification_BigTextStyle setBigContentTitle(jni.JniObject title) =>
      Notification_BigTextStyle.fromRef(
          _setBigContentTitle(reference, title.reference).object);

  static final _setSummaryText = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_BigTextStyle__setSummaryText")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.BigTextStyle setSummaryText(java.lang.CharSequence cs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the first line of text after the detail section in the big form of the template.
  Notification_BigTextStyle setSummaryText(jni.JniObject cs) =>
      Notification_BigTextStyle.fromRef(
          _setSummaryText(reference, cs.reference).object);

  static final _bigText = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_BigTextStyle__bigText")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.BigTextStyle bigText(java.lang.CharSequence cs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Provide the longer text to be displayed in the big form of the
  /// template in place of the content text.
  Notification_BigTextStyle bigText(jni.JniObject cs) =>
      Notification_BigTextStyle.fromRef(
          _bigText(reference, cs.reference).object);
}

/// from: android.app.Notification$BigPictureStyle
///
/// Helper class for generating large-format notifications that include a large image attachment.
///
/// Here's how you'd set the <code>BigPictureStyle</code> on a notification:
/// <pre class="prettyprint">
/// Notification notif = new Notification.Builder(mContext)
///     .setContentTitle(&quot;New photo from &quot; + sender.toString())
///     .setContentText(subject)
///     .setSmallIcon(R.drawable.new_post)
///     .setLargeIcon(aBitmap)
///     .setStyle(new Notification.BigPictureStyle()
///         .bigPicture(aBigBitmap))
///     .build();
/// </pre>
///@see Notification\#bigContentView
class Notification_BigPictureStyle extends Notification_Style {
  Notification_BigPictureStyle.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Notification_BigPictureStyle__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  Notification_BigPictureStyle() : super.fromRef(_ctor().object);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_BigPictureStyle__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Notification.Builder builder)
  ///
  /// @deprecated use {@code BigPictureStyle()}.
  Notification_BigPictureStyle.ctor1(Notification_Builder builder)
      : super.fromRef(_ctor1(builder.reference).object);

  static final _setBigContentTitle = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_BigPictureStyle__setBigContentTitle")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.BigPictureStyle setBigContentTitle(java.lang.CharSequence title)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Overrides ContentTitle in the big form of the template.
  /// This defaults to the value passed to setContentTitle().
  Notification_BigPictureStyle setBigContentTitle(jni.JniObject title) =>
      Notification_BigPictureStyle.fromRef(
          _setBigContentTitle(reference, title.reference).object);

  static final _setSummaryText = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_BigPictureStyle__setSummaryText")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.BigPictureStyle setSummaryText(java.lang.CharSequence cs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set the first line of text after the detail section in the big form of the template.
  Notification_BigPictureStyle setSummaryText(jni.JniObject cs) =>
      Notification_BigPictureStyle.fromRef(
          _setSummaryText(reference, cs.reference).object);

  static final _bigPicture = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_BigPictureStyle__bigPicture")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.BigPictureStyle bigPicture(android.graphics.Bitmap b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Provide the bitmap to be used as the payload for the BigPicture notification.
  Notification_BigPictureStyle bigPicture(jni.JniObject b) =>
      Notification_BigPictureStyle.fromRef(
          _bigPicture(reference, b.reference).object);

  static final _bigLargeIcon = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_BigPictureStyle__bigLargeIcon")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.BigPictureStyle bigLargeIcon(android.graphics.Bitmap b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Override the large icon when the big notification is shown.
  Notification_BigPictureStyle bigLargeIcon(jni.JniObject b) =>
      Notification_BigPictureStyle.fromRef(
          _bigLargeIcon(reference, b.reference).object);

  static final _bigLargeIcon1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_BigPictureStyle__bigLargeIcon1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.BigPictureStyle bigLargeIcon(android.graphics.drawable.Icon icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Override the large icon when the big notification is shown.
  Notification_BigPictureStyle bigLargeIcon1(jni.JniObject icon) =>
      Notification_BigPictureStyle.fromRef(
          _bigLargeIcon1(reference, icon.reference).object);
}

/// from: android.app.Notification$Action
///
/// Structure to encapsulate a named action that can be shown as part of this notification.
/// It must include an icon, a label, and a PendingIntent to be fired when the action is
/// selected by the user.
///
/// Apps should use Notification.Builder\#addAction(int, CharSequence, PendingIntent)
/// or Notification.Builder\#addAction(Notification.Action)
/// to attach actions.
class Notification_Action extends jni.JniObject {
  Notification_Action.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Notification_Action__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.Notification.Action> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  /// from: static public final int SEMANTIC_ACTION_ARCHIVE
  ///
  /// {@code SemanticAction}: Archive the content associated with the notification. This
  /// could mean archiving an email, message, etc.
  static const SEMANTIC_ACTION_ARCHIVE = 5;

  /// from: static public final int SEMANTIC_ACTION_CALL
  ///
  /// {@code SemanticAction}: Call a contact, group, etc.
  static const SEMANTIC_ACTION_CALL = 10;

  /// from: static public final int SEMANTIC_ACTION_DELETE
  ///
  /// {@code SemanticAction}: Delete the content associated with the notification. This
  /// could mean deleting an email, message, etc.
  static const SEMANTIC_ACTION_DELETE = 4;

  /// from: static public final int SEMANTIC_ACTION_MARK_AS_READ
  ///
  /// {@code SemanticAction}: Mark content as read.
  static const SEMANTIC_ACTION_MARK_AS_READ = 2;

  /// from: static public final int SEMANTIC_ACTION_MARK_AS_UNREAD
  ///
  /// {@code SemanticAction}: Mark content as unread.
  static const SEMANTIC_ACTION_MARK_AS_UNREAD = 3;

  /// from: static public final int SEMANTIC_ACTION_MUTE
  ///
  /// {@code SemanticAction}: Mute the content associated with the notification. This could
  /// mean silencing a conversation or currently playing media.
  static const SEMANTIC_ACTION_MUTE = 6;

  /// from: static public final int SEMANTIC_ACTION_NONE
  ///
  /// /*missing*/: No semantic action defined.
  static const SEMANTIC_ACTION_NONE = 0;

  /// from: static public final int SEMANTIC_ACTION_REPLY
  ///
  /// {@code SemanticAction}: Reply to a conversation, chat, group, or wherever replies
  /// may be appropriate.
  static const SEMANTIC_ACTION_REPLY = 1;

  /// from: static public final int SEMANTIC_ACTION_THUMBS_DOWN
  ///
  /// {@code SemanticAction}: Mark content with a thumbs down.
  static const SEMANTIC_ACTION_THUMBS_DOWN = 9;

  /// from: static public final int SEMANTIC_ACTION_THUMBS_UP
  ///
  /// {@code SemanticAction}: Mark content with a thumbs up.
  static const SEMANTIC_ACTION_THUMBS_UP = 8;

  /// from: static public final int SEMANTIC_ACTION_UNMUTE
  ///
  /// {@code SemanticAction}: Unmute the content associated with the notification. This could
  /// mean un-silencing a conversation or currently playing media.
  static const SEMANTIC_ACTION_UNMUTE = 7;

  static final _get_actionIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification_Action__actionIntent")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public android.app.PendingIntent actionIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Intent to send when the user invokes this action. May be null, in which case the action
  /// may be rendered in a disabled presentation by the system UI.
  PendingIntent get actionIntent =>
      PendingIntent.fromRef(_get_actionIntent(reference).object);
  static final _set_actionIntent = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>>(
          "set_Notification_Action__actionIntent")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent actionIntent
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Intent to send when the user invokes this action. May be null, in which case the action
  /// may be rendered in a disabled presentation by the system UI.
  set actionIntent(PendingIntent value) =>
      _set_actionIntent(reference, value.reference);

  static final _get_icon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification_Action__icon")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public int icon
  ///
  /// Small icon representing the action.
  ///@deprecated Use Action\#getIcon() instead.
  int get icon => _get_icon(reference).integer;
  static final _set_icon = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(
                  jni.JObject, ffi.Int32)>>("set_Notification_Action__icon")
      .asFunction<jni.JThrowable Function(jni.JObject, int)>();

  /// from: public int icon
  ///
  /// Small icon representing the action.
  ///@deprecated Use Action\#getIcon() instead.
  set icon(int value) => _set_icon(reference, value);

  static final _get_title = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_Notification_Action__title")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public java.lang.CharSequence title
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Title of the action.
  jni.JniObject get title =>
      jni.JniObject.fromRef(_get_title(reference).object);
  static final _set_title = jniLookup<
          ffi.NativeFunction<
              jni.JThrowable Function(jni.JObject,
                  ffi.Pointer<ffi.Void>)>>("set_Notification_Action__title")
      .asFunction<
          jni.JThrowable Function(jni.JObject, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence title
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Title of the action.
  set title(jni.JniObject value) => _set_title(reference, value.reference);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Int32, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Action__ctor")
      .asFunction<
          jni.JniResult Function(
              int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int icon, java.lang.CharSequence title, android.app.PendingIntent intent)
  ///
  /// @deprecated Use android.app.Notification.Action.Builder.
  Notification_Action(int icon, jni.JniObject title, PendingIntent intent)
      : super.fromRef(_ctor(icon, title.reference, intent.reference).object);

  static final _getIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification_Action__getIcon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Icon getIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an icon representing the action.
  jni.JniObject getIcon() => jni.JniObject.fromRef(_getIcon(reference).object);

  static final _getExtras = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification_Action__getExtras")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get additional metadata carried around with this Action.
  os_.Bundle getExtras() => os_.Bundle.fromRef(_getExtras(reference).object);

  static final _getAllowGeneratedReplies = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_Action__getAllowGeneratedReplies")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getAllowGeneratedReplies()
  ///
  /// Return whether the platform should automatically generate possible replies for this
  /// Action
  bool getAllowGeneratedReplies() =>
      _getAllowGeneratedReplies(reference).boolean;

  static final _getRemoteInputs = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_Action__getRemoteInputs")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.RemoteInput[] getRemoteInputs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the list of inputs to be collected from the user when this action is sent.
  /// May return null if no remote inputs were added. Only returns inputs which accept
  /// a text input. For inputs which only accept data use \#getDataOnlyRemoteInputs.
  jni.JniObject getRemoteInputs() =>
      jni.JniObject.fromRef(_getRemoteInputs(reference).object);

  static final _getSemanticAction = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_Action__getSemanticAction")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getSemanticAction()
  ///
  /// Returns the {@code SemanticAction} associated with this Action. A
  /// {@code SemanticAction} denotes what an Action's PendingIntent will do
  /// (eg. reply, mark as read, delete, etc).
  ///@return Value is android.app.Notification.Action\#SEMANTIC_ACTION_NONE, android.app.Notification.Action\#SEMANTIC_ACTION_REPLY, android.app.Notification.Action\#SEMANTIC_ACTION_MARK_AS_READ, android.app.Notification.Action\#SEMANTIC_ACTION_MARK_AS_UNREAD, android.app.Notification.Action\#SEMANTIC_ACTION_DELETE, android.app.Notification.Action\#SEMANTIC_ACTION_ARCHIVE, android.app.Notification.Action\#SEMANTIC_ACTION_MUTE, android.app.Notification.Action\#SEMANTIC_ACTION_UNMUTE, android.app.Notification.Action\#SEMANTIC_ACTION_THUMBS_UP, android.app.Notification.Action\#SEMANTIC_ACTION_THUMBS_DOWN, or android.app.Notification.Action\#SEMANTIC_ACTION_CALL
  int getSemanticAction() => _getSemanticAction(reference).integer;

  static final _getDataOnlyRemoteInputs = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_Action__getDataOnlyRemoteInputs")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.RemoteInput[] getDataOnlyRemoteInputs()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the list of inputs to be collected from the user that ONLY accept data when this
  /// action is sent. These remote inputs are guaranteed to return true on a call to
  /// RemoteInput\#isDataOnly.
  ///
  /// Returns null if there are no data-only remote inputs.
  ///
  /// This method exists so that legacy RemoteInput collectors that pre-date the addition
  /// of non-textual RemoteInputs do not access these remote inputs.
  jni.JniObject getDataOnlyRemoteInputs() =>
      jni.JniObject.fromRef(_getDataOnlyRemoteInputs(reference).object);

  static final _clone = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification_Action__clone")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Notification_Action clone() =>
      Notification_Action.fromRef(_clone(reference).object);

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_Action__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Notification_Action__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os_.Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags).check();
}

/// from: android.app.Notification$Action$WearableExtender
///
/// Wearable extender for notification actions. To add extensions to an action,
/// create a new android.app.Notification.Action.WearableExtender object using
/// the {@code WearableExtender()} constructor and apply it to a
/// android.app.Notification.Action.Builder using
/// android.app.Notification.Action.Builder\#extend.
///
/// <pre class="prettyprint">
/// Notification.Action action = new Notification.Action.Builder(
///         R.drawable.archive_all, "Archive all", actionIntent)
///         .extend(new Notification.Action.WearableExtender()
///                 .setAvailableOffline(false))
///         .build();</pre>
class Notification_Action_WearableExtender extends jni.JniObject {
  Notification_Action_WearableExtender.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Notification_Action_WearableExtender__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ///
  /// Create a android.app.Notification.Action.WearableExtender with default
  /// options.
  Notification_Action_WearableExtender() : super.fromRef(_ctor().object);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_Action_WearableExtender__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Notification.Action action)
  ///
  /// Create a android.app.Notification.Action.WearableExtender by reading
  /// wearable options present in an existing notification action.
  ///@param action the notification action to inspect.
  Notification_Action_WearableExtender.ctor1(Notification_Action action)
      : super.fromRef(_ctor1(action.reference).object);

  static final _extend = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Action_WearableExtender__extend")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action.Builder extend(android.app.Notification.Action.Builder builder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Apply wearable extensions to a notification action that is being built. This is
  /// typically called by the android.app.Notification.Action.Builder\#extend
  /// method of android.app.Notification.Action.Builder.
  Notification_Action_Builder extend(Notification_Action_Builder builder) =>
      Notification_Action_Builder.fromRef(
          _extend(reference, builder.reference).object);

  static final _clone = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_Action_WearableExtender__clone")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action.WearableExtender clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Notification_Action_WearableExtender clone() =>
      Notification_Action_WearableExtender.fromRef(_clone(reference).object);

  static final _setAvailableOffline = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "Notification_Action_WearableExtender__setAvailableOffline")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Action.WearableExtender setAvailableOffline(boolean availableOffline)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether this action is available when the wearable device is not connected to
  /// a companion device. The user can still trigger this action when the wearable device is
  /// offline, but a visual hint will indicate that the action may not be available.
  /// Defaults to true.
  Notification_Action_WearableExtender setAvailableOffline(
          bool availableOffline) =>
      Notification_Action_WearableExtender.fromRef(
          _setAvailableOffline(reference, availableOffline ? 1 : 0).object);

  static final _isAvailableOffline = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_Action_WearableExtender__isAvailableOffline")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isAvailableOffline()
  ///
  /// Get whether this action is available when the wearable device is not connected to
  /// a companion device. The user can still trigger this action when the wearable device is
  /// offline, but a visual hint will indicate that the action may not be available.
  /// Defaults to true.
  bool isAvailableOffline() => _isAvailableOffline(reference).boolean;

  static final _setInProgressLabel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Action_WearableExtender__setInProgressLabel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action.WearableExtender setInProgressLabel(java.lang.CharSequence label)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a label to display while the wearable is preparing to automatically execute the
  /// action. This is usually a 'ing' verb ending in ellipsis like "Sending..."
  ///@param label the label to display while the action is being prepared to execute
  ///@return this object for method chaining
  Notification_Action_WearableExtender setInProgressLabel(
          jni.JniObject label) =>
      Notification_Action_WearableExtender.fromRef(
          _setInProgressLabel(reference, label.reference).object);

  static final _getInProgressLabel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_Action_WearableExtender__getInProgressLabel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getInProgressLabel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the label to display while the wearable is preparing to automatically execute
  /// the action. This is usually a 'ing' verb ending in ellipsis like "Sending..."
  ///@return the label to display while the action is being prepared to execute
  jni.JniObject getInProgressLabel() =>
      jni.JniObject.fromRef(_getInProgressLabel(reference).object);

  static final _setConfirmLabel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Action_WearableExtender__setConfirmLabel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action.WearableExtender setConfirmLabel(java.lang.CharSequence label)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a label to display to confirm that the action should be executed.
  /// This is usually an imperative verb like "Send".
  ///@param label the label to confirm the action should be executed
  ///@return this object for method chaining
  Notification_Action_WearableExtender setConfirmLabel(jni.JniObject label) =>
      Notification_Action_WearableExtender.fromRef(
          _setConfirmLabel(reference, label.reference).object);

  static final _getConfirmLabel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_Action_WearableExtender__getConfirmLabel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getConfirmLabel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the label to display to confirm that the action should be executed.
  /// This is usually an imperative verb like "Send".
  ///@return the label to confirm the action should be executed
  jni.JniObject getConfirmLabel() =>
      jni.JniObject.fromRef(_getConfirmLabel(reference).object);

  static final _setCancelLabel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Action_WearableExtender__setCancelLabel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action.WearableExtender setCancelLabel(java.lang.CharSequence label)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a label to display to cancel the action.
  /// This is usually an imperative verb, like "Cancel".
  ///@param label the label to display to cancel the action
  ///@return this object for method chaining
  Notification_Action_WearableExtender setCancelLabel(jni.JniObject label) =>
      Notification_Action_WearableExtender.fromRef(
          _setCancelLabel(reference, label.reference).object);

  static final _getCancelLabel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_Action_WearableExtender__getCancelLabel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getCancelLabel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the label to display to cancel the action.
  /// This is usually an imperative verb like "Cancel".
  ///@return the label to display to cancel the action
  jni.JniObject getCancelLabel() =>
      jni.JniObject.fromRef(_getCancelLabel(reference).object);

  static final _setHintLaunchesActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "Notification_Action_WearableExtender__setHintLaunchesActivity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Action.WearableExtender setHintLaunchesActivity(boolean hintLaunchesActivity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a hint that this Action will launch an Activity directly, telling the
  /// platform that it can generate the appropriate transitions.
  ///@param hintLaunchesActivity {@code true} if the content intent will launch
  /// an activity and transitions should be generated, false otherwise.
  ///@return this object for method chaining
  Notification_Action_WearableExtender setHintLaunchesActivity(
          bool hintLaunchesActivity) =>
      Notification_Action_WearableExtender.fromRef(
          _setHintLaunchesActivity(reference, hintLaunchesActivity ? 1 : 0)
              .object);

  static final _getHintLaunchesActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_Action_WearableExtender__getHintLaunchesActivity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getHintLaunchesActivity()
  ///
  /// Get a hint that this Action will launch an Activity directly, telling the
  /// platform that it can generate the appropriate transitions
  ///@return {@code true} if the content intent will launch an activity and transitions
  /// should be generated, false otherwise. The default value is {@code false} if this was
  /// never set.
  bool getHintLaunchesActivity() => _getHintLaunchesActivity(reference).boolean;

  static final _setHintDisplayActionInline = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "Notification_Action_WearableExtender__setHintDisplayActionInline")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Action.WearableExtender setHintDisplayActionInline(boolean hintDisplayInline)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a hint that this Action should be displayed inline.
  ///@param hintDisplayInline {@code true} if action should be displayed inline, false
  ///        otherwise
  ///@return this object for method chaining
  Notification_Action_WearableExtender setHintDisplayActionInline(
          bool hintDisplayInline) =>
      Notification_Action_WearableExtender.fromRef(
          _setHintDisplayActionInline(reference, hintDisplayInline ? 1 : 0)
              .object);

  static final _getHintDisplayActionInline = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_Action_WearableExtender__getHintDisplayActionInline")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getHintDisplayActionInline()
  ///
  /// Get a hint that this Action should be displayed inline.
  ///@return {@code true} if the Action should be displayed inline, {@code false}
  ///         otherwise. The default value is {@code false} if this was never set.
  bool getHintDisplayActionInline() =>
      _getHintDisplayActionInline(reference).boolean;
}

/// from: android.app.Notification$Action$Extender
///
/// Extender interface for use with Builder\#extend. Extenders may be used to add
/// metadata or change options on an action builder.
class Notification_Action_Extender extends jni.JniObject {
  Notification_Action_Extender.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _extend = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Action_Extender__extend")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.app.Notification.Action.Builder extend(android.app.Notification.Action.Builder builder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Apply this extender to a notification action builder.
  ///@param builder the builder to be modified.
  ///@return the build object for chaining.
  Notification_Action_Builder extend(Notification_Action_Builder builder) =>
      Notification_Action_Builder.fromRef(
          _extend(reference, builder.reference).object);
}

/// from: android.app.Notification$Action$Builder
///
/// Builder class for Action objects.
class Notification_Action_Builder extends jni.JniObject {
  Notification_Action_Builder.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Int32, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Action_Builder__ctor")
      .asFunction<
          jni.JniResult Function(
              int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int icon, java.lang.CharSequence title, android.app.PendingIntent intent)
  ///
  /// Construct a new builder for Action object.
  ///@param icon icon to show for this action
  ///@param title the title of the action
  ///@param intent the PendingIntent to fire when users trigger this action
  Notification_Action_Builder(
      int icon, jni.JniObject title, PendingIntent intent)
      : super.fromRef(_ctor(icon, title.reference, intent.reference).object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Notification_Action_Builder__ctor1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.graphics.drawable.Icon icon, java.lang.CharSequence title, android.app.PendingIntent intent)
  ///
  /// Construct a new builder for Action object.
  ///@param icon icon to show for this action
  ///@param title the title of the action
  ///@param intent the PendingIntent to fire when users trigger this action
  Notification_Action_Builder.ctor1(
      jni.JniObject icon, jni.JniObject title, PendingIntent intent)
      : super.fromRef(
            _ctor1(icon.reference, title.reference, intent.reference).object);

  static final _ctor2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification_Action_Builder__ctor2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.Notification.Action action)
  ///
  /// Construct a new builder for Action object using the fields from an
  /// Action.
  ///@param action the action to read fields from.
  Notification_Action_Builder.ctor2(Notification_Action action)
      : super.fromRef(_ctor2(action.reference).object);

  static final _addExtras = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Action_Builder__addExtras")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action.Builder addExtras(android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Merge additional metadata into this builder.
  ///
  /// Values within the Bundle will replace existing extras values in this Builder.
  ///@see Notification.Action\#extras
  Notification_Action_Builder addExtras(os_.Bundle extras) =>
      Notification_Action_Builder.fromRef(
          _addExtras(reference, extras.reference).object);

  static final _getExtras = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Notification_Action_Builder__getExtras")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the metadata Bundle used by this Builder.
  ///
  /// The returned Bundle is shared with this Builder.
  os_.Bundle getExtras() => os_.Bundle.fromRef(_getExtras(reference).object);

  static final _addRemoteInput = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Action_Builder__addRemoteInput")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action.Builder addRemoteInput(android.app.RemoteInput remoteInput)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add an input to be collected from the user when this action is sent.
  /// Response values can be retrieved from the fired intent by using the
  /// RemoteInput\#getResultsFromIntent function.
  ///@param remoteInput a RemoteInput to add to the action
  ///@return this object for method chaining
  Notification_Action_Builder addRemoteInput(RemoteInput remoteInput) =>
      Notification_Action_Builder.fromRef(
          _addRemoteInput(reference, remoteInput.reference).object);

  static final _setAllowGeneratedReplies = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8)>>(
          "Notification_Action_Builder__setAllowGeneratedReplies")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Action.Builder setAllowGeneratedReplies(boolean allowGeneratedReplies)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set whether the platform should automatically generate possible replies to add to
  /// RemoteInput\#getChoices(). If the Action doesn't have a
  /// RemoteInput, this has no effect.
  ///@param allowGeneratedReplies {@code true} to allow generated replies, {@code false}
  /// otherwise
  ///@return this object for method chaining
  /// The default value is {@code true}
  Notification_Action_Builder setAllowGeneratedReplies(
          bool allowGeneratedReplies) =>
      Notification_Action_Builder.fromRef(
          _setAllowGeneratedReplies(reference, allowGeneratedReplies ? 1 : 0)
              .object);

  static final _setSemanticAction = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Notification_Action_Builder__setSemanticAction")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Notification.Action.Builder setSemanticAction(int semanticAction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the {@code SemanticAction} for this Action. A
  /// {@code SemanticAction} denotes what an Action's
  /// PendingIntent will do (eg. reply, mark as read, delete, etc).
  ///@param semanticAction a SemanticAction defined within Action with
  /// {@code SEMANTIC_ACTION_} prefixes
  /// Value is android.app.Notification.Action\#SEMANTIC_ACTION_NONE, android.app.Notification.Action\#SEMANTIC_ACTION_REPLY, android.app.Notification.Action\#SEMANTIC_ACTION_MARK_AS_READ, android.app.Notification.Action\#SEMANTIC_ACTION_MARK_AS_UNREAD, android.app.Notification.Action\#SEMANTIC_ACTION_DELETE, android.app.Notification.Action\#SEMANTIC_ACTION_ARCHIVE, android.app.Notification.Action\#SEMANTIC_ACTION_MUTE, android.app.Notification.Action\#SEMANTIC_ACTION_UNMUTE, android.app.Notification.Action\#SEMANTIC_ACTION_THUMBS_UP, android.app.Notification.Action\#SEMANTIC_ACTION_THUMBS_DOWN, or android.app.Notification.Action\#SEMANTIC_ACTION_CALL
  ///@return this object for method chaining
  Notification_Action_Builder setSemanticAction(int semanticAction) =>
      Notification_Action_Builder.fromRef(
          _setSemanticAction(reference, semanticAction).object);

  static final _extend = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "Notification_Action_Builder__extend")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action.Builder extend(android.app.Notification.Action.Extender extender)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Apply an extender to this action builder. Extenders may be used to add
  /// metadata or change options on this builder.
  Notification_Action_Builder extend(Notification_Action_Extender extender) =>
      Notification_Action_Builder.fromRef(
          _extend(reference, extender.reference).object);

  static final _build = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Notification_Action_Builder__build")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Notification.Action build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Combine all of the options that have been set and return a new Action
  /// object.
  ///@return the built action
  Notification_Action build() =>
      Notification_Action.fromRef(_build(reference).object);
}

/// from: android.app.NotificationChannel
///
/// A representation of settings that apply to a collection of similarly themed notifications.
class NotificationChannel extends jni.JniObject {
  NotificationChannel.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_NotificationChannel__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.NotificationChannel> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  /// from: static public final java.lang.String DEFAULT_CHANNEL_ID
  ///
  /// The id of the default channel for an app. This id is reserved by the system. All
  /// notifications posted from apps targeting android.os.Build.VERSION_CODES\#N_MR1 or
  /// earlier without a notification channel specified are posted to this channel.
  static const DEFAULT_CHANNEL_ID = "miscellaneous";

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("NotificationChannel__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String id, java.lang.CharSequence name, int importance)
  ///
  /// Creates a notification channel.
  ///@param id The id of the channel. Must be unique per package. The value may be truncated if
  ///           it is too long.
  ///@param name The user visible name of the channel. You can rename this channel when the system
  ///             locale changes by listening for the Intent\#ACTION_LOCALE_CHANGED
  ///             broadcast. The recommended maximum length is 40 characters; the value may be
  ///             truncated if it is too long.
  ///@param importance The importance of the channel. This controls how interruptive notifications
  ///                   posted to this channel are.
  ///
  /// Value is android.app.NotificationManager\#IMPORTANCE_UNSPECIFIED, android.app.NotificationManager\#IMPORTANCE_NONE, android.app.NotificationManager\#IMPORTANCE_MIN, android.app.NotificationManager\#IMPORTANCE_LOW, android.app.NotificationManager\#IMPORTANCE_DEFAULT, or android.app.NotificationManager\#IMPORTANCE_HIGH
  NotificationChannel(jni.JniString id, jni.JniObject name, int importance)
      : super.fromRef(_ctor(id.reference, name.reference, importance).object);

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("NotificationChannel__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _setName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("NotificationChannel__setName")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setName(java.lang.CharSequence name)
  ///
  /// Sets the user visible name of this channel.
  ///
  /// The recommended maximum length is 40 characters; the value may be truncated if it is too
  /// long.
  void setName(jni.JniObject name) =>
      _setName(reference, name.reference).check();

  static final _setDescription = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NotificationChannel__setDescription")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setDescription(java.lang.String description)
  ///
  /// Sets the user visible description of this channel.
  ///
  /// The recommended maximum length is 300 characters; the value may be truncated if it is too
  /// long.
  void setDescription(jni.JniString description) =>
      _setDescription(reference, description.reference).check();

  static final _setGroup = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("NotificationChannel__setGroup")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setGroup(java.lang.String groupId)
  ///
  /// Sets what group this channel belongs to.
  ///
  /// Group information is only used for presentation, not for behavior.
  ///
  /// Only modifiable before the channel is submitted to
  /// NotificationManager\#createNotificationChannel(NotificationChannel), unless the
  /// channel is not currently part of a group.
  ///@param groupId the id of a group created by
  /// NotificationManager\#createNotificationChannelGroup(NotificationChannelGroup).
  void setGroup(jni.JniString groupId) =>
      _setGroup(reference, groupId.reference).check();

  static final _setShowBadge = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("NotificationChannel__setShowBadge")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setShowBadge(boolean showBadge)
  ///
  /// Sets whether notifications posted to this channel can appear as application icon badges
  /// in a Launcher.
  ///
  /// Only modifiable before the channel is submitted to
  /// NotificationManager\#createNotificationChannel(NotificationChannel).
  ///@param showBadge true if badges should be allowed to be shown.
  void setShowBadge(bool showBadge) =>
      _setShowBadge(reference, showBadge ? 1 : 0).check();

  static final _setSound = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("NotificationChannel__setSound")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void setSound(android.net.Uri sound, android.media.AudioAttributes audioAttributes)
  ///
  /// Sets the sound that should be played for notifications posted to this channel and its
  /// audio attributes. Notification channels with an \#getImportance() importance of at
  /// least NotificationManager\#IMPORTANCE_DEFAULT should have a sound.
  ///
  /// Only modifiable before the channel is submitted to
  /// NotificationManager\#createNotificationChannel(NotificationChannel).
  void setSound(jni.JniObject sound, jni.JniObject audioAttributes) =>
      _setSound(reference, sound.reference, audioAttributes.reference).check();

  static final _enableLights = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("NotificationChannel__enableLights")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void enableLights(boolean lights)
  ///
  /// Sets whether notifications posted to this channel should display notification lights,
  /// on devices that support that feature.
  ///
  /// Only modifiable before the channel is submitted to
  /// NotificationManager\#createNotificationChannel(NotificationChannel).
  void enableLights(bool lights) =>
      _enableLights(reference, lights ? 1 : 0).check();

  static final _setLightColor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("NotificationChannel__setLightColor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setLightColor(int argb)
  ///
  /// Sets the notification light color for notifications posted to this channel, if lights are
  /// \#enableLights(boolean) enabled on this channel and the device supports that feature.
  ///
  /// Only modifiable before the channel is submitted to
  /// NotificationManager\#createNotificationChannel(NotificationChannel).
  void setLightColor(int argb) => _setLightColor(reference, argb).check();

  static final _enableVibration = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("NotificationChannel__enableVibration")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void enableVibration(boolean vibration)
  ///
  /// Sets whether notification posted to this channel should vibrate. The vibration pattern can
  /// be set with \#setVibrationPattern(long[]).
  ///
  /// Only modifiable before the channel is submitted to
  /// NotificationManager\#createNotificationChannel(NotificationChannel).
  void enableVibration(bool vibration) =>
      _enableVibration(reference, vibration ? 1 : 0).check();

  static final _setVibrationPattern = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NotificationChannel__setVibrationPattern")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setVibrationPattern(long[] vibrationPattern)
  ///
  /// Sets the vibration pattern for notifications posted to this channel. If the provided
  /// pattern is valid (non-null, non-empty), will \#enableVibration(boolean) enable
  /// vibration} as well. Otherwise, vibration will be disabled.
  ///
  /// Only modifiable before the channel is submitted to
  /// NotificationManager\#createNotificationChannel(NotificationChannel).
  void setVibrationPattern(jni.JniObject vibrationPattern) =>
      _setVibrationPattern(reference, vibrationPattern.reference).check();

  static final _setImportance = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("NotificationChannel__setImportance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setImportance(int importance)
  ///
  /// Sets the level of interruption of this notification channel.
  ///
  /// Only modifiable before the channel is submitted to
  /// NotificationManager\#createNotificationChannel(NotificationChannel).
  ///@param importance the amount the user should be interrupted by
  ///            notifications from this channel.
  ///
  /// Value is android.app.NotificationManager\#IMPORTANCE_UNSPECIFIED, android.app.NotificationManager\#IMPORTANCE_NONE, android.app.NotificationManager\#IMPORTANCE_MIN, android.app.NotificationManager\#IMPORTANCE_LOW, android.app.NotificationManager\#IMPORTANCE_DEFAULT, or android.app.NotificationManager\#IMPORTANCE_HIGH
  void setImportance(int importance) =>
      _setImportance(reference, importance).check();

  static final _setBypassDnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("NotificationChannel__setBypassDnd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setBypassDnd(boolean bypassDnd)
  ///
  /// Sets whether or not notifications posted to this channel can interrupt the user in
  /// android.app.NotificationManager.Policy\#INTERRUPTION_FILTER_PRIORITY mode.
  ///
  /// Only modifiable by the system and notification ranker.
  void setBypassDnd(bool bypassDnd) =>
      _setBypassDnd(reference, bypassDnd ? 1 : 0).check();

  static final _setLockscreenVisibility = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("NotificationChannel__setLockscreenVisibility")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setLockscreenVisibility(int lockscreenVisibility)
  ///
  /// Sets whether notifications posted to this channel appear on the lockscreen or not, and if so,
  /// whether they appear in a redacted form. See e.g. Notification\#VISIBILITY_SECRET.
  ///
  /// Only modifiable by the system and notification ranker.
  void setLockscreenVisibility(int lockscreenVisibility) =>
      _setLockscreenVisibility(reference, lockscreenVisibility).check();

  static final _getId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NotificationChannel__getId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the id of this channel.
  jni.JniString getId() => jni.JniString.fromRef(_getId(reference).object);

  static final _getName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NotificationChannel__getName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the user visible name of this channel.
  jni.JniObject getName() => jni.JniObject.fromRef(_getName(reference).object);

  static final _getDescription = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationChannel__getDescription")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the user visible description of this channel.
  jni.JniString getDescription() =>
      jni.JniString.fromRef(_getDescription(reference).object);

  static final _getImportance = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NotificationChannel__getImportance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getImportance()
  ///
  /// Returns the user specified importance e.g.&nbsp;NotificationManager\#IMPORTANCE_LOW for
  /// notifications posted to this channel. Note: This value might be >
  /// NotificationManager\#IMPORTANCE_NONE, but notifications posted to this channel will
  /// not be shown to the user if the parent NotificationChannelGroup or app is blocked.
  /// See NotificationChannelGroup\#isBlocked() and
  /// NotificationManager\#areNotificationsEnabled().
  int getImportance() => _getImportance(reference).integer;

  static final _canBypassDnd = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NotificationChannel__canBypassDnd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean canBypassDnd()
  ///
  /// Whether or not notifications posted to this channel can bypass the Do Not Disturb
  /// NotificationManager\#INTERRUPTION_FILTER_PRIORITY mode.
  bool canBypassDnd() => _canBypassDnd(reference).boolean;

  static final _getSound = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NotificationChannel__getSound")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri getSound()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the notification sound for this channel.
  jni.JniObject getSound() =>
      jni.JniObject.fromRef(_getSound(reference).object);

  static final _getAudioAttributes = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationChannel__getAudioAttributes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.media.AudioAttributes getAudioAttributes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the audio attributes for sound played by notifications posted to this channel.
  jni.JniObject getAudioAttributes() =>
      jni.JniObject.fromRef(_getAudioAttributes(reference).object);

  static final _shouldShowLights = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationChannel__shouldShowLights")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldShowLights()
  ///
  /// Returns whether notifications posted to this channel trigger notification lights.
  bool shouldShowLights() => _shouldShowLights(reference).boolean;

  static final _getLightColor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NotificationChannel__getLightColor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLightColor()
  ///
  /// Returns the notification light color for notifications posted to this channel. Irrelevant
  /// unless \#shouldShowLights().
  int getLightColor() => _getLightColor(reference).integer;

  static final _shouldVibrate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NotificationChannel__shouldVibrate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldVibrate()
  ///
  /// Returns whether notifications posted to this channel always vibrate.
  bool shouldVibrate() => _shouldVibrate(reference).boolean;

  static final _getVibrationPattern = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationChannel__getVibrationPattern")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long[] getVibrationPattern()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the vibration pattern for notifications posted to this channel. Will be ignored if
  /// vibration is not enabled (\#shouldVibrate().
  jni.JniObject getVibrationPattern() =>
      jni.JniObject.fromRef(_getVibrationPattern(reference).object);

  static final _getLockscreenVisibility = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationChannel__getLockscreenVisibility")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLockscreenVisibility()
  ///
  /// Returns whether or not notifications posted to this channel are shown on the lockscreen in
  /// full or redacted form.
  int getLockscreenVisibility() => _getLockscreenVisibility(reference).integer;

  static final _canShowBadge = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NotificationChannel__canShowBadge")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean canShowBadge()
  ///
  /// Returns whether notifications posted to this channel can appear as badges in a Launcher
  /// application.
  ///
  /// Note that badging may be disabled for other reasons.
  bool canShowBadge() => _canShowBadge(reference).boolean;

  static final _getGroup = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NotificationChannel__getGroup")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getGroup()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns what group this channel belongs to.
  ///
  /// This is used only for visually grouping channels in the UI.
  jni.JniString getGroup() =>
      jni.JniString.fromRef(_getGroup(reference).object);

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationChannel__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("NotificationChannel__equals1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => _equals1(reference, o.reference).boolean;

  static final _hashCode1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NotificationChannel__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() => _hashCode1(reference).integer;

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NotificationChannel__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);
}

/// from: android.app.NotificationChannelGroup
///
/// A grouping of related notification channels. e.g., channels that all belong to a single account.
class NotificationChannelGroup extends jni.JniObject {
  NotificationChannelGroup.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_NotificationChannelGroup__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.NotificationChannelGroup> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("NotificationChannelGroup__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String id, java.lang.CharSequence name)
  ///
  /// Creates a notification channel group.
  ///@param id The id of the group. Must be unique per package.  the value may be truncated if
  ///           it is too long.
  ///@param name The user visible name of the group. You can rename this group when the system
  ///             locale changes by listening for the Intent\#ACTION_LOCALE_CHANGED
  ///             broadcast. The recommended maximum length is 40 characters; the value may be
  ///             truncated if it is too long.
  NotificationChannelGroup(jni.JniString id, jni.JniObject name)
      : super.fromRef(_ctor(id.reference, name.reference).object);

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("NotificationChannelGroup__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _getId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NotificationChannelGroup__getId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the id of this group.
  jni.JniString getId() => jni.JniString.fromRef(_getId(reference).object);

  static final _getName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NotificationChannelGroup__getName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the user visible name of this group.
  jni.JniObject getName() => jni.JniObject.fromRef(_getName(reference).object);

  static final _getDescription = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationChannelGroup__getDescription")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the user visible description of this group.
  jni.JniString getDescription() =>
      jni.JniString.fromRef(_getDescription(reference).object);

  static final _getChannels = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationChannelGroup__getChannels")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.NotificationChannel> getChannels()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the list of channels that belong to this group
  jni.JniObject getChannels() =>
      jni.JniObject.fromRef(_getChannels(reference).object);

  static final _isBlocked = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationChannelGroup__isBlocked")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isBlocked()
  ///
  /// Returns whether or not notifications posted to NotificationChannel channels belonging
  /// to this group are blocked. This value is independent of
  /// NotificationManager\#areNotificationsEnabled() and
  /// NotificationChannel\#getImportance().
  bool isBlocked() => _isBlocked(reference).boolean;

  static final _setDescription = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NotificationChannelGroup__setDescription")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setDescription(java.lang.String description)
  ///
  /// Sets the user visible description of this group.
  ///
  /// The recommended maximum length is 300 characters; the value may be truncated if it is too
  /// long.
  void setDescription(jni.JniString description) =>
      _setDescription(reference, description.reference).check();

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationChannelGroup__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("NotificationChannelGroup__equals1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => _equals1(reference, o.reference).boolean;

  static final _hashCode1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationChannelGroup__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() => _hashCode1(reference).integer;

  static final _clone = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NotificationChannelGroup__clone")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.NotificationChannelGroup clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  NotificationChannelGroup clone() =>
      NotificationChannelGroup.fromRef(_clone(reference).object);

  static final _toString1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationChannelGroup__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);
}

/// from: android.app.NotificationManager
///
/// Class to notify the user of events that happen.  This is how you tell
/// the user that something has happened in the background. {@more }
///
/// Notifications can take different forms:
/// <ul>
///      <li>A persistent icon that goes in the status bar and is accessible
///          through the launcher, (when the user selects it, a designated Intent
///          can be launched),</li>
///      <li>Turning on or flashing LEDs on the device, or</li>
///      <li>Alerting the user by flashing the backlight, playing a sound,
///          or vibrating.</li>
/// </ul>
///
///
/// Each of the notify methods takes an int id parameter and optionally a
/// String tag parameter, which may be {@code null}.  These parameters
/// are used to form a pair (tag, id), or ({@code null}, id) if tag is
/// unspecified.  This pair identifies this notification from your app to the
/// system, so that pair should be unique within your app.  If you call one
/// of the notify methods with a (tag, id) pair that is currently active and
/// a new set of notification parameters, it will be updated.  For example,
/// if you pass a new status bar icon, the old icon in the status bar will
/// be replaced with the new one.  This is also the same tag and id you pass
/// to the \#cancel(int) or \#cancel(String, int) method to clear
/// this notification.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For a guide to creating notifications, read the
/// <a href="{@docRoot}guide/topics/ui/notifiers/notifications.html">Status Bar Notifications</a>
/// developer guide.
///
/// </div>
///@see android.app.Notification
class NotificationManager extends jni.JniObject {
  NotificationManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_APP_BLOCK_STATE_CHANGED
  ///
  /// Intent that is broadcast when an application is blocked or unblocked.
  ///
  /// This broadcast is only sent to the app whose block state has changed.
  ///
  /// Input: nothing
  /// Output: \#EXTRA_BLOCKED_STATE
  static const ACTION_APP_BLOCK_STATE_CHANGED =
      "android.app.action.APP_BLOCK_STATE_CHANGED";

  /// from: static public final java.lang.String ACTION_INTERRUPTION_FILTER_CHANGED
  ///
  /// Intent that is broadcast when the state of getCurrentInterruptionFilter() changes.
  /// This broadcast is only sent to registered receivers.
  static const ACTION_INTERRUPTION_FILTER_CHANGED =
      "android.app.action.INTERRUPTION_FILTER_CHANGED";

  /// from: static public final java.lang.String ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED
  ///
  /// Intent that is broadcast when a NotificationChannel is blocked
  /// (when NotificationChannel\#getImportance() is \#IMPORTANCE_NONE) or unblocked
  /// (when NotificationChannel\#getImportance() is anything other than
  /// \#IMPORTANCE_NONE).
  ///
  /// This broadcast is only sent to the app that owns the channel that has changed.
  ///
  /// Input: nothing
  /// Output: \#EXTRA_NOTIFICATION_CHANNEL_ID
  /// Output: \#EXTRA_BLOCKED_STATE
  static const ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED =
      "android.app.action.NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED";

  /// from: static public final java.lang.String ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED
  ///
  /// Intent that is broadcast when a NotificationChannelGroup is
  /// NotificationChannelGroup\#isBlocked() blocked or unblocked.
  ///
  /// This broadcast is only sent to the app that owns the channel group that has changed.
  ///
  /// Input: nothing
  /// Output: \#EXTRA_NOTIFICATION_CHANNEL_GROUP_ID
  /// Output: \#EXTRA_BLOCKED_STATE
  static const ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED =
      "android.app.action.NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED";

  /// from: static public final java.lang.String ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED
  ///
  /// Intent that is broadcast when the state of \#isNotificationPolicyAccessGranted()
  /// changes.
  ///
  /// This broadcast is only sent to registered receivers, and only to the apps that have changed.
  static const ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED =
      "android.app.action.NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED";

  /// from: static public final java.lang.String ACTION_NOTIFICATION_POLICY_CHANGED
  ///
  /// Intent that is broadcast when the state of getNotificationPolicy() changes.
  /// This broadcast is only sent to registered receivers.
  static const ACTION_NOTIFICATION_POLICY_CHANGED =
      "android.app.action.NOTIFICATION_POLICY_CHANGED";

  /// from: static public final java.lang.String EXTRA_BLOCKED_STATE
  ///
  /// Extra for \#ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED or
  /// \#ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED containing the new blocked
  /// state as a boolean.
  ///
  /// The value will be {@code true} if this channel or group is now blocked and {@code false} if
  /// this channel or group is now unblocked.
  static const EXTRA_BLOCKED_STATE = "android.app.extra.BLOCKED_STATE";

  /// from: static public final java.lang.String EXTRA_NOTIFICATION_CHANNEL_GROUP_ID
  ///
  /// Extra for \#ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED containing the id
  /// of the NotificationChannelGroup which has a new blocked state.
  ///
  /// The value will be the NotificationChannelGroup\#getId() of the group.
  static const EXTRA_NOTIFICATION_CHANNEL_GROUP_ID =
      "android.app.extra.NOTIFICATION_CHANNEL_GROUP_ID";

  /// from: static public final java.lang.String EXTRA_NOTIFICATION_CHANNEL_ID
  ///
  /// Extra for \#ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED containing the id of the
  /// NotificationChannel which has a new blocked state.
  ///
  /// The value will be the NotificationChannel\#getId() of the channel.
  static const EXTRA_NOTIFICATION_CHANNEL_ID =
      "android.app.extra.NOTIFICATION_CHANNEL_ID";

  /// from: static public final int IMPORTANCE_DEFAULT
  ///
  /// Default notification importance: shows everywhere, makes noise, but does not visually
  /// intrude.
  static const IMPORTANCE_DEFAULT = 3;

  /// from: static public final int IMPORTANCE_HIGH
  ///
  /// Higher notification importance: shows everywhere, makes noise and peeks. May use full screen
  /// intents.
  static const IMPORTANCE_HIGH = 4;

  /// from: static public final int IMPORTANCE_LOW
  ///
  /// Low notification importance: shows everywhere, but is not intrusive.
  static const IMPORTANCE_LOW = 2;

  /// from: static public final int IMPORTANCE_MAX
  ///
  /// Unused.
  static const IMPORTANCE_MAX = 5;

  /// from: static public final int IMPORTANCE_MIN
  ///
  /// Min notification importance: only shows in the shade, below the fold.  This should
  /// not be used with Service\#startForeground(int, Notification) Service.startForeground
  /// since a foreground service is supposed to be something the user cares about so it does
  /// not make semantic sense to mark its notification as minimum importance.  If you do this
  /// as of Android version android.os.Build.VERSION_CODES\#O, the system will show
  /// a higher-priority notification about your app running in the background.
  static const IMPORTANCE_MIN = 1;

  /// from: static public final int IMPORTANCE_NONE
  ///
  /// A notification with no importance: does not show in the shade.
  static const IMPORTANCE_NONE = 0;

  /// from: static public final int IMPORTANCE_UNSPECIFIED
  ///
  /// Value signifying that the user has not expressed an importance.
  ///
  /// This value is for persisting preferences, and should never be associated with
  /// an actual notification.
  static const IMPORTANCE_UNSPECIFIED = -1000;

  /// from: static public final int INTERRUPTION_FILTER_ALARMS
  ///
  /// \#getCurrentInterruptionFilter() Interruption filter constant -
  ///     Alarms only interruption filter - all notifications except those of category
  ///     Notification\#CATEGORY_ALARM are suppressed. Some audio streams are muted.
  static const INTERRUPTION_FILTER_ALARMS = 4;

  /// from: static public final int INTERRUPTION_FILTER_ALL
  ///
  /// \#getCurrentInterruptionFilter() Interruption filter constant -
  ///     Normal interruption filter - no notifications are suppressed.
  static const INTERRUPTION_FILTER_ALL = 1;

  /// from: static public final int INTERRUPTION_FILTER_NONE
  ///
  /// \#getCurrentInterruptionFilter() Interruption filter constant -
  ///     No interruptions filter - all notifications are suppressed and all audio streams (except
  ///     those used for phone calls) and vibrations are muted.
  static const INTERRUPTION_FILTER_NONE = 3;

  /// from: static public final int INTERRUPTION_FILTER_PRIORITY
  ///
  /// \#getCurrentInterruptionFilter() Interruption filter constant -
  ///     Priority interruption filter - all notifications are suppressed except those that match
  ///     the priority criteria. Some audio streams are muted. See
  ///     Policy\#priorityCallSenders, Policy\#priorityCategories,
  ///     Policy\#priorityMessageSenders to define or query this criteria. Users can
  ///     additionally specify packages that can bypass this interruption filter.
  static const INTERRUPTION_FILTER_PRIORITY = 2;

  /// from: static public final int INTERRUPTION_FILTER_UNKNOWN
  ///
  /// \#getCurrentInterruptionFilter() Interruption filter constant - returned when
  /// the value is unavailable for any reason.
  static const INTERRUPTION_FILTER_UNKNOWN = 0;

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("NotificationManager__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.content.Context context, android.os.Handler handler)
  NotificationManager(content_.Context context, os_.Handler handler)
      : super.fromRef(_ctor(context.reference, handler.reference).object);

  static final _notify = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("NotificationManager__notify")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void notify(int id, android.app.Notification notification)
  ///
  /// Post a notification to be shown in the status bar. If a notification with
  /// the same id has already been posted by your application and has not yet been canceled, it
  /// will be replaced by the updated information.
  ///@param id An identifier for this notification unique within your
  ///        application.
  ///@param notification A Notification object describing what to show the user. Must not
  ///        be null.
  void notify(int id, Notification notification) =>
      _notify(reference, id, notification.reference).check();

  static final _notify1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("NotificationManager__notify1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public void notify(java.lang.String tag, int id, android.app.Notification notification)
  ///
  /// Post a notification to be shown in the status bar. If a notification with
  /// the same tag and id has already been posted by your application and has not yet been
  /// canceled, it will be replaced by the updated information.
  ///
  /// All android.service.notification.NotificationListenerService listener services will
  /// be granted Intent\#FLAG_GRANT_READ_URI_PERMISSION access to any Uri uris
  /// provided on this notification or the
  /// NotificationChannel this notification is posted to using
  /// Context\#grantUriPermission(String, Uri, int). Permission will be revoked when the
  /// notification is canceled, or you can revoke permissions with
  /// Context\#revokeUriPermission(Uri, int).
  ///@param tag A string identifier for this notification.  May be {@code null}.
  ///@param id An identifier for this notification.  The pair (tag, id) must be unique
  ///        within your application.
  ///@param notification A Notification object describing what to
  ///        show the user. Must not be null.
  void notify1(jni.JniString tag, int id, Notification notification) =>
      _notify1(reference, tag.reference, id, notification.reference).check();

  static final _cancel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("NotificationManager__cancel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void cancel(int id)
  ///
  /// Cancel a previously shown notification.  If it's transient, the view
  /// will be hidden.  If it's persistent, it will be removed from the status
  /// bar.
  void cancel(int id) => _cancel(reference, id).check();

  static final _cancel1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("NotificationManager__cancel1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void cancel(java.lang.String tag, int id)
  ///
  /// Cancel a previously shown notification.  If it's transient, the view
  /// will be hidden.  If it's persistent, it will be removed from the status
  /// bar.
  void cancel1(jni.JniString tag, int id) =>
      _cancel1(reference, tag.reference, id).check();

  static final _cancelAll = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NotificationManager__cancelAll")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void cancelAll()
  ///
  /// Cancel all previously shown notifications. See \#cancel for the
  /// detailed behavior.
  void cancelAll() => _cancelAll(reference).check();

  static final _createNotificationChannelGroup = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__createNotificationChannelGroup")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void createNotificationChannelGroup(android.app.NotificationChannelGroup group)
  ///
  /// Creates a group container for NotificationChannel objects.
  ///
  /// This can be used to rename an existing group.
  ///
  ///     Group information is only used for presentation, not for behavior. Groups are optional
  ///     for channels, and you can have a mix of channels that belong to groups and channels
  ///     that do not.
  ///
  ///
  ///
  ///     For example, if your application supports multiple accounts, and those accounts will
  ///     have similar channels, you can create a group for each account with account specific
  ///     labels instead of appending account information to each channel's label.
  ///
  ///
  ///@param group The group to create
  ///
  /// This value must never be {@code null}.
  void createNotificationChannelGroup(NotificationChannelGroup group) =>
      _createNotificationChannelGroup(reference, group.reference).check();

  static final _createNotificationChannelGroups = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__createNotificationChannelGroups")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void createNotificationChannelGroups(java.util.List<android.app.NotificationChannelGroup> groups)
  ///
  /// Creates multiple notification channel groups.
  ///@param groups The list of groups to create
  ///
  /// This value must never be {@code null}.
  void createNotificationChannelGroups(jni.JniObject groups) =>
      _createNotificationChannelGroups(reference, groups.reference).check();

  static final _createNotificationChannel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__createNotificationChannel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void createNotificationChannel(android.app.NotificationChannel channel)
  ///
  /// Creates a notification channel that notifications can be posted to.
  ///
  /// This can also be used to restore a deleted channel and to update an existing channel's
  /// name, description, group, and/or importance.
  ///
  /// The name and description should only be changed if the locale changes
  /// or in response to the user renaming this channel. For example, if a user has a channel
  /// named 'John Doe' that represents messages from a 'John Doe', and 'John Doe' changes his name
  /// to 'John Smith,' the channel can be renamed to match.
  ///
  /// The importance of an existing channel will only be changed if the new importance is lower
  /// than the current value and the user has not altered any settings on this channel.
  ///
  /// The group an existing channel will only be changed if the channel does not already
  /// belong to a group.
  ///
  /// All other fields are ignored for channels that already exist.
  ///@param channel the channel to create.  Note that the created channel may differ from this
  ///                 value. If the provided channel is malformed, a RemoteException will be
  ///                 thrown.
  ///
  /// This value must never be {@code null}.
  void createNotificationChannel(NotificationChannel channel) =>
      _createNotificationChannel(reference, channel.reference).check();

  static final _createNotificationChannels = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__createNotificationChannels")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void createNotificationChannels(java.util.List<android.app.NotificationChannel> channels)
  ///
  /// Creates multiple notification channels that different notifications can be posted to. See
  /// \#createNotificationChannel(NotificationChannel).
  ///@param channels the list of channels to attempt to create.
  ///
  /// This value must never be {@code null}.
  void createNotificationChannels(jni.JniObject channels) =>
      _createNotificationChannels(reference, channels.reference).check();

  static final _getNotificationChannel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__getNotificationChannel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.NotificationChannel getNotificationChannel(java.lang.String channelId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the notification channel settings for a given channel id.
  ///
  /// The channel must belong to your package, or it will not be returned.
  NotificationChannel getNotificationChannel(jni.JniString channelId) =>
      NotificationChannel.fromRef(
          _getNotificationChannel(reference, channelId.reference).object);

  static final _getNotificationChannels = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__getNotificationChannels")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.NotificationChannel> getNotificationChannels()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns all notification channels belonging to the calling package.
  jni.JniObject getNotificationChannels() =>
      jni.JniObject.fromRef(_getNotificationChannels(reference).object);

  static final _deleteNotificationChannel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__deleteNotificationChannel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void deleteNotificationChannel(java.lang.String channelId)
  ///
  /// Deletes the given notification channel.
  ///
  /// If you \#createNotificationChannel(NotificationChannel) create a new channel with
  /// this same id, the deleted channel will be un-deleted with all of the same settings it
  /// had before it was deleted.
  void deleteNotificationChannel(jni.JniString channelId) =>
      _deleteNotificationChannel(reference, channelId.reference).check();

  static final _getNotificationChannelGroup = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__getNotificationChannelGroup")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.NotificationChannelGroup getNotificationChannelGroup(java.lang.String channelGroupId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the notification channel group settings for a given channel group id.
  ///
  /// The channel group must belong to your package, or null will be returned.
  NotificationChannelGroup getNotificationChannelGroup(
          jni.JniString channelGroupId) =>
      NotificationChannelGroup.fromRef(
          _getNotificationChannelGroup(reference, channelGroupId.reference)
              .object);

  static final _getNotificationChannelGroups = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__getNotificationChannelGroups")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.NotificationChannelGroup> getNotificationChannelGroups()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns all notification channel groups belonging to the calling app.
  jni.JniObject getNotificationChannelGroups() =>
      jni.JniObject.fromRef(_getNotificationChannelGroups(reference).object);

  static final _deleteNotificationChannelGroup = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__deleteNotificationChannelGroup")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void deleteNotificationChannelGroup(java.lang.String groupId)
  ///
  /// Deletes the given notification channel group, and all notification channels that
  /// belong to it.
  void deleteNotificationChannelGroup(jni.JniString groupId) =>
      _deleteNotificationChannelGroup(reference, groupId.reference).check();

  static final _getAutomaticZenRules = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__getAutomaticZenRules")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Map<java.lang.String,android.app.AutomaticZenRule> getAutomaticZenRules()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns AutomaticZenRules owned by the caller.
  ///
  ///
  /// Throws a SecurityException if policy access is granted to this package.
  /// See \#isNotificationPolicyAccessGranted.
  jni.JniObject getAutomaticZenRules() =>
      jni.JniObject.fromRef(_getAutomaticZenRules(reference).object);

  static final _getAutomaticZenRule = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__getAutomaticZenRule")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.AutomaticZenRule getAutomaticZenRule(java.lang.String id)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the AutomaticZenRule with the given id, if it exists and the caller has access.
  ///
  ///
  /// Throws a SecurityException if policy access is granted to this package.
  /// See \#isNotificationPolicyAccessGranted.
  ///
  ///
  /// Returns null if there are no zen rules that match the given id, or if the calling package
  /// doesn't own the matching rule. See AutomaticZenRule\#getOwner.
  AutomaticZenRule getAutomaticZenRule(jni.JniString id) =>
      AutomaticZenRule.fromRef(
          _getAutomaticZenRule(reference, id.reference).object);

  static final _addAutomaticZenRule = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__addAutomaticZenRule")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String addAutomaticZenRule(android.app.AutomaticZenRule automaticZenRule)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates the given zen rule.
  ///
  ///
  /// Throws a SecurityException if policy access is granted to this package.
  /// See \#isNotificationPolicyAccessGranted.
  ///@param automaticZenRule the rule to create.
  ///@return The id of the newly created rule; null if the rule could not be created.
  jni.JniString addAutomaticZenRule(AutomaticZenRule automaticZenRule) =>
      jni.JniString.fromRef(
          _addAutomaticZenRule(reference, automaticZenRule.reference).object);

  static final _updateAutomaticZenRule = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__updateAutomaticZenRule")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean updateAutomaticZenRule(java.lang.String id, android.app.AutomaticZenRule automaticZenRule)
  ///
  /// Updates the given zen rule.
  ///
  ///
  /// Throws a SecurityException if policy access is granted to this package.
  /// See \#isNotificationPolicyAccessGranted.
  ///
  ///
  /// Callers can only update rules that they own. See AutomaticZenRule\#getOwner.
  ///@param id The id of the rule to update
  ///@param automaticZenRule the rule to update.
  ///@return Whether the rule was successfully updated.
  bool updateAutomaticZenRule(
          jni.JniString id, AutomaticZenRule automaticZenRule) =>
      _updateAutomaticZenRule(
              reference, id.reference, automaticZenRule.reference)
          .boolean;

  static final _removeAutomaticZenRule = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__removeAutomaticZenRule")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean removeAutomaticZenRule(java.lang.String id)
  ///
  /// Deletes the automatic zen rule with the given id.
  ///
  ///
  /// Throws a SecurityException if policy access is granted to this package.
  /// See \#isNotificationPolicyAccessGranted.
  ///
  ///
  /// Callers can only delete rules that they own. See AutomaticZenRule\#getOwner.
  ///@param id the id of the rule to delete.
  ///@return Whether the rule was successfully deleted.
  bool removeAutomaticZenRule(jni.JniString id) =>
      _removeAutomaticZenRule(reference, id.reference).boolean;

  static final _getImportance = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NotificationManager__getImportance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getImportance()
  ///
  /// Returns the user specified importance for notifications from the calling
  /// package.
  ///@return Value is android.app.NotificationManager\#IMPORTANCE_UNSPECIFIED, android.app.NotificationManager\#IMPORTANCE_NONE, android.app.NotificationManager\#IMPORTANCE_MIN, android.app.NotificationManager\#IMPORTANCE_LOW, android.app.NotificationManager\#IMPORTANCE_DEFAULT, or android.app.NotificationManager\#IMPORTANCE_HIGH
  int getImportance() => _getImportance(reference).integer;

  static final _areNotificationsEnabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__areNotificationsEnabled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean areNotificationsEnabled()
  ///
  /// Returns whether notifications from the calling package are blocked.
  bool areNotificationsEnabled() => _areNotificationsEnabled(reference).boolean;

  static final _isNotificationPolicyAccessGranted = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__isNotificationPolicyAccessGranted")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isNotificationPolicyAccessGranted()
  ///
  /// Checks the ability to modify notification do not disturb policy for the calling package.
  ///
  ///
  /// Returns true if the calling package can modify notification policy.
  ///
  ///
  /// Apps can request policy access by sending the user to the activity that matches the system
  /// intent action android.provider.Settings\#ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS.
  ///
  ///
  /// Use \#ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED to listen for
  /// user grant or denial of this access.
  bool isNotificationPolicyAccessGranted() =>
      _isNotificationPolicyAccessGranted(reference).boolean;

  static final _isNotificationListenerAccessGranted = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__isNotificationListenerAccessGranted")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isNotificationListenerAccessGranted(android.content.ComponentName listener)
  ///
  /// Checks whether the user has approved a given
  /// android.service.notification.NotificationListenerService.
  ///
  ///
  /// The listener service must belong to the calling app.
  ///
  ///
  /// Apps can request notification listener access by sending the user to the activity that
  /// matches the system intent action
  /// android.provider.Settings\#ACTION_NOTIFICATION_LISTENER_SETTINGS.
  bool isNotificationListenerAccessGranted(content_.ComponentName listener) =>
      _isNotificationListenerAccessGranted(reference, listener.reference)
          .boolean;

  static final _getNotificationPolicy = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__getNotificationPolicy")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.NotificationManager.Policy getNotificationPolicy()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the current notification policy.
  ///
  ///
  NotificationManager_Policy getNotificationPolicy() =>
      NotificationManager_Policy.fromRef(
          _getNotificationPolicy(reference).object);

  static final _setNotificationPolicy = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__setNotificationPolicy")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setNotificationPolicy(android.app.NotificationManager.Policy policy)
  ///
  /// Sets the current notification policy.
  ///
  ///
  /// Only available if policy access is granted to this package.
  /// See \#isNotificationPolicyAccessGranted.
  ///@param policy The new desired policy.
  ///
  /// This value must never be {@code null}.
  void setNotificationPolicy(NotificationManager_Policy policy) =>
      _setNotificationPolicy(reference, policy.reference).check();

  static final _getActiveNotifications = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__getActiveNotifications")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.service.notification.StatusBarNotification[] getActiveNotifications()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Recover a list of active notifications: ones that have been posted by the calling app that
  /// have not yet been dismissed by the user or \#cancel(String, int)ed by the app.
  ///
  /// Each notification is embedded in a StatusBarNotification object, including the
  /// original <code>tag</code> and <code>id</code> supplied to
  /// \#notify(String, int, Notification) notify()
  /// (via StatusBarNotification\#getTag() getTag() and
  /// StatusBarNotification\#getId() getId()) as well as a copy of the original
  /// Notification object (via StatusBarNotification\#getNotification()).
  ///@return An array of StatusBarNotification.
  jni.JniObject getActiveNotifications() =>
      jni.JniObject.fromRef(_getActiveNotifications(reference).object);

  static final _getCurrentInterruptionFilter = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationManager__getCurrentInterruptionFilter")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int getCurrentInterruptionFilter()
  ///
  /// Gets the current notification interruption filter.
  ///
  /// The interruption filter defines which notifications are allowed to
  /// interrupt the user (e.g. via sound &amp; vibration) and is applied
  /// globally.
  ///@return Value is android.app.NotificationManager\#INTERRUPTION_FILTER_NONE, android.app.NotificationManager\#INTERRUPTION_FILTER_PRIORITY, android.app.NotificationManager\#INTERRUPTION_FILTER_ALARMS, android.app.NotificationManager\#INTERRUPTION_FILTER_ALL, or android.app.NotificationManager\#INTERRUPTION_FILTER_UNKNOWN
  int getCurrentInterruptionFilter() =>
      _getCurrentInterruptionFilter(reference).integer;

  static final _setInterruptionFilter = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("NotificationManager__setInterruptionFilter")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void setInterruptionFilter(int interruptionFilter)
  ///
  /// Sets the current notification interruption filter.
  ///
  /// The interruption filter defines which notifications are allowed to
  /// interrupt the user (e.g. via sound &amp; vibration) and is applied
  /// globally.
  ///
  /// Only available if policy access is granted to this package. See
  /// \#isNotificationPolicyAccessGranted.
  ///@param interruptionFilter Value is android.app.NotificationManager\#INTERRUPTION_FILTER_NONE, android.app.NotificationManager\#INTERRUPTION_FILTER_PRIORITY, android.app.NotificationManager\#INTERRUPTION_FILTER_ALARMS, android.app.NotificationManager\#INTERRUPTION_FILTER_ALL, or android.app.NotificationManager\#INTERRUPTION_FILTER_UNKNOWN
  void setInterruptionFilter(int interruptionFilter) =>
      _setInterruptionFilter(reference, interruptionFilter).check();
}

/// from: android.app.NotificationManager$Policy
///
/// Notification policy configuration.  Represents user-preferences for notification
/// filtering.
class NotificationManager_Policy extends jni.JniObject {
  NotificationManager_Policy.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_NotificationManager_Policy__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.NotificationManager.Policy> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  /// from: static public final int PRIORITY_CATEGORY_ALARMS
  ///
  /// Alarms are prioritized
  static const PRIORITY_CATEGORY_ALARMS = 32;

  /// from: static public final int PRIORITY_CATEGORY_CALLS
  ///
  /// Calls are prioritized.
  static const PRIORITY_CATEGORY_CALLS = 8;

  /// from: static public final int PRIORITY_CATEGORY_EVENTS
  ///
  /// Event notifications are prioritized.
  static const PRIORITY_CATEGORY_EVENTS = 2;

  /// from: static public final int PRIORITY_CATEGORY_MEDIA
  ///
  /// Media, game, voice navigation are prioritized
  static const PRIORITY_CATEGORY_MEDIA = 64;

  /// from: static public final int PRIORITY_CATEGORY_MESSAGES
  ///
  /// Message notifications are prioritized.
  static const PRIORITY_CATEGORY_MESSAGES = 4;

  /// from: static public final int PRIORITY_CATEGORY_REMINDERS
  ///
  /// Reminder notifications are prioritized.
  static const PRIORITY_CATEGORY_REMINDERS = 1;

  /// from: static public final int PRIORITY_CATEGORY_REPEAT_CALLERS
  ///
  /// Calls from repeat callers are prioritized.
  static const PRIORITY_CATEGORY_REPEAT_CALLERS = 16;

  /// from: static public final int PRIORITY_CATEGORY_SYSTEM
  ///
  /// System (catch-all for non-never suppressible sounds) are prioritized
  static const PRIORITY_CATEGORY_SYSTEM = 128;

  /// from: static public final int PRIORITY_SENDERS_ANY
  ///
  /// Any sender is prioritized.
  static const PRIORITY_SENDERS_ANY = 0;

  /// from: static public final int PRIORITY_SENDERS_CONTACTS
  ///
  /// Saved contacts are prioritized.
  static const PRIORITY_SENDERS_CONTACTS = 1;

  /// from: static public final int PRIORITY_SENDERS_STARRED
  ///
  /// Only starred contacts are prioritized.
  static const PRIORITY_SENDERS_STARRED = 2;

  /// from: static public final int SUPPRESSED_EFFECT_AMBIENT
  ///
  /// Whether notification intercepted by DND are prevented from appearing on ambient displays
  /// on devices that support ambient display.
  static const SUPPRESSED_EFFECT_AMBIENT = 128;

  /// from: static public final int SUPPRESSED_EFFECT_BADGE
  ///
  /// Whether NotificationChannel\#canShowBadge() badges from
  /// notifications intercepted by DND are blocked on devices that support badging.
  static const SUPPRESSED_EFFECT_BADGE = 64;

  /// from: static public final int SUPPRESSED_EFFECT_FULL_SCREEN_INTENT
  ///
  /// Whether Notification\#fullScreenIntent full screen intents from
  /// notifications intercepted by DND are blocked.
  static const SUPPRESSED_EFFECT_FULL_SCREEN_INTENT = 4;

  /// from: static public final int SUPPRESSED_EFFECT_LIGHTS
  ///
  /// Whether NotificationChannel\#shouldShowLights() notification lights from
  /// notifications intercepted by DND are blocked.
  static const SUPPRESSED_EFFECT_LIGHTS = 8;

  /// from: static public final int SUPPRESSED_EFFECT_NOTIFICATION_LIST
  ///
  /// Whether notification intercepted by DND are prevented from appearing in notification
  /// list views like the notification shade or lockscreen on devices that support those
  /// views.
  static const SUPPRESSED_EFFECT_NOTIFICATION_LIST = 256;

  /// from: static public final int SUPPRESSED_EFFECT_PEEK
  ///
  /// Whether notifications intercepted by DND are prevented from peeking.
  static const SUPPRESSED_EFFECT_PEEK = 16;

  /// from: static public final int SUPPRESSED_EFFECT_SCREEN_OFF
  ///
  /// Whether notifications suppressed by DND should not interrupt visually (e.g.&nbsp;with
  /// notification lights or by turning the screen on) when the screen is off.
  ///@deprecated use \#SUPPRESSED_EFFECT_FULL_SCREEN_INTENT and
  /// \#SUPPRESSED_EFFECT_AMBIENT and \#SUPPRESSED_EFFECT_LIGHTS individually.
  static const SUPPRESSED_EFFECT_SCREEN_OFF = 1;

  /// from: static public final int SUPPRESSED_EFFECT_SCREEN_ON
  ///
  /// Whether notifications suppressed by DND should not interrupt visually when the screen
  /// is on (e.g.&nbsp;by peeking onto the screen).
  ///@deprecated use \#SUPPRESSED_EFFECT_PEEK.
  static const SUPPRESSED_EFFECT_SCREEN_ON = 2;

  /// from: static public final int SUPPRESSED_EFFECT_STATUS_BAR
  ///
  /// Whether notifications intercepted by DND are prevented from appearing in the status bar,
  /// on devices that support status bars.
  static const SUPPRESSED_EFFECT_STATUS_BAR = 32;

  static final _get_priorityCallSenders = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_NotificationManager_Policy__priorityCallSenders")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public final int priorityCallSenders
  ///
  /// Notification senders to prioritize for calls. One of:
  /// PRIORITY_SENDERS_ANY, PRIORITY_SENDERS_CONTACTS, PRIORITY_SENDERS_STARRED
  int get priorityCallSenders => _get_priorityCallSenders(reference).integer;

  static final _get_priorityCategories = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_NotificationManager_Policy__priorityCategories")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public final int priorityCategories
  ///
  /// Notification categories to prioritize. Bitmask of PRIORITY_CATEGORY_* constants.
  int get priorityCategories => _get_priorityCategories(reference).integer;

  static final _get_priorityMessageSenders = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_NotificationManager_Policy__priorityMessageSenders")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public final int priorityMessageSenders
  ///
  /// Notification senders to prioritize for messages. One of:
  /// PRIORITY_SENDERS_ANY, PRIORITY_SENDERS_CONTACTS, PRIORITY_SENDERS_STARRED
  int get priorityMessageSenders =>
      _get_priorityMessageSenders(reference).integer;

  static final _get_suppressedVisualEffects = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
    jni.JObject,
  )>>("get_NotificationManager_Policy__suppressedVisualEffects")
      .asFunction<
          jni.JniResult Function(
    jni.JObject,
  )>();

  /// from: public final int suppressedVisualEffects
  ///
  /// Visual effects to suppress for a notification that is filtered by Do Not Disturb mode.
  /// Bitmask of SUPPRESSED_EFFECT_* constants.
  int get suppressedVisualEffects =>
      _get_suppressedVisualEffects(reference).integer;

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Int32, ffi.Int32,
                  ffi.Int32)>>("NotificationManager_Policy__ctor")
      .asFunction<jni.JniResult Function(int, int, int)>();

  /// from: public void <init>(int priorityCategories, int priorityCallSenders, int priorityMessageSenders)
  ///
  /// Constructs a policy for Do Not Disturb priority mode behavior.
  ///
  ///
  ///     Apps that target API levels below Build.VERSION_CODES\#P cannot
  ///     change user-designated values to allow or disallow
  ///     Policy\#PRIORITY_CATEGORY_ALARMS, Policy\#PRIORITY_CATEGORY_SYSTEM, and
  ///     Policy\#PRIORITY_CATEGORY_MEDIA from bypassing dnd.
  ///@param priorityCategories bitmask of categories of notifications that can bypass DND.
  ///@param priorityCallSenders which callers can bypass DND.
  ///@param priorityMessageSenders which message senders can bypass DND.
  NotificationManager_Policy(int priorityCategories, int priorityCallSenders,
      int priorityMessageSenders)
      : super.fromRef(_ctor(
                priorityCategories, priorityCallSenders, priorityMessageSenders)
            .object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Int32, ffi.Int32, ffi.Int32,
                  ffi.Int32)>>("NotificationManager_Policy__ctor1")
      .asFunction<jni.JniResult Function(int, int, int, int)>();

  /// from: public void <init>(int priorityCategories, int priorityCallSenders, int priorityMessageSenders, int suppressedVisualEffects)
  ///
  /// Constructs a policy for Do Not Disturb priority mode behavior.
  ///
  ///
  ///     Apps that target API levels below Build.VERSION_CODES\#P cannot
  ///     change user-designated values to allow or disallow
  ///     Policy\#PRIORITY_CATEGORY_ALARMS, Policy\#PRIORITY_CATEGORY_SYSTEM, and
  ///     Policy\#PRIORITY_CATEGORY_MEDIA from bypassing dnd.
  ///
  ///     Additionally, apps that target API levels below Build.VERSION_CODES\#P can
  ///     only modify the \#SUPPRESSED_EFFECT_SCREEN_ON and
  ///     \#SUPPRESSED_EFFECT_SCREEN_OFF bits of the suppressed visual effects field.
  ///     All other suppressed effects will be ignored and reconstituted from the screen on
  ///     and screen off values.
  ///
  ///     Apps that target Build.VERSION_CODES\#P or above can set any
  ///     suppressed visual effects. However, if any suppressed effects >
  ///     \#SUPPRESSED_EFFECT_SCREEN_ON are set, \#SUPPRESSED_EFFECT_SCREEN_ON
  ///     and \#SUPPRESSED_EFFECT_SCREEN_OFF will be ignored and reconstituted from
  ///     the more specific suppressed visual effect bits. Apps should migrate to targeting
  ///     specific effects instead of the deprecated \#SUPPRESSED_EFFECT_SCREEN_ON and
  ///     \#SUPPRESSED_EFFECT_SCREEN_OFF effects.
  ///@param priorityCategories bitmask of categories of notifications that can bypass DND.
  ///@param priorityCallSenders which callers can bypass DND.
  ///@param priorityMessageSenders which message senders can bypass DND.
  ///@param suppressedVisualEffects which visual interruptions should be suppressed from
  ///                                notifications that are filtered by DND.
  NotificationManager_Policy.ctor1(
      int priorityCategories,
      int priorityCallSenders,
      int priorityMessageSenders,
      int suppressedVisualEffects)
      : super.fromRef(_ctor1(priorityCategories, priorityCallSenders,
                priorityMessageSenders, suppressedVisualEffects)
            .object);

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("NotificationManager_Policy__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationManager_Policy__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _hashCode1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationManager_Policy__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() => _hashCode1(reference).integer;

  static final _equals1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NotificationManager_Policy__equals1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => _equals1(reference, o.reference).boolean;

  static final _toString1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NotificationManager_Policy__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);

  static final _suppressedEffectsToString =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "NotificationManager_Policy__suppressedEffectsToString")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public java.lang.String suppressedEffectsToString(int effects)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniString suppressedEffectsToString(int effects) =>
      jni.JniString.fromRef(_suppressedEffectsToString(effects).object);

  static final _priorityCategoriesToString =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "NotificationManager_Policy__priorityCategoriesToString")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public java.lang.String priorityCategoriesToString(int priorityCategories)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniString priorityCategoriesToString(int priorityCategories) =>
      jni.JniString.fromRef(
          _priorityCategoriesToString(priorityCategories).object);

  static final _prioritySendersToString =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "NotificationManager_Policy__prioritySendersToString")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public java.lang.String prioritySendersToString(int prioritySenders)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JniString prioritySendersToString(int prioritySenders) =>
      jni.JniString.fromRef(_prioritySendersToString(prioritySenders).object);
}

/// from: android.app.PendingIntent
///
/// A description of an Intent and target action to perform with it.  Instances
/// of this class are created with \#getActivity, \#getActivities,
/// \#getBroadcast, and \#getService; the returned object can be
/// handed to other applications so that they can perform the action you
/// described on your behalf at a later time.
///
/// By giving a PendingIntent to another application,
/// you are granting it the right to perform the operation you have specified
/// as if the other application was yourself (with the same permissions and
/// identity).  As such, you should be careful about how you build the PendingIntent:
/// almost always, for example, the base Intent you supply should have the component
/// name explicitly set to one of your own components, to ensure it is ultimately
/// sent there and nowhere else.
///
/// A PendingIntent itself is simply a reference to a token maintained by
/// the system describing the original data used to retrieve it.  This means
/// that, even if its owning application's process is killed, the
/// PendingIntent itself will remain usable from other processes that
/// have been given it.  If the creating application later re-retrieves the
/// same kind of PendingIntent (same operation, same Intent action, data,
/// categories, and components, and same flags), it will receive a PendingIntent
/// representing the same token if that is still valid, and can thus call
/// \#cancel to remove it.
///
/// Because of this behavior, it is important to know when two Intents
/// are considered to be the same for purposes of retrieving a PendingIntent.
/// A common mistake people make is to create multiple PendingIntent objects
/// with Intents that only vary in their "extra" contents, expecting to get
/// a different PendingIntent each time.  This does _not_ happen.  The
/// parts of the Intent that are used for matching are the same ones defined
/// by Intent\#filterEquals(Intent) Intent.filterEquals.  If you use two
/// Intent objects that are equivalent as per
/// Intent\#filterEquals(Intent) Intent.filterEquals, then you will get
/// the same PendingIntent for both of them.
///
/// There are two typical ways to deal with this.
///
/// If you truly need multiple distinct PendingIntent objects active at
/// the same time (such as to use as two notifications that are both shown
/// at the same time), then you will need to ensure there is something that
/// is different about them to associate them with different PendingIntents.
/// This may be any of the Intent attributes considered by
/// Intent\#filterEquals(Intent) Intent.filterEquals, or different
/// request code integers supplied to \#getActivity, \#getActivities,
/// \#getBroadcast, or \#getService.
///
/// If you only need one PendingIntent active at a time for any of the
/// Intents you will use, then you can alternatively use the flags
/// \#FLAG_CANCEL_CURRENT or \#FLAG_UPDATE_CURRENT to either
/// cancel or modify whatever current PendingIntent is associated with the
/// Intent you are supplying.
class PendingIntent extends jni.JniObject {
  PendingIntent.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_PendingIntent__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.PendingIntent> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  /// from: static public final int FLAG_CANCEL_CURRENT
  ///
  /// Flag indicating that if the described PendingIntent already exists,
  /// the current one should be canceled before generating a new one.
  /// For use with \#getActivity, \#getBroadcast, and
  /// \#getService. You can use
  /// this to retrieve a new PendingIntent when you are only changing the
  /// extra data in the Intent; by canceling the previous pending intent,
  /// this ensures that only entities given the new data will be able to
  /// launch it.  If this assurance is not an issue, consider
  /// \#FLAG_UPDATE_CURRENT.
  static const FLAG_CANCEL_CURRENT = 268435456;

  /// from: static public final int FLAG_IMMUTABLE
  ///
  /// Flag indicating that the created PendingIntent should be immutable.
  /// This means that the additional intent argument passed to the send
  /// methods to fill in unpopulated properties of this intent will be
  /// ignored.
  static const FLAG_IMMUTABLE = 67108864;

  /// from: static public final int FLAG_NO_CREATE
  ///
  /// Flag indicating that if the described PendingIntent does not
  /// already exist, then simply return null instead of creating it.
  /// For use with \#getActivity, \#getBroadcast, and
  /// \#getService.
  static const FLAG_NO_CREATE = 536870912;

  /// from: static public final int FLAG_ONE_SHOT
  ///
  /// Flag indicating that this PendingIntent can be used only once.
  /// For use with \#getActivity, \#getBroadcast, and
  /// \#getService. If set, after
  /// \#send() is called on it, it will be automatically
  /// canceled for you and any future attempt to send through it will fail.
  static const FLAG_ONE_SHOT = 1073741824;

  /// from: static public final int FLAG_UPDATE_CURRENT
  ///
  /// Flag indicating that if the described PendingIntent already exists,
  /// then keep it but replace its extra data with what is in this new
  /// Intent. For use with \#getActivity, \#getBroadcast, and
  /// \#getService. This can be used if you are creating intents where only the
  /// extras change, and don't care that any entities that received your
  /// previous PendingIntent will be able to launch it with your new
  /// extras even if they are not explicitly given to it.
  static const FLAG_UPDATE_CURRENT = 134217728;

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PendingIntent__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.IBinder target, java.lang.Object cookie)
  PendingIntent(os_.IBinder target, jni.JniObject cookie)
      : super.fromRef(_ctor(target.reference, cookie.reference).object);

  static final _getActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("PendingIntent__getActivity")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.app.PendingIntent getActivity(android.content.Context context, int requestCode, android.content.Intent intent, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a PendingIntent that will start a new activity, like calling
  /// Context\#startActivity(Intent) Context.startActivity(Intent).
  /// Note that the activity will be started outside of the context of an
  /// existing activity, so you must use the Intent\#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK launch flag in the Intent.
  ///
  /// <p class="note">For security reasons, the android.content.Intent
  /// you supply here should almost always be an _explicit intent_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should start
  /// the activity.
  ///@param requestCode Private request code for the sender
  ///@param intent Intent of the activity to be launched.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getActivity(content_.Context context, int requestCode,
          content_.Intent intent, int flags) =>
      PendingIntent.fromRef(
          _getActivity(context.reference, requestCode, intent.reference, flags)
              .object);

  static final _getActivity1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("PendingIntent__getActivity1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.PendingIntent getActivity(android.content.Context context, int requestCode, android.content.Intent intent, int flags, android.os.Bundle options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a PendingIntent that will start a new activity, like calling
  /// Context\#startActivity(Intent) Context.startActivity(Intent).
  /// Note that the activity will be started outside of the context of an
  /// existing activity, so you must use the Intent\#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK launch flag in the Intent.
  ///
  /// <p class="note">For security reasons, the android.content.Intent
  /// you supply here should almost always be an _explicit intent_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should start
  /// the activity.
  ///@param requestCode Private request code for the sender
  ///@param intent Intent of the activity to be launched.
  /// This value must never be {@code null}.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@param options Additional options for how the Activity should be started.
  /// May be null if there are no options.
  ///
  /// This value may be {@code null}.
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getActivity1(content_.Context context, int requestCode,
          content_.Intent intent, int flags, os_.Bundle options) =>
      PendingIntent.fromRef(_getActivity1(context.reference, requestCode,
              intent.reference, flags, options.reference)
          .object);

  static final _getActivities = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("PendingIntent__getActivities")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.app.PendingIntent getActivities(android.content.Context context, int requestCode, android.content.Intent[] intents, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#getActivity(Context, int, Intent, int), but allows an
  /// array of Intents to be supplied.  The last Intent in the array is
  /// taken as the primary key for the PendingIntent, like the single Intent
  /// given to \#getActivity(Context, int, Intent, int).  Upon sending
  /// the resulting PendingIntent, all of the Intents are started in the same
  /// way as they would be by passing them to Context\#startActivities(Intent[]).
  ///
  /// <p class="note">
  /// The _first_ intent in the array will be started outside of the context of an
  /// existing activity, so you must use the Intent\#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK launch flag in the Intent.  (Activities after
  /// the first in the array are started in the context of the previous activity
  /// in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
  ///
  ///
  ///
  /// <p class="note">
  /// The _last_ intent in the array represents the key for the
  /// PendingIntent.  In other words, it is the significant element for matching
  /// (as done with the single intent given to \#getActivity(Context, int, Intent, int),
  /// its content will be the subject of replacement by
  /// \#send(Context, int, Intent) and \#FLAG_UPDATE_CURRENT, etc.
  /// This is because it is the most specific of the supplied intents, and the
  /// UI the user actually sees when the intents are started.
  ///
  ///
  ///
  /// <p class="note">For security reasons, the android.content.Intent objects
  /// you supply here should almost always be _explicit intents_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should start
  /// the activity.
  ///@param requestCode Private request code for the sender
  ///@param intents Array of Intents of the activities to be launched.
  /// This value must never be {@code null}.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getActivities(content_.Context context, int requestCode,
          jni.JniObject intents, int flags) =>
      PendingIntent.fromRef(_getActivities(
              context.reference, requestCode, intents.reference, flags)
          .object);

  static final _getActivities1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("PendingIntent__getActivities1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.PendingIntent getActivities(android.content.Context context, int requestCode, android.content.Intent[] intents, int flags, android.os.Bundle options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#getActivity(Context, int, Intent, int), but allows an
  /// array of Intents to be supplied.  The last Intent in the array is
  /// taken as the primary key for the PendingIntent, like the single Intent
  /// given to \#getActivity(Context, int, Intent, int).  Upon sending
  /// the resulting PendingIntent, all of the Intents are started in the same
  /// way as they would be by passing them to Context\#startActivities(Intent[]).
  ///
  /// <p class="note">
  /// The _first_ intent in the array will be started outside of the context of an
  /// existing activity, so you must use the Intent\#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK launch flag in the Intent.  (Activities after
  /// the first in the array are started in the context of the previous activity
  /// in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
  ///
  ///
  ///
  /// <p class="note">
  /// The _last_ intent in the array represents the key for the
  /// PendingIntent.  In other words, it is the significant element for matching
  /// (as done with the single intent given to \#getActivity(Context, int, Intent, int),
  /// its content will be the subject of replacement by
  /// \#send(Context, int, Intent) and \#FLAG_UPDATE_CURRENT, etc.
  /// This is because it is the most specific of the supplied intents, and the
  /// UI the user actually sees when the intents are started.
  ///
  ///
  ///
  /// <p class="note">For security reasons, the android.content.Intent objects
  /// you supply here should almost always be _explicit intents_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should start
  /// the activity.
  ///@param requestCode Private request code for the sender
  ///@param intents Array of Intents of the activities to be launched.
  /// This value must never be {@code null}.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// \#FLAG_IMMUTABLE or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@param options This value may be {@code null}.
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getActivities1(content_.Context context, int requestCode,
          jni.JniObject intents, int flags, os_.Bundle options) =>
      PendingIntent.fromRef(_getActivities1(context.reference, requestCode,
              intents.reference, flags, options.reference)
          .object);

  static final _getBroadcast = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("PendingIntent__getBroadcast")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.app.PendingIntent getBroadcast(android.content.Context context, int requestCode, android.content.Intent intent, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a PendingIntent that will perform a broadcast, like calling
  /// Context\#sendBroadcast(Intent) Context.sendBroadcast().
  ///
  /// <p class="note">For security reasons, the android.content.Intent
  /// you supply here should almost always be an _explicit intent_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should perform
  /// the broadcast.
  ///@param requestCode Private request code for the sender
  ///@param intent The Intent to be broadcast.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// \#FLAG_IMMUTABLE or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getBroadcast(content_.Context context, int requestCode,
          content_.Intent intent, int flags) =>
      PendingIntent.fromRef(
          _getBroadcast(context.reference, requestCode, intent.reference, flags)
              .object);

  static final _getService = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("PendingIntent__getService")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.app.PendingIntent getService(android.content.Context context, int requestCode, android.content.Intent intent, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a PendingIntent that will start a service, like calling
  /// Context\#startService Context.startService().  The start
  /// arguments given to the service will come from the extras of the Intent.
  ///
  /// <p class="note">For security reasons, the android.content.Intent
  /// you supply here should almost always be an _explicit intent_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should start
  /// the service.
  ///@param requestCode Private request code for the sender
  ///@param intent An Intent describing the service to be started.
  /// This value must never be {@code null}.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// \#FLAG_IMMUTABLE or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getService(content_.Context context, int requestCode,
          content_.Intent intent, int flags) =>
      PendingIntent.fromRef(
          _getService(context.reference, requestCode, intent.reference, flags)
              .object);

  static final _getForegroundService = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("PendingIntent__getForegroundService")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.app.PendingIntent getForegroundService(android.content.Context context, int requestCode, android.content.Intent intent, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a PendingIntent that will start a foreground service, like calling
  /// Context\#startForegroundService Context.startForegroundService().  The start
  /// arguments given to the service will come from the extras of the Intent.
  ///
  /// <p class="note">For security reasons, the android.content.Intent
  /// you supply here should almost always be an _explicit intent_,
  /// that is specify an explicit component to be delivered to through
  /// Intent\#setClass(android.content.Context, Class) Intent.setClass
  ///
  ///@param context The Context in which this PendingIntent should start
  /// the service.
  ///@param requestCode Private request code for the sender
  ///@param intent An Intent describing the service to be started.
  /// This value must never be {@code null}.
  ///@param flags May be \#FLAG_ONE_SHOT, \#FLAG_NO_CREATE,
  /// \#FLAG_CANCEL_CURRENT, \#FLAG_UPDATE_CURRENT,
  /// \#FLAG_IMMUTABLE or any of the flags as supported by
  /// Intent\#fillIn Intent.fillIn() to control which unspecified parts
  /// of the intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return Returns an existing or new PendingIntent matching the given
  /// parameters.  May return null only if \#FLAG_NO_CREATE has been
  /// supplied.
  static PendingIntent getForegroundService(content_.Context context,
          int requestCode, content_.Intent intent, int flags) =>
      PendingIntent.fromRef(_getForegroundService(
              context.reference, requestCode, intent.reference, flags)
          .object);

  static final _getIntentSender = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PendingIntent__getIntentSender")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.IntentSender getIntentSender()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a IntentSender object that wraps the existing sender of the PendingIntent
  ///@return Returns a IntentSender object that wraps the sender of PendingIntent
  content_.IntentSender getIntentSender() =>
      content_.IntentSender.fromRef(_getIntentSender(reference).object);

  static final _cancel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PendingIntent__cancel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void cancel()
  ///
  /// Cancel a currently active PendingIntent.  Only the original application
  /// owning a PendingIntent can cancel it.
  void cancel() => _cancel(reference).check();

  static final _send = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PendingIntent__send")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void send()
  ///
  /// Perform the operation associated with this PendingIntent.
  ///@see \#send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send() => _send(reference).check();

  static final _send1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("PendingIntent__send1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void send(int code)
  ///
  /// Perform the operation associated with this PendingIntent.
  ///@param code Result code to supply back to the PendingIntent's target.
  ///@see \#send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send1(int code) => _send1(reference, code).check();

  static final _send2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("PendingIntent__send2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public void send(android.content.Context context, int code, android.content.Intent intent)
  ///
  /// Perform the operation associated with this PendingIntent, allowing the
  /// caller to specify information about the Intent to use.
  ///@param context The Context of the caller.
  ///@param code Result code to supply back to the PendingIntent's target.
  ///@param intent Additional Intent data.  See Intent\#fillIn Intent.fillIn() for information on how this is applied to the
  /// original Intent. If flag \#FLAG_IMMUTABLE was set when this
  /// pending intent was created, this argument will be ignored.
  ///
  /// This value may be {@code null}.
  ///@see \#send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send2(content_.Context context, int code, content_.Intent intent) =>
      _send2(reference, context.reference, code, intent.reference).check();

  static final _send3 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PendingIntent__send3")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void send(int code, android.app.PendingIntent.OnFinished onFinished, android.os.Handler handler)
  ///
  /// Perform the operation associated with this PendingIntent, allowing the
  /// caller to be notified when the send has completed.
  ///@param code Result code to supply back to the PendingIntent's target.
  ///@param onFinished The object to call back on when the send has
  /// completed, or null for no callback.
  /// This value may be {@code null}.
  ///@param handler Handler identifying the thread on which the callback
  /// should happen.  If null, the callback will happen from the thread
  /// pool of the process.
  ///
  /// This value may be {@code null}.
  ///@see \#send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send3(
          int code, PendingIntent_OnFinished onFinished, os_.Handler handler) =>
      _send3(reference, code, onFinished.reference, handler.reference).check();

  static final _send4 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PendingIntent__send4")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void send(android.content.Context context, int code, android.content.Intent intent, android.app.PendingIntent.OnFinished onFinished, android.os.Handler handler)
  ///
  /// Perform the operation associated with this PendingIntent, allowing the
  /// caller to specify information about the Intent to use and be notified
  /// when the send has completed.
  ///
  /// For the intent parameter, a PendingIntent
  /// often has restrictions on which fields can be supplied here, based on
  /// how the PendingIntent was retrieved in \#getActivity,
  /// \#getBroadcast, or \#getService.
  ///@param context The Context of the caller.  This may be null if
  /// <var>intent</var> is also null.
  ///@param code Result code to supply back to the PendingIntent's target.
  ///@param intent Additional Intent data.  See Intent\#fillIn Intent.fillIn() for information on how this is applied to the
  /// original Intent.  Use null to not modify the original Intent.
  /// If flag \#FLAG_IMMUTABLE was set when this pending intent was
  /// created, this argument will be ignored.
  /// This value may be {@code null}.
  ///@param onFinished The object to call back on when the send has
  /// completed, or null for no callback.
  /// This value may be {@code null}.
  ///@param handler Handler identifying the thread on which the callback
  /// should happen.  If null, the callback will happen from the thread
  /// pool of the process.
  ///
  /// This value may be {@code null}.
  ///@see \#send()
  ///@see \#send(int)
  ///@see \#send(Context, int, Intent)
  ///@see \#send(int, android.app.PendingIntent.OnFinished, Handler)
  ///@see \#send(Context, int, Intent, OnFinished, Handler, String)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send4(content_.Context context, int code, content_.Intent intent,
          PendingIntent_OnFinished onFinished, os_.Handler handler) =>
      _send4(reference, context.reference, code, intent.reference,
              onFinished.reference, handler.reference)
          .check();

  static final _send5 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PendingIntent__send5")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void send(android.content.Context context, int code, android.content.Intent intent, android.app.PendingIntent.OnFinished onFinished, android.os.Handler handler, java.lang.String requiredPermission)
  ///
  /// Perform the operation associated with this PendingIntent, allowing the
  /// caller to specify information about the Intent to use and be notified
  /// when the send has completed.
  ///
  /// For the intent parameter, a PendingIntent
  /// often has restrictions on which fields can be supplied here, based on
  /// how the PendingIntent was retrieved in \#getActivity,
  /// \#getBroadcast, or \#getService.
  ///@param context The Context of the caller.  This may be null if
  /// <var>intent</var> is also null.
  ///@param code Result code to supply back to the PendingIntent's target.
  ///@param intent Additional Intent data.  See Intent\#fillIn Intent.fillIn() for information on how this is applied to the
  /// original Intent.  Use null to not modify the original Intent.
  /// If flag \#FLAG_IMMUTABLE was set when this pending intent was
  /// created, this argument will be ignored.
  /// This value may be {@code null}.
  ///@param onFinished The object to call back on when the send has
  /// completed, or null for no callback.
  /// This value may be {@code null}.
  ///@param handler Handler identifying the thread on which the callback
  /// should happen.  If null, the callback will happen from the thread
  /// pool of the process.
  /// This value may be {@code null}.
  ///@param requiredPermission Name of permission that a recipient of the PendingIntent
  /// is required to hold.  This is only valid for broadcast intents, and
  /// corresponds to the permission argument in
  /// Context\#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String).
  /// If null, no permission is required.
  ///
  /// This value may be {@code null}.
  ///@see \#send()
  ///@see \#send(int)
  ///@see \#send(Context, int, Intent)
  ///@see \#send(int, android.app.PendingIntent.OnFinished, Handler)
  ///@see \#send(Context, int, Intent, OnFinished, Handler)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send5(
          content_.Context context,
          int code,
          content_.Intent intent,
          PendingIntent_OnFinished onFinished,
          os_.Handler handler,
          jni.JniString requiredPermission) =>
      _send5(
              reference,
              context.reference,
              code,
              intent.reference,
              onFinished.reference,
              handler.reference,
              requiredPermission.reference)
          .check();

  static final _send6 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PendingIntent__send6")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void send(android.content.Context context, int code, android.content.Intent intent, android.app.PendingIntent.OnFinished onFinished, android.os.Handler handler, java.lang.String requiredPermission, android.os.Bundle options)
  ///
  /// Perform the operation associated with this PendingIntent, allowing the
  /// caller to specify information about the Intent to use and be notified
  /// when the send has completed.
  ///
  /// For the intent parameter, a PendingIntent
  /// often has restrictions on which fields can be supplied here, based on
  /// how the PendingIntent was retrieved in \#getActivity,
  /// \#getBroadcast, or \#getService.
  ///@param context The Context of the caller.  This may be null if
  /// <var>intent</var> is also null.
  ///@param code Result code to supply back to the PendingIntent's target.
  ///@param intent Additional Intent data.  See Intent\#fillIn Intent.fillIn() for information on how this is applied to the
  /// original Intent.  Use null to not modify the original Intent.
  /// If flag \#FLAG_IMMUTABLE was set when this pending intent was
  /// created, this argument will be ignored.
  /// This value may be {@code null}.
  ///@param onFinished The object to call back on when the send has
  /// completed, or null for no callback.
  /// This value may be {@code null}.
  ///@param handler Handler identifying the thread on which the callback
  /// should happen.  If null, the callback will happen from the thread
  /// pool of the process.
  /// This value may be {@code null}.
  ///@param requiredPermission Name of permission that a recipient of the PendingIntent
  /// is required to hold.  This is only valid for broadcast intents, and
  /// corresponds to the permission argument in
  /// Context\#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String).
  /// If null, no permission is required.
  /// This value may be {@code null}.
  ///@param options Additional options the caller would like to provide to modify the sending
  /// behavior.  May be built from an ActivityOptions to apply to an activity start.
  ///
  /// This value may be {@code null}.
  ///@see \#send()
  ///@see \#send(int)
  ///@see \#send(Context, int, Intent)
  ///@see \#send(int, android.app.PendingIntent.OnFinished, Handler)
  ///@see \#send(Context, int, Intent, OnFinished, Handler)
  ///@throws CanceledException Throws CanceledException if the PendingIntent
  /// is no longer allowing more intents to be sent through it.
  void send6(
          content_.Context context,
          int code,
          content_.Intent intent,
          PendingIntent_OnFinished onFinished,
          os_.Handler handler,
          jni.JniString requiredPermission,
          os_.Bundle options) =>
      _send6(
              reference,
              context.reference,
              code,
              intent.reference,
              onFinished.reference,
              handler.reference,
              requiredPermission.reference,
              options.reference)
          .check();

  static final _getTargetPackage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PendingIntent__getTargetPackage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getTargetPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @deprecated Renamed to \#getCreatorPackage().
  jni.JniString getTargetPackage() =>
      jni.JniString.fromRef(_getTargetPackage(reference).object);

  static final _getCreatorPackage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PendingIntent__getCreatorPackage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getCreatorPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the package name of the application that created this
  /// PendingIntent, that is the identity under which you will actually be
  /// sending the Intent.  The returned string is supplied by the system, so
  /// that an application can not spoof its package.
  ///
  /// <p class="note">Be careful about how you use this.  All this tells you is
  /// who created the PendingIntent.  It does <strong>not</strong> tell you who
  /// handed the PendingIntent to you: that is, PendingIntent objects are intended to be
  /// passed between applications, so the PendingIntent you receive from an application
  /// could actually be one it received from another application, meaning the result
  /// you get here will identify the original application.  Because of this, you should
  /// only use this information to identify who you expect to be interacting with
  /// through a \#send call, not who gave you the PendingIntent.
  ///
  ///@return The package name of the PendingIntent, or null if there is
  /// none associated with it.
  jni.JniString getCreatorPackage() =>
      jni.JniString.fromRef(_getCreatorPackage(reference).object);

  static final _getCreatorUid = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PendingIntent__getCreatorUid")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getCreatorUid()
  ///
  /// Return the uid of the application that created this
  /// PendingIntent, that is the identity under which you will actually be
  /// sending the Intent.  The returned integer is supplied by the system, so
  /// that an application can not spoof its uid.
  ///
  /// <p class="note">Be careful about how you use this.  All this tells you is
  /// who created the PendingIntent.  It does <strong>not</strong> tell you who
  /// handed the PendingIntent to you: that is, PendingIntent objects are intended to be
  /// passed between applications, so the PendingIntent you receive from an application
  /// could actually be one it received from another application, meaning the result
  /// you get here will identify the original application.  Because of this, you should
  /// only use this information to identify who you expect to be interacting with
  /// through a \#send call, not who gave you the PendingIntent.
  ///
  ///@return The uid of the PendingIntent, or -1 if there is
  /// none associated with it.
  int getCreatorUid() => _getCreatorUid(reference).integer;

  static final _getCreatorUserHandle = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PendingIntent__getCreatorUserHandle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.UserHandle getCreatorUserHandle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the user handle of the application that created this
  /// PendingIntent, that is the user under which you will actually be
  /// sending the Intent.  The returned UserHandle is supplied by the system, so
  /// that an application can not spoof its user.  See
  /// android.os.Process\#myUserHandle() Process.myUserHandle() for
  /// more explanation of user handles.
  ///
  /// <p class="note">Be careful about how you use this.  All this tells you is
  /// who created the PendingIntent.  It does <strong>not</strong> tell you who
  /// handed the PendingIntent to you: that is, PendingIntent objects are intended to be
  /// passed between applications, so the PendingIntent you receive from an application
  /// could actually be one it received from another application, meaning the result
  /// you get here will identify the original application.  Because of this, you should
  /// only use this information to identify who you expect to be interacting with
  /// through a \#send call, not who gave you the PendingIntent.
  ///
  ///@return The user handle of the PendingIntent, or null if there is
  /// none associated with it.
  os_.UserHandle getCreatorUserHandle() =>
      os_.UserHandle.fromRef(_getCreatorUserHandle(reference).object);

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("PendingIntent__equals1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object otherObj)
  ///
  /// Comparison operator on two PendingIntent objects, such that true
  /// is returned then they both represent the same operation from the
  /// same package.  This allows you to use \#getActivity,
  /// \#getBroadcast, or \#getService multiple times (even
  /// across a process being killed), resulting in different PendingIntent
  /// objects but whose equals() method identifies them as being the same
  /// operation.
  bool equals1(jni.JniObject otherObj) =>
      _equals1(reference, otherObj.reference).boolean;

  static final _hashCode1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PendingIntent__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() => _hashCode1(reference).integer;

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PendingIntent__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("PendingIntent__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("PendingIntent__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os_.Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags).check();

  static final _writePendingIntentOrNullToParcel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "PendingIntent__writePendingIntentOrNullToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void writePendingIntentOrNullToParcel(android.app.PendingIntent sender, android.os.Parcel out)
  ///
  /// Convenience function for writing either a PendingIntent or null pointer to
  /// a Parcel.  You must use this with \#readPendingIntentOrNullFromParcel
  /// for later reading it.
  ///@param sender The PendingIntent to write, or null.
  /// This value may be {@code null}.
  ///@param out Where to write the PendingIntent.
  ///
  /// This value must never be {@code null}.
  static void writePendingIntentOrNullToParcel(
          PendingIntent sender, os_.Parcel out) =>
      _writePendingIntentOrNullToParcel(sender.reference, out.reference)
          .check();

  static final _readPendingIntentOrNullFromParcel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PendingIntent__readPendingIntentOrNullFromParcel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.PendingIntent readPendingIntentOrNullFromParcel(android.os.Parcel in)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Convenience function for reading either a PendingIntent or null pointer from
  /// a Parcel.  You must have previously written the PendingIntent with
  /// \#writePendingIntentOrNullToParcel.
  ///@param in The Parcel containing the written PendingIntent.
  ///
  /// This value must never be {@code null}.
  ///@return Returns the PendingIntent read from the Parcel, or null if null had
  /// been written.
  static PendingIntent readPendingIntentOrNullFromParcel(os_.Parcel in0) =>
      PendingIntent.fromRef(
          _readPendingIntentOrNullFromParcel(in0.reference).object);
}

/// from: android.app.PendingIntent$OnFinished
///
/// Callback interface for discovering when a send operation has
/// completed.  Primarily for use with a PendingIntent that is
/// performing a broadcast, this provides the same information as
/// calling Context\#sendOrderedBroadcast(Intent, String,
/// android.content.BroadcastReceiver, Handler, int, String, Bundle) Context.sendBroadcast() with a final BroadcastReceiver.
class PendingIntent_OnFinished extends jni.JniObject {
  PendingIntent_OnFinished.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onSendFinished = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "PendingIntent_OnFinished__onSendFinished")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onSendFinished(android.app.PendingIntent pendingIntent, android.content.Intent intent, int resultCode, java.lang.String resultData, android.os.Bundle resultExtras)
  ///
  /// Called when a send operation as completed.
  ///@param pendingIntent The PendingIntent this operation was sent through.
  ///@param intent The original Intent that was sent.
  ///@param resultCode The final result code determined by the send.
  ///@param resultData The final data collected by a broadcast.
  ///@param resultExtras The final extras collected by a broadcast.
  void onSendFinished(PendingIntent pendingIntent, content_.Intent intent,
          int resultCode, jni.JniString resultData, os_.Bundle resultExtras) =>
      _onSendFinished(reference, pendingIntent.reference, intent.reference,
              resultCode, resultData.reference, resultExtras.reference)
          .check();
}

/// from: android.app.PendingIntent$CanceledException
///
/// Exception thrown when trying to send through a PendingIntent that
/// has been canceled or is otherwise no longer able to execute the request.
class PendingIntent_CanceledException extends jni.JniObject {
  PendingIntent_CanceledException.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "PendingIntent_CanceledException__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  PendingIntent_CanceledException() : super.fromRef(_ctor().object);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PendingIntent_CanceledException__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String name)
  PendingIntent_CanceledException.ctor1(jni.JniString name)
      : super.fromRef(_ctor1(name.reference).object);

  static final _ctor2 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PendingIntent_CanceledException__ctor2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.Exception cause)
  PendingIntent_CanceledException.ctor2(jni.JniObject cause)
      : super.fromRef(_ctor2(cause.reference).object);
}

/// from: android.app.Person
///
/// Provides an immutable reference to an entity that appears repeatedly on different surfaces of the
/// platform. For example, this could represent the sender of a message.
class Person extends jni.JniObject {
  Person.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Person__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.Person> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Person__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Parcel in)
  Person(os_.Parcel in0) : super.fromRef(_ctor(in0.reference).object);

  static final _toBuilder = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Person__toBuilder")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Person.Builder toBuilder()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates and returns a new Builder initialized with this Person's data.
  Person_Builder toBuilder() =>
      Person_Builder.fromRef(_toBuilder(reference).object);

  static final _getUri = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Person__getUri")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getUri()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the uri provided for this person or {@code null} if no Uri was provided.
  jni.JniString getUri() => jni.JniString.fromRef(_getUri(reference).object);

  static final _getName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Person__getName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the name provided for this person or {@code null} if no name was provided.
  jni.JniObject getName() => jni.JniObject.fromRef(_getName(reference).object);

  static final _getIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Person__getIcon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Icon getIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the icon provided for this person or {@code null} if no icon was provided.
  jni.JniObject getIcon() => jni.JniObject.fromRef(_getIcon(reference).object);

  static final _getKey = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Person__getKey")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getKey()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return the key provided for this person or {@code null} if no key was provided.
  jni.JniString getKey() => jni.JniString.fromRef(_getKey(reference).object);

  static final _isBot = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Person__isBot")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isBot()
  ///
  /// @return whether this Person is a machine.
  bool isBot() => _isBot(reference).boolean;

  static final _isImportant = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Person__isImportant")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isImportant()
  ///
  /// @return whether this Person is important.
  bool isImportant() => _isImportant(reference).boolean;

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Person__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Person__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  ///
  /// @param flags Value is either <code>0</code> or a combination of android.os.Parcelable\#PARCELABLE_WRITE_RETURN_VALUE, and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();
}

/// from: android.app.Person$Builder
///
/// Builder for the immutable Person class.
class Person_Builder extends jni.JniObject {
  Person_Builder.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Person_Builder__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  ///
  /// Creates a new, empty Builder.
  Person_Builder() : super.fromRef(_ctor().object);

  static final _setName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Person_Builder__setName")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Person.Builder setName(java.lang.CharSequence name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Give this person a name.
  ///@param name the name of this person.
  ///
  /// This value may be {@code null}.
  ///@return This value will never be {@code null}.
  Person_Builder setName(jni.JniObject name) =>
      Person_Builder.fromRef(_setName(reference, name.reference).object);

  static final _setIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Person_Builder__setIcon")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Person.Builder setIcon(android.graphics.drawable.Icon icon)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add an icon for this person.
  /// <br/>
  /// The system will prefer this icon over any images that are resolved from the URI.
  ///@param icon the icon of the person.
  ///
  /// This value may be {@code null}.
  ///@return This value will never be {@code null}.
  Person_Builder setIcon(jni.JniObject icon) =>
      Person_Builder.fromRef(_setIcon(reference, icon.reference).object);

  static final _setUri = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Person_Builder__setUri")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Person.Builder setUri(java.lang.String uri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a URI associated with this person.
  ///
  /// <P>
  /// The person should be specified by the {@code String} representation of a
  /// android.provider.ContactsContract.Contacts\#CONTENT_LOOKUP_URI.
  /// </P>
  ///
  /// <P>The system will also attempt to resolve {@code mailto:} and {@code tel:} schema
  /// URIs. The path part of these URIs must exist in the contacts database, in the
  /// appropriate column, or the reference will be discarded as invalid. Telephone schema
  /// URIs will be resolved by android.provider.ContactsContract.PhoneLookup.
  /// </P>
  ///@param uri a URI for the person.
  ///
  /// This value may be {@code null}.
  ///@return This value will never be {@code null}.
  Person_Builder setUri(jni.JniString uri) =>
      Person_Builder.fromRef(_setUri(reference, uri.reference).object);

  static final _setKey = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Person_Builder__setKey")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Person.Builder setKey(java.lang.String key)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a key to this person in order to uniquely identify it.
  /// This is especially useful if the name doesn't uniquely identify this person or if the
  /// display name is a short handle of the actual name.
  ///
  /// <P>If no key is provided, the name serves as the key for the purpose of
  /// identification.</P>
  ///@param key the key that uniquely identifies this person.
  ///
  /// This value may be {@code null}.
  ///@return This value will never be {@code null}.
  Person_Builder setKey(jni.JniString key) =>
      Person_Builder.fromRef(_setKey(reference, key.reference).object);

  static final _setImportant = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Person_Builder__setImportant")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Person.Builder setImportant(boolean isImportant)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets whether this is an important person. Use this method to denote users who frequently
  /// interact with the user of this device when \#setUri(String) isn't provided with
  /// android.provider.ContactsContract.Contacts\#CONTENT_LOOKUP_URI, and instead with
  /// the {@code mailto:} or {@code tel:} schemas.
  ///@param isImportant {@code true} if this is an important person, {@code false} otherwise.
  ///@return This value will never be {@code null}.
  Person_Builder setImportant(bool isImportant) => Person_Builder.fromRef(
      _setImportant(reference, isImportant ? 1 : 0).object);

  static final _setBot = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Person_Builder__setBot")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.Person.Builder setBot(boolean isBot)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets whether this person is a machine rather than a human.
  ///@param isBot {@code true} if this person is a machine, {@code false} otherwise.
  ///@return This value will never be {@code null}.
  Person_Builder setBot(bool isBot) =>
      Person_Builder.fromRef(_setBot(reference, isBot ? 1 : 0).object);

  static final _build = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Person_Builder__build")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Person build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates and returns the Person this builder represents.
  ///@return This value will never be {@code null}.
  Person build() => Person.fromRef(_build(reference).object);
}

/// from: android.app.PictureInPictureParams
///
/// Represents a set of parameters used to initialize and update an Activity in picture-in-picture
/// mode.
class PictureInPictureParams extends jni.JniObject {
  PictureInPictureParams.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_PictureInPictureParams__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.PictureInPictureParams> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "PictureInPictureParams__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  ///
  /// {@hide }
  PictureInPictureParams() : super.fromRef(_ctor().object);

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PictureInPictureParams__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("PictureInPictureParams__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os_.Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags).check();
}

/// from: android.app.PictureInPictureParams$Builder
///
/// Builder class for PictureInPictureParams objects.
class PictureInPictureParams_Builder extends jni.JniObject {
  PictureInPictureParams_Builder.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "PictureInPictureParams_Builder__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  PictureInPictureParams_Builder() : super.fromRef(_ctor().object);

  static final _setAspectRatio = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "PictureInPictureParams_Builder__setAspectRatio")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PictureInPictureParams.Builder setAspectRatio(android.util.Rational aspectRatio)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the aspect ratio.  This aspect ratio is defined as the desired width / height, and
  /// does not change upon device rotation.
  ///@param aspectRatio the new aspect ratio for the activity in picture-in-picture, must be
  /// between 2.39:1 and 1:2.39 (inclusive).
  ///@return this builder instance.
  PictureInPictureParams_Builder setAspectRatio(jni.JniObject aspectRatio) =>
      PictureInPictureParams_Builder.fromRef(
          _setAspectRatio(reference, aspectRatio.reference).object);

  static final _setActions = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "PictureInPictureParams_Builder__setActions")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PictureInPictureParams.Builder setActions(java.util.List<android.app.RemoteAction> actions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the user actions.  If there are more than
  /// Activity\#getMaxNumPictureInPictureActions() actions, then the input list
  /// will be truncated to that number.
  ///@param actions the new actions to show in the picture-in-picture menu.
  ///@return this builder instance.
  ///@see RemoteAction
  PictureInPictureParams_Builder setActions(jni.JniObject actions) =>
      PictureInPictureParams_Builder.fromRef(
          _setActions(reference, actions.reference).object);

  static final _setSourceRectHint = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "PictureInPictureParams_Builder__setSourceRectHint")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PictureInPictureParams.Builder setSourceRectHint(android.graphics.Rect launchBounds)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Sets the source bounds hint. These bounds are only used when an activity first enters
  /// picture-in-picture, and describe the bounds in window coordinates of activity entering
  /// picture-in-picture that will be visible following the transition. For the best effect,
  /// these bounds should also match the aspect ratio in the arguments.
  ///@param launchBounds window-coordinate bounds indicating the area of the activity that
  /// will still be visible following the transition into picture-in-picture (eg. the video
  /// view bounds in a video player)
  ///@return this builder instance.
  PictureInPictureParams_Builder setSourceRectHint(
          jni.JniObject launchBounds) =>
      PictureInPictureParams_Builder.fromRef(
          _setSourceRectHint(reference, launchBounds.reference).object);

  static final _build = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "PictureInPictureParams_Builder__build")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PictureInPictureParams build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// @return an immutable PictureInPictureParams to be used when entering or updating
  /// the activity in picture-in-picture.
  ///@see Activity\#enterPictureInPictureMode(PictureInPictureParams)
  ///@see Activity\#setPictureInPictureParams(PictureInPictureParams)
  PictureInPictureParams build() =>
      PictureInPictureParams.fromRef(_build(reference).object);
}

/// from: android.app.Presentation
///
/// Base class for presentations.
///
/// A presentation is a special kind of dialog whose purpose is to present
/// content on a secondary display.  A Presentation is associated with
/// the target Display at creation time and configures its context and
/// resource configuration according to the display's metrics.
///
///
/// Notably, the Context of a presentation is different from the context
/// of its containing Activity.  It is important to inflate the layout
/// of a presentation and load other resources using the presentation's own context
/// to ensure that assets of the correct size and density for the target display
/// are loaded.
///
///
/// A presentation is automatically canceled (see Dialog\#cancel()) when
/// the display to which it is attached is removed.  An activity should take
/// care of pausing and resuming whatever content is playing within the presentation
/// whenever the activity itself is paused or resumed.
///
///
///
/// <h3>Choosing a presentation display</h3>
///
/// Before showing a Presentation it's important to choose the Display
/// on which it will appear.  Choosing a presentation display is sometimes difficult
/// because there may be multiple displays attached.  Rather than trying to guess
/// which display is best, an application should let the system choose a suitable
/// presentation display.
///
///
/// There are two main ways to choose a Display.
///
///
///
/// <h4>Using the media router to choose a presentation display</h4>
///
/// The easiest way to choose a presentation display is to use the
/// android.media.MediaRouter MediaRouter API.  The media router service keeps
/// track of which audio and video routes are available on the system.
/// The media router sends notifications whenever routes are selected or unselected
/// or when the preferred presentation display of a route changes.
/// So an application can simply watch for these notifications and show or dismiss
/// a presentation on the preferred presentation display automatically.
///
///
/// The preferred presentation display is the display that the media router recommends
/// that the application should use if it wants to show content on the secondary display.
/// Sometimes there may not be a preferred presentation display in which
/// case the application should show its content locally without using a presentation.
///
///
/// Here's how to use the media router to create and show a presentation on the preferred
/// presentation display using android.media.MediaRouter.RouteInfo\#getPresentationDisplay().
///
///
/// <pre>
/// MediaRouter mediaRouter = (MediaRouter) context.getSystemService(Context.MEDIA_ROUTER_SERVICE);
/// MediaRouter.RouteInfo route = mediaRouter.getSelectedRoute();
/// if (route != null) {
///     Display presentationDisplay = route.getPresentationDisplay();
///     if (presentationDisplay != null) {
///         Presentation presentation = new MyPresentation(context, presentationDisplay);
///         presentation.show();
///     }
/// }</pre>
///
/// The following sample code from <code>ApiDemos</code> demonstrates how to use the media
/// router to automatically switch between showing content in the main activity and showing
/// the content in a presentation when a presentation display is available.
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/PresentationWithMediaRouterActivity.java
///      activity}
///
/// <h4>Using the display manager to choose a presentation display</h4>
///
/// Another way to choose a presentation display is to use the DisplayManager API
/// directly.  The display manager service provides functions to enumerate and describe all
/// displays that are attached to the system including displays that may be used
/// for presentations.
///
///
/// The display manager keeps track of all displays in the system.  However, not all
/// displays are appropriate for showing presentations.  For example, if an activity
/// attempted to show a presentation on the main display it might obscure its own content
/// (it's like opening a dialog on top of your activity).
///
///
/// Here's how to identify suitable displays for showing presentations using
/// DisplayManager\#getDisplays(String) and the
/// DisplayManager\#DISPLAY_CATEGORY_PRESENTATION category.
///
///
/// <pre>
/// DisplayManager displayManager = (DisplayManager) context.getSystemService(Context.DISPLAY_SERVICE);
/// Display[] presentationDisplays = displayManager.getDisplays(DisplayManager.DISPLAY_CATEGORY_PRESENTATION);
/// if (presentationDisplays.length > 0) {
///     // If there is more than one suitable presentation display, then we could consider
///     // giving the user a choice.  For this example, we simply choose the first display
///     // which is the one the system recommends as the preferred presentation display.
///     Display display = presentationDisplays[0];
///     Presentation presentation = new MyPresentation(context, presentationDisplay);
///     presentation.show();
/// }</pre>
///
/// The following sample code from <code>ApiDemos</code> demonstrates how to use the display
/// manager to enumerate displays and show content on multiple presentation displays
/// simultaneously.
///
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/PresentationActivity.java
///      activity}
///@see android.media.MediaRouter\#ROUTE_TYPE_LIVE_VIDEO for information on about live
/// video routes and how to obtain the preferred presentation display for the
/// current media route.
///@see DisplayManager for information on how to enumerate displays and receive
/// notifications when displays are added or removed.
class Presentation extends Dialog {
  Presentation.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor3 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Presentation__ctor3")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context outerContext, android.view.Display display)
  ///
  /// Creates a new presentation that is attached to the specified display
  /// using the default theme.
  ///@param outerContext The context of the application that is showing the presentation.
  /// The presentation will create its own context (see \#getContext()) based
  /// on this context and information about the associated display.
  ///@param display The display to which the presentation should be attached.
  Presentation.ctor3(content_.Context outerContext, jni.JniObject display)
      : super.fromRef(_ctor3(outerContext.reference, display.reference).object);

  static final _ctor4 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Presentation__ctor4")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Context outerContext, android.view.Display display, int theme)
  ///
  /// Creates a new presentation that is attached to the specified display
  /// using the optionally specified theme.
  ///@param outerContext The context of the application that is showing the presentation.
  /// The presentation will create its own context (see \#getContext()) based
  /// on this context and information about the associated display.
  ///@param display The display to which the presentation should be attached.
  ///@param theme A style resource describing the theme to use for the window.
  /// See <a href="{@docRoot}guide/topics/resources/available-resources.html\#stylesandthemes">
  /// Style and Theme Resources</a> for more information about defining and using
  /// styles.  This theme is applied on top of the current theme in
  /// <var>outerContext</var>.  If 0, the default presentation theme will be used.
  Presentation.ctor4(
      content_.Context outerContext, jni.JniObject display, int theme)
      : super.fromRef(
            _ctor4(outerContext.reference, display.reference, theme).object);

  static final _getDisplay = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Presentation__getDisplay")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.Display getDisplay()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the Display that this presentation appears on.
  ///@return The display.
  jni.JniObject getDisplay() =>
      jni.JniObject.fromRef(_getDisplay(reference).object);

  static final _getResources = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Presentation__getResources")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.Resources getResources()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the Resources that should be used to inflate the layout of this presentation.
  /// This resources object has been configured according to the metrics of the
  /// display that the presentation appears on.
  ///@return The presentation resources object.
  res_.Resources getResources() =>
      res_.Resources.fromRef(_getResources(reference).object);

  static final _onStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Presentation__onStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStart()
  void onStart() => _onStart(reference).check();

  static final _onStop = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Presentation__onStop")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStop()
  void onStop() => _onStop(reference).check();

  static final _show0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Presentation__show0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void show()
  ///
  /// Inherited from Dialog\#show. Will throw
  /// android.view.WindowManager.InvalidDisplayException if the specified secondary
  /// Display can't be found.
  void show0() => _show0(reference).check();

  static final _onDisplayRemoved = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Presentation__onDisplayRemoved")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDisplayRemoved()
  ///
  /// Called by the system when the Display to which the presentation
  /// is attached has been removed.
  ///
  /// The system automatically calls \#cancel to dismiss the presentation
  /// after sending this event.
  ///@see \#getDisplay
  void onDisplayRemoved() => _onDisplayRemoved(reference).check();

  static final _onDisplayChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Presentation__onDisplayChanged")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDisplayChanged()
  ///
  /// Called by the system when the properties of the Display to which
  /// the presentation is attached have changed.
  ///
  /// If the display metrics have changed (for example, if the display has been
  /// resized or rotated), then the system automatically calls
  /// \#cancel to dismiss the presentation.
  ///@see \#getDisplay
  void onDisplayChanged() => _onDisplayChanged(reference).check();
}

/// from: android.app.ProgressDialog
///
/// A dialog showing a progress indicator and an optional text message or view.
/// Only a text message or a view can be used at the same time.
///
/// The dialog can be made cancelable on back key press.
///
///
/// The progress range is 0 to \#getMax() max.
///
///@deprecated <code>ProgressDialog</code> is a modal dialog, which prevents the
/// user from interacting with the app. Instead of using this class, you should
/// use a progress indicator like android.widget.ProgressBar, which can
/// be embedded in your app's UI. Alternatively, you can use a
/// <a href="/guide/topics/ui/notifiers/notifications.html">notification</a>
/// to inform the user of the task's progress.
class ProgressDialog extends AlertDialog {
  ProgressDialog.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int STYLE_HORIZONTAL
  ///
  /// Creates a ProgressDialog with a horizontal progress bar.
  static const STYLE_HORIZONTAL = 1;

  /// from: static public final int STYLE_SPINNER
  ///
  /// Creates a ProgressDialog with a circular, spinning progress
  /// bar. This is the default.
  static const STYLE_SPINNER = 0;

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ProgressDialog__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context)
  ///
  /// Creates a Progress dialog.
  ///@param context the parent context
  ProgressDialog(content_.Context context)
      : super.fromRef(_ctor(context.reference).object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("ProgressDialog__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(android.content.Context context, int theme)
  ///
  /// Creates a Progress dialog.
  ///@param context the parent context
  ///@param theme the resource ID of the theme against which to inflate
  ///              this dialog, or {@code 0} to use the parent
  ///              {@code context}'s default alert dialog theme
  ProgressDialog.ctor1(content_.Context context, int theme)
      : super.fromRef(_ctor1(context.reference, theme).object);

  static final _show1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ProgressDialog__show1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.ProgressDialog show(android.content.Context context, java.lang.CharSequence title, java.lang.CharSequence message)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates and shows a ProgressDialog.
  ///@param context the parent context
  ///@param title the title text for the dialog's window
  ///@param message the text to be displayed in the dialog
  ///@return the ProgressDialog
  static ProgressDialog show1(content_.Context context, jni.JniObject title,
          jni.JniObject message) =>
      ProgressDialog.fromRef(
          _show1(context.reference, title.reference, message.reference).object);

  static final _show2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("ProgressDialog__show2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.app.ProgressDialog show(android.content.Context context, java.lang.CharSequence title, java.lang.CharSequence message, boolean indeterminate)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates and shows a ProgressDialog.
  ///@param context the parent context
  ///@param title the title text for the dialog's window
  ///@param message the text to be displayed in the dialog
  ///@param indeterminate true if the dialog should be \#setIndeterminate(boolean) indeterminate, false otherwise
  ///@return the ProgressDialog
  static ProgressDialog show2(content_.Context context, jni.JniObject title,
          jni.JniObject message, bool indeterminate) =>
      ProgressDialog.fromRef(_show2(context.reference, title.reference,
              message.reference, indeterminate ? 1 : 0)
          .object);

  static final _show3 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Uint8)>>("ProgressDialog__show3")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: static public android.app.ProgressDialog show(android.content.Context context, java.lang.CharSequence title, java.lang.CharSequence message, boolean indeterminate, boolean cancelable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates and shows a ProgressDialog.
  ///@param context the parent context
  ///@param title the title text for the dialog's window
  ///@param message the text to be displayed in the dialog
  ///@param indeterminate true if the dialog should be \#setIndeterminate(boolean) indeterminate, false otherwise
  ///@param cancelable true if the dialog is \#setCancelable(boolean) cancelable,
  ///        false otherwise
  ///@return the ProgressDialog
  static ProgressDialog show3(content_.Context context, jni.JniObject title,
          jni.JniObject message, bool indeterminate, bool cancelable) =>
      ProgressDialog.fromRef(_show3(context.reference, title.reference,
              message.reference, indeterminate ? 1 : 0, cancelable ? 1 : 0)
          .object);

  static final _show4 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Uint8,
                  ffi.Pointer<ffi.Void>)>>("ProgressDialog__show4")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.ProgressDialog show(android.content.Context context, java.lang.CharSequence title, java.lang.CharSequence message, boolean indeterminate, boolean cancelable, android.content.DialogInterface.OnCancelListener cancelListener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates and shows a ProgressDialog.
  ///@param context the parent context
  ///@param title the title text for the dialog's window
  ///@param message the text to be displayed in the dialog
  ///@param indeterminate true if the dialog should be \#setIndeterminate(boolean) indeterminate, false otherwise
  ///@param cancelable true if the dialog is \#setCancelable(boolean) cancelable,
  ///        false otherwise
  ///@param cancelListener the \#setOnCancelListener(OnCancelListener) listener
  ///        to be invoked when the dialog is canceled
  ///@return the ProgressDialog
  static ProgressDialog show4(
          content_.Context context,
          jni.JniObject title,
          jni.JniObject message,
          bool indeterminate,
          bool cancelable,
          content_.DialogInterface_OnCancelListener cancelListener) =>
      ProgressDialog.fromRef(_show4(
              context.reference,
              title.reference,
              message.reference,
              indeterminate ? 1 : 0,
              cancelable ? 1 : 0,
              cancelListener.reference)
          .object);

  static final _onCreate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ProgressDialog__onCreate")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onCreate(android.os.Bundle savedInstanceState)
  void onCreate(os_.Bundle savedInstanceState) =>
      _onCreate(reference, savedInstanceState.reference).check();

  static final _onStart1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ProgressDialog__onStart1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onStart()
  void onStart1() => _onStart1(reference).check();

  static final _onStop1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ProgressDialog__onStop1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void onStop()
  void onStop1() => _onStop1(reference).check();

  static final _setProgress = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ProgressDialog__setProgress")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setProgress(int value)
  ///
  /// Sets the current progress.
  ///@param value the current progress, a value between 0 and \#getMax()
  ///@see ProgressBar\#setProgress(int)
  void setProgress(int value) => _setProgress(reference, value).check();

  static final _setSecondaryProgress = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ProgressDialog__setSecondaryProgress")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setSecondaryProgress(int secondaryProgress)
  ///
  /// Sets the secondary progress.
  ///@param secondaryProgress the current secondary progress, a value between 0 and
  /// \#getMax()
  ///@see ProgressBar\#setSecondaryProgress(int)
  void setSecondaryProgress(int secondaryProgress) =>
      _setSecondaryProgress(reference, secondaryProgress).check();

  static final _getProgress = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ProgressDialog__getProgress")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getProgress()
  ///
  /// Gets the current progress.
  ///@return the current progress, a value between 0 and \#getMax()
  int getProgress() => _getProgress(reference).integer;

  static final _getSecondaryProgress = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ProgressDialog__getSecondaryProgress")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getSecondaryProgress()
  ///
  /// Gets the current secondary progress.
  ///@return the current secondary progress, a value between 0 and \#getMax()
  int getSecondaryProgress() => _getSecondaryProgress(reference).integer;

  static final _getMax = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ProgressDialog__getMax")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getMax()
  ///
  /// Gets the maximum allowed progress value. The default value is 100.
  ///@return the maximum value
  int getMax() => _getMax(reference).integer;

  static final _setMax = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("ProgressDialog__setMax")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setMax(int max)
  ///
  /// Sets the maximum allowed progress value.
  void setMax(int max) => _setMax(reference, max).check();

  static final _incrementProgressBy = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ProgressDialog__incrementProgressBy")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void incrementProgressBy(int diff)
  ///
  /// Increments the current progress value.
  ///@param diff the amount by which the current progress will be incremented,
  /// up to \#getMax()
  void incrementProgressBy(int diff) =>
      _incrementProgressBy(reference, diff).check();

  static final _incrementSecondaryProgressBy = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ProgressDialog__incrementSecondaryProgressBy")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void incrementSecondaryProgressBy(int diff)
  ///
  /// Increments the current secondary progress value.
  ///@param diff the amount by which the current secondary progress will be incremented,
  /// up to \#getMax()
  void incrementSecondaryProgressBy(int diff) =>
      _incrementSecondaryProgressBy(reference, diff).check();

  static final _setProgressDrawable = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ProgressDialog__setProgressDrawable")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setProgressDrawable(android.graphics.drawable.Drawable d)
  ///
  /// Sets the drawable to be used to display the progress value.
  ///@param d the drawable to be used
  ///@see ProgressBar\#setProgressDrawable(Drawable)
  void setProgressDrawable(jni.JniObject d) =>
      _setProgressDrawable(reference, d.reference).check();

  static final _setIndeterminateDrawable = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ProgressDialog__setIndeterminateDrawable")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setIndeterminateDrawable(android.graphics.drawable.Drawable d)
  ///
  /// Sets the drawable to be used to display the indeterminate progress value.
  ///@param d the drawable to be used
  ///@see ProgressBar\#setProgressDrawable(Drawable)
  ///@see \#setIndeterminate(boolean)
  void setIndeterminateDrawable(jni.JniObject d) =>
      _setIndeterminateDrawable(reference, d.reference).check();

  static final _setIndeterminate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("ProgressDialog__setIndeterminate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setIndeterminate(boolean indeterminate)
  ///
  /// Change the indeterminate mode for this ProgressDialog. In indeterminate
  /// mode, the progress is ignored and the dialog shows an infinite
  /// animation instead.
  ///
  /// <strong>Note:</strong> A ProgressDialog with style \#STYLE_SPINNER
  /// is always indeterminate and will ignore this setting.
  ///
  ///@param indeterminate true to enable indeterminate mode, false otherwise
  ///@see \#setProgressStyle(int)
  void setIndeterminate(bool indeterminate) =>
      _setIndeterminate(reference, indeterminate ? 1 : 0).check();

  static final _isIndeterminate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ProgressDialog__isIndeterminate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isIndeterminate()
  ///
  /// Whether this ProgressDialog is in indeterminate mode.
  ///@return true if the dialog is in indeterminate mode, false otherwise
  bool isIndeterminate() => _isIndeterminate(reference).boolean;

  static final _setMessage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ProgressDialog__setMessage")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setMessage(java.lang.CharSequence message)
  void setMessage(jni.JniObject message) =>
      _setMessage(reference, message.reference).check();

  static final _setProgressStyle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ProgressDialog__setProgressStyle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setProgressStyle(int style)
  ///
  /// Sets the style of this ProgressDialog, either \#STYLE_SPINNER or
  /// \#STYLE_HORIZONTAL. The default is \#STYLE_SPINNER.
  ///
  /// <strong>Note:</strong> A ProgressDialog with style \#STYLE_SPINNER
  /// is always indeterminate and will ignore the \#setIndeterminate(boolean) indeterminate setting.
  ///
  ///@param style the style of this ProgressDialog, either \#STYLE_SPINNER or
  /// \#STYLE_HORIZONTAL
  void setProgressStyle(int style) =>
      _setProgressStyle(reference, style).check();

  static final _setProgressNumberFormat = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ProgressDialog__setProgressNumberFormat")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setProgressNumberFormat(java.lang.String format)
  ///
  /// Change the format of the small text showing current and maximum units
  /// of progress.  The default is "%1d/%2d".
  /// Should not be called during the number is progressing.
  ///@param format A string passed to String\#format String.format();
  /// use "%1d" for the current number and "%2d" for the maximum.  If null,
  /// nothing will be shown.
  void setProgressNumberFormat(jni.JniString format) =>
      _setProgressNumberFormat(reference, format.reference).check();

  static final _setProgressPercentFormat = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "ProgressDialog__setProgressPercentFormat")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setProgressPercentFormat(java.text.NumberFormat format)
  ///
  /// Change the format of the small text showing the percentage of progress.
  /// The default is
  /// NumberFormat\#getPercentInstance() NumberFormat.getPercentageInstnace().
  /// Should not be called during the number is progressing.
  ///@param format An instance of a NumberFormat to generate the
  /// percentage text.  If null, nothing will be shown.
  void setProgressPercentFormat(jni.JniObject format) =>
      _setProgressPercentFormat(reference, format.reference).check();
}

/// from: android.app.RemoteAction
///
/// Represents a remote action that can be called from another process.  The action can have an
/// associated visualization including metadata like an icon or title.
class RemoteAction extends jni.JniObject {
  RemoteAction.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_RemoteAction__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.RemoteAction> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("RemoteAction__ctor")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.graphics.drawable.Icon icon, java.lang.CharSequence title, java.lang.CharSequence contentDescription, android.app.PendingIntent intent)
  ///
  /// @param icon This value must never be {@code null}.
  ///@param title This value must never be {@code null}.
  ///@param contentDescription This value must never be {@code null}.
  ///@param intent This value must never be {@code null}.
  RemoteAction(jni.JniObject icon, jni.JniObject title,
      jni.JniObject contentDescription, PendingIntent intent)
      : super.fromRef(_ctor(icon.reference, title.reference,
                contentDescription.reference, intent.reference)
            .object);

  static final _setEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("RemoteAction__setEnabled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setEnabled(boolean enabled)
  ///
  /// Sets whether this action is enabled.
  void setEnabled(bool enabled) =>
      _setEnabled(reference, enabled ? 1 : 0).check();

  static final _isEnabled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteAction__isEnabled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isEnabled()
  ///
  /// Return whether this action is enabled.
  bool isEnabled() => _isEnabled(reference).boolean;

  static final _setShouldShowIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("RemoteAction__setShouldShowIcon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setShouldShowIcon(boolean shouldShowIcon)
  ///
  /// Sets whether the icon should be shown.
  void setShouldShowIcon(bool shouldShowIcon) =>
      _setShouldShowIcon(reference, shouldShowIcon ? 1 : 0).check();

  static final _shouldShowIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteAction__shouldShowIcon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldShowIcon()
  ///
  /// Return whether the icon should be shown.
  bool shouldShowIcon() => _shouldShowIcon(reference).boolean;

  static final _getIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteAction__getIcon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Icon getIcon()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an icon representing the action.
  ///@return This value will never be {@code null}.
  jni.JniObject getIcon() => jni.JniObject.fromRef(_getIcon(reference).object);

  static final _getTitle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteAction__getTitle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getTitle()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an title representing the action.
  ///@return This value will never be {@code null}.
  jni.JniObject getTitle() =>
      jni.JniObject.fromRef(_getTitle(reference).object);

  static final _getContentDescription = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "RemoteAction__getContentDescription")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getContentDescription()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a content description representing the action.
  ///@return This value will never be {@code null}.
  jni.JniObject getContentDescription() =>
      jni.JniObject.fromRef(_getContentDescription(reference).object);

  static final _getActionIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteAction__getActionIntent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent getActionIntent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the action intent.
  ///@return This value will never be {@code null}.
  PendingIntent getActionIntent() =>
      PendingIntent.fromRef(_getActionIntent(reference).object);

  static final _clone = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteAction__clone")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.RemoteAction clone()
  /// The returned object must be deleted after use, by calling the `delete` method.
  RemoteAction clone() => RemoteAction.fromRef(_clone(reference).object);

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteAction__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("RemoteAction__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os_.Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags).check();

  static final _dump = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("RemoteAction__dump")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(java.lang.String prefix, java.io.PrintWriter pw)
  void dump(jni.JniString prefix, jni.JniObject pw) =>
      _dump(reference, prefix.reference, pw.reference).check();
}

/// from: android.app.RemoteInput
///
/// A {@code RemoteInput} object specifies input to be collected from a user to be passed along with
/// an intent inside a android.app.PendingIntent that is sent.
/// Always use RemoteInput.Builder to create instances of this class.
/// <p class="note"> See
/// <a href="{@docRoot}guide/topics/ui/notifiers/notifications.html\#direct">Replying
/// to notifications</a> for more information on how to use this class.
///
/// The following example adds a {@code RemoteInput} to a Notification.Action,
/// sets the result key as {@code quick_reply}, and sets the label as {@code Quick reply}.
/// Users are prompted to input a response when they trigger the action. The results are sent along
/// with the intent and can be retrieved with the result key (provided to the Builder
/// constructor) from the Bundle returned by \#getResultsFromIntent.
///
/// <pre class="prettyprint">
/// public static final String KEY_QUICK_REPLY_TEXT = "quick_reply";
/// Notification.Action action = new Notification.Action.Builder(
///         R.drawable.reply, &quot;Reply&quot;, actionIntent)
///         __.addRemoteInput(new RemoteInput.Builder(KEY_QUICK_REPLY_TEXT)
///                 .setLabel("Quick reply").build()__)
///         .build();</pre>
///
/// When the android.app.PendingIntent is fired, the intent inside will contain the
/// input results if collected. To access these results, use the \#getResultsFromIntent
/// function. The result values will present under the result key passed to the Builder
/// constructor.
///
/// <pre class="prettyprint">
/// public static final String KEY_QUICK_REPLY_TEXT = "quick_reply";
/// Bundle results = RemoteInput.getResultsFromIntent(intent);
/// if (results != null) {
///     CharSequence quickReplyResult = results.getCharSequence(KEY_QUICK_REPLY_TEXT);
/// }</pre>
class RemoteInput extends jni.JniObject {
  RemoteInput.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_RemoteInput__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.RemoteInput> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  /// from: static public final java.lang.String EXTRA_RESULTS_DATA
  ///
  /// Extra added to a clip data intent object to hold the text results bundle.
  static const EXTRA_RESULTS_DATA = "android.remoteinput.resultsData";

  /// from: static public final java.lang.String RESULTS_CLIP_LABEL
  ///
  /// Label used to denote the clip data type used for remote input transport
  static const RESULTS_CLIP_LABEL = "android.remoteinput.results";

  /// from: static public final int SOURCE_CHOICE
  ///
  /// The user selected one of the choices from \#getChoices.
  static const SOURCE_CHOICE = 1;

  /// from: static public final int SOURCE_FREE_FORM_INPUT
  ///
  /// The user manually entered the data.
  static const SOURCE_FREE_FORM_INPUT = 0;

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteInput__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Parcel in)
  RemoteInput(os_.Parcel in0) : super.fromRef(_ctor(in0.reference).object);

  static final _getResultKey = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteInput__getResultKey")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getResultKey()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the key that the result of this input will be set in from the Bundle returned by
  /// \#getResultsFromIntent when the android.app.PendingIntent is sent.
  jni.JniString getResultKey() =>
      jni.JniString.fromRef(_getResultKey(reference).object);

  static final _getLabel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteInput__getLabel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getLabel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the label to display to users when collecting this input.
  jni.JniObject getLabel() =>
      jni.JniObject.fromRef(_getLabel(reference).object);

  static final _getChoices = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteInput__getChoices")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence[] getChoices()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get possible input choices. This can be {@code null} if there are no choices to present.
  jni.JniObject getChoices() =>
      jni.JniObject.fromRef(_getChoices(reference).object);

  static final _getAllowedDataTypes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteInput__getAllowedDataTypes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Set<java.lang.String> getAllowedDataTypes()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get possible non-textual inputs that are accepted.
  /// This can be {@code null} if the input does not accept non-textual values.
  /// See Builder\#setAllowDataType.
  jni.JniObject getAllowedDataTypes() =>
      jni.JniObject.fromRef(_getAllowedDataTypes(reference).object);

  static final _isDataOnly = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteInput__isDataOnly")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isDataOnly()
  ///
  /// Returns true if the input only accepts data, meaning \#getAllowFreeFormInput
  /// is false, \#getChoices is null or empty, and \#getAllowedDataTypes is
  /// non-null and not empty.
  bool isDataOnly() => _isDataOnly(reference).boolean;

  static final _getAllowFreeFormInput = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteInput__getAllowFreeFormInput")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getAllowFreeFormInput()
  ///
  /// Get whether or not users can provide an arbitrary value for
  /// input. If you set this to {@code false}, users must select one of the
  /// choices in \#getChoices. An IllegalArgumentException is thrown
  /// if you set this to false and \#getChoices returns {@code null} or empty.
  bool getAllowFreeFormInput() => _getAllowFreeFormInput(reference).boolean;

  static final _getExtras = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteInput__getExtras")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get additional metadata carried around with this remote input.
  os_.Bundle getExtras() => os_.Bundle.fromRef(_getExtras(reference).object);

  static final _getDataResultsFromIntent = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "RemoteInput__getDataResultsFromIntent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.Map<java.lang.String,android.net.Uri> getDataResultsFromIntent(android.content.Intent intent, java.lang.String remoteInputResultKey)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Similar as \#getResultsFromIntent but retrieves data results for a
  /// specific RemoteInput result. To retrieve a value use:
  /// <pre>
  /// {@code
  /// Map<String, Uri> results =
  ///     RemoteInput.getDataResultsFromIntent(intent, REMOTE_INPUT_KEY);
  /// if (results != null) {
  ///   Uri data = results.get(MIME_TYPE_OF_INTEREST);
  /// }
  /// }
  /// </pre>
  ///@param intent The intent object that fired in response to an action or content intent
  ///               which also had one or more remote input requested.
  ///@param remoteInputResultKey The result key for the RemoteInput you want results for.
  static jni.JniObject getDataResultsFromIntent(
          content_.Intent intent, jni.JniString remoteInputResultKey) =>
      jni.JniObject.fromRef(_getDataResultsFromIntent(
              intent.reference, remoteInputResultKey.reference)
          .object);

  static final _getResultsFromIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteInput__getResultsFromIntent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.os.Bundle getResultsFromIntent(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the remote input text results bundle from an intent. The returned Bundle will
  /// contain a key/value for every result key populated with text by remote input collector.
  /// Use the Bundle\#getCharSequence(String) method to retrieve a value. For non-text
  /// results use \#getDataResultsFromIntent.
  ///@param intent The intent object that fired in response to an action or content intent
  ///               which also had one or more remote input requested.
  static os_.Bundle getResultsFromIntent(content_.Intent intent) =>
      os_.Bundle.fromRef(_getResultsFromIntent(intent.reference).object);

  static final _addResultsToIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("RemoteInput__addResultsToIntent")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void addResultsToIntent(android.app.RemoteInput[] remoteInputs, android.content.Intent intent, android.os.Bundle results)
  ///
  /// Populate an intent object with the text results gathered from remote input. This method
  /// should only be called by remote input collection services when sending results to a
  /// pending intent.
  ///@param remoteInputs The remote inputs for which results are being provided
  ///@param intent The intent to add remote inputs to. The ClipData
  ///               field of the intent will be modified to contain the results.
  ///@param results A bundle holding the remote input results. This bundle should
  ///                be populated with keys matching the result keys specified in
  ///                {@code remoteInputs} with values being the CharSequence results per key.
  static void addResultsToIntent(jni.JniObject remoteInputs,
          content_.Intent intent, os_.Bundle results) =>
      _addResultsToIntent(
              remoteInputs.reference, intent.reference, results.reference)
          .check();

  static final _addDataResultToIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("RemoteInput__addDataResultToIntent")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void addDataResultToIntent(android.app.RemoteInput remoteInput, android.content.Intent intent, java.util.Map<java.lang.String,android.net.Uri> results)
  ///
  /// Same as \#addResultsToIntent but for setting data results. This is used
  /// for inputs that accept non-textual results (see Builder\#setAllowDataType).
  /// Only one result can be provided for every mime type accepted by the RemoteInput.
  /// If multiple inputs of the same mime type are expected then multiple RemoteInputs
  /// should be used.
  ///@param remoteInput The remote input for which results are being provided
  ///@param intent The intent to add remote input results to. The ClipData
  ///               field of the intent will be modified to contain the results.
  ///@param results A map of mime type to the Uri result for that mime type.
  static void addDataResultToIntent(RemoteInput remoteInput,
          content_.Intent intent, jni.JniObject results) =>
      _addDataResultToIntent(
              remoteInput.reference, intent.reference, results.reference)
          .check();

  static final _setResultsSource = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("RemoteInput__setResultsSource")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: static public void setResultsSource(android.content.Intent intent, int source)
  ///
  /// Set the source of the RemoteInput results. This method should only be called by remote
  /// input collection services (e.g.
  /// android.service.notification.NotificationListenerService)
  /// when sending results to a pending intent.
  ///@see \#SOURCE_FREE_FORM_INPUT
  ///@see \#SOURCE_CHOICE
  ///@param intent The intent to add remote input source to. The ClipData
  ///               field of the intent will be modified to contain the source.
  ///@param source The source of the results.
  ///
  /// Value is android.app.RemoteInput\#SOURCE_FREE_FORM_INPUT, or android.app.RemoteInput\#SOURCE_CHOICE
  static void setResultsSource(content_.Intent intent, int source) =>
      _setResultsSource(intent.reference, source).check();

  static final _getResultsSource = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteInput__getResultsSource")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public int getResultsSource(android.content.Intent intent)
  ///
  /// Get the source of the RemoteInput results.
  ///@see \#SOURCE_FREE_FORM_INPUT
  ///@see \#SOURCE_CHOICE
  ///@param intent The intent object that fired in response to an action or content intent
  ///               which also had one or more remote input requested.
  ///@return The source of the results. If no source was set, \#SOURCE_FREE_FORM_INPUT will
  /// be returned.
  ///
  /// Value is android.app.RemoteInput\#SOURCE_FREE_FORM_INPUT, or android.app.RemoteInput\#SOURCE_CHOICE
  static int getResultsSource(content_.Intent intent) =>
      _getResultsSource(intent.reference).integer;

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteInput__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("RemoteInput__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel out, int flags)
  void writeToParcel(os_.Parcel out, int flags) =>
      _writeToParcel(reference, out.reference, flags).check();
}

/// from: android.app.RemoteInput$Builder
///
/// Builder class for RemoteInput objects.
class RemoteInput_Builder extends jni.JniObject {
  RemoteInput_Builder.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteInput_Builder__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String resultKey)
  ///
  /// Create a builder object for RemoteInput objects.
  ///@param resultKey the Bundle key that refers to this input when collected from the user
  ///
  /// This value must never be {@code null}.
  RemoteInput_Builder(jni.JniString resultKey)
      : super.fromRef(_ctor(resultKey.reference).object);

  static final _setLabel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("RemoteInput_Builder__setLabel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.RemoteInput.Builder setLabel(java.lang.CharSequence label)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Set a label to be displayed to the user when collecting this input.
  ///@param label The label to show to users when they input a response
  /// This value may be {@code null}.
  ///@return this object for method chaining
  ///
  /// This value will never be {@code null}.
  RemoteInput_Builder setLabel(jni.JniObject label) =>
      RemoteInput_Builder.fromRef(_setLabel(reference, label.reference).object);

  static final _setChoices = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("RemoteInput_Builder__setChoices")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.RemoteInput.Builder setChoices(java.lang.CharSequence[] choices)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specifies choices available to the user to satisfy this input.
  ///
  /// Note: Starting in Android P, these choices will always be shown on phones if the app's
  /// target SDK is >= P. However, these choices may also be rendered on other types of devices
  /// regardless of target SDK.
  ///@param choices an array of pre-defined choices for users input.
  ///        You must provide a non-null and non-empty array if
  ///        you disabled free form input using \#setAllowFreeFormInput
  /// This value may be {@code null}.
  ///@return this object for method chaining
  RemoteInput_Builder setChoices(jni.JniObject choices) =>
      RemoteInput_Builder.fromRef(
          _setChoices(reference, choices.reference).object);

  static final _setAllowDataType = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("RemoteInput_Builder__setAllowDataType")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.RemoteInput.Builder setAllowDataType(java.lang.String mimeType, boolean doAllow)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specifies whether the user can provide arbitrary values. This allows an input
  /// to accept non-textual values. Examples of usage are an input that wants audio
  /// or an image.
  ///@param mimeType A mime type that results are allowed to come in.
  ///         Be aware that text results (see \#setAllowFreeFormInput
  ///         are allowed by default. If you do not want text results you will have to
  ///         pass false to {@code setAllowFreeFormInput}
  /// This value must never be {@code null}.
  ///@param doAllow Whether the mime type should be allowed or not
  ///@return this object for method chaining
  ///
  /// This value will never be {@code null}.
  RemoteInput_Builder setAllowDataType(jni.JniString mimeType, bool doAllow) =>
      RemoteInput_Builder.fromRef(
          _setAllowDataType(reference, mimeType.reference, doAllow ? 1 : 0)
              .object);

  static final _setAllowFreeFormInput = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("RemoteInput_Builder__setAllowFreeFormInput")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.RemoteInput.Builder setAllowFreeFormInput(boolean allowFreeFormTextInput)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Specifies whether the user can provide arbitrary text values.
  ///@param allowFreeFormTextInput The default is {@code true}.
  ///         If you specify {@code false}, you must either provide a non-null
  ///         and non-empty array to \#setChoices, or enable a data result
  ///         in {@code setAllowDataType}. Otherwise an
  ///         IllegalArgumentException is thrown
  ///@return this object for method chaining
  RemoteInput_Builder setAllowFreeFormInput(bool allowFreeFormTextInput) =>
      RemoteInput_Builder.fromRef(
          _setAllowFreeFormInput(reference, allowFreeFormTextInput ? 1 : 0)
              .object);

  static final _addExtras = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("RemoteInput_Builder__addExtras")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.RemoteInput.Builder addExtras(android.os.Bundle extras)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Merge additional metadata into this builder.
  ///
  /// Values within the Bundle will replace existing extras values in this Builder.
  ///@see RemoteInput\#getExtras
  ///@param extras This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  RemoteInput_Builder addExtras(os_.Bundle extras) =>
      RemoteInput_Builder.fromRef(
          _addExtras(reference, extras.reference).object);

  static final _getExtras = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteInput_Builder__getExtras")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the metadata Bundle used by this Builder.
  ///
  /// The returned Bundle is shared with this Builder.
  ///@return This value will never be {@code null}.
  os_.Bundle getExtras() => os_.Bundle.fromRef(_getExtras(reference).object);

  static final _build = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("RemoteInput_Builder__build")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.RemoteInput build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Combine all of the options that have been set and return a new RemoteInput
  /// object.
  ///@return This value will never be {@code null}.
  RemoteInput build() => RemoteInput.fromRef(_build(reference).object);
}

/// from: android.app.SearchManager
///
/// This class provides access to the system search services.
///
/// In practice, you won't interact with this class directly, as search
/// services are provided through methods in android.app.Activity Activity
/// and the android.content.Intent\#ACTION_SEARCH ACTION_SEARCH
/// android.content.Intent Intent.
///
///
/// Configuration\#UI_MODE_TYPE_WATCH does not support this system service.
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For more information about using the search dialog and adding search
/// suggestions in your application, read the
/// <a href="{@docRoot}guide/topics/search/index.html">Search</a> developer guide.
///
/// </div>
class SearchManager extends jni.JniObject {
  SearchManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_KEY
  ///
  /// Intent extra data key: Use this key with Intent.ACTION_SEARCH and
  /// android.content.Intent\#getIntExtra content.Intent.getIntExtra()
  /// to obtain the keycode that the user used to trigger this query.  It will be zero if the
  /// user simply pressed the "GO" button on the search UI.  This is primarily used in conjunction
  /// with the keycode attribute in the actionkey element of your searchable.xml configuration
  /// file.
  static const ACTION_KEY = "action_key";

  /// from: static public final java.lang.String ACTION_MSG
  ///
  /// Intent extra data key: Use this key with Intent.ACTION_SEARCH and
  /// android.content.Intent\#getStringExtra content.Intent.getStringExtra()
  /// to obtain the action message that was defined for a particular search action key and/or
  /// suggestion.  It will be null if the search was launched by typing "enter", touched the the
  /// "GO" button, or other means not involving any action key.
  static const ACTION_MSG = "action_msg";

  /// from: static public final java.lang.String APP_DATA
  ///
  /// Intent extra data key: Use this key with Intent.ACTION_SEARCH and
  /// android.content.Intent\#getBundleExtra content.Intent.getBundleExtra()
  /// to obtain any additional app-specific data that was inserted by the
  /// activity that launched the search.
  static const APP_DATA = "app_data";

  /// from: static public final java.lang.String CURSOR_EXTRA_KEY_IN_PROGRESS
  ///
  /// Boolean extra data key for a suggestion provider to return in Cursor\#getExtras to
  /// indicate that the search is not complete yet. This can be used by the search UI
  /// to indicate that a search is in progress. The suggestion provider can return partial results
  /// this way and send a change notification on the cursor when more results are available.
  static const CURSOR_EXTRA_KEY_IN_PROGRESS = "in_progress";

  /// from: static public final java.lang.String EXTRA_DATA_KEY
  ///
  /// Intent extra data key: This key will be used for the extra populated by the
  /// \#SUGGEST_COLUMN_INTENT_EXTRA_DATA column.
  static const EXTRA_DATA_KEY = "intent_extra_data_key";

  /// from: static public final java.lang.String EXTRA_NEW_SEARCH
  ///
  /// Boolean extra data key for Intent\#ACTION_WEB_SEARCH intents.  If {@code true},
  /// this search should open a new browser window, rather than using an existing one.
  static const EXTRA_NEW_SEARCH = "new_search";

  /// from: static public final java.lang.String EXTRA_SELECT_QUERY
  ///
  /// Boolean extra data key for \#INTENT_ACTION_GLOBAL_SEARCH intents. If {@code true},
  /// the initial query should be selected when the global search activity is started, so
  /// that the user can easily replace it with another query.
  static const EXTRA_SELECT_QUERY = "select_query";

  /// from: static public final java.lang.String EXTRA_WEB_SEARCH_PENDINGINTENT
  ///
  /// Extra data key for Intent\#ACTION_WEB_SEARCH. If set, the value must be a
  /// PendingIntent. The search activity handling the Intent\#ACTION_WEB_SEARCH
  /// intent will fill in and launch the pending intent. The data URI will be filled in with an
  /// http or https URI, and android.provider.Browser\#EXTRA_HEADERS may be filled in.
  static const EXTRA_WEB_SEARCH_PENDINGINTENT = "web_search_pendingintent";

  /// from: static public final int FLAG_QUERY_REFINEMENT
  ///
  /// Flag to specify that the entry can be used for query refinement, i.e., the query text
  /// in the search field can be replaced with the text in this entry, when a query refinement
  /// icon is clicked. The suggestion list should show such a clickable icon beside the entry.
  /// Use this flag as a bit-field for \#SUGGEST_COLUMN_FLAGS.
  static const FLAG_QUERY_REFINEMENT = 1;

  /// from: static public final java.lang.String INTENT_ACTION_GLOBAL_SEARCH
  ///
  /// Intent action for starting the global search activity.
  /// The global search provider should handle this intent.
  ///
  /// Supported extra data keys: \#QUERY,
  /// \#EXTRA_SELECT_QUERY,
  /// \#APP_DATA.
  static const INTENT_ACTION_GLOBAL_SEARCH =
      "android.search.action.GLOBAL_SEARCH";

  /// from: static public final java.lang.String INTENT_ACTION_SEARCHABLES_CHANGED
  ///
  /// Intent action broadcasted to inform that the searchables list or default have changed.
  /// Components should handle this intent if they cache any searchable data and wish to stay
  /// up to date on changes.
  static const INTENT_ACTION_SEARCHABLES_CHANGED =
      "android.search.action.SEARCHABLES_CHANGED";

  /// from: static public final java.lang.String INTENT_ACTION_SEARCH_SETTINGS
  ///
  /// Intent action for starting the global search settings activity.
  /// The global search provider should handle this intent.
  static const INTENT_ACTION_SEARCH_SETTINGS =
      "android.search.action.SEARCH_SETTINGS";

  /// from: static public final java.lang.String INTENT_ACTION_SEARCH_SETTINGS_CHANGED
  ///
  /// Intent action broadcasted to inform that the search settings have changed in some way.
  /// Either searchables have been enabled or disabled, or a different web search provider
  /// has been chosen.
  static const INTENT_ACTION_SEARCH_SETTINGS_CHANGED =
      "android.search.action.SETTINGS_CHANGED";

  /// from: static public final java.lang.String INTENT_ACTION_WEB_SEARCH_SETTINGS
  ///
  /// Intent action for starting a web search provider's settings activity.
  /// Web search providers should handle this intent if they have provider-specific
  /// settings to implement.
  static const INTENT_ACTION_WEB_SEARCH_SETTINGS =
      "android.search.action.WEB_SEARCH_SETTINGS";

  /// from: static public final java.lang.String INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED
  ///
  /// Intent action to be broadcast to inform that the global search provider
  /// has changed.
  static const INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED =
      "android.search.action.GLOBAL_SEARCH_ACTIVITY_CHANGED";

  /// from: static public final char MENU_KEY
  ///
  /// This is a shortcut definition for the default menu key to use for invoking search.
  ///
  /// See Menu.Item.setAlphabeticShortcut() for more information.
  static const MENU_KEY = "s";

  /// from: static public final int MENU_KEYCODE
  ///
  /// This is a shortcut definition for the default menu key to use for invoking search.
  ///
  /// See Menu.Item.setAlphabeticShortcut() for more information.
  static const MENU_KEYCODE = 47;

  /// from: static public final java.lang.String QUERY
  ///
  /// Intent extra data key: Use this key with
  /// android.content.Intent\#getStringExtra content.Intent.getStringExtra()
  /// to obtain the query string from Intent.ACTION_SEARCH.
  static const QUERY = "query";

  /// from: static public final java.lang.String SHORTCUT_MIME_TYPE
  ///
  /// MIME type for shortcut validation.  You'll use this in your suggestions content provider
  /// in the getType() function.
  static const SHORTCUT_MIME_TYPE =
      "vnd.android.cursor.item/vnd.android.search.suggest";

  /// from: static public final java.lang.String SUGGEST_COLUMN_AUDIO_CHANNEL_CONFIG
  ///
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content contains audio, you
  /// should provide this column to specify the audio channel configuration. The data in the
  /// column is string with format like "channels.subchannels" such as "1.0" or "5.1".
  static const SUGGEST_COLUMN_AUDIO_CHANNEL_CONFIG =
      "suggest_audio_channel_config";

  /// from: static public final java.lang.String SUGGEST_COLUMN_CONTENT_TYPE
  ///
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content is media type, you
  /// should provide this column so search app could understand more about your content. The data
  /// in the column must specify the MIME type of the content.
  static const SUGGEST_COLUMN_CONTENT_TYPE = "suggest_content_type";

  /// from: static public final java.lang.String SUGGEST_COLUMN_DURATION
  ///
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content is video or audio, you
  /// should provide this column to specify the duration of your content in milliseconds. The data
  /// in the column is of long type.
  static const SUGGEST_COLUMN_DURATION = "suggest_duration";

  /// from: static public final java.lang.String SUGGEST_COLUMN_FLAGS
  ///
  /// Column name for suggestions cursor. <i>Optional.</i> This column is used to specify
  /// additional flags per item. Multiple flags can be specified.
  ///
  /// Must be one of \#FLAG_QUERY_REFINEMENT or 0 to indicate no flags.
  ///
  ///
  static const SUGGEST_COLUMN_FLAGS = "suggest_flags";

  /// from: static public final java.lang.String SUGGEST_COLUMN_FORMAT
  ///
  /// Column name for suggestions cursor.  <i>Unused - can be null or column can be omitted.</i>
  static const SUGGEST_COLUMN_FORMAT = "suggest_format";

  /// from: static public final java.lang.String SUGGEST_COLUMN_ICON_1
  ///
  /// Column name for suggestions cursor.  <i>Optional.</i>  If your cursor includes this column,
  ///  then all suggestions will be provided in a format that includes space for two small icons,
  ///  one at the left and one at the right of each suggestion.  The data in the column must
  ///  be a resource ID of a drawable, or a URI in one of the following formats:
  ///
  /// <ul>
  /// <li>content (android.content.ContentResolver\#SCHEME_CONTENT)</li>
  /// <li>android.resource (android.content.ContentResolver\#SCHEME_ANDROID_RESOURCE)</li>
  /// <li>file (android.content.ContentResolver\#SCHEME_FILE)</li>
  /// </ul>
  ///
  /// See android.content.ContentResolver\#openAssetFileDescriptor(Uri, String)
  /// for more information on these schemes.
  static const SUGGEST_COLUMN_ICON_1 = "suggest_icon_1";

  /// from: static public final java.lang.String SUGGEST_COLUMN_ICON_2
  ///
  /// Column name for suggestions cursor.  <i>Optional.</i>  If your cursor includes this column,
  ///  then all suggestions will be provided in a format that includes space for two small icons,
  ///  one at the left and one at the right of each suggestion.  The data in the column must
  ///  be a resource ID of a drawable, or a URI in one of the following formats:
  ///
  /// <ul>
  /// <li>content (android.content.ContentResolver\#SCHEME_CONTENT)</li>
  /// <li>android.resource (android.content.ContentResolver\#SCHEME_ANDROID_RESOURCE)</li>
  /// <li>file (android.content.ContentResolver\#SCHEME_FILE)</li>
  /// </ul>
  ///
  /// See android.content.ContentResolver\#openAssetFileDescriptor(Uri, String)
  /// for more information on these schemes.
  static const SUGGEST_COLUMN_ICON_2 = "suggest_icon_2";

  /// from: static public final java.lang.String SUGGEST_COLUMN_INTENT_ACTION
  ///
  /// Column name for suggestions cursor.  <i>Optional.</i>  If this column exists <i>and</i>
  /// this element exists at the given row, this is the action that will be used when
  /// forming the suggestion's intent.  If the element is not provided, the action will be taken
  /// from the android:searchSuggestIntentAction field in your XML metadata.  <i>At least one of
  /// these must be present for the suggestion to generate an intent.</i>  Note:  If your action is
  /// the same for all suggestions, it is more efficient to specify it using XML metadata and omit
  /// it from the cursor.
  static const SUGGEST_COLUMN_INTENT_ACTION = "suggest_intent_action";

  /// from: static public final java.lang.String SUGGEST_COLUMN_INTENT_DATA
  ///
  /// Column name for suggestions cursor.  <i>Optional.</i>  If this column exists <i>and</i>
  /// this element exists at the given row, this is the data that will be used when
  /// forming the suggestion's intent.  If the element is not provided, the data will be taken
  /// from the android:searchSuggestIntentData field in your XML metadata.  If neither source
  /// is provided, the Intent's data field will be null.  Note:  If your data is
  /// the same for all suggestions, or can be described using a constant part and a specific ID,
  /// it is more efficient to specify it using XML metadata and omit it from the cursor.
  static const SUGGEST_COLUMN_INTENT_DATA = "suggest_intent_data";

  /// from: static public final java.lang.String SUGGEST_COLUMN_INTENT_DATA_ID
  ///
  /// Column name for suggestions cursor.  <i>Optional.</i>  If this column exists <i>and</i>
  /// this element exists at the given row, then "/" and this value will be appended to the data
  /// field in the Intent.  This should only be used if the data field has already been set to an
  /// appropriate base string.
  static const SUGGEST_COLUMN_INTENT_DATA_ID = "suggest_intent_data_id";

  /// from: static public final java.lang.String SUGGEST_COLUMN_INTENT_EXTRA_DATA
  ///
  /// Column name for suggestions cursor.  <i>Optional.</i>  If this column exists <i>and</i>
  /// this element exists at the given row, this is the data that will be used when
  /// forming the suggestion's intent. If not provided, the Intent's extra data field will be null.
  /// This column allows suggestions to provide additional arbitrary data which will be included as
  /// an extra under the key \#EXTRA_DATA_KEY.
  static const SUGGEST_COLUMN_INTENT_EXTRA_DATA = "suggest_intent_extra_data";

  /// from: static public final java.lang.String SUGGEST_COLUMN_IS_LIVE
  ///
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content is media type, you
  /// should provide this column to specify whether your content is live media such as live video
  /// or live audio. The value in the column is of integer type with value of either 0 indicating
  /// non-live content or 1 indicating live content.
  static const SUGGEST_COLUMN_IS_LIVE = "suggest_is_live";

  /// from: static public final java.lang.String SUGGEST_COLUMN_LAST_ACCESS_HINT
  ///
  /// Column name for suggestions cursor. <i>Optional.</i> This column may be
  /// used to specify the time in System\#currentTimeMillis System.currentTImeMillis() (wall time in UTC) when an item was last
  /// accessed within the results-providing application. If set, this may be
  /// used to show more-recently-used items first.
  static const SUGGEST_COLUMN_LAST_ACCESS_HINT = "suggest_last_access_hint";

  /// from: static public final java.lang.String SUGGEST_COLUMN_PRODUCTION_YEAR
  ///
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content is video or audio and
  /// has a known production year, you should provide this column to specify the production year
  /// of your content. The data in the column is of integer type.
  static const SUGGEST_COLUMN_PRODUCTION_YEAR = "suggest_production_year";

  /// from: static public final java.lang.String SUGGEST_COLUMN_PURCHASE_PRICE
  ///
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content is purchasable, you
  /// should provide this column to specify the displayable string representation of the purchase
  /// price of your content including the currency and the amount. If it's free, you should
  /// provide localized string to specify that it's free. This column can be omitted if the content
  /// is not applicable to purchase.
  static const SUGGEST_COLUMN_PURCHASE_PRICE = "suggest_purchase_price";

  /// from: static public final java.lang.String SUGGEST_COLUMN_QUERY
  ///
  /// Column name for suggestions cursor.  <i>Required if action is
  /// android.content.Intent\#ACTION_SEARCH ACTION_SEARCH, optional otherwise.</i>  If this
  /// column exists <i>and</i> this element exists at the given row, this is the data that will be
  /// used when forming the suggestion's query.
  static const SUGGEST_COLUMN_QUERY = "suggest_intent_query";

  /// from: static public final java.lang.String SUGGEST_COLUMN_RATING_SCORE
  ///
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content has a rating, you
  /// should provide this column to specify the rating score of your content. The data in the
  /// column is of float type. See android.media.Rating about valid rating scores for each
  /// rating style.
  static const SUGGEST_COLUMN_RATING_SCORE = "suggest_rating_score";

  /// from: static public final java.lang.String SUGGEST_COLUMN_RATING_STYLE
  ///
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content has a rating, you
  /// should provide this column to specify the rating style of your content. The data in the
  /// column must be one of the constant values specified in android.media.Rating
  static const SUGGEST_COLUMN_RATING_STYLE = "suggest_rating_style";

  /// from: static public final java.lang.String SUGGEST_COLUMN_RENTAL_PRICE
  ///
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content is rentable, you
  /// should provide this column to specify the displayable string representation of the rental
  /// price of your content including the currency and the amount. If it's free, you should
  /// provide localized string to specify that it's free. This column can be ommitted if the
  /// content is not applicable to rent.
  static const SUGGEST_COLUMN_RENTAL_PRICE = "suggest_rental_price";

  /// from: static public final java.lang.String SUGGEST_COLUMN_RESULT_CARD_IMAGE
  ///
  /// Column name for suggestions cursor.  <i>Optional.</i>  If your cursor includes this column,
  /// then the image will be displayed when forming the suggestion. The suggested dimension for
  /// the image is 270x400 px for portrait mode and 400x225 px for landscape mode. The data in the
  /// column must be a resource ID of a drawable, or a URI in one of the following formats:
  ///
  /// <ul>
  /// <li>content (android.content.ContentResolver\#SCHEME_CONTENT)</li>
  /// <li>android.resource (android.content.ContentResolver\#SCHEME_ANDROID_RESOURCE)</li>
  /// <li>file (android.content.ContentResolver\#SCHEME_FILE)</li>
  /// </ul>
  ///
  /// See android.content.ContentResolver\#openAssetFileDescriptor(Uri, String)
  /// for more information on these schemes.
  static const SUGGEST_COLUMN_RESULT_CARD_IMAGE = "suggest_result_card_image";

  /// from: static public final java.lang.String SUGGEST_COLUMN_SHORTCUT_ID
  ///
  /// Column name for suggestions cursor. <i>Optional.</i>  This column is used to indicate whether
  /// a search suggestion should be stored as a shortcut, and whether it should be refreshed.  If
  /// missing, the result will be stored as a shortcut and never validated.  If set to
  /// \#SUGGEST_NEVER_MAKE_SHORTCUT, the result will not be stored as a shortcut.
  /// Otherwise, the shortcut id will be used to check back for an up to date suggestion using
  /// \#SUGGEST_URI_PATH_SHORTCUT.
  static const SUGGEST_COLUMN_SHORTCUT_ID = "suggest_shortcut_id";

  /// from: static public final java.lang.String SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING
  ///
  /// Column name for suggestions cursor. <i>Optional.</i> This column is used to specify
  /// that a spinner should be shown in lieu of an icon2 while the shortcut of this suggestion
  /// is being refreshed.
  static const SUGGEST_COLUMN_SPINNER_WHILE_REFRESHING =
      "suggest_spinner_while_refreshing";

  /// from: static public final java.lang.String SUGGEST_COLUMN_TEXT_1
  ///
  /// Column name for suggestions cursor.  <i>Required.</i>  This is the primary line of text that
  /// will be presented to the user as the suggestion.
  static const SUGGEST_COLUMN_TEXT_1 = "suggest_text_1";

  /// from: static public final java.lang.String SUGGEST_COLUMN_TEXT_2
  ///
  /// Column name for suggestions cursor.  <i>Optional.</i>  If your cursor includes this column,
  ///  then all suggestions will be provided in a two-line format.  The second line of text is in
  ///  a much smaller appearance.
  static const SUGGEST_COLUMN_TEXT_2 = "suggest_text_2";

  /// from: static public final java.lang.String SUGGEST_COLUMN_TEXT_2_URL
  ///
  /// Column name for suggestions cursor.  <i>Optional.</i> This is a URL that will be shown
  /// as the second line of text instead of \#SUGGEST_COLUMN_TEXT_2. This is a separate
  /// column so that the search UI knows to display the text as a URL, e.g. by using a different
  /// color. If this column is absent, or has the value {@code null},
  /// \#SUGGEST_COLUMN_TEXT_2 will be used instead.
  static const SUGGEST_COLUMN_TEXT_2_URL = "suggest_text_2_url";

  /// from: static public final java.lang.String SUGGEST_COLUMN_VIDEO_HEIGHT
  ///
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content is video, you should
  /// provide this column to specify the number of horizontal lines. The data in the column is of
  /// integer type.
  static const SUGGEST_COLUMN_VIDEO_HEIGHT = "suggest_video_height";

  /// from: static public final java.lang.String SUGGEST_COLUMN_VIDEO_WIDTH
  ///
  /// Column name for suggestions cursor. <i>Optional.</i>  If your content is video, you should
  /// provide this column to specify the number of vertical lines. The data in the column is of
  /// integer type.
  static const SUGGEST_COLUMN_VIDEO_WIDTH = "suggest_video_width";

  /// from: static public final java.lang.String SUGGEST_MIME_TYPE
  ///
  /// MIME type for suggestions data.  You'll use this in your suggestions content provider
  /// in the getType() function.
  static const SUGGEST_MIME_TYPE =
      "vnd.android.cursor.dir/vnd.android.search.suggest";

  /// from: static public final java.lang.String SUGGEST_NEVER_MAKE_SHORTCUT
  ///
  /// Column value for suggestion column \#SUGGEST_COLUMN_SHORTCUT_ID when a suggestion
  /// should not be stored as a shortcut in global search.
  static const SUGGEST_NEVER_MAKE_SHORTCUT = "_-1";

  /// from: static public final java.lang.String SUGGEST_PARAMETER_LIMIT
  ///
  /// Query parameter added to suggestion queries to limit the number of suggestions returned.
  /// This limit is only advisory and suggestion providers may chose to ignore it.
  static const SUGGEST_PARAMETER_LIMIT = "limit";

  /// from: static public final java.lang.String SUGGEST_URI_PATH_QUERY
  ///
  /// Uri path for queried suggestions data.  This is the path that the search manager
  /// will use when querying your content provider for suggestions data based on user input
  /// (e.g. looking for partial matches).
  /// Typically you'll use this with a URI matcher.
  static const SUGGEST_URI_PATH_QUERY = "search_suggest_query";

  /// from: static public final java.lang.String SUGGEST_URI_PATH_SHORTCUT
  ///
  /// Uri path for shortcut validation.  This is the path that the search manager will use when
  /// querying your content provider to refresh a shortcutted suggestion result and to check if it
  /// is still valid.  When asked, a source may return an up to date result, or no result.  No
  /// result indicates the shortcut refers to a no longer valid sugggestion.
  ///@see \#SUGGEST_COLUMN_SHORTCUT_ID
  static const SUGGEST_URI_PATH_SHORTCUT = "search_suggest_shortcut";

  /// from: static public final java.lang.String USER_QUERY
  ///
  /// Intent extra data key: Use this key with
  /// android.content.Intent\#getStringExtra content.Intent.getStringExtra()
  /// to obtain the query string typed in by the user.
  /// This may be different from the value of \#QUERY
  /// if the intent is the result of selecting a suggestion.
  /// In that case, \#QUERY will contain the value of
  /// \#SUGGEST_COLUMN_QUERY for the suggestion, and
  /// \#USER_QUERY will contain the string typed by the
  /// user.
  static const USER_QUERY = "user_query";

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "SearchManager__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  SearchManager() : super.fromRef(_ctor().object);

  static final _startSearch = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("SearchManager__startSearch")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void startSearch(java.lang.String initialQuery, boolean selectInitialQuery, android.content.ComponentName launchActivity, android.os.Bundle appSearchData, boolean globalSearch)
  ///
  /// Launch search UI.
  ///
  /// The search manager will open a search widget in an overlapping
  /// window, and the underlying activity may be obscured.  The search
  /// entry state will remain in effect until one of the following events:
  /// <ul>
  /// <li>The user completes the search.  In most cases this will launch
  /// a search intent.</li>
  /// <li>The user uses the back, home, or other keys to exit the search.</li>
  /// <li>The application calls the \#stopSearch
  /// method, which will hide the search window and return focus to the
  /// activity from which it was launched.</li>
  ///
  /// Most applications will <i>not</i> use this interface to invoke search.
  /// The primary method for invoking search is to call
  /// android.app.Activity\#onSearchRequested Activity.onSearchRequested() or
  /// android.app.Activity\#startSearch Activity.startSearch().
  ///@param initialQuery A search string can be pre-entered here, but this
  /// is typically null or empty.
  ///@param selectInitialQuery If true, the intial query will be preselected, which means that
  /// any further typing will replace it.  This is useful for cases where an entire pre-formed
  /// query is being inserted.  If false, the selection point will be placed at the end of the
  /// inserted query.  This is useful when the inserted query is text that the user entered,
  /// and the user would expect to be able to keep typing.  <i>This parameter is only meaningful
  /// if initialQuery is a non-empty string.</i>
  ///@param launchActivity The ComponentName of the activity that has launched this search.
  ///@param appSearchData An application can insert application-specific
  /// context here, in order to improve quality or specificity of its own
  /// searches.  This data will be returned with SEARCH intent(s).  Null if
  /// no extra data is required.
  ///@param globalSearch If false, this will only launch the search that has been specifically
  /// defined by the application (which is usually defined as a local search).  If no default
  /// search is defined in the current application or activity, global search will be launched.
  /// If true, this will always launch a platform-global (e.g. web-based) search instead.
  ///@see android.app.Activity\#onSearchRequested
  ///@see \#stopSearch
  void startSearch(
          jni.JniString initialQuery,
          bool selectInitialQuery,
          content_.ComponentName launchActivity,
          os_.Bundle appSearchData,
          bool globalSearch) =>
      _startSearch(
              reference,
              initialQuery.reference,
              selectInitialQuery ? 1 : 0,
              launchActivity.reference,
              appSearchData.reference,
              globalSearch ? 1 : 0)
          .check();

  static final _getGlobalSearchActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchManager__getGlobalSearchActivity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getGlobalSearchActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the name of the global search activity.
  content_.ComponentName getGlobalSearchActivity() =>
      content_.ComponentName.fromRef(
          _getGlobalSearchActivity(reference).object);

  static final _triggerSearch = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("SearchManager__triggerSearch")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void triggerSearch(java.lang.String query, android.content.ComponentName launchActivity, android.os.Bundle appSearchData)
  ///
  /// Similar to \#startSearch but actually fires off the search query after invoking
  /// the search dialog.  Made available for testing purposes.
  ///@param query The query to trigger.  If empty, request will be ignored.
  ///@param launchActivity The ComponentName of the activity that has launched this search.
  ///@param appSearchData An application can insert application-specific
  /// context here, in order to improve quality or specificity of its own
  /// searches.  This data will be returned with SEARCH intent(s).  Null if
  /// no extra data is required.
  ///@see \#startSearch
  void triggerSearch(jni.JniString query, content_.ComponentName launchActivity,
          os_.Bundle appSearchData) =>
      _triggerSearch(reference, query.reference, launchActivity.reference,
              appSearchData.reference)
          .check();

  static final _stopSearch = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SearchManager__stopSearch")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void stopSearch()
  ///
  /// Terminate search UI.
  ///
  /// Typically the user will terminate the search UI by launching a
  /// search or by canceling.  This function allows the underlying application
  /// or activity to cancel the search prematurely (for any reason).
  ///
  /// This function can be safely called at any time (even if no search is active.)
  ///
  /// Configuration\#UI_MODE_TYPE_TELEVISION does not support this method.
  ///@see \#startSearch
  void stopSearch() => _stopSearch(reference).check();

  static final _setOnDismissListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "SearchManager__setOnDismissListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnDismissListener(android.app.SearchManager.OnDismissListener listener)
  ///
  /// Set or clear the callback that will be invoked whenever the search UI is dismissed.
  ///
  /// Configuration\#UI_MODE_TYPE_TELEVISION does not support this method.
  ///@param listener The OnDismissListener to use, or null.
  void setOnDismissListener(SearchManager_OnDismissListener listener) =>
      _setOnDismissListener(reference, listener.reference).check();

  static final _setOnCancelListener = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("SearchManager__setOnCancelListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnCancelListener(android.app.SearchManager.OnCancelListener listener)
  ///
  /// Set or clear the callback that will be invoked whenever the search UI is canceled.
  ///
  /// Configuration\#UI_MODE_TYPE_TELEVISION does not support this method.
  ///@param listener The OnCancelListener to use, or null.
  void setOnCancelListener(SearchManager_OnCancelListener listener) =>
      _setOnCancelListener(reference, listener.reference).check();

  static final _onCancel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("SearchManager__onCancel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCancel(android.content.DialogInterface dialog)
  ///
  /// @deprecated This method is an obsolete internal implementation detail. Do not use.
  void onCancel(content_.DialogInterface dialog) =>
      _onCancel(reference, dialog.reference).check();

  static final _onDismiss = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("SearchManager__onDismiss")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onDismiss(android.content.DialogInterface dialog)
  ///
  /// @deprecated This method is an obsolete internal implementation detail. Do not use.
  void onDismiss(content_.DialogInterface dialog) =>
      _onDismiss(reference, dialog.reference).check();

  static final _getSearchableInfo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("SearchManager__getSearchableInfo")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.SearchableInfo getSearchableInfo(android.content.ComponentName componentName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets information about a searchable activity.
  ///@param componentName The activity to get searchable information for.
  ///@return Searchable information, or <code>null</code> if the activity does not
  ///         exist, or is not searchable.
  SearchableInfo getSearchableInfo(content_.ComponentName componentName) =>
      SearchableInfo.fromRef(
          _getSearchableInfo(reference, componentName.reference).object);

  static final _getSearchablesInGlobalSearch = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchManager__getSearchablesInGlobalSearch")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.app.SearchableInfo> getSearchablesInGlobalSearch()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a list of the searchable activities that can be included in global search.
  ///@return a list containing searchable information for all searchable activities
  ///         that have the <code>android:includeInGlobalSearch</code> attribute set
  ///         in their searchable meta-data.
  jni.JniObject getSearchablesInGlobalSearch() =>
      jni.JniObject.fromRef(_getSearchablesInGlobalSearch(reference).object);
}

/// from: android.app.SearchManager$OnDismissListener
///
/// See SearchManager\#setOnDismissListener for configuring your activity to monitor
/// search UI state.
class SearchManager_OnDismissListener extends jni.JniObject {
  SearchManager_OnDismissListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onDismiss = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchManager_OnDismissListener__onDismiss")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onDismiss()
  ///
  /// This method will be called when the search UI is dismissed. To make use of it, you must
  /// implement this method in your activity, and call
  /// SearchManager\#setOnDismissListener to register it.
  void onDismiss() => _onDismiss(reference).check();
}

/// from: android.app.SearchManager$OnCancelListener
///
/// See SearchManager\#setOnCancelListener for configuring your activity to monitor
/// search UI state.
class SearchManager_OnCancelListener extends jni.JniObject {
  SearchManager_OnCancelListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onCancel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchManager_OnCancelListener__onCancel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onCancel()
  ///
  /// This method will be called when the search UI is canceled. To make use if it, you must
  /// implement this method in your activity, and call
  /// SearchManager\#setOnCancelListener to register it.
  void onCancel() => _onCancel(reference).check();
}

/// from: android.app.SearchableInfo
///
/// Searchability meta-data for an activity. Only applications that search other applications
/// should need to use this class.
/// See <a href="{@docRoot}guide/topics/search/searchable-config.html">Searchable Configuration</a>
/// for more information about declaring searchability meta-data for your application.
///@see SearchManager\#getSearchableInfo(ComponentName)
///@see SearchManager\#getSearchablesInGlobalSearch()
class SearchableInfo extends jni.JniObject {
  SearchableInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_SearchableInfo__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.SearchableInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Support for parcelable and aidl operations.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SearchableInfo__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.os.Parcel in)
  ///
  /// Instantiates a new SearchableInfo from the data in a Parcel that was
  /// previously written with \#writeToParcel(Parcel, int).
  ///@param in The Parcel containing the previously written SearchableInfo,
  /// positioned at the location in the buffer where it was written.
  SearchableInfo(os_.Parcel in0) : super.fromRef(_ctor(in0.reference).object);

  static final _getSuggestAuthority = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchableInfo__getSuggestAuthority")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSuggestAuthority()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the search suggestion content provider authority.
  ///@return The search suggestions authority, or {@code null} if not set.
  ///@see android.R.styleable\#Searchable_searchSuggestAuthority
  jni.JniString getSuggestAuthority() =>
      jni.JniString.fromRef(_getSuggestAuthority(reference).object);

  static final _getSuggestPackage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SearchableInfo__getSuggestPackage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSuggestPackage()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the name of the package where the suggestion provider lives,
  /// or {@code null}.
  jni.JniString getSuggestPackage() =>
      jni.JniString.fromRef(_getSuggestPackage(reference).object);

  static final _getSearchActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SearchableInfo__getSearchActivity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getSearchActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the component name of the searchable activity.
  ///@return A component name, never {@code null}.
  content_.ComponentName getSearchActivity() =>
      content_.ComponentName.fromRef(_getSearchActivity(reference).object);

  static final _shouldRewriteQueryFromData = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchableInfo__shouldRewriteQueryFromData")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldRewriteQueryFromData()
  ///
  /// Checks whether the text in the query field should come from the suggestion intent data.
  ///@see android.R.styleable\#Searchable_searchMode
  bool shouldRewriteQueryFromData() =>
      _shouldRewriteQueryFromData(reference).boolean;

  static final _shouldRewriteQueryFromText = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchableInfo__shouldRewriteQueryFromText")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldRewriteQueryFromText()
  ///
  /// Checks whether the text in the query field should come from the suggestion title.
  ///@see android.R.styleable\#Searchable_searchMode
  bool shouldRewriteQueryFromText() =>
      _shouldRewriteQueryFromText(reference).boolean;

  static final _getSettingsDescriptionId = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchableInfo__getSettingsDescriptionId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getSettingsDescriptionId()
  ///
  /// Gets the resource id of the description string to use for this source in system search
  /// settings, or {@code 0} if none has been specified.
  ///@see android.R.styleable\#Searchable_searchSettingsDescription
  int getSettingsDescriptionId() =>
      _getSettingsDescriptionId(reference).integer;

  static final _getSuggestPath = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SearchableInfo__getSuggestPath")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSuggestPath()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the content provider path for obtaining search suggestions.
  ///@return The suggestion path, or {@code null} if not set.
  ///@see android.R.styleable\#Searchable_searchSuggestPath
  jni.JniString getSuggestPath() =>
      jni.JniString.fromRef(_getSuggestPath(reference).object);

  static final _getSuggestSelection = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchableInfo__getSuggestSelection")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSuggestSelection()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the selection for obtaining search suggestions.
  ///@see android.R.styleable\#Searchable_searchSuggestSelection
  jni.JniString getSuggestSelection() =>
      jni.JniString.fromRef(_getSuggestSelection(reference).object);

  static final _getSuggestIntentAction = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchableInfo__getSuggestIntentAction")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSuggestIntentAction()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the optional intent action for use with these suggestions. This is
  /// useful if all intents will have the same action
  /// (e.g. android.content.Intent\#ACTION_VIEW)
  ///
  /// This can be overriden in any given suggestion using the column
  /// SearchManager\#SUGGEST_COLUMN_INTENT_ACTION.
  ///@return The default intent action, or {@code null} if not set.
  ///@see android.R.styleable\#Searchable_searchSuggestIntentAction
  jni.JniString getSuggestIntentAction() =>
      jni.JniString.fromRef(_getSuggestIntentAction(reference).object);

  static final _getSuggestIntentData = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchableInfo__getSuggestIntentData")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSuggestIntentData()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the optional intent data for use with these suggestions.  This is
  /// useful if all intents will have similar data URIs,
  /// but you'll likely need to provide a specific ID as well via the column
  /// SearchManager\#SUGGEST_COLUMN_INTENT_DATA_ID, which will be appended to the
  /// intent data URI.
  ///
  /// This can be overriden in any given suggestion using the column
  /// SearchManager\#SUGGEST_COLUMN_INTENT_DATA.
  ///@return The default intent data, or {@code null} if not set.
  ///@see android.R.styleable\#Searchable_searchSuggestIntentData
  jni.JniString getSuggestIntentData() =>
      jni.JniString.fromRef(_getSuggestIntentData(reference).object);

  static final _getSuggestThreshold = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchableInfo__getSuggestThreshold")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getSuggestThreshold()
  ///
  /// Gets the suggestion threshold.
  ///@return The suggestion threshold, or {@code 0} if not set.
  ///@see android.R.styleable\#Searchable_searchSuggestThreshold
  int getSuggestThreshold() => _getSuggestThreshold(reference).integer;

  static final _getHintId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SearchableInfo__getHintId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getHintId()
  ///
  /// Gets the resource id of the hint text. This must be
  /// read using the searchable Activity's resources.
  ///@return A resource id, or {@code 0} if no hint was specified.
  ///@see android.R.styleable\#Searchable_hint
  int getHintId() => _getHintId(reference).integer;

  static final _getVoiceSearchEnabled = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchableInfo__getVoiceSearchEnabled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getVoiceSearchEnabled()
  ///
  /// Checks if the searchable activity wants the voice search button to be shown.
  ///@see android.R.styleable\#Searchable_voiceSearchMode
  bool getVoiceSearchEnabled() => _getVoiceSearchEnabled(reference).boolean;

  static final _getVoiceSearchLaunchWebSearch = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchableInfo__getVoiceSearchLaunchWebSearch")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getVoiceSearchLaunchWebSearch()
  ///
  /// Checks if voice search should start web search.
  ///@see android.R.styleable\#Searchable_voiceSearchMode
  bool getVoiceSearchLaunchWebSearch() =>
      _getVoiceSearchLaunchWebSearch(reference).boolean;

  static final _getVoiceSearchLaunchRecognizer = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchableInfo__getVoiceSearchLaunchRecognizer")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getVoiceSearchLaunchRecognizer()
  ///
  /// Checks if voice search should start in-app search.
  ///@see android.R.styleable\#Searchable_voiceSearchMode
  bool getVoiceSearchLaunchRecognizer() =>
      _getVoiceSearchLaunchRecognizer(reference).boolean;

  static final _getVoiceLanguageModeId = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchableInfo__getVoiceLanguageModeId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getVoiceLanguageModeId()
  ///
  /// Gets the resource id of the voice search language model string.
  ///@return A resource id, or {@code 0} if no language model was specified.
  ///@see android.R.styleable\#Searchable_voiceLanguageModel
  int getVoiceLanguageModeId() => _getVoiceLanguageModeId(reference).integer;

  static final _getVoicePromptTextId = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchableInfo__getVoicePromptTextId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getVoicePromptTextId()
  ///
  /// Gets the resource id of the voice prompt text string.
  ///@return A resource id, or {@code 0} if no voice prompt text was specified.
  ///@see android.R.styleable\#Searchable_voicePromptText
  int getVoicePromptTextId() => _getVoicePromptTextId(reference).integer;

  static final _getVoiceLanguageId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SearchableInfo__getVoiceLanguageId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getVoiceLanguageId()
  ///
  /// Gets the resource id of the spoken language to recognize in voice search.
  ///@return A resource id, or {@code 0} if no language was specified.
  ///@see android.R.styleable\#Searchable_voiceLanguage
  int getVoiceLanguageId() => _getVoiceLanguageId(reference).integer;

  static final _getVoiceMaxResults = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SearchableInfo__getVoiceMaxResults")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getVoiceMaxResults()
  ///
  /// The maximum number of voice recognition results to return.
  ///@return the max results count, if specified in the searchable
  ///         activity's metadata, or {@code 0} if not specified.
  ///@see android.R.styleable\#Searchable_voiceMaxResults
  int getVoiceMaxResults() => _getVoiceMaxResults(reference).integer;

  static final _getInputType = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SearchableInfo__getInputType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getInputType()
  ///
  /// Gets the input type as specified in the searchable attributes. This will default to
  /// InputType\#TYPE_CLASS_TEXT if not specified (which is appropriate
  /// for free text input).
  ///@return the input type
  ///@see android.R.styleable\#Searchable_inputType
  int getInputType() => _getInputType(reference).integer;

  static final _getImeOptions = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SearchableInfo__getImeOptions")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getImeOptions()
  ///
  /// Gets the input method options specified in the searchable attributes.
  /// This will default to EditorInfo\#IME_ACTION_GO if not specified (which is
  /// appropriate for a search box).
  ///@return the input type
  ///@see android.R.styleable\#Searchable_imeOptions
  int getImeOptions() => _getImeOptions(reference).integer;

  static final _shouldIncludeInGlobalSearch = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchableInfo__shouldIncludeInGlobalSearch")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean shouldIncludeInGlobalSearch()
  ///
  /// Checks whether the searchable should be included in global search.
  ///@return The value of the android.R.styleable\#Searchable_includeInGlobalSearch
  ///         attribute, or {@code false} if the attribute is not set.
  ///@see android.R.styleable\#Searchable_includeInGlobalSearch
  bool shouldIncludeInGlobalSearch() =>
      _shouldIncludeInGlobalSearch(reference).boolean;

  static final _queryAfterZeroResults = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SearchableInfo__queryAfterZeroResults")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean queryAfterZeroResults()
  ///
  /// Checks whether this searchable activity should be queried for suggestions if a prefix
  /// of the query has returned no results.
  ///@see android.R.styleable\#Searchable_queryAfterZeroResults
  bool queryAfterZeroResults() => _queryAfterZeroResults(reference).boolean;

  static final _autoUrlDetect = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SearchableInfo__autoUrlDetect")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean autoUrlDetect()
  ///
  /// Checks whether this searchable activity has auto URL detection turned on.
  ///@see android.R.styleable\#Searchable_autoUrlDetect
  bool autoUrlDetect() => _autoUrlDetect(reference).boolean;

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("SearchableInfo__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("SearchableInfo__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();
}

/// from: android.app.Service
///
/// A Service is an application component representing either an application's desire
/// to perform a longer-running operation while not interacting with the user
/// or to supply functionality for other applications to use.  Each service
/// class must have a corresponding
/// android.R.styleable\#AndroidManifestService &lt;service&gt;
/// declaration in its package's <code>AndroidManifest.xml</code>.  Services
/// can be started with
/// android.content.Context\#startService Context.startService() and
/// android.content.Context\#bindService Context.bindService().
///
/// Note that services, like other application objects, run in the main
/// thread of their hosting process.  This means that, if your service is going
/// to do any CPU intensive (such as MP3 playback) or blocking (such as
/// networking) operations, it should spawn its own thread in which to do that
/// work.  More information on this can be found in
/// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html">Processes and
/// Threads</a>.  The IntentService class is available
/// as a standard implementation of Service that has its own thread where it
/// schedules its work to be done.
///
///
/// Topics covered here:
/// <ol>
/// <li><a href="\#WhatIsAService">What is a Service?</a>
/// <li><a href="\#ServiceLifecycle">Service Lifecycle</a>
/// <li><a href="\#Permissions">Permissions</a>
/// <li><a href="\#ProcessLifecycle">Process Lifecycle</a>
/// <li><a href="\#LocalServiceSample">Local Service Sample</a>
/// <li><a href="\#RemoteMessengerServiceSample">Remote Messenger Service Sample</a>
/// </ol>
///
/// <div class="special reference">
/// <h3>Developer Guides</h3>
/// For a detailed discussion about how to create services, read the
/// <a href="{@docRoot}guide/topics/fundamentals/services.html">Services</a> developer guide.
///
/// </div>
///
/// <a name="WhatIsAService"></a>
/// <h3>What is a Service?</h3>
///
/// Most confusion about the Service class actually revolves around what
/// it is _not_:
///
///
/// <ul>
/// <li> A Service is __not__ a separate process.  The Service object itself
/// does not imply it is running in its own process; unless otherwise specified,
/// it runs in the same process as the application it is part of.
/// <li> A Service is __not__ a thread.  It is not a means itself to do work off
/// of the main thread (to avoid Application Not Responding errors).
/// </ul>
///
/// Thus a Service itself is actually very simple, providing two main features:
///
///
/// <ul>
/// <li>A facility for the application to tell the system _about_
/// something it wants to be doing in the background (even when the user is not
/// directly interacting with the application).  This corresponds to calls to
/// android.content.Context\#startService Context.startService(), which
/// ask the system to schedule work for the service, to be run until the service
/// or someone else explicitly stop it.
/// <li>A facility for an application to expose some of its functionality to
/// other applications.  This corresponds to calls to
/// android.content.Context\#bindService Context.bindService(), which
/// allows a long-standing connection to be made to the service in order to
/// interact with it.
/// </ul>
///
/// When a Service component is actually created, for either of these reasons,
/// all that the system actually does is instantiate the component
/// and call its \#onCreate and any other appropriate callbacks on the
/// main thread.  It is up to the Service to implement these with the appropriate
/// behavior, such as creating a secondary thread in which it does its work.
///
///
/// Note that because Service itself is so simple, you can make your
/// interaction with it as simple or complicated as you want: from treating it
/// as a local Java object that you make direct method calls on (as illustrated
/// by <a href="\#LocalServiceSample">Local Service Sample</a>), to providing
/// a full remoteable interface using AIDL.
///
///
/// <a name="ServiceLifecycle"></a>
/// <h3>Service Lifecycle</h3>
///
/// There are two reasons that a service can be run by the system.  If someone
/// calls android.content.Context\#startService Context.startService() then the system will
/// retrieve the service (creating it and calling its \#onCreate method
/// if needed) and then call its \#onStartCommand method with the
/// arguments supplied by the client.  The service will at this point continue
/// running until android.content.Context\#stopService Context.stopService() or
/// \#stopSelf() is called.  Note that multiple calls to
/// Context.startService() do not nest (though they do result in multiple corresponding
/// calls to onStartCommand()), so no matter how many times it is started a service
/// will be stopped once Context.stopService() or stopSelf() is called; however,
/// services can use their \#stopSelf(int) method to ensure the service is
/// not stopped until started intents have been processed.
///
/// For started services, there are two additional major modes of operation
/// they can decide to run in, depending on the value they return from
/// onStartCommand(): \#START_STICKY is used for services that are
/// explicitly started and stopped as needed, while \#START_NOT_STICKY
/// or \#START_REDELIVER_INTENT are used for services that should only
/// remain running while processing any commands sent to them.  See the linked
/// documentation for more detail on the semantics.
///
/// Clients can also use android.content.Context\#bindService Context.bindService() to
/// obtain a persistent connection to a service.  This likewise creates the
/// service if it is not already running (calling \#onCreate while
/// doing so), but does not call onStartCommand().  The client will receive the
/// android.os.IBinder object that the service returns from its
/// \#onBind method, allowing the client to then make calls back
/// to the service.  The service will remain running as long as the connection
/// is established (whether or not the client retains a reference on the
/// service's IBinder).  Usually the IBinder returned is for a complex
/// interface that has been <a href="{@docRoot}guide/components/aidl.html">written
/// in aidl</a>.
///
/// A service can be both started and have connections bound to it.  In such
/// a case, the system will keep the service running as long as either it is
/// started _or_ there are one or more connections to it with the
/// android.content.Context\#BIND_AUTO_CREATE Context.BIND_AUTO_CREATE
/// flag.  Once neither
/// of these situations hold, the service's \#onDestroy method is called
/// and the service is effectively terminated.  All cleanup (stopping threads,
/// unregistering receivers) should be complete upon returning from onDestroy().
///
/// <a name="Permissions"></a>
/// <h3>Permissions</h3>
///
/// Global access to a service can be enforced when it is declared in its
/// manifest's android.R.styleable\#AndroidManifestService &lt;service&gt;
/// tag.  By doing so, other applications will need to declare a corresponding
/// android.R.styleable\#AndroidManifestUsesPermission &lt;uses-permission&gt;
/// element in their own manifest to be able to start, stop, or bind to
/// the service.
///
/// As of android.os.Build.VERSION_CODES\#GINGERBREAD, when using
/// Context\#startService(Intent) Context.startService(Intent), you can
/// also set Intent\#FLAG_GRANT_READ_URI_PERMISSION Intent.FLAG_GRANT_READ_URI_PERMISSION and/or Intent\#FLAG_GRANT_WRITE_URI_PERMISSION Intent.FLAG_GRANT_WRITE_URI_PERMISSION on the Intent.  This will grant the
/// Service temporary access to the specific URIs in the Intent.  Access will
/// remain until the Service has called \#stopSelf(int) for that start
/// command or a later one, or until the Service has been completely stopped.
/// This works for granting access to the other apps that have not requested
/// the permission protecting the Service, or even when the Service is not
/// exported at all.
///
/// In addition, a service can protect individual IPC calls into it with
/// permissions, by calling the
/// \#checkCallingPermission
/// method before executing the implementation of that call.
///
/// See the <a href="{@docRoot}guide/topics/security/security.html">Security and Permissions</a>
/// document for more information on permissions and security in general.
///
/// <a name="ProcessLifecycle"></a>
/// <h3>Process Lifecycle</h3>
///
/// The Android system will attempt to keep the process hosting a service
/// around as long as the service has been started or has clients bound to it.
/// When running low on memory and needing to kill existing processes, the
/// priority of a process hosting the service will be the higher of the
/// following possibilities:
///
/// <ul>
/// <li>If the service is currently executing code in its
/// \#onCreate onCreate(), \#onStartCommand onStartCommand(),
/// or \#onDestroy onDestroy() methods, then the hosting process will
/// be a foreground process to ensure this code can execute without
/// being killed.
/// <li>If the service has been started, then its hosting process is considered
/// to be less important than any processes that are currently visible to the
/// user on-screen, but more important than any process not visible.  Because
/// only a few processes are generally visible to the user, this means that
/// the service should not be killed except in low memory conditions.  However, since
/// the user is not directly aware of a background service, in that state it _is_
/// considered a valid candidate to kill, and you should be prepared for this to
/// happen.  In particular, long-running services will be increasingly likely to
/// kill and are guaranteed to be killed (and restarted if appropriate) if they
/// remain started long enough.
/// <li>If there are clients bound to the service, then the service's hosting
/// process is never less important than the most important client.  That is,
/// if one of its clients is visible to the user, then the service itself is
/// considered to be visible.  The way a client's importance impacts the service's
/// importance can be adjusted through Context\#BIND_ABOVE_CLIENT,
/// Context\#BIND_ALLOW_OOM_MANAGEMENT, Context\#BIND_WAIVE_PRIORITY,
/// Context\#BIND_IMPORTANT, and Context\#BIND_ADJUST_WITH_ACTIVITY.
/// <li>A started service can use the \#startForeground(int, Notification)
/// API to put the service in a foreground state, where the system considers
/// it to be something the user is actively aware of and thus not a candidate
/// for killing when low on memory.  (It is still theoretically possible for
/// the service to be killed under extreme memory pressure from the current
/// foreground application, but in practice this should not be a concern.)
/// </ul>
///
/// Note this means that most of the time your service is running, it may
/// be killed by the system if it is under heavy memory pressure.  If this
/// happens, the system will later try to restart the service.  An important
/// consequence of this is that if you implement \#onStartCommand onStartCommand()
/// to schedule work to be done asynchronously or in another thread, then you
/// may want to use \#START_FLAG_REDELIVERY to have the system
/// re-deliver an Intent for you so that it does not get lost if your service
/// is killed while processing it.
///
/// Other application components running in the same process as the service
/// (such as an android.app.Activity) can, of course, increase the
/// importance of the overall
/// process beyond just the importance of the service itself.
///
/// <a name="LocalServiceSample"></a>
/// <h3>Local Service Sample</h3>
///
/// One of the most common uses of a Service is as a secondary component
/// running alongside other parts of an application, in the same process as
/// the rest of the components.  All components of an .apk run in the same
/// process unless explicitly stated otherwise, so this is a typical situation.
///
/// When used in this way, by assuming the
/// components are in the same process, you can greatly simplify the interaction
/// between them: clients of the service can simply cast the IBinder they
/// receive from it to a concrete class published by the service.
///
/// An example of this use of a Service is shown here.  First is the Service
/// itself, publishing a custom class when bound:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/LocalService.java
///      service}
///
/// With that done, one can now write client code that directly accesses the
/// running service, such as:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/LocalServiceActivities.java
///      bind}
///
/// <a name="RemoteMessengerServiceSample"></a>
/// <h3>Remote Messenger Service Sample</h3>
///
/// If you need to be able to write a Service that can perform complicated
/// communication with clients in remote processes (beyond simply the use of
/// Context\#startService(Intent) Context.startService to send
/// commands to it), then you can use the android.os.Messenger class
/// instead of writing full AIDL files.
///
/// An example of a Service that uses Messenger as its client interface
/// is shown here.  First is the Service itself, publishing a Messenger to
/// an internal Handler when bound:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/MessengerService.java
///      service}
///
/// If we want to make this service run in a remote process (instead of the
/// standard one for its .apk), we can use <code>android:process</code> in its
/// manifest tag to specify one:
///
/// {@sample development/samples/ApiDemos/AndroidManifest.xml remote_service_declaration}
///
/// Note that the name "remote" chosen here is arbitrary, and you can use
/// other names if you want additional processes.  The ':' prefix appends the
/// name to your package's standard process name.
///
/// With that done, clients can now bind to the service and send messages
/// to it.  Note that this allows clients to register with it to receive
/// messages back as well:
///
/// {@sample development/samples/ApiDemos/src/com/example/android/apis/app/MessengerServiceActivities.java
///      bind}
class Service extends content_.ContextWrapper {
  Service.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int START_CONTINUATION_MASK
  ///
  /// Bits returned by \#onStartCommand describing how to continue
  /// the service if it is killed.  May be \#START_STICKY,
  /// \#START_NOT_STICKY, \#START_REDELIVER_INTENT,
  /// or \#START_STICKY_COMPATIBILITY.
  static const START_CONTINUATION_MASK = 15;

  /// from: static public final int START_FLAG_REDELIVERY
  ///
  /// This flag is set in \#onStartCommand if the Intent is a
  /// re-delivery of a previously delivered intent, because the service
  /// had previously returned \#START_REDELIVER_INTENT but had been
  /// killed before calling \#stopSelf(int) for that Intent.
  static const START_FLAG_REDELIVERY = 1;

  /// from: static public final int START_FLAG_RETRY
  ///
  /// This flag is set in \#onStartCommand if the Intent is a
  /// retry because the original attempt never got to or returned from
  /// \#onStartCommand(Intent, int, int).
  static const START_FLAG_RETRY = 2;

  /// from: static public final int START_NOT_STICKY
  ///
  /// Constant to return from \#onStartCommand: if this service's
  /// process is killed while it is started (after returning from
  /// \#onStartCommand), and there are no new start intents to
  /// deliver to it, then take the service out of the started state and
  /// don't recreate until a future explicit call to
  /// Context\#startService Context.startService(Intent).  The
  /// service will not receive a \#onStartCommand(Intent, int, int)
  /// call with a null Intent because it will not be re-started if there
  /// are no pending Intents to deliver.
  ///
  /// This mode makes sense for things that want to do some work as a
  /// result of being started, but can be stopped when under memory pressure
  /// and will explicit start themselves again later to do more work.  An
  /// example of such a service would be one that polls for data from
  /// a server: it could schedule an alarm to poll every N minutes by having
  /// the alarm start its service.  When its \#onStartCommand is
  /// called from the alarm, it schedules a new alarm for N minutes later,
  /// and spawns a thread to do its networking.  If its process is killed
  /// while doing that check, the service will not be restarted until the
  /// alarm goes off.
  static const START_NOT_STICKY = 2;

  /// from: static public final int START_REDELIVER_INTENT
  ///
  /// Constant to return from \#onStartCommand: if this service's
  /// process is killed while it is started (after returning from
  /// \#onStartCommand), then it will be scheduled for a restart
  /// and the last delivered Intent re-delivered to it again via
  /// \#onStartCommand.  This Intent will remain scheduled for
  /// redelivery until the service calls \#stopSelf(int) with the
  /// start ID provided to \#onStartCommand.  The
  /// service will not receive a \#onStartCommand(Intent, int, int)
  /// call with a null Intent because it will will only be re-started if
  /// it is not finished processing all Intents sent to it (and any such
  /// pending events will be delivered at the point of restart).
  static const START_REDELIVER_INTENT = 3;

  /// from: static public final int START_STICKY
  ///
  /// Constant to return from \#onStartCommand: if this service's
  /// process is killed while it is started (after returning from
  /// \#onStartCommand), then leave it in the started state but
  /// don't retain this delivered intent.  Later the system will try to
  /// re-create the service.  Because it is in the started state, it will
  /// guarantee to call \#onStartCommand after creating the new
  /// service instance; if there are not any pending start commands to be
  /// delivered to the service, it will be called with a null intent
  /// object, so you must take care to check for this.
  ///
  /// This mode makes sense for things that will be explicitly started
  /// and stopped to run for arbitrary periods of time, such as a service
  /// performing background music playback.
  static const START_STICKY = 1;

  /// from: static public final int START_STICKY_COMPATIBILITY
  ///
  /// Constant to return from \#onStartCommand: compatibility
  /// version of \#START_STICKY that does not guarantee that
  /// \#onStartCommand will be called again after being killed.
  static const START_STICKY_COMPATIBILITY = 0;

  /// from: static public final int STOP_FOREGROUND_DETACH
  ///
  /// Flag for \#stopForeground(int): if set, the notification previously provided
  /// to \#startForeground will be detached from the service.  Only makes sense
  /// when \#STOP_FOREGROUND_REMOVE is __not__ set -- in this case, the notification
  /// will remain shown, but be completely detached from the service and so no longer changed
  /// except through direct calls to the notification manager.
  static const STOP_FOREGROUND_DETACH = 2;

  /// from: static public final int STOP_FOREGROUND_REMOVE
  ///
  /// Flag for \#stopForeground(int): if set, the notification previously provided
  /// to \#startForeground will be removed.  Otherwise it will remain
  /// until a later call (to \#startForeground(int, Notification) or
  /// \#stopForeground(int) removes it, or the service is destroyed.
  static const STOP_FOREGROUND_REMOVE = 1;

  static final _ctor2 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Service__ctor2")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  Service.ctor2() : super.fromRef(_ctor2().object);

  static final _getApplication = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Service__getApplication")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final android.app.Application getApplication()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the application that owns this service.
  Application getApplication() =>
      Application.fromRef(_getApplication(reference).object);

  static final _onCreate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Service__onCreate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onCreate()
  ///
  /// Called by the system when the service is first created.  Do not call this method directly.
  void onCreate() => _onCreate(reference).check();

  static final _onStart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Service__onStart")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onStart(android.content.Intent intent, int startId)
  ///
  /// @deprecated Implement \#onStartCommand(Intent, int, int) instead.
  void onStart(content_.Intent intent, int startId) =>
      _onStart(reference, intent.reference, startId).check();

  static final _onStartCommand = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32)>>("Service__onStartCommand")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int onStartCommand(android.content.Intent intent, int flags, int startId)
  ///
  /// Called by the system every time a client explicitly starts the service by calling
  /// android.content.Context\#startService, providing the arguments it supplied and a
  /// unique integer token representing the start request.  Do not call this method directly.
  ///
  /// For backwards compatibility, the default implementation calls
  /// \#onStart and returns either \#START_STICKY
  /// or \#START_STICKY_COMPATIBILITY.
  ///
  /// <p class="caution">Note that the system calls this on your
  /// service's main thread.  A service's main thread is the same
  /// thread where UI operations take place for Activities running in the
  /// same process.  You should always avoid stalling the main
  /// thread's event loop.  When doing long-running operations,
  /// network calls, or heavy disk I/O, you should kick off a new
  /// thread, or use android.os.AsyncTask.
  ///
  ///@param intent The Intent supplied to android.content.Context\#startService,
  /// as given.  This may be null if the service is being restarted after
  /// its process has gone away, and it had previously returned anything
  /// except \#START_STICKY_COMPATIBILITY.
  ///@param flags Additional data about this start request.
  /// Value is either <code>0</code> or a combination of android.app.Service\#START_FLAG_REDELIVERY, and android.app.Service\#START_FLAG_RETRY
  ///@param startId A unique integer representing this specific request to
  /// start.  Use with \#stopSelfResult(int).
  ///@return The return value indicates what semantics the system should
  /// use for the service's current started state.  It may be one of the
  /// constants associated with the \#START_CONTINUATION_MASK bits.
  ///
  /// Value is android.app.Service\#START_STICKY_COMPATIBILITY, android.app.Service\#START_STICKY, android.app.Service\#START_NOT_STICKY, or android.app.Service\#START_REDELIVER_INTENT
  ///@see \#stopSelfResult(int)
  int onStartCommand(content_.Intent intent, int flags, int startId) =>
      _onStartCommand(reference, intent.reference, flags, startId).integer;

  static final _onDestroy = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Service__onDestroy")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDestroy()
  ///
  /// Called by the system to notify a Service that it is no longer used and is being removed.  The
  /// service should clean up any resources it holds (threads, registered
  /// receivers, etc) at this point.  Upon return, there will be no more calls
  /// in to this Service object and it is effectively dead.  Do not call this method directly.
  void onDestroy() => _onDestroy(reference).check();

  static final _onConfigurationChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Service__onConfigurationChanged")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onConfigurationChanged(android.content.res.Configuration newConfig)
  void onConfigurationChanged(res_.Configuration newConfig) =>
      _onConfigurationChanged(reference, newConfig.reference).check();

  static final _onLowMemory = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Service__onLowMemory")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onLowMemory()
  void onLowMemory() => _onLowMemory(reference).check();

  static final _onTrimMemory = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Service__onTrimMemory")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onTrimMemory(int level)
  void onTrimMemory(int level) => _onTrimMemory(reference, level).check();

  static final _onBind = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Service__onBind")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.os.IBinder onBind(android.content.Intent intent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the communication channel to the service.  May return null if
  /// clients can not bind to the service.  The returned
  /// android.os.IBinder is usually for a complex interface
  /// that has been <a href="{@docRoot}guide/components/aidl.html">described using
  /// aidl</a>.
  ///
  /// _Note that unlike other application components, calls on to the
  /// IBinder interface returned here may not happen on the main thread
  /// of the process_.  More information about the main thread can be found in
  /// <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html">Processes and
  /// Threads</a>.
  ///
  ///@param intent The Intent that was used to bind to this service,
  /// as given to android.content.Context\#bindService Context.bindService.  Note that any extras that were included with
  /// the Intent at that point will _not_ be seen here.
  ///@return Return an IBinder through which clients can call on to the
  ///         service.
  os_.IBinder onBind(content_.Intent intent) =>
      os_.IBinder.fromRef(_onBind(reference, intent.reference).object);

  static final _onUnbind = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Service__onUnbind")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean onUnbind(android.content.Intent intent)
  ///
  /// Called when all clients have disconnected from a particular interface
  /// published by the service.  The default implementation does nothing and
  /// returns false.
  ///@param intent The Intent that was used to bind to this service,
  /// as given to android.content.Context\#bindService Context.bindService.  Note that any extras that were included with
  /// the Intent at that point will _not_ be seen here.
  ///@return Return true if you would like to have the service's
  /// \#onRebind method later called when new clients bind to it.
  bool onUnbind(content_.Intent intent) =>
      _onUnbind(reference, intent.reference).boolean;

  static final _onRebind = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Service__onRebind")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onRebind(android.content.Intent intent)
  ///
  /// Called when new clients have connected to the service, after it had
  /// previously been notified that all had disconnected in its
  /// \#onUnbind.  This will only be called if the implementation
  /// of \#onUnbind was overridden to return true.
  ///@param intent The Intent that was used to bind to this service,
  /// as given to android.content.Context\#bindService Context.bindService.  Note that any extras that were included with
  /// the Intent at that point will _not_ be seen here.
  void onRebind(content_.Intent intent) =>
      _onRebind(reference, intent.reference).check();

  static final _onTaskRemoved = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Service__onTaskRemoved")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onTaskRemoved(android.content.Intent rootIntent)
  ///
  /// This is called if the service is currently running and the user has
  /// removed a task that comes from the service's application.  If you have
  /// set android.content.pm.ServiceInfo\#FLAG_STOP_WITH_TASK ServiceInfo.FLAG_STOP_WITH_TASK
  /// then you will not receive this callback; instead, the service will simply
  /// be stopped.
  ///@param rootIntent The original root Intent that was used to launch
  /// the task that is being removed.
  void onTaskRemoved(content_.Intent rootIntent) =>
      _onTaskRemoved(reference, rootIntent.reference).check();

  static final _stopSelf = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("Service__stopSelf")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final void stopSelf()
  ///
  /// Stop the service, if it was previously started.  This is the same as
  /// calling android.content.Context\#stopService for this particular service.
  ///@see \#stopSelfResult(int)
  void stopSelf() => _stopSelf(reference).check();

  static final _stopSelf1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Service__stopSelf1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void stopSelf(int startId)
  ///
  /// Old version of \#stopSelfResult that doesn't return a result.
  ///@see \#stopSelfResult
  void stopSelf1(int startId) => _stopSelf1(reference, startId).check();

  static final _stopSelfResult = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Service__stopSelfResult")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final boolean stopSelfResult(int startId)
  ///
  /// Stop the service if the most recent time it was started was
  /// <var>startId</var>.  This is the same as calling android.content.Context\#stopService for this particular service but allows you to
  /// safely avoid stopping if there is a start request from a client that you
  /// haven't yet seen in \#onStart.
  ///
  /// _Be careful about ordering of your calls to this function._.
  /// If you call this function with the most-recently received ID before
  /// you have called it for previously received IDs, the service will be
  /// immediately stopped anyway.  If you may end up processing IDs out
  /// of order (such as by dispatching them on separate threads), then you
  /// are responsible for stopping them in the same order you received them.
  ///
  ///@param startId The most recent start identifier received in \#onStart.
  ///@return Returns true if the startId matches the last start request
  /// and the service will be stopped, else false.
  ///@see \#stopSelf()
  bool stopSelfResult(int startId) =>
      _stopSelfResult(reference, startId).boolean;

  static final _startForeground = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Service__startForeground")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final void startForeground(int id, android.app.Notification notification)
  ///
  /// If your service is started (running through Context\#startService(Intent)), then
  /// also make this service run in the foreground, supplying the ongoing
  /// notification to be shown to the user while in this state.
  /// By default started services are background, meaning that their process won't be given
  /// foreground CPU scheduling (unless something else in that process is foreground) and,
  /// if the system needs to kill them to reclaim more memory (such as to display a large page in a
  /// web browser), they can be killed without too much harm.  You use
  /// \#startForeground if killing your service would be disruptive to the user, such as
  /// if your service is performing background music playback, so the user
  /// would notice if their music stopped playing.
  ///
  /// Note that calling this method does _not_ put the service in the started state
  /// itself, even though the name sounds like it.  You must always call
  /// \#startService(Intent) first to tell the system it should keep the service running,
  /// and then use this method to tell it to keep it running harder.
  ///
  ///
  /// Apps targeting API android.os.Build.VERSION_CODES\#P or later must request
  /// the permission android.Manifest.permission\#FOREGROUND_SERVICE in order to use
  /// this API.
  ///
  ///@param id The identifier for this notification as per
  /// NotificationManager\#notify(int, Notification) NotificationManager.notify(int, Notification); must not be 0.
  ///@param notification The Notification to be displayed.
  ///@see \#stopForeground(boolean)
  void startForeground(int id, Notification notification) =>
      _startForeground(reference, id, notification.reference).check();

  static final _stopForeground = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Service__stopForeground")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void stopForeground(boolean removeNotification)
  ///
  /// Synonym for \#stopForeground(int).
  ///@param removeNotification If true, the \#STOP_FOREGROUND_REMOVE flag
  /// will be supplied.
  ///@see \#stopForeground(int)
  ///@see \#startForeground(int, Notification)
  void stopForeground(bool removeNotification) =>
      _stopForeground(reference, removeNotification ? 1 : 0).check();

  static final _stopForeground1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Service__stopForeground1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public final void stopForeground(int flags)
  ///
  /// Remove this service from foreground state, allowing it to be killed if
  /// more memory is needed.  This does not stop the service from running (for that
  /// you use \#stopSelf() or related methods), just takes it out of the
  /// foreground state.
  ///@param flags additional behavior options.
  /// Value is either <code>0</code> or a combination of android.app.Service\#STOP_FOREGROUND_REMOVE, and android.app.Service\#STOP_FOREGROUND_DETACH
  ///@see \#startForeground(int, Notification)
  void stopForeground1(int flags) => _stopForeground1(reference, flags).check();

  static final _dump = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Service__dump")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void dump(java.io.FileDescriptor fd, java.io.PrintWriter writer, java.lang.String[] args)
  ///
  /// Print the Service's state into the given stream.  This gets invoked if
  /// you run "adb shell dumpsys activity service &lt;yourservicename&gt;"
  /// (note that for this command to work, the service must be running, and
  /// you must specify a fully-qualified service name).
  /// This is distinct from "dumpsys &lt;servicename&gt;", which only works for
  /// named system services and which invokes the IBinder\#dump method
  /// on the IBinder interface registered with ServiceManager.
  ///@param fd The raw file descriptor that the dump is being sent to.
  ///@param writer The PrintWriter to which you should dump your state.  This will be
  /// closed for you after you return.
  ///@param args additional arguments to the dump request.
  void dump(jni.JniObject fd, jni.JniObject writer, jni.JniObject args) =>
      _dump(reference, fd.reference, writer.reference, args.reference).check();
}

/// from: android.app.SharedElementCallback
///
/// Listener provided in
/// Activity\#setEnterSharedElementCallback(SharedElementCallback) and
/// Activity\#setExitSharedElementCallback(SharedElementCallback) as well as
/// Fragment\#setEnterSharedElementCallback(SharedElementCallback) and
/// Fragment\#setExitSharedElementCallback(SharedElementCallback)
/// to monitor the Shared element transitions. The events can be used to customize Activity
/// and Fragment Transition behavior.
class SharedElementCallback extends jni.JniObject {
  SharedElementCallback.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "SharedElementCallback__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  SharedElementCallback() : super.fromRef(_ctor().object);

  static final _onSharedElementStart = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "SharedElementCallback__onSharedElementStart")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onSharedElementStart(java.util.List<java.lang.String> sharedElementNames, java.util.List<android.view.View> sharedElements, java.util.List<android.view.View> sharedElementSnapshots)
  ///
  /// In Activity Transitions, onSharedElementStart is called immediately before
  /// capturing the start of the shared element state on enter and reenter transitions and
  /// immediately before capturing the end of the shared element state for exit and return
  /// transitions.
  ///
  /// In Fragment Transitions, onSharedElementStart is called immediately before capturing the
  /// start state of all shared element transitions.
  ///
  /// This call can be used to adjust the transition start state by modifying the shared
  /// element Views. Note that no layout step will be executed between onSharedElementStart
  /// and the transition state capture.
  ///
  /// For Activity Transitions, any changes made in \#onSharedElementEnd(List, List, List)
  /// that are not updated during by layout should be corrected in onSharedElementStart for exit and
  /// return transitions. For example, rotation or scale will not be affected by layout and
  /// if changed in \#onSharedElementEnd(List, List, List), it will also have to be reset
  /// in onSharedElementStart again to correct the end state.
  ///@param sharedElementNames The names of the shared elements that were accepted into
  ///                           the View hierarchy.
  ///@param sharedElements The shared elements that are part of the View hierarchy.
  ///@param sharedElementSnapshots The Views containing snap shots of the shared element
  ///                               from the launching Window. These elements will not
  ///                               be part of the scene, but will be positioned relative
  ///                               to the Window decor View. This list is null for Fragment
  ///                               Transitions.
  void onSharedElementStart(jni.JniObject sharedElementNames,
          jni.JniObject sharedElements, jni.JniObject sharedElementSnapshots) =>
      _onSharedElementStart(reference, sharedElementNames.reference,
              sharedElements.reference, sharedElementSnapshots.reference)
          .check();

  static final _onSharedElementEnd = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "SharedElementCallback__onSharedElementEnd")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onSharedElementEnd(java.util.List<java.lang.String> sharedElementNames, java.util.List<android.view.View> sharedElements, java.util.List<android.view.View> sharedElementSnapshots)
  ///
  /// In Activity Transitions, onSharedElementEnd is called immediately before
  /// capturing the end of the shared element state on enter and reenter transitions and
  /// immediately before capturing the start of the shared element state for exit and return
  /// transitions.
  ///
  /// In Fragment Transitions, onSharedElementEnd is called immediately before capturing the
  /// end state of all shared element transitions.
  ///
  /// This call can be used to adjust the transition end state by modifying the shared
  /// element Views. Note that no layout step will be executed between onSharedElementEnd
  /// and the transition state capture.
  ///
  /// Any changes made in \#onSharedElementStart(List, List, List) that are not updated
  /// during layout should be corrected in onSharedElementEnd. For example, rotation or scale
  /// will not be affected by layout and if changed in
  /// \#onSharedElementStart(List, List, List), it will also have to be reset in
  /// onSharedElementEnd again to correct the end state.
  ///@param sharedElementNames The names of the shared elements that were accepted into
  ///                           the View hierarchy.
  ///@param sharedElements The shared elements that are part of the View hierarchy.
  ///@param sharedElementSnapshots The Views containing snap shots of the shared element
  ///                               from the launching Window. These elements will not
  ///                               be part of the scene, but will be positioned relative
  ///                               to the Window decor View. This list will be null for
  ///                               Fragment Transitions.
  void onSharedElementEnd(jni.JniObject sharedElementNames,
          jni.JniObject sharedElements, jni.JniObject sharedElementSnapshots) =>
      _onSharedElementEnd(reference, sharedElementNames.reference,
              sharedElements.reference, sharedElementSnapshots.reference)
          .check();

  static final _onRejectSharedElements = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "SharedElementCallback__onRejectSharedElements")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onRejectSharedElements(java.util.List<android.view.View> rejectedSharedElements)
  ///
  /// Called after \#onMapSharedElements(java.util.List, java.util.Map) when
  /// transferring shared elements in. Any shared elements that have no mapping will be in
  /// <var>rejectedSharedElements</var>. The elements remaining in
  /// <var>rejectedSharedElements</var> will be transitioned out of the Scene. If a
  /// View is removed from <var>rejectedSharedElements</var>, it must be handled by the
  /// <code>SharedElementCallback</code>.
  ///
  /// Views in rejectedSharedElements will have their position and size set to the
  /// position of the calling shared element, relative to the Window decor View and contain
  /// snapshots of the View from the calling Activity or Fragment. This
  /// view may be safely added to the decor View's overlay to remain in position.
  ///
  ///
  /// This method is not called for Fragment Transitions. All rejected shared elements
  /// will be handled by the exit transition.
  ///
  ///@param rejectedSharedElements Views containing visual information of shared elements
  ///                               that are not part of the entering scene. These Views
  ///                               are positioned relative to the Window decor View. A
  ///                               View removed from this list will not be transitioned
  ///                               automatically.
  void onRejectSharedElements(jni.JniObject rejectedSharedElements) =>
      _onRejectSharedElements(reference, rejectedSharedElements.reference)
          .check();

  static final _onMapSharedElements = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "SharedElementCallback__onMapSharedElements")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onMapSharedElements(java.util.List<java.lang.String> names, java.util.Map<java.lang.String,android.view.View> sharedElements)
  ///
  /// Lets the SharedElementCallback adjust the mapping of shared element names to
  /// Views.
  ///@param names The names of all shared elements transferred from the calling Activity
  ///              or Fragment in the order they were provided.
  ///@param sharedElements The mapping of shared element names to Views. The best guess
  ///                       will be filled into sharedElements based on the transitionNames.
  void onMapSharedElements(jni.JniObject names, jni.JniObject sharedElements) =>
      _onMapSharedElements(reference, names.reference, sharedElements.reference)
          .check();

  static final _onCaptureSharedElementSnapshot = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "SharedElementCallback__onCaptureSharedElementSnapshot")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Parcelable onCaptureSharedElementSnapshot(android.view.View sharedElement, android.graphics.Matrix viewToGlobalMatrix, android.graphics.RectF screenBounds)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a snapshot of a shared element to be used by the remote Activity and reconstituted
  /// with \#onCreateSnapshotView(android.content.Context, android.os.Parcelable). A
  /// null return value will mean that the remote Activity will have a null snapshot View in
  /// \#onSharedElementStart(java.util.List, java.util.List, java.util.List) and
  /// \#onSharedElementEnd(java.util.List, java.util.List, java.util.List).
  ///
  /// This is not called for Fragment Transitions.
  ///
  ///@param sharedElement The shared element View to create a snapshot for.
  ///@param viewToGlobalMatrix A matrix containing a transform from the view to the screen
  ///                           coordinates.
  ///@param screenBounds The bounds of shared element in screen coordinate space. This is
  ///                     the bounds of the view with the viewToGlobalMatrix applied.
  ///@return A snapshot to send to the remote Activity to be reconstituted with
  /// \#onCreateSnapshotView(android.content.Context, android.os.Parcelable) and passed
  /// into \#onSharedElementStart(java.util.List, java.util.List, java.util.List) and
  /// \#onSharedElementEnd(java.util.List, java.util.List, java.util.List).
  os_.Parcelable onCaptureSharedElementSnapshot(jni.JniObject sharedElement,
          jni.JniObject viewToGlobalMatrix, jni.JniObject screenBounds) =>
      os_.Parcelable.fromRef(_onCaptureSharedElementSnapshot(
              reference,
              sharedElement.reference,
              viewToGlobalMatrix.reference,
              screenBounds.reference)
          .object);

  static final _onCreateSnapshotView = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "SharedElementCallback__onCreateSnapshotView")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.View onCreateSnapshotView(android.content.Context context, android.os.Parcelable snapshot)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Reconstitutes a snapshot View from a Parcelable returned in
  /// \#onCaptureSharedElementSnapshot(android.view.View, android.graphics.Matrix,
  /// android.graphics.RectF) to be used in \#onSharedElementStart(java.util.List,
  /// java.util.List, java.util.List) and \#onSharedElementEnd(java.util.List,
  /// java.util.List, java.util.List). The returned View will be sized and positioned after
  /// this call so that it is ready to be added to the decor View's overlay.
  ///
  /// This is not called for Fragment Transitions.
  ///
  ///@param context The Context used to create the snapshot View.
  ///@param snapshot The Parcelable returned by \#onCaptureSharedElementSnapshot(
  /// android.view.View, android.graphics.Matrix, android.graphics.RectF).
  ///@return A View to be sent in \#onSharedElementStart(java.util.List, java.util.List,
  /// java.util.List) and \#onSharedElementEnd(java.util.List, java.util.List,
  /// java.util.List). A null value will produce a null snapshot value for those two methods.
  jni.JniObject onCreateSnapshotView(
          content_.Context context, os_.Parcelable snapshot) =>
      jni.JniObject.fromRef(_onCreateSnapshotView(
              reference, context.reference, snapshot.reference)
          .object);

  static final _onSharedElementsArrived = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "SharedElementCallback__onSharedElementsArrived")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onSharedElementsArrived(java.util.List<java.lang.String> sharedElementNames, java.util.List<android.view.View> sharedElements, android.app.SharedElementCallback.OnSharedElementsReadyListener listener)
  ///
  /// Called during an Activity Transition when the shared elements have arrived at the
  /// final location and are ready to be transferred. This method is called for both the
  /// source and destination Activities.
  ///
  /// When the shared elements are ready to be transferred,
  /// OnSharedElementsReadyListener\#onSharedElementsReady()
  /// must be called to trigger the transfer.
  ///
  /// The default behavior is to trigger the transfer immediately.
  ///@param sharedElementNames The names of the shared elements that are being transferred..
  ///@param sharedElements The shared elements that are part of the View hierarchy.
  ///@param listener The listener to call when the shared elements are ready to be hidden
  ///                 in the source Activity or shown in the destination Activity.
  void onSharedElementsArrived(
          jni.JniObject sharedElementNames,
          jni.JniObject sharedElements,
          SharedElementCallback_OnSharedElementsReadyListener listener) =>
      _onSharedElementsArrived(reference, sharedElementNames.reference,
              sharedElements.reference, listener.reference)
          .check();
}

/// from: android.app.SharedElementCallback$OnSharedElementsReadyListener
///
/// Listener to be called after SharedElementCallback\#onSharedElementsArrived(List, List, OnSharedElementsReadyListener)
/// when the shared elements are ready to be hidden in the source Activity and shown in the
/// destination Activity.
class SharedElementCallback_OnSharedElementsReadyListener
    extends jni.JniObject {
  SharedElementCallback_OnSharedElementsReadyListener.fromRef(
      ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onSharedElementsReady = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "SharedElementCallback_OnSharedElementsReadyListener__onSharedElementsReady")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onSharedElementsReady()
  ///
  /// Call this method during or after the OnSharedElementsReadyListener has been received
  /// in SharedElementCallback\#onSharedElementsArrived(List, List,
  /// OnSharedElementsReadyListener) to indicate that the shared elements are ready to be
  /// hidden in the source and shown in the destination Activity.
  void onSharedElementsReady() => _onSharedElementsReady(reference).check();
}

/// from: android.app.TabActivity
///
/// For apps developing against android.os.Build.VERSION_CODES\#HONEYCOMB
/// or later, tabs are typically presented in the UI using the new
/// ActionBar\#newTab() ActionBar.newTab() and
/// related APIs for placing tabs within their action bar area.
///
///@deprecated New applications should use Fragments instead of this class;
/// to continue to run on older devices, you can use the v4 support library
/// which provides a version of the Fragment API that is compatible down to
/// android.os.Build.VERSION_CODES\#DONUT.
class TabActivity extends ActivityGroup {
  TabActivity.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "TabActivity__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  TabActivity() : super.fromRef(_ctor().object);

  static final _setDefaultTab = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("TabActivity__setDefaultTab")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setDefaultTab(java.lang.String tag)
  ///
  /// Sets the default tab that is the first tab highlighted.
  ///@param tag the name of the default tab
  void setDefaultTab(jni.JniString tag) =>
      _setDefaultTab(reference, tag.reference).check();

  static final _setDefaultTab1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("TabActivity__setDefaultTab1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setDefaultTab(int index)
  ///
  /// Sets the default tab that is the first tab highlighted.
  ///@param index the index of the default tab
  void setDefaultTab1(int index) => _setDefaultTab1(reference, index).check();

  static final _onRestoreInstanceState2 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "TabActivity__onRestoreInstanceState2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onRestoreInstanceState(android.os.Bundle state)
  void onRestoreInstanceState2(os_.Bundle state) =>
      _onRestoreInstanceState2(reference, state.reference).check();

  static final _onPostCreate2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("TabActivity__onPostCreate2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onPostCreate(android.os.Bundle icicle)
  void onPostCreate2(os_.Bundle icicle) =>
      _onPostCreate2(reference, icicle.reference).check();

  static final _onSaveInstanceState = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("TabActivity__onSaveInstanceState")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: protected void onSaveInstanceState(android.os.Bundle outState)
  void onSaveInstanceState(os_.Bundle outState) =>
      _onSaveInstanceState(reference, outState.reference).check();

  static final _onContentChanged1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("TabActivity__onContentChanged1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onContentChanged()
  ///
  /// Updates the screen state (current list and other views) when the
  /// content changes.
  ///@see Activity\#onContentChanged()
  void onContentChanged1() => _onContentChanged1(reference).check();

  static final _onChildTitleChanged1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("TabActivity__onChildTitleChanged1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: protected void onChildTitleChanged(android.app.Activity childActivity, java.lang.CharSequence title)
  void onChildTitleChanged1(Activity childActivity, jni.JniObject title) =>
      _onChildTitleChanged1(reference, childActivity.reference, title.reference)
          .check();

  static final _getTabHost = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("TabActivity__getTabHost")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.TabHost getTabHost()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the TabHost the activity is using to host its tabs.
  ///@return the TabHost the activity is using to host its tabs.
  jni.JniObject getTabHost() =>
      jni.JniObject.fromRef(_getTabHost(reference).object);

  static final _getTabWidget = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("TabActivity__getTabWidget")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.widget.TabWidget getTabWidget()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the TabWidget the activity is using to draw the actual tabs.
  ///@return the TabWidget the activity is using to draw the actual tabs.
  jni.JniObject getTabWidget() =>
      jni.JniObject.fromRef(_getTabWidget(reference).object);
}

/// from: android.app.TaskStackBuilder
///
/// Utility class for constructing synthetic back stacks for cross-task navigation
/// on Android 3.0 and newer.
///
/// In API level 11 (Android 3.0/Honeycomb) the recommended conventions for
/// app navigation using the back key changed. The back key's behavior is local
/// to the current task and does not capture navigation across different tasks.
/// Navigating across tasks and easily reaching the previous task is accomplished
/// through the "recents" UI, accessible through the software-provided Recents key
/// on the navigation or system bar. On devices with the older hardware button configuration
/// the recents UI can be accessed with a long press on the Home key.
///
///
/// When crossing from one task stack to another post-Android 3.0,
/// the application should synthesize a back stack/history for the new task so that
/// the user may navigate out of the new task and back to the Launcher by repeated
/// presses of the back key. Back key presses should not navigate across task stacks.
///
///
/// TaskStackBuilder provides a way to obey the correct conventions
/// around cross-task navigation.
///
///
/// <div class="special reference">
/// <h3>About Navigation</h3>
/// For more detailed information about tasks, the back stack, and navigation design guidelines,
/// please read
/// <a href="{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html">Tasks and Back Stack</a>
/// from the developer guide and <a href="{@docRoot}design/patterns/navigation.html">Navigation</a>
/// from the design guide.
/// </div>
class TaskStackBuilder extends jni.JniObject {
  TaskStackBuilder.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("TaskStackBuilder__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: void <init>(android.content.Context a)
  TaskStackBuilder(content_.Context a)
      : super.fromRef(_ctor(a.reference).object);

  static final _create = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("TaskStackBuilder__create")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.TaskStackBuilder create(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a new TaskStackBuilder for launching a fresh task stack consisting
  /// of a series of activities.
  ///@param context The context that will launch the new task stack or generate a PendingIntent
  ///@return A new TaskStackBuilder
  static TaskStackBuilder create(content_.Context context) =>
      TaskStackBuilder.fromRef(_create(context.reference).object);

  static final _addNextIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("TaskStackBuilder__addNextIntent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.TaskStackBuilder addNextIntent(android.content.Intent nextIntent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a new Intent to the task stack. The most recently added Intent will invoke
  /// the Activity at the top of the final task stack.
  ///@param nextIntent Intent for the next Activity in the synthesized task stack
  ///@return This TaskStackBuilder for method chaining
  TaskStackBuilder addNextIntent(content_.Intent nextIntent) =>
      TaskStackBuilder.fromRef(
          _addNextIntent(reference, nextIntent.reference).object);

  static final _addNextIntentWithParentStack = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "TaskStackBuilder__addNextIntentWithParentStack")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.TaskStackBuilder addNextIntentWithParentStack(android.content.Intent nextIntent)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a new Intent with the resolved chain of parents for the target activity to
  /// the task stack.
  ///
  /// This is equivalent to calling \#addParentStack(ComponentName) addParentStack
  /// with the resolved ComponentName of nextIntent (if it can be resolved), followed by
  /// \#addNextIntent(Intent) addNextIntent with nextIntent.
  ///
  ///@param nextIntent Intent for the topmost Activity in the synthesized task stack.
  ///                   Its chain of parents as specified in the manifest will be added.
  ///@return This TaskStackBuilder for method chaining.
  TaskStackBuilder addNextIntentWithParentStack(content_.Intent nextIntent) =>
      TaskStackBuilder.fromRef(
          _addNextIntentWithParentStack(reference, nextIntent.reference)
              .object);

  static final _addParentStack = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("TaskStackBuilder__addParentStack")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.TaskStackBuilder addParentStack(android.app.Activity sourceActivity)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add the activity parent chain as specified by the
  /// Activity\#getParentActivityIntent() getParentActivityIntent() method of the activity
  /// specified and the android.R.attr\#parentActivityName parentActivityName attributes
  /// of each successive activity (or activity-alias) element in the application's manifest
  /// to the task stack builder.
  ///@param sourceActivity All parents of this activity will be added
  ///@return This TaskStackBuilder for method chaining
  TaskStackBuilder addParentStack(Activity sourceActivity) =>
      TaskStackBuilder.fromRef(
          _addParentStack(reference, sourceActivity.reference).object);

  static final _addParentStack1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("TaskStackBuilder__addParentStack1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.TaskStackBuilder addParentStack(java.lang.Class<?> sourceActivityClass)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add the activity parent chain as specified by the
  /// android.R.attr\#parentActivityName parentActivityName attribute of the activity
  /// (or activity-alias) element in the application's manifest to the task stack builder.
  ///@param sourceActivityClass All parents of this activity will be added
  ///@return This TaskStackBuilder for method chaining
  TaskStackBuilder addParentStack1(jni.JniObject sourceActivityClass) =>
      TaskStackBuilder.fromRef(
          _addParentStack1(reference, sourceActivityClass.reference).object);

  static final _addParentStack2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("TaskStackBuilder__addParentStack2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.TaskStackBuilder addParentStack(android.content.ComponentName sourceActivityName)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add the activity parent chain as specified by the
  /// android.R.attr\#parentActivityName parentActivityName attribute of the activity
  /// (or activity-alias) element in the application's manifest to the task stack builder.
  ///@param sourceActivityName Must specify an Activity component. All parents of
  ///                           this activity will be added
  ///@return This TaskStackBuilder for method chaining
  TaskStackBuilder addParentStack2(content_.ComponentName sourceActivityName) =>
      TaskStackBuilder.fromRef(
          _addParentStack2(reference, sourceActivityName.reference).object);

  static final _getIntentCount = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("TaskStackBuilder__getIntentCount")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getIntentCount()
  ///
  /// @return the number of intents added so far.
  int getIntentCount() => _getIntentCount(reference).integer;

  static final _editIntentAt = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("TaskStackBuilder__editIntentAt")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.content.Intent editIntentAt(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the intent at the specified index for modification.
  /// Useful if you need to modify the flags or extras of an intent that was previously added,
  /// for example with \#addParentStack(Activity).
  ///@param index Index from 0-getIntentCount()
  ///@return the intent at position index
  content_.Intent editIntentAt(int index) =>
      content_.Intent.fromRef(_editIntentAt(reference, index).object);

  static final _startActivities = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("TaskStackBuilder__startActivities")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivities()
  ///
  /// Start the task stack constructed by this builder.
  void startActivities() => _startActivities(reference).check();

  static final _startActivities1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("TaskStackBuilder__startActivities1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void startActivities(android.os.Bundle options)
  ///
  /// Start the task stack constructed by this builder.
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  void startActivities1(os_.Bundle options) =>
      _startActivities1(reference, options.reference).check();

  static final _getPendingIntent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("TaskStackBuilder__getPendingIntent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.app.PendingIntent getPendingIntent(int requestCode, int flags)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtain a PendingIntent for launching the task constructed by this builder so far.
  ///@param requestCode Private request code for the sender
  ///@param flags May be PendingIntent\#FLAG_ONE_SHOT,
  ///              PendingIntent\#FLAG_NO_CREATE, PendingIntent\#FLAG_CANCEL_CURRENT,
  ///              PendingIntent\#FLAG_UPDATE_CURRENT, or any of the flags supported by
  ///              Intent\#fillIn(Intent, int) to control which unspecified parts of the
  ///              intent that can be supplied when the actual send happens.
  ///
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@return The obtained PendingIntent
  PendingIntent getPendingIntent(int requestCode, int flags) =>
      PendingIntent.fromRef(
          _getPendingIntent(reference, requestCode, flags).object);

  static final _getPendingIntent1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Int32, ffi.Pointer<ffi.Void>)>>(
          "TaskStackBuilder__getPendingIntent1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.PendingIntent getPendingIntent(int requestCode, int flags, android.os.Bundle options)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtain a PendingIntent for launching the task constructed by this builder so far.
  ///@param requestCode Private request code for the sender
  ///@param flags May be PendingIntent\#FLAG_ONE_SHOT,
  ///              PendingIntent\#FLAG_NO_CREATE, PendingIntent\#FLAG_CANCEL_CURRENT,
  ///              PendingIntent\#FLAG_UPDATE_CURRENT, or any of the flags supported by
  ///              Intent\#fillIn(Intent, int) to control which unspecified parts of the
  ///              intent that can be supplied when the actual send happens.
  /// Value is either <code>0</code> or a combination of android.app.PendingIntent\#FLAG_ONE_SHOT, android.app.PendingIntent\#FLAG_NO_CREATE, android.app.PendingIntent\#FLAG_CANCEL_CURRENT, android.app.PendingIntent\#FLAG_UPDATE_CURRENT, android.app.PendingIntent\#FLAG_IMMUTABLE, android.content.Intent\#FILL_IN_ACTION, android.content.Intent\#FILL_IN_DATA, android.content.Intent\#FILL_IN_CATEGORIES, android.content.Intent\#FILL_IN_COMPONENT, android.content.Intent\#FILL_IN_PACKAGE, android.content.Intent\#FILL_IN_SOURCE_BOUNDS, android.content.Intent\#FILL_IN_SELECTOR, and android.content.Intent\#FILL_IN_CLIP_DATA
  ///@param options Additional options for how the Activity should be started.
  /// See android.content.Context\#startActivity(Intent, Bundle)
  /// Context.startActivity(Intent, Bundle)} for more details.
  ///@return The obtained PendingIntent
  PendingIntent getPendingIntent1(
          int requestCode, int flags, os_.Bundle options) =>
      PendingIntent.fromRef(
          _getPendingIntent1(reference, requestCode, flags, options.reference)
              .object);

  static final _getIntents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("TaskStackBuilder__getIntents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent[] getIntents()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an array containing the intents added to this builder. The intent at the
  /// root of the task stack will appear as the first item in the array and the
  /// intent at the top of the stack will appear as the last item.
  ///@return An array containing the intents added to this builder.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getIntents() =>
      jni.JniObject.fromRef(_getIntents(reference).object);
}

/// from: android.app.TimePickerDialog
///
/// A dialog that prompts the user for the time of day using a
/// TimePicker.
///
///
/// See the <a href="{@docRoot}guide/topics/ui/controls/pickers.html">Pickers</a>
/// guide.
class TimePickerDialog extends AlertDialog {
  TimePickerDialog.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor3 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Uint8)>>("TimePickerDialog__ctor3")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void <init>(android.content.Context context, android.app.TimePickerDialog.OnTimeSetListener listener, int hourOfDay, int minute, boolean is24HourView)
  ///
  /// Creates a new time picker dialog.
  ///@param context the parent context
  ///@param listener the listener to call when the time is set
  ///@param hourOfDay the initial hour
  ///@param minute the initial minute
  ///@param is24HourView whether this is a 24 hour view or AM/PM
  TimePickerDialog.ctor3(
      content_.Context context,
      TimePickerDialog_OnTimeSetListener listener,
      int hourOfDay,
      int minute,
      bool is24HourView)
      : super.fromRef(_ctor3(context.reference, listener.reference, hourOfDay,
                minute, is24HourView ? 1 : 0)
            .object);

  static final _ctor4 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Uint8)>>("TimePickerDialog__ctor4")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void <init>(android.content.Context context, int themeResId, android.app.TimePickerDialog.OnTimeSetListener listener, int hourOfDay, int minute, boolean is24HourView)
  ///
  /// Creates a new time picker dialog with the specified theme.
  ///
  /// The theme is overlaid on top of the theme of the parent {@code context}.
  /// If {@code themeResId} is 0, the dialog will be inflated using the theme
  /// specified by the
  /// android.R.attr\#timePickerDialogTheme android:timePickerDialogTheme
  /// attribute on the parent {@code context}'s theme.
  ///@param context the parent context
  ///@param themeResId the resource ID of the theme to apply to this dialog
  ///@param listener the listener to call when the time is set
  ///@param hourOfDay the initial hour
  ///@param minute the initial minute
  ///@param is24HourView Whether this is a 24 hour view, or AM/PM.
  TimePickerDialog.ctor4(
      content_.Context context,
      int themeResId,
      TimePickerDialog_OnTimeSetListener listener,
      int hourOfDay,
      int minute,
      bool is24HourView)
      : super.fromRef(_ctor4(context.reference, themeResId, listener.reference,
                hourOfDay, minute, is24HourView ? 1 : 0)
            .object);

  static final _onTimeChanged = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32)>>("TimePickerDialog__onTimeChanged")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void onTimeChanged(android.widget.TimePicker view, int hourOfDay, int minute)
  void onTimeChanged(jni.JniObject view, int hourOfDay, int minute) =>
      _onTimeChanged(reference, view.reference, hourOfDay, minute).check();

  static final _show1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("TimePickerDialog__show1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void show()
  void show1() => _show1(reference).check();

  static final _onClick = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("TimePickerDialog__onClick")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void onClick(android.content.DialogInterface dialog, int which)
  void onClick(content_.DialogInterface dialog, int which) =>
      _onClick(reference, dialog.reference, which).check();

  static final _updateTime = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("TimePickerDialog__updateTime")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void updateTime(int hourOfDay, int minuteOfHour)
  ///
  /// Sets the current time.
  ///@param hourOfDay The current hour within the day.
  ///@param minuteOfHour The current minute within the hour.
  void updateTime(int hourOfDay, int minuteOfHour) =>
      _updateTime(reference, hourOfDay, minuteOfHour).check();

  static final _onSaveInstanceState1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "TimePickerDialog__onSaveInstanceState1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle onSaveInstanceState()
  /// The returned object must be deleted after use, by calling the `delete` method.
  os_.Bundle onSaveInstanceState1() =>
      os_.Bundle.fromRef(_onSaveInstanceState1(reference).object);

  static final _onRestoreInstanceState1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "TimePickerDialog__onRestoreInstanceState1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onRestoreInstanceState(android.os.Bundle savedInstanceState)
  void onRestoreInstanceState1(os_.Bundle savedInstanceState) =>
      _onRestoreInstanceState1(reference, savedInstanceState.reference).check();
}

/// from: android.app.TimePickerDialog$OnTimeSetListener
///
/// The callback interface used to indicate the user is done filling in
/// the time (e.g.&nbsp;they clicked on the 'OK' button).
class TimePickerDialog_OnTimeSetListener extends jni.JniObject {
  TimePickerDialog_OnTimeSetListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onTimeSet = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32)>>("TimePickerDialog_OnTimeSetListener__onTimeSet")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void onTimeSet(android.widget.TimePicker view, int hourOfDay, int minute)
  ///
  /// Called when the user is done setting a new time and the dialog has
  /// closed.
  ///@param view the view associated with this listener
  ///@param hourOfDay the hour that was set
  ///@param minute the minute that was set
  void onTimeSet(jni.JniObject view, int hourOfDay, int minute) =>
      _onTimeSet(reference, view.reference, hourOfDay, minute).check();
}

/// from: android.app.UiAutomation
///
/// Class for interacting with the device's UI by simulation user actions and
/// introspection of the screen content. It relies on the platform accessibility
/// APIs to introspect the screen and to perform some actions on the remote view
/// tree. It also allows injecting of arbitrary raw input events simulating user
/// interaction with keyboards and touch devices. One can think of a UiAutomation
/// as a special type of android.accessibilityservice.AccessibilityService
/// which does not provide hooks for the service life cycle and exposes other
/// APIs that are useful for UI test automation.
///
/// The APIs exposed by this class are low-level to maximize flexibility when
/// developing UI test automation tools and libraries. Generally, a UiAutomation
/// client should be using a higher-level library or implement high-level functions.
/// For example, performing a tap on the screen requires construction and injecting
/// of a touch down and up events which have to be delivered to the system by a
/// call to \#injectInputEvent(InputEvent, boolean).
///
///
///
/// The APIs exposed by this class operate across applications enabling a client
/// to write tests that cover use cases spanning over multiple applications. For
/// example, going to the settings application to change a setting and then
/// interacting with another application whose behavior depends on that setting.
///
///
class UiAutomation extends jni.JniObject {
  UiAutomation.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES
  ///
  /// UiAutomation supresses accessibility services by default. This flag specifies that
  /// existing accessibility services should continue to run, and that new ones may start.
  /// This flag is set when obtaining the UiAutomation from
  /// Instrumentation\#getUiAutomation(int).
  static const FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES = 1;

  /// from: static public final int ROTATION_FREEZE_0
  ///
  /// Rotation constant: Freeze rotation to 0 degrees (natural orientation)
  static const ROTATION_FREEZE_0 = 0;

  /// from: static public final int ROTATION_FREEZE_180
  ///
  /// Rotation constant: Freeze rotation to 180 degrees .
  static const ROTATION_FREEZE_180 = 2;

  /// from: static public final int ROTATION_FREEZE_270
  ///
  /// Rotation constant: Freeze rotation to 270 degrees .
  static const ROTATION_FREEZE_270 = 3;

  /// from: static public final int ROTATION_FREEZE_90
  ///
  /// Rotation constant: Freeze rotation to 90 degrees .
  static const ROTATION_FREEZE_90 = 1;

  /// from: static public final int ROTATION_FREEZE_CURRENT
  ///
  /// Rotation constant: Freeze rotation to its current state.
  static const ROTATION_FREEZE_CURRENT = -1;

  /// from: static public final int ROTATION_UNFREEZE
  ///
  /// Rotation constant: Unfreeze rotation (rotating the device changes its rotation state).
  static const ROTATION_UNFREEZE = -2;

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "UiAutomation__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  UiAutomation() : super.fromRef(_ctor().object);

  static final _setOnAccessibilityEventListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "UiAutomation__setOnAccessibilityEventListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setOnAccessibilityEventListener(android.app.UiAutomation.OnAccessibilityEventListener listener)
  ///
  /// Sets a callback for observing the stream of AccessibilityEvents.
  /// The callbacks are delivered on the main application thread.
  ///@param listener The callback.
  void setOnAccessibilityEventListener(
          UiAutomation_OnAccessibilityEventListener listener) =>
      _setOnAccessibilityEventListener(reference, listener.reference).check();

  static final _performGlobalAction = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("UiAutomation__performGlobalAction")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean performGlobalAction(int action)
  ///
  /// Performs a global action. Such an action can be performed at any moment
  /// regardless of the current application or user location in that application.
  /// For example going back, going home, opening recents, etc.
  ///@param action The action to perform.
  ///@return Whether the action was successfully performed.
  ///@see android.accessibilityservice.AccessibilityService\#GLOBAL_ACTION_BACK
  ///@see android.accessibilityservice.AccessibilityService\#GLOBAL_ACTION_HOME
  ///@see android.accessibilityservice.AccessibilityService\#GLOBAL_ACTION_NOTIFICATIONS
  ///@see android.accessibilityservice.AccessibilityService\#GLOBAL_ACTION_RECENTS
  bool performGlobalAction(int action) =>
      _performGlobalAction(reference, action).boolean;

  static final _findFocus = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("UiAutomation__findFocus")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.accessibility.AccessibilityNodeInfo findFocus(int focus)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Find the view that has the specified focus type. The search is performed
  /// across all windows.
  ///
  /// <strong>Note:</strong> In order to access the windows you have to opt-in
  /// to retrieve the interactive windows by setting the
  /// AccessibilityServiceInfo\#FLAG_RETRIEVE_INTERACTIVE_WINDOWS flag.
  /// Otherwise, the search will be performed only in the active window.
  ///
  ///
  ///@param focus The focus to find. One of AccessibilityNodeInfo\#FOCUS_INPUT or
  ///         AccessibilityNodeInfo\#FOCUS_ACCESSIBILITY.
  ///@return The node info of the focused view or null.
  ///@see AccessibilityNodeInfo\#FOCUS_INPUT
  ///@see AccessibilityNodeInfo\#FOCUS_ACCESSIBILITY
  jni.JniObject findFocus(int focus) =>
      jni.JniObject.fromRef(_findFocus(reference, focus).object);

  static final _getServiceInfo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("UiAutomation__getServiceInfo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.accessibilityservice.AccessibilityServiceInfo getServiceInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the an AccessibilityServiceInfo describing this UiAutomation.
  /// This method is useful if one wants to change some of the dynamically
  /// configurable properties at runtime.
  ///@return The accessibility service info.
  ///@see AccessibilityServiceInfo
  jni.JniObject getServiceInfo() =>
      jni.JniObject.fromRef(_getServiceInfo(reference).object);

  static final _setServiceInfo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("UiAutomation__setServiceInfo")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setServiceInfo(android.accessibilityservice.AccessibilityServiceInfo info)
  ///
  /// Sets the AccessibilityServiceInfo that describes how this
  /// UiAutomation will be handled by the platform accessibility layer.
  ///@param info The info.
  ///@see AccessibilityServiceInfo
  void setServiceInfo(jni.JniObject info) =>
      _setServiceInfo(reference, info.reference).check();

  static final _getWindows = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("UiAutomation__getWindows")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List<android.view.accessibility.AccessibilityWindowInfo> getWindows()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the windows on the screen. This method returns only the windows
  /// that a sighted user can interact with, as opposed to all windows.
  /// For example, if there is a modal dialog shown and the user cannot touch
  /// anything behind it, then only the modal window will be reported
  /// (assuming it is the top one). For convenience the returned windows
  /// are ordered in a descending layer order, which is the windows that
  /// are higher in the Z-order are reported first.
  ///
  /// <strong>Note:</strong> In order to access the windows you have to opt-in
  /// to retrieve the interactive windows by setting the
  /// AccessibilityServiceInfo\#FLAG_RETRIEVE_INTERACTIVE_WINDOWS flag.
  ///
  ///
  ///@return The windows if there are windows such, otherwise an empty list.
  jni.JniObject getWindows() =>
      jni.JniObject.fromRef(_getWindows(reference).object);

  static final _getRootInActiveWindow = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "UiAutomation__getRootInActiveWindow")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.accessibility.AccessibilityNodeInfo getRootInActiveWindow()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the root AccessibilityNodeInfo in the active window.
  ///@return The root info.
  jni.JniObject getRootInActiveWindow() =>
      jni.JniObject.fromRef(_getRootInActiveWindow(reference).object);

  static final _injectInputEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("UiAutomation__injectInputEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean injectInputEvent(android.view.InputEvent event, boolean sync)
  ///
  /// A method for injecting an arbitrary input event.
  ///
  /// <strong>Note:</strong> It is caller's responsibility to recycle the event.
  ///
  ///
  ///@param event The event to inject.
  ///@param sync Whether to inject the event synchronously.
  ///@return Whether event injection succeeded.
  bool injectInputEvent(jni.JniObject event, bool sync0) =>
      _injectInputEvent(reference, event.reference, sync0 ? 1 : 0).boolean;

  static final _setRotation = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("UiAutomation__setRotation")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean setRotation(int rotation)
  ///
  /// Sets the device rotation. A client can freeze the rotation in
  /// desired state or freeze the rotation to its current state or
  /// unfreeze the rotation (rotating the device changes its rotation
  /// state).
  ///@param rotation The desired rotation.
  ///@return Whether the rotation was set successfully.
  ///@see \#ROTATION_FREEZE_0
  ///@see \#ROTATION_FREEZE_90
  ///@see \#ROTATION_FREEZE_180
  ///@see \#ROTATION_FREEZE_270
  ///@see \#ROTATION_FREEZE_CURRENT
  ///@see \#ROTATION_UNFREEZE
  bool setRotation(int rotation) => _setRotation(reference, rotation).boolean;

  static final _executeAndWaitForEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64)>>("UiAutomation__executeAndWaitForEvent")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.accessibility.AccessibilityEvent executeAndWaitForEvent(java.lang.Runnable command, android.app.UiAutomation.AccessibilityEventFilter filter, long timeoutMillis)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Executes a command and waits for a specific accessibility event up to a
  /// given wait timeout. To detect a sequence of events one can implement a
  /// filter that keeps track of seen events of the expected sequence and
  /// returns true after the last event of that sequence is received.
  ///
  /// <strong>Note:</strong> It is caller's responsibility to recycle the returned event.
  ///
  ///
  ///@param command The command to execute.
  ///@param filter Filter that recognizes the expected event.
  ///@param timeoutMillis The wait timeout in milliseconds.
  ///@throws TimeoutException If the expected event is not received within the timeout.
  jni.JniObject executeAndWaitForEvent(jni.JniObject command,
          UiAutomation_AccessibilityEventFilter filter, int timeoutMillis) =>
      jni.JniObject.fromRef(_executeAndWaitForEvent(
              reference, command.reference, filter.reference, timeoutMillis)
          .object);

  static final _waitForIdle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Int64)>>("UiAutomation__waitForIdle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void waitForIdle(long idleTimeoutMillis, long globalTimeoutMillis)
  ///
  /// Waits for the accessibility event stream to become idle, which is not to
  /// have received an accessibility event within <code>idleTimeoutMillis</code>.
  /// The total time spent to wait for an idle accessibility event stream is bounded
  /// by the <code>globalTimeoutMillis</code>.
  ///@param idleTimeoutMillis The timeout in milliseconds between two events
  ///            to consider the device idle.
  ///@param globalTimeoutMillis The maximal global timeout in milliseconds in
  ///            which to wait for an idle state.
  ///@throws TimeoutException If no idle state was detected within
  ///            <code>globalTimeoutMillis.</code>
  void waitForIdle(int idleTimeoutMillis, int globalTimeoutMillis) =>
      _waitForIdle(reference, idleTimeoutMillis, globalTimeoutMillis).check();

  static final _takeScreenshot = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("UiAutomation__takeScreenshot")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap takeScreenshot()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Takes a screenshot.
  ///@return The screenshot bitmap on success, null otherwise.
  jni.JniObject takeScreenshot() =>
      jni.JniObject.fromRef(_takeScreenshot(reference).object);

  static final _setRunAsMonkey = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("UiAutomation__setRunAsMonkey")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setRunAsMonkey(boolean enable)
  ///
  /// Sets whether this UiAutomation to run in a "monkey" mode. Applications can query whether
  /// they are executed in a "monkey" mode, i.e. run by a test framework, and avoid doing
  /// potentially undesirable actions such as calling 911 or posting on public forums etc.
  ///@param enable whether to run in a "monkey" mode or not. Default is not.
  ///@see ActivityManager\#isUserAMonkey()
  void setRunAsMonkey(bool enable) =>
      _setRunAsMonkey(reference, enable ? 1 : 0).check();

  static final _clearWindowContentFrameStats = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("UiAutomation__clearWindowContentFrameStats")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean clearWindowContentFrameStats(int windowId)
  ///
  /// Clears the frame statistics for the content of a given window. These
  /// statistics contain information about the most recently rendered content
  /// frames.
  ///@param windowId The window id.
  ///@return Whether the window is present and its frame statistics
  ///         were cleared.
  ///@see android.view.WindowContentFrameStats
  ///@see \#getWindowContentFrameStats(int)
  ///@see \#getWindows()
  ///@see AccessibilityWindowInfo\#getId() AccessibilityWindowInfo.getId()
  bool clearWindowContentFrameStats(int windowId) =>
      _clearWindowContentFrameStats(reference, windowId).boolean;

  static final _getWindowContentFrameStats = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("UiAutomation__getWindowContentFrameStats")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.view.WindowContentFrameStats getWindowContentFrameStats(int windowId)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the frame statistics for a given window. These statistics contain
  /// information about the most recently rendered content frames.
  ///
  /// A typical usage requires clearing the window frame statistics via \#clearWindowContentFrameStats(int) followed by an interaction with the UI and
  /// finally getting the window frame statistics via calling this method.
  ///
  ///
  /// <pre>
  /// // Assume we have at least one window.
  /// final int windowId = getWindows().get(0).getId();
  ///
  /// // Start with a clean slate.
  /// uiAutimation.clearWindowContentFrameStats(windowId);
  ///
  /// // Do stuff with the UI.
  ///
  /// // Get the frame statistics.
  /// WindowContentFrameStats stats = uiAutomation.getWindowContentFrameStats(windowId);
  /// </pre>
  ///@param windowId The window id.
  ///@return The window frame statistics, or null if the window is not present.
  ///@see android.view.WindowContentFrameStats
  ///@see \#clearWindowContentFrameStats(int)
  ///@see \#getWindows()
  ///@see AccessibilityWindowInfo\#getId() AccessibilityWindowInfo.getId()
  jni.JniObject getWindowContentFrameStats(int windowId) =>
      jni.JniObject.fromRef(
          _getWindowContentFrameStats(reference, windowId).object);

  static final _clearWindowAnimationFrameStats = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "UiAutomation__clearWindowAnimationFrameStats")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void clearWindowAnimationFrameStats()
  ///
  /// Clears the window animation rendering statistics. These statistics contain
  /// information about the most recently rendered window animation frames, i.e.
  /// for window transition animations.
  ///@see android.view.WindowAnimationFrameStats
  ///@see \#getWindowAnimationFrameStats()
  ///@see android.R.styleable\#WindowAnimation
  void clearWindowAnimationFrameStats() =>
      _clearWindowAnimationFrameStats(reference).check();

  static final _getWindowAnimationFrameStats = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "UiAutomation__getWindowAnimationFrameStats")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.view.WindowAnimationFrameStats getWindowAnimationFrameStats()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the window animation frame statistics. These statistics contain
  /// information about the most recently rendered window animation frames, i.e.
  /// for window transition animations.
  ///
  ///
  /// A typical usage requires clearing the window animation frame statistics via
  /// \#clearWindowAnimationFrameStats() followed by an interaction that causes
  /// a window transition which uses a window animation and finally getting the window
  /// animation frame statistics by calling this method.
  ///
  ///
  /// <pre>
  /// // Start with a clean slate.
  /// uiAutimation.clearWindowAnimationFrameStats();
  ///
  /// // Do stuff to trigger a window transition.
  ///
  /// // Get the frame statistics.
  /// WindowAnimationFrameStats stats = uiAutomation.getWindowAnimationFrameStats();
  /// </pre>
  ///@return The window animation frame statistics.
  ///@see android.view.WindowAnimationFrameStats
  ///@see \#clearWindowAnimationFrameStats()
  ///@see android.R.styleable\#WindowAnimation
  jni.JniObject getWindowAnimationFrameStats() =>
      jni.JniObject.fromRef(_getWindowAnimationFrameStats(reference).object);

  static final _grantRuntimePermission = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "UiAutomation__grantRuntimePermission")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void grantRuntimePermission(java.lang.String packageName, java.lang.String permission)
  ///
  /// Grants a runtime permission to a package.
  ///@param packageName The package to which to grant.
  ///@param permission The permission to grant.
  ///@throws SecurityException if unable to grant the permission.
  void grantRuntimePermission(
          jni.JniString packageName, jni.JniString permission) =>
      _grantRuntimePermission(
              reference, packageName.reference, permission.reference)
          .check();

  static final _grantRuntimePermissionAsUser = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "UiAutomation__grantRuntimePermissionAsUser")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void grantRuntimePermissionAsUser(java.lang.String packageName, java.lang.String permission, android.os.UserHandle userHandle)
  ///
  /// Grants a runtime permission to a package for a user.
  ///@param packageName The package to which to grant.
  ///@param permission The permission to grant.
  ///@throws SecurityException if unable to grant the permission.
  void grantRuntimePermissionAsUser(jni.JniString packageName,
          jni.JniString permission, os_.UserHandle userHandle) =>
      _grantRuntimePermissionAsUser(reference, packageName.reference,
              permission.reference, userHandle.reference)
          .check();

  static final _revokeRuntimePermission = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "UiAutomation__revokeRuntimePermission")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void revokeRuntimePermission(java.lang.String packageName, java.lang.String permission)
  ///
  /// Revokes a runtime permission from a package.
  ///@param packageName The package to which to grant.
  ///@param permission The permission to grant.
  ///@throws SecurityException if unable to revoke the permission.
  void revokeRuntimePermission(
          jni.JniString packageName, jni.JniString permission) =>
      _revokeRuntimePermission(
              reference, packageName.reference, permission.reference)
          .check();

  static final _revokeRuntimePermissionAsUser = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "UiAutomation__revokeRuntimePermissionAsUser")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void revokeRuntimePermissionAsUser(java.lang.String packageName, java.lang.String permission, android.os.UserHandle userHandle)
  ///
  /// Revokes a runtime permission from a package.
  ///@param packageName The package to which to grant.
  ///@param permission The permission to grant.
  ///@throws SecurityException if unable to revoke the permission.
  void revokeRuntimePermissionAsUser(jni.JniString packageName,
          jni.JniString permission, os_.UserHandle userHandle) =>
      _revokeRuntimePermissionAsUser(reference, packageName.reference,
              permission.reference, userHandle.reference)
          .check();

  static final _executeShellCommand = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("UiAutomation__executeShellCommand")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.ParcelFileDescriptor executeShellCommand(java.lang.String command)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Executes a shell command. This method returns a file descriptor that points
  /// to the standard output stream. The command execution is similar to running
  /// "adb shell <command>" from a host connected to the device.
  ///
  /// <strong>Note:</strong> It is your responsibility to close the returned file
  /// descriptor once you are done reading.
  ///
  ///
  ///@param command The command to execute.
  ///@return A file descriptor to the standard output stream.
  os_.ParcelFileDescriptor executeShellCommand(jni.JniString command) =>
      os_.ParcelFileDescriptor.fromRef(
          _executeShellCommand(reference, command.reference).object);
}

/// from: android.app.UiAutomation$OnAccessibilityEventListener
///
/// Listener for observing the AccessibilityEvent stream.
class UiAutomation_OnAccessibilityEventListener extends jni.JniObject {
  UiAutomation_OnAccessibilityEventListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onAccessibilityEvent = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "UiAutomation_OnAccessibilityEventListener__onAccessibilityEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onAccessibilityEvent(android.view.accessibility.AccessibilityEvent event)
  ///
  /// Callback for receiving an AccessibilityEvent.
  ///
  /// <strong>Note:</strong> This method is <strong>NOT</strong> executed
  /// on the main test thread. The client is responsible for proper
  /// synchronization.
  ///
  ///
  ///
  /// <strong>Note:</strong> It is responsibility of the client
  /// to recycle the received events to minimize object creation.
  ///
  ///
  ///@param event The received event.
  void onAccessibilityEvent(jni.JniObject event) =>
      _onAccessibilityEvent(reference, event.reference).check();
}

/// from: android.app.UiAutomation$AccessibilityEventFilter
///
/// Listener for filtering accessibility events.
class UiAutomation_AccessibilityEventFilter extends jni.JniObject {
  UiAutomation_AccessibilityEventFilter.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _accept = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "UiAutomation_AccessibilityEventFilter__accept")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean accept(android.view.accessibility.AccessibilityEvent event)
  ///
  /// Callback for determining whether an event is accepted or
  /// it is filtered out.
  ///@param event The event to process.
  ///@return True if the event is accepted, false to filter it out.
  bool accept(jni.JniObject event) =>
      _accept(reference, event.reference).boolean;
}

/// from: android.app.UiModeManager
///
/// This class provides access to the system uimode services.  These services
/// allow applications to control UI modes of the device.
/// It provides functionality to disable the car mode and it gives access to the
/// night mode settings.
///
/// These facilities are built on top of the underlying
/// android.content.Intent\#ACTION_DOCK_EVENT broadcasts that are sent when the user
/// physical places the device into and out of a dock.  When that happens,
/// the UiModeManager switches the system android.content.res.Configuration
/// to the appropriate UI mode, sends broadcasts about the mode switch, and
/// starts the corresponding mode activity if appropriate.  See the
/// broadcasts \#ACTION_ENTER_CAR_MODE and
/// \#ACTION_ENTER_DESK_MODE for more information.
///
/// In addition, the user may manually switch the system to car mode without
/// physically being in a dock.  While in car mode -- whether by manual action
/// from the user or being physically placed in a dock -- a notification is
/// displayed allowing the user to exit dock mode.  Thus the dock mode
/// represented here may be different than the current state of the underlying
/// dock event broadcast.
class UiModeManager extends jni.JniObject {
  UiModeManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_ACTION_ENTER_CAR_MODE =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_UiModeManager__ACTION_ENTER_CAR_MODE")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.lang.String ACTION_ENTER_CAR_MODE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Broadcast sent when the device's UI has switched to car mode, either
  /// by being placed in a car dock or explicit action of the user.  After
  /// sending the broadcast, the system will start the intent
  /// android.content.Intent\#ACTION_MAIN with category
  /// android.content.Intent\#CATEGORY_CAR_DOCK
  /// to display the car UI, which typically what an application would
  /// implement to provide their own interface.  However, applications can
  /// also monitor this Intent in order to be informed of mode changes or
  /// prevent the normal car UI from being displayed by setting the result
  /// of the broadcast to Activity\#RESULT_CANCELED.
  static jni.JniString get ACTION_ENTER_CAR_MODE =>
      jni.JniString.fromRef(_get_ACTION_ENTER_CAR_MODE().object);
  static final _set_ACTION_ENTER_CAR_MODE = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(ffi.Pointer<ffi.Void>)>>(
          "set_UiModeManager__ACTION_ENTER_CAR_MODE")
      .asFunction<jni.JThrowable Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String ACTION_ENTER_CAR_MODE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Broadcast sent when the device's UI has switched to car mode, either
  /// by being placed in a car dock or explicit action of the user.  After
  /// sending the broadcast, the system will start the intent
  /// android.content.Intent\#ACTION_MAIN with category
  /// android.content.Intent\#CATEGORY_CAR_DOCK
  /// to display the car UI, which typically what an application would
  /// implement to provide their own interface.  However, applications can
  /// also monitor this Intent in order to be informed of mode changes or
  /// prevent the normal car UI from being displayed by setting the result
  /// of the broadcast to Activity\#RESULT_CANCELED.
  static set ACTION_ENTER_CAR_MODE(jni.JniString value) =>
      _set_ACTION_ENTER_CAR_MODE(value.reference);

  static final _get_ACTION_ENTER_DESK_MODE =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_UiModeManager__ACTION_ENTER_DESK_MODE")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.lang.String ACTION_ENTER_DESK_MODE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Broadcast sent when the device's UI has switched to desk mode,
  /// by being placed in a desk dock.  After
  /// sending the broadcast, the system will start the intent
  /// android.content.Intent\#ACTION_MAIN with category
  /// android.content.Intent\#CATEGORY_DESK_DOCK
  /// to display the desk UI, which typically what an application would
  /// implement to provide their own interface.  However, applications can
  /// also monitor this Intent in order to be informed of mode changes or
  /// prevent the normal desk UI from being displayed by setting the result
  /// of the broadcast to Activity\#RESULT_CANCELED.
  static jni.JniString get ACTION_ENTER_DESK_MODE =>
      jni.JniString.fromRef(_get_ACTION_ENTER_DESK_MODE().object);
  static final _set_ACTION_ENTER_DESK_MODE = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(ffi.Pointer<ffi.Void>)>>(
          "set_UiModeManager__ACTION_ENTER_DESK_MODE")
      .asFunction<jni.JThrowable Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String ACTION_ENTER_DESK_MODE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Broadcast sent when the device's UI has switched to desk mode,
  /// by being placed in a desk dock.  After
  /// sending the broadcast, the system will start the intent
  /// android.content.Intent\#ACTION_MAIN with category
  /// android.content.Intent\#CATEGORY_DESK_DOCK
  /// to display the desk UI, which typically what an application would
  /// implement to provide their own interface.  However, applications can
  /// also monitor this Intent in order to be informed of mode changes or
  /// prevent the normal desk UI from being displayed by setting the result
  /// of the broadcast to Activity\#RESULT_CANCELED.
  static set ACTION_ENTER_DESK_MODE(jni.JniString value) =>
      _set_ACTION_ENTER_DESK_MODE(value.reference);

  static final _get_ACTION_EXIT_CAR_MODE =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_UiModeManager__ACTION_EXIT_CAR_MODE")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.lang.String ACTION_EXIT_CAR_MODE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Broadcast sent when the device's UI has switch away from car mode back
  /// to normal mode.  Typically used by a car mode app, to dismiss itself
  /// when the user exits car mode.
  static jni.JniString get ACTION_EXIT_CAR_MODE =>
      jni.JniString.fromRef(_get_ACTION_EXIT_CAR_MODE().object);
  static final _set_ACTION_EXIT_CAR_MODE = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(ffi.Pointer<ffi.Void>)>>(
          "set_UiModeManager__ACTION_EXIT_CAR_MODE")
      .asFunction<jni.JThrowable Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String ACTION_EXIT_CAR_MODE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Broadcast sent when the device's UI has switch away from car mode back
  /// to normal mode.  Typically used by a car mode app, to dismiss itself
  /// when the user exits car mode.
  static set ACTION_EXIT_CAR_MODE(jni.JniString value) =>
      _set_ACTION_EXIT_CAR_MODE(value.reference);

  static final _get_ACTION_EXIT_DESK_MODE =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_UiModeManager__ACTION_EXIT_DESK_MODE")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.lang.String ACTION_EXIT_DESK_MODE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Broadcast sent when the device's UI has switched away from desk mode back
  /// to normal mode.  Typically used by a desk mode app, to dismiss itself
  /// when the user exits desk mode.
  static jni.JniString get ACTION_EXIT_DESK_MODE =>
      jni.JniString.fromRef(_get_ACTION_EXIT_DESK_MODE().object);
  static final _set_ACTION_EXIT_DESK_MODE = jniLookup<
              ffi.NativeFunction<
                  jni.JThrowable Function(ffi.Pointer<ffi.Void>)>>(
          "set_UiModeManager__ACTION_EXIT_DESK_MODE")
      .asFunction<jni.JThrowable Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String ACTION_EXIT_DESK_MODE
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Broadcast sent when the device's UI has switched away from desk mode back
  /// to normal mode.  Typically used by a desk mode app, to dismiss itself
  /// when the user exits desk mode.
  static set ACTION_EXIT_DESK_MODE(jni.JniString value) =>
      _set_ACTION_EXIT_DESK_MODE(value.reference);

  /// from: static public final int DISABLE_CAR_MODE_GO_HOME
  ///
  /// Flag for use with \#disableCarMode(int): go to the normal
  /// home activity as part of the disable.  Disabling this way ensures
  /// a clean transition between the current activity (in car mode) and
  /// the original home activity (which was typically last running without
  /// being in car mode).
  static const DISABLE_CAR_MODE_GO_HOME = 1;

  /// from: static public final int ENABLE_CAR_MODE_ALLOW_SLEEP
  ///
  /// Flag for use with \#enableCarMode(int): allow sleep mode while in car mode.
  /// By default, when this flag is not set, the system may hold a full wake lock to keep the
  /// screen turned on and prevent the system from entering sleep mode while in car mode.
  /// Setting this flag disables such behavior and the system may enter sleep mode
  /// if there is no other user activity and no other wake lock held.
  /// Setting this flag can be relevant for a car dock application that does not require the
  /// screen kept on.
  static const ENABLE_CAR_MODE_ALLOW_SLEEP = 2;

  /// from: static public final int ENABLE_CAR_MODE_GO_CAR_HOME
  ///
  /// Flag for use with \#enableCarMode(int): go to the car
  /// home activity as part of the enable.  Enabling this way ensures
  /// a clean transition between the current activity (in non-car-mode) and
  /// the car home activity that will serve as home while in car mode.  This
  /// will switch to the car home activity even if we are already in car mode.
  static const ENABLE_CAR_MODE_GO_CAR_HOME = 1;

  /// from: static public final int MODE_NIGHT_AUTO
  ///
  /// Constant for \#setNightMode(int) and \#getNightMode():
  /// automatically switch night mode on and off based on the time.
  static const MODE_NIGHT_AUTO = 0;

  /// from: static public final int MODE_NIGHT_NO
  ///
  /// Constant for \#setNightMode(int) and \#getNightMode():
  /// never run in night mode.
  static const MODE_NIGHT_NO = 1;

  /// from: static public final int MODE_NIGHT_YES
  ///
  /// Constant for \#setNightMode(int) and \#getNightMode():
  /// always run in night mode.
  static const MODE_NIGHT_YES = 2;

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "UiModeManager__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  UiModeManager() : super.fromRef(_ctor().object);

  static final _enableCarMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("UiModeManager__enableCarMode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void enableCarMode(int flags)
  ///
  /// Force device into car mode, like it had been placed in the car dock.
  /// This will cause the device to switch to the car home UI as part of
  /// the mode switch.
  ///@param flags Must be 0.
  void enableCarMode(int flags) => _enableCarMode(reference, flags).check();

  static final _disableCarMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("UiModeManager__disableCarMode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void disableCarMode(int flags)
  ///
  /// Turn off special mode if currently in car mode.
  ///@param flags May be 0 or \#DISABLE_CAR_MODE_GO_HOME.
  void disableCarMode(int flags) => _disableCarMode(reference, flags).check();

  static final _getCurrentModeType = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("UiModeManager__getCurrentModeType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getCurrentModeType()
  ///
  /// Return the current running mode type.  May be one of
  /// Configuration\#UI_MODE_TYPE_NORMAL Configuration.UI_MODE_TYPE_NORMAL,
  /// Configuration\#UI_MODE_TYPE_DESK Configuration.UI_MODE_TYPE_DESK,
  /// Configuration\#UI_MODE_TYPE_CAR Configuration.UI_MODE_TYPE_CAR,
  /// Configuration\#UI_MODE_TYPE_TELEVISION Configuration.UI_MODE_TYPE_TELEVISION,
  /// Configuration\#UI_MODE_TYPE_APPLIANCE Configuration.UI_MODE_TYPE_APPLIANCE,
  /// Configuration\#UI_MODE_TYPE_WATCH Configuration.UI_MODE_TYPE_WATCH, or
  /// Configuration\#UI_MODE_TYPE_VR_HEADSET Configuration.UI_MODE_TYPE_VR_HEADSET.
  int getCurrentModeType() => _getCurrentModeType(reference).integer;

  static final _setNightMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("UiModeManager__setNightMode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setNightMode(int mode)
  ///
  /// Sets the night mode.
  ///
  /// The mode can be one of:
  /// <ul>
  ///   <li>_\#MODE_NIGHT_NO_ sets the device into
  ///       {@code notnight} mode</li>
  ///   <li>_\#MODE_NIGHT_YES_ sets the device into
  ///       {@code night} mode</li>
  ///   <li>_\#MODE_NIGHT_AUTO_ automatically switches between
  ///       {@code night} and {@code notnight} based on the device's current
  ///       location and certain other sensors</li>
  /// </ul>
  ///
  /// <strong>Note:</strong> On API 22 and below, changes to the night mode
  /// are only effective when the Configuration\#UI_MODE_TYPE_CAR car
  /// or Configuration\#UI_MODE_TYPE_DESK desk mode is enabled on a
  /// device. Starting in API 23, changes to night mode are always effective.
  ///@param mode the night mode to set
  /// Value is android.app.UiModeManager\#MODE_NIGHT_AUTO, android.app.UiModeManager\#MODE_NIGHT_NO, or android.app.UiModeManager\#MODE_NIGHT_YES
  ///@see \#getNightMode()
  void setNightMode(int mode) => _setNightMode(reference, mode).check();

  static final _getNightMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("UiModeManager__getNightMode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getNightMode()
  ///
  /// Returns the currently configured night mode.
  ///
  /// May be one of:
  /// <ul>
  ///   <li>\#MODE_NIGHT_NO</li>
  ///   <li>\#MODE_NIGHT_YES</li>
  ///   <li>\#MODE_NIGHT_AUTO</li>
  ///   <li>{@code -1} on error</li>
  /// </ul>
  ///@return the current night mode, or {@code -1} on error
  /// Value is android.app.UiModeManager\#MODE_NIGHT_AUTO, android.app.UiModeManager\#MODE_NIGHT_NO, or android.app.UiModeManager\#MODE_NIGHT_YES
  ///@see \#setNightMode(int)
  int getNightMode() => _getNightMode(reference).integer;
}

/// from: android.app.VoiceInteractor
///
/// Interface for an Activity to interact with the user through voice.  Use
/// android.app.Activity\#getVoiceInteractor() Activity.getVoiceInteractor
/// to retrieve the interface, if the activity is currently involved in a voice interaction.
///
/// The voice interactor revolves around submitting voice interaction requests to the
/// back-end voice interaction service that is working with the user.  These requests are
/// submitted with \#submitRequest, providing a new instance of a
/// Request subclass describing the type of operation to perform -- currently the
/// possible requests are ConfirmationRequest and CommandRequest.
///
/// Once a request is submitted, the voice system will process it and eventually deliver
/// the result to the request object.  The application can cancel a pending request at any
/// time.
///
/// The VoiceInteractor is integrated with Activity's state saving mechanism, so that
/// if an activity is being restarted with retained state, it will retain the current
/// VoiceInteractor and any outstanding requests.  Because of this, you should always use
/// Request\#getActivity() Request.getActivity to get back to the activity of a
/// request, rather than holding on to the activity instance yourself, either explicitly
/// or implicitly through a non-static inner class.
class VoiceInteractor extends jni.JniObject {
  VoiceInteractor.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "VoiceInteractor__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  VoiceInteractor() : super.fromRef(_ctor().object);

  static final _submitRequest = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("VoiceInteractor__submitRequest")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean submitRequest(android.app.VoiceInteractor.Request request)
  bool submitRequest(VoiceInteractor_Request request) =>
      _submitRequest(reference, request.reference).boolean;

  static final _submitRequest1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("VoiceInteractor__submitRequest1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean submitRequest(android.app.VoiceInteractor.Request request, java.lang.String name)
  ///
  /// Submit a new Request to the voice interaction service.  The request must be
  /// one of the available subclasses -- ConfirmationRequest, PickOptionRequest,
  /// CompleteVoiceRequest, AbortVoiceRequest, or CommandRequest.
  ///@param request The desired request to submit.
  ///@param name An optional name for this request, or null. This can be used later with
  /// \#getActiveRequests and \#getActiveRequest to find the request.
  ///@return Returns true of the request was successfully submitted, else false.
  bool submitRequest1(VoiceInteractor_Request request, jni.JniString name) =>
      _submitRequest1(reference, request.reference, name.reference).boolean;

  static final _getActiveRequests = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("VoiceInteractor__getActiveRequests")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.VoiceInteractor.Request[] getActiveRequests()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return all currently active requests.
  jni.JniObject getActiveRequests() =>
      jni.JniObject.fromRef(_getActiveRequests(reference).object);

  static final _getActiveRequest = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("VoiceInteractor__getActiveRequest")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.VoiceInteractor.Request getActiveRequest(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return any currently active request that was submitted with the given name.
  ///@param name The name used to submit the request, as per
  /// \#submitRequest(android.app.VoiceInteractor.Request, String).
  ///@return Returns the active request with that name, or null if there was none.
  VoiceInteractor_Request getActiveRequest(jni.JniString name) =>
      VoiceInteractor_Request.fromRef(
          _getActiveRequest(reference, name.reference).object);

  static final _supportsCommands = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("VoiceInteractor__supportsCommands")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean[] supportsCommands(java.lang.String[] commands)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Queries the supported commands available from the VoiceInteractionService.
  /// The command is a string that describes the generic operation to be performed.
  /// An example might be "org.example.commands.PICK_DATE" to ask the user to pick
  /// a date.  (Note: This is not an actual working example.)
  ///@param commands The array of commands to query for support.
  ///@return Array of booleans indicating whether each command is supported or not.
  jni.JniObject supportsCommands(jni.JniObject commands) =>
      jni.JniObject.fromRef(
          _supportsCommands(reference, commands.reference).object);
}

/// from: android.app.VoiceInteractor$Request
///
/// Base class for voice interaction requests that can be submitted to the interactor.
/// Do not instantiate this directly -- instead, use the appropriate subclass.
class VoiceInteractor_Request extends jni.JniObject {
  VoiceInteractor_Request.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "VoiceInteractor_Request__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  VoiceInteractor_Request() : super.fromRef(_ctor().object);

  static final _getName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("VoiceInteractor_Request__getName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the name this request was submitted through
  /// \#submitRequest(android.app.VoiceInteractor.Request, String).
  jni.JniString getName() => jni.JniString.fromRef(_getName(reference).object);

  static final _cancel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("VoiceInteractor_Request__cancel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void cancel()
  ///
  /// Cancel this active request.
  void cancel() => _cancel(reference).check();

  static final _getContext = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_Request__getContext")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Context getContext()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the current Context this request is associated with.  May change
  /// if the activity hosting it goes through a configuration change.
  content_.Context getContext() =>
      content_.Context.fromRef(_getContext(reference).object);

  static final _getActivity = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_Request__getActivity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.Activity getActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the current Activity this request is associated with.  Will change
  /// if the activity is restarted such as through a configuration change.
  Activity getActivity() => Activity.fromRef(_getActivity(reference).object);

  static final _onCancel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("VoiceInteractor_Request__onCancel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onCancel()
  ///
  /// Report from voice interaction service: this operation has been canceled, typically
  /// as a completion of a previous call to \#cancel or when the user explicitly
  /// cancelled.
  void onCancel() => _onCancel(reference).check();

  static final _onAttached = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_Request__onAttached")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onAttached(android.app.Activity activity)
  ///
  /// The request is now attached to an activity, or being re-attached to a new activity
  /// after a configuration change.
  void onAttached(Activity activity) =>
      _onAttached(reference, activity.reference).check();

  static final _onDetached = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_Request__onDetached")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void onDetached()
  ///
  /// The request is being detached from an activity.
  void onDetached() => _onDetached(reference).check();

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("VoiceInteractor_Request__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);
}

/// from: android.app.VoiceInteractor$Prompt
///
/// A set of voice prompts to use with the voice interaction system to confirm an action, select
/// an option, or do similar operations. Multiple voice prompts may be provided for variety. A
/// visual prompt must be provided, which might not match the spoken version. For example, the
/// confirmation "Are you sure you want to purchase this item?" might use a visual label like
/// "Purchase item".
class VoiceInteractor_Prompt extends jni.JniObject {
  VoiceInteractor_Prompt.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_VoiceInteractor_Prompt__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.VoiceInteractor.Prompt> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("VoiceInteractor_Prompt__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.CharSequence[] voicePrompts, java.lang.CharSequence visualPrompt)
  ///
  /// Constructs a prompt set.
  ///@param voicePrompts An array of one or more voice prompts. Must not be empty or null.
  /// This value must never be {@code null}.
  ///@param visualPrompt A prompt to display on the screen. Must not be null.
  ///
  /// This value must never be {@code null}.
  VoiceInteractor_Prompt(jni.JniObject voicePrompts, jni.JniObject visualPrompt)
      : super.fromRef(
            _ctor(voicePrompts.reference, visualPrompt.reference).object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("VoiceInteractor_Prompt__ctor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.CharSequence prompt)
  ///
  /// Constructs a prompt set with single prompt used for all interactions. This is most useful
  /// in test apps. Non-trivial apps should prefer the detailed constructor.
  ///@param prompt This value must never be {@code null}.
  VoiceInteractor_Prompt.ctor1(jni.JniObject prompt)
      : super.fromRef(_ctor1(prompt.reference).object);

  static final _getVoicePromptAt = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("VoiceInteractor_Prompt__getVoicePromptAt")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.CharSequence getVoicePromptAt(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a prompt to use for voice interactions.
  ///@return This value will never be {@code null}.
  jni.JniObject getVoicePromptAt(int index) =>
      jni.JniObject.fromRef(_getVoicePromptAt(reference, index).object);

  static final _countVoicePrompts = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_Prompt__countVoicePrompts")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int countVoicePrompts()
  ///
  /// Returns the number of different voice prompts.
  int countVoicePrompts() => _countVoicePrompts(reference).integer;

  static final _getVisualPrompt = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_Prompt__getVisualPrompt")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getVisualPrompt()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the prompt to use for visual display.
  ///@return This value will never be {@code null}.
  jni.JniObject getVisualPrompt() =>
      jni.JniObject.fromRef(_getVisualPrompt(reference).object);

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("VoiceInteractor_Prompt__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_Prompt__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("VoiceInteractor_Prompt__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();
}

/// from: android.app.VoiceInteractor$PickOptionRequest
///
/// Select a single option from multiple potential options with the user via the trusted system
/// VoiceInteractionService. Typically, the application would present this visually as
/// a list view to allow selecting the option by touch.
/// The result of the confirmation will be returned through an asynchronous call to
/// either \#onPickOptionResult or \#onCancel() - these methods should
/// be overridden to define the application specific behavior.
class VoiceInteractor_PickOptionRequest extends VoiceInteractor_Request {
  VoiceInteractor_PickOptionRequest.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_PickOptionRequest__ctor1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.VoiceInteractor.Prompt prompt, android.app.VoiceInteractor.PickOptionRequest.Option[] options, android.os.Bundle extras)
  ///
  /// Create a new pick option request.
  ///@param prompt Optional question to be asked of the user when the options are
  ///     presented or null if nothing should be asked.
  /// This value may be {@code null}.
  ///@param options The set of Options the user is selecting from.
  ///@param extras Additional optional information or null.
  ///
  /// This value may be {@code null}.
  VoiceInteractor_PickOptionRequest.ctor1(
      VoiceInteractor_Prompt prompt, jni.JniObject options, os_.Bundle extras)
      : super.fromRef(
            _ctor1(prompt.reference, options.reference, extras.reference)
                .object);

  static final _onPickOptionResult = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_PickOptionRequest__onPickOptionResult")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onPickOptionResult(boolean finished, android.app.VoiceInteractor.PickOptionRequest.Option[] selections, android.os.Bundle result)
  ///
  /// Called when a single option is confirmed or narrowed to one of several options. Override
  /// this method to define the behavior when the user selects an option or narrows down the
  /// set of options.
  ///@param finished True if the voice interaction has finished making a selection, in
  ///     which case {@code selections} contains the final result.  If false, this request is
  ///     still active and you will continue to get calls on it.
  ///@param selections Either a single Option or one of several Options the
  ///     user has narrowed the choices down to.
  ///@param result Additional optional information.
  void onPickOptionResult(
          bool finished, jni.JniObject selections, os_.Bundle result) =>
      _onPickOptionResult(reference, finished ? 1 : 0, selections.reference,
              result.reference)
          .check();
}

/// from: android.app.VoiceInteractor$PickOptionRequest$Option
///
/// Represents a single option that the user may select using their voice. The
/// \#getIndex() method should be used as a unique ID to identify the option
/// when it is returned from the voice interactor.
class VoiceInteractor_PickOptionRequest_Option extends jni.JniObject {
  VoiceInteractor_PickOptionRequest_Option.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_VoiceInteractor_PickOptionRequest_Option__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.VoiceInteractor.PickOptionRequest.Option> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("VoiceInteractor_PickOptionRequest_Option__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.CharSequence label, int index)
  ///
  /// Creates an option that a user can select with their voice by matching the label
  /// or one of several synonyms.
  ///@param label The label that will both be matched against what the user speaks
  ///     and displayed visually.
  ///@param index The location of this option within the overall set of options.
  ///     Can be used to help identify the option when it is returned from the
  ///     voice interactor.
  VoiceInteractor_PickOptionRequest_Option(jni.JniObject label, int index)
      : super.fromRef(_ctor(label.reference, index).object);

  static final _addSynonym = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_PickOptionRequest_Option__addSynonym")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.VoiceInteractor.PickOptionRequest.Option addSynonym(java.lang.CharSequence synonym)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Add a synonym term to the option to indicate an alternative way the content
  /// may be matched.
  ///@param synonym The synonym that will be matched against what the user speaks,
  ///     but not displayed.
  VoiceInteractor_PickOptionRequest_Option addSynonym(jni.JniObject synonym) =>
      VoiceInteractor_PickOptionRequest_Option.fromRef(
          _addSynonym(reference, synonym.reference).object);

  static final _getLabel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_PickOptionRequest_Option__getLabel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence getLabel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getLabel() =>
      jni.JniObject.fromRef(_getLabel(reference).object);

  static final _getIndex = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_PickOptionRequest_Option__getIndex")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getIndex()
  ///
  /// Return the index that was supplied in the constructor.
  /// If the option was constructed without an index, -1 is returned.
  int getIndex() => _getIndex(reference).integer;

  static final _countSynonyms = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_PickOptionRequest_Option__countSynonyms")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int countSynonyms()
  int countSynonyms() => _countSynonyms(reference).integer;

  static final _getSynonymAt = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "VoiceInteractor_PickOptionRequest_Option__getSynonymAt")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public java.lang.CharSequence getSynonymAt(int index)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniObject getSynonymAt(int index) =>
      jni.JniObject.fromRef(_getSynonymAt(reference, index).object);

  static final _setExtras = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_PickOptionRequest_Option__setExtras")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setExtras(android.os.Bundle extras)
  ///
  /// Set optional extra information associated with this option.  Note that this
  /// method takes ownership of the supplied extras Bundle.
  void setExtras(os_.Bundle extras) =>
      _setExtras(reference, extras.reference).check();

  static final _getExtras = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_PickOptionRequest_Option__getExtras")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.os.Bundle getExtras()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return any optional extras information associated with this option, or null
  /// if there is none.  Note that this method returns a reference to the actual
  /// extras Bundle in the option, so modifications to it will directly modify the
  /// extras in the option.
  os_.Bundle getExtras() => os_.Bundle.fromRef(_getExtras(reference).object);

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_PickOptionRequest_Option__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "VoiceInteractor_PickOptionRequest_Option__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();
}

/// from: android.app.VoiceInteractor$ConfirmationRequest
///
/// Confirms an operation with the user via the trusted system
/// VoiceInteractionService.  This allows an Activity to complete an unsafe operation that
/// would require the user to touch the screen when voice interaction mode is not enabled.
/// The result of the confirmation will be returned through an asynchronous call to
/// either \#onConfirmationResult(boolean, android.os.Bundle) or
/// \#onCancel() - these methods should be overridden to define the application specific
///  behavior.
///
/// In some cases this may be a simple yes / no confirmation or the confirmation could
/// include context information about how the action will be completed
/// (e.g. booking a cab might include details about how long until the cab arrives)
/// so the user can give a confirmation.
class VoiceInteractor_ConfirmationRequest extends VoiceInteractor_Request {
  VoiceInteractor_ConfirmationRequest.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_ConfirmationRequest__ctor1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.VoiceInteractor.Prompt prompt, android.os.Bundle extras)
  ///
  /// Create a new confirmation request.
  ///@param prompt Optional confirmation to speak to the user or null if nothing
  ///     should be spoken.
  /// This value may be {@code null}.
  ///@param extras Additional optional information or null.
  ///
  /// This value may be {@code null}.
  VoiceInteractor_ConfirmationRequest.ctor1(
      VoiceInteractor_Prompt prompt, os_.Bundle extras)
      : super.fromRef(_ctor1(prompt.reference, extras.reference).object);

  static final _onConfirmationResult = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                      ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_ConfirmationRequest__onConfirmationResult")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onConfirmationResult(boolean confirmed, android.os.Bundle result)
  ///
  /// Handle the confirmation result. Override this method to define
  /// the behavior when the user confirms or rejects the operation.
  ///@param confirmed Whether the user confirmed or rejected the operation.
  ///@param result Additional result information or null.
  void onConfirmationResult(bool confirmed, os_.Bundle result) =>
      _onConfirmationResult(reference, confirmed ? 1 : 0, result.reference)
          .check();
}

/// from: android.app.VoiceInteractor$CompleteVoiceRequest
///
/// Reports that the current interaction was successfully completed with voice, so the
/// application can report the final status to the user. When the response comes back, the
/// voice system has handled the request and is ready to switch; at that point the
/// application can start a new non-voice activity or finish.  Be sure when starting the new
/// activity to use android.content.Intent\#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK to keep the new activity out of the current voice
/// interaction task.
class VoiceInteractor_CompleteVoiceRequest extends VoiceInteractor_Request {
  VoiceInteractor_CompleteVoiceRequest.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_CompleteVoiceRequest__ctor1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.VoiceInteractor.Prompt prompt, android.os.Bundle extras)
  ///
  /// Create a new completed voice interaction request.
  ///@param prompt Optional message to speak to the user about the completion status of
  ///     the task or null if nothing should be spoken.
  /// This value may be {@code null}.
  ///@param extras Additional optional information or null.
  ///
  /// This value may be {@code null}.
  VoiceInteractor_CompleteVoiceRequest.ctor1(
      VoiceInteractor_Prompt prompt, os_.Bundle extras)
      : super.fromRef(_ctor1(prompt.reference, extras.reference).object);

  static final _onCompleteResult = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_CompleteVoiceRequest__onCompleteResult")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCompleteResult(android.os.Bundle result)
  void onCompleteResult(os_.Bundle result) =>
      _onCompleteResult(reference, result.reference).check();
}

/// from: android.app.VoiceInteractor$CommandRequest
///
/// Execute a vendor-specific command using the trusted system VoiceInteractionService.
/// This allows an Activity to request additional information from the user needed to
/// complete an action (e.g. booking a table might have several possible times that the
/// user could select from or an app might need the user to agree to a terms of service).
/// The result of the confirmation will be returned through an asynchronous call to
/// either \#onCommandResult(boolean, android.os.Bundle) or
/// \#onCancel().
///
/// The command is a string that describes the generic operation to be performed.
/// The command will determine how the properties in extras are interpreted and the set of
/// available commands is expected to grow over time.  An example might be
/// "com.google.voice.commands.REQUEST_NUMBER_BAGS" to request the number of bags as part of
/// airline check-in.  (This is not an actual working example.)
class VoiceInteractor_CommandRequest extends VoiceInteractor_Request {
  VoiceInteractor_CommandRequest.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_CommandRequest__ctor1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String command, android.os.Bundle args)
  ///
  /// Create a new generic command request.
  ///@param command The desired command to perform.
  ///@param args Additional arguments to control execution of the command.
  VoiceInteractor_CommandRequest.ctor1(jni.JniString command, os_.Bundle args)
      : super.fromRef(_ctor1(command.reference, args.reference).object);

  static final _onCommandResult = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Uint8,
                      ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_CommandRequest__onCommandResult")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onCommandResult(boolean isCompleted, android.os.Bundle result)
  ///
  /// Results for CommandRequest can be returned in partial chunks.
  /// The isCompleted is set to true iff all results have been returned, indicating the
  /// CommandRequest has completed.
  void onCommandResult(bool isCompleted, os_.Bundle result) =>
      _onCommandResult(reference, isCompleted ? 1 : 0, result.reference)
          .check();
}

/// from: android.app.VoiceInteractor$AbortVoiceRequest
///
/// Reports that the current interaction can not be complete with voice, so the
/// application will need to switch to a traditional input UI.  Applications should
/// only use this when they need to completely bail out of the voice interaction
/// and switch to a traditional UI.  When the response comes back, the voice
/// system has handled the request and is ready to switch; at that point the application
/// can start a new non-voice activity.  Be sure when starting the new activity
/// to use android.content.Intent\#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK to keep the new activity out of the current voice
/// interaction task.
class VoiceInteractor_AbortVoiceRequest extends VoiceInteractor_Request {
  VoiceInteractor_AbortVoiceRequest.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_AbortVoiceRequest__ctor1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.VoiceInteractor.Prompt prompt, android.os.Bundle extras)
  ///
  /// Create a new voice abort request.
  ///@param prompt Optional message to speak to the user indicating why the task could
  ///     not be completed by voice or null if nothing should be spoken.
  /// This value may be {@code null}.
  ///@param extras Additional optional information or null.
  ///
  /// This value may be {@code null}.
  VoiceInteractor_AbortVoiceRequest.ctor1(
      VoiceInteractor_Prompt prompt, os_.Bundle extras)
      : super.fromRef(_ctor1(prompt.reference, extras.reference).object);

  static final _onAbortResult = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "VoiceInteractor_AbortVoiceRequest__onAbortResult")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onAbortResult(android.os.Bundle result)
  void onAbortResult(os_.Bundle result) =>
      _onAbortResult(reference, result.reference).check();
}

/// from: android.app.WallpaperColors
///
/// Provides information about the colors of a wallpaper.
///
/// Exposes the 3 most visually representative colors of a wallpaper. Can be either
/// WallpaperColors\#getPrimaryColor(), WallpaperColors\#getSecondaryColor()
/// or WallpaperColors\#getTertiaryColor().
class WallpaperColors extends jni.JniObject {
  WallpaperColors.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_WallpaperColors__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.WallpaperColors> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperColors__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.os.Parcel parcel)
  WallpaperColors(os_.Parcel parcel)
      : super.fromRef(_ctor(parcel.reference).object);

  static final _ctor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("WallpaperColors__ctor1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.graphics.Color primaryColor, android.graphics.Color secondaryColor, android.graphics.Color tertiaryColor)
  ///
  /// Constructs a new object from three colors.
  ///@param primaryColor Primary color.
  /// This value must never be {@code null}.
  ///@param secondaryColor Secondary color.
  /// This value may be {@code null}.
  ///@param tertiaryColor Tertiary color.
  /// This value may be {@code null}.
  ///@see WallpaperColors\#fromBitmap(Bitmap)
  ///@see WallpaperColors\#fromDrawable(Drawable)
  WallpaperColors.ctor1(jni.JniObject primaryColor,
      jni.JniObject secondaryColor, jni.JniObject tertiaryColor)
      : super.fromRef(_ctor1(primaryColor.reference, secondaryColor.reference,
                tertiaryColor.reference)
            .object);

  static final _fromDrawable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperColors__fromDrawable")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.WallpaperColors fromDrawable(android.graphics.drawable.Drawable drawable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs WallpaperColors from a drawable.
  ///
  /// Main colors will be extracted from the drawable.
  ///@param drawable Source where to extract from.
  static WallpaperColors fromDrawable(jni.JniObject drawable) =>
      WallpaperColors.fromRef(_fromDrawable(drawable.reference).object);

  static final _fromBitmap = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperColors__fromBitmap")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.WallpaperColors fromBitmap(android.graphics.Bitmap bitmap)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Constructs WallpaperColors from a bitmap.
  ///
  /// Main colors will be extracted from the bitmap.
  ///@param bitmap Source where to extract from.
  ///
  /// This value must never be {@code null}.
  static WallpaperColors fromBitmap(jni.JniObject bitmap) =>
      WallpaperColors.fromRef(_fromBitmap(bitmap.reference).object);

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperColors__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("WallpaperColors__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _getPrimaryColor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperColors__getPrimaryColor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Color getPrimaryColor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the most visually representative color of the wallpaper.
  /// "Visually representative" means easily noticeable in the image,
  /// probably happening at high frequency.
  ///@return A color.
  ///
  /// This value will never be {@code null}.
  jni.JniObject getPrimaryColor() =>
      jni.JniObject.fromRef(_getPrimaryColor(reference).object);

  static final _getSecondaryColor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperColors__getSecondaryColor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Color getSecondaryColor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the second most preeminent color of the wallpaper. Can be null.
  ///@return A color, may be null.
  jni.JniObject getSecondaryColor() =>
      jni.JniObject.fromRef(_getSecondaryColor(reference).object);

  static final _getTertiaryColor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperColors__getTertiaryColor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Color getTertiaryColor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the third most preeminent color of the wallpaper. Can be null.
  ///@return A color, may be null.
  jni.JniObject getTertiaryColor() =>
      jni.JniObject.fromRef(_getTertiaryColor(reference).object);

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("WallpaperColors__equals1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object o)
  bool equals1(jni.JniObject o) => _equals1(reference, o.reference).boolean;

  static final _hashCode1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperColors__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() => _hashCode1(reference).integer;

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperColors__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);
}

/// from: android.app.WallpaperInfo
///
/// This class is used to specify meta information of a wallpaper service.
class WallpaperInfo extends jni.JniObject {
  WallpaperInfo.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_WallpaperInfo__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.WallpaperInfo> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Used to make this class parcelable.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("WallpaperInfo__ctor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.content.Context context, android.content.pm.ResolveInfo service)
  ///
  /// Constructor.
  ///@param context The Context in which we are parsing the wallpaper.
  ///@param service The ResolveInfo returned from the package manager about
  /// this wallpaper's component.
  WallpaperInfo(content_.Context context, pm_.ResolveInfo service)
      : super.fromRef(_ctor(context.reference, service.reference).object);

  static final _getPackageName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperInfo__getPackageName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPackageName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the .apk package that implements this wallpaper.
  jni.JniString getPackageName() =>
      jni.JniString.fromRef(_getPackageName(reference).object);

  static final _getServiceName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperInfo__getServiceName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getServiceName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the class name of the service component that implements
  /// this wallpaper.
  jni.JniString getServiceName() =>
      jni.JniString.fromRef(_getServiceName(reference).object);

  static final _getServiceInfo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperInfo__getServiceInfo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.pm.ServiceInfo getServiceInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the raw information about the Service implementing this
  /// wallpaper.  Do not modify the returned object.
  pm_.ServiceInfo getServiceInfo() =>
      pm_.ServiceInfo.fromRef(_getServiceInfo(reference).object);

  static final _getComponent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperInfo__getComponent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.ComponentName getComponent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the component of the service that implements this wallpaper.
  content_.ComponentName getComponent() =>
      content_.ComponentName.fromRef(_getComponent(reference).object);

  static final _loadLabel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("WallpaperInfo__loadLabel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence loadLabel(android.content.pm.PackageManager pm)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Load the user-displayed label for this wallpaper.
  ///@param pm Supply a PackageManager used to load the wallpaper's
  /// resources.
  jni.JniObject loadLabel(pm_.PackageManager pm) =>
      jni.JniObject.fromRef(_loadLabel(reference, pm.reference).object);

  static final _loadIcon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("WallpaperInfo__loadIcon")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable loadIcon(android.content.pm.PackageManager pm)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Load the user-displayed icon for this wallpaper.
  ///@param pm Supply a PackageManager used to load the wallpaper's
  /// resources.
  jni.JniObject loadIcon(pm_.PackageManager pm) =>
      jni.JniObject.fromRef(_loadIcon(reference, pm.reference).object);

  static final _loadThumbnail = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("WallpaperInfo__loadThumbnail")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable loadThumbnail(android.content.pm.PackageManager pm)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Load the thumbnail image for this wallpaper.
  ///@param pm Supply a PackageManager used to load the wallpaper's
  /// resources.
  jni.JniObject loadThumbnail(pm_.PackageManager pm) =>
      jni.JniObject.fromRef(_loadThumbnail(reference, pm.reference).object);

  static final _loadAuthor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("WallpaperInfo__loadAuthor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence loadAuthor(android.content.pm.PackageManager pm)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a string indicating the author(s) of this wallpaper.
  jni.JniObject loadAuthor(pm_.PackageManager pm) =>
      jni.JniObject.fromRef(_loadAuthor(reference, pm.reference).object);

  static final _loadDescription = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("WallpaperInfo__loadDescription")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence loadDescription(android.content.pm.PackageManager pm)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return a brief summary of this wallpaper's behavior.
  jni.JniObject loadDescription(pm_.PackageManager pm) =>
      jni.JniObject.fromRef(_loadDescription(reference, pm.reference).object);

  static final _loadContextUri = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("WallpaperInfo__loadContextUri")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri loadContextUri(android.content.pm.PackageManager pm)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an URI that specifies a link for further context about this wallpaper.
  ///@param pm An instance of PackageManager to retrieve the URI.
  ///@return The URI.
  jni.JniObject loadContextUri(pm_.PackageManager pm) =>
      jni.JniObject.fromRef(_loadContextUri(reference, pm.reference).object);

  static final _loadContextDescription = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "WallpaperInfo__loadContextDescription")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.CharSequence loadContextDescription(android.content.pm.PackageManager pm)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieves a title of the URI that specifies a link for further context about this wallpaper.
  ///@param pm An instance of PackageManager to retrieve the title.
  ///@return The title.
  jni.JniObject loadContextDescription(pm_.PackageManager pm) =>
      jni.JniObject.fromRef(
          _loadContextDescription(reference, pm.reference).object);

  static final _getShowMetadataInPreview = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "WallpaperInfo__getShowMetadataInPreview")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getShowMetadataInPreview()
  ///
  /// Queries whether any metadata should be shown when previewing the wallpaper. If this value is
  /// set to true, any component that shows a preview of this live wallpaper should also show
  /// accompanying information like \#loadLabel,
  /// \#loadDescription, \#loadAuthor and
  /// \#loadContextDescription(PackageManager), so the user gets to know further information
  /// about this wallpaper.
  ///@return Whether any metadata should be shown when previewing the wallpaper.
  bool getShowMetadataInPreview() =>
      _getShowMetadataInPreview(reference).boolean;

  static final _getSettingsActivity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperInfo__getSettingsActivity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSettingsActivity()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return the class name of an activity that provides a settings UI for
  /// the wallpaper.  You can launch this activity be starting it with
  /// an android.content.Intent whose action is MAIN and with an
  /// explicit android.content.ComponentName
  /// composed of \#getPackageName and the class name returned here.
  ///
  /// A null will be returned if there is no settings activity associated
  /// with the wallpaper.
  jni.JniString getSettingsActivity() =>
      jni.JniString.fromRef(_getSettingsActivity(reference).object);

  static final _dump = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("WallpaperInfo__dump")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void dump(android.util.Printer pw, java.lang.String prefix)
  void dump(jni.JniObject pw, jni.JniString prefix) =>
      _dump(reference, pw.reference, prefix.reference).check();

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperInfo__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString toString1() =>
      jni.JniString.fromRef(_toString1(reference).object);

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("WallpaperInfo__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  ///
  /// Used to package this object into a Parcel.
  ///@param dest The Parcel to be written.
  ///@param flags The flags used for parceling.
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperInfo__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;
}

/// from: android.app.WallpaperManager
///
/// Provides access to the system wallpaper. With WallpaperManager, you can
/// get the current wallpaper, get the desired dimensions for the wallpaper, set
/// the wallpaper, and more.
///
///  An app can check whether wallpapers are supported for the current user, by calling
/// \#isWallpaperSupported(), and whether setting of wallpapers is allowed, by calling
/// \#isSetWallpaperAllowed().
class WallpaperManager extends jni.JniObject {
  WallpaperManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final java.lang.String ACTION_CHANGE_LIVE_WALLPAPER
  ///
  /// Directly launch live wallpaper preview, allowing the user to immediately
  /// confirm to switch to a specific live wallpaper.  You must specify
  /// \#EXTRA_LIVE_WALLPAPER_COMPONENT with the ComponentName of
  /// a live wallpaper component that is to be shown.
  static const ACTION_CHANGE_LIVE_WALLPAPER =
      "android.service.wallpaper.CHANGE_LIVE_WALLPAPER";

  /// from: static public final java.lang.String ACTION_CROP_AND_SET_WALLPAPER
  ///
  /// Activity Action: Show settings for choosing wallpaper. Do not use directly to construct
  /// an intent; instead, use \#getCropAndSetWallpaperIntent.
  /// Input:  Intent\#getData is the URI of the image to crop and set as wallpaper.
  /// Output: RESULT_OK if user decided to crop/set the wallpaper, RESULT_CANCEL otherwise
  /// Activities that support this intent should specify a MIME filter of "image/*"
  static const ACTION_CROP_AND_SET_WALLPAPER =
      "android.service.wallpaper.CROP_AND_SET_WALLPAPER";

  /// from: static public final java.lang.String ACTION_LIVE_WALLPAPER_CHOOSER
  ///
  /// Launch an activity for the user to pick the current global live
  /// wallpaper.
  static const ACTION_LIVE_WALLPAPER_CHOOSER =
      "android.service.wallpaper.LIVE_WALLPAPER_CHOOSER";

  /// from: static public final java.lang.String COMMAND_DROP
  ///
  /// Command for \#sendWallpaperCommand: reported by the wallpaper
  /// host when the user drops an object into an area of the host.  The x
  /// and y arguments are the location of the drop.
  static const COMMAND_DROP = "android.home.drop";

  /// from: static public final java.lang.String COMMAND_SECONDARY_TAP
  ///
  /// Command for \#sendWallpaperCommand: reported by the wallpaper
  /// host when the user releases a secondary pointer on an empty area
  /// (not performing an action in the host).  The x and y arguments are
  /// the location of the secondary tap in screen coordinates.
  static const COMMAND_SECONDARY_TAP = "android.wallpaper.secondaryTap";

  /// from: static public final java.lang.String COMMAND_TAP
  ///
  /// Command for \#sendWallpaperCommand: reported by the wallpaper
  /// host when the user taps on an empty area (not performing an action
  /// in the host).  The x and y arguments are the location of the tap in
  /// screen coordinates.
  static const COMMAND_TAP = "android.wallpaper.tap";

  /// from: static public final java.lang.String EXTRA_LIVE_WALLPAPER_COMPONENT
  ///
  /// Extra in \#ACTION_CHANGE_LIVE_WALLPAPER that specifies the
  /// ComponentName of a live wallpaper that should be shown as a preview,
  /// for the user to confirm.
  static const EXTRA_LIVE_WALLPAPER_COMPONENT =
      "android.service.wallpaper.extra.LIVE_WALLPAPER_COMPONENT";

  /// from: static public final int FLAG_LOCK
  ///
  /// Flag: set or retrieve the lock-screen-specific wallpaper.
  static const FLAG_LOCK = 2;

  /// from: static public final int FLAG_SYSTEM
  ///
  /// Flag: set or retrieve the general system wallpaper.
  static const FLAG_SYSTEM = 1;

  /// from: static public final java.lang.String WALLPAPER_PREVIEW_META_DATA
  ///
  /// Manifest entry for activities that respond to Intent\#ACTION_SET_WALLPAPER
  /// which allows them to provide a custom large icon associated with this action.
  static const WALLPAPER_PREVIEW_META_DATA = "android.wallpaper.preview";

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "WallpaperManager__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  WallpaperManager() : super.fromRef(_ctor().object);

  static final _getInstance = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperManager__getInstance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.app.WallpaperManager getInstance(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve a WallpaperManager associated with the given Context.
  static WallpaperManager getInstance(content_.Context context) =>
      WallpaperManager.fromRef(_getInstance(context.reference).object);

  static final _getDrawable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperManager__getDrawable")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable getDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the current system wallpaper; if
  /// no wallpaper is set, the system built-in static wallpaper is returned.
  /// This is returned as an
  /// abstract Drawable that you can install in a View to display whatever
  /// wallpaper the user has currently set.
  ///
  /// This method can return null if there is no system wallpaper available, if
  /// wallpapers are not supported in the current user, or if the calling app is not
  /// permitted to access the system wallpaper.
  ///@return Returns a Drawable object that will draw the system wallpaper,
  ///     or {@code null} if no system wallpaper exists or if the calling application
  ///     is not able to access the wallpaper.
  jni.JniObject getDrawable() =>
      jni.JniObject.fromRef(_getDrawable(reference).object);

  static final _getBuiltInDrawable = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "WallpaperManager__getBuiltInDrawable")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable getBuiltInDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtain a drawable for the built-in static system wallpaper.
  jni.JniObject getBuiltInDrawable() =>
      jni.JniObject.fromRef(_getBuiltInDrawable(reference).object);

  static final _getBuiltInDrawable1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("WallpaperManager__getBuiltInDrawable1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.drawable.Drawable getBuiltInDrawable(int which)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtain a drawable for the specified built-in static system wallpaper.
  ///@param which The {@code FLAG_*} identifier of a valid wallpaper type.  Throws
  ///     IllegalArgumentException if an invalid wallpaper is requested.
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@return A Drawable presenting the specified wallpaper image, or {@code null}
  ///     if no built-in default image for that wallpaper type exists.
  jni.JniObject getBuiltInDrawable1(int which) =>
      jni.JniObject.fromRef(_getBuiltInDrawable1(reference, which).object);

  static final _getBuiltInDrawable2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Uint8,
                  ffi.Float,
                  ffi.Float)>>("WallpaperManager__getBuiltInDrawable2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, int, double, double)>();

  /// from: public android.graphics.drawable.Drawable getBuiltInDrawable(int outWidth, int outHeight, boolean scaleToFit, float horizontalAlignment, float verticalAlignment)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a drawable for the system built-in static wallpaper. Based on the parameters, the
  /// drawable can be cropped and scaled
  ///@param outWidth The width of the returned drawable
  ///@param outWidth The height of the returned drawable
  ///@param scaleToFit If true, scale the wallpaper down rather than just cropping it
  ///@param horizontalAlignment A float value between 0 and 1 specifying where to crop the image;
  ///        0 for left-aligned, 0.5 for horizontal center-aligned, and 1 for right-aligned
  ///@param verticalAlignment A float value between 0 and 1 specifying where to crop the image;
  ///        0 for top-aligned, 0.5 for vertical center-aligned, and 1 for bottom-aligned
  ///@return A Drawable presenting the built-in default system wallpaper image,
  ///        or {@code null} if no such default image is defined on this device.
  jni.JniObject getBuiltInDrawable2(
          int outWidth,
          int outHeight,
          bool scaleToFit,
          double horizontalAlignment,
          double verticalAlignment) =>
      jni.JniObject.fromRef(_getBuiltInDrawable2(reference, outWidth, outHeight,
              scaleToFit ? 1 : 0, horizontalAlignment, verticalAlignment)
          .object);

  static final _getBuiltInDrawable3 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Uint8,
                  ffi.Float,
                  ffi.Float,
                  ffi.Int32)>>("WallpaperManager__getBuiltInDrawable3")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, int, double, double, int)>();

  /// from: public android.graphics.drawable.Drawable getBuiltInDrawable(int outWidth, int outHeight, boolean scaleToFit, float horizontalAlignment, float verticalAlignment, int which)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a drawable for the built-in static wallpaper of the specified type.  Based on the
  /// parameters, the drawable can be cropped and scaled.
  ///@param outWidth The width of the returned drawable
  ///@param outWidth The height of the returned drawable
  ///@param scaleToFit If true, scale the wallpaper down rather than just cropping it
  ///@param horizontalAlignment A float value between 0 and 1 specifying where to crop the image;
  ///        0 for left-aligned, 0.5 for horizontal center-aligned, and 1 for right-aligned
  ///@param verticalAlignment A float value between 0 and 1 specifying where to crop the image;
  ///        0 for top-aligned, 0.5 for vertical center-aligned, and 1 for bottom-aligned
  ///@param which The {@code FLAG_*} identifier of a valid wallpaper type.  Throws
  ///     IllegalArgumentException if an invalid wallpaper is requested.
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@return A Drawable presenting the built-in default wallpaper image of the given type,
  ///        or {@code null} if no default image of that type is defined on this device.
  jni.JniObject getBuiltInDrawable3(
          int outWidth,
          int outHeight,
          bool scaleToFit,
          double horizontalAlignment,
          double verticalAlignment,
          int which) =>
      jni.JniObject.fromRef(_getBuiltInDrawable3(reference, outWidth, outHeight,
              scaleToFit ? 1 : 0, horizontalAlignment, verticalAlignment, which)
          .object);

  static final _peekDrawable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperManager__peekDrawable")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable peekDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Retrieve the current system wallpaper; if there is no wallpaper set,
  /// a null pointer is returned. This is returned as an
  /// abstract Drawable that you can install in a View to display whatever
  /// wallpaper the user has currently set.
  ///@return Returns a Drawable object that will draw the wallpaper or a
  /// null pointer if these is none.
  jni.JniObject peekDrawable() =>
      jni.JniObject.fromRef(_peekDrawable(reference).object);

  static final _getFastDrawable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperManager__getFastDrawable")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable getFastDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#getDrawable(), but the returned Drawable has a number
  /// of limitations to reduce its overhead as much as possible. It will
  /// never scale the wallpaper (only centering it if the requested bounds
  /// do match the bitmap bounds, which should not be typical), doesn't
  /// allow setting an alpha, color filter, or other attributes, etc.  The
  /// bounds of the returned drawable will be initialized to the same bounds
  /// as the wallpaper, so normally you will not need to touch it.  The
  /// drawable also assumes that it will be used in a context running in
  /// the same density as the screen (not in density compatibility mode).
  ///
  /// Requires android.Manifest.permission\#READ_EXTERNAL_STORAGE
  ///@return Returns a Drawable object that will draw the wallpaper.
  jni.JniObject getFastDrawable() =>
      jni.JniObject.fromRef(_getFastDrawable(reference).object);

  static final _peekFastDrawable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperManager__peekFastDrawable")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.drawable.Drawable peekFastDrawable()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#getFastDrawable(), but if there is no wallpaper set,
  /// a null pointer is returned.
  ///
  /// Requires android.Manifest.permission\#READ_EXTERNAL_STORAGE
  ///@return Returns an optimized Drawable object that will draw the
  /// wallpaper or a null pointer if these is none.
  jni.JniObject peekFastDrawable() =>
      jni.JniObject.fromRef(_peekFastDrawable(reference).object);

  static final _getWallpaperFile = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("WallpaperManager__getWallpaperFile")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.os.ParcelFileDescriptor getWallpaperFile(int which)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get an open, readable file descriptor to the given wallpaper image file.
  /// The caller is responsible for closing the file descriptor when done ingesting the file.
  ///
  /// If no lock-specific wallpaper has been configured for the given user, then
  /// this method will return {@code null} when requesting \#FLAG_LOCK rather than
  /// returning the system wallpaper's image file.
  ///
  /// Requires android.Manifest.permission\#READ_EXTERNAL_STORAGE
  ///@param which The wallpaper whose image file is to be retrieved.  Must be a single
  ///     defined kind of wallpaper, either \#FLAG_SYSTEM or
  ///     \#FLAG_LOCK.
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@return An open, readable file desriptor to the requested wallpaper image file;
  ///     or {@code null} if no such wallpaper is configured or if the calling app does
  ///     not have permission to read the current wallpaper.
  ///@see \#FLAG_LOCK
  ///@see \#FLAG_SYSTEM
  os_.ParcelFileDescriptor getWallpaperFile(int which) =>
      os_.ParcelFileDescriptor.fromRef(
          _getWallpaperFile(reference, which).object);

  static final _addOnColorsChangedListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "WallpaperManager__addOnColorsChangedListener")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void addOnColorsChangedListener(android.app.WallpaperManager.OnColorsChangedListener listener, android.os.Handler handler)
  ///
  /// Registers a listener to get notified when the wallpaper colors change.
  ///@param listener A listener to register
  /// This value must never be {@code null}.
  ///@param handler Where to call it from. Will be called from the main thread
  ///                if null.
  ///
  /// This value must never be {@code null}.
  void addOnColorsChangedListener(
          WallpaperManager_OnColorsChangedListener listener,
          os_.Handler handler) =>
      _addOnColorsChangedListener(
              reference, listener.reference, handler.reference)
          .check();

  static final _removeOnColorsChangedListener = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "WallpaperManager__removeOnColorsChangedListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void removeOnColorsChangedListener(android.app.WallpaperManager.OnColorsChangedListener callback)
  ///
  /// Stop listening to color updates.
  ///@param callback A callback to unsubscribe.
  ///
  /// This value must never be {@code null}.
  void removeOnColorsChangedListener(
          WallpaperManager_OnColorsChangedListener callback) =>
      _removeOnColorsChangedListener(reference, callback.reference).check();

  static final _getWallpaperColors = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("WallpaperManager__getWallpaperColors")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.WallpaperColors getWallpaperColors(int which)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the primary colors of a wallpaper.
  ///
  /// This method can return {@code null} when:
  /// <ul>
  /// <li>Colors are still being processed by the system.</li>
  /// <li>The user has chosen to use a live wallpaper:  live wallpapers might not
  /// implement
  /// android.service.wallpaper.WallpaperService.Engine\#onComputeColors() WallpaperService.Engine\#onComputeColors().</li>
  /// </ul>
  ///@param which Wallpaper type. Must be either \#FLAG_SYSTEM or
  ///     \#FLAG_LOCK.
  ///@return Current WallpaperColors or null if colors are unknown.
  ///@see \#addOnColorsChangedListener(OnColorsChangedListener, Handler)
  WallpaperColors getWallpaperColors(int which) =>
      WallpaperColors.fromRef(_getWallpaperColors(reference, which).object);

  static final _forgetLoadedWallpaper = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "WallpaperManager__forgetLoadedWallpaper")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void forgetLoadedWallpaper()
  ///
  /// Remove all internal references to the last loaded wallpaper.  Useful
  /// for apps that want to reduce memory usage when they only temporarily
  /// need to have the wallpaper.  After calling, the next request for the
  /// wallpaper will require reloading it again from disk.
  void forgetLoadedWallpaper() => _forgetLoadedWallpaper(reference).check();

  static final _getWallpaperInfo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperManager__getWallpaperInfo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.WallpaperInfo getWallpaperInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// If the current wallpaper is a live wallpaper component, return the
  /// information about that wallpaper.  Otherwise, if it is a static image,
  /// simply return null.
  WallpaperInfo getWallpaperInfo() =>
      WallpaperInfo.fromRef(_getWallpaperInfo(reference).object);

  static final _getWallpaperId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("WallpaperManager__getWallpaperId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getWallpaperId(int which)
  ///
  /// Get the ID of the current wallpaper of the given kind.  If there is no
  /// such wallpaper configured, returns a negative number.
  ///
  /// Every time the wallpaper image is set, a new ID is assigned to it.
  /// This method allows the caller to determine whether the wallpaper imagery
  /// has changed, regardless of how that change happened.
  ///@param which The wallpaper whose ID is to be returned.  Must be a single
  ///     defined kind of wallpaper, either \#FLAG_SYSTEM or
  ///     \#FLAG_LOCK.
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@return The positive numeric ID of the current wallpaper of the given kind,
  ///     or a negative value if no such wallpaper is configured.
  int getWallpaperId(int which) => _getWallpaperId(reference, which).integer;

  static final _getCropAndSetWallpaperIntent = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "WallpaperManager__getCropAndSetWallpaperIntent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.Intent getCropAndSetWallpaperIntent(android.net.Uri imageUri)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets an Intent that will launch an activity that crops the given
  /// image and sets the device's wallpaper. If there is a default HOME activity
  /// that supports cropping wallpapers, it will be preferred as the default.
  /// Use this method instead of directly creating a \#ACTION_CROP_AND_SET_WALLPAPER
  /// intent.
  ///@param imageUri The image URI that will be set in the intent. The must be a content
  ///                 URI and its provider must resolve its type to "image/*"
  ///@throws IllegalArgumentException if the URI is not a content URI or its MIME type is
  ///         not "image/*"
  content_.Intent getCropAndSetWallpaperIntent(jni.JniObject imageUri) =>
      content_.Intent.fromRef(
          _getCropAndSetWallpaperIntent(reference, imageUri.reference).object);

  static final _setResource = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("WallpaperManager__setResource")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setResource(int resid)
  ///
  /// Change the current system wallpaper to the bitmap in the given resource.
  /// The resource is opened as a raw data stream and copied into the
  /// wallpaper; it must be a valid PNG or JPEG image.  On success, the intent
  /// Intent\#ACTION_WALLPAPER_CHANGED is broadcast.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param resid The resource ID of the bitmap to be used as the wallpaper image
  ///@throws IOException If an error occurs reverting to the built-in
  /// wallpaper.
  void setResource(int resid) => _setResource(reference, resid).check();

  static final _setResource1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("WallpaperManager__setResource1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int setResource(int resid, int which)
  ///
  /// Version of \#setResource(int) that allows the caller to specify which
  /// of the supported wallpaper categories to set.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param resid The resource ID of the bitmap to be used as the wallpaper image
  ///@param which Flags indicating which wallpaper(s) to configure with the new imagery
  ///
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@see \#FLAG_LOCK
  ///@see \#FLAG_SYSTEM
  ///@return An integer ID assigned to the newly active wallpaper; or zero on failure.
  ///@throws IOException
  int setResource1(int resid, int which) =>
      _setResource1(reference, resid, which).integer;

  static final _setBitmap = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("WallpaperManager__setBitmap")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setBitmap(android.graphics.Bitmap bitmap)
  ///
  /// Change the current system wallpaper to a bitmap.  The given bitmap is
  /// converted to a PNG and stored as the wallpaper.  On success, the intent
  /// Intent\#ACTION_WALLPAPER_CHANGED is broadcast.
  ///
  /// This method is equivalent to calling
  /// \#setBitmap(Bitmap, Rect, boolean) and passing {@code null} for the
  /// {@code visibleCrop} rectangle and {@code true} for the {@code allowBackup}
  /// parameter.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param bitmap The bitmap to be used as the new system wallpaper.
  ///@throws IOException If an error occurs when attempting to set the wallpaper
  ///     to the provided image.
  void setBitmap(jni.JniObject bitmap) =>
      _setBitmap(reference, bitmap.reference).check();

  static final _setBitmap1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("WallpaperManager__setBitmap1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public int setBitmap(android.graphics.Bitmap fullImage, android.graphics.Rect visibleCropHint, boolean allowBackup)
  ///
  /// Change the current system wallpaper to a bitmap, specifying a hint about
  /// which subrectangle of the full image is to be visible.  The OS will then
  /// try to best present the given portion of the full image as the static system
  /// wallpaper image.  On success, the intent
  /// Intent\#ACTION_WALLPAPER_CHANGED is broadcast.
  ///
  /// Passing {@code null} as the {@code visibleHint} parameter is equivalent to
  /// passing (0, 0, {@code fullImage.getWidth()}, {@code fullImage.getHeight()}).
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param fullImage A bitmap that will supply the wallpaper imagery.
  ///@param visibleCropHint The rectangular subregion of {@code fullImage} that should be
  ///     displayed as wallpaper.  Passing {@code null} for this parameter means that
  ///     the full image should be displayed if possible given the image's and device's
  ///     aspect ratios, etc.
  ///@param allowBackup {@code true} if the OS is permitted to back up this wallpaper
  ///     image for restore to a future device; {@code false} otherwise.
  ///@return An integer ID assigned to the newly active wallpaper; or zero on failure.
  ///@throws IOException If an error occurs when attempting to set the wallpaper
  ///     to the provided image.
  ///@throws IllegalArgumentException If the {@code visibleCropHint} rectangle is
  ///     empty or invalid.
  int setBitmap1(jni.JniObject fullImage, jni.JniObject visibleCropHint,
          bool allowBackup) =>
      _setBitmap1(reference, fullImage.reference, visibleCropHint.reference,
              allowBackup ? 1 : 0)
          .integer;

  static final _setBitmap2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Int32)>>("WallpaperManager__setBitmap2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int setBitmap(android.graphics.Bitmap fullImage, android.graphics.Rect visibleCropHint, boolean allowBackup, int which)
  ///
  /// Version of \#setBitmap(Bitmap, Rect, boolean) that allows the caller
  /// to specify which of the supported wallpaper categories to set.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param fullImage A bitmap that will supply the wallpaper imagery.
  ///@param visibleCropHint The rectangular subregion of {@code fullImage} that should be
  ///     displayed as wallpaper.  Passing {@code null} for this parameter means that
  ///     the full image should be displayed if possible given the image's and device's
  ///     aspect ratios, etc.
  ///@param allowBackup {@code true} if the OS is permitted to back up this wallpaper
  ///     image for restore to a future device; {@code false} otherwise.
  ///@param which Flags indicating which wallpaper(s) to configure with the new imagery.
  ///
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@see \#FLAG_LOCK
  ///@see \#FLAG_SYSTEM
  ///@return An integer ID assigned to the newly active wallpaper; or zero on failure.
  ///@throws IOException
  int setBitmap2(jni.JniObject fullImage, jni.JniObject visibleCropHint,
          bool allowBackup, int which) =>
      _setBitmap2(reference, fullImage.reference, visibleCropHint.reference,
              allowBackup ? 1 : 0, which)
          .integer;

  static final _setStream = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("WallpaperManager__setStream")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setStream(java.io.InputStream bitmapData)
  ///
  /// Change the current system wallpaper to a specific byte stream.  The
  /// give InputStream is copied into persistent storage and will now be
  /// used as the wallpaper.  Currently it must be either a JPEG or PNG
  /// image.  On success, the intent Intent\#ACTION_WALLPAPER_CHANGED
  /// is broadcast.
  ///
  /// This method is equivalent to calling
  /// \#setStream(InputStream, Rect, boolean) and passing {@code null} for the
  /// {@code visibleCrop} rectangle and {@code true} for the {@code allowBackup}
  /// parameter.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param bitmapData A stream containing the raw data to install as a wallpaper.  This
  ///     data can be in any format handled by BitmapRegionDecoder.
  ///@throws IOException If an error occurs when attempting to set the wallpaper
  ///     based on the provided image data.
  void setStream(jni.JniObject bitmapData) =>
      _setStream(reference, bitmapData.reference).check();

  static final _setStream1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("WallpaperManager__setStream1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public int setStream(java.io.InputStream bitmapData, android.graphics.Rect visibleCropHint, boolean allowBackup)
  ///
  /// Change the current system wallpaper to a specific byte stream, specifying a
  /// hint about which subrectangle of the full image is to be visible.  The OS will
  /// then try to best present the given portion of the full image as the static system
  /// wallpaper image.  The data from the given InputStream is copied into persistent
  /// storage and will then be used as the system wallpaper.  Currently the data must
  /// be either a JPEG or PNG image.  On success, the intent
  /// Intent\#ACTION_WALLPAPER_CHANGED is broadcast.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param bitmapData A stream containing the raw data to install as a wallpaper.  This
  ///     data can be in any format handled by BitmapRegionDecoder.
  ///@param visibleCropHint The rectangular subregion of the streamed image that should be
  ///     displayed as wallpaper.  Passing {@code null} for this parameter means that
  ///     the full image should be displayed if possible given the image's and device's
  ///     aspect ratios, etc.
  ///@param allowBackup {@code true} if the OS is permitted to back up this wallpaper
  ///     image for restore to a future device; {@code false} otherwise.
  ///@return An integer ID assigned to the newly active wallpaper; or zero on failure.
  ///@see \#getWallpaperId(int)
  ///@throws IOException If an error occurs when attempting to set the wallpaper
  ///     based on the provided image data.
  ///@throws IllegalArgumentException If the {@code visibleCropHint} rectangle is
  ///     empty or invalid.
  int setStream1(jni.JniObject bitmapData, jni.JniObject visibleCropHint,
          bool allowBackup) =>
      _setStream1(reference, bitmapData.reference, visibleCropHint.reference,
              allowBackup ? 1 : 0)
          .integer;

  static final _setStream2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Int32)>>("WallpaperManager__setStream2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int setStream(java.io.InputStream bitmapData, android.graphics.Rect visibleCropHint, boolean allowBackup, int which)
  ///
  /// Version of \#setStream(InputStream, Rect, boolean) that allows the caller
  /// to specify which of the supported wallpaper categories to set.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param bitmapData A stream containing the raw data to install as a wallpaper.  This
  ///     data can be in any format handled by BitmapRegionDecoder.
  ///@param visibleCropHint The rectangular subregion of the streamed image that should be
  ///     displayed as wallpaper.  Passing {@code null} for this parameter means that
  ///     the full image should be displayed if possible given the image's and device's
  ///     aspect ratios, etc.
  ///@param allowBackup {@code true} if the OS is permitted to back up this wallpaper
  ///     image for restore to a future device; {@code false} otherwise.
  ///@param which Flags indicating which wallpaper(s) to configure with the new imagery.
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@return An integer ID assigned to the newly active wallpaper; or zero on failure.
  ///@see \#getWallpaperId(int)
  ///@see \#FLAG_LOCK
  ///@see \#FLAG_SYSTEM
  ///@throws IOException
  int setStream2(jni.JniObject bitmapData, jni.JniObject visibleCropHint,
          bool allowBackup, int which) =>
      _setStream2(reference, bitmapData.reference, visibleCropHint.reference,
              allowBackup ? 1 : 0, which)
          .integer;

  static final _hasResourceWallpaper = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("WallpaperManager__hasResourceWallpaper")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean hasResourceWallpaper(int resid)
  ///
  /// Return whether any users are currently set to use the wallpaper
  /// with the given resource ID.  That is, their wallpaper has been
  /// set through \#setResource(int) with the same resource id.
  bool hasResourceWallpaper(int resid) =>
      _hasResourceWallpaper(reference, resid).boolean;

  static final _getDesiredMinimumWidth = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "WallpaperManager__getDesiredMinimumWidth")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getDesiredMinimumWidth()
  ///
  /// Returns the desired minimum width for the wallpaper. Callers of
  /// \#setBitmap(android.graphics.Bitmap) or
  /// \#setStream(java.io.InputStream) should check this value
  /// beforehand to make sure the supplied wallpaper respects the desired
  /// minimum width.
  ///
  /// If the returned value is <= 0, the caller should use the width of
  /// the default display instead.
  ///@return The desired minimum width for the wallpaper. This value should
  /// be honored by applications that set the wallpaper but it is not
  /// mandatory.
  int getDesiredMinimumWidth() => _getDesiredMinimumWidth(reference).integer;

  static final _getDesiredMinimumHeight = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "WallpaperManager__getDesiredMinimumHeight")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getDesiredMinimumHeight()
  ///
  /// Returns the desired minimum height for the wallpaper. Callers of
  /// \#setBitmap(android.graphics.Bitmap) or
  /// \#setStream(java.io.InputStream) should check this value
  /// beforehand to make sure the supplied wallpaper respects the desired
  /// minimum height.
  ///
  /// If the returned value is <= 0, the caller should use the height of
  /// the default display instead.
  ///@return The desired minimum height for the wallpaper. This value should
  /// be honored by applications that set the wallpaper but it is not
  /// mandatory.
  int getDesiredMinimumHeight() => _getDesiredMinimumHeight(reference).integer;

  static final _suggestDesiredDimensions = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("WallpaperManager__suggestDesiredDimensions")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void suggestDesiredDimensions(int minimumWidth, int minimumHeight)
  ///
  /// For use only by the current home application, to specify the size of
  /// wallpaper it would like to use.  This allows such applications to have
  /// a virtual wallpaper that is larger than the physical screen, matching
  /// the size of their workspace.
  ///
  /// Note developers, who don't seem to be reading this.  This is
  /// for _home apps_ to tell what size wallpaper they would like.
  /// Nobody else should be calling this!  Certainly not other non-home
  /// apps that change the wallpaper.  Those apps are supposed to
  /// __retrieve__ the suggested size so they can construct a wallpaper
  /// that matches it.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER_HINTS.
  ///@param minimumWidth Desired minimum width
  ///@param minimumHeight Desired minimum height
  void suggestDesiredDimensions(int minimumWidth, int minimumHeight) =>
      _suggestDesiredDimensions(reference, minimumWidth, minimumHeight).check();

  static final _setDisplayPadding = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "WallpaperManager__setDisplayPadding")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setDisplayPadding(android.graphics.Rect padding)
  ///
  /// Specify extra padding that the wallpaper should have outside of the display.
  /// That is, the given padding supplies additional pixels the wallpaper should extend
  /// outside of the display itself.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER_HINTS.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER_HINTS
  ///@param padding The number of pixels the wallpaper should extend beyond the display,
  /// on its left, top, right, and bottom sides.
  void setDisplayPadding(jni.JniObject padding) =>
      _setDisplayPadding(reference, padding.reference).check();

  static final _clearWallpaper = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperManager__clearWallpaper")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void clearWallpaper()
  ///
  /// Reset all wallpaper to the factory default.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  void clearWallpaper() => _clearWallpaper(reference).check();

  static final _setWallpaperOffsets = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Float,
                  ffi.Float)>>("WallpaperManager__setWallpaperOffsets")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, double, double)>();

  /// from: public void setWallpaperOffsets(android.os.IBinder windowToken, float xOffset, float yOffset)
  ///
  /// Set the display position of the current wallpaper within any larger space, when
  /// that wallpaper is visible behind the given window.  The X and Y offsets
  /// are floating point numbers ranging from 0 to 1, representing where the
  /// wallpaper should be positioned within the screen space.  These only
  /// make sense when the wallpaper is larger than the display.
  ///@param windowToken The window who these offsets should be associated
  /// with, as returned by android.view.View\#getWindowToken() View.getWindowToken().
  ///@param xOffset The offset along the X dimension, from 0 to 1.
  ///@param yOffset The offset along the Y dimension, from 0 to 1.
  void setWallpaperOffsets(
          os_.IBinder windowToken, double xOffset, double yOffset) =>
      _setWallpaperOffsets(reference, windowToken.reference, xOffset, yOffset)
          .check();

  static final _setWallpaperOffsetSteps = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Float,
                  ffi.Float)>>("WallpaperManager__setWallpaperOffsetSteps")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, double, double)>();

  /// from: public void setWallpaperOffsetSteps(float xStep, float yStep)
  ///
  /// For applications that use multiple virtual screens showing a wallpaper,
  /// specify the step size between virtual screens. For example, if the
  /// launcher has 3 virtual screens, it would specify an xStep of 0.5,
  /// since the X offset for those screens are 0.0, 0.5 and 1.0
  ///@param xStep The X offset delta from one screen to the next one
  ///@param yStep The Y offset delta from one screen to the next one
  void setWallpaperOffsetSteps(double xStep, double yStep) =>
      _setWallpaperOffsetSteps(reference, xStep, yStep).check();

  static final _sendWallpaperCommand = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "WallpaperManager__sendWallpaperCommand")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void sendWallpaperCommand(android.os.IBinder windowToken, java.lang.String action, int x, int y, int z, android.os.Bundle extras)
  ///
  /// Send an arbitrary command to the current active wallpaper.
  ///@param windowToken The window who these offsets should be associated
  /// with, as returned by android.view.View\#getWindowToken() View.getWindowToken().
  ///@param action Name of the command to perform.  This must be a scoped
  /// name to avoid collisions, such as "com.mycompany.wallpaper.DOIT".
  ///@param x Arbitrary integer argument based on command.
  ///@param y Arbitrary integer argument based on command.
  ///@param z Arbitrary integer argument based on command.
  ///@param extras Optional additional information for the command, or null.
  void sendWallpaperCommand(os_.IBinder windowToken, jni.JniString action,
          int x, int y, int z, os_.Bundle extras) =>
      _sendWallpaperCommand(reference, windowToken.reference, action.reference,
              x, y, z, extras.reference)
          .check();

  static final _isWallpaperSupported = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "WallpaperManager__isWallpaperSupported")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isWallpaperSupported()
  ///
  /// Returns whether wallpapers are supported for the calling user. If this function returns
  /// {@code false}, any attempts to changing the wallpaper will have no effect,
  /// and any attempt to obtain of the wallpaper will return {@code null}.
  bool isWallpaperSupported() => _isWallpaperSupported(reference).boolean;

  static final _isSetWallpaperAllowed = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "WallpaperManager__isSetWallpaperAllowed")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isSetWallpaperAllowed()
  ///
  /// Returns whether the calling package is allowed to set the wallpaper for the calling user.
  /// If this function returns {@code false}, any attempts to change the wallpaper will have
  /// no effect. Always returns {@code true} for device owner and profile owner.
  ///@see android.os.UserManager\#DISALLOW_SET_WALLPAPER
  bool isSetWallpaperAllowed() => _isSetWallpaperAllowed(reference).boolean;

  static final _clearWallpaperOffsets = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "WallpaperManager__clearWallpaperOffsets")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void clearWallpaperOffsets(android.os.IBinder windowToken)
  ///
  /// Clear the offsets previously associated with this window through
  /// \#setWallpaperOffsets(IBinder, float, float).  This reverts
  /// the window to its default state, where it does not cause the wallpaper
  /// to scroll from whatever its last offsets were.
  ///@param windowToken The window who these offsets should be associated
  /// with, as returned by android.view.View\#getWindowToken() View.getWindowToken().
  void clearWallpaperOffsets(os_.IBinder windowToken) =>
      _clearWallpaperOffsets(reference, windowToken.reference).check();

  static final _clear = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("WallpaperManager__clear")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void clear()
  ///
  /// Remove any currently set system wallpaper, reverting to the system's built-in
  /// wallpaper. On success, the intent Intent\#ACTION_WALLPAPER_CHANGED
  /// is broadcast.
  ///
  /// This method requires the caller to hold the permission
  /// android.Manifest.permission\#SET_WALLPAPER.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@throws IOException If an error occurs reverting to the built-in
  /// wallpaper.
  void clear() => _clear(reference).check();

  static final _clear1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("WallpaperManager__clear1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void clear(int which)
  ///
  /// Remove one or more currently set wallpapers, reverting to the system default
  /// display for each one.  If \#FLAG_SYSTEM is set in the {@code which}
  /// parameter, the intent Intent\#ACTION_WALLPAPER_CHANGED will be broadcast
  /// upon success.
  ///
  /// Requires android.Manifest.permission\#SET_WALLPAPER
  ///@param which A bitwise combination of \#FLAG_SYSTEM or
  ///   \#FLAG_LOCK
  /// Value is either <code>0</code> or a combination of android.app.WallpaperManager\#FLAG_SYSTEM, and android.app.WallpaperManager\#FLAG_LOCK
  ///@throws IOException If an error occurs reverting to the built-in wallpaper.
  void clear1(int which) => _clear1(reference, which).check();
}

/// from: android.app.WallpaperManager$OnColorsChangedListener
///
/// Interface definition for a callback to be invoked when colors change on a wallpaper.
class WallpaperManager_OnColorsChangedListener extends jni.JniObject {
  WallpaperManager_OnColorsChangedListener.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _onColorsChanged = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Int32)>>(
          "WallpaperManager_OnColorsChangedListener__onColorsChanged")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract void onColorsChanged(android.app.WallpaperColors colors, int which)
  ///
  /// Called when colors change.
  /// A android.app.WallpaperColors object containing a simplified
  /// color histogram will be given.
  ///@param colors Wallpaper color info
  ///@param which A combination of \#FLAG_LOCK and \#FLAG_SYSTEM
  void onColorsChanged(WallpaperColors colors, int which) =>
      _onColorsChanged(reference, colors.reference, which).check();
}
