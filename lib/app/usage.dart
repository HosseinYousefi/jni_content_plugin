// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: constant_identifier_names
// ignore_for_file: annotate_overrides
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: unused_element

import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "../os.dart" as os_;

import "../content/res.dart" as res_;
import "../_init.dart" show jniLookup;

/// from: android.app.usage.ConfigurationStats
///
/// Represents the usage statistics of a device android.content.res.Configuration for a
/// specific time range.
class ConfigurationStats extends jni.JniObject {
  ConfigurationStats.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_ConfigurationStats__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.usage.ConfigurationStats> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ConfigurationStats__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.usage.ConfigurationStats stats)
  ConfigurationStats(ConfigurationStats stats)
      : super.fromRef(_ctor(stats.reference).object);

  static final _getConfiguration = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ConfigurationStats__getConfiguration")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.Configuration getConfiguration()
  /// The returned object must be deleted after use, by calling the `delete` method.
  res_.Configuration getConfiguration() =>
      res_.Configuration.fromRef(_getConfiguration(reference).object);

  static final _getFirstTimeStamp = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ConfigurationStats__getFirstTimeStamp")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getFirstTimeStamp()
  ///
  /// Get the beginning of the time range this ConfigurationStats represents,
  /// measured in milliseconds since the epoch.
  /// <p/>
  /// See System\#currentTimeMillis().
  int getFirstTimeStamp() => _getFirstTimeStamp(reference).long;

  static final _getLastTimeStamp = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ConfigurationStats__getLastTimeStamp")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getLastTimeStamp()
  ///
  /// Get the end of the time range this ConfigurationStats represents,
  /// measured in milliseconds since the epoch.
  /// <p/>
  /// See System\#currentTimeMillis().
  int getLastTimeStamp() => _getLastTimeStamp(reference).long;

  static final _getLastTimeActive = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ConfigurationStats__getLastTimeActive")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getLastTimeActive()
  ///
  /// Get the last time this configuration was active, measured in milliseconds since the epoch.
  /// <p/>
  /// See System\#currentTimeMillis().
  int getLastTimeActive() => _getLastTimeActive(reference).long;

  static final _getTotalTimeActive = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ConfigurationStats__getTotalTimeActive")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTotalTimeActive()
  ///
  /// Get the total time this configuration was active, measured in milliseconds.
  int getTotalTimeActive() => _getTotalTimeActive(reference).long;

  static final _getActivationCount = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ConfigurationStats__getActivationCount")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getActivationCount()
  ///
  /// Get the number of times this configuration was active.
  int getActivationCount() => _getActivationCount(reference).integer;

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ConfigurationStats__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ConfigurationStats__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();
}

/// from: android.app.usage.EventStats
///
/// Contains usage statistics for an event type for a specific
/// time range.
class EventStats extends jni.JniObject {
  EventStats.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_EventStats__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.usage.EventStats> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("EventStats__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.usage.EventStats stats)
  EventStats(EventStats stats) : super.fromRef(_ctor(stats.reference).object);

  static final _getEventType = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("EventStats__getEventType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getEventType()
  ///
  /// Return the type of event this is usage for.  May be one of the event
  /// constants in UsageEvents.Event.
  int getEventType() => _getEventType(reference).integer;

  static final _getFirstTimeStamp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("EventStats__getFirstTimeStamp")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getFirstTimeStamp()
  ///
  /// Get the beginning of the time range this android.app.usage.EventStats represents,
  /// measured in milliseconds since the epoch.
  /// <p/>
  /// See System\#currentTimeMillis().
  int getFirstTimeStamp() => _getFirstTimeStamp(reference).long;

  static final _getLastTimeStamp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("EventStats__getLastTimeStamp")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getLastTimeStamp()
  ///
  /// Get the end of the time range this android.app.usage.EventStats represents,
  /// measured in milliseconds since the epoch.
  /// <p/>
  /// See System\#currentTimeMillis().
  int getLastTimeStamp() => _getLastTimeStamp(reference).long;

  static final _getLastEventTime = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("EventStats__getLastEventTime")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getLastEventTime()
  ///
  /// Get the last time this event triggered, measured in milliseconds since the epoch.
  /// <p/>
  /// See System\#currentTimeMillis().
  int getLastEventTime() => _getLastEventTime(reference).long;

  static final _getCount = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("EventStats__getCount")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getCount()
  ///
  /// Return the number of times that this event occurred over the interval.
  int getCount() => _getCount(reference).integer;

  static final _getTotalTime = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("EventStats__getTotalTime")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTotalTime()
  ///
  /// Get the total time this event was active, measured in milliseconds.
  int getTotalTime() => _getTotalTime(reference).long;

  static final _add = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("EventStats__add")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void add(android.app.usage.EventStats right)
  ///
  /// Add the statistics from the right EventStats to the left. The event type for
  /// both UsageStats objects must be the same.
  ///@param right The EventStats object to merge into this one.
  ///@throws java.lang.IllegalArgumentException if the event types of the two
  ///         UsageStats objects are different.
  void add(EventStats right) => _add(reference, right.reference).check();

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("EventStats__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("EventStats__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();
}

/// from: android.app.usage.ExternalStorageStats
///
/// Shared/external storage statistics for a UserHandle on a single
/// storage volume.
///@see StorageStatsManager
class ExternalStorageStats extends jni.JniObject {
  ExternalStorageStats.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_ExternalStorageStats__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.usage.ExternalStorageStats> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "ExternalStorageStats__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  ///
  /// {@hide }
  ExternalStorageStats() : super.fromRef(_ctor().object);

  static final _getTotalBytes = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ExternalStorageStats__getTotalBytes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTotalBytes()
  ///
  /// Return the total bytes used by all files in the shared/external storage
  /// hosted on this volume.
  ///
  /// This value only includes data which is isolated for each user on a
  /// multiuser device. Any OBB data shared between users is not accounted in
  /// this value.
  ///
  /// Value is a non-negative number of bytes.
  ///@return Value is a non-negative number of bytes.
  int getTotalBytes() => _getTotalBytes(reference).long;

  static final _getAudioBytes = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ExternalStorageStats__getAudioBytes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getAudioBytes()
  ///
  /// Return the total bytes used by all audio files in the shared/external
  /// storage hosted on this volume.
  ///
  /// This value only includes data which is isolated for each user on a
  /// multiuser device. This value does not include any app files which are all
  /// accounted under \#getAppBytes().
  ///
  /// Value is a non-negative number of bytes.
  ///@return Value is a non-negative number of bytes.
  int getAudioBytes() => _getAudioBytes(reference).long;

  static final _getVideoBytes = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ExternalStorageStats__getVideoBytes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getVideoBytes()
  ///
  /// Return the total bytes used by all video files in the shared/external
  /// storage hosted on this volume.
  ///
  /// This value only includes data which is isolated for each user on a
  /// multiuser device. This value does not include any app files which are all
  /// accounted under \#getAppBytes().
  ///
  /// Value is a non-negative number of bytes.
  ///@return Value is a non-negative number of bytes.
  int getVideoBytes() => _getVideoBytes(reference).long;

  static final _getImageBytes = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ExternalStorageStats__getImageBytes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getImageBytes()
  ///
  /// Return the total bytes used by all image files in the shared/external
  /// storage hosted on this volume.
  ///
  /// This value only includes data which is isolated for each user on a
  /// multiuser device. This value does not include any app files which are all
  /// accounted under \#getAppBytes().
  ///
  /// Value is a non-negative number of bytes.
  ///@return Value is a non-negative number of bytes.
  int getImageBytes() => _getImageBytes(reference).long;

  static final _getAppBytes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("ExternalStorageStats__getAppBytes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getAppBytes()
  ///
  /// Return the total bytes used by app files in the shared/external storage
  /// hosted on this volume.
  ///
  /// This data is already accounted against individual apps as returned
  /// through StorageStats.
  ///
  /// This value only includes data which is isolated for each user on a
  /// multiuser device.
  ///
  /// Value is a non-negative number of bytes.
  ///@return Value is a non-negative number of bytes.
  int getAppBytes() => _getAppBytes(reference).long;

  static final _describeContents = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ExternalStorageStats__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("ExternalStorageStats__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();
}

/// from: android.app.usage.NetworkStats
///
/// Class providing enumeration over buckets of network usage statistics. NetworkStats objects
/// are returned as results to various queries in NetworkStatsManager.
class NetworkStats extends jni.JniObject {
  NetworkStats.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "NetworkStats__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  NetworkStats() : super.fromRef(_ctor().object);

  static final _finalize = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NetworkStats__finalize")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: protected void finalize()
  void finalize() => _finalize(reference).check();

  static final _getNextBucket = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("NetworkStats__getNextBucket")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getNextBucket(android.app.usage.NetworkStats.Bucket bucketOut)
  ///
  /// Fills the recycled bucket with data of the next bin in the enumeration.
  ///@param bucketOut Bucket to be filled with data.
  ///@return true if successfully filled the bucket, false otherwise.
  bool getNextBucket(NetworkStats_Bucket bucketOut) =>
      _getNextBucket(reference, bucketOut.reference).boolean;

  static final _hasNextBucket = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NetworkStats__hasNextBucket")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasNextBucket()
  ///
  /// Check if it is possible to ask for a next bucket in the enumeration.
  ///@return true if there is at least one more bucket.
  bool hasNextBucket() => _hasNextBucket(reference).boolean;

  static final _close = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NetworkStats__close")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void close()
  ///
  /// Closes the enumeration. Call this method before this object gets out of scope.
  void close() => _close(reference).check();
}

/// from: android.app.usage.NetworkStats$Bucket
///
/// Buckets are the smallest elements of a query result. As some dimensions of a result may be
/// aggregated (e.g. time or state) some values may be equal across all buckets.
class NetworkStats_Bucket extends jni.JniObject {
  NetworkStats_Bucket.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int DEFAULT_NETWORK_ALL
  ///
  /// Combined usage for this network regardless of default network status.
  static const DEFAULT_NETWORK_ALL = -1;

  /// from: static public final int DEFAULT_NETWORK_NO
  ///
  /// Usage that occurs while this network is not a default network.
  ///
  /// This implies that the app responsible for this usage requested that it occur on a
  /// specific network different from the one(s) the system would have selected for it.
  static const DEFAULT_NETWORK_NO = 1;

  /// from: static public final int DEFAULT_NETWORK_YES
  ///
  /// Usage that occurs while this network is a default network.
  ///
  /// This implies that the app either did not select a specific network for this usage,
  /// or it selected a network that the system could have selected for app traffic.
  static const DEFAULT_NETWORK_YES = 2;

  /// from: static public final int METERED_ALL
  ///
  /// Combined usage across all metered states. Covers metered and unmetered usage.
  static const METERED_ALL = -1;

  /// from: static public final int METERED_NO
  ///
  /// Usage that occurs on an unmetered network.
  static const METERED_NO = 1;

  /// from: static public final int METERED_YES
  ///
  /// Usage that occurs on a metered network.
  ///
  /// A network is classified as metered when the user is sensitive to heavy data usage on
  /// that connection.
  static const METERED_YES = 2;

  /// from: static public final int ROAMING_ALL
  ///
  /// Combined usage across all roaming states. Covers both roaming and non-roaming usage.
  static const ROAMING_ALL = -1;

  /// from: static public final int ROAMING_NO
  ///
  /// Usage that occurs on a home, non-roaming network.
  ///
  /// Any cellular usage in this bucket was incurred while the device was connected to a
  /// tower owned or operated by the user's wireless carrier, or a tower that the user's
  /// wireless carrier has indicated should be treated as a home network regardless.
  ///
  /// This is also the default value for network types that do not support roaming.
  static const ROAMING_NO = 1;

  /// from: static public final int ROAMING_YES
  ///
  /// Usage that occurs on a roaming network.
  ///
  /// Any cellular usage in this bucket as incurred while the device was roaming on another
  /// carrier's network, for which additional charges may apply.
  static const ROAMING_YES = 2;

  /// from: static public final int STATE_ALL
  ///
  /// Combined usage across all states.
  static const STATE_ALL = -1;

  /// from: static public final int STATE_DEFAULT
  ///
  /// Usage not accounted for in any other state.
  static const STATE_DEFAULT = 1;

  /// from: static public final int STATE_FOREGROUND
  ///
  /// Foreground usage.
  static const STATE_FOREGROUND = 2;

  /// from: static public final int TAG_NONE
  ///
  /// Special TAG value for total data across all tags
  static const TAG_NONE = 0;

  /// from: static public final int UID_ALL
  ///
  /// Special UID value for aggregate/unspecified.
  static const UID_ALL = -1;

  /// from: static public final int UID_REMOVED
  ///
  /// Special UID value for removed apps.
  static const UID_REMOVED = -4;

  /// from: static public final int UID_TETHERING
  ///
  /// Special UID value for data usage by tethering.
  static const UID_TETHERING = -5;

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "NetworkStats_Bucket__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  NetworkStats_Bucket() : super.fromRef(_ctor().object);

  static final _getUid = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NetworkStats_Bucket__getUid")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getUid()
  ///
  /// Key of the bucket. Usually an app uid or one of the following special values:<p/>
  /// <ul>
  /// <li>\#UID_REMOVED</li>
  /// <li>\#UID_TETHERING</li>
  /// <li>android.os.Process\#SYSTEM_UID</li>
  /// </ul>
  ///@return Bucket key.
  int getUid() => _getUid(reference).integer;

  static final _getTag = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NetworkStats_Bucket__getTag")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getTag()
  ///
  /// Tag of the bucket.<p/>
  ///@return Bucket tag.
  int getTag() => _getTag(reference).integer;

  static final _getState = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NetworkStats_Bucket__getState")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getState()
  ///
  /// Usage state. One of the following values:<p/>
  /// <ul>
  /// <li>\#STATE_ALL</li>
  /// <li>\#STATE_DEFAULT</li>
  /// <li>\#STATE_FOREGROUND</li>
  /// </ul>
  ///@return Usage state.
  ///
  /// Value is android.app.usage.NetworkStats.Bucket\#STATE_ALL, android.app.usage.NetworkStats.Bucket\#STATE_DEFAULT, or android.app.usage.NetworkStats.Bucket\#STATE_FOREGROUND
  int getState() => _getState(reference).integer;

  static final _getMetered = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NetworkStats_Bucket__getMetered")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getMetered()
  ///
  /// Metered state. One of the following values:<p/>
  /// <ul>
  /// <li>\#METERED_ALL</li>
  /// <li>\#METERED_NO</li>
  /// <li>\#METERED_YES</li>
  /// </ul>
  /// A network is classified as metered when the user is sensitive to heavy data usage on
  /// that connection. Apps may warn before using these networks for large downloads. The
  /// metered state can be set by the user within data usage network restrictions.
  ///@return Value is android.app.usage.NetworkStats.Bucket\#METERED_ALL, android.app.usage.NetworkStats.Bucket\#METERED_NO, or android.app.usage.NetworkStats.Bucket\#METERED_YES
  int getMetered() => _getMetered(reference).integer;

  static final _getRoaming = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NetworkStats_Bucket__getRoaming")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getRoaming()
  ///
  /// Roaming state. One of the following values:<p/>
  /// <ul>
  /// <li>\#ROAMING_ALL</li>
  /// <li>\#ROAMING_NO</li>
  /// <li>\#ROAMING_YES</li>
  /// </ul>
  ///@return Value is android.app.usage.NetworkStats.Bucket\#ROAMING_ALL, android.app.usage.NetworkStats.Bucket\#ROAMING_NO, or android.app.usage.NetworkStats.Bucket\#ROAMING_YES
  int getRoaming() => _getRoaming(reference).integer;

  static final _getDefaultNetworkStatus = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NetworkStats_Bucket__getDefaultNetworkStatus")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getDefaultNetworkStatus()
  ///
  /// Default network status. One of the following values:<p/>
  /// <ul>
  /// <li>\#DEFAULT_NETWORK_ALL</li>
  /// <li>\#DEFAULT_NETWORK_NO</li>
  /// <li>\#DEFAULT_NETWORK_YES</li>
  /// </ul>
  ///@return Value is android.app.usage.NetworkStats.Bucket\#DEFAULT_NETWORK_ALL, android.app.usage.NetworkStats.Bucket\#DEFAULT_NETWORK_NO, or android.app.usage.NetworkStats.Bucket\#DEFAULT_NETWORK_YES
  int getDefaultNetworkStatus() => _getDefaultNetworkStatus(reference).integer;

  static final _getStartTimeStamp = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NetworkStats_Bucket__getStartTimeStamp")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getStartTimeStamp()
  ///
  /// Start timestamp of the bucket's time interval. Defined in terms of "Unix time", see
  /// java.lang.System\#currentTimeMillis.
  ///@return Start of interval.
  int getStartTimeStamp() => _getStartTimeStamp(reference).long;

  static final _getEndTimeStamp = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "NetworkStats_Bucket__getEndTimeStamp")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getEndTimeStamp()
  ///
  /// End timestamp of the bucket's time interval. Defined in terms of "Unix time", see
  /// java.lang.System\#currentTimeMillis.
  ///@return End of interval.
  int getEndTimeStamp() => _getEndTimeStamp(reference).long;

  static final _getRxBytes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NetworkStats_Bucket__getRxBytes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getRxBytes()
  ///
  /// Number of bytes received during the bucket's time interval. Statistics are measured at
  /// the network layer, so they include both TCP and UDP usage.
  ///@return Number of bytes.
  int getRxBytes() => _getRxBytes(reference).long;

  static final _getTxBytes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NetworkStats_Bucket__getTxBytes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTxBytes()
  ///
  /// Number of bytes transmitted during the bucket's time interval. Statistics are measured at
  /// the network layer, so they include both TCP and UDP usage.
  ///@return Number of bytes.
  int getTxBytes() => _getTxBytes(reference).long;

  static final _getRxPackets = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NetworkStats_Bucket__getRxPackets")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getRxPackets()
  ///
  /// Number of packets received during the bucket's time interval. Statistics are measured at
  /// the network layer, so they include both TCP and UDP usage.
  ///@return Number of packets.
  int getRxPackets() => _getRxPackets(reference).long;

  static final _getTxPackets = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("NetworkStats_Bucket__getTxPackets")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTxPackets()
  ///
  /// Number of packets transmitted during the bucket's time interval. Statistics are measured
  /// at the network layer, so they include both TCP and UDP usage.
  ///@return Number of packets.
  int getTxPackets() => _getTxPackets(reference).long;
}

/// from: android.app.usage.NetworkStatsManager
///
/// Provides access to network usage history and statistics. Usage data is collected in
/// discrete bins of time called 'Buckets'. See NetworkStats.Bucket for details.
/// <p/>
/// Queries can define a time interval in the form of start and end timestamps (Long.MIN_VALUE and
/// Long.MAX_VALUE can be used to simulate open ended intervals). By default, apps can only obtain
/// data about themselves. See the below note for special cases in which apps can obtain data about
/// other applications.
/// <h3>
/// Summary queries
/// </h3>
/// \#querySummaryForDevice <p/>
/// \#querySummaryForUser <p/>
/// \#querySummary <p/>
/// These queries aggregate network usage across the whole interval. Therefore there will be only one
/// bucket for a particular key, state, metered and roaming combination. In case of the user-wide
/// and device-wide summaries a single bucket containing the totalised network usage is returned.
/// <h3>
/// History queries
/// </h3>
/// \#queryDetailsForUid <p/>
/// \#queryDetails <p/>
/// These queries do not aggregate over time but do aggregate over state, metered and roaming.
/// Therefore there can be multiple buckets for a particular key. However, all Buckets will have
/// {@code state} NetworkStats.Bucket\#STATE_ALL,
/// {@code defaultNetwork} NetworkStats.Bucket\#DEFAULT_NETWORK_ALL,
/// {@code metered } NetworkStats.Bucket\#METERED_ALL,
/// {@code roaming} NetworkStats.Bucket\#ROAMING_ALL.
/// <p/>
/// __NOTE:__ Calling \#querySummaryForDevice or accessing stats for apps other than the
/// calling app requires the permission android.Manifest.permission\#PACKAGE_USAGE_STATS,
/// which is a system-level permission and will not be granted to third-party apps. However,
/// declaring the permission implies intention to use the API and the user of the device can grant
/// permission through the Settings application.
/// <p/>
/// Profile owner apps are automatically granted permission to query data on the profile they manage
/// (that is, for any query except \#querySummaryForDevice). Device owner apps and carrier-
/// privileged apps likewise get access to usage data for all users on the device.
/// <p/>
/// In addition to tethering usage, usage by removed users and apps, and usage by the system
/// is also included in the results for callers with one of these higher levels of access.
/// <p/>
/// __NOTE:__ Prior to API level {@value android.os.Build.VERSION_CODES\#N}, all calls to these APIs required
/// the above permission, even to access an app's own data usage, and carrier-privileged apps were
/// not included.
class NetworkStatsManager extends jni.JniObject {
  NetworkStatsManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "NetworkStatsManager__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  NetworkStatsManager() : super.fromRef(_ctor().object);

  static final _querySummaryForDevice = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Int64)>>("NetworkStatsManager__querySummaryForDevice")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.app.usage.NetworkStats.Bucket querySummaryForDevice(int networkType, java.lang.String subscriberId, long startTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query network usage statistics summaries. Result is summarised data usage for the whole
  /// device. Result is a single Bucket aggregated over time, state, uid, tag, metered, and
  /// roaming. This means the bucket's start and end timestamp are going to be the same as the
  /// 'startTime' and 'endTime' parameters. State is going to be
  /// NetworkStats.Bucket\#STATE_ALL, uid NetworkStats.Bucket\#UID_ALL,
  /// tag NetworkStats.Bucket\#TAG_NONE,
  /// default network NetworkStats.Bucket\#DEFAULT_NETWORK_ALL,
  /// metered NetworkStats.Bucket\#METERED_ALL,
  /// and roaming NetworkStats.Bucket\#ROAMING_ALL.
  ///@param networkType As defined in ConnectivityManager, e.g.
  ///            ConnectivityManager\#TYPE_MOBILE, ConnectivityManager\#TYPE_WIFI
  ///            etc.
  ///@param subscriberId If applicable, the subscriber id of the network interface.
  ///@param startTime Start of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@param endTime End of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@return Bucket object or null if permissions are insufficient or error happened during
  ///         statistics collection.
  NetworkStats_Bucket querySummaryForDevice(int networkType,
          jni.JniString subscriberId, int startTime, int endTime) =>
      NetworkStats_Bucket.fromRef(_querySummaryForDevice(reference, networkType,
              subscriberId.reference, startTime, endTime)
          .object);

  static final _querySummaryForUser = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Int64)>>("NetworkStatsManager__querySummaryForUser")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.app.usage.NetworkStats.Bucket querySummaryForUser(int networkType, java.lang.String subscriberId, long startTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query network usage statistics summaries. Result is summarised data usage for all uids
  /// belonging to calling user. Result is a single Bucket aggregated over time, state and uid.
  /// This means the bucket's start and end timestamp are going to be the same as the 'startTime'
  /// and 'endTime' parameters. State is going to be NetworkStats.Bucket\#STATE_ALL,
  /// uid NetworkStats.Bucket\#UID_ALL, tag NetworkStats.Bucket\#TAG_NONE,
  /// metered NetworkStats.Bucket\#METERED_ALL, and roaming
  /// NetworkStats.Bucket\#ROAMING_ALL.
  ///@param networkType As defined in ConnectivityManager, e.g.
  ///            ConnectivityManager\#TYPE_MOBILE, ConnectivityManager\#TYPE_WIFI
  ///            etc.
  ///@param subscriberId If applicable, the subscriber id of the network interface.
  ///@param startTime Start of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@param endTime End of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@return Bucket object or null if permissions are insufficient or error happened during
  ///         statistics collection.
  NetworkStats_Bucket querySummaryForUser(int networkType,
          jni.JniString subscriberId, int startTime, int endTime) =>
      NetworkStats_Bucket.fromRef(_querySummaryForUser(reference, networkType,
              subscriberId.reference, startTime, endTime)
          .object);

  static final _querySummary = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Int64)>>("NetworkStatsManager__querySummary")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.app.usage.NetworkStats querySummary(int networkType, java.lang.String subscriberId, long startTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query network usage statistics summaries. Result filtered to include only uids belonging to
  /// calling user. Result is aggregated over time, hence all buckets will have the same start and
  /// end timestamps. Not aggregated over state, uid, default network, metered, or roaming. This
  /// means buckets' start and end timestamps are going to be the same as the 'startTime' and
  /// 'endTime' parameters. State, uid, metered, and roaming are going to vary, and tag is going to
  /// be the same.
  ///@param networkType As defined in ConnectivityManager, e.g.
  ///            ConnectivityManager\#TYPE_MOBILE, ConnectivityManager\#TYPE_WIFI
  ///            etc.
  ///@param subscriberId If applicable, the subscriber id of the network interface.
  ///@param startTime Start of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@param endTime End of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@return Statistics object or null if permissions are insufficient or error happened during
  ///         statistics collection.
  NetworkStats querySummary(int networkType, jni.JniString subscriberId,
          int startTime, int endTime) =>
      NetworkStats.fromRef(_querySummary(reference, networkType,
              subscriberId.reference, startTime, endTime)
          .object);

  static final _queryDetailsForUid = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Int32)>>("NetworkStatsManager__queryDetailsForUid")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public android.app.usage.NetworkStats queryDetailsForUid(int networkType, java.lang.String subscriberId, long startTime, long endTime, int uid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query network usage statistics details for a given uid.
  ///
  /// \#see queryDetailsForUidTagState(int, String, long, long, int, int, int)
  NetworkStats queryDetailsForUid(int networkType, jni.JniString subscriberId,
          int startTime, int endTime, int uid) =>
      NetworkStats.fromRef(_queryDetailsForUid(reference, networkType,
              subscriberId.reference, startTime, endTime, uid)
          .object);

  static final _queryDetailsForUidTag = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Int32,
                  ffi.Int32)>>("NetworkStatsManager__queryDetailsForUidTag")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: public android.app.usage.NetworkStats queryDetailsForUidTag(int networkType, java.lang.String subscriberId, long startTime, long endTime, int uid, int tag)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query network usage statistics details for a given uid and tag.
  ///
  /// \#see queryDetailsForUidTagState(int, String, long, long, int, int, int)
  NetworkStats queryDetailsForUidTag(
          int networkType,
          jni.JniString subscriberId,
          int startTime,
          int endTime,
          int uid,
          int tag) =>
      NetworkStats.fromRef(_queryDetailsForUidTag(reference, networkType,
              subscriberId.reference, startTime, endTime, uid, tag)
          .object);

  static final _queryDetailsForUidTagState = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int64,
                      ffi.Int64,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32)>>(
          "NetworkStatsManager__queryDetailsForUidTagState")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, int, int, int, int)>();

  /// from: public android.app.usage.NetworkStats queryDetailsForUidTagState(int networkType, java.lang.String subscriberId, long startTime, long endTime, int uid, int tag, int state)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query network usage statistics details for a given uid, tag, and state. Only usable for uids
  /// belonging to calling user. Result is not aggregated over time. This means buckets' start and
  /// end timestamps are going to be between 'startTime' and 'endTime' parameters. The uid is going
  /// to be the same as the 'uid' parameter, the tag the same as the 'tag' parameter, and the state
  /// the same as the 'state' parameter.
  /// defaultNetwork is going to be NetworkStats.Bucket\#DEFAULT_NETWORK_ALL,
  /// metered is going to be NetworkStats.Bucket\#METERED_ALL, and
  /// roaming is going to be NetworkStats.Bucket\#ROAMING_ALL.
  /// Only includes buckets that atomically occur in the inclusive time range. Doesn't
  /// interpolate across partial buckets. Since bucket length is in the order of hours, this
  /// method cannot be used to measure data usage on a fine grained time scale.
  ///@param networkType As defined in ConnectivityManager, e.g.
  ///            ConnectivityManager\#TYPE_MOBILE, ConnectivityManager\#TYPE_WIFI
  ///            etc.
  ///@param subscriberId If applicable, the subscriber id of the network interface.
  ///@param startTime Start of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@param endTime End of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@param uid UID of app
  ///@param tag TAG of interest. Use NetworkStats.Bucket\#TAG_NONE for no tags.
  ///@param state state of interest. Use NetworkStats.Bucket\#STATE_ALL to aggregate
  ///            traffic from all states.
  ///@return Statistics object or null if an error happened during statistics collection.
  ///@throws SecurityException if permissions are insufficient to read network statistics.
  NetworkStats queryDetailsForUidTagState(
          int networkType,
          jni.JniString subscriberId,
          int startTime,
          int endTime,
          int uid,
          int tag,
          int state) =>
      NetworkStats.fromRef(_queryDetailsForUidTagState(reference, networkType,
              subscriberId.reference, startTime, endTime, uid, tag, state)
          .object);

  static final _queryDetails = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Int64)>>("NetworkStatsManager__queryDetails")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.app.usage.NetworkStats queryDetails(int networkType, java.lang.String subscriberId, long startTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query network usage statistics details. Result filtered to include only uids belonging to
  /// calling user. Result is aggregated over state but not aggregated over time, uid, tag,
  /// metered, nor roaming. This means buckets' start and end timestamps are going to be between
  /// 'startTime' and 'endTime' parameters. State is going to be
  /// NetworkStats.Bucket\#STATE_ALL, uid will vary,
  /// tag NetworkStats.Bucket\#TAG_NONE,
  /// default network is going to be NetworkStats.Bucket\#DEFAULT_NETWORK_ALL,
  /// metered is going to be NetworkStats.Bucket\#METERED_ALL,
  /// and roaming is going to be NetworkStats.Bucket\#ROAMING_ALL.
  /// Only includes buckets that atomically occur in the inclusive time range. Doesn't
  /// interpolate across partial buckets. Since bucket length is in the order of hours, this
  /// method cannot be used to measure data usage on a fine grained time scale.
  ///@param networkType As defined in ConnectivityManager, e.g.
  ///            ConnectivityManager\#TYPE_MOBILE, ConnectivityManager\#TYPE_WIFI
  ///            etc.
  ///@param subscriberId If applicable, the subscriber id of the network interface.
  ///@param startTime Start of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@param endTime End of period. Defined in terms of "Unix time", see
  ///            java.lang.System\#currentTimeMillis.
  ///@return Statistics object or null if permissions are insufficient or error happened during
  ///         statistics collection.
  NetworkStats queryDetails(int networkType, jni.JniString subscriberId,
          int startTime, int endTime) =>
      NetworkStats.fromRef(_queryDetails(reference, networkType,
              subscriberId.reference, startTime, endTime)
          .object);

  static final _registerUsageCallback = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int64,
                      ffi.Pointer<ffi.Void>)>>(
          "NetworkStatsManager__registerUsageCallback")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void registerUsageCallback(int networkType, java.lang.String subscriberId, long thresholdBytes, android.app.usage.NetworkStatsManager.UsageCallback callback)
  ///
  /// Registers to receive notifications about data usage on specified networks.
  ///
  /// \#see registerUsageCallback(int, String[], long, UsageCallback, Handler)
  void registerUsageCallback(int networkType, jni.JniString subscriberId,
          int thresholdBytes, NetworkStatsManager_UsageCallback callback) =>
      _registerUsageCallback(reference, networkType, subscriberId.reference,
              thresholdBytes, callback.reference)
          .check();

  static final _registerUsageCallback1 = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Int32,
                      ffi.Pointer<ffi.Void>,
                      ffi.Int64,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "NetworkStatsManager__registerUsageCallback1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void registerUsageCallback(int networkType, java.lang.String subscriberId, long thresholdBytes, android.app.usage.NetworkStatsManager.UsageCallback callback, android.os.Handler handler)
  ///
  /// Registers to receive notifications about data usage on specified networks.
  ///
  /// The callbacks will continue to be called as long as the process is live or
  /// \#unregisterUsageCallback is called.
  ///@param networkType Type of network to monitor. Either
  ///             ConnectivityManager\#TYPE_MOBILE or ConnectivityManager\#TYPE_WIFI.
  ///@param subscriberId If applicable, the subscriber id of the network interface.
  ///@param thresholdBytes Threshold in bytes to be notified on.
  ///@param callback The UsageCallback that the system will call when data usage
  ///            has exceeded the specified threshold.
  ///@param handler to dispatch callback events through, otherwise if {@code null} it uses
  ///            the calling thread.
  ///
  /// This value may be {@code null}.
  void registerUsageCallback1(
          int networkType,
          jni.JniString subscriberId,
          int thresholdBytes,
          NetworkStatsManager_UsageCallback callback,
          os_.Handler handler) =>
      _registerUsageCallback1(reference, networkType, subscriberId.reference,
              thresholdBytes, callback.reference, handler.reference)
          .check();

  static final _unregisterUsageCallback = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "NetworkStatsManager__unregisterUsageCallback")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void unregisterUsageCallback(android.app.usage.NetworkStatsManager.UsageCallback callback)
  ///
  /// Unregisters callbacks on data usage.
  ///@param callback The UsageCallback used when registering.
  void unregisterUsageCallback(NetworkStatsManager_UsageCallback callback) =>
      _unregisterUsageCallback(reference, callback.reference).check();
}

/// from: android.app.usage.NetworkStatsManager$UsageCallback
///
/// Base class for usage callbacks. Should be extended by applications wanting notifications.
class NetworkStatsManager_UsageCallback extends jni.JniObject {
  NetworkStatsManager_UsageCallback.fromRef(ffi.Pointer<ffi.Void> ref)
      : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "NetworkStatsManager_UsageCallback__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  NetworkStatsManager_UsageCallback() : super.fromRef(_ctor().object);

  static final _onThresholdReached = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "NetworkStatsManager_UsageCallback__onThresholdReached")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onThresholdReached(int networkType, java.lang.String subscriberId)
  ///
  /// Called when data usage has reached the given threshold.
  void onThresholdReached(int networkType, jni.JniString subscriberId) =>
      _onThresholdReached(reference, networkType, subscriberId.reference)
          .check();
}

/// from: android.app.usage.StorageStats
///
/// Storage statistics for a UID, package, or UserHandle on a single
/// storage volume.
///@see StorageStatsManager
class StorageStats extends jni.JniObject {
  StorageStats.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_StorageStats__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.usage.StorageStats> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "StorageStats__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  ///
  /// {@hide }
  StorageStats() : super.fromRef(_ctor().object);

  static final _getAppBytes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("StorageStats__getAppBytes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getAppBytes()
  ///
  /// Return the size of app. This includes {@code APK} files, optimized
  /// compiler output, and unpacked native libraries.
  ///
  /// If the primary external/shared storage is hosted on this storage device,
  /// then this includes files stored under Context\#getObbDir().
  ///
  /// Code is shared between all users on a multiuser device.
  ///
  /// Value is a non-negative number of bytes.
  ///@return Value is a non-negative number of bytes.
  int getAppBytes() => _getAppBytes(reference).long;

  static final _getDataBytes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("StorageStats__getDataBytes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getDataBytes()
  ///
  /// Return the size of all data. This includes files stored under
  /// Context\#getDataDir(), Context\#getCacheDir(),
  /// Context\#getCodeCacheDir().
  ///
  /// If the primary external/shared storage is hosted on this storage device,
  /// then this includes files stored under
  /// Context\#getExternalFilesDir(String),
  /// Context\#getExternalCacheDir(), and
  /// Context\#getExternalMediaDirs().
  ///
  /// Data is isolated for each user on a multiuser device.
  ///
  /// Value is a non-negative number of bytes.
  ///@return Value is a non-negative number of bytes.
  int getDataBytes() => _getDataBytes(reference).long;

  static final _getCacheBytes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("StorageStats__getCacheBytes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getCacheBytes()
  ///
  /// Return the size of all cached data. This includes files stored under
  /// Context\#getCacheDir() and Context\#getCodeCacheDir().
  ///
  /// If the primary external/shared storage is hosted on this storage device,
  /// then this includes files stored under
  /// Context\#getExternalCacheDir().
  ///
  /// Cached data is isolated for each user on a multiuser device.
  ///
  /// Value is a non-negative number of bytes.
  ///@return Value is a non-negative number of bytes.
  int getCacheBytes() => _getCacheBytes(reference).long;

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("StorageStats__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("StorageStats__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();
}

/// from: android.app.usage.StorageStatsManager
///
/// Access to detailed storage statistics. This provides a summary of how apps,
/// users, and external/shared storage is utilizing disk space.
/// <p class="note">
/// Note: no permissions are required when calling these APIs for your own
/// package or UID. However, requesting details for any other package requires
/// the {@code android.Manifest.permission\#PACKAGE_USAGE_STATS} permission, which
/// is a system-level permission that will not be granted to normal apps.
/// Declaring that permission expresses your intention to use this API and an end
/// user can then choose to grant this permission through the Settings
/// application.
///
///
class StorageStatsManager extends jni.JniObject {
  StorageStatsManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "StorageStatsManager__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  StorageStatsManager() : super.fromRef(_ctor().object);

  static final _getTotalBytes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("StorageStatsManager__getTotalBytes")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public long getTotalBytes(java.util.UUID storageUuid)
  ///
  /// Return the total size of the underlying physical media that is hosting
  /// this storage volume.
  ///
  /// This value is best suited for visual display to end users, since it's
  /// designed to reflect the total storage size advertised in a retail
  /// environment.
  ///
  /// Apps making logical decisions about disk space should always use
  /// File\#getTotalSpace() instead of this value.
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  /// Value is a non-negative number of bytes.
  ///@param storageUuid the UUID of the storage volume you're interested in,
  ///            such as StorageManager\#UUID_DEFAULT.
  /// This value must never be {@code null}.
  ///@throws IOException when the storage device isn't present.
  ///@return Value is a non-negative number of bytes.
  int getTotalBytes(jni.JniObject storageUuid) =>
      _getTotalBytes(reference, storageUuid.reference).long;

  static final _getFreeBytes = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("StorageStatsManager__getFreeBytes")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public long getFreeBytes(java.util.UUID storageUuid)
  ///
  /// Return the free space on the requested storage volume.
  ///
  /// This value is best suited for visual display to end users, since it's
  /// designed to reflect both unused space _and_ and cached space that
  /// could be reclaimed by the system.
  ///
  /// Apps making logical decisions about disk space should always use
  /// StorageManager\#getAllocatableBytes(UUID) instead of this value.
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  /// Value is a non-negative number of bytes.
  ///@param storageUuid the UUID of the storage volume you're interested in,
  ///            such as StorageManager\#UUID_DEFAULT.
  /// This value must never be {@code null}.
  ///@throws IOException when the storage device isn't present.
  ///@return Value is a non-negative number of bytes.
  int getFreeBytes(jni.JniObject storageUuid) =>
      _getFreeBytes(reference, storageUuid.reference).long;

  static final _queryStatsForPackage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "StorageStatsManager__queryStatsForPackage")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.usage.StorageStats queryStatsForPackage(java.util.UUID storageUuid, java.lang.String packageName, android.os.UserHandle user)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return storage statistics for a specific package on the requested storage
  /// volume.
  /// <p class="note">
  /// Note: no permissions are required when calling this API for your own
  /// package. However, requesting details for any other package requires the
  /// {@code android.Manifest.permission\#PACKAGE_USAGE_STATS} permission, which
  /// is a system-level permission that will not be granted to normal apps.
  /// Declaring that permission expresses your intention to use this API and an
  /// end user can then choose to grant this permission through the Settings
  /// application.
  ///
  ///
  /// <p class="note">
  /// Note: if the requested package uses the {@code android:sharedUserId}
  /// manifest feature, this call will be forced into a slower manual
  /// calculation path. If possible, consider always using
  /// \#queryStatsForUid(UUID, int), which is typically faster.
  ///
  ///
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param storageUuid the UUID of the storage volume you're interested in,
  ///            such as StorageManager\#UUID_DEFAULT.
  /// This value must never be {@code null}.
  ///@param packageName the package name you're interested in.
  /// This value must never be {@code null}.
  ///@param user the user you're interested in.
  /// This value must never be {@code null}.
  ///@throws PackageManager.NameNotFoundException when the requested package
  ///             name isn't installed for the requested user.
  ///@throws IOException when the storage device isn't present.
  ///@see ApplicationInfo\#storageUuid
  ///@see PackageInfo\#packageName
  ///@return This value will never be {@code null}.
  StorageStats queryStatsForPackage(jni.JniObject storageUuid,
          jni.JniString packageName, os_.UserHandle user) =>
      StorageStats.fromRef(_queryStatsForPackage(reference,
              storageUuid.reference, packageName.reference, user.reference)
          .object);

  static final _queryStatsForUid = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("StorageStatsManager__queryStatsForUid")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.app.usage.StorageStats queryStatsForUid(java.util.UUID storageUuid, int uid)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return storage statistics for a specific UID on the requested storage
  /// volume.
  /// <p class="note">
  /// Note: no permissions are required when calling this API for your own UID.
  /// However, requesting details for any other UID requires the
  /// {@code android.Manifest.permission\#PACKAGE_USAGE_STATS} permission, which
  /// is a system-level permission that will not be granted to normal apps.
  /// Declaring that permission expresses your intention to use this API and an
  /// end user can then choose to grant this permission through the Settings
  /// application.
  ///
  ///
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param storageUuid the UUID of the storage volume you're interested in,
  ///            such as StorageManager\#UUID_DEFAULT.
  /// This value must never be {@code null}.
  ///@param uid the UID you're interested in.
  ///@throws IOException when the storage device isn't present.
  ///@see ApplicationInfo\#storageUuid
  ///@see ApplicationInfo\#uid
  ///@return This value will never be {@code null}.
  StorageStats queryStatsForUid(jni.JniObject storageUuid, int uid) =>
      StorageStats.fromRef(
          _queryStatsForUid(reference, storageUuid.reference, uid).object);

  static final _queryStatsForUser = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "StorageStatsManager__queryStatsForUser")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.usage.StorageStats queryStatsForUser(java.util.UUID storageUuid, android.os.UserHandle user)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return storage statistics for a specific UserHandle on the
  /// requested storage volume.
  /// <p class="note">
  /// Note: this API requires the
  /// {@code android.Manifest.permission\#PACKAGE_USAGE_STATS} permission, which
  /// is a system-level permission that will not be granted to normal apps.
  /// Declaring that permission expresses your intention to use this API and an
  /// end user can then choose to grant this permission through the Settings
  /// application.
  ///
  ///
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param storageUuid the UUID of the storage volume you're interested in,
  ///            such as StorageManager\#UUID_DEFAULT.
  /// This value must never be {@code null}.
  ///@param user the user you're interested in.
  /// This value must never be {@code null}.
  ///@throws IOException when the storage device isn't present.
  ///@see android.os.Process\#myUserHandle()
  ///@return This value will never be {@code null}.
  StorageStats queryStatsForUser(
          jni.JniObject storageUuid, os_.UserHandle user) =>
      StorageStats.fromRef(
          _queryStatsForUser(reference, storageUuid.reference, user.reference)
              .object);

  static final _queryExternalStatsForUser = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "StorageStatsManager__queryExternalStatsForUser")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.app.usage.ExternalStorageStats queryExternalStatsForUser(java.util.UUID storageUuid, android.os.UserHandle user)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return shared/external storage statistics for a specific
  /// UserHandle on the requested storage volume.
  /// <p class="note">
  /// Note: this API requires the
  /// {@code android.Manifest.permission\#PACKAGE_USAGE_STATS} permission, which
  /// is a system-level permission that will not be granted to normal apps.
  /// Declaring that permission expresses your intention to use this API and an
  /// end user can then choose to grant this permission through the Settings
  /// application.
  ///
  ///
  ///
  /// This method may take several seconds to complete, so it should
  ///  *            only be called from a worker thread.
  ///@param storageUuid the UUID of the storage volume you're interested in,
  ///            such as StorageManager\#UUID_DEFAULT.
  /// This value must never be {@code null}.
  ///@throws IOException when the storage device isn't present.
  ///@see android.os.Process\#myUserHandle()
  ///@param user This value must never be {@code null}.
  ///@return This value will never be {@code null}.
  ExternalStorageStats queryExternalStatsForUser(
          jni.JniObject storageUuid, os_.UserHandle user) =>
      ExternalStorageStats.fromRef(_queryExternalStatsForUser(
              reference, storageUuid.reference, user.reference)
          .object);
}

/// from: android.app.usage.UsageEvents
///
/// A result returned from android.app.usage.UsageStatsManager\#queryEvents(long, long)
/// from which to read android.app.usage.UsageEvents.Event objects.
class UsageEvents extends jni.JniObject {
  UsageEvents.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_UsageEvents__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.usage.UsageEvents> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "UsageEvents__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  ///
  /// Create an empty iterator.
  /// {@hide }
  UsageEvents() : super.fromRef(_ctor().object);

  static final _hasNextEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("UsageEvents__hasNextEvent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasNextEvent()
  ///
  /// Returns whether or not there are more events to read using
  /// \#getNextEvent(android.app.usage.UsageEvents.Event).
  ///@return true if there are more events, false otherwise.
  bool hasNextEvent() => _hasNextEvent(reference).boolean;

  static final _getNextEvent = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("UsageEvents__getNextEvent")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean getNextEvent(android.app.usage.UsageEvents.Event eventOut)
  ///
  /// Retrieve the next android.app.usage.UsageEvents.Event from the collection and put the
  /// resulting data into {@code eventOut}.
  ///@param eventOut The android.app.usage.UsageEvents.Event object that will receive the
  ///                 next event data.
  ///@return true if an event was available, false if there are no more events.
  bool getNextEvent(UsageEvents_Event eventOut) =>
      _getNextEvent(reference, eventOut.reference).boolean;

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("UsageEvents__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("UsageEvents__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();
}

/// from: android.app.usage.UsageEvents$Event
///
/// An event representing a state change for a component.
class UsageEvents_Event extends jni.JniObject {
  UsageEvents_Event.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int CONFIGURATION_CHANGE
  ///
  /// An event type denoting that the device configuration has changed.
  static const CONFIGURATION_CHANGE = 5;

  /// from: static public final int KEYGUARD_HIDDEN
  ///
  /// An event type denoting that the screen's keyguard has been hidden.  This typically
  /// happens when the user unlocks their phone after turning it on.
  static const KEYGUARD_HIDDEN = 18;

  /// from: static public final int KEYGUARD_SHOWN
  ///
  /// An event type denoting that the screen's keyguard has been shown, whether or not
  /// the screen is off.
  static const KEYGUARD_SHOWN = 17;

  /// from: static public final int MOVE_TO_BACKGROUND
  ///
  /// An event type denoting that a component moved to the background.
  static const MOVE_TO_BACKGROUND = 2;

  /// from: static public final int MOVE_TO_FOREGROUND
  ///
  /// An event type denoting that a component moved to the foreground.
  static const MOVE_TO_FOREGROUND = 1;

  /// from: static public final int NONE
  ///
  /// No event type.
  static const NONE = 0;

  /// from: static public final int SCREEN_INTERACTIVE
  ///
  /// An event type denoting that the screen has gone in to an interactive state (turned
  /// on for full user interaction, not ambient display or other non-interactive state).
  static const SCREEN_INTERACTIVE = 15;

  /// from: static public final int SCREEN_NON_INTERACTIVE
  ///
  /// An event type denoting that the screen has gone in to a non-interactive state
  /// (completely turned off or turned on only in a non-interactive state like ambient
  /// display).
  static const SCREEN_NON_INTERACTIVE = 16;

  /// from: static public final int SHORTCUT_INVOCATION
  ///
  /// An event type denoting that an action equivalent to a ShortcutInfo is taken by the user.
  ///@see android.content.pm.ShortcutManager\#reportShortcutUsed(String)
  static const SHORTCUT_INVOCATION = 8;

  /// from: static public final int STANDBY_BUCKET_CHANGED
  ///
  /// An event type denoting a change in App Standby Bucket. The new bucket can be
  /// retrieved by calling \#getAppStandbyBucket().
  ///@see UsageStatsManager\#getAppStandbyBucket()
  static const STANDBY_BUCKET_CHANGED = 11;

  /// from: static public final int USER_INTERACTION
  ///
  /// An event type denoting that a package was interacted with in some way by the user.
  static const USER_INTERACTION = 7;

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "UsageEvents_Event__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  UsageEvents_Event() : super.fromRef(_ctor().object);

  static final _getPackageName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("UsageEvents_Event__getPackageName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPackageName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The package name of the source of this event.
  jni.JniString getPackageName() =>
      jni.JniString.fromRef(_getPackageName(reference).object);

  static final _getClassName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("UsageEvents_Event__getClassName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getClassName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// The class name of the source of this event. This may be null for
  /// certain events.
  jni.JniString getClassName() =>
      jni.JniString.fromRef(_getClassName(reference).object);

  static final _getTimeStamp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("UsageEvents_Event__getTimeStamp")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTimeStamp()
  ///
  /// The time at which this event occurred, measured in milliseconds since the epoch.
  /// <p/>
  /// See System\#currentTimeMillis().
  int getTimeStamp() => _getTimeStamp(reference).long;

  static final _getEventType = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("UsageEvents_Event__getEventType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getEventType()
  ///
  /// The event type.
  ///@see \#MOVE_TO_BACKGROUND
  ///@see \#MOVE_TO_FOREGROUND
  ///@see \#CONFIGURATION_CHANGE
  ///@see \#USER_INTERACTION
  ///@see \#STANDBY_BUCKET_CHANGED
  int getEventType() => _getEventType(reference).integer;

  static final _getConfiguration = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "UsageEvents_Event__getConfiguration")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.content.res.Configuration getConfiguration()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns a Configuration for this event if the event is of type
  /// \#CONFIGURATION_CHANGE, otherwise it returns null.
  res_.Configuration getConfiguration() =>
      res_.Configuration.fromRef(_getConfiguration(reference).object);

  static final _getShortcutId = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("UsageEvents_Event__getShortcutId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getShortcutId()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the ID of a android.content.pm.ShortcutInfo for this event
  /// if the event is of type \#SHORTCUT_INVOCATION, otherwise it returns null.
  ///@see android.content.pm.ShortcutManager\#reportShortcutUsed(String)
  jni.JniString getShortcutId() =>
      jni.JniString.fromRef(_getShortcutId(reference).object);

  static final _getAppStandbyBucket = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "UsageEvents_Event__getAppStandbyBucket")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getAppStandbyBucket()
  ///
  /// Returns the standby bucket of the app, if the event is of type
  /// \#STANDBY_BUCKET_CHANGED, otherwise returns 0.
  ///@return the standby bucket associated with the event.
  int getAppStandbyBucket() => _getAppStandbyBucket(reference).integer;
}

/// from: android.app.usage.UsageStats
///
/// Contains usage statistics for an app package for a specific
/// time range.
class UsageStats extends jni.JniObject {
  UsageStats.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_UsageStats__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable.Creator<android.app.usage.UsageStats> CREATOR
  /// The returned object must be deleted after use, by calling the `delete` method.
  static os_.Parcelable_Creator get CREATOR =>
      os_.Parcelable_Creator.fromRef(_get_CREATOR().object);

  static final _ctor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("UsageStats__ctor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.app.usage.UsageStats stats)
  UsageStats(UsageStats stats) : super.fromRef(_ctor(stats.reference).object);

  static final _getPackageName = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("UsageStats__getPackageName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPackageName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JniString getPackageName() =>
      jni.JniString.fromRef(_getPackageName(reference).object);

  static final _getFirstTimeStamp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("UsageStats__getFirstTimeStamp")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getFirstTimeStamp()
  ///
  /// Get the beginning of the time range this android.app.usage.UsageStats represents,
  /// measured in milliseconds since the epoch.
  /// <p/>
  /// See System\#currentTimeMillis().
  int getFirstTimeStamp() => _getFirstTimeStamp(reference).long;

  static final _getLastTimeStamp = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("UsageStats__getLastTimeStamp")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getLastTimeStamp()
  ///
  /// Get the end of the time range this android.app.usage.UsageStats represents,
  /// measured in milliseconds since the epoch.
  /// <p/>
  /// See System\#currentTimeMillis().
  int getLastTimeStamp() => _getLastTimeStamp(reference).long;

  static final _getLastTimeUsed = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("UsageStats__getLastTimeUsed")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getLastTimeUsed()
  ///
  /// Get the last time this package was used, measured in milliseconds since the epoch.
  /// <p/>
  /// See System\#currentTimeMillis().
  int getLastTimeUsed() => _getLastTimeUsed(reference).long;

  static final _getTotalTimeInForeground = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "UsageStats__getTotalTimeInForeground")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getTotalTimeInForeground()
  ///
  /// Get the total time this package spent in the foreground, measured in milliseconds.
  int getTotalTimeInForeground() => _getTotalTimeInForeground(reference).long;

  static final _add = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("UsageStats__add")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void add(android.app.usage.UsageStats right)
  ///
  /// Add the statistics from the right UsageStats to the left. The package name for
  /// both UsageStats objects must be the same.
  ///@param right The UsageStats object to merge into this one.
  ///@throws java.lang.IllegalArgumentException if the package names of the two
  ///         UsageStats objects are different.
  void add(UsageStats right) => _add(reference, right.reference).check();

  static final _describeContents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>)>>("UsageStats__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() => _describeContents(reference).integer;

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("UsageStats__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel dest, int flags)
  void writeToParcel(os_.Parcel dest, int flags) =>
      _writeToParcel(reference, dest.reference, flags).check();
}

/// from: android.app.usage.UsageStatsManager
///
/// Provides access to device usage history and statistics. Usage data is aggregated into
/// time intervals: days, weeks, months, and years.
/// <p/>
/// When requesting usage data since a particular time, the request might look something like this:
/// <pre>
/// PAST                   REQUEST_TIME                    TODAY                   FUTURE
/// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014||\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014-----------------------|
///                        YEAR ||                                                  |
/// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014||\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014-----------------------|
///  MONTH            |         ||                MONTH                             |
/// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014|\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014||\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014-----------------------|
///   |      WEEK     |     WEEK||    |     WEEK     |     WEEK     |      WEEK     |
/// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014||\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014|\u2014\u2014\u2014\u2014\u2014\u2014\u2014-----------------------|
///                             ||           |DAY|DAY|DAY|DAYDAY|DAY|DAY|DAY|DAY|DAY|
/// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014||\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014-----------------------|
/// </pre>
/// A request for data in the middle of a time interval will include that interval.
/// <p/>
/// __NOTE:__ Most methods on this API require the permission
/// android.permission.PACKAGE_USAGE_STATS. However, declaring the permission implies intention to
/// use the API and the user of the device still needs to grant permission through the Settings
/// application.
/// See android.provider.Settings\#ACTION_USAGE_ACCESS_SETTINGS.
/// Methods which only return the information for the calling package do not require this permission.
/// E.g. \#getAppStandbyBucket() and \#queryEventsForSelf(long, long).
class UsageStatsManager extends jni.JniObject {
  UsageStatsManager.fromRef(ffi.Pointer<ffi.Void> ref) : super.fromRef(ref);

  /// from: static public final int INTERVAL_BEST
  ///
  /// An interval type that will use the best fit interval for the given time range.
  /// See \#queryUsageStats(int, long, long).
  static const INTERVAL_BEST = 4;

  /// from: static public final int INTERVAL_DAILY
  ///
  /// An interval type that spans a day. See \#queryUsageStats(int, long, long).
  static const INTERVAL_DAILY = 0;

  /// from: static public final int INTERVAL_MONTHLY
  ///
  /// An interval type that spans a month. See \#queryUsageStats(int, long, long).
  static const INTERVAL_MONTHLY = 2;

  /// from: static public final int INTERVAL_WEEKLY
  ///
  /// An interval type that spans a week. See \#queryUsageStats(int, long, long).
  static const INTERVAL_WEEKLY = 1;

  /// from: static public final int INTERVAL_YEARLY
  ///
  /// An interval type that spans a year. See \#queryUsageStats(int, long, long).
  static const INTERVAL_YEARLY = 3;

  /// from: static public final int STANDBY_BUCKET_ACTIVE
  ///
  /// The app was used very recently, currently in use or likely to be used very soon. Standby
  /// bucket values that are &le; \#STANDBY_BUCKET_ACTIVE will not be throttled by the
  /// system while they are in this bucket. Buckets &gt; \#STANDBY_BUCKET_ACTIVE will most
  /// likely be restricted in some way. For instance, jobs and alarms may be deferred.
  ///@see \#getAppStandbyBucket()
  static const STANDBY_BUCKET_ACTIVE = 10;

  /// from: static public final int STANDBY_BUCKET_FREQUENT
  ///
  /// The app was used in the last few days and/or likely to be used in the next few days.
  /// Restrictions will apply to these apps, such as deferral of jobs and alarms. The delays may be
  /// greater than for apps in higher buckets (lower bucket value). Bucket values &gt;
  /// \#STANDBY_BUCKET_FREQUENT may additionally have network access limited.
  ///@see \#getAppStandbyBucket()
  static const STANDBY_BUCKET_FREQUENT = 30;

  /// from: static public final int STANDBY_BUCKET_RARE
  ///
  /// The app has not be used for several days and/or is unlikely to be used for several days.
  /// Apps in this bucket will have the most restrictions, including network restrictions, except
  /// during certain short periods (at a minimum, once a day) when they are allowed to execute
  /// jobs, access the network, etc.
  ///@see \#getAppStandbyBucket()
  static const STANDBY_BUCKET_RARE = 40;

  /// from: static public final int STANDBY_BUCKET_WORKING_SET
  ///
  /// The app was used recently and/or likely to be used in the next few hours. Restrictions will
  /// apply to these apps, such as deferral of jobs and alarms.
  ///@see \#getAppStandbyBucket()
  static const STANDBY_BUCKET_WORKING_SET = 20;

  static final _ctor = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "UsageStatsManager__ctor")
      .asFunction<jni.JniResult Function()>();

  /// from: void <init>()
  UsageStatsManager() : super.fromRef(_ctor().object);

  static final _queryUsageStats = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int64, ffi.Int64)>>("UsageStatsManager__queryUsageStats")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public java.util.List<android.app.usage.UsageStats> queryUsageStats(int intervalType, long beginTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets application usage stats for the given time range, aggregated by the specified interval.
  /// The returned list will contain a UsageStats object for each package that
  /// has data for an interval that is a subset of the time range given. To illustrate:
  ///
  /// <pre>
  /// intervalType = INTERVAL_YEARLY
  /// beginTime = 2013
  /// endTime = 2015 (exclusive)
  ///
  /// Results:
  /// 2013 - com.example.alpha
  /// 2013 - com.example.beta
  /// 2014 - com.example.alpha
  /// 2014 - com.example.beta
  /// 2014 - com.example.charlie
  /// </pre>
  ///
  ///  The caller must have android.Manifest.permission\#PACKAGE_USAGE_STATS
  ///
  ///@param intervalType The time interval by which the stats are aggregated.
  ///@param beginTime The inclusive beginning of the range of stats to include in the results.
  ///@param endTime The exclusive end of the range of stats to include in the results.
  ///@return A list of UsageStats
  ///@see \#INTERVAL_DAILY
  ///@see \#INTERVAL_WEEKLY
  ///@see \#INTERVAL_MONTHLY
  ///@see \#INTERVAL_YEARLY
  ///@see \#INTERVAL_BEST
  jni.JniObject queryUsageStats(int intervalType, int beginTime, int endTime) =>
      jni.JniObject.fromRef(
          _queryUsageStats(reference, intervalType, beginTime, endTime).object);

  static final _queryConfigurations = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int64,
                  ffi.Int64)>>("UsageStatsManager__queryConfigurations")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public java.util.List<android.app.usage.ConfigurationStats> queryConfigurations(int intervalType, long beginTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets the hardware configurations the device was in for the given time range, aggregated by
  /// the specified interval. The results are ordered as in
  /// \#queryUsageStats(int, long, long).
  ///  The caller must have android.Manifest.permission\#PACKAGE_USAGE_STATS
  ///
  ///@param intervalType The time interval by which the stats are aggregated.
  ///@param beginTime The inclusive beginning of the range of stats to include in the results.
  ///@param endTime The exclusive end of the range of stats to include in the results.
  ///@return A list of ConfigurationStats
  jni.JniObject queryConfigurations(
          int intervalType, int beginTime, int endTime) =>
      jni.JniObject.fromRef(
          _queryConfigurations(reference, intervalType, beginTime, endTime)
              .object);

  static final _queryEventStats = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int64, ffi.Int64)>>("UsageStatsManager__queryEventStats")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public java.util.List<android.app.usage.EventStats> queryEventStats(int intervalType, long beginTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Gets aggregated event stats for the given time range, aggregated by the specified interval.
  /// The returned list will contain a EventStats object for each event type that
  /// is being aggregated and has data for an interval that is a subset of the time range given.
  ///
  /// The current event types that will be aggregated here are:
  ///
  /// <ul>
  ///     <li>UsageEvents.Event\#SCREEN_INTERACTIVE</li>
  ///     <li>UsageEvents.Event\#SCREEN_NON_INTERACTIVE</li>
  ///     <li>UsageEvents.Event\#KEYGUARD_SHOWN</li>
  ///     <li>UsageEvents.Event\#KEYGUARD_HIDDEN</li>
  /// </ul>
  ///
  ///  The caller must have android.Manifest.permission\#PACKAGE_USAGE_STATS
  ///
  ///@param intervalType The time interval by which the stats are aggregated.
  ///@param beginTime The inclusive beginning of the range of stats to include in the results.
  ///@param endTime The exclusive end of the range of stats to include in the results.
  ///@return A list of EventStats
  ///@see \#INTERVAL_DAILY
  ///@see \#INTERVAL_WEEKLY
  ///@see \#INTERVAL_MONTHLY
  ///@see \#INTERVAL_YEARLY
  ///@see \#INTERVAL_BEST
  jni.JniObject queryEventStats(int intervalType, int beginTime, int endTime) =>
      jni.JniObject.fromRef(
          _queryEventStats(reference, intervalType, beginTime, endTime).object);

  static final _queryEvents = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Int64)>>("UsageStatsManager__queryEvents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.app.usage.UsageEvents queryEvents(long beginTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Query for events in the given time range. Events are only kept by the system for a few
  /// days.
  ///  The caller must have android.Manifest.permission\#PACKAGE_USAGE_STATS
  ///
  ///@param beginTime The inclusive beginning of the range of events to include in the results.
  ///@param endTime The exclusive end of the range of events to include in the results.
  ///@return A UsageEvents.
  UsageEvents queryEvents(int beginTime, int endTime) =>
      UsageEvents.fromRef(_queryEvents(reference, beginTime, endTime).object);

  static final _queryEventsForSelf = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Int64)>>("UsageStatsManager__queryEventsForSelf")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.app.usage.UsageEvents queryEventsForSelf(long beginTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Like \#queryEvents(long, long), but only returns events for the calling package.
  ///@param beginTime The inclusive beginning of the range of events to include in the results.
  ///@param endTime The exclusive end of the range of events to include in the results.
  ///@return A UsageEvents object.
  ///@see \#queryEvents(long, long)
  UsageEvents queryEventsForSelf(int beginTime, int endTime) =>
      UsageEvents.fromRef(
          _queryEventsForSelf(reference, beginTime, endTime).object);

  static final _queryAndAggregateUsageStats = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Int64)>>("UsageStatsManager__queryAndAggregateUsageStats")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public java.util.Map<java.lang.String,android.app.usage.UsageStats> queryAndAggregateUsageStats(long beginTime, long endTime)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// A convenience method that queries for all stats in the given range (using the best interval
  /// for that range), merges the resulting data, and keys it by package name.
  /// See \#queryUsageStats(int, long, long).
  ///  The caller must have android.Manifest.permission\#PACKAGE_USAGE_STATS
  ///
  ///@param beginTime The inclusive beginning of the range of stats to include in the results.
  ///@param endTime The exclusive end of the range of stats to include in the results.
  ///@return A java.util.Map keyed by package name
  jni.JniObject queryAndAggregateUsageStats(int beginTime, int endTime) =>
      jni.JniObject.fromRef(
          _queryAndAggregateUsageStats(reference, beginTime, endTime).object);

  static final _isAppInactive = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("UsageStatsManager__isAppInactive")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isAppInactive(java.lang.String packageName)
  ///
  /// Returns whether the specified app is currently considered inactive. This will be true if the
  /// app hasn't been used directly or indirectly for a period of time defined by the system. This
  /// could be of the order of several hours or days.
  ///@param packageName The package name of the app to query
  ///@return whether the app is currently considered inactive
  bool isAppInactive(jni.JniString packageName) =>
      _isAppInactive(reference, packageName.reference).boolean;

  static final _getAppStandbyBucket = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "UsageStatsManager__getAppStandbyBucket")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getAppStandbyBucket()
  ///
  /// Returns the current standby bucket of the calling app. The system determines the standby
  /// state of the app based on app usage patterns. Standby buckets determine how much an app will
  /// be restricted from running background tasks such as jobs and alarms.
  /// Restrictions increase progressively from \#STANDBY_BUCKET_ACTIVE to
  /// \#STANDBY_BUCKET_RARE, with \#STANDBY_BUCKET_ACTIVE being the least
  /// restrictive. The battery level of the device might also affect the restrictions.
  /// Apps in buckets &le; \#STANDBY_BUCKET_ACTIVE have no standby restrictions imposed.
  /// Apps in buckets &gt; \#STANDBY_BUCKET_FREQUENT may have network access restricted when
  /// running in the background.
  /// The standby state of an app can change at any time either due to a user interaction or a
  /// system interaction or some algorithm determining that the app can be restricted for a period
  /// of time before the user has a need for it.
  /// You can also query the recent history of standby bucket changes by calling
  /// \#queryEventsForSelf(long, long) and searching for
  /// UsageEvents.Event\#STANDBY_BUCKET_CHANGED.
  ///@return the current standby bucket of the calling app. One of STANDBY_BUCKET_* constants.
  ///
  /// Value is android.app.usage.UsageStatsManager.STANDBY_BUCKET_EXEMPTED, android.app.usage.UsageStatsManager\#STANDBY_BUCKET_ACTIVE, android.app.usage.UsageStatsManager\#STANDBY_BUCKET_WORKING_SET, android.app.usage.UsageStatsManager\#STANDBY_BUCKET_FREQUENT, android.app.usage.UsageStatsManager\#STANDBY_BUCKET_RARE, or android.app.usage.UsageStatsManager.STANDBY_BUCKET_NEVER
  int getAppStandbyBucket() => _getAppStandbyBucket(reference).integer;
}
